StubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder_get_Name_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varName);


void __RPC_STUB Folder_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder_get_Messages_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varMessages);


void __RPC_STUB Folder_get_Messages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Folder_INTERFACE_DEFINED__ */


#ifndef __Messages_INTERFACE_DEFINED__
#define __Messages_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Messages
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Messages;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064A02-9D99-11D0-ABE5-00AA0064D470")
    Messages : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *varCount) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT __RPC_FAR *var,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [helpstring][propget][hidden][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT Subject,
            /* [optional][in] */ VARIANT Text,
            /* [optional][in] */ VARIANT Importance,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFirst( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNext( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLast( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPrevious( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct MessagesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Messages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Messages __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Messages __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Messages __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Messages __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Messages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Messages __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varCount);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Messages __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *var,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [helpstring][propget][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            Messages __RPC_FAR * This,
            /* [optional][in] */ VARIANT Subject,
            /* [optional][in] */ VARIANT Text,
            /* [optional][in] */ VARIANT Importance,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            Messages __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirst )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLast )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPrevious )( 
            Messages __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        END_INTERFACE
    } MessagesVtbl;

    interface Messages
    {
        CONST_VTBL struct MessagesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Messages_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Messages_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Messages_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Messages_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Messages_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Messages_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Messages_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Messages_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define Messages_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define Messages_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define Messages_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define Messages_get_Count(This,varCount)	\
    (This)->lpVtbl -> get_Count(This,varCount)

#define Messages_get_Item(This,var,pvarResult)	\
    (This)->lpVtbl -> get_Item(This,var,pvarResult)

#define Messages_get__NewEnum(This,ppunkResult)	\
    (This)->lpVtbl -> get__NewEnum(This,ppunkResult)

#define Messages_Add(This,Subject,Text,Importance,pvarResult)	\
    (This)->lpVtbl -> Add(This,Subject,Text,Importance,pvarResult)

#define Messages_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define Messages_GetFirst(This,pvarResult)	\
    (This)->lpVtbl -> GetFirst(This,pvarResult)

#define Messages_GetNext(This,pvarResult)	\
    (This)->lpVtbl -> GetNext(This,pvarResult)

#define Messages_GetLast(This,pvarResult)	\
    (This)->lpVtbl -> GetLast(This,pvarResult)

#define Messages_GetPrevious(This,pvarResult)	\
    (This)->lpVtbl -> GetPrevious(This,pvarResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Messages_get_Application_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB Messages_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Messages_get_Parent_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB Messages_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Messages_get_Session_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB Messages_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Messages_get_Class_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB Messages_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Messages_get_Count_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varCount);


void __RPC_STUB Messages_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Messages_get_Item_Proxy( 
    Messages __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *var,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Messages_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][hidden][id] */ HRESULT STDMETHODCALLTYPE Messages_get__NewEnum_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);


void __RPC_STUB Messages_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Messages_Add_Proxy( 
    Messages __RPC_FAR * This,
    /* [optional][in] */ VARIANT Subject,
    /* [optional][in] */ VARIANT Text,
    /* [optional][in] */ VARIANT Importance,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Messages_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Messages_Delete_Proxy( 
    Messages __RPC_FAR * This);


void __RPC_STUB Messages_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Messages_GetFirst_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Messages_GetFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Messages_GetNext_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Messages_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Messages_GetLast_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Messages_GetLast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Messages_GetPrevious_Proxy( 
    Messages __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Messages_GetPrevious_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Messages_INTERFACE_DEFINED__ */


#ifndef __Message_INTERFACE_DEFINED__
#define __Message_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Message
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Message;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064A03-9D99-11D0-ABE5-00AA0064D470")
    Message : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long __RPC_FAR *varSize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Importance( 
            /* [retval][out] */ long __RPC_FAR *pImportance) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Importance( 
            /* [in] */ long varImportance) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR __RPC_FAR *pSubject) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Subject( 
            /* [in] */ BSTR varSubject) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Sender( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSender) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TimeSent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varTimeSent) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TimeSent( 
            /* [in] */ VARIANT varTimeSent) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TimeReceived( 
            /* [retval][out] */ VARIANT __RPC_FAR *varTimeReceived) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TimeReceived( 
            /* [in] */ VARIANT varTimeReceived) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ VARIANT __RPC_FAR *varText) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HTMLText( 
            /* [retval][out] */ VARIANT __RPC_FAR *varHTMLText) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HTMLText( 
            /* [in] */ VARIANT varHTMLText) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Recipients( 
            /* [retval][out] */ VARIANT __RPC_FAR *varRecipients) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Recipients( 
            /* [in] */ VARIANT varRecipients) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Attachments( 
            /* [retval][out] */ VARIANT __RPC_FAR *varAttachments) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MessageFormat( 
            /* [in] */ long __MIDL_0015) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentLocation( 
            /* [retval][out] */ VARIANT __RPC_FAR *varContentLocation) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentLocation( 
            /* [in] */ VARIANT varContentLocation) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentBase( 
            /* [retval][out] */ VARIANT __RPC_FAR *varContentBase) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentBase( 
            /* [in] */ VARIANT varContentBase) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentID( 
            /* [retval][out] */ VARIANT __RPC_FAR *varContentID) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ContentID( 
            /* [in] */ VARIANT varContentID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Send( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct MessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Message __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Message __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Message __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Message __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Message __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Message __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Message __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varSize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Importance )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pImportance);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Importance )( 
            Message __RPC_FAR * This,
            /* [in] */ long varImportance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Subject )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pSubject);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Subject )( 
            Message __RPC_FAR * This,
            /* [in] */ BSTR varSubject);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Sender )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSender);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TimeSent )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varTimeSent);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TimeSent )( 
            Message __RPC_FAR * This,
            /* [in] */ VARIANT varTimeSent);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TimeReceived )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varTimeReceived);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TimeReceived )( 
            Message __RPC_FAR * This,
            /* [in] */ VARIANT varTimeReceived);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Text )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varText);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Text )( 
            Message __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HTMLText )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varHTMLText);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HTMLText )( 
            Message __RPC_FAR * This,
            /* [in] */ VARIANT varHTMLText);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Recipients )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varRecipients);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Recipients )( 
            Message __RPC_FAR * This,
            /* [in] */ VARIANT varRecipients);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attachments )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varAttachments);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessageFormat )( 
            Message __RPC_FAR * This,
            /* [in] */ long __MIDL_0015);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentLocation )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varContentLocation);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentLocation )( 
            Message __RPC_FAR * This,
            /* [in] */ VARIANT varContentLocation);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentBase )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varContentBase);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentBase )( 
            Message __RPC_FAR * This,
            /* [in] */ VARIANT varContentBase);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentID )( 
            Message __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varContentID);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentID )( 
            Message __RPC_FAR * This,
            /* [in] */ VARIANT varContentID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            Message __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Send )( 
            Message __RPC_FAR * This);
        
        END_INTERFACE
    } MessageVtbl;

    interface Message
    {
        CONST_VTBL struct MessageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Message_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Message_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Message_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Message_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Message_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Message_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Message_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Message_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define Message_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define Message_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define Message_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define Message_get_Size(This,varSize)	\
    (This)->lpVtbl -> get_Size(This,varSize)

#define Message_get_Importance(This,pImportance)	\
    (This)->lpVtbl -> get_Importance(This,pImportance)

#define Message_put_Importance(This,varImportance)	\
    (This)->lpVtbl -> put_Importance(This,varImportance)

#define Message_get_Subject(This,pSubject)	\
    (This)->lpVtbl -> get_Subject(This,pSubject)

#define Message_put_Subject(This,varSubject)	\
    (This)->lpVtbl -> put_Subject(This,varSubject)

#define Message_get_Sender(This,varSender)	\
    (This)->lpVtbl -> get_Sender(This,varSender)

#define Message_get_TimeSent(This,varTimeSent)	\
    (This)->lpVtbl -> get_TimeSent(This,varTimeSent)

#define Message_put_TimeSent(This,varTimeSent)	\
    (This)->lpVtbl -> put_TimeSent(This,varTimeSent)

#define Message_get_TimeReceived(This,varTimeReceived)	\
    (This)->lpVtbl -> get_TimeReceived(This,varTimeReceived)

#define Message_put_TimeReceived(This,varTimeReceived)	\
    (This)->lpVtbl -> put_TimeReceived(This,varTimeReceived)

#define Message_get_Text(This,varText)	\
    (This)->lpVtbl -> get_Text(This,varText)

#define Message_put_Text(This,varText)	\
    (This)->lpVtbl -> put_Text(This,varText)

#define Message_get_HTMLText(This,varHTMLText)	\
    (This)->lpVtbl -> get_HTMLText(This,varHTMLText)

#define Message_put_HTMLText(This,varHTMLText)	\
    (This)->lpVtbl -> put_HTMLText(This,varHTMLText)

#define Message_get_Recipients(This,varRecipients)	\
    (This)->lpVtbl -> get_Recipients(This,varRecipients)

#define Message_put_Recipients(This,varRecipients)	\
    (This)->lpVtbl -> put_Recipients(This,varRecipients)

#define Message_get_Attachments(This,varAttachments)	\
    (This)->lpVtbl -> get_Attachments(This,varAttachments)

#define Message_put_MessageFormat(This,__MIDL_0015)	\
    (This)->lpVtbl -> put_MessageFormat(This,__MIDL_0015)

#define Message_get_ContentLocation(This,varContentLocation)	\
    (This)->lpVtbl -> get_ContentLocation(This,varContentLocation)

#define Message_put_ContentLocation(This,varContentLocation)	\
    (This)->lpVtbl -> put_ContentLocation(This,varContentLocation)

#define Message_get_ContentBase(This,varContentBase)	\
    (This)->lpVtbl -> get_ContentBase(This,varContentBase)

#define Message_put_ContentBase(This,varContentBase)	\
    (This)->lpVtbl -> put_ContentBase(This,varContentBase)

#define Message_get_ContentID(This,varContentID)	\
    (This)->lpVtbl -> get_ContentID(This,varContentID)

#define Message_put_ContentID(This,varContentID)	\
    (This)->lpVtbl -> put_ContentID(This,varContentID)

#define Message_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define Message_Send(This)	\
    (This)->lpVtbl -> Send(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Application_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB Message_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Parent_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB Message_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Session_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB Message_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Class_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB Message_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Size_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varSize);


void __RPC_STUB Message_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Importance_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pImportance);


void __RPC_STUB Message_get_Importance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_Importance_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ long varImportance);


void __RPC_STUB Message_put_Importance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Subject_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pSubject);


void __RPC_STUB Message_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_Subject_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ BSTR varSubject);


void __RPC_STUB Message_put_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Sender_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSender);


void __RPC_STUB Message_get_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_TimeSent_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varTimeSent);


void __RPC_STUB Message_get_TimeSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_TimeSent_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ VARIANT varTimeSent);


void __RPC_STUB Message_put_TimeSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_TimeReceived_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varTimeReceived);


void __RPC_STUB Message_get_TimeReceived_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_TimeReceived_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ VARIANT varTimeReceived);


void __RPC_STUB Message_put_TimeReceived_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Text_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varText);


void __RPC_STUB Message_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_Text_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB Message_put_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_HTMLText_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varHTMLText);


void __RPC_STUB Message_get_HTMLText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_HTMLText_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ VARIANT varHTMLText);


void __RPC_STUB Message_put_HTMLText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Recipients_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varRecipients);


void __RPC_STUB Message_get_Recipients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_Recipients_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ VARIANT varRecipients);


void __RPC_STUB Message_put_Recipients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_Attachments_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varAttachments);


void __RPC_STUB Message_get_Attachments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Message_put_MessageFormat_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ long __MIDL_0015);


void __RPC_STUB Message_put_MessageFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_ContentLocation_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varContentLocation);


void __RPC_STUB Message_get_ContentLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_ContentLocation_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ VARIANT varContentLocation);


void __RPC_STUB Message_put_ContentLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_ContentBase_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varContentBase);


void __RPC_STUB Message_get_ContentBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_ContentBase_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ VARIANT varContentBase);


void __RPC_STUB Message_put_ContentBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Message_get_ContentID_Proxy( 
    Message __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varContentID);


void __RPC_STUB Message_get_ContentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Message_put_ContentID_Proxy( 
    Message __RPC_FAR * This,
    /* [in] */ VARIANT varContentID);


void __RPC_STUB Message_put_ContentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Message_Delete_Proxy( 
    Message __RPC_FAR * This);


void __RPC_STUB Message_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Message_Send_Proxy( 
    Message __RPC_FAR * This);


void __RPC_STUB Message_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Message_INTERFACE_DEFINED__ */


#ifndef __Recipients_INTERFACE_DEFINED__
#define __Recipients_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Recipients
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Recipients;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064A04-9D99-11D0-ABE5-00AA0064D470")
    Recipients : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT __RPC_FAR *var,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *varCount) = 0;
        
        virtual /* [helpstring][propget][hidden][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT Name,
            /* [optional][in] */ VARIANT Address,
            /* [optional][in] */ VARIANT Type,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct RecipientsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Recipients __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Recipients __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Recipients __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Recipients __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Recipients __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Recipients __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Recipients __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Recipients __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Recipients __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            Recipients __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            Recipients __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Recipients __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *var,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Recipients __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varCount);
        
        /* [helpstring][propget][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            Recipients __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            Recipients __RPC_FAR * This,
            /* [optional][in] */ VARIANT Name,
            /* [optional][in] */ VARIANT Address,
            /* [optional][in] */ VARIANT Type,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            Recipients __RPC_FAR * This);
        
        END_INTERFACE
    } RecipientsVtbl;

    interface Recipients
    {
        CONST_VTBL struct RecipientsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Recipients_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Recipients_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Recipients_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Recipients_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Recipients_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Recipients_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Recipients_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Recipients_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define Recipients_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define Recipients_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define Recipients_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define Recipients_get_Item(This,var,pvarResult)	\
    (This)->lpVtbl -> get_Item(This,var,pvarResult)

#define Recipients_get_Count(This,varCount)	\
    (This)->lpVtbl -> get_Count(This,varCount)

#define Recipients_get__NewEnum(This,ppunkResult)	\
    (This)->lpVtbl -> get__NewEnum(This,ppunkResult)

#define Recipients_Add(This,Name,Address,Type,pvarResult)	\
    (This)->lpVtbl -> Add(This,Name,Address,Type,pvarResult)

#define Recipients_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipients_get_Application_Proxy( 
    Recipients __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB Recipients_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipients_get_Parent_Proxy( 
    Recipients __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB Recipients_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipients_get_Session_Proxy( 
    Recipients __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB Recipients_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipients_get_Class_Proxy( 
    Recipients __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB Recipients_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipients_get_Item_Proxy( 
    Recipients __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *var,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Recipients_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipients_get_Count_Proxy( 
    Recipients __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varCount);


void __RPC_STUB Recipients_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][hidden][id] */ HRESULT STDMETHODCALLTYPE Recipients_get__NewEnum_Proxy( 
    Recipients __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);


void __RPC_STUB Recipients_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Recipients_Add_Proxy( 
    Recipients __RPC_FAR * This,
    /* [optional][in] */ VARIANT Name,
    /* [optional][in] */ VARIANT Address,
    /* [optional][in] */ VARIANT Type,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Recipients_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Recipients_Delete_Proxy( 
    Recipients __RPC_FAR * This);


void __RPC_STUB Recipients_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Recipients_INTERFACE_DEFINED__ */


#ifndef __Recipient_INTERFACE_DEFINED__
#define __Recipient_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Recipient
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Recipient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064A05-9D99-11D0-ABE5-00AA0064D470")
    Recipient : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ long __RPC_FAR *pType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ long varType) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ BSTR __RPC_FAR *pAddress) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Address( 
            /* [in] */ BSTR varAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct RecipientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Recipient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Recipient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Recipient __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Recipient __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Recipient __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Recipient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Recipient __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Recipient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Recipient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            Recipient __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            Recipient __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Recipient __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            Recipient __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            Recipient __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            Recipient __RPC_FAR * This,
            /* [in] */ long varType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            Recipient __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pAddress);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Address )( 
            Recipient __RPC_FAR * This,
            /* [in] */ BSTR varAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            Recipient __RPC_FAR * This);
        
        END_INTERFACE
    } RecipientVtbl;

    interface Recipient
    {
        CONST_VTBL struct RecipientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Recipient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Recipient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Recipient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Recipient_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Recipient_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Recipient_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Recipient_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Recipient_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define Recipient_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define Recipient_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define Recipient_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define Recipient_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define Recipient_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#define Recipient_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define Recipient_put_Type(This,varType)	\
    (This)->lpVtbl -> put_Type(This,varType)

#define Recipient_get_Address(This,pAddress)	\
    (This)->lpVtbl -> get_Address(This,pAddress)

#define Recipient_put_Address(This,varAddress)	\
    (This)->lpVtbl -> put_Address(This,varAddress)

#define Recipient_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipient_get_Application_Proxy( 
    Recipient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB Recipient_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipient_get_Parent_Proxy( 
    Recipient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB Recipient_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipient_get_Session_Proxy( 
    Recipient __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB Recipient_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipient_get_Class_Proxy( 
    Recipient __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB Recipient_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipient_get_Name_Proxy( 
    Recipient __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB Recipient_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Recipient_put_Name_Proxy( 
    Recipient __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB Recipient_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipient_get_Type_Proxy( 
    Recipient __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pType);


void __RPC_STUB Recipient_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Recipient_put_Type_Proxy( 
    Recipient __RPC_FAR * This,
    /* [in] */ long varType);


void __RPC_STUB Recipient_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Recipient_get_Address_Proxy( 
    Recipient __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pAddress);


void __RPC_STUB Recipient_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Recipient_put_Address_Proxy( 
    Recipient __RPC_FAR * This,
    /* [in] */ BSTR varAddress);


void __RPC_STUB Recipient_put_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Recipient_Delete_Proxy( 
    Recipient __RPC_FAR * This);


void __RPC_STUB Recipient_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Recipient_INTERFACE_DEFINED__ */


#ifndef __Attachments_INTERFACE_DEFINED__
#define __Attachments_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Attachments
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Attachments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064A06-9D99-11D0-ABE5-00AA0064D470")
    Attachments : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT __RPC_FAR *var,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *varCount) = 0;
        
        virtual /* [helpstring][propget][hidden][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [optional][in] */ VARIANT Name,
            /* [optional][in] */ VARIANT Type,
            /* [optional][in] */ VARIANT Source,
            /* [optional][in] */ VARIANT ContentLocation,
            /* [optional][in] */ VARIANT ContentBase,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AttachmentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Attachments __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Attachments __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Attachments __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Attachments __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Attachments __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Attachments __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Attachments __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Attachments __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Attachments __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            Attachments __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            Attachments __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            Attachments __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *var,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            Attachments __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varCount);
        
        /* [helpstring][propget][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            Attachments __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            Attachments __RPC_FAR * This,
            /* [optional][in] */ VARIANT Name,
            /* [optional][in] */ VARIANT Type,
            /* [optional][in] */ VARIANT Source,
            /* [optional][in] */ VARIANT ContentLocation,
            /* [optional][in] */ VARIANT ContentBase,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            Attachments __RPC_FAR * This);
        
        END_INTERFACE
    } AttachmentsVtbl;

    interface Attachments
    {
        CONST_VTBL struct AttachmentsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Attachments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Attachments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Attachments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Attachments_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Attachments_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Attachments_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Attachments_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Attachments_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define Attachments_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define Attachments_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define Attachments_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define Attachments_get_Item(This,var,pvarResult)	\
    (This)->lpVtbl -> get_Item(This,var,pvarResult)

#define Attachments_get_Count(This,varCount)	\
    (This)->lpVtbl -> get_Count(This,varCount)

#define Attachments_get__NewEnum(This,ppunkResult)	\
    (This)->lpVtbl -> get__NewEnum(This,ppunkResult)

#define Attachments_Add(This,Name,Type,Source,ContentLocation,ContentBase,pvarResult)	\
    (This)->lpVtbl -> Add(This,Name,Type,Source,ContentLocation,ContentBase,pvarResult)

#define Attachments_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachments_get_Application_Proxy( 
    Attachments __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB Attachments_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachments_get_Parent_Proxy( 
    Attachments __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB Attachments_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachments_get_Session_Proxy( 
    Attachments __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB Attachments_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachments_get_Class_Proxy( 
    Attachments __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB Attachments_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachments_get_Item_Proxy( 
    Attachments __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *var,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Attachments_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachments_get_Count_Proxy( 
    Attachments __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varCount);


void __RPC_STUB Attachments_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][hidden][id] */ HRESULT STDMETHODCALLTYPE Attachments_get__NewEnum_Proxy( 
    Attachments __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);


void __RPC_STUB Attachments_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Attachments_Add_Proxy( 
    Attachments __RPC_FAR * This,
    /* [optional][in] */ VARIANT Name,
    /* [optional][in] */ VARIANT Type,
    /* [optional][in] */ VARIANT Source,
    /* [optional][in] */ VARIANT ContentLocation,
    /* [optional][in] */ VARIANT ContentBase,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);


void __RPC_STUB Attachments_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Attachments_Delete_Proxy( 
    Attachments __RPC_FAR * This);


void __RPC_STUB Attachments_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Attachments_INTERFACE_DEFINED__ */


#ifndef __Attachment_INTERFACE_DEFINED__
#define __Attachment_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Attachment
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Attachment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064A07-9D99-11D0-ABE5-00AA0064D470")
    Attachment : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ long __RPC_FAR *pType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ long varType) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSource) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Source( 
            /* [in] */ VARIANT varSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentLocation( 
            /* [retval][out] */ VARIANT __RPC_FAR *varContentLocation) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentBase( 
            /* [retval][out] */ VARIANT __RPC_FAR *varContentBase) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentID( 
            /* [retval][out] */ VARIANT __RPC_FAR *varContentID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadFromFile( 
            /* [in] */ BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteToFile( 
            /* [in] */ BSTR FileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AttachmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Attachment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Attachment __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Attachment __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Attachment __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Attachment __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Attachment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Attachment __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            Attachment __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            Attachment __RPC_FAR * This,
            /* [in] */ long varType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSource);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Source )( 
            Attachment __RPC_FAR * This,
            /* [in] */ VARIANT varSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentLocation )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varContentLocation);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentBase )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varContentBase);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentID )( 
            Attachment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varContentID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            Attachment __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadFromFile )( 
            Attachment __RPC_FAR * This,
            /* [in] */ BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteToFile )( 
            Attachment __RPC_FAR * This,
            /* [in] */ BSTR FileName);
        
        END_INTERFACE
    } AttachmentVtbl;

    interface Attachment
    {
        CONST_VTBL struct AttachmentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Attachment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Attachment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Attachment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Attachment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Attachment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Attachment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Attachment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Attachment_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define Attachment_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define Attachment_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define Attachment_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define Attachment_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define Attachment_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#define Attachment_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define Attachment_put_Type(This,varType)	\
    (This)->lpVtbl -> put_Type(This,varType)

#define Attachment_get_Source(This,varSource)	\
    (This)->lpVtbl -> get_Source(This,varSource)

#define Attachment_put_Source(This,varSource)	\
    (This)->lpVtbl -> put_Source(This,varSource)

#define Attachment_get_ContentLocation(This,varContentLocation)	\
    (This)->lpVtbl -> get_ContentLocation(This,varContentLocation)

#define Attachment_get_ContentBase(This,varContentBase)	\
    (This)->lpVtbl -> get_ContentBase(This,varContentBase)

#define Attachment_get_ContentID(This,varContentID)	\
    (This)->lpVtbl -> get_ContentID(This,varContentID)

#define Attachment_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define Attachment_ReadFromFile(This,FileName)	\
    (This)->lpVtbl -> ReadFromFile(This,FileName)

#define Attachment_WriteToFile(This,FileName)	\
    (This)->lpVtbl -> WriteToFile(This,FileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_Application_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB Attachment_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_Parent_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB Attachment_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_Session_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB Attachment_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_Class_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB Attachment_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_Name_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB Attachment_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Attachment_put_Name_Proxy( 
    Attachment __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB Attachment_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_Type_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pType);


void __RPC_STUB Attachment_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Attachment_put_Type_Proxy( 
    Attachment __RPC_FAR * This,
    /* [in] */ long varType);


void __RPC_STUB Attachment_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_Source_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSource);


void __RPC_STUB Attachment_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE Attachment_put_Source_Proxy( 
    Attachment __RPC_FAR * This,
    /* [in] */ VARIANT varSource);


void __RPC_STUB Attachment_put_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_ContentLocation_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varContentLocation);


void __RPC_STUB Attachment_get_ContentLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_ContentBase_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varContentBase);


void __RPC_STUB Attachment_get_ContentBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Attachment_get_ContentID_Proxy( 
    Attachment __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varContentID);


void __RPC_STUB Attachment_get_ContentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Attachment_Delete_Proxy( 
    Attachment __RPC_FAR * This);


void __RPC_STUB Attachment_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Attachment_ReadFromFile_Proxy( 
    Attachment __RPC_FAR * This,
    /* [in] */ BSTR FileName);


void __RPC_STUB Attachment_ReadFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Attachment_WriteToFile_Proxy( 
    Attachment __RPC_FAR * This,
    /* [in] */ BSTR FileName);


void __RPC_STUB Attachment_WriteToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Attachment_INTERFACE_DEFINED__ */


#ifndef __AddressEntry_INTERFACE_DEFINED__
#define __AddressEntry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: AddressEntry
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_AddressEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E064A08-9D99-11D0-ABE5-00AA0064D470")
    AddressEntry : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ VARIANT __RPC_FAR *varParent) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ VARIANT __RPC_FAR *varSession) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long __RPC_FAR *varClass) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ BSTR __RPC_FAR *varAddress) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *varType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AddressEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            AddressEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            AddressEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            AddressEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            AddressEntry __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            AddressEntry __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            AddressEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            AddressEntry __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            AddressEntry __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varApplication);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            AddressEntry __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varParent);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            AddressEntry __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varSession);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            AddressEntry __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *varClass);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            AddressEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            AddressEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varAddress);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            AddressEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varType);
        
        END_INTERFACE
    } AddressEntryVtbl;

    interface AddressEntry
    {
        CONST_VTBL struct AddressEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AddressEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AddressEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AddressEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AddressEntry_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define AddressEntry_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define AddressEntry_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define AddressEntry_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define AddressEntry_get_Application(This,varApplication)	\
    (This)->lpVtbl -> get_Application(This,varApplication)

#define AddressEntry_get_Parent(This,varParent)	\
    (This)->lpVtbl -> get_Parent(This,varParent)

#define AddressEntry_get_Session(This,varSession)	\
    (This)->lpVtbl -> get_Session(This,varSession)

#define AddressEntry_get_Class(This,varClass)	\
    (This)->lpVtbl -> get_Class(This,varClass)

#define AddressEntry_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define AddressEntry_get_Address(This,varAddress)	\
    (This)->lpVtbl -> get_Address(This,varAddress)

#define AddressEntry_get_Type(This,varType)	\
    (This)->lpVtbl -> get_Type(This,varType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE AddressEntry_get_Application_Proxy( 
    AddressEntry __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varApplication);


void __RPC_STUB AddressEntry_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE AddressEntry_get_Parent_Proxy( 
    AddressEntry __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varParent);


void __RPC_STUB AddressEntry_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE AddressEntry_get_Session_Proxy( 
    AddressEntry __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varSession);


void __RPC_STUB AddressEntry_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE AddressEntry_get_Class_Proxy( 
    AddressEntry __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *varClass);


void __RPC_STUB AddressEntry_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE AddressEntry_get_Name_Proxy( 
    AddressEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB AddressEntry_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE AddressEntry_get_Address_Proxy( 
    AddressEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varAddress);


void __RPC_STUB AddressEntry_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE AddressEntry_get_Type_Proxy( 
    AddressEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varType);


void __RPC_STUB AddressEntry_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __AddressEntry_INTERFACE_DEFINED__ */



#ifndef __CDONTS_LIBRARY_DEFINED__
#define __CDONTS_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: CDONTS
 * at Sun Nov 02 08:48:51 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [helpstring] */ 
enum CdoRecipientTypes
    {	CdoTo	= 1,
	CdoCc	= 2,
	CdoBcc	= 3
    }	CdoRecipientTypes;

typedef /* [helpstring] */ 
enum CdoImportance
    {	CdoLow	= 0,
	CdoNormal	= 1,
	CdoHigh	= 2
    }	CdoImportance;

typedef /* [helpstring] */ 
enum CdoAttachmentTypes
    {	CdoFileData	= 1,
	CdoEmbeddedMessage	= 4
    }	CdoAttachmentTypes;

typedef /* [helpstring] */ 
enum CdoFolderTypes
    {	CdoDefaultFolderInbox	= 1,
	CdoDefaultFolderOutbox	= 2
    }	CdoFolderTypes;

typedef /* [helpstring] */ 
enum CdoMessageFormats
    {	CdoMime	= 0,
	CdoText	= 1
    }	CdoMessageFormats;

typedef /* [helpstring] */ 
enum CdoMailFormats
    {	CdoMailFormatMime	= 0,
	CdoMailFormatText	= 1
    }	CdoMailFormats;

typedef /* [helpstring] */ 
enum CdoBodyFormats
    {	CdoBodyFormatHTML	= 0,
	CdoBodyFormatText	= 1
    }	CdoBodyFormats;

typedef /* [helpstring] */ 
enum CdoEncodingMethod
    {	CdoEncodingUUencode	= 0,
	CdoEncodingBase64	= 1
    }	CdoEncodingMethod;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_actmsg_0220_0001
    {	CdoSession	= 0,
	CdoFolder	= 2,
	CdoMsg	= 3,
	CdoRecipient	= 4,
	CdoAttachment	= 5,
	CdoAddressEntry	= 8,
	CdoMessages	= 16,
	CdoRecipients	= 17,
	CdoAttachments	= 18,
	CdoClassTotal	= 29
    }	CdoObjectClass;










EXTERN_C const IID LIBID_CDONTS;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_NewMail;

class DECLSPEC_UUID("AF0EB60E-0775-11D1-A77D-00C04FC2F5B3")
NewMail;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Session;

class DECLSPEC_UUID("0E064AEC-9D99-11D0-ABE5-00AA0064D470")
Session;
#endif
#endif /* __CDONTS_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\smtphelp.cpp ===
// based on SMTP spec RFC 821
 
#include "precomp.h" 
 
#include <stdio.h> 
#include <stdarg.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h> 
#include <io.h> 
#include <fcntl.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <wbemutil.h>
#include <ArrTempl.h>

#define SMTP_PORT 25
#define MAX_SMTP_BUFFER		0x4000		// 16K
#define MAX_SUBJECT_LINE	2048		// leave room for the encoding
#define MAX_USER_NAME		512
#define MAX_EXTRA_HEADER	1024

#define SMTP_OKAY           250         // doc'd as 'Requested mail action okay, completed'                           
#define INTERNAL_ERROR      554         // sorta fit in with the SMTP error codes
                                        // doc'd as 'Transaction Failed' by the SMTP spec    

#define HH_MAX_COMPUTERNAME_LENGTH 256 // because the system defined MAX_COMPUTERNAME_LENGTH isn't


// returns true if dwRet is an SMTP error
bool IsSMTPError(DWORD dwRet)
{
    return (dwRet >= 400);
}
    
 
// Helper functions 
 
void SkipWhite(PSTR *ppS ) 
{ 
    PSTR pS = *ppS; 
 
    while ( *pS && isspace(*pS) ) 
        ++pS; 
 
    *ppS = pS; 
} 
 
 
void SkipNonWhite(PSTR *ppS ) 
{ 
    PSTR pS = *ppS; 
 
    while ( *pS && !isspace(*pS) ) 
        ++pS; 
 
    *ppS = pS; 
} 
 
 
/* 
BOOL 
HttpGetSocket( 
    char * Server
    ) 

{ 
    char               ReceiveBuffer[8*1024]; 
    int                Error; 
    char               Request[1024]; 
    int                RequestSize; 
    SOCKET             Socket = INVALID_SOCKET; 
    struct sockaddr_in Address; 
    struct hostent *   HostEntry; 
    int                cRec; 
    DWORD              cLen; 
    DWORD              cToRead; 
    BOOL               fSt = FALSE; 
    int                hnd = EOF; 
 
 
    if ( Socket == INVALID_SOCKET ) 
    { 
    } 
 
    // 
    // Send the client request 
    // 

    sprintf(Request, "GET / HTTP/1.0\r\n\r\n");
 
    RequestSize = strlen(Request); 
 
    Error = 
    send( 
        Socket, 
        Request, 
        RequestSize, 
        0); 
 
    if (Error != RequestSize)  
    { 
        printf("Error in client send = %d, %d\n", Error, GetLastError()); 
        fSt = FALSE; 
        goto ex; 
    } 
 
    // parse status & header 
 
    cLen = (DWORD)-1; 
 
    for ( pH = ReceiveBuffer, fStatusLine = TRUE ; fInHeader ; ) 
    { 
        cRec = recv( Socket, pH, ReceiveBuffer+sizeof(ReceiveBuffer)-pH, 0 ); 
        if ( cRec <= 0 ) 
        { 
            closesocket( Socket ); 
            Socket = INVALID_SOCKET; 
            break; 
        } 
        pH[ cRec ] = '\0';
        printf(pH);
    } 
 

 
ex:  
    if ( hnd != EOF ) 
        close( hnd ); 
 
    return fSt; 
} 
*/

// returns numeric reply code
// in general, anything >= 400 is bad.
int SMTPReceive(int Socket)
{
    int nCode;
    
	char *szBuffer = new char[MAX_SMTP_BUFFER];
	if (szBuffer == NULL)
		return INTERNAL_ERROR;

    int nLen = recv( Socket, szBuffer, MAX_SMTP_BUFFER, 0);          
    if (nLen == SOCKET_ERROR)
    {
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "SMTPReceive failed: %d\n", err));
        nCode = INTERNAL_ERROR;

    }	
    else
    {
	    szBuffer[nLen]=0;	    
        if (1 != sscanf(szBuffer, " %d", &nCode))
			nCode = INTERNAL_ERROR;
    }

	if (szBuffer)
		delete szBuffer;

    return nCode;
}

// returns numeric reply code
// in general, anything >= 400 is bad.
DWORD SMTPTransactMailCommand(SOCKET Socket, char *cCommand)
{
	DWORD dwError;
	
    if(SOCKET_ERROR == send(Socket, cCommand, strlen(cCommand), 0))
    {
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "SMTPTransactMailCommand failed on command: %s (%d)\n", cCommand, err));
        dwError = INTERNAL_ERROR;
    }
    else{
        dwError = SMTPReceive(Socket);	

		if(IsSMTPError(dwError)){

			ERRORTRACE((LOG_ESS, "SMTP command \"%s\" returned %d\n", cCommand, dwError));
		}
	}

	return dwError;
}


// returns 0 on success
// don't bother trying to make sense of the number otherwise       
int SMTPConnect(char* szHost, SOCKET* pSocket)
{
    SOCKET             Socket = INVALID_SOCKET; 
    struct sockaddr_in Address; 
    struct hostent *   HostEntry; 
    int Error = -1;
    BOOL fSt = FALSE;


	TCHAR cComputer[HH_MAX_COMPUTERNAME_LENGTH +2];
	DWORD dwBuffSize= HH_MAX_COMPUTERNAME_LENGTH +1;

    Socket = socket(AF_INET, SOCK_STREAM, 0); 

    if (Socket == INVALID_SOCKET)  
    { 
        // fprintf(stderr, "Error creating socket = %d\n", GetLastError()); 

        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "Error creating socket = %d\n", err));

        fSt = FALSE; 
        goto ex; 
    } 

    Address.sin_family = AF_INET; 
    Address.sin_port = 0; 
    Address.sin_addr.s_addr = INADDR_ANY; 

    Error =  
    bind( 
        Socket, 
        (struct sockaddr *) &Address, 
        sizeof(Address)); 

    if (Error)  
    { 
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "bind failed = %d\n", err));
        fSt = FALSE; 
        goto ex; 
    } 

    Address.sin_family = AF_INET; 
    Address.sin_port = htons(SMTP_PORT); 

    HostEntry = gethostbyname(szHost); 
    if (HostEntry == NULL)  
    { 
        Error = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "unable to resolve host %s error = %d\n", szHost, Error));

        fSt = FALSE; 
        goto ex; 
    } 
    else  
    { 
        Address.sin_addr.s_addr = *((unsigned long *) HostEntry->h_addr); 
    } 

    Error = 
    connect( 
        Socket, 
        (struct sockaddr *) &Address, 
        sizeof(Address)); 

    if (Error)  
    { 
        int err = WSAGetLastError();
        ERRORTRACE((LOG_ESS, "Error connecting to %s = %d\n", szHost, err));
        fSt = FALSE; 
        goto ex; 
    } 

	Error = SMTPReceive(Socket);
    if (!IsSMTPError(Error))
    {
	    if (!GetComputerName(cComputer,&dwBuffSize))
		{
			ERRORTRACE((LOG_ESS, "GetComputerName failed! 0x%08X\n", GetLastError()));
			return -1;
		}

        char cMailCommand[2*HH_MAX_COMPUTERNAME_LENGTH + 20];
	    strcpy(cMailCommand,"HELO ");
#ifdef _UNICODE
        char narrowcComputer[2*HH_MAX_COMPUTERNAME_LENGTH + 1];
        sprintf(narrowcComputer, "%S", cComputer);

        strcat(cMailCommand,narrowcComputer);
#else
	    strcat(cMailCommand,cComputer);
#endif
	    strcat(cMailCommand,"\r\n");


	    Error=SMTPTransactMailCommand(Socket, cMailCommand);
        fSt = TRUE;
    }
    else
	{
        fSt = FALSE;
		ERRORTRACE((LOG_ESS, "Error establishing SMTP connection (%d)\n", Error));
	}

ex:
    if(!fSt)
    {
        closesocket(Socket);
        return Error;
    }
    else
    {
        *pSocket = Socket;
        return NOERROR;
    }
}


// returns SMTP reply code
DWORD SMTPDisconnect(SOCKET Socket)
{
	DWORD dwError = SMTP_OKAY;
	
	if (Socket != INVALID_SOCKET)
	{
		dwError=SMTPTransactMailCommand(Socket, "QUIT\r\n");
		closesocket(Socket);
	};

	return(dwError);
}

LPSTR Months[] = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
LPSTR Days[] =   { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };

void GetTimeString(char *cTimeString,DWORD  dwMaxSize)
{
	SYSTEMTIME st;

	GetSystemTime(&st);

	sprintf( cTimeString, "%s, %02d %s %4d %02d:%02d:%02d GMT",
			 Days[ st.wDayOfWeek ], st.wDay, Months[ st.wMonth], st.wYear, st.wHour, st.wMinute, st.wSecond);
}

	
// returns 0 upon success
// inputs may be zero length, but may not be NULL.
DWORD SMTPSendMailHeader(SOCKET Socket, char* szTo, char* szCc, char* szFrom, char* szReplyTo, char* szSubject, char* szHeaders)
{	
    // dang gone it! they went & made 'template' a keyword...
    const char templitt[] = "Date: %s\r\nTo: %s\r\nCc: %s\r\nFrom: %s via WMI auto-mailer\r\nReply-To: %s\r\nSubject: %s";
    char* pszOutputBuffer = new char[strlen(templitt) +strlen(szTo)   +strlen(szCc) 
                                                      +strlen(szFrom) +strlen(szReplyTo)
                                                      +strlen(szSubject) +strlen(szHeaders)
                                                      +104]; // to account for date string and for the trailing \r\n\r\n

    if (!pszOutputBuffer)
        return INTERNAL_ERROR;
    else
    {
        CDeleteMe<char> delbuf(pszOutputBuffer);
        char cTimeString[100];
	    GetTimeString(cTimeString,100);  
        
        sprintf(pszOutputBuffer, templitt, cTimeString, szTo, szCc, szFrom, szReplyTo, szSubject);

        if (strlen(szHeaders))
        {
            strcat(pszOutputBuffer, "\r\n");
            strcat(pszOutputBuffer, szHeaders);
        }
        strcat(pszOutputBuffer, "\r\n\r\n");
    
        if (SOCKET_ERROR == send(Socket, pszOutputBuffer, strlen(pszOutputBuffer), 0))
        {
            int err = WSAGetLastError();
            ERRORTRACE((LOG_ESS, "SMTPSendMailHeader failed (%d)\n", err));
            return INTERNAL_ERROR;
        }
        else
	    {
	        return(NO_ERROR);
	    }
    }
}

// returns 0 on success
// but ignores error returns from server (server returns error if it must relay recipients.
DWORD SMTPSendRecipients(SOCKET Socket, LPCSTR szRecipients)
{
	char *tok;
    DWORD dwError = SMTP_OKAY;    
	char*  pParseBuffer = new char[strlen(szRecipients) +1];

    if (!pParseBuffer)
        dwError = INTERNAL_ERROR;
    else
    {
        char szBuffer[1024];
        CDeleteMe<char> delbuf(pParseBuffer);

	    strcpy(pParseBuffer,szRecipients);
	    
	    tok=strtok(pParseBuffer," ;,");
	    while (tok!=NULL)
	    {
		    DWORD dwErrInternal;
            
            sprintf(szBuffer, "RCPT TO:<%s>\r\n",tok);
		    dwErrInternal=SMTPTransactMailCommand(Socket, szBuffer);
            if(IsSMTPError(dwErrInternal))
            { 
                if ((dwErrInternal == 550) || (dwErrInternal == 551))
                    ERRORTRACE((LOG_ESS, "Ignoring RCPT Error, will attempt to send mail.\n"));
                else
                {
                    dwError = dwErrInternal;
                    break;
                }
            }

		    
		    tok=strtok(NULL," ;,");
	    }
    }

	return dwError;
}


// returns 0 on success, SMTP numeric reply code otherwise
DWORD SMTPSendText(SOCKET Socket, char* szTo, char* szCc, char* szFrom, char* szReplyTo, char* szSubject, 
                   char* szHeaders, char *szText)
{
	DWORD dwError;
	int nLen;
	int nSizeToSend;
	char *tmp;
	
	dwError=SMTPTransactMailCommand(Socket, "DATA\r\n");
    if (IsSMTPError(dwError))
        return dwError;

	dwError=SMTPSendMailHeader(Socket, szTo, szCc, szFrom, szReplyTo, szSubject, szHeaders);
    if (IsSMTPError(dwError))
        return dwError;

    nLen=strlen(szText);
	tmp=szText;
	
	while (nLen>0)
	{
		nSizeToSend=min(1000,nLen);
		
        if (SOCKET_ERROR == send(Socket, tmp, nSizeToSend, 0))
        {
            int err = WSAGetLastError();
            ERRORTRACE((LOG_ESS, "SMTPSendText failed (%d)\n", err));

            return INTERNAL_ERROR;
        }

		nLen-=nSizeToSend;
		tmp+=nSizeToSend;
	}
	
	
	dwError=SMTPTransactMailCommand(Socket, "\r\n.\r\n");
	
	return dwError;
}


// uses SMTP verification to determine whether
// recipient actually exists (is known to this server)
// returns return value from SMTPTransactMailCommand
//-->> will return success code if passed a NULL buffer
DWORD CheckRecipients(SOCKET Socket2me, char* szRecipients)
{
    DWORD dwError = SMTP_OKAY;
	char*  pParseBuffer = new char[strlen(szRecipients) +1];

    if (!pParseBuffer)
        dwError = INTERNAL_ERROR;
    else
    {
        CDeleteMe<char> delbuf(pParseBuffer);
        char *tok;            
        char szBuffer[1024];
	    
	    strcpy(pParseBuffer,szRecipients);
	    
	    tok=strtok(pParseBuffer," ;,");
	    while (tok!=NULL)
	    {
		    sprintf(szBuffer, "VRFY %s\r\n",tok);
		    dwError=SMTPTransactMailCommand(Socket2me, szBuffer);
            if(IsSMTPError(dwError))
                break;
		    
		    tok=strtok(NULL," ;,");
	    }
    }

    // hack to disable error returns
    // some servers don't handle VRFY
    dwError = SMTP_OKAY;
	return dwError;
    
}

// returns zero upon success.
DWORD SMTPSend(char* szServer, char* szTo, char* szCc, char* szBcc, char* szFrom,
			   char* szReplyTo, char* szSubject, char* szHeaders, char *szText)
{
	DWORD dwError = -1;
    SOCKET Socket = INVALID_SOCKET;
    
    char szFromBuffer[1024];
    sprintf(szFromBuffer,"MAIL FROM: <%s>\r\n",szFrom);
	
    // each of the functions below do their own error reporting to the log
	if ( (0 == SMTPConnect(szServer, &Socket))                       &&

	     !IsSMTPError(CheckRecipients(Socket, szTo))     &&
         !IsSMTPError(CheckRecipients(Socket, szCc))    &&		 
         !IsSMTPError(CheckRecipients(Socket, szBcc))   &&  

         !IsSMTPError(SMTPTransactMailCommand(Socket, szFromBuffer)) && 
         
         !IsSMTPError(SMTPSendRecipients(Socket, szTo))                     &&
		 !IsSMTPError(SMTPSendRecipients(Socket, szCc))                     &&
		 !IsSMTPError(SMTPSendRecipients(Socket, szBcc))                    &&

         !IsSMTPError(SMTPSendText(Socket, szTo, szCc, szFrom, szReplyTo, szSubject, szHeaders, szText)) )
	{     
		 dwError = 0;
	}

    DWORD dwDebugError;
    dwDebugError=SMTPDisconnect(Socket);
	
	if(IsSMTPError(dwDebugError))
	{
		// If disconnect failed log a message, but don't interfere with
		// operation
		ERRORTRACE((LOG_ESS, "SMTPDisconnect returned %d\n", dwDebugError));
	}

	return dwError;
} 


// test harness
//void main()
//{
//    WSADATA            WsaData; 
//    int Error = WSAStartup (0x101, &WsaData); 
// 
//    if (Error == SOCKET_ERROR)  
//    { 
//        fprintf(stderr, "Error in WSAStartup = %d\n", GetLastError()); 
//        return;
//    } 
//
//    SMTPSend("smarthost", "levn@microsoft.com", "levn@microsoft.com", "subject", "Text");
//    /*
//    SOCKET Socket;
//    SMTPConnect("smarthost", &Socket);
//    SMTPDisconnect(Socket);
//    */
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\email.h ===
#ifndef __WBEM_EMAIL_CONSUMER__H_
#define __WBEM_EMAIL_CONSUMER__H_

#include <unk.h>


#include <wbemidl.h>
#include <cdonts.h>

#include "txttempl.h"

class CEmailConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CEmailConsumer>
    {
    public:
        XProvider(CEmailConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CEmailConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CEmailConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL);
    ~CEmailConsumer();
    void* GetInterface(REFIID riid);
};


class CEmailSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CEmailSink>
    {
    public:
        XSink(CEmailSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CEmailSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    CTextTemplate m_SubjectTemplate;
    CTextTemplate m_MessageTemplate;

    WString m_wsTo;
    WString m_wsCc;
    WString m_wsBcc;
    WString m_wsFrom;

    BOOL m_bIsHTML;
    long m_lImportance;

    INewMail* m_pNewMail;
public:
    CEmailSink(CLifeControl* pControl = NULL);
    ~CEmailSink();

    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\emailmapi.cpp ===
#include "email.h"
#include "mapisdk.h"
#include <wbemutil.h>
#include <cominit.h>

#define EMAIL_PROPNAME_PROFILE L"Profile"
#define EMAIL_PROPNAME_ADDRESSEE L"Addressee"
#define EMAIL_PROPNAME_SUBJECT L"Subject"
#define EMAIL_PROPNAME_MESSAGE L"Message"



CEmailConsumer::CEmailConsumer(CLifeControl* pControl, IUnknown* pOuter)
        : CUnk(pControl, pOuter), m_XProvider(this)
{
    m_hAttention = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_pLogicalConsumer = NULL;
    m_pStream = NULL;

    DWORD dwId;
    m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&staticWorker, 
                    (void*)this, 0, &dwId);
}

CEmailConsumer::~CEmailConsumer()
{
    m_pLogicalConsumer = NULL;
    SetEvent(m_hAttention);
    WaitForSingleObject(m_hThread, INFINITE);
    CloseHandle(m_hAttention);
    CloseHandle(m_hDone);
    CloseHandle(m_hThread);
}

DWORD CEmailConsumer::staticWorker(void* pv)
{
    ((CEmailConsumer*)pv)->Worker();
    return 0;
}

void CEmailConsumer::Worker()
{
    HRESULT hres;

    hres = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    MAPIINIT_0 init;
    init.ulVersion = MAPI_INIT_VERSION;
    init.ulFlags = WBEM_MAPI_FLAGS; 

    hres = MAPIInitialize((void*)&init);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "MAPI initialization failed: %X\n", hres));
        return;
    }

    while(1)
    {
        DWORD dwRet = MsgWaitForMultipleObjects(1, &m_hAttention, FALSE, 
                            INFINITE, QS_ALLINPUT);
        MSG msg;
        if(dwRet == (WAIT_OBJECT_0 + 1)) 
        {
            while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                DispatchMessage(&msg);
            }
            continue;
        }

        if(m_pLogicalConsumer == NULL)
            return;

        CEmailSink* pSink = new CEmailSink(m_pControl);
        HRESULT hres = pSink->Initialize(m_pLogicalConsumer);
        m_pStream = NULL;
        if(FAILED(hres))
        {
            delete pSink;
        }
        else 
        {
            pSink->AddRef();
            CoMarshalInterThreadInterfaceInStream(
                IID_IWbemUnboundObjectSink, pSink, &m_pStream);
            pSink->Release();
        }

        SetEvent(m_hDone);
    }

    CoUninitialize();
}



HRESULT STDMETHODCALLTYPE CEmailConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    m_pObject->m_pLogicalConsumer = pLogicalConsumer;
    HANDLE aHandles[2];
    aHandles[0] = m_pObject->m_hThread;
    aHandles[1] = m_pObject->m_hDone;
    SetEvent(m_pObject->m_hAttention);

    DWORD dwRes = WaitForMultipleObjects(2, aHandles, FALSE, INFINITE);
    if(dwRes != WAIT_OBJECT_0 + 1 || m_pObject->m_pStream == NULL)
    {
        return WBEM_E_FAILED;
    }
    
    return CoGetInterfaceAndReleaseStream(m_pObject->m_pStream, 
        IID_IWbemUnboundObjectSink, (void**)ppConsumer);
}

void* CEmailConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else
        return NULL;
}




CEmailSink::CEmailSink(CLifeControl* pControl)
    : CUnk(pControl), m_XSink(this), m_pSession(NULL), m_pStore(NULL), 
        m_pOutbox(NULL), m_pAddrBook(NULL), m_pAddrList(NULL)
{
}

HRESULT CEmailSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    HRESULT hres;

    // Retrieve information from the logical consumer instance
    // =======================================================

    VARIANT v;
    VariantInit(&v);

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_PROFILE, 0, &v, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_PARAMETER;

    m_wsProfile = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_ADDRESSEE, 0, &v, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_PARAMETER;

    m_wsAddressee = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_SUBJECT, 0, &v, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_PARAMETER;

    m_SubjectTemplate.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    hres = pLogicalConsumer->Get(EMAIL_PROPNAME_MESSAGE, 0, &v, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_PARAMETER;

    m_MessageTemplate.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    // Create the profile if necessary
    // ===============================

    IProfAdmin* pProfAdmin;
    hres = MAPIAdminProfiles(0, &pProfAdmin); // UNICODE?
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to create MAPI profile administrator: %X\n",
            hres));
        return WBEM_E_FAILED;
    }

    LPSTR szProfile = m_wsProfile.GetLPSTR();
    hres = pProfAdmin->CreateProfile(szProfile, NULL, NULL,
        MAPI_DEFAULT_SERVICES); // | MAPI_UNICODE);
    if(FAILED(hres) && hres != MAPI_E_NO_ACCESS)
    {
        ERRORTRACE((LOG_ESS, "Unable to create MAPI profile %S: %X\n",
            (LPWSTR)m_wsProfile, hres));
        delete [] szProfile;
        return WBEM_E_FAILED;
    }
    else if(SUCCEEDED(hres))
    {
        DEBUGTRACE((LOG_ESS, "Created MAPI profile %S\n", (LPWSTR)m_wsProfile));
    }

    pProfAdmin->Release();

    // Log on to the profile
    // =====================

    hres = MAPILogonEx(NULL, szProfile, NULL, 
        MAPI_EXTENDED | WBEM_MAPI_LOGON_FLAGS, // | MAPI_UNICODE,
        &m_pSession); 
    delete [] szProfile;
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Umnable to log on to MAPI profile %S: $X\n", 
            (LPWSTR)m_wsProfile, hres));
        return WBEM_E_FAILED;
    }

    // Open default store
    // ==================

    hres = HrOpenDefaultStore(m_pSession, &m_pStore);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Umnable to open default store in MAPI profile "
            "%S: $X\n", (LPWSTR)m_wsProfile, hres));
        return WBEM_E_FAILED;
    }

    // Open out folder
    // ===============

    hres = HrOpenOutFolder(m_pStore, &m_pOutbox);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Umnable to open outbox in MAPI profile "
            "%S: $X\n", (LPWSTR)m_wsProfile, hres));
        return WBEM_E_FAILED;
    }
    
    // Open address book
    // =================

    hres = HrOpenAddressBook(m_pSession, &m_pAddrBook);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Umnable to open address book in MAPI profile "
            "%S: $X\n", (LPWSTR)m_wsProfile, hres));
        return WBEM_E_FAILED;
    }

    // Create the address list
    // =======================

    hres = HrCreateAddrList(m_wsAddressee, m_pAddrBook, &m_pAddrList);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Umnable to resolve %S in MAPI profile "
            "%S: $X\n", (LPWSTR)m_wsAddressee, (LPWSTR)m_wsProfile, hres));
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}


CEmailSink::~CEmailSink()
{
    if(m_pOutbox)
        m_pOutbox->Release();

    if(m_pStore)
    {
        //get our message out of the outbox
        ULONG ulFlags = LOGOFF_PURGE;
        m_pStore->StoreLogoff(&ulFlags);
        m_pStore->Release();
    }
    
    if(m_pAddrBook)
    {
        m_pAddrBook->Release();
    }

    if(m_pAddrList)
    {
        FreePadrlist(m_pAddrList);
    }

    if(m_pSession)
    {
        m_pSession->Logoff(0, 0, 0);
        m_pSession->Release();
    }
}


HRESULT STDMETHODCALLTYPE CEmailSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    HRESULT hres;
    for(long i = 0; i < lNumObjects; i++)
    {
        // Obtain customized versions of the subject and the message
        // =========================================================

        BSTR strSubject = m_pObject->m_SubjectTemplate.Apply(apObjects[0]);
        BSTR strMessage = m_pObject->m_MessageTemplate.Apply(apObjects[0]);

        // Create a message
        // ================

        IMessage* pMessage;
        hres = HrCreateOutMessage(m_pObject->m_pOutbox, &pMessage);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Umnable to create message in MAPI profile "
                "%S: $X\n", (LPWSTR)m_pObject->m_wsProfile, hres));
            return hres;
        }
    
        // Set data
        // ========
    
        hres = HrInitMsg(pMessage, m_pObject->m_pAddrList, strSubject, 
                strMessage);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Umnable to init message in MAPI profile "
                "%S: $X\n", (LPWSTR)m_pObject->m_wsProfile, hres));
            pMessage->Release();
            return hres;
        }

        // Send it
        // =======

        hres = pMessage->SubmitMessage(0);
        pMessage->Release();
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Umnable to send message in MAPI profile "
                "%S: 0x%X\n", (LPWSTR)m_pObject->m_wsProfile, hres));
            return hres;            
        }
    }

    return WBEM_S_NO_ERROR;
}

void* CEmailSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\evtlog.h ===
#ifndef __WBEM_EVENTLOG_CONSUMER__H_
#define __WBEM_EVENTLOG_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include "txttempl.h"
#include <stdio.h>

class CEventLogConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CEventLogConsumer>
    {
    public:
        XProvider(CEventLogConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CEventLogConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CEventLogConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this)
    {}
    ~CEventLogConsumer(){}
    void* GetInterface(REFIID riid);
};


class CEventLogSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CEventLogSink>
    {
    public:
        XSink(CEventLogSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CEventLogSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    private:
        void GetDatData(IWbemClassObject* pEventObj, WCHAR* dataName, 
                        VARIANT& vData, BYTE*& pData, DWORD& dataSize);
        void GetDatSID(IWbemClassObject* pEventObj, WCHAR* dataName, PSID& pSid);
        HRESULT GetDatDataVariant(IWbemClassObject* pEventObj, WCHAR* dataName, VARIANT& vData);
        HRESULT GetDatEmbeddedObjectOut(IWbemClassObject* pObject, WCHAR* objectName, IWbemClassObject*& pEmbeddedObject);

    } m_XSink;
    friend XSink;

protected:
    DWORD m_dwType;
    DWORD m_dwCategory;
    DWORD m_dwEventId;
    DWORD m_dwNumTemplates;
    CTextTemplate* m_aTemplates;
    PSID  m_pSidCreator;   
    WString m_dataName; // name of property in event, property is handed off to the 'additional data' block in nt event log
    WString m_sidName;  // name of property in event, property is handed off to the 'user sid' block in nt event log

    HANDLE m_hEventLog;

public:
    CEventLogSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), m_aTemplates(NULL), m_hEventLog(NULL), m_pSidCreator(NULL)          
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);

    ~CEventLogSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\evtlog.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemutil.h>
#include <wbemcomn.h>
#include <GroupsForUser.h>
#include "evtlog.h"
#include <GenUtils.h>
#include <comdef.h>
#include <Sddl.h>

#define EVENTLOG_PROPNAME_SERVER L"UNCServerName"
#define EVENTLOG_PROPNAME_SOURCE L"SourceName"
#define EVENTLOG_PROPNAME_EVENTID L"EventID"
#define EVENTLOG_PROPNAME_TYPE L"EventType"
#define EVENTLOG_PROPNAME_CATEGORY L"Category"
#define EVENTLOG_PROPNAME_NUMSTRINGS L"NumberOfInsertionStrings"
#define EVENTLOG_PROPNAME_STRINGS L"InsertionStringTemplates"
#define EVENTLOG_PROPNAME_CREATORSID L"CreatorSid"
#define EVENTLOG_PROPNAME_DATANAME L"NameOfRawDataProperty"
#define EVENTLOG_PROPNAME_SIDNAME L"NameOfUserSIDProperty"

HRESULT STDMETHODCALLTYPE CEventLogConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    CEventLogSink* pSink = new CEventLogSink(m_pObject->m_pControl);

    if(pSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }
    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}


void* CEventLogConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else return NULL;
}

CEventLogSink::~CEventLogSink()
{
    if(m_hEventLog)
        DeregisterEventSource(m_hEventLog);

    if(m_aTemplates)
        delete [] m_aTemplates;
}

HRESULT CEventLogSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    // Get the information
    // ===================

    HRESULT hres;
    VARIANT v;
    VariantInit(&v);

    // Get the server and source
    // =========================

    WString wsServer;
    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_SERVER, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        wsServer = V_BSTR(&v);
    VariantClear(&v);

    WString wsSource;
    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_SOURCE, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_BSTR)
        wsSource = V_BSTR(&v);
    VariantClear(&v);

    m_hEventLog = RegisterEventSourceW(
        ( (wsServer.Length() == 0) ? NULL : (LPCWSTR)wsServer),
        wsSource);
    if(m_hEventLog == NULL)
    {
        ERRORTRACE((LOG_ESS, "Unable to register event source '%S' on server "
            "'%S'. Error code: %X\n", (LPCWSTR)wsSource, (LPCWSTR)wsServer,
            GetLastError()));
        return WBEM_E_FAILED;
    }

    // Get event parameters
    // ====================

    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_EVENTID, 0, &v, NULL, NULL);
    if(V_VT(&v) == VT_I4)
        m_dwEventId = V_I4(&v);
    else
        // This will mean we need to try to get the event information off of each
        // event class as it arrives.
        m_dwEventId = 0;
    
    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_TYPE, 0, &v, NULL, NULL);
    if(V_VT(&v) != VT_I4)
        return WBEM_E_INVALID_PARAMETER;
    m_dwType = V_I4(&v);
    
    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_CATEGORY, 0, &v, NULL, NULL);
    if(V_VT(&v) != VT_I4)
        m_dwCategory = 0;
    else
        m_dwCategory = V_I4(&v);

    if (m_dwCategory > 0xFFFF)
        return WBEM_E_INVALID_PARAMETER;


    // Get insertion strings
    // =====================

    // Only get this stuff if the logical consumer has an event id.
    if (m_dwEventId)
    {
        hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_NUMSTRINGS, 0, &v, 
                                        NULL, NULL);
        if(V_VT(&v) != VT_I4)
            return WBEM_E_INVALID_PARAMETER;
        m_dwNumTemplates = V_I4(&v);
    

        hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_STRINGS, 0, &v, NULL, NULL);
        if(FAILED(hres))
           return WBEM_E_INVALID_PARAMETER;

        // array of bstrs or null, else bail
        if ((V_VT(&v) != (VT_BSTR | VT_ARRAY)) && (V_VT(&v) != VT_NULL))
        {
            VariantClear(&v);
            return WBEM_E_INVALID_PARAMETER;
        }
    
        if ((V_VT(&v) == VT_NULL) && (m_dwNumTemplates > 0))
            return WBEM_E_INVALID_PARAMETER;

        if (m_dwNumTemplates > 0)
        {
            CVarVector vv(VT_BSTR, V_ARRAY(&v));
            VariantClear(&v);

            if (vv.Size() < m_dwNumTemplates)
                return WBEM_E_INVALID_PARAMETER;

            m_aTemplates = new CTextTemplate[m_dwNumTemplates];
            if(m_aTemplates == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            for(DWORD i = 0; i < m_dwNumTemplates; i++)
            {
                m_aTemplates[i].SetTemplate(vv.GetAt(i).GetLPWSTR());
            }
        }
    }

    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_DATANAME, 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres) && (v.vt == VT_BSTR) && (v.bstrVal != NULL))
    {    
        m_dataName = v.bstrVal;
    }

    VariantClear(&v);

    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_SIDNAME, 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres) && (v.vt == VT_BSTR) && (v.bstrVal != NULL))
    {    
        m_sidName = v.bstrVal;
    }

    VariantClear(&v);

    hres = pLogicalConsumer->Get(EVENTLOG_PROPNAME_CREATORSID, 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres))
    {
        HRESULT hDebug;
        
        long ubound;
        hDebug = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound);

        PVOID pVoid;
        hDebug = SafeArrayAccessData(V_ARRAY(&v), &pVoid);

        m_pSidCreator = new BYTE[ubound +1];
        if(m_pSidCreator == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if (m_pSidCreator)
            memcpy(m_pSidCreator, pVoid, ubound + 1);
        else
            return WBEM_E_OUT_OF_MEMORY;

        SafeArrayUnaccessData(V_ARRAY(&v));
    }
    VariantClear(&v);


    return S_OK;
}

HRESULT CEventLogSink::XSink::GetDatEmbeddedObjectOut(IWbemClassObject* pObject, WCHAR* objectName, IWbemClassObject*& pEmbeddedObject)
{
    HRESULT hr;
    
    VARIANT vObject;
    VariantInit(&vObject);
    
    hr = pObject->Get(objectName, 0, &vObject, NULL, NULL);

    if (FAILED(hr))
    {
        ERRORTRACE((LOG_ESS, "NT Event Log Consumer: could not retrieve %S, 0x%08X\n", objectName, hr));
    }
    else if ((vObject.vt != VT_UNKNOWN) || (vObject.punkVal == NULL) 
             || FAILED(vObject.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&pEmbeddedObject)))
    {
        ERRORTRACE((LOG_ESS, "NT Event Log Consumer: %S is not an embedded object\n", objectName));
        hr = WBEM_E_INVALID_PARAMETER;
    }

    VariantClear(&vObject);

    return hr;

}

HRESULT CEventLogSink::XSink::GetDatDataVariant(IWbemClassObject* pEventObj, WCHAR* dataName, VARIANT& vData)
{
    WCHAR* propName = NULL;
    IWbemClassObject* pDataObj = NULL;
    HRESULT hr = WBEM_S_NO_ERROR;
    
    // parse out data name
    WCHAR* pDot;
    if (pDot = wcschr(dataName, L'.'))
    {
        // found a dot, we're dealing with an embedded object
        // mask out dot to make our life easier
        *pDot = L'\0';

        WCHAR* pNextDot;
        pNextDot = wcschr(pDot+1, L'.');
        
        if (pNextDot)
        // we have a doubly embedded object, that's as deep as we support
        {
            // we now have three prop names with nulls between
            *pNextDot = '\0';
            IWbemClassObject* pIntermediateObj = NULL;

            if (SUCCEEDED(hr = GetDatEmbeddedObjectOut(pEventObj, dataName, pIntermediateObj)))
            {
                hr = GetDatEmbeddedObjectOut(pIntermediateObj, pDot +1, pDataObj);                
                pIntermediateObj->Release();
            }

            propName = pNextDot +1;

            // put dot back
            *pDot = L'.';

            // put dot dot back back
            *pNextDot = L'.';

        }
        else
        // we have a singly embedded object. cool.
        {
            hr = GetDatEmbeddedObjectOut(pEventObj, dataName, pDataObj);

            // put dot back
            *pDot = L'.';
        
            propName = pDot +1;
        }
    }
    else
    {
        // not an embedded object
        pDataObj = pEventObj;
        pDataObj->AddRef();

        propName = dataName;
    }

    if (SUCCEEDED(hr) && pDataObj)
    {
        if (FAILED(hr = pDataObj->Get(propName, 0, &vData, NULL, NULL)))
            ERRORTRACE((LOG_ESS, "NT Event Log Consumer: could not retrieve %S, 0x%08X\n", dataName, hr));
    }

    if (pDataObj)
        pDataObj->Release();

    return hr;
}

// assumes that dataName is a valid string
// retrieves data from event object
// upon return pData points at data contained in variant
// calls responsibility to clear variant (don't delete pData)
// void return, any errors are logged - we don't want to block an event log if we can avoid it
void CEventLogSink::XSink::GetDatData(IWbemClassObject* pEventObj, WCHAR* dataName, 
                                      VARIANT& vData, BYTE*& pData, DWORD& dataSize)
{
    pData = NULL;
    dataSize = 0;
    HRESULT hr;
    
    if (SUCCEEDED(GetDatDataVariant(pEventObj, dataName, vData)))
    {
        hr = VariantChangeType(&vData, &vData, 0, (VT_UI1 | VT_ARRAY));
        
        if (FAILED(hr) || (vData.vt != (VT_UI1 | VT_ARRAY)))
        {
            ERRORTRACE((LOG_ESS, "NT Event Log Consumer: %S cannot be converted to a byte array (0x%08X)\n", dataName, hr));
            VariantClear(&vData);
        }
        else
        // should be good to go!
        {            
            if (FAILED(hr = SafeArrayAccessData(vData.parray, (void**)&pData)))
            {
                ERRORTRACE((LOG_ESS, "NT Event Log Consumer: failed to access %S, 0x%08X\n", dataName, hr));
                VariantClear(&vData);
            }

            long lDataSize;
            SafeArrayGetUBound(vData.parray, 1, &lDataSize);
            dataSize = (DWORD)lDataSize + 1;
        }
    }
}

// assumes that dataName is a valid string
// retrieves data from event object
// void return, any errors are logged - we don't want to block an event log if we can avoid it
void CEventLogSink::XSink::GetDatSID(IWbemClassObject* pEventObj, WCHAR* dataName, PSID& pSid)
{
    HRESULT hr;

    VARIANT vData;
    VariantInit(&vData);

    pSid = NULL;
    
    if (SUCCEEDED(hr = GetDatDataVariant(pEventObj, dataName, vData)))
    {
        if (vData.vt == (VT_UI1 | VT_ARRAY))
        {
            BYTE* pData;
            
            // this should be a binary SID
            if (FAILED(hr = SafeArrayAccessData(vData.parray, (void**)&pData)))
                ERRORTRACE((LOG_ESS, "NT Event Log Consumer: failed to access %S, 0x%08X\n", dataName, hr));
            else
            {
                if (IsValidSid((PSID)pData))
                {
                    DWORD l = GetLengthSid((PSID)pData);
                    if (pSid = new BYTE[l])
                        CopySid(l, pSid, (PSID)pData);
                }
            }
        }
        else if ((vData.vt == VT_BSTR) && (vData.bstrVal != NULL))
        {            
            PSID pLocalSid;

            if (!ConvertStringSidToSid(vData.bstrVal, &pLocalSid))
                ERRORTRACE((LOG_ESS, "NT Event Log Consumer: cannot convert %S to a SID\n", vData.bstrVal));
            else
            {
                DWORD l = GetLengthSid(pLocalSid);
                if (pSid = new BYTE[l])
                    CopySid(l, pSid, pLocalSid);             
                FreeSid(pLocalSid);
            }
        }
        else
            ERRORTRACE((LOG_ESS, "NT Event Log Consumer: %S is not a SID\n", dataName));
    
        VariantClear(&vData);    
    }
}


HRESULT STDMETHODCALLTYPE CEventLogSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if (IsNT())
    {
        PSID pSidSystem;
        SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
 
        if  (AllocateAndInitializeSid(&id, 1,
            SECURITY_LOCAL_SYSTEM_RID, 
            0, 0,0,0,0,0,0,&pSidSystem))
        {         
            // guilty until proven innocent
            hr = WBEM_E_ACCESS_DENIED;

            // check to see if sid is either Local System or an admin of some sort...
            if ((EqualSid(pSidSystem, m_pObject->m_pSidCreator)) ||
                (S_OK == IsUserAdministrator(m_pObject->m_pSidCreator)))
                hr = WBEM_S_NO_ERROR;
          
            // We're done with this
            FreeSid(pSidSystem);

            if (FAILED(hr))
                return hr;
        }
        else
            return WBEM_E_OUT_OF_MEMORY;
    }
    
    for(int i = 0; i < lNumObjects; i++)
    {
        int  j;
        BOOL bRes = FALSE;
        
        // Do all events use the same ID?
        if (m_pObject->m_dwEventId)
        {
            BSTR* astrStrings = new BSTR[m_pObject->m_dwNumTemplates];
            if(astrStrings == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            for(j = 0; j < m_pObject->m_dwNumTemplates; j++)
            {
                BSTR strText = m_pObject->m_aTemplates[j].Apply(apObjects[i]);
                if(strText == NULL)
                {
                    strText = SysAllocString(L"invalid log entry");
                    if(strText == NULL)
                        return WBEM_E_OUT_OF_MEMORY;
                }
                astrStrings[j] = strText;
            }

            DWORD dataSize = NULL;
            
            // data is actually held in the variant
            // pData just makes access easier (clear the variant, don't delete pData!)
            VARIANT vData;
            VariantInit(&vData);
            BYTE *pData = NULL;

            PSID pSid = NULL;

            if (m_pObject->m_dataName.Length() > 0)
                GetDatData(apObjects[i], m_pObject->m_dataName, vData, pData, dataSize);

            if (m_pObject->m_sidName.Length() > 0)
                GetDatSID(apObjects[i], m_pObject->m_sidName, pSid);

            bRes = ReportEventW(m_pObject->m_hEventLog, m_pObject->m_dwType,
                m_pObject->m_dwCategory, m_pObject->m_dwEventId, pSid,
                m_pObject->m_dwNumTemplates, dataSize, 
                (LPCWSTR*)astrStrings, pData);

            // sid was allocated as an array of BYTE, not via AllocateAndInitializeSid
            if (pSid)
                delete[] pSid;
             
            if (vData.vt == (VT_UI1 | VT_ARRAY))
                SafeArrayUnaccessData(vData.parray);

            VariantClear(&vData);
            pData = NULL;

            if(!bRes)
            {
                ERRORTRACE((LOG_ESS, "Failed to log an event: %X\n", 
                    GetLastError()));

                hr = WBEM_E_FAILED;
            }


            for(j = 0; j < m_pObject->m_dwNumTemplates; j++)
            {
                SysFreeString(astrStrings[j]);
            }
            delete [] astrStrings;
        }
        // If each event supplies its own ID, we have some work to do.
        else
        {
            IWbemQualifierSet *pQuals = NULL;

            if (SUCCEEDED(apObjects[i]->GetQualifierSet(&pQuals)))
            {
                _variant_t vMsgID;
                
                if (SUCCEEDED(pQuals->Get(
                    EVENTLOG_PROPNAME_EVENTID, 0, &vMsgID, NULL)))
                {
                    _variant_t vTemplates;
                    BSTR       *pstrInsertionStrings = NULL;
                    DWORD      nStrings = 0;

                    if (SUCCEEDED(pQuals->Get(
                        EVENTLOG_PROPNAME_STRINGS, 0, &vTemplates, NULL)) &&
                        vTemplates.vt == (VT_ARRAY | VT_BSTR) && 
                        vTemplates.parray->rgsabound[0].cElements > 0)
                    {
                        CTextTemplate *pTemplates;

                        nStrings = vTemplates.parray->rgsabound[0].cElements;
                        pTemplates = new CTextTemplate[nStrings];
                        if(pTemplates == NULL)
                            return WBEM_E_OUT_OF_MEMORY;
                    
                        pstrInsertionStrings = new BSTR[nStrings];
                        if(pstrInsertionStrings == NULL)
                        {
                            delete [] pTemplates;
                            return WBEM_E_OUT_OF_MEMORY;
                        }

                        if (pTemplates && pstrInsertionStrings)
                        {
                            BSTR *pTemplateStrings = (BSTR*) vTemplates.parray->pvData;

                            for (j = 0; j < nStrings; j++)
                            {
                                pTemplates[j].SetTemplate(pTemplateStrings[j]);
                                pstrInsertionStrings[j] = pTemplates[j].Apply(apObjects[i]);
                            }
                        }
                        else
                            nStrings = 0;

                        if (pTemplates)
                            delete [] pTemplates;
                    }

                    
                    DWORD      dwEventID,
                               dwType,
                               dwCategory;
                    _variant_t vTemp;
                    WCHAR      *szBad;

                    if (vMsgID.vt == VT_BSTR)
                        dwEventID = wcstoul(V_BSTR(&vMsgID), &szBad, 10);
                    else if (vMsgID.vt == VT_I4)
                        dwEventID = V_I4(&vMsgID);

                    if (SUCCEEDED(pQuals->Get(
                        EVENTLOG_PROPNAME_TYPE, 0, &vTemp, NULL)))
                        dwType = V_I4(&vTemp);
                    else
                        dwType = m_pObject->m_dwType;

                    if (SUCCEEDED(pQuals->Get(
                        EVENTLOG_PROPNAME_CATEGORY, 0, &vTemp, NULL)))
                        dwCategory = V_I4(&vTemp);
                    else
                        dwCategory = m_pObject->m_dwCategory;

                    DWORD dataSize = NULL;
                    // data is actually held in the variant
                    // pData just makes access easier (clear the variant, don't delete pData!)
                    VARIANT vData;
                    VariantInit(&vData);
                    BYTE *pData = NULL;
                    PSID pSid = NULL;

                    if (m_pObject->m_dataName.Length() > 0)
                        GetDatData(apObjects[i], m_pObject->m_dataName, vData, pData, dataSize);

                    if (m_pObject->m_sidName.Length() > 0)
                        GetDatSID(apObjects[i], m_pObject->m_sidName, pSid);

                    bRes =
                        ReportEventW(
                            m_pObject->m_hEventLog, 
                            dwType,
                            dwCategory, 
                            dwEventID, 
                            pSid,
                            nStrings, 
                            dataSize, 
                            (LPCWSTR*) pstrInsertionStrings, 
                            pData);

                    // sid was allocated as an array of BYTE, not via AllocateAndInitializeSid
                    if (pSid)
                        delete[] pSid;

                    if (vData.vt == (VT_UI1 | VT_ARRAY))
                        SafeArrayUnaccessData(vData.parray);

                    VariantClear(&vData);
                    pData = NULL;

                    if (!bRes)
                    {
                        ERRORTRACE((LOG_ESS, "Failed to log an event: %X\n", 
                            GetLastError()));

                        hr = WBEM_E_FAILED;
                    }

                    for (j = 0; j < nStrings; j++)
                        SysFreeString(pstrInsertionStrings[j]);

                } // SUCCEEDED(Get)
                
                pQuals->Release();
            
            } // SUCCEEDED(GetQualifierSet)
        }

    }

    return hr;
}
    

    

void* CEventLogSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\emailmapi.h ===
#ifndef __WBEM_EMAIL_CONSUMER__H_
#define __WBEM_EMAIL_CONSUMER__H_

#include <unk.h>


#include <wbemidl.h>
#include <mapix.h>

#include "txttempl.h"

class CEmailConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CEmailConsumer>
    {
    public:
        XProvider(CEmailConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CEmailConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

protected:
    HANDLE m_hAttention;
    HANDLE m_hDone;
    HANDLE m_hThread;
    IWbemClassObject* m_pLogicalConsumer;
    IStream* m_pStream;

    static DWORD staticWorker(void*);
    void Worker();
public:
    CEmailConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL);
    ~CEmailConsumer();
    void* GetInterface(REFIID riid);
};


class CEmailSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CEmailSink>
    {
    public:
        XSink(CEmailSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CEmailSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    IMAPISession* m_pSession;
    IMAPIFolder* m_pOutbox;
    IMsgStore* m_pStore;
    IAddrBook* m_pAddrBook;
    ADRLIST* m_pAddrList;

    CTextTemplate m_SubjectTemplate;
    CTextTemplate m_MessageTemplate;

    WString m_wsProfile;
    WString m_wsAddressee;

public:
    CEmailSink(CLifeControl* pControl = NULL);
    ~CEmailSink();

    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\mapisdk.cpp ===
#include "mapisdk.h"
#include <stdio.h>
#include <wstring.h>

//
//  Open the default message store. (The one that has PR_DEFAULT_STORE set to
//  TRUE in the message store table.
//
HRESULT HrOpenDefaultStore(IMAPISession* pses, IMsgStore** ppmdb)
{
    HRESULT hr;
    LPMDB lpmdb = NULL;
    LPMAPITABLE ptable = NULL;
    LPSRowSet prows = NULL;
    LPSPropValue pvalProp = NULL;
    static SizedSPropTagArray(2, columns) =
                { 2, { PR_DEFAULT_STORE, PR_ENTRYID} };
    SPropValue valDefStore;
    SRestriction restDefStore;

    valDefStore.ulPropTag = PR_DEFAULT_STORE;
    valDefStore.dwAlignPad = 0;
    valDefStore.Value.b = TRUE;

    restDefStore.rt = RES_PROPERTY;
    restDefStore.res.resProperty.relop = RELOP_EQ;
    restDefStore.res.resProperty.ulPropTag = PR_DEFAULT_STORE;
    restDefStore.res.resProperty.lpProp = &valDefStore;

    hr = pses->GetMsgStoresTable(0, &ptable);
    if (HR_FAILED(hr))
    {
        goto ret;
    }

    hr = HrQueryAllRows(ptable, (LPSPropTagArray) &columns, &restDefStore, 
                            NULL, 0, &prows);
    if (HR_FAILED(hr))
    {
        goto ret;
    }

    if (prows == NULL || prows->cRows == 0
        || prows->aRow[0].lpProps[1].ulPropTag != PR_ENTRYID)
    {
        goto ret;
    }

    hr = pses->OpenMsgStore(0,
                        prows->aRow[0].lpProps[1].Value.bin.cb,
                        (LPENTRYID)prows->aRow[0].lpProps[1].Value.bin.lpb,
                        NULL, MDB_WRITE | MDB_NO_DIALOG, &lpmdb);
    if (HR_FAILED(hr))
    {
        if (GetScode(hr) != MAPI_E_USER_CANCEL)
        goto ret;
    }

    *ppmdb = lpmdb;



ret:
    FreeProws(prows);
    UlRelease(ptable);

    return hr;
}

//
//  Open MAPI address book
//
HRESULT HrOpenAddressBook(IMAPISession* pses, IAddrBook** ppAddrBook)
{
    HRESULT hr;
    LPADRBOOK pabAddrBook = NULL;

    hr = pses->OpenAddressBook(0, NULL, 0, &pabAddrBook);
    if(HR_FAILED(hr))
    {
        return hr;
    }

    *ppAddrBook = pabAddrBook;

    return hrSuccess;
}

//
//  Open the outbox of the default store.
//  Assumes the default message store has been opened.
//
HRESULT HrOpenOutFolder(IMsgStore* pmdb, IMAPIFolder** lppF)
{
    LPMAPIFOLDER lpfOutF = NULL;
    HRESULT hr;
    LPSPropValue lpspvFEID = NULL;
    ULONG  ulObjType = 0;

    *lppF = NULL;
    hr = HrGetOneProp((LPMAPIPROP) pmdb, PR_IPM_OUTBOX_ENTRYID, &lpspvFEID);
    if(hr)
    {
        goto err;
    }

    hr = pmdb->OpenEntry(lpspvFEID->Value.bin.cb,
                        (LPENTRYID)lpspvFEID->Value.bin.lpb, NULL,
                        MAPI_MODIFY | MAPI_DEFERRED_ERRORS,
                        &ulObjType, (LPUNKNOWN FAR *) &lpfOutF);
    if(HR_FAILED(hr))
    {
        goto err;
    }

    *lppF = lpfOutF;

err:
    MAPIFreeBuffer(lpspvFEID);

    return hr;

}

//
//  Create a message in the outbox
//
HRESULT HrCreateOutMessage(IMAPIFolder* pfldOutBox, IMessage** ppmM)
{

    LPMESSAGE lpmResM = NULL;
    HRESULT hr;

    hr = pfldOutBox->CreateMessage(NULL, MAPI_DEFERRED_ERRORS, &lpmResM);
    if(HR_FAILED(hr))
    {
        return hr;
    }

    *ppmM = lpmResM;

    return S_OK;
}


//
//  Create an adrlist with resolved recipients
//
HRESULT HrCreateAddrList(LPWSTR wszAddressee, IAddrBook* pAddrBook, 
                            LPADRLIST * ppal)
{
    WString wsAddressee = wszAddressee;

    HRESULT hr;
    LPADRLIST pal = NULL;

    int cb = CbNewADRLIST(1);

    hr = MAPIAllocateBuffer(cb, (LPVOID FAR *) &pal);
    if(hr)
    {
        goto err;
    }

    ZeroMemory(pal, cb);

    hr = MAPIAllocateBuffer(2 * sizeof(SPropValue),
                            (LPVOID FAR *)&pal->aEntries[0].rgPropVals);
    if(hr)
    {
        goto err;
    }

    pal->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    pal->aEntries[0].rgPropVals[0].Value.lpszA = wsAddressee.GetLPSTR();
    pal->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    pal->aEntries[0].rgPropVals[1].Value.l= MAPI_TO;
    pal->aEntries[0].cValues = 2;
    pal->cEntries = 1;

    hr = pAddrBook->ResolveName(0, 0, NULL, pal);
    if(HR_FAILED(hr))
    {
        goto err;
    }

    *ppal = pal;

err:

    return hr;
}


//
//  Put the data from globals in the message
//
HRESULT HrInitMsg(IMessage* pmsg, ADRLIST* pal, 
                    LPWSTR wszSubject, LPWSTR wszMessage)
{
    WString wsSubject = wszSubject;
    WString wsMessage = wszMessage;

    HRESULT hr;
    enum {iSubj, iSentMail, iConvTopic, iConvIdx, iMsgClass, iMsgText, cProps};
    // PR_SUBJECT, PR_SENTMAIL_ENTRYID,
    // PR_CONVERSATION_TOPIC, PR_COVERSATION_INDEX

    SPropValue props[cProps];
    ULONG cbConvIdx = 0;
    LPBYTE lpbConvIdx = NULL;

    hr = pmsg->ModifyRecipients(0, pal);
    if(HR_FAILED(hr))
    {
        goto err;
    }

    //subject  and conversation topic
    props[iSubj].ulPropTag = PR_SUBJECT;
    props[iSubj].Value.lpszA = wsSubject.GetLPSTR();

    props[iConvTopic].ulPropTag = PR_CONVERSATION_TOPIC;
    props[iConvTopic].Value.lpszA = wsSubject.GetLPSTR();

    props[iConvIdx].ulPropTag = PR_NULL;

    props[iSentMail].ulPropTag = PR_NULL;

    props[iMsgClass].ulPropTag = PR_MESSAGE_CLASS;
    props[iMsgClass].Value.lpszA = "IPM.Note";

    props[iMsgText].ulPropTag = PR_BODY;
    props[iMsgText].Value.lpszA = wsMessage.GetLPSTR();

    hr = pmsg->SetProps(cProps, (LPSPropValue)&props, NULL);
    if(HR_FAILED(hr))
    {
        goto err;
    }

err:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\logfile.cpp ===
#include "precomp.h"
#include "logfile.h"
#include <stdio.h>
#include <io.h>
#include <wbemutil.h>
#include <GroupsForUser.h>
#include <ArrTempl.h>
#include <GenUtils.h>
#include <sync.h>
#include <errno.h>

#define LOGFILE_PROPNAME_FILENAME L"Filename"
#define LOGFILE_PROPNAME_TEXT L"Text"
#define LOGFILE_PROPNAME_MAX_SIZE L"MaximumFileSize"
#define LOGFILE_PROPNAME_IS_UNICODE L"IsUnicode"

const char ByteOrderMark[2] = {'\xFF','\xFE'};

CCritSec fileLock;

HRESULT STDMETHODCALLTYPE CLogFileConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    // Create a new sink
    // =================

    CLogFileSink* pSink = new CLogFileSink(m_pObject->m_pControl);
    if (!pSink)
        return WBEM_E_OUT_OF_MEMORY;

    // Initialize it
    // =============

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }

    // return it

    else return pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
}


HRESULT STDMETHODCALLTYPE CLogFileConsumer::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink* pSink)
{
    pSink->SetStatus(0, 0);
    return 0;
}
    

void* CLogFileConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}

CLogFileSink::~CLogFileSink()
{
    if(m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);
}

// determine whether file needs to be backed up
// returns false if we are not expected to back up file
bool CLogFileSink::IsFileTooBig(UINT64 maxFileSize, HANDLE hFile)
{   
    bool bRet = false;

    // zero is interpreted to mean 'Let it grow without bounds'
    if (maxFileSize > 0)
    {    
		LARGE_INTEGER size;

		if (GetFileSizeEx(hFile, &size))
			bRet = size.QuadPart > maxFileSize;
    }

    return bRet;
}

bool CLogFileSink::IsFileTooBig(UINT64 maxFileSize, WString& fileName)
{
    bool bRet = false;

    // zero is interpreted to mean 'Let it grow without bounds'
    if (maxFileSize > 0)
    {
        struct _wfinddatai64_t foundData;

        __int64 handle;
        handle = _wfindfirsti64( (wchar_t *)fileName, &foundData);
        if (handle != -1l)
        {
            bRet = foundData.size >= maxFileSize;
            _findclose(handle);
        }
    }

    return bRet;
}


bool CLogFileSink::GetNumericExtension(WCHAR* pName, int& foundNumber)
{
    WCHAR foundExtension[_MAX_EXT];
    _wsplitpath(pName, NULL, NULL, NULL, foundExtension);
    
    return (swscanf(foundExtension, L".%d", &foundNumber) == 1);
}

// makes backup of file
// file must be closed when this is called
HRESULT CLogFileSink::ArchiveFile(WString& fullName)
{    
	// first, let's make sure the dang file actually exists...
    struct _wfinddatai64_t foundData;
    __int64 findHandle;
   if ((findHandle = _wfindfirsti64( fullName, &foundData)) == -1i64)
   {
        if (GetLastError() == ENOENT)
            return WBEM_S_NO_ERROR;
        else
            return WBEM_E_FAILED;
   }
   else
       _findclose(findHandle);

    
    WCHAR drive[_MAX_DRIVE];
    WCHAR dir[_MAX_DIR];
    WCHAR fname[_MAX_FNAME];
    WCHAR ext[_MAX_EXT];

    // warning: reused, it'll be the mask for the lookup
    // then it'll be the new file name.
    WCHAR pathBuf[MAX_PATH +1];
    
    _wsplitpath( (const wchar_t *)fullName, drive, dir, fname, ext );

    bool bItEightDotThree = (wcslen(fname) <= 8) && (wcslen(ext) <= 4);
    // eightdot three file names are backed up to name.###
    // NON eight dotthree are backed up to name.ext.###

    // build mask for lookup
    wcscpy(pathBuf, drive);
    wcscat(pathBuf, dir);
    wcscat(pathBuf, fname);

    if (!bItEightDotThree)
    {
        // there's a possibility that the filename would be too long
        // if we appended four chars.  Will trunc if needed
        if ((wcslen(pathBuf) + wcslen(ext) + 4) > MAX_PATH)
        {
            // see if we can get away with just dropping the ext
            if ((wcslen(pathBuf) + 4) > MAX_PATH)
                pathBuf[MAX_PATH -4] = L'\0';
        }
        else
        // everything fits, no trunc needed
            wcscat(pathBuf, ext);
    }
    // and the dotstar goes on the end, no matter what.
    wcscat(pathBuf, L".*");

    // pathbuf is now the proper mask to lookup stuff.
    int biggestOne = 0; 
    bool foundOne = false;
    bool foundOnes[1000];
    // keep track of which ones we found
    // just in case we have to go back & find a hole
    // using 1000 so I don't have to convert all the time.
    ZeroMemory(foundOnes, sizeof(bool) * 1000);

    if ((findHandle = _wfindfirsti64( pathBuf, &foundData)) != -1i64)
    {
        int latestOne;

        if (foundOne = GetNumericExtension(foundData.name, latestOne))
        {
            if (latestOne <= 999)
            {
                foundOnes[latestOne] = true;
                if (latestOne > biggestOne)
                    biggestOne = latestOne;
            }
        }

        while (0 == _wfindnexti64(findHandle, &foundData))
        {
            if (GetNumericExtension(foundData.name, latestOne) && (latestOne <= 999))
            {   
                foundOne = true;
                foundOnes[latestOne] = true;
                if (latestOne > biggestOne)
                    biggestOne = latestOne;
            }
        }
    }

    int newExt = -1;

    if (foundOne)
        if (biggestOne < 999)
            newExt = biggestOne + 1;
        else
        {
            newExt = -1;

            // see if there's a hole somewhere
            for (int i = 1; i <= 999; i++)
                if (!foundOnes[i]) 
                {
                    newExt = i;
                    break;
                }
        }
    
    WCHAR *pTok;
    pTok = wcschr(pathBuf, L'*');

	// "can't happen" - the asterisk is added approximately 60 lines up
	// however, we'll go ahead & do the check - will make PREFIX happy if nothing else.
	if (!pTok)
		return WBEM_E_CRITICAL_ERROR;

    if (newExt != -1)
    {
        // construct new name
        // we want to replace the * with ###
        swprintf(pTok, L"%03d", newExt);
    }
    else
    // okay, we'll hammer an old file
    {
        wcscpy(pTok, L"001");

        _wremove(pathBuf);
    }
    
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL bRet;
	//int retval = _wrename(fullName, pathBuf);
	{
		bRet = MoveFile(fullName, pathBuf);
	}
	
	if (!bRet)
	{
		ERRORTRACE((LOG_ESS, "MoveFile failed 0x%08X\n", GetLastError()));
		hr = WBEM_E_FAILED;
	}

    return hr;
}


// determines whether file is too large, archives old if needed
// use this function rather than accessing the file pointer directly
HANDLE CLogFileSink::GetFileHandle(void)
{
	CInCritSec lockMe(&fileLock);		

    if (m_hFile != INVALID_HANDLE_VALUE)
	{

		if (IsFileTooBig(m_maxFileSize, m_hFile))
		{
			// two possibilities: we have ahold of logfile.log OR we've got logfile.001			
			
			CloseHandle(m_hFile);
			m_hFile = INVALID_HANDLE_VALUE;
			
			HRESULT hr = WBEM_S_NO_ERROR;
			if (IsFileTooBig(m_maxFileSize, m_wsFile))
				 hr = ArchiveFile(m_wsFile);

			if (FAILED(hr))
				return INVALID_HANDLE_VALUE;
		}
	}
	else
	{
		
		if (IsFileTooBig(m_maxFileSize, m_wsFile))
		{
			HRESULT hr = ArchiveFile(m_wsFile);
			if (FAILED(hr))
				return INVALID_HANDLE_VALUE;
		}	
	}
    
    if (m_hFile == INVALID_HANDLE_VALUE)
    {

        // Open the file
        // =============
        // we'll try opening an existing file first

		m_hFile = CreateFile(m_wsFile, GENERIC_READ | GENERIC_WRITE, 
			                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
							 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

		/******** old way **************************
        // Unicode files are opened in binary mode
        if (m_bUnicode)
            m_pFile = _wfopen(m_wsFile, L"rb+");
        else
            m_pFile = _wfopen(m_wsFile, L"r+");
		********************************************/

        
        if(m_hFile != INVALID_HANDLE_VALUE)
        {
            // now, take a looksee and determine whether the existing file is unicode
            // *regardless* of what the flag says
            char readbuf[2] = {'\0','\0'};
			DWORD bytesRead;
            
            // if (fread(&readbuf, sizeof(WCHAR), 1, m_pFile) > 0)
			if (ReadFile(m_hFile, &readbuf, sizeof(WCHAR), &bytesRead, NULL) &&
			    (bytesRead == sizeof(WCHAR)))
            {
                // only interesting cases are those where the flag
                // doesn't match what's in the file...
                if ((readbuf[0] == ByteOrderMark[0]) && (readbuf[1] == ByteOrderMark[1])
					&& !m_bUnicode)
                    m_bUnicode = true;
                else if (((readbuf[0] != ByteOrderMark[0]) || (readbuf[1] != ByteOrderMark[1])) && m_bUnicode)
                    m_bUnicode = false;
            }

            // line up at the end of the file
            SetFilePointer(m_hFile, 0,0, FILE_END);        
        }
        else
        {
            // ahhh - it wasn't there, for whatever reason.
			/*************************************
            if (m_bUnicode)
                m_pFile = _wfopen(m_wsFile, L"ab");
            else
                m_pFile = _wfopen(m_wsFile, L"a");
			**************************************/

			m_hFile = CreateFile(m_wsFile, GENERIC_READ | GENERIC_WRITE, 
			                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
							 NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

            if (m_hFile != INVALID_HANDLE_VALUE)
            {
				DWORD bytesWryt;
                if (m_bUnicode)
				{
					if (0 == WriteFile(m_hFile, (LPCVOID)ByteOrderMark, 2, &bytesWryt, NULL))
						ERRORTRACE((LOG_ESS, "Failed to write byte order mark to log file 0x%08X\n", GetLastError()));
				}
            }
            else
                ERRORTRACE((LOG_ESS, "Unable to open log file %S, [0x%X]\n", (LPWSTR)m_wsFile, GetLastError()));
        }
    }

    return m_hFile;
}

// initialize members, do security check.
// a tidier programmer would probably move the security check to a separate function
HRESULT CLogFileSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    // Get the information
    // ===================

    HRESULT hres;
    VARIANT v;
    VariantInit(&v);

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_FILENAME, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;

    size_t length;
    length = wcslen(v.bstrVal);
    if ((length > MAX_PATH) || (length == 0))
        return WBEM_E_INVALID_PARAMETER;                                 

    m_wsFile = V_BSTR(&v);

    // check for disallowed filenames
    VariantClear(&v);
    m_wsFile.StripWs(WString::leading);
    if (m_wsFile.Length() == 0)
        return WBEM_E_INVALID_PARAMETER;

    // UNC global file names: no-no.
    if (wcsstr(m_wsFile, L"\\\\."))
        return WBEM_E_ACCESS_DENIED;
    if (wcsstr(m_wsFile, L"//."))
        return WBEM_E_ACCESS_DENIED;
    if (wcsstr(m_wsFile, L"\\\\??"))
        return WBEM_E_ACCESS_DENIED;
    if (wcsstr(m_wsFile, L"//??"))
        return WBEM_E_ACCESS_DENIED;

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_TEXT, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;
    m_Template.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_IS_UNICODE, 0, &v, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_PARAMETER;
    else if (V_VT(&v) == VT_BOOL)
        m_bUnicode = v.boolVal == VARIANT_TRUE;
    else if (V_VT(&v) == VT_NULL)
        m_bUnicode = false;
    else
        return WBEM_E_INVALID_PARAMETER;
    VariantClear(&v);

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_MAX_SIZE, 0, &v, NULL, NULL);

    if (FAILED(hres))
        return WBEM_E_INVALID_PARAMETER;
    else if (V_VT(&v) == VT_BSTR)
    {
        if (!ReadUI64(V_BSTR(&v), m_maxFileSize))
           return WBEM_E_INVALID_PARAMETER;
    }
    else if (V_VT(&v) == VT_NULL)
        m_maxFileSize = 65535;
    else
        return WBEM_E_INVALID_PARAMETER;
        
    VariantClear(&v);

    // Determine whether user has rights to file
    // =========================================
    // first determine who is our creator...
    hres = pLogicalConsumer->Get(L"CreatorSid", 0, &v,
            NULL, NULL);
    if (SUCCEEDED(hres))
    {
        HRESULT hDebug;
        long ubound;

        hDebug = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound);

        PVOID pVoid;
        hDebug = SafeArrayAccessData(V_ARRAY(&v), &pVoid);

        PSID pSidCreator;

        pSidCreator = new BYTE[ubound +1];
        if (pSidCreator)
            memcpy(pSidCreator, pVoid, ubound + 1);
        else
            return WBEM_E_OUT_OF_MEMORY;

        CDeleteMe<BYTE> deleteTheCreator((BYTE*)pSidCreator);
        SafeArrayUnaccessData(V_ARRAY(&v));
        VariantClear(&v);

        BOOL bIsSystem;
        // check to see if the creator is The System
        {
            PSID pSidSystem;
            SID_IDENTIFIER_AUTHORITY sa = SECURITY_NT_AUTHORITY;
            if (AllocateAndInitializeSid(&sa, 1, SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0, &pSidSystem))
            {
                bIsSystem = EqualSid(pSidCreator, pSidSystem);
                FreeSid(pSidSystem);
            }
            else 
                return WBEM_E_FAILED;
        }
        
        if (bIsSystem)
            // creator is local system, let him in.
            hres = WBEM_S_NO_ERROR;
        else
        {
            DWORD dwSize;
            WString fNameForCheck = m_wsFile;
            // call once to see how big a buffer we might need
            GetFileSecurityW(fNameForCheck, DACL_SECURITY_INFORMATION, NULL, 0, &dwSize);
            DWORD dwErr = GetLastError();
            if (dwErr == ERROR_INVALID_NAME)
                return WBEM_E_INVALID_PARAMETER;
            else if (dwErr == ERROR_FILE_NOT_FOUND)
            // no file - see if directory exists
            {
                WCHAR drive[_MAX_DRIVE];
                WCHAR dir[_MAX_DIR];
                _wsplitpath( m_wsFile,drive, dir, NULL, NULL);
                WCHAR path[MAX_PATH];
                wcscpy(path, drive);
                wcscat(path, dir);

                fNameForCheck = path;
                GetFileSecurityW(fNameForCheck, DACL_SECURITY_INFORMATION, NULL, 0, &dwSize);
                dwErr = GetLastError();
            }
            // we don't bother trying to create the directory.
            if ((dwErr == ERROR_FILE_NOT_FOUND)  || (dwErr == ERROR_PATH_NOT_FOUND) || (dwErr == ERROR_INVALID_NAME))
                return WBEM_E_INVALID_PARAMETER;

            if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                return WBEM_E_FAILED;
        
            PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];
            if (!psd)
                return WBEM_E_OUT_OF_MEMORY;
        
            PACL pDacl = NULL;
            BOOL bDaclPresent, bDaclDefaulted;
            // retrieve file's security, if any
            if (GetFileSecurityW(fNameForCheck, DACL_SECURITY_INFORMATION, psd, dwSize, &dwSize) &&
                GetSecurityDescriptorDacl(psd, &bDaclPresent, &pDacl, &bDaclDefaulted))
            {
                if (bDaclPresent && pDacl)
                {
                    DWORD accessMask;
                    if (S_OK == GetAccessMask(pSidCreator, pDacl, &accessMask))
                    {
                        DWORD rightAccess = GENERIC_WRITE | FILE_WRITE_DATA;

                        if (!(accessMask & rightAccess))
                        {
                            HRESULT hr = ArchiveFile(m_wsFile);
                            if (FAILED(hr))
                                return hr;
                        }
                    }
                    else
                        return WBEM_E_ACCESS_DENIED;
                }
            }
            else
                return WBEM_E_FAILED;
        }

    }
    
    return hres;
}

HRESULT STDMETHODCALLTYPE CLogFileSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    for(int i = 0; i < lNumObjects; i++)
    {
        // Apply the template to the event
        // ===============================
        BSTR strText = m_pObject->m_Template.Apply(apObjects[i]);
        if(strText == NULL)
            strText = SysAllocString(L"invalid log entry");
        if (strText == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CSysFreeMe freeString(strText);

        HANDLE hFile = m_pObject->GetFileHandle();

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (FILE_TYPE_DISK != GetFileType(hFile))
                return WBEM_E_ACCESS_DENIED;

            if (m_pObject->m_bUnicode)
            {
				CInCritSec lockMe(&fileLock);
				WCHAR EOL[] = L"\r\n";

                // make sure we're at the end, in case of multiple writers
	            SetFilePointer(hFile, 0,0, FILE_END);        

				DWORD bitzwritz;
				if (!WriteFile(hFile, strText, wcslen(strText) *2, &bitzwritz, NULL) ||
					!WriteFile(hFile, EOL, wcslen(EOL) *2, &bitzwritz, NULL))
				{
					ERRORTRACE((LOG_ESS, "LOGFILE: Failed to write to file, 0x%08X\n", GetLastError()));
					return WBEM_E_FAILED;
				}
            }
            else
            {
                // convert to mbcs
                char* pStr = new char[wcslen(strText) *2 +1];
                
                if (!pStr)
                    return WBEM_E_OUT_OF_MEMORY;
                // else...
                CDeleteMe<char> delStr(pStr);

                if (-1 == wcstombs(pStr, strText, wcslen(strText) *2 +1))
                    ERRORTRACE((LOG_ESS, "LOGFILE: Unable to completely convert \"%S\" to MBCS, continuing\n", strText));

    			{
					CInCritSec lockMe(&fileLock);

					char EOL[] = "\r\n";

					// make sure we're at the end, in case of multiple writers
					SetFilePointer(hFile, 0,0, FILE_END);        

					DWORD bitzwritz;
					if (!WriteFile(hFile, pStr, strlen(pStr), &bitzwritz, NULL) ||
						!WriteFile(hFile, EOL, strlen(EOL), &bitzwritz, NULL))
					{
						ERRORTRACE((LOG_ESS, "LOGFILE: Failed to write to file, 0x%08X\n", GetLastError()));
						return WBEM_E_FAILED;
					}
				}
            }            
        }
        else
            return WBEM_E_FAILED;
    }
    return S_OK;
}
    

    

void* CLogFileSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\mapisdk.h ===
#ifndef __WBEM_MAPI_SDK__H_
#define __WBEM_MAPI_SDK__H_

#define WBEM_SERVICE
#ifdef WBEM_SERVICE
#define WBEM_MAPI_FLAGS MAPI_NT_SERVICE
#define WBEM_MAPI_LOGON_FLAGS (WBEM_MAPI_FLAGS | MAPI_NO_MAIL)
#else
#define WBEM_MAPI_FLAGS 0
#define WBEM_MAPI_LOGON_FLAGS 0
#endif

#include <mapiutil.h>

HRESULT HrOpenDefaultStore(IMAPISession* pses, IMsgStore** ppmdb);
HRESULT HrOpenAddressBook(IMAPISession* pses, IAddrBook** ppAddrBook);
HRESULT HrOpenOutFolder(IMsgStore* pmdb, IMAPIFolder** lppF);
HRESULT HrCreateOutMessage(IMAPIFolder* pfldOutBox, IMessage** ppmM);
HRESULT HrCreateAddrList(LPWSTR wszAddressee, IAddrBook* pAddrBook, 
                            LPADRLIST * ppal);
HRESULT HrInitMsg(IMessage* pmsg, ADRLIST* pal, 
                    LPWSTR wszSubject, LPWSTR wszMessage);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\logfile.h ===
#ifndef __WBEM_LOGFILE_CONSUMER__H_
#define __WBEM_LOGFILE_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include "txttempl.h"
#include <stdio.h>

class CLogFileConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CLogFileConsumer>
    {
    public:
        XProvider(CLogFileConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CLogFileConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CLogFileConsumer>
    {
    public:
        XInit(CLogFileConsumer* pObj)
            : CImpl<IWbemProviderInit, CLogFileConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;


public:
    CLogFileConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this)
    {}
    ~CLogFileConsumer(){}
    void* GetInterface(REFIID riid);
};


class CLogFileSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CLogFileSink>
    {
    public:
        XSink(CLogFileSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CLogFileSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    CTextTemplate m_Template;
    WString m_wsFile;

    // determines whether file is too large, archives old if needed
    // probably returns INVALID_HANDLE_VALUE on error
    HANDLE GetFileHandle(void);

    // don't access this directly. use GetFileHandle
	HANDLE m_hFile;

    bool  m_bUnicode;     // do the file be unicode?
    UINT64 m_maxFileSize;

    bool IsFileTooBig(UINT64 maxFileSize, HANDLE hFile);
	bool IsFileTooBig(UINT64 maxFileSize, WString& fileName);
    HRESULT ArchiveFile(WString& fileName);
    bool GetNumericExtension(WCHAR* pName, int& foundNumber);

	void OpenThisFile(WString fname, bool openExisting, bool allowDelete);
	void CloseCurrentFile();




public:
    CLogFileSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), 
		   m_hFile(INVALID_HANDLE_VALUE), 
           m_maxFileSize(0), m_bUnicode(false)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);
    ~CLogFileSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\main.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include "logfile.h"
#include "cmdline.h"
#include "evtlog.h"
#include "ProcKiller.h"
#include "msgbox.h"
#include "perf.h"
#include "pager.h"

#include <tchar.h>

const CLSID CLSID_WbemLogFileConsumer = 
    {0x266c72d4,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

const CLSID CLSID_WbemCommandLineConsumer = 
    {0x266c72e5,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

const CLSID CLSID_WbemNTEventLogConsumer = 
    {0x266c72e6,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

#ifdef INCLUDE_NON_PULSAR

    const CLSID CLSID_WbemPerformanceConsumer = 
        {0x266c72f8,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

    const CLSID CLSID_WbemMsgBoxConsumer = 
        {0x266c72d2,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

    // {C7A3A54A-0250-11d3-9CD1-00105A1F4801}
    const CLSID CLSID_WbemPagerConsumer = 
    { 0xc7a3a54a, 0x250, 0x11d3, { 0x9c, 0xd1, 0x0, 0x10, 0x5a, 0x1f, 0x48, 0x1 } };

#endif

//const CLSID CLSID_WbemEmailConsumer = 
//    {0x266c72d3,0x62e8,0x11d1,{0xad,0x89,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

class CMyServer : public CComServer
{
public: 

#ifdef ENABLE_REMOTING
	void RegisterMe(CLSID clsID, WCHAR* name)
	{    
        WCHAR      wcID[128];
        WCHAR      szKeyName[128];
        HKEY       hKey;

        // open/create registry entry under CLSID
        StringFromGUID2(clsID, wcID, 128);
        lstrcpy(szKeyName, TEXT("SOFTWARE\\Classes\\CLSID\\"));
        lstrcat(szKeyName, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        
        // set AppID
        RegSetValueEx(hKey, L"AppID", 0, REG_SZ, (BYTE*)wcID, 2*(wcslen(wcID) +1));
        RegCloseKey(hKey);

        // make appID entry w/ DLLSurrogate value
        lstrcpy(szKeyName, TEXT("SOFTWARE\\Classes\\APPID\\"));
        lstrcat(szKeyName, wcID);
        RegCreateKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);
        RegSetValueEx(hKey, L"DllSurrogate", 0, REG_SZ, (BYTE*)L"\0", 2);

        // and a nice name
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)name, 2*(wcslen(name) +1));
        RegCloseKey(hKey);
	}

    // provider server specific registration
    virtual void Register()
    {
		RegisterMe(CLSID_WbemLogFileConsumer, L"Microsoft WBEM Log File Event Consumer Provider");
		RegisterMe(CLSID_WbemCommandLineConsumer, L"Microsoft WBEM Command Line Event Consumer Provider");
		RegisterMe(CLSID_WbemNTEventLogConsumer, L"Microsoft WBEM NT Event Log Event Consumer Provider");
		
#ifdef INCLUDE_NON_PULSAR

		// NOTE: Of the non-pulsar componenets,
        //       Only the pager consumer is registered for remote activation
		//		 MessageBox & Performance consumer are not
		RegisterMe(CLSID_WbemPagerConsumer, L"Microsoft WBEM Pager Event Consumer Provider");


#endif // INCLUDE_NON_PULSAR


    }

	void UnregisterMe(CLSID clsID)
	{
		WCHAR      wcID[128];
        HKEY       hKey;

		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\APPID\\"), &hKey))
		{
			if (0 != StringFromGUID2(clsID, wcID, 128))
			{
				RegDeleteKey(hKey, wcID);
			}
			RegCloseKey(hKey);
		}

	}
	
	virtual void Unregister()
	{
		UnregisterMe(CLSID_WbemLogFileConsumer);
		UnregisterMe(CLSID_WbemCommandLineConsumer);
		UnregisterMe(CLSID_WbemNTEventLogConsumer);

#ifdef INCLUDE_NON_PULSAR

		// NOTE: Of the non-pulsar componenets,
        //       Only the pager consumer is registered for remote activation
		//		 MessageBox & Performance consumer are not
		UnregisterMe(CLSID_WbemPagerConsumer);

#endif // INCLUDE_NON_PULSAR


	}
#endif //ENABLE_REMOTING


protected:
    HRESULT Initialize()
    {
        g_procKillerTimer.Initialize(GetLifeControl());

        AddClassInfo(CLSID_WbemLogFileConsumer, 
            new CClassFactory<CLogFileConsumer>(GetLifeControl()),
            _T("Log File Event Consumer Provider"), TRUE);
        AddClassInfo(CLSID_WbemCommandLineConsumer, 
            new CClassFactory<CCommandLineConsumer>(GetLifeControl()), 
            _T("Command Line Event Consumer Provider"), TRUE);
        AddClassInfo(CLSID_WbemNTEventLogConsumer, 
            new CClassFactory<CEventLogConsumer>(GetLifeControl()), 
            _T("NT Event Log Event Consumer Provider"), TRUE);

#ifdef INCLUDE_NON_PULSAR
        AddClassInfo(CLSID_WbemMsgBoxConsumer, 
            new CClassFactory<CMsgBoxConsumer>(GetLifeControl()),
            "Message Box Event Consumer Provider", TRUE);

        AddClassInfo(CLSID_WbemPerformanceConsumer, 
            new CClassFactory<CPerfConsumer>(GetLifeControl()), 
            "Performance measurement Event Consumer Provider", TRUE);
        AddClassInfo(CLSID_WbemPagerConsumer,
            new CClassFactory<CPagerConsumer>(GetLifeControl()), 
            "Pager Event Consumer Provider", TRUE);
#endif // INCLUDE_NON_PULSAR
        return S_OK;
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\precomp.h ===
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\msgbox.h ===
#ifndef _WBEM_MSGBOX_CONSUMER__H_
#define _WBEM_MSGBOX_CONSUMER__H_

#include <windows.h>
#include <unk.h>
#include <wbemidl.h>

class CMsgBoxConsumer : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CMsgBoxConsumer>
    {
    public:
        XSink(CMsgBoxConsumer* pObj) : 
            CImpl<IWbemUnboundObjectSink, CMsgBoxConsumer>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;

public:
    CMsgBoxConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XSink(this)
    {}
    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\msgbox.cpp ===
#include "msgbox.h"
#include "txttempl.h"
#include <stdio.h>
#include <winuser.h>
#include <wbemutil.h>


#define MSGBOX_PROPNAME_TITLE L"Title"
#define MSGBOX_PROPNAME_TEXT L"Text"

HRESULT STDMETHODCALLTYPE CMsgBoxConsumer::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    HRESULT hres;

    // Examine the consumer object
    // ===========================

    // Get the message box title
    // =========================

    VARIANT v;
    VariantInit(&v);
    hres = pLogicalConsumer->Get(MSGBOX_PROPNAME_TITLE, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
    {
        VariantClear(&v);
        return hres;
    }

    BSTR strTitle = V_BSTR(&v);
    V_BSTR(&v) = NULL;

    // Get the message box text
    // ========================

    hres = pLogicalConsumer->Get(MSGBOX_PROPNAME_TEXT, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
    {
        SysFreeString(strTitle);
        VariantClear(&v);
        return hres;
    }

    BSTR strTextTemplate = V_BSTR(&v);
    V_BSTR(&v) = NULL;

    // Bring up message boxes for all   
    // ==============================

    for(long i = 0; i < lNumObjects; i++)
    {
        // Generate the text
        // =================

        CTextTemplate Template(strTextTemplate);
        BSTR strText = Template.Apply(apObjects[i]);
        if(strText == NULL)
            continue;
        
        // Bring up the message box
        // ========================

        OSVERSIONINFO info;
        info.dwOSVersionInfoSize = sizeof(info);
        GetVersionEx(&info);
        int nRet = 0;
        if(info.dwPlatformId != VER_PLATFORM_WIN32_NT)
        {
            // Use ASCII
            // =========

            char* szTitle = new char[wcslen(strTitle)*2 + 2];
            sprintf(szTitle, "%S", strTitle);

            char* szText = new char[wcslen(strText)*2 + 2];
            sprintf(szText, "%S", strText);

            nRet = MessageBoxA(NULL, szText, szTitle, MB_OK | MB_ICONHAND);
            if (nRet == 0)
                ERRORTRACE((LOG_ESS, "Failed to display message box: 0x%X\n", GetLastError()));


            delete [] szTitle;
            delete [] szText;
        }
        else 
        {
            int nFlag;
            if(info.dwMajorVersion < 4)
                nFlag = MB_SERVICE_NOTIFICATION_NT3X;
            else
                nFlag = MB_SERVICE_NOTIFICATION;

            nRet = MessageBoxW(NULL, strText, strTitle, MB_OK | MB_ICONHAND | nFlag);   
            if (nRet == 0)
                ERRORTRACE((LOG_ESS, "Failed to display message box: 0x%X\n", GetLastError()));
        }

        SysFreeString(strText);
        if (nRet == 0)
            return WBEM_E_FAILED;    
    }

    SysFreeString(strTitle);
    SysFreeString(strTextTemplate);

    return WBEM_S_NO_ERROR;
}

void* CMsgBoxConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\pager.cpp ===
#include <wbemidl.h>
#include <wbemcomn.h>
#include <wbemutil.h>
#include <cominit.h>
#include "Pager.h"

#define LOGFILE_PROPNAME_NUMBER           L"PhoneNumber"
#define LOGFILE_PROPNAME_MESSAGE          L"Message"

#define LOGFILE_PROPNAME_ID               L"ID"
#define LOGFILE_PROPNAME_PORT             L"Port"
#define LOGFILE_PROPNAME_BAUDRATE         L"BaudRate"
#define LOGFILE_PROPNAME_SETUPSTR         L"ModemSetupString"
#define LOGFILE_PROPNAME_TIMEOUT          L"AnswerTimeout"

#define ACK '\x06'
#define NAK	'\x15'
#define EOT	'\x04'
#define NUL	'\x00'


HRESULT STDMETHODCALLTYPE CPagerConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    HRESULT hr = WBEM_E_FAILED;

    DEBUGTRACE((LOG_ESS, "Pager: Find Consumer\n"));

    CPagerSink* pSink = new CPagerSink(m_pObject->m_pControl);
    if (pSink)    
	{
		if (SUCCEEDED(hr = pSink->SetConsumer(pLogicalConsumer)))
			hr = pSink->QueryInterface(IID_IWbemUnboundObjectSink, (void**)ppConsumer);
		else
			pSink->Release();
	}
	else
        hr = WBEM_E_OUT_OF_MEMORY;
     

    DEBUGTRACE((LOG_ESS, "Pager: Find Consumer returning 0x%08X\n", hr));
    return hr;
}


HRESULT STDMETHODCALLTYPE CPagerConsumer::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink* pSink)
{
    pSink->SetStatus(0, 0);
    return 0;
}
    

void* CPagerConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}



CPagerSink::~CPagerSink()
{
}

HRESULT CPagerSink::SetConsumer(IWbemClassObject* pLogicalConsumer)
{
    // Get the information
    // ===================

    HRESULT hres;
    VARIANT v;
    VariantInit(&v);

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_NUMBER, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;
    m_phoneNumber = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_MESSAGE, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;
    m_messageTemplate.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

	hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_ID, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;
    m_pagerID = V_BSTR(&v);
    VariantClear(&v);

	hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_PORT, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;
    m_port = V_BSTR(&v);
    VariantClear(&v);

	hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_BAUDRATE, 0, &v, NULL, NULL);
	if (SUCCEEDED(hres))
	{
		if (V_VT(&v) == VT_I4)
			m_baudRate = V_I4(&v);
		else if (V_VT(&v) == VT_NULL)
			m_baudRate = INVALID_BAUD_RATE;
		else
			return WBEM_E_INVALID_PARAMETER;    
	}
	else
		return hres;
    VariantClear(&v);

	hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_TIMEOUT, 0, &v, NULL, NULL);
	if (SUCCEEDED(hres))
	{
		if (V_VT(&v) == VT_I4)
			m_timeout = 1000 * V_I4(&v);
		else if (V_VT(&v) == VT_NULL)
			m_timeout = 30000;
		else
			return WBEM_E_INVALID_PARAMETER;    
	}
	else
		return hres;
    VariantClear(&v);

	hres = pLogicalConsumer->Get(LOGFILE_PROPNAME_SETUPSTR, 0, &v, NULL, NULL);
    if(FAILED(hres) || !((V_VT(&v) == VT_BSTR) || (V_VT(&v) == VT_NULL)))
        return WBEM_E_INVALID_PARAMETER;
    m_modemSetupString = V_BSTR(&v);
	m_modemSetupString += L"\r";
    VariantClear(&v);

    return hres;
}

HRESULT STDMETHODCALLTYPE CPagerSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{    
    HRESULT hr = WBEM_S_NO_ERROR;
    
    DEBUGTRACE((LOG_ESS, "Pager: CPagerSink::IndicateToConsumer %d objects\n", lNumObjects));
        
    for (int i = 0; i < lNumObjects; i++)
    {
        // Apply the template to the event
        // ===============================
        BSTR strText = m_pObject->m_messageTemplate.Apply(apObjects[i]);

        // call somebody & let 'em know about it....
        if(strText)
        {
            hr = m_pObject->RingMeUp(strText);
            SysFreeString(strText);
        }
        else
            hr = WBEM_E_FAILED;
    }

    return hr;
}        

// listens to the modem for a while,
// searches for the string 'OK' in the string read
// modem should echo back OK if everything's hunky dory
HRESULT CPagerSink::IsOK(HANDLE hPort)
{
	HRESULT hr = WBEM_E_FAILED;
	SetTimeout(hPort, 1000);

    // monitor the return from the modem
	BYTE buffer[101];
	ZeroMemory(buffer, 101);
	DWORD dwErr = 0;
	DWORD bytesWryt;
	int nTries = 0;

	while (FAILED(hr) &&
		   ReadFile(hPort, &buffer, 100, &bytesWryt, NULL) &&
		   (nTries++ < 3))
				if (strstr(_strupr((char*)buffer), "OK"))
					hr = WBEM_S_NO_ERROR;

	if (SUCCEEDED(hr))
		DEBUGTRACE((LOG_ESS, "Pager: modem responds OK\n"));
	else
		ERRORTRACE((LOG_ESS, "Pager: modem does not respond OK (%s)\n", buffer));

	return hr;
}

// listens to the modem for a while,
// searches for the ACK char
bool CPagerSink::GotACK(HANDLE hPort)
{
	return (GetResponse(hPort) == ACK);	
}

// listens to the modem for a while,
// searches for the NAK char
bool CPagerSink::GotNAK(HANDLE hPort)
{
	return (GetResponse(hPort) == NAK);	
}

// listens to the modem for a while,
// searches for the string 'CONNECT' in the string read
// caller should set timeout to a fairly large number before calling this
HRESULT CPagerSink::IsConnected(HANDLE hPort)
{
	HRESULT hr = WBEM_E_FAILED;

    // monitor the return from the modem
	BYTE buffer[101];
	ZeroMemory(buffer, 101);
	DWORD dwErr = 0;
	DWORD bytesWryt;
	if (ReadFile(hPort, &buffer, 100, &bytesWryt, NULL))
	{
		if (strstr(_strupr((char*)buffer), "CONNECT"))
		{
			DEBUGTRACE((LOG_ESS, "Pager: connected (%s)\n", buffer));
			hr = WBEM_S_NO_ERROR;
		}
		else
			ERRORTRACE((LOG_ESS, "Pager: Failed to connect\"%s\"", buffer));
	}

	return hr;
}

// listens to the modem for a while,
// searches for the string that signifies we're ready to go
bool CPagerSink::ReadyToProceed(HANDLE hPort)
{
	bool bRet = false;
	SetTimeout(hPort, 10000);

    // monitor the return from the modem
	BYTE buffer[101];
	ZeroMemory(buffer, 101);
	DWORD dwErr = 0;
	DWORD bytesWryt;
	int nTries = 0;

	while (!bRet && (nTries++ < 3) && ReadFile(hPort, &buffer, 100, &bytesWryt, NULL))
		if (strstr((char*)buffer, "[p"))
			bRet = true;
		else
			ZeroMemory(buffer, 101);

	if (bRet)
		DEBUGTRACE((LOG_ESS, "Pager: Message go-ahead\n"));
	else
		ERRORTRACE((LOG_ESS, "Pager: FAILED to receive go-ahead\"%s\"\n", buffer));		

	return bRet;
}


// if timeout == 0 (the default) it will 
// set a (hopefully) reasonable timeout
// for waiting for a response from the modem itself
// timeout is in milliseconds
void CPagerSink::SetTimeout(HANDLE hPort, DWORD timeout)
{
	COMMTIMEOUTS commTimeout;
	
	if (timeout == 0)
	{
		commTimeout.WriteTotalTimeoutConstant   = 100; 
		commTimeout.ReadTotalTimeoutConstant    = 100; 		
	}
	else
	{
		commTimeout.WriteTotalTimeoutConstant   = timeout; 
		commTimeout.ReadTotalTimeoutConstant    = timeout; 		
	}

	commTimeout.ReadIntervalTimeout         = 20; 
	commTimeout.ReadTotalTimeoutMultiplier  = 10; 
	commTimeout.WriteTotalTimeoutMultiplier = 10; 

	SetCommTimeouts(hPort, &commTimeout);
}

// configure modem using both our 'well known settings'
// and the modem control string in the MOF
// upon successful return *ppDCB points to a DCB representing
// the orginal state of the modem before we whacked it.
// caller's responsibility to delete the ppDCB
HRESULT CPagerSink::ConfigureModem(HANDLE hPort, DCB** ppDCB)
{
	DEBUGTRACE((LOG_ESS, "Pager: CPagerSink::ConfigureModem\n"));
	
	HRESULT hr = WBEM_E_FAILED;

	*ppDCB = new DCB;
	if (!*ppDCB)
		hr = WBEM_E_OUT_OF_MEMORY;
	else
	{
		if (!GetCommState(hPort, *ppDCB))
			hr = WBEM_E_FAILED;
		else
		{
			SetTimeout(hPort);

			// we're here - let's set some settings
			// first copy the existing settings...
			DCB dcb = **ppDCB;

			// ...and then tweak the bits we want tweaked
			if (m_baudRate != INVALID_BAUD_RATE)
				dcb.BaudRate = m_baudRate;
			
			// following setting is per the TAP standard
			// E-7-1
			dcb.Parity = 2;   // even parity
			dcb.ByteSize = 7; // seven bits
			dcb.StopBits = 0; // per the spec, 0 == "one stop bit"
			dcb.fParity = 1;  // enable parity checking

			if (SetCommState(hPort, &dcb))
			{
				hr = WBEM_S_NO_ERROR;
				DWORD bytesWryt;
				
				// Is there an echo in here?
				// if so - turn it OFF!
				const char* echoOff = "ATE0\r";
				WriteFile(hPort, echoOff, strlen(echoOff), &bytesWryt, NULL);

				// this will clear the buffer, but we won't write it down...
				IsOK(hPort);						

				if (SUCCEEDED(hr) && (m_modemSetupString.Length() != 0))
				{
					LPSTR pSetup = m_modemSetupString.GetLPSTR();
					if (!pSetup)
						hr = WBEM_E_OUT_OF_MEMORY;
					else
					{					
						// setup string is problem of originator, we'll believe it:
						WriteFile(hPort, pSetup, strlen(pSetup), &bytesWryt, NULL);
						delete pSetup;

						hr = IsOK(hPort);
					}
				}
			}
			else
				ERRORTRACE((LOG_ESS, "Pager: SetCommState Failed: %d", GetLastError()));
		}
	}

	return hr;
}

HRESULT CPagerSink::DialUp(HANDLE hPort)
{
	DEBUGTRACE((LOG_ESS,"Pager: CPagerSink::DialUp\n"));
	
	HRESULT hr = WBEM_E_FAILED;
																	   
	LPSTR pNumber = m_phoneNumber.GetLPSTR();

	if (!pNumber)
		hr = WBEM_E_OUT_OF_MEMORY;
	else
	{
		char buf[100];
		DWORD bytesWryt;
		wsprintf(buf, "ATDT%s\r", pNumber);
		WriteFile(hPort, buf, strlen(buf), &bytesWryt, NULL); 

		SetTimeout(hPort, m_timeout);
		hr = IsConnected(hPort);

		delete pNumber;

		SetTimeout(hPort);
	}

	return hr;
}

// SHOULD return ACK, NAK, EOT, or NUL
// will keep trying until it gets one or another;
char CPagerSink::GetResponse(HANDLE hPort)
{
	SetTimeout(hPort, 5000);

    // monitor the return from the modem
	BYTE buffer[101];
	ZeroMemory(buffer, 101);
	DWORD dwErr = 0;
	DWORD bytesWryt;
	int nTries = 0;
	
	// see if we see a response we might be interested in
	while ((nTries++ < 3) && ReadFile(hPort, &buffer, 100, &bytesWryt, NULL))
	{
		if (strchr((const char *)buffer, ACK))
		{
			DEBUGTRACE((LOG_ESS, "Pager: service responds ACK\n"));
			return ACK;			
		}
		else if (strchr((const char *)buffer, NAK))
		{
			DEBUGTRACE((LOG_ESS, "Pager: service responds NAK\n"));
			return NAK;
		}
		else if (strchr((const char *)buffer, EOT))
		{
			DEBUGTRACE((LOG_ESS, "Pager: service responds EOT\n"));
			return EOT;
		}
		else
			// go back, jack, and do it again...
			ZeroMemory(buffer, 101); 
	}
	
	// welp, tried three times & couldn't get it.  bail.
	return NUL;
};

// gonna sit here and listen for a prompt
// but we're gonna proceed even if we don't...
void CPagerSink::GetPrompt(HANDLE hPort)
{
	int nAttempts = 0;
	bool gotPrompt = false;
	DWORD bytesWrytten;
	// per TAP spec - they're supposed to respond within ONE second
	SetTimeout(hPort, 1500);
	char buf[101];

	do 
	{
		WriteFile(hPort, "\r", 1, &bytesWrytten, NULL);
		ZeroMemory(buf, 101);
		if (ReadFile(hPort, &buf, 100, &bytesWrytten, NULL))
			if (strstr(_strupr((char*)buf), "ID="))
				gotPrompt = true;
	}
	while ((++nAttempts < 3) && !gotPrompt);

	if (gotPrompt)
		DEBUGTRACE((LOG_ESS, "Pager: Received prompt\n"));
	else
		ERRORTRACE((LOG_ESS, "Pager: Did not receive prompt\n"));
}

HRESULT CPagerSink::Login(HANDLE hPort)
{
	HRESULT hr = WBEM_E_FAILED;
	
	GetPrompt(hPort);

	// this *should* be universal.  Maybe not, too...
	char* loginString = "\x1BPG1\r";
	DWORD bytesWrytten;
	
	SetTimeout(hPort, 10000);
	WriteFile(hPort, loginString, strlen(loginString), &bytesWrytten, NULL);
	
	if (GotACK(hPort))
	{
		hr = WBEM_S_NO_ERROR;
		DEBUGTRACE((LOG_ESS, "Pager: Received ACK on login\n"));
	}
	else
		ERRORTRACE((LOG_ESS, "Pager: Failed to receive ACK on Login\n"));
	
	return hr;
}

HRESULT CPagerSink::SendMessage(HANDLE hPort, BSTR message)
{
	HRESULT hr = WBEM_E_FAILED;

	if (ReadyToProceed(hPort))
	{
		DEBUGTRACE((LOG_ESS, "Pager: CPagerSink::SendMessage\n"));

		// alloc enough buffer for message that's all double-byte chars.
		// not that the pager is likely to UNDERSTAND, but let's not embarrass ourselves with an overwrite.
		// also room for null teminator, the separators that TAP will want, and some paranoia-padding
		// format: <STX>[pager id]<CR>[message]<ETX>[3 char checksum]<CR>

		char* pMessage = new char[2*wcslen(message) + 2*wcslen(m_pagerID) +12];
		if (!pMessage)
			hr = WBEM_E_OUT_OF_MEMORY;
		else
		{
			// djinn up the message per format
			sprintf(pMessage, "\x02%S\x0D%S\x03", m_pagerID, message);
			int nlen = strlen(pMessage);
			int sum = 0;

			// compute checksum:
			for (int i = 0; i < nlen; i++)
				sum += pMessage[i];
			
			// only want the lower three bytes:
			sum &= 0x0FFF;

			// append to message:
			// it's hex: but 'A' through 'E' are ':' through '?' 
			// (look at ASCII table - it makes sense)
			// there's probably a cute way to do this in a loop,
			// but what the heck, I'm lazy (or stoopid):
			pMessage[nlen +0] = (char) (0x30 + ((sum & 0x0F00) / 0x100));
			pMessage[nlen +1] = (char) (0x30 + ((sum & 0x00F0) / 0x10));
			pMessage[nlen +2] = (char) (0x30 + ((sum & 0x000F) / 0x1));
			pMessage[nlen +3] = '\x0D';
			pMessage[nlen +4] =	'\0';
				
			// we'll retry if we get a NAK
			DWORD bytesWrytten;
			int nTries = 0;
			do 
			{			
				DEBUGTRACE((LOG_ESS, "Pager: attempting send #%d\n", nTries +1));
				if (WriteFile(hPort, pMessage, strlen(pMessage), &bytesWrytten, NULL))
					hr = WBEM_S_NO_ERROR;
			}
			while (GotNAK(hPort) && (++nTries < 3));
			
			delete[] pMessage;
		} // if allocated memory
	}// if ready to proceed

	return hr;
}

// issue logout commands and hang up.
// won't bother listening for any response: 
// we don't care - we were just leaving, anyway.
void CPagerSink::LogOut(HANDLE hPort)
{
	DEBUGTRACE((LOG_ESS, "Pager: CPagerSink::LogOut\n"));
	DWORD bytesWrytten;
	
	char* logout = "\x04\r";
	WriteFile(hPort, logout, strlen(logout), &bytesWrytten, NULL);

	char* hangup = "ATH0";
	WriteFile(hPort, hangup, strlen(hangup), &bytesWrytten, NULL);
}


HRESULT CPagerSink::RingMeUp(BSTR message)
{
    DEBUGTRACE((LOG_ESS, "Pager: Paging with message \"%S\"\n", message));
    HRESULT hr = WBEM_E_FAILED;

	LPSTR port = m_port.GetLPSTR();
	if (!port)
		hr = WBEM_E_OUT_OF_MEMORY;
	else
	{
		HANDLE hPort;
		hPort = CreateFile(port, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		delete port;
		port = NULL;
		 
		if (hPort == INVALID_HANDLE_VALUE)
		{
			ERRORTRACE((LOG_ESS, "Pager: CreateFile failed with %d\n", GetLastError()));
			// todo: investigate various failure modes
			// we ought to be able to distinguish between a modem that's in use
			// and one that doesn't exist, at the very least.
			hr = WBEM_E_FAILED;
			// hr = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			DCB* pDCBOld = NULL;
			if (SUCCEEDED(hr = ConfigureModem(hPort, &pDCBOld))	&&
				SUCCEEDED(hr = DialUp(hPort)) &&
				SUCCEEDED(hr = Login(hPort)))
			{
				hr = SendMessage(hPort, message);	
			}
			
			// even if we blew it somewhere along the line
			// we still want to hang up.
			// at worst we'll be sending commands to a modem that's already disconnected
			LogOut(hPort);

			if 	(pDCBOld)
			{			
				SetCommState(hPort, pDCBOld);
				delete pDCBOld;
				pDCBOld = NULL;
			}

			CloseHandle(hPort);
		}
	}

	return hr;
}

void* CPagerSink::GetInterface(REFIID riid)
{
    if (riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else 
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\prockiller.cpp ===
#include "precomp.h"
#include "ProcKiller.h"

// the only one we'll ever need
CProcKillerTimer g_procKillerTimer;

// terminate process
void CProcKiller::Die()
{
    bool bDoIt = true;
    DWORD exitCode;
    
    // sleazy attempt to ensure that the proc is still running when we try to kill it
    // proc could still terminate on its own in the interim.
    if (GetExitCodeProcess(m_hProc, &exitCode))
        bDoIt = (exitCode == STILL_ACTIVE); 
    
    if (bDoIt)
        TerminateProcess(m_hProc, 1);
    
    CloseHandle(m_hProc);
    m_hProc = NULL;
}


// hVictim is a handle to a process
// last meal is the scheduled execution date
HRESULT CProcKillerTimer::ScheduleAssassination(HANDLE hVictim, FILETIME lastMeal)
{
    HRESULT hr = WBEM_E_FAILED;

    CProcKiller* pKiller;
    // gotta dup the handle - caller may close it.
    HANDLE hMyHandle;

    if (DuplicateHandle(GetCurrentProcess(), hVictim, GetCurrentProcess(), &hMyHandle, 0, false, DUPLICATE_SAME_ACCESS))
	{
		if (pKiller = new CProcKiller(hMyHandle, lastMeal, m_pControl))
		{
			hr = CKillerTimer::ScheduleAssassination(pKiller);
		}
		else
			// allocation failed
			hr = WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		ERRORTRACE((LOG_ESS, "DuplicateHandle failed, 0x%08X\n", GetLastError()));
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\perf.h ===
#ifndef __WBEM_PERF_CONSUMER__H_
#define __WBEM_PERF_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include "txttempl.h"
#include <stdio.h>

class CPerfConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CPerfConsumer>
    {
    public:
        XProvider(CPerfConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CPerfConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPerfConsumer>
    {
    public:
        XInit(CPerfConsumer* pObj)
            : CImpl<IWbemProviderInit, CPerfConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;


public:
    CPerfConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this)
    {}
    ~CPerfConsumer(){}
    void* GetInterface(REFIID riid);
};


class CPerfSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CPerfSink>
    {
    public:
        XSink(CPerfSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CPerfSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    CTextTemplate m_Template;
    WString m_wsFile;
    FILE* m_f;
    long m_nLogEvery;
    long m_nCurrent;

public:
    CPerfSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), m_f(NULL), m_nCurrent(0)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);
    ~CPerfSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\perf.cpp ===
#include "perf.h"
#include <stdio.h>
#include <wbemutil.h>

#define PERF_PROPNAME_FILENAME L"Filename"
#define PERF_PROPNAME_TEXT L"Text"
#define PERF_PROPNAME_COUNT L"CountToLog"

HRESULT STDMETHODCALLTYPE CPerfConsumer::XProvider::FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer)
{
    // Create a new sink
    // =================

    CPerfSink* pSink = new CPerfSink(m_pObject->m_pControl);

    // Initialize it
    // =============

    HRESULT hres = pSink->Initialize(pLogicalConsumer);
    if(FAILED(hres))
    {
        delete pSink;
        *ppConsumer = NULL;
        return hres;
    }

    // return it

    pSink->QueryInterface(IID_IWbemUnboundObjectSink, (void**)ppConsumer);
    return WBEM_S_FALSE; // no need to repeat pLogicalConsumer!
}


HRESULT STDMETHODCALLTYPE CPerfConsumer::XInit::Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink* pSink)
{
    pSink->SetStatus(0, 0);
    return 0;
}
    

void* CPerfConsumer::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventConsumerProvider)
        return &m_XProvider;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else return NULL;
}






CPerfSink::~CPerfSink()
{
    if(m_f)
        fclose(m_f);
}

HRESULT CPerfSink::Initialize(IWbemClassObject* pLogicalConsumer)
{
    // Get the information
    // ===================

    HRESULT hres;
    VARIANT v;
    VariantInit(&v);

    hres = pLogicalConsumer->Get(PERF_PROPNAME_FILENAME, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;
    m_wsFile = V_BSTR(&v);
    VariantClear(&v);

    hres = pLogicalConsumer->Get(PERF_PROPNAME_TEXT, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PARAMETER;
    m_Template.SetTemplate(V_BSTR(&v));
    VariantClear(&v);

    hres = pLogicalConsumer->Get(PERF_PROPNAME_COUNT, 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_I4)
        return WBEM_E_INVALID_PARAMETER;
    m_nLogEvery = V_I4(&v);
    VariantClear(&v);

    // Open the file
    // =============

    m_f = _wfopen(m_wsFile, L"a");
    if(m_f == NULL)
    {
        ERRORTRACE((LOG_ESS, "Unable to open log file %S\n", (LPWSTR)m_wsFile));
        return WBEM_E_FAILED;
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerfSink::XSink::IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects)
{
    for(int i = 0; i < lNumObjects; i++)
    {
        if(InterlockedIncrement(&m_pObject->m_nCurrent) == 
                m_pObject->m_nLogEvery)
        {
            m_pObject->m_nCurrent = 0;

            // Apply the template to the event
            // ===============================

            BSTR strText = m_pObject->m_Template.Apply(apObjects[i]);
            if(strText == NULL)
                strText = SysAllocString(L"invalid log entry");

            // Log the result
            // ==============
            int nRet;

            nRet = fprintf(m_pObject->m_f, "Tick: %d. Count: %d. %S\n", 
                GetTickCount(), m_pObject->m_nLogEvery, strText);
            if (nRet < 0)
                ERRORTRACE((LOG_ESS, "Failed to log perf event: 0x%X\n", GetLastError()));

            fflush(m_pObject->m_f);
            SysFreeString(strText);

            if (nRet < 0)
                return WBEM_E_FAILED;
        }
    }
    return S_OK;
}
    

    

void* CPerfSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
        return &m_XSink;
    else return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\prockiller.h ===
#ifndef __PROC_KILLER_COMPILED__
#define __PROC_KILLER_COMPILED__

#include "KillTimer.h"

// only need one of these laying around
class CProcKillerTimer;
extern CProcKillerTimer g_procKillerTimer;

// specialized to kill processes
class CProcKillerTimer : public CKillerTimer
{
public:
    
    // who to kill & when
    HRESULT ScheduleAssassination(HANDLE hVictim, FILETIME lastMeal);            
};

/* CLASS CProcKiller DEFINITION */

// hold process that needs to be killed
// owner of process handle, responsible for closing it
class CProcKiller : public CKiller
{
public:
    CProcKiller(HANDLE hProc, FILETIME deathDate, CLifeControl* pControl) :
      CKiller(deathDate, pControl), m_hProc(hProc)
        {
        }

    virtual ~CProcKiller()
    {
        // we don't kill off the process if we're shutdown prematurely
        if (m_hProc)
            CloseHandle(m_hProc);
    }

    // terminate process, 
    virtual void Die();

protected:

private:
    HANDLE m_hProc;

};

#endif //__PROC_KILLER_COMPILED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\pager.h ===
#ifndef __PAGER_H_COMPILED__
#define __PAGER_H_COMPILED__

#include <unk.h>
#include <TxtTempl.h>
#include <sync.h>

#define INVALID_BAUD_RATE 0xFFFFFFFF

class CPagerConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CPagerConsumer>
    {
    public:
        XProvider(CPagerConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CPagerConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

    class XInit : public CImpl<IWbemProviderInit, CPagerConsumer>
    {
    public:
        XInit(CPagerConsumer* pObj)
            : CImpl<IWbemProviderInit, CPagerConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE Initialize(
            LPWSTR, LONG, LPWSTR, LPWSTR, IWbemServices*, IWbemContext*, 
            IWbemProviderInitSink*);
    } m_XInit;
    friend XInit;


public:
    CPagerConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this), m_XInit(this)
    {}
    ~CPagerConsumer(){}
    void* GetInterface(REFIID riid);
};


class CPagerSink : public CUnk
{
public:
    CPagerSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this), m_timeout(30000), m_baudRate(INVALID_BAUD_RATE)
    {}
    HRESULT SetConsumer(IWbemClassObject* pLogicalConsumer);
    ~CPagerSink();

    void* GetInterface(REFIID riid);

protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CPagerSink>
    {
    public:
        XSink(CPagerSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CPagerSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

	/* call state progression */
    HRESULT		RingMeUp(BSTR message);
	HRESULT		DialUp(HANDLE hPort);
	HRESULT		IsConnected(HANDLE hPort);
	void		GetPrompt(HANDLE hPort);
	HRESULT		Login(HANDLE hPort);
	bool		ReadyToProceed(HANDLE hPort);
	HRESULT		SendMessage(HANDLE hPort, BSTR message);
	void		LogOut(HANDLE hPort);
	
	/* modem communication */
	HRESULT		IsOK(HANDLE hPort);
	bool		GotNAK(HANDLE hPort);
	bool		GotACK(HANDLE hPort);
	char		GetResponse(HANDLE hPort);
	void		SetTimeout(HANDLE hPort, DWORD timeout = 0);
	HRESULT		ConfigureModem(HANDLE hPort, DCB** ppDCB);	


    // numeric message to send to pager dude
    CTextTemplate m_messageTemplate;

	// phoney number we'll dial
    WString m_phoneNumber;

	// string identifying pager
	WString m_pagerID;

	// COM1 or something.
	// who knows - maybe \\.\someothercomputer\com1 will work
	WString m_port;

	// rate your baud.  Mine's a ten.
	UINT32 m_baudRate;

	// additional setup parms required
	WString m_modemSetupString;

	// a timeout time, used both for waiting for the phoen to answer
	// and for waiting for the pager service provider to answer
	// units: milliseconds
	DWORD m_timeout;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\datep.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

#include <windows.h>
#include <comdef.h>
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>

#include "dnf.h"
#include "datep.h"

/******************************************************************/


COrderedUniqueSet64::COrderedUniqueSet64(void)
{
  m_BitField = SETEMPTY;
}

COrderedUniqueSet64 COrderedUniqueSet64::Set(ULONGLONG n)
{
  m_BitField = n;

 return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Add(ULONGLONG n) 
{ 
  ULONGLONG iBit = SETMIN;

  if((n <= 63))
    m_BitField |= iBit << n;

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Remove(ULONGLONG n)
{
  ULONGLONG iBit = SETMIN;

  if((n >= 1) && (n <= 64))
    m_BitField &= ~(iBit << n);

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Union(COrderedUniqueSet64 n)
{
  m_BitField |= n.m_BitField;

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Intersection(COrderedUniqueSet64 n)
{
  m_BitField &= n.m_BitField;

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::UpperBound(ULONGLONG n)
{
  if((n <= 63))
  {
    n = 63 - n;
    m_BitField = (m_BitField << n) >> n;
  }

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::LowerBound(ULONGLONG n)
{
  if((n <= 63))
    m_BitField = (m_BitField >> n) << n;

  return *this;
}

COrderedUniqueSet64 COrderedUniqueSet64::Rotate(int n)
{
  while(n > 64) n -= 64;
  while(n < 0) n += 64;

  m_BitField = (m_BitField << n) | (m_BitField >> (64 - n));

  return *this;
}

BOOL COrderedUniqueSet64::Member(ULONGLONG n)
{
  return ((n <= 63) ? m_BitField & (SETMIN << n) : 0);
}

unsigned COrderedUniqueSet64::Next(ULONGLONG n)
{
  ULONGLONG nStart = n;
  ULONGLONG 
    SetValue = SETMIN << n;

  if(0x0 == m_BitField)
    return -1;

  while(! (SetValue & m_BitField))
  {
    SetValue <<= 1;
    n++;

    if(SETEMPTY == SetValue)
    {
      SetValue = SETMIN;
      n = 0;
    }
  }

  return (unsigned)n;
}

unsigned COrderedUniqueSet64::Prev(ULONGLONG n)
{
  ULONGLONG nStart = n;
  ULONGLONG SetValue = SETMIN << n;

  if(0x0 == m_BitField)
    return -1;

  while(! (SetValue & m_BitField))
  {
    SetValue >>= 1;
    n--;

    if(SETEMPTY == SetValue)
    {
      SetValue = SETMAX;
      n = 63;
    }
  }

  return (unsigned)n;
}

/******************************************************************/

unsigned CPattern::GetNextValue(unsigned NextValue)
{
  unsigned i;

  // **** perform quick sanity check 

  if((m_FieldsUsed & LOWERBOUND) && 
     (m_FieldsUsed & UPPERBOUND) &&
     (m_UpperBound < m_LowerBound))
    return -1;
  
  if(m_FieldsUsed & EQUALTO)
  {
    if(NextValue > m_EqualTo)
      return -1;
    else
      NextValue = m_EqualTo;

    // **** perform sanity checks for equality

    if((m_FieldsUsed & LOWERBOUND) &&
       (m_EqualTo < m_LowerBound))
      return -1;

    if((m_FieldsUsed & UPPERBOUND) &&
       (m_EqualTo > m_UpperBound))
      return -1;

    if(m_FieldsUsed & NOTEQUALTO)
    {
      for(i = 0; i < m_CountNotEqualTo; i++)
        if(NextValue == m_NotEqualTo[i])
          return -1;
    }
  }
  else
  {
    if(m_FieldsUsed & LOWERBOUND)
    {
      if(NextValue < m_LowerBound)
        NextValue = m_LowerBound;
    }

    if(m_FieldsUsed & NOTEQUALTO)
    {
      int
        YearGotBumpedUp = 1;

      while(YearGotBumpedUp)
      {
        YearGotBumpedUp = 0;

        for(i = 0; i < m_CountNotEqualTo; i++)
          if(NextValue == m_NotEqualTo[i])
          {
            NextValue += 1;
            YearGotBumpedUp = 1;
          }
      }
    }

    if(m_FieldsUsed & UPPERBOUND)
    {
      if(NextValue > m_UpperBound)
        return -1;
    }
  }

  return NextValue;
}
/******************************************************************/

// this belongs to CDatePattern but is stuck outside
// of scope because of compiler bug (re: C2334)

wchar_t* m_FieldName[] =
{
  L"Year",
  L"Month",
  L"Day",
  L"DayOfWeek",
  L"WeekInMonth",
  L"Quarter",
  L"Hour",
  L"Minute",
  L"Second"
};


int CDatePattern::FieldIndx(const wchar_t *suName)
{
  int 
    iField;

  if(NULL == suName) return -1;

  for(iField = INDX_Year; 
      (iField < INDX_MAX) && _wcsicmp(m_FieldName[iField], suName);
      iField++);

  if(INDX_MAX == iField) iField = -1;

  return iField;
}

HRESULT CDatePattern::AugmentPattern(QL_LEVEL_1_TOKEN *pExp)
{
  int
    i = pExp->PropertyName.GetNumElements(),
    iField = FieldIndx(pExp->PropertyName.GetStringAt(i - 1));

  unsigned 
    j,
    testVal;

  VARIANT
    iValue;

  VariantInit(&iValue);

  if(-1 == iField)
  {
    if(_wcsicmp(L"TargetInstance", pExp->PropertyName.GetStringAt(i - 1)))
      return WBEM_E_INVALID_PROPERTY;
    else
      return WBEM_S_NO_ERROR;
  }

  if(FAILED(VariantChangeType(&iValue, &(pExp->vConstValue), 0x0, VT_I4)))
    return WBEM_E_INVALID_QUERY;

  switch(pExp->nOperator)
  {
    case QL_LEVEL_1_TOKEN::OP_EQUAL : 

      // **** first make sure that value can be in pattern

      testVal = m_Pattern[iField].GetNextValue(iValue.lVal);
      if(testVal == iValue.lVal)
      {
        m_Pattern[iField].m_FieldsUsed |= CPattern::EQUALTO;
        m_Pattern[iField].m_EqualTo = iValue.lVal;
      }
      break;

    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL : 
      m_Pattern[iField].m_FieldsUsed |= CPattern::NOTEQUALTO;
      j = m_Pattern[iField].m_CountNotEqualTo;
      if(j < 64)
      {
        m_Pattern[iField].m_NotEqualTo[j] = iValue.lVal;
        m_Pattern[iField].m_CountNotEqualTo++;
      }
      else
      {
        return WBEM_E_FAILED;
      }

      break;

    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN : 
      if(! (m_Pattern[iField].m_FieldsUsed & CPattern::LOWERBOUND))
      {
        m_Pattern[iField].m_LowerBound = 0;
        m_Pattern[iField].m_FieldsUsed |= CPattern::LOWERBOUND;
      }
      if(m_Pattern[iField].m_LowerBound < iValue.lVal)
        m_Pattern[iField].m_LowerBound = iValue.lVal;
      break;

    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN : 
      if(! (m_Pattern[iField].m_FieldsUsed & CPattern::UPPERBOUND))
      {
        m_Pattern[iField].m_UpperBound = -1;
        m_Pattern[iField].m_FieldsUsed |= CPattern::UPPERBOUND;
      }
      m_Pattern[iField].m_FieldsUsed |= CPattern::UPPERBOUND;
      if(m_Pattern[iField].m_UpperBound > iValue.lVal)
        m_Pattern[iField].m_UpperBound = iValue.lVal;
      break;

    case QL_LEVEL_1_TOKEN::OP_LESSTHAN : 
      if(! (m_Pattern[iField].m_FieldsUsed & CPattern::UPPERBOUND))
      {
        m_Pattern[iField].m_UpperBound = -1;
        m_Pattern[iField].m_FieldsUsed |= CPattern::UPPERBOUND;
      }
      m_Pattern[iField].m_FieldsUsed |= CPattern::UPPERBOUND;
      if(m_Pattern[iField].m_UpperBound >= iValue.lVal)
        m_Pattern[iField].m_UpperBound = iValue.lVal - 1;
      break;

    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN : 
      if(! (m_Pattern[iField].m_FieldsUsed & CPattern::LOWERBOUND))
      {
        m_Pattern[iField].m_LowerBound = 0;
        m_Pattern[iField].m_FieldsUsed |= CPattern::LOWERBOUND;
      }
      m_Pattern[iField].m_FieldsUsed |= CPattern::LOWERBOUND;
      if(m_Pattern[iField].m_LowerBound <= iValue.lVal)
        m_Pattern[iField].m_LowerBound = iValue.lVal + 1;
      break;

    case QL_LEVEL_1_TOKEN::OP_LIKE : 
    default : ;
      return WBEM_E_INVALID_QUERY;
  }

  return WBEM_S_NO_ERROR;
}

HRESULT CDatePattern::BuildSetsFromPatterns(void)
{
  // Second

  m_Set[INDX_Second].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Second], &m_Set[INDX_Second]);
  m_Set[INDX_Second].UpperBound(59);

  // Minute

  m_Set[INDX_Minute].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Minute], &m_Set[INDX_Minute]);
  m_Set[INDX_Minute].UpperBound(59);

  // Hour

  m_Set[INDX_Hour].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Hour], &m_Set[INDX_Hour]);
  m_Set[INDX_Hour].UpperBound(23);

  // Quarter

  m_Set[INDX_Quarter].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Quarter], &m_Set[INDX_Quarter]);
  m_Set[INDX_Quarter].LowerBound(1);
  m_Set[INDX_Quarter].UpperBound(4);

  // WeekInMonth

  m_Set[INDX_WeekInMonth].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_WeekInMonth], &m_Set[INDX_WeekInMonth]);
  m_Set[INDX_WeekInMonth].LowerBound(1);
  m_Set[INDX_WeekInMonth].UpperBound(7);

  // DayOfWeek

  m_Set[INDX_DayOfWeek].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_DayOfWeek], &m_Set[INDX_DayOfWeek]);
  m_Set[INDX_DayOfWeek].LowerBound(1);
  m_Set[INDX_DayOfWeek].UpperBound(7);

  // Day

  m_Set[INDX_Day].Set(SETEMPTY);

  // Month

  m_Set[INDX_Month].Set(SETFULL);
  MapPatternToSet(&m_Pattern[INDX_Month], &m_Set[INDX_Month]);
  m_Set[INDX_Month].LowerBound(1);
  m_Set[INDX_Month].UpperBound(12);

  // Year

  m_Set[INDX_Year].Set(SETEMPTY);

  return WBEM_S_NO_ERROR;
}

HRESULT CDatePattern::MapPatternToSet(CPattern *pPattern, COrderedUniqueSet64 *pSet)
{
  unsigned i;

  if(pPattern->m_FieldsUsed & CPattern::EQUALTO)
  {
    pSet->Set(SETEMPTY);
    pSet->Add(pPattern->m_EqualTo);
  }
  else
  {
    if(pPattern->m_FieldsUsed & CPattern::NOTEQUALTO)
    {
      for(i = 0; i < pPattern->m_CountNotEqualTo; i++)
        pSet->Remove(pPattern->m_NotEqualTo[i]);
    }

    if(pPattern->m_FieldsUsed & CPattern::UPPERBOUND)
    {
      pSet->UpperBound(pPattern->m_UpperBound);
    }

    if(pPattern->m_FieldsUsed & CPattern::LOWERBOUND)
    {
      pSet->LowerBound(pPattern->m_LowerBound);
    }
  }

  return WBEM_S_NO_ERROR;
}

HRESULT CDatePattern::GetDaysInMonth(WORD iYear, WORD iMonth)
{
  ULONGLONG
    Time1,
    Time2;

  int
    i, j, k,
    DayOfWeek,
    DaysInMonth;

  SYSTEMTIME
    SystemTime;

  FILETIME
    FileTime1,
    FileTime2;

  SystemTime.wYear = iYear;
  SystemTime.wMonth = iMonth;
  SystemTime.wDay = 1;
  SystemTime.wHour = 0;
  SystemTime.wMinute = 0;
  SystemTime.wSecond = 0;
  SystemTime.wMilliseconds = 0;

  if(m_Set[INDX_Month].Member(iMonth) && 
     m_Set[INDX_Quarter].Member(1 + (iMonth - 1) / 3))
  {
    // **** get DayOfWeek

    SystemTimeToFileTime(&SystemTime, &FileTime1);

    if(12 == SystemTime.wMonth)
    {
      SystemTime.wMonth = 1;
      SystemTime.wYear++;
    }
    else
      SystemTime.wMonth++;

    SystemTimeToFileTime(&SystemTime, &FileTime2);
    FileTimeToSystemTime(&FileTime1, &SystemTime);

    DayOfWeek = SystemTime.wDayOfWeek; // 0..6

    // **** get DaysInMonth

    Time1 = FileTime1.dwHighDateTime;
    Time1 = (Time1 << 32) + FileTime1.dwLowDateTime;
    Time2 = FileTime2.dwHighDateTime;
    Time2 = (Time2 << 32) + FileTime2.dwLowDateTime;

    DaysInMonth = (int) ((Time2 - Time1) / 864000000000);

    // **** get set for DaysInMonth

    m_Set[INDX_Day].Set(SETFULL);
    m_Set[INDX_Day].LowerBound(1);
    m_Set[INDX_Day].UpperBound(DaysInMonth);
    MapPatternToSet(&m_Pattern[INDX_Day], &m_Set[INDX_Day]);

    // build bitfield from DayOfWeek and WeekInMonth sets

    m_Set[INDX_MAX].Set(SETEMPTY);

    for(i = 0; i < DaysInMonth; i++)
    {
      j = (DayOfWeek + i) % 7 + 1;  // Day of week
      k = (DayOfWeek + i) / 7 + 1;  // Week in Month

      if(m_Set[INDX_DayOfWeek].Member(j) &&
         m_Set[INDX_WeekInMonth].Member(k))
        m_Set[INDX_MAX].Add(i + 1);
    }

    m_Set[INDX_Day].Intersection(m_Set[INDX_MAX]);
  }
  else
    m_Set[INDX_Day].Set(SETEMPTY);

  return WBEM_S_NO_ERROR;
}

ULONGLONG CDatePattern::GetNextTime(SYSTEMTIME *pSystemTime)
{
  WORD
    wCurrValue,
    wCurrValue2,
    ThresholdYear = 12;

  FILETIME
    FileTime;

  ULONGLONG
    NewTime;

  /*
     Assumptions:

       1. ASSUME EACH SET HAS AT LEAST ONE MEMBER EXCEPT 'Day'
       2. set values start at 1 but hours, mins and secs start at 0
  */

  // **** second

  wCurrValue = m_CurrentTime.wSecond + 1;
  m_CurrentTime.wSecond = (USHORT) m_Set[INDX_Second].Next(wCurrValue);
  if(m_CurrentTime.wSecond < wCurrValue)
  {
    // **** minute

    wCurrValue = m_CurrentTime.wMinute + 1;
    m_CurrentTime.wMinute = (USHORT) m_Set[INDX_Minute].Next(wCurrValue);
    if(m_CurrentTime.wMinute < wCurrValue)
    {
      // **** hour

      wCurrValue = m_CurrentTime.wHour + 1;
      m_CurrentTime.wHour = (USHORT) m_Set[INDX_Hour].Next(wCurrValue);
      if(m_CurrentTime.wHour < wCurrValue)
      {
        // **** day

        wCurrValue = m_CurrentTime.wDay + 1;
        m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(wCurrValue);

        while((SETEMPTY == m_Set[INDX_Day].m_BitField) || 
              (m_CurrentTime.wDay < wCurrValue))
        {
          // **** Month

          wCurrValue2 = m_CurrentTime.wMonth + 1;
          m_CurrentTime.wMonth = (USHORT) m_Set[INDX_Month].Next(wCurrValue2);
          if(m_CurrentTime.wMonth < wCurrValue2)
          {
            if(!ThresholdYear--)
              return -1;

            // **** year

            m_CurrentTime.wYear = (USHORT)
              m_Pattern[INDX_Year].GetNextValue(m_CurrentTime.wYear + 1);

            if((WORD)-1 == m_CurrentTime.wYear)
              return -1;
          }

          GetDaysInMonth(m_CurrentTime.wYear, m_CurrentTime.wMonth);

          wCurrValue = 1;
          m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(wCurrValue);
        }
      }
    }
  }

  SystemTimeToFileTime(&m_CurrentTime, &FileTime);
    
  NewTime = FileTime.dwHighDateTime;
  NewTime = (NewTime << 32) + FileTime.dwLowDateTime;

  if(NULL != pSystemTime)
    *pSystemTime = m_CurrentTime;

  return NewTime;
}

ULONGLONG CDatePattern::SetStartTime(SYSTEMTIME StartTime)
{
  WORD
    wCurrValue,
    ThresholdYear = 12;

  FILETIME
    FileTime;

  ULONGLONG
    NewTime;

  m_CurrentTime = StartTime;

  // **** check that there are at least one each of
  // **** year, month, hour, min and sec

  if((SETEMPTY == m_Set[INDX_Second].m_BitField) ||
     (SETEMPTY == m_Set[INDX_Minute].m_BitField) ||
     (SETEMPTY == m_Set[INDX_Hour].m_BitField)   ||
     (SETEMPTY == m_Set[INDX_Quarter].m_BitField)   ||
     (SETEMPTY == m_Set[INDX_WeekInMonth].m_BitField)   ||
     (SETEMPTY == m_Set[INDX_DayOfWeek].m_BitField)   ||
     (SETEMPTY == m_Set[INDX_Month].m_BitField))
    return -1;

  // **** find first Month/year combo following current time

  m_CurrentTime.wYear =
    (USHORT) m_Pattern[INDX_Year].GetNextValue(m_CurrentTime.wYear);

  if(m_CurrentTime.wYear == (USHORT)-1)
    return -1;

  if(m_CurrentTime.wYear != StartTime.wYear)
    m_CurrentTime.wMonth = (USHORT) m_Set[INDX_Month].Next(1);

  // **** now find first month/year that has at least
  // **** one day in it

  GetDaysInMonth(m_CurrentTime.wYear, m_CurrentTime.wMonth);

  while(SETEMPTY == m_Set[INDX_Day].m_BitField)
  {
    wCurrValue = m_CurrentTime.wMonth + 1;
    m_CurrentTime.wMonth = (USHORT) m_Set[INDX_Month].Next(wCurrValue);

    if(m_CurrentTime.wMonth < wCurrValue)
      m_CurrentTime.wYear
        = (USHORT) m_Pattern[INDX_Year].GetNextValue(m_CurrentTime.wYear + 1);

    if(m_CurrentTime.wYear == (USHORT)-1)
      return -1;

    GetDaysInMonth(m_CurrentTime.wYear, m_CurrentTime.wMonth);
  }

  // **** NOTE: it is still possible, at this point, to have a 
  // **** day in month for the current year/month that is before
  // **** the current day.  But, this is taken care of below.

  // **** align hour:min:sec to first valid date

  if((m_CurrentTime.wYear != StartTime.wYear) || 
     (m_CurrentTime.wMonth != StartTime.wMonth))
  {
    m_CurrentTime.wSecond = (USHORT) m_Set[INDX_Second].Next(0);
    m_CurrentTime.wMinute = (USHORT) m_Set[INDX_Minute].Next(0);
    m_CurrentTime.wHour = (USHORT) m_Set[INDX_Hour].Next(0);
    m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(1);
  }
  else
  {
    wCurrValue = m_CurrentTime.wSecond;
    m_CurrentTime.wSecond = (USHORT) m_Set[INDX_Second].Next(wCurrValue);
    if(m_CurrentTime.wSecond < wCurrValue)
      m_CurrentTime.wMinute += 1;

    wCurrValue = m_CurrentTime.wMinute;
    m_CurrentTime.wMinute = (USHORT) m_Set[INDX_Minute].Next(wCurrValue);
    if(m_CurrentTime.wMinute < wCurrValue)
      m_CurrentTime.wHour += 1;

    wCurrValue = m_CurrentTime.wHour;
    m_CurrentTime.wHour = (USHORT) m_Set[INDX_Hour].Next(wCurrValue);
    if(m_CurrentTime.wHour < wCurrValue)
      m_CurrentTime.wDay += 1;

    wCurrValue = m_CurrentTime.wDay;
    m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(wCurrValue);

    while((SETEMPTY == m_Set[INDX_Day].m_BitField) ||
          (m_CurrentTime.wDay < wCurrValue))
    {
      wCurrValue = m_CurrentTime.wMonth + 1;
      m_CurrentTime.wMonth = (USHORT) m_Set[INDX_Month].Next(wCurrValue);
  
      if(m_CurrentTime.wMonth < wCurrValue)
        m_CurrentTime.wYear 
          = (USHORT) m_Pattern[INDX_Year].GetNextValue(m_CurrentTime.wYear + 1);
  
      if(m_CurrentTime.wYear == (USHORT)-1)
        return -1;

      GetDaysInMonth(m_CurrentTime.wYear, m_CurrentTime.wMonth);

      wCurrValue = 1;
      m_CurrentTime.wDay = (USHORT) m_Set[INDX_Day].Next(wCurrValue);
    }
  }

  SystemTimeToFileTime(&m_CurrentTime, &FileTime);

  NewTime = FileTime.dwHighDateTime;
  NewTime = (NewTime << 32) + FileTime.dwLowDateTime;

  return NewTime;
}

/******************************************************************/


HRESULT WQLDateTime::Init(QL_LEVEL_1_RPN_EXPRESSION *pExp)
{
  HRESULT
    hres = WBEM_S_NO_ERROR;

  int i, j;

  CDNFExpression 
    DNFExpression;

  CConjunction 
    *pConjunction;

  QL_LEVEL_1_TOKEN 
    *pToken, 
    *pTokens;

  pTokens = pExp->pArrayOfTokens + pExp->nNumTokens - 1;

  DNFExpression.CreateFromTokens(pTokens);

  if(pTokens != pExp->pArrayOfTokens - 1)
    return WBEM_E_CRITICAL_ERROR;

  DNFExpression.Sort();

  // **** first, if there is a previous definition, delete it

  if(m_NLeaves > 0)
  {
    m_NLeaves = 0;
    delete[] m_ParseTreeLeaves;
  }

  // **** now, build new logic

  m_NLeaves = DNFExpression.GetNumTerms();

  m_ParseTreeLeaves = new _DatePattern[m_NLeaves];

  if(NULL == m_ParseTreeLeaves)
    return WBEM_E_OUT_OF_MEMORY;

  for(i = 0; (i < m_NLeaves) && SUCCEEDED(hres); i++)
  {
    #ifdef WQLDEBUG 
      if(i > 0) printf(" V ");
    #endif

    pConjunction = DNFExpression.GetTermAt(i);
    m_ParseTreeLeaves[i].m_Datum = new CDatePattern;

    if(NULL == m_ParseTreeLeaves[i].m_Datum)
      return WBEM_E_OUT_OF_MEMORY;

    #ifdef WQLDEBUG 
      printf("(");
    #endif
    for(j = 0; j < pConjunction->GetNumTokens(); j++)
    {
      #ifdef WQLDEBUG 
        if(j > 0) printf(" ^ ");
      #endif
      pToken = pConjunction->GetTokenAt(j);
      #ifdef WQLDEBUG 
        wprintf(L"%s", pToken->GetText());
      #endif

      hres = m_ParseTreeLeaves[i].m_Datum->AugmentPattern(pToken);
      if(FAILED(hres)) return WBEM_E_INVALID_QUERY;
    }
    m_ParseTreeLeaves[i].m_Index = 0;
    m_ParseTreeLeaves[i].m_Next = NULL;
    #ifdef WQLDEBUG 
      printf(")");
    #endif

    hres = m_ParseTreeLeaves[i].m_Datum->BuildSetsFromPatterns();
    if(FAILED(hres)) return WBEM_E_INVALID_QUERY;
  }

  return hres;
}

ULONGLONG WQLDateTime::SetStartTime(SYSTEMTIME *StartTime)
{
  int i;

  if(NULL == StartTime)
    return -1;

  // **** insert all alternatives into ordered list

  m_ListHead = NULL;

  for(i = 0; i < m_NLeaves; i++)
  {
     m_ParseTreeLeaves[i].m_Next = NULL;
     m_ParseTreeLeaves[i].m_Index = m_ParseTreeLeaves[i].m_Datum->SetStartTime(*StartTime);

     if((ULONGLONG)-1 != m_ParseTreeLeaves[i].m_Index)
       InsertOrdered(m_ParseTreeLeaves + i);
  }

  return GetNextTime(StartTime);
}

void WQLDateTime::InsertOrdered(_DatePattern *pNode)
{
  _DatePattern
    *pPrevDatePattern = NULL,
    *pDatePattern = m_ListHead;

  while(NULL != pDatePattern && (pNode->m_Index > pDatePattern->m_Index))
  {
    pPrevDatePattern = pDatePattern;
    pDatePattern = pDatePattern->m_Next;
  }

  pNode->m_Next = pDatePattern;
  if(NULL != pPrevDatePattern)
    pPrevDatePattern->m_Next = pNode;
  else
    m_ListHead = pNode;
}

ULONGLONG WQLDateTime::GetNextTime(SYSTEMTIME *NextTime)
{
  _DatePattern
    *pDate;

  ULONGLONG
    FiringTime;

  if(NULL != m_ListHead)
  {
    pDate = m_ListHead;
    m_ListHead = m_ListHead->m_Next;

    FiringTime = pDate->m_Index;

    if(NULL != NextTime)
      *NextTime = pDate->m_Datum->m_CurrentTime;

    pDate->m_Index = pDate->m_Datum->GetNextTime();

    // **** if next time is -1 then there are no future times
    // **** so don't add back into list

    if((ULONGLONG)-1 != pDate->m_Index)
      InsertOrdered(pDate);

    return FiringTime;
  }

  return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\makefile.inc ===
$(O)\wmitimep.mof $(O)\wmitimep.mfl: wmitimep.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wmitimepTmp.mof -MFL:$(O)\wmitimepTmp.mfl wmitimep.mof
    copy copyright.mof+$(O)\wmitimepTmp.mof+$(O)\wmitimepTmp.mfl $(O)\wmitimep.mof
    copy copyright.mof+$(O)\wmitimepTmp.mfl $(O)\wmitimep.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\dnf.cpp ===
#include <windows.h>
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include "dnf.h"
// #include "TwoPropNode.h"
// #include "dumbnode.h"

void CDNFExpression::CreateFromTokens(QL_LEVEL_1_TOKEN*& pLastToken,
                                        BOOL bNegate)
{
    QL_LEVEL_1_TOKEN& Head = *pLastToken;
    if(Head.nTokenType == QL1_OP_EXPRESSION)
    {
        CreateFromToken(Head, bNegate);
        pLastToken--;
        return;
    }

    // Build arguments
    // ===============

    pLastToken--;

    if(Head.nTokenType == QL1_NOT)
    {
        CreateFromTokens(pLastToken, !bNegate);
        return;
    }

    CDNFExpression Arg1;
    Arg1.CreateFromTokens(pLastToken, bNegate);

    CDNFExpression Arg2;
    Arg2.CreateFromTokens(pLastToken, bNegate);

    if(Head.nTokenType == QL1_AND)
    {
        CreateAnd(Arg1, Arg2);
    }
    else
    {
        CreateOr(Arg1, Arg2);
    }
}

void CDNFExpression::CreateAnd(CDNFExpression& Arg1, CDNFExpression& Arg2)
{
    for(long lFirst = 0; lFirst < Arg1.GetNumTerms(); lFirst++)
        for(long lSecond = 0; lSecond < Arg2.GetNumTerms(); lSecond++)
        {
            CConjunction* pNewTerm =
                new CConjunction(*Arg1.GetTermAt(lFirst),
                                    *Arg2.GetTermAt(lSecond));
            m_apTerms.Add(pNewTerm);
        }
}

void CDNFExpression::CreateOr(CDNFExpression& Arg1, CDNFExpression& Arg2)
{
    int i;
    for(i = 0; i < Arg1.GetNumTerms(); i++)
    {
        m_apTerms.Add(new CConjunction(*Arg1.GetTermAt(i)));
    }
    for(i = 0; i < Arg2.GetNumTerms(); i++)
    {
        m_apTerms.Add(new CConjunction(*Arg2.GetTermAt(i)));
    }
}

void CDNFExpression::CreateFromToken(QL_LEVEL_1_TOKEN& Token, BOOL bNegate)
{
    m_apTerms.Add(new CConjunction(Token, bNegate));
}

#ifdef UNDEFINED
HRESULT CDNFExpression::BuildTree(CContextMetaData* pNamespace,
                                  CImplicationList& Implications,
                                  CEvalNode** ppRes)
{
    HRESULT hres;

    // Check if there is only one conjunction to talk about
    // ====================================================

    if(m_apTerms.GetSize() == 1)
    {
        // Just build that one
        // ===================

        return m_apTerms[0]->BuildTree(pNamespace, Implications, ppRes);
    }

    // Build them for all conjunctions and OR together
    // ===============================================

    COrNode* pRes = new COrNode;
    if(pRes == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    for(int i = 0; i < m_apTerms.GetSize(); i++)
    {
        CEvalNode* pNew;
        hres = m_apTerms[i]->BuildTree(pNamespace, Implications, &pNew);
        if(FAILED(hres))
        {
            delete pRes;
            return hres;
        }

        hres = pRes->AddBranch(pNew);
        if(FAILED(hres))
        {
            delete pRes;
            return hres;
        }
    }

    *ppRes = pRes;
    return WBEM_S_NO_ERROR;
}
#endif

void CDNFExpression::Sort()
{
    for(int i = 0; i < m_apTerms.GetSize(); i++)
    {
        m_apTerms[i]->Sort();
    }
}


CConjunction::CConjunction(QL_LEVEL_1_TOKEN& Token, BOOL bNegate)
{
    m_apTokens.Add(new QL_LEVEL_1_TOKEN(Token));
    if(bNegate)
    {
        m_apTokens[0]->nOperator = NegateOperator(m_apTokens[0]->nOperator);
    }
}

CConjunction::CConjunction(CConjunction& Other)
{
    for(int i = 0; i < Other.GetNumTokens(); i++)
    {
        m_apTokens.Add(new QL_LEVEL_1_TOKEN(*Other.GetTokenAt(i)));
    }
}

CConjunction::CConjunction(CConjunction& Other1, CConjunction& Other2)
{
    int i;
    for(i = 0; i < Other1.GetNumTokens(); i++)
    {
        m_apTokens.Add(new QL_LEVEL_1_TOKEN(*Other1.GetTokenAt(i)));
    }

    for(i = 0; i < Other2.GetNumTokens(); i++)
    {
        m_apTokens.Add(new QL_LEVEL_1_TOKEN(*Other2.GetTokenAt(i)));
    }
}

int CConjunction::NegateOperator(int nOperator)
{
    switch(nOperator)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_ISNOTA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_INV_ISA;
    }

    return nOperator;
}

#ifdef UNDEFINED
HRESULT CConjunction::BuildTree(CContextMetaData* pNamespace,
                                  CImplicationList& Implications,
                                  CEvalNode** ppRes)
{
    HRESULT hres;

    // Build them for all tokens and AND together
    // ==========================================

    *ppRes = NULL;
    CImplicationList BranchImplications(Implications);
    for(int i = 0; i < m_apTokens.GetSize(); i++)
    {
        CEvalNode* pNew = NULL;
        hres = CEvalTree::BuildFromToken(pNamespace, BranchImplications,
            *m_apTokens[i], &pNew);
        if(FAILED(hres))
        {
            delete *ppRes;
            return hres;
        }

        if(i > 0)
        {
            CEvalNode* pOld = *ppRes;
            CEvalTree::Combine(pOld, pNew, EVAL_OP_AND, pNamespace,
                Implications, true, true, ppRes); // delete both
        }
        else
        {
            *ppRes = pNew;
        }
    }
    return WBEM_S_NO_ERROR;
}
#endif

void CConjunction::Sort()
{
    int i = 0;

    while(i < m_apTokens.GetSize() - 1)
    {
        int nLeft = m_apTokens[i]->PropertyName.GetNumElements();
        int nRight = m_apTokens[i+1]->PropertyName.GetNumElements();
        if(nLeft > nRight)
        {
            m_apTokens.Swap(i, i+1);
            if(i != 0)
            {
                i--;
            }
        }
        else
        {
            i++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\dnf.h ===
#include <parmdefs.h>
#include <ql.h>
#include <sync.h>
#include <limits.h>
#include <sortarr.h>

#ifndef __WBEM_EVALUTAION_TREE__H_
#define __WBEM_EVALUTAION_TREE__H_

class CConjunction
{
protected:
    CUniquePointerArray<QL_LEVEL_1_TOKEN> m_apTokens;

public:
    CConjunction(QL_LEVEL_1_TOKEN& Token, BOOL bNegate);
    CConjunction(CConjunction& Other);
    CConjunction(CConjunction& Other1, CConjunction& Other2);

    long GetNumTokens() {return m_apTokens.GetSize();}
    INTERNAL QL_LEVEL_1_TOKEN* GetTokenAt(int nIndex)
        {return m_apTokens[nIndex];}
    void AddToken(ACQUIRE QL_LEVEL_1_TOKEN* pNew)
        {m_apTokens.Add(pNew);}

//    HRESULT BuildTree(CContextMetaData* pNamespace,
//                                  CImplicationList& Implications,
//                                  CEvalNode** ppRes);
    void Sort();
    static int NegateOperator(int nOperator);
};

class CDNFExpression
{
protected:
    CUniquePointerArray<CConjunction> m_apTerms;

protected:
    void CreateFromToken(QL_LEVEL_1_TOKEN& Token, BOOL bNegate = FALSE);
    void CreateOr(CDNFExpression& Arg1, CDNFExpression& Arg2);
    void CreateAnd(CDNFExpression& Arg1, CDNFExpression& Arg2);

public:
    long GetNumTerms() {return m_apTerms.GetSize();}
    INTERNAL CConjunction* GetTermAt(int nIndex)
        {return m_apTerms[nIndex];}
    void AddTerm(ACQUIRE CConjunction* pNew)
        {m_apTerms.Add(pNew);}
//    HRESULT BuildTree(CContextMetaData* pNamespace,
//                                  CImplicationList& Implications,
//                                  CEvalNode** ppRes);

    void CreateFromTokens(QL_LEVEL_1_TOKEN*& pLastToken, BOOL bNegate = FALSE);
    void Sort();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\datep.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

/******************************************************************/

#ifndef __WBEM_TIME__DATEP__H_
#define __WBEM_TIME__DATEP__H_

#include <ql.h>
#define SETMIN ((__int64)0x0000000000000001)
#define SETMAX ((__int64)0x8000000000000000)
#define SETEMPTY ((__int64)0x0000000000000000)
#define SETFULL ((__int64)0xFFFFFFFFFFFFFFFF)

struct COrderedUniqueSet64
{
  ULONGLONG
    m_BitField; // m_BitField MUST be an unsigned type

  COrderedUniqueSet64(void);

  COrderedUniqueSet64 
    Set(ULONGLONG n),
    Add(ULONGLONG n),
    Remove(ULONGLONG n),
    Union(COrderedUniqueSet64 n),
    Intersection(COrderedUniqueSet64 n),
    UpperBound(ULONGLONG n),
    LowerBound(ULONGLONG n),
    Rotate(int n);

  int 
    Member(ULONGLONG n);

  unsigned 
    Next(ULONGLONG n),
    Prev(ULONGLONG n);
};

/******************************************************************/

struct CPattern
{
  enum
  {
    UPPERBOUND = 0x00000001,
    LOWERBOUND = 0x00000002,
    MODULUS    = 0x00000004,
    EQUALTO    = 0x00000008,
    NOTEQUALTO = 0x00000010
  };

  unsigned 
    m_FieldsUsed,
    m_UpperBound,
    m_LowerBound,
    m_Modulus,
    m_EqualTo,
    m_CountNotEqualTo,
    m_NotEqualTo[64];

  CPattern(void) 
  { m_FieldsUsed = 0x0; m_CountNotEqualTo = 0x0; }

  unsigned
    GetNextValue(unsigned x);
};

/******************************************************************/

struct CDatePattern
{
  enum
  {
    INDX_Year = 0,
    INDX_Month,
    INDX_Day,
    INDX_DayOfWeek,
    INDX_WeekInMonth,
    INDX_Quarter,
    INDX_Hour,
    INDX_Minute,
    INDX_Second,
    INDX_MAX
  };

  COrderedUniqueSet64        
    m_Set[CDatePattern::INDX_MAX + 1]; // use extra set as buffer in
                         // GetDayInMonth()

  CPattern
    m_Pattern[CDatePattern::INDX_MAX];

  SYSTEMTIME
    m_CurrentTime;

  int 
    FieldIndx(const wchar_t *suName);

  ULONGLONG 
    GetNextTime(SYSTEMTIME *pSystemTime = NULL),
    SetStartTime(SYSTEMTIME StartTime);

  HRESULT
    AugmentPattern(QL_LEVEL_1_TOKEN *pExp),
    BuildSetsFromPatterns(void),
    MapPatternToSet(CPattern *pPattern, COrderedUniqueSet64 *pSet),
    GetDaysInMonth(WORD iYear, WORD iMonth);
};

/******************************************************************/

struct WQLDateTime
{
  struct _DatePattern
  {
    CDatePattern 
      *m_Datum;

    ULONGLONG 
      m_Index;

    _DatePattern
      *m_Next;

    _DatePattern(void)
    { m_Datum = NULL; m_Next = NULL; m_Index = 0; }

    ~_DatePattern(void)
    { if(NULL != m_Datum) delete m_Datum; }
  } 
    *m_ParseTreeLeaves, 
    *m_ListHead;

  int
    m_NLeaves;

  WQLDateTime(void)
  { m_ParseTreeLeaves = m_ListHead = NULL; m_NLeaves = 0; }
  
  ~WQLDateTime(void)
  { if(NULL != m_ParseTreeLeaves) delete [] m_ParseTreeLeaves; }

  HRESULT 
    Init(QL_LEVEL_1_RPN_EXPRESSION *pExp = NULL);

  ULONGLONG 
    SetStartTime(SYSTEMTIME *StartTime),
    GetNextTime(SYSTEMTIME *NextTime = NULL);

  void 
    InsertOrdered(_DatePattern *pNode);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\timemain.cpp ===
#include <windows.h>
#include <commain.h>
#include <clsfac.h>
#include <win32clock.h>

#include <tchar.h>

// {C4819C8D-9AB8-4b2f-B8AE-C77DABF553D5}
static const CLSID CLSID_CurrentTimeProvider = {0xc4819c8d, 0x9ab8, 0x4b2f, {0xb8, 0xae, 0xc7, 0x7d, 0xab, 0xf5, 0x53, 0xd5}};

class CMyServer : public CComServer
{
protected:
    HRESULT Initialize()
    {
        AddClassInfo( CLSID_CurrentTimeProvider, 
                      new CSimpleClassFactory<CWin32Clock>(GetLifeControl()),
                      _T("Current Time Provider"), TRUE );

        return S_OK;
    }
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\win32clock.h ===
/*
  Copyright (c) 1997-1999 Microsoft Corporation.

  File:  Win32Clock.H

  Description:
        Alarm event provider - header file defines alarm provider class

  History:
*/


#ifndef _WIN32CLOCKPROV_H_
#define _WIN32CLOCKPROV_H_

#include <objbase.h>
#include <wbemprov.h>
#include "tss.h"
#include "datep.h"
#include <unk.h>

/*
class Win32_CurrentTime
{
  uint16 Year;
  uint32 Month;
  uint32 Day;
  uint32 DayOfWeek;
  uint32 WeekInMonth;
  uint32 Quarter;
  uint32 Hour;
  uint32 Minute;
  uint32 Second;
};
*/

#define WIN32LOCALTIMECLASS  L"Win32_LocalTime"
#define WIN32UTCTIMECLASS  L"Win32_UTCTime"
#define INSTMODEVCLASS  L"__InstanceModificationEvent"

template <class T> class CArray
{
  int
    m_nElts;

  struct _Node { ULONG m_Key; T *m_pT; _Node *m_pNext; }
    *m_pHead;

  CRITICAL_SECTION
    m_hModificationLock;

public:

  CArray(void)
  { 
    m_pHead = NULL; m_nElts = 0; 
    InitializeCriticalSection(&m_hModificationLock); 
  }

  ~CArray(void)
  {
    DeleteCriticalSection(&m_hModificationLock);
  }

  void Lock(void) 
  { EnterCriticalSection(&m_hModificationLock); }

  void UnLock(void)
  { LeaveCriticalSection(&m_hModificationLock); }

  void Insert(T *pT, ULONG Key)  
  // **** to check for dup. keys, change this to sorted order
  {
    Lock();

    _Node
      *pNewNode = NULL;

    if(Key == -1) return;

    pNewNode = new _Node();

    if(NULL == pNewNode) return;

    pNewNode->m_pT = pT; pT->AddRef();
    pNewNode->m_Key = Key;
    pNewNode->m_pNext = m_pHead;
    m_pHead = pNewNode;

    m_nElts++;

    UnLock();
  }

  void Remove(T *pT)
  {
    Lock();

    _Node
      *pCurrent = m_pHead,
      *pPrev = NULL;

    // **** find element using pointer

    while((NULL != pCurrent) && (pCurrent->m_pT != pT))
    {
      pPrev = pCurrent;
      pCurrent = pCurrent->m_pNext;
    }

    // **** remove element, if found, from queue

    if(NULL != pCurrent)
    {
      if(NULL == pPrev)
        m_pHead = m_pHead->m_pNext;
      else
        pPrev->m_pNext = pCurrent->m_pNext;

      pCurrent->m_pT->Release();
      delete pCurrent;
      m_nElts--;
    }

    UnLock();
  }

  // **** find element by Index

  T* operator[] (ULONG Index)
  {
    _Node
      *pCurrent = m_pHead;

    // **** get element using array index
  
    if( Index >= m_nElts )
      return NULL;

    while((NULL != pCurrent) && (Index > 0))  // optimize?
    {
      pCurrent = pCurrent->m_pNext;
      Index--;
    }

    if(NULL != pCurrent)
      return pCurrent->m_pT;

    return NULL;
  }

  // **** get element by key

  T* operator() (ULONG Key, BOOL bLock = FALSE)
  {
    if(TRUE == bLock) Lock();

    _Node
      *pCurrent = m_pHead;

    // **** find element using Key

    while((pCurrent != NULL) && (pCurrent->m_Key != Key))  // optimize?
      pCurrent = pCurrent->m_pNext;

    if(NULL != pCurrent)
      return pCurrent->m_pT;
    else
      if(TRUE == bLock) UnLock();

    return NULL;
  }
};
      
class CWin32Clock
: 
public IWbemEventProvider, 
public IWbemEventProviderQuerySink, 
public IWbemServices,
public IWbemProviderInit
{
public:

  class CScheduledEvent : public CTimerInstruction
  {
  public:

    enum { TypeNONE = 0, TypeUTC, TypeLocal };

    ULONG
      m_Type,
      m_cRef,        // reference count on this object
      m_dwId;        // unique id assigned by WMI

    ULONGLONG
      m_stLastFiringTime;    // the first, and possibly only, firing
                     // time for the event generator

    CWin32Clock
      *m_pWin32Clock; // ptr back to clock obj containing 
                      // this CScheduledEvent object

    wchar_t
      *m_WQLStmt;     // WQL stmt that defines behavior for
                      // this CScheduledEvent object

    int 
      m_nDatePatterns; // # of date pattern objects

    WQLDateTime
      m_WQLTime;       // interprets WQL statement and 
                       // calculates next firing time

    // Local members

    CScheduledEvent();
    ~CScheduledEvent();

    HRESULT Init(CWin32Clock *pClock, wchar_t *WQLStmt, ULONG dwId);
    HRESULT ReInit(wchar_t *WQLStmt);

    void GetTime(SYSTEMTIME *CurrentTime) const;
    void GetFileTime(FILETIME *CurrentTime) const;

    // Inherited from CTimerInstruction

    void AddRef();
    void Release();
    int GetInstructionType();

    CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
                                long* plFiringCount) const;
    CWbemTime GetFirstFiringTime() const;
    HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
  };

  CLifeControl* m_pControl;
  CCritSec      m_csWin32Clock;

  // **** WMI attributes for both Event and Instance providers

  CTimerGenerator   m_Timer;             // timer object to hold pending events
  ULONG             m_cRef;              // reference count on this object
  IWbemServices     *m_pNs;              // resource handle to wmi service daemon
  IWbemClassObject  *m_pLocalTimeClassDef;    // CIM class def for Win32_CurrentTime
  IWbemClassObject  *m_pUTCTimeClassDef;    // CIM class def for Win32_CurrentTime

  // **** WMI Event Provider specific attributes

  ULONGLONG         m_MostRecentLocalFiringTime;
  ULONGLONG         m_MostRecentUTCFiringTime;
  IWbemObjectSink   *m_pSink;            // sink object in which to place inst. objs
  IWbemClassObject  *m_pInstModClassDef; // class def for __InstanceModificationEvent
  HANDLE            m_ClockResetThread;  // holds thread that adjusts firing times
                                         // when the clock is reset
  HWND              m_hEventWindowHandle;

  CArray<CScheduledEvent> m_EventArray;  // array of clock provider objects

public:

  CWin32Clock(CLifeControl* pControl);
 ~CWin32Clock();

  // local members

  static DWORD AsyncEventThread(LPVOID pArg);

  static HRESULT SystemTimeToWin32_CurrentTime(IWbemClassObject *pClassDef, IWbemClassObject ** pNewInst, SYSTEMTIME *TheTime);

  HRESULT SendEvent(IWbemClassObject *pSystemTime);

  HRESULT ReAlignToCurrentTime(void);

  // IUnknown members

  STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
  STDMETHODIMP_(ULONG) AddRef(void);
  STDMETHODIMP_(ULONG) Release(void);

  // Inherited from IWbemEventProvider

  HRESULT STDMETHODCALLTYPE ProvideEvents( 
          /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
          /* [in] */ long lFlags);

  // Inherited from IWbemEventProviderQuerySink

  HRESULT STDMETHODCALLTYPE NewQuery(
          /* [in] */ unsigned long dwId,
          /* [in] */ wchar_t *wszQueryLanguage,
          /* [in] */ wchar_t *wszQuery);

  HRESULT STDMETHODCALLTYPE CancelQuery(
          /* [in] */ unsigned long dwId);

  // Inherited from IWbemProviderInit

  HRESULT STDMETHODCALLTYPE Initialize(
          /* [in] */ LPWSTR pszUser,
          /* [in] */ LONG lFlags,
          /* [in] */ LPWSTR pszNamespace,
          /* [in] */ LPWSTR pszLocale,
          /* [in] */ IWbemServices __RPC_FAR *pNamespace,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);

  // Inherited from IWbemServices

  HRESULT STDMETHODCALLTYPE OpenNamespace( 
          /* [in] */ const BSTR Namespace,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
          /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE QueryObjectSink( 
          /* [in] */ long lFlags,
          /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE GetObject( 
          /* [in] */ const BSTR ObjectPath,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE GetObjectAsync( 
          /* [in] */ const BSTR ObjectPath,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
      
  HRESULT STDMETHODCALLTYPE PutClass( 
          /* [in] */ IWbemClassObject __RPC_FAR *pObject,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE PutClassAsync( 
          /* [in] */ IWbemClassObject __RPC_FAR *pObject,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE DeleteClass( 
          /* [in] */ const BSTR Class,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
          /* [in] */ const BSTR Class,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CreateClassEnum( 
          /* [in] */ const BSTR Superclass,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
          /* [in] */ const BSTR Superclass,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE PutInstance( 
          /* [in] */ IWbemClassObject __RPC_FAR *pInst,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
          /* [in] */ IWbemClassObject __RPC_FAR *pInst,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE DeleteInstance( 
          /* [in] */ const BSTR ObjectPath,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
          /* [in] */ const BSTR ObjectPath,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
          /* [in] */ const BSTR Class,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
          /* [in] */ const BSTR Class,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
      
  HRESULT STDMETHODCALLTYPE ExecQuery( 
          /* [in] */ const BSTR QueryLanguage,
          /* [in] */ const BSTR Query,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
          /* [in] */ const BSTR QueryLanguage,
          /* [in] */ const BSTR Query,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
          /* [in] */ const BSTR QueryLanguage,
          /* [in] */ const BSTR Query,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
      
  HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
          /* [in] */ const BSTR QueryLanguage,
          /* [in] */ const BSTR Query,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
  HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
          IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

  HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
          IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaplug\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\win32clock.cpp ===
/*
  CWin32Clock.CPP

  Module: WMI Current Time Instance Provider

  Purpose: The methods of CWin32Clock class are defined here.  

  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
*/

#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemcomn.h>
#undef _ASSERT
#include <atlbase.h>
#include "genlex.h"
#include "objpath.h"
#include "dnf.h"
#include "datep.h"
#include "Win32Clock.h"

// **** long glNumInst = sizeof(MyDefs)/sizeof(InstDef);

/****************************************************************************/

CWin32Clock::CScheduledEvent::CScheduledEvent(void)
{
  
  m_Type = TypeNONE;
  m_cRef = 0;
  m_dwId = -1;
  m_stLastFiringTime = 0;
  m_pWin32Clock = NULL;
  m_WQLStmt = NULL;
}

CWin32Clock::CScheduledEvent::~CScheduledEvent(void)
{
  if(0 != m_cRef)
  {
    // ****  error
  }

  if(NULL != m_WQLStmt)
    delete[] m_WQLStmt;
}

HRESULT CWin32Clock::CScheduledEvent::Init(CWin32Clock *pClock,
                                           wchar_t *WQLStmt,
                                           ULONG dwId)
{
  HRESULT
    hr = S_OK;

  // ****  check for valid arguments

  if((NULL == pClock) || (NULL == WQLStmt) || (-1 == dwId))
    return WBEM_E_FAILED;

  // ****  copy to local arguments

  if((NULL != m_pWin32Clock) || (NULL != m_WQLStmt))
    return WBEM_E_FAILED;

  m_dwId = dwId;

  m_pWin32Clock = pClock;  // ****  note: no AddRef() is done here because 
                           // ****  the lifetime of this CScheduledEvent obj is
                           // ****  ALWAYS encapsulated within that of pClock

  // ****  now parse m_WQLStmt to determine values for timer start and interval

  hr = ReInit(WQLStmt);

  return hr;
}

HRESULT CWin32Clock::CScheduledEvent::ReInit(wchar_t *WQLStmt)
{
  HRESULT 
    hr = WBEM_E_FAILED;

  int 
    nRes;

  if(NULL != m_WQLStmt)
    delete[] m_WQLStmt;

  // ****  save WQL expression

  m_WQLStmt = new wchar_t[wcslen(WQLStmt) + 1];
  if(NULL == m_WQLStmt)
    return WBEM_E_OUT_OF_MEMORY;

  wcscpy(m_WQLStmt, WQLStmt);

  // ****  parse WQL expression

  CTextLexSource src(m_WQLStmt);
  QL1_Parser parser(&src);
  QL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;
  QL_LEVEL_1_TOKEN *pToken = NULL;

  #ifdef WQLDEBUG
     wchar_t classbuf[128];
     *classbuf = 0;
     printf("[1] ----GetQueryClass----\n");
     nRes = parser.GetQueryClass(classbuf, 128);
     if (nRes)
     {
       printf("ERROR %d: line %d, token %S\n",
         nRes,
         parser.CurrentLine(),
         parser.CurrentToken());
     }
     printf("Query class is %S\n", classbuf);
  #endif

  if(nRes = parser.Parse(&pExp))
  {
    #ifdef WQLDEBUG
      if (nRes)
      {
        printf("ERROR %d: line %d, token %S\n",
          nRes,
          parser.CurrentLine(),
          parser.CurrentToken());
      }
      else
      {
        printf("No errors.\n");
      }
    #endif

    hr = WBEM_E_INVALID_QUERY;
    goto cleanup;
  }

  // ****  validate WQL statement

  if((NULL == pExp) ||
     (NULL == pExp->bsClassName) ||
     (_wcsicmp(L"__InstanceModificationEvent", pExp->bsClassName)) ||
     (pExp->nNumTokens < 1))
  {
    #ifdef WQLDEBUG
      printf("WQL statement failed validation\n");
    #endif

    hr = WBEM_E_INVALID_QUERY;
    goto cleanup;
  }

  // **** determine type

  for(int i = 0; i < pExp->nNumTokens && (m_Type == TypeNONE); i++)
  {
    pToken = pExp->pArrayOfTokens + i;

    if(NULL == pToken) continue;

    long nElts = pToken->PropertyName.GetNumElements();
    LPCWSTR pAttrName = pToken->PropertyName.GetStringAt(nElts -1);

    if((NULL != pAttrName) && 
       (0 == _wcsicmp(L"targetinstance", pAttrName)) &&
       (pToken->nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION) &&
       (pToken->vConstValue.vt == VT_BSTR))
    {
      if(0 == _wcsicmp(WIN32LOCALTIMECLASS, pToken->vConstValue.bstrVal)) m_Type = TypeLocal;
      else if(0 == _wcsicmp(WIN32UTCTIMECLASS, pToken->vConstValue.bstrVal)) m_Type = TypeUTC;
    }
  }

  if(TypeNONE == m_Type)
  {
    hr = WBEM_E_INVALID_QUERY;
    goto cleanup;
  }

  // **** interpret WQL Expression

  #ifdef WQLDEBUG
    printf("\n[2] ----ShowParseTree----\n");
    pExp->Dump("CON");
    printf("\n[3] ----ShowRebuiltQuery----\n");
    LPWSTR wszText = pExp->GetText();
    printf("--WQL passed to provider--\n");
    printf("%S\n", wszText);
    printf("\n[4] ----ShowInterpretation----\n");
  #endif

  try
  {
    hr = m_WQLTime.Init(pExp);
  }
  catch(...)
  {
    hr = WBEM_E_FAILED;
    goto cleanup;
  }

  #ifdef WQLDEBUG
    printf("\n\n[5] ----End of WQL Compilation----\n");
    delete [] wszText;
  #endif

cleanup:

  delete pExp;

  return hr;
}

void CWin32Clock::CScheduledEvent::AddRef()
{
  InterlockedIncrement((long *)&m_cRef);
}

void CWin32Clock::CScheduledEvent::Release()
{
  ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

  if(0L == nNewCount)
    delete this;
}

int CWin32Clock::CScheduledEvent::GetInstructionType()
{
  return INSTTYPE_WBEM;
}

CWbemTime CWin32Clock::CScheduledEvent::GetNextFiringTime(CWbemTime LastFiringTime,
                                                          long *plFiringCount) const
{
  FILETIME
    FileTime,
    FileTime2;

  ULONGLONG
    NextFiringTime,
    CurrentTime;

  CWbemTime
    ResultTime;

  int
    nMisses = 0;

  // **** save the firing time for event just fired from LastFiringTime

  ((CWin32Clock::CScheduledEvent*)this)->m_stLastFiringTime = LastFiringTime.Get100nss();

  // ****  calculate the next firing time after LastFiringTime and after the current time

  GetFileTime(&FileTime);

  CurrentTime = FileTime.dwHighDateTime;
  CurrentTime = (CurrentTime << 32) + FileTime.dwLowDateTime;

  while((NextFiringTime = ((WQLDateTime*)&m_WQLTime)->GetNextTime()) <= CurrentTime)
    nMisses += 1;

  if(-1 == NextFiringTime)
  {
    // ****  no future event to be scheduled so, so indicate

    return CWbemTime::GetInfinity();
  }

  if(NULL != plFiringCount)
    *plFiringCount = nMisses;

  // **** if local time, convert to UTC time for the scheduling logic

  if(TypeLocal == m_Type)
  {
    FileTime.dwLowDateTime = ((NextFiringTime << 32) >> 32);
    FileTime.dwHighDateTime = (NextFiringTime >> 32);

    LocalFileTimeToFileTime(&FileTime, &FileTime2);

    NextFiringTime = FileTime2.dwHighDateTime;
    NextFiringTime = (NextFiringTime << 32) + FileTime2.dwLowDateTime;
  }

  ResultTime.Set100nss(NextFiringTime);

  return ResultTime;
}

CWbemTime CWin32Clock::CScheduledEvent::GetFirstFiringTime() const
{
  SYSTEMTIME
    CurrentTime;

  CWbemTime
    ResultTime;

  ULONGLONG
    ullStartTime;

  GetTime(&CurrentTime);

  /*
    Since the finest granularity used by the time provider is seconds, set milliseconds
    to zero so that we can compare two FILETIME values in the Fire method and have
    the numbers agree.
  */

  CurrentTime.wMilliseconds = 0;

  ullStartTime = ((WQLDateTime*)&m_WQLTime)->SetStartTime(&CurrentTime);

  if(TypeLocal == m_Type)
  {
    FILETIME
      FileTime,
      FileTime2;

    FileTime.dwLowDateTime = ((ullStartTime << 32) >> 32);
    FileTime.dwHighDateTime = (ullStartTime >> 32);

    LocalFileTimeToFileTime(&FileTime, &FileTime2);

    ullStartTime = FileTime2.dwHighDateTime;
    ullStartTime = (ullStartTime << 32) + FileTime2.dwLowDateTime;
  }

  ResultTime.Set100nss(ullStartTime);

  return ResultTime;
}

HRESULT CWin32Clock::CScheduledEvent::Fire(long lNumTimes, 
                                           CWbemTime NextFiringTime)
{
  HRESULT
    hr = WBEM_E_FAILED;

  FILETIME
    ft,
    ft2;

  SYSTEMTIME
    SystemTime;

  CComPtr<IWbemClassObject>
    pSystemTime;

  // ****  Do a check of arguments and make sure we have pointer to sink obj

  if((NULL == m_pWin32Clock) || (NULL == m_pWin32Clock->m_ClockResetThread))
  {
    hr = WBEM_E_INVALID_PARAMETER;
  }

  // ****  create an instance of Win32_CurrentTime for each timezone

  else
  {
    CInCritSec 
      ics(&(m_pWin32Clock->m_csWin32Clock));

    // **** reconstitute a SYSTEMTIME from the current firing time

    ft.dwLowDateTime = ((m_stLastFiringTime << 32) >> 32);
    ft.dwHighDateTime = (m_stLastFiringTime >> 32);

    if(((TypeLocal == m_Type) && (m_pWin32Clock->m_MostRecentLocalFiringTime != m_stLastFiringTime)) ||
       ((TypeUTC == m_Type) && (m_pWin32Clock->m_MostRecentUTCFiringTime != m_stLastFiringTime)))
    {
      if(TypeLocal == m_Type) 
      {
        m_pWin32Clock->m_MostRecentLocalFiringTime = m_stLastFiringTime;
        FileTimeToLocalFileTime(&ft, &ft2);
        ft = ft2;
      }
      else if(TypeUTC == m_Type) 
        m_pWin32Clock->m_MostRecentUTCFiringTime = m_stLastFiringTime;

      if(FileTimeToSystemTime(&ft, &SystemTime))
      {
        #ifdef WQLDEBUG
          printf("[%d] Fire: Misses(%d) %d/%d/%d %d:%d:%d",
            m_dwId,
            lNumTimes,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
        #else
          // ****  Send the object to the caller

          if(TypeUTC == m_Type)
            hr = CWin32Clock::SystemTimeToWin32_CurrentTime(m_pWin32Clock->m_pUTCTimeClassDef, &pSystemTime, &SystemTime);
          else if(TypeLocal == m_Type)
            hr = CWin32Clock::SystemTimeToWin32_CurrentTime(m_pWin32Clock->m_pLocalTimeClassDef, &pSystemTime, &SystemTime);

          hr = m_pWin32Clock->SendEvent(pSystemTime);
        #endif
      }
      else
        hr = WBEM_E_FAILED;
    }
  }

  return hr;
}

/******************************************************************/

LRESULT CALLBACK Win32ClockProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   return DefWindowProc(hWnd, msg, wParam, lParam);
}

DWORD CWin32Clock::AsyncEventThread(LPVOID pArg)
{
  if(NULL == pArg) 
    return -1;

  CWin32Clock 
    *pCWin32Clock = (CWin32Clock*)pArg;

  WNDCLASS wndclass;
  MSG msg;

  BOOL bRet;

  // **** create top level window to receive system messages

  wndclass.style = 0;
  wndclass.lpfnWndProc = Win32ClockProc;
  wndclass.cbClsExtra = 0;
  wndclass.cbWndExtra = sizeof(DWORD);
  wndclass.hInstance = GetModuleHandle(NULL);
  wndclass.hIcon = NULL;
  wndclass.hCursor = NULL;
  wndclass.hbrBackground = NULL;
  wndclass.lpszMenuName = NULL;
  wndclass.lpszClassName = TEXT("Win32Clock");

  if(!RegisterClass(&wndclass))
  {
    if(GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
    {
      return NULL;
    }
  }

  HMODULE
    hModule = GetModuleHandle(NULL);

  if(NULL == hModule)
    return -1;

  try
  {
    pCWin32Clock->m_hEventWindowHandle = CreateWindow(TEXT("Win32Clock"),
                                        TEXT("Win32ClockMsgs"),
                                        WS_OVERLAPPED,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        HWND_MESSAGE, 
                                        NULL, 
                                        hModule,
                                        NULL);
  }
  catch(...)
  {
    return -1;
  }

  if(NULL == pCWin32Clock->m_hEventWindowHandle)
  {
    return NULL;
  }

  ShowWindow(pCWin32Clock->m_hEventWindowHandle, SW_HIDE);

  // **** start the message loop

  while(GetMessage(&msg, pCWin32Clock->m_hEventWindowHandle, 0, 0))
  {
    switch (msg.message)
    {
      case WM_TIMECHANGE:
        pCWin32Clock->ReAlignToCurrentTime();
        break;

      default:
        DefWindowProc(pCWin32Clock->m_hEventWindowHandle, msg.message, msg.wParam, msg.lParam);
    }
  }

  // **** cleanup

  bRet = DestroyWindow(pCWin32Clock->m_hEventWindowHandle);

  bRet = UnregisterClass(TEXT("Win32Clock"), 0);

  return 0;
}

void CWin32Clock::CScheduledEvent::GetTime(SYSTEMTIME *TheTime) const
{
  if(NULL != TheTime)
  {
    memset(TheTime, 0, sizeof(SYSTEMTIME));

    if(TypeLocal == m_Type)
      GetLocalTime(TheTime);
    else if(TypeUTC == m_Type)
      GetSystemTime(TheTime);
  }
}

void CWin32Clock::CScheduledEvent::GetFileTime(FILETIME *TheTime) const
{
  SYSTEMTIME
    SysTime;

  if(NULL != TheTime)
  {
    memset(TheTime, 0, sizeof(FILETIME));

    if(TypeLocal == m_Type)
    {
      GetLocalTime(&SysTime);
      SystemTimeToFileTime(&SysTime, TheTime);
    }
    else if(TypeUTC == m_Type)
    {
      GetSystemTime(&SysTime);
      SystemTimeToFileTime(&SysTime, TheTime);
    }
  }
}

HRESULT CWin32Clock::SendEvent(IWbemClassObject *pSystemTime)
{
  HRESULT 
    hr = WBEM_E_FAILED;

  CComPtr<IWbemClassObject>
    pInstanceModEvnt;

  CComVariant
    v;

  // **** if m_pSink has not been provided by winmgmt just drop
  // **** generated events on the floor

  if((NULL != m_pSink) && (NULL != pSystemTime))
  {
    // ****  create and init instance of __InstanceModificationEvent
 
    hr = m_pInstModClassDef->SpawnInstance(0, &pInstanceModEvnt);
    if(FAILED(hr)) return hr;

    // ****  put Win32_CurrentTime into __InstanceModificationEvent

    v.vt = VT_UNKNOWN;
    v.punkVal = NULL;
    hr = pSystemTime->QueryInterface(IID_IUnknown, (void**)&(v.punkVal));
    if(FAILED(hr)) return hr;

    hr = pInstanceModEvnt->Put(L"TargetInstance", 0, &v, 0);
    if(FAILED(hr)) return hr;

    // ****  deliver new event to WMI

    hr = m_pSink->Indicate(1, &pInstanceModEvnt);
  }

  return hr;
}

HRESULT CWin32Clock::ReAlignToCurrentTime()
{
  CInCritSec 
    ics(&m_csWin32Clock);

  HRESULT 
    hr = S_OK;

  ULONG 
    i,
    nElts;

  CScheduledEvent
    *pcEvent;

  #ifdef WQLDEBUG
    printf("System Clock Resync\n");
  #endif

  m_EventArray.Lock();

  nElts = *(ULONG *)(&(this->m_EventArray)); // voodoo

  m_MostRecentLocalFiringTime = 0;
  m_MostRecentUTCFiringTime = 0;

  for(i = 0; i < nElts; i++)
  {
    // **** pull event from the event queue

    pcEvent = m_EventArray[i];

    if(NULL != pcEvent)
    {
      // **** change time for event obj and re-queue

      m_Timer.Remove(&CIdentityTest(pcEvent));
      m_Timer.Set(pcEvent);
    }
  }

  m_EventArray.UnLock();

  return hr;
}

CWin32Clock::CWin32Clock(CLifeControl* pControl)
: m_Timer(), m_EventArray(), m_pControl(pControl)
{
  pControl->ObjectCreated((IWbemServices*)this);

  m_cRef = 0;
  m_MostRecentLocalFiringTime = 0;
  m_MostRecentUTCFiringTime = 0;
  m_pNs = NULL;
  m_pSink = NULL;
  m_pInstModClassDef = NULL;
  m_pLocalTimeClassDef = NULL;
  m_pUTCTimeClassDef = NULL;
  m_ClockResetThread = NULL;
  m_hEventWindowHandle = NULL;
}

CWin32Clock::~CWin32Clock(void)
{
  // ****  Kill Async thread if it has been started

  if(NULL != m_ClockResetThread)
  {
    BOOL
      bRes;

    do
    {
      bRes = PostMessage(m_hEventWindowHandle, WM_QUIT, 0, 0);
    }
    while(WAIT_TIMEOUT == WaitForSingleObject(m_ClockResetThread, 6000));
  }

  // **** shutdown event thread

  m_Timer.Shutdown();

  // **** release all held COM objects

  if(NULL != m_pNs) m_pNs->Release();
  if(NULL != m_pSink) m_pSink->Release();
  if(NULL != m_pInstModClassDef) m_pInstModClassDef->Release();
  if(NULL != m_pLocalTimeClassDef) m_pLocalTimeClassDef->Release();
  if(NULL != m_pUTCTimeClassDef) m_pUTCTimeClassDef->Release();

  m_pControl->ObjectDestroyed((IWbemServices*)this);
}

// **** ***************************************************************************
// **** 
// ****  CWin32Clock::QueryInterface
// ****  CWin32Clock::AddRef
// ****  CWin32Clock::Release
// **** 
// ****  Purpose: IUnknown members for CWin32Clock object.
// **** ***************************************************************************


STDMETHODIMP CWin32Clock::QueryInterface(REFIID riid, PVOID *ppv)
{
  *ppv=NULL;

  // ****  cast to the type of the base class specified by riid

  if(IID_IWbemEventProvider == riid)
  {
    *ppv = (IWbemEventProvider *)this;
  }
  else if(IID_IWbemEventProviderQuerySink == riid)
  {
    *ppv = (IWbemEventProviderQuerySink *)this;
  }
  else if(IID_IWbemServices == riid)
  {
    *ppv=(IWbemServices*)this;
  }
  else if(IID_IUnknown == riid || IID_IWbemProviderInit == riid)
  {
    *ppv=(IWbemProviderInit*)this;
  }
    
  if(NULL!=*ppv) 
  {
    AddRef();

    return S_OK;
  }
  else
    return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CWin32Clock::AddRef(void)
{
  return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) CWin32Clock::Release(void)
{
  ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

  if(0L == nNewCount)
    delete this;
    
  return nNewCount;
}

/*
  IWbemProviderInit::Initialize

  Purpose: This is the implementation of IWbemProviderInit. The method
           is need to initialize with CIMOM.

           The members set up include:
           m_pNs
           m_pLocalTimeClassDef
           m_pUTCTimeClassDef
           m_pInstModClassDef
*/

HRESULT CWin32Clock::Initialize(LPWSTR pszUser, 
                                LONG lFlags,
                                LPWSTR pszNamespace, 
                                LPWSTR pszLocale,
                                IWbemServices *pNamespace, 
                                IWbemContext *pCtx,
                                IWbemProviderInitSink *pInitSink)
{
  HRESULT 
    hr = WBEM_E_FAILED;

  if((NULL != pNamespace) && (NULL != pInitSink))
  {
    m_pNs = pNamespace;
    m_pNs->AddRef();

    // ****  get needed class definitions 

    hr = m_pNs->GetObject(WIN32LOCALTIMECLASS, 
                          0, pCtx, &m_pLocalTimeClassDef, 0);

    if(SUCCEEDED(hr))
      hr = m_pNs->GetObject(WIN32UTCTIMECLASS, 
                            0, pCtx, &m_pUTCTimeClassDef, 0);

    if(SUCCEEDED(hr))
      hr = m_pNs->GetObject(INSTMODEVCLASS,
                            0, pCtx, &m_pInstModClassDef, 0);

    if(WBEM_S_NO_ERROR == hr)
    {
      pInitSink->SetStatus(WBEM_S_INITIALIZED,0);

      hr = WBEM_NO_ERROR;
    }
  }

  // ****  if there was a problem, release the resources we have aquired

  if(FAILED(hr))
  {
    if(NULL != m_pLocalTimeClassDef) { m_pLocalTimeClassDef->Release(); m_pLocalTimeClassDef = NULL; }
    if(NULL != m_pUTCTimeClassDef) { m_pUTCTimeClassDef->Release(); m_pUTCTimeClassDef = NULL; }
    if(NULL != m_pInstModClassDef) { m_pInstModClassDef->Release(); m_pInstModClassDef = NULL; }
  }

  return hr;
}

/*
  IWbemEventProvider::ProvideEvents

  Purpose: register to provide events to the WMI service
*/

HRESULT CWin32Clock::ProvideEvents(IWbemObjectSink *pSink,
                                   long lFlags)
{
  HRESULT 
    hr = WBEM_S_NO_ERROR;

  // ****  copy object sink for future event registrations

  m_pSink = pSink;
  if(NULL != m_pSink)
    m_pSink->AddRef();
  else
    hr = WBEM_E_FAILED;

  // **** start system clock change adj. thread

  DWORD dwThreadId;

  if(NULL == m_ClockResetThread)
  {
    m_ClockResetThread = CreateThread(
        NULL,                // pointer to thread security attributes
        0,                   // initial thread stack size, in bytes
        (LPTHREAD_START_ROUTINE)AsyncEventThread, // pointer to thread function
        (LPVOID)this,                // argument for new thread
        0,                   // creation flags
        &dwThreadId);        // pointer to returned thread identifier

    if(NULL == m_ClockResetThread)
      hr = WBEM_E_FAILED;
  }
  else
    hr = WBEM_E_FAILED;

  return hr;
}

/*
  IWbemEventProviderQuerySink::NewQuery

  Purpose: add a new query for event generation
*/

HRESULT CWin32Clock::NewQuery(ULONG dwId,
                              wchar_t *wszQueryLanguage,
                              wchar_t *wszQuery)
{
  HRESULT
    hr = WBEM_E_FAILED;

  CScheduledEvent
    *pNewEvent = NULL;

  if(_wcsicmp(L"WQL", wszQueryLanguage) || (NULL == wszQuery))
    return WBEM_E_FAILED;

  // ****  see if event obj with dwId is already in queue

  pNewEvent = m_EventArray(dwId, TRUE); // find registered event query

  if(NULL != pNewEvent)
  {
    #ifdef WQLDEBUG
      printf("[%d] Redefinition: %s\n", dwId, wszQuery);
    #endif

    if(_wcsicmp(wszQuery, pNewEvent->m_WQLStmt))
    {
      hr = m_Timer.Remove(&CIdentityTest(pNewEvent)); // may or may not be in queue
      hr = pNewEvent->ReInit(wszQuery); // on failure, NewEvent is preserved
      m_Timer.Set(pNewEvent);
    }

    m_EventArray.UnLock();
  }

  // ****  this is a new event, create it and place it in the event queue

  else
  {
    #ifdef WQLDEBUG
      printf("[%d] Definition: %s\n", dwId, wszQuery);
    #endif

    // ****  create new event and initialize

    pNewEvent = new CScheduledEvent();

    if(NULL == pNewEvent)
      hr = WBEM_E_OUT_OF_MEMORY;
    else
    {
      pNewEvent->AddRef();

      hr = pNewEvent->Init(this, wszQuery, dwId);

      // ****  add event to queue

      if(SUCCEEDED(hr))
      {
        m_EventArray.Insert(pNewEvent, dwId);
        hr = m_Timer.Set(pNewEvent);
      }
      else
      {
        pNewEvent->Release();
        pNewEvent = NULL;
      }
    }
  }

  return hr;
}

/*
  IWbemEventProviderQuerySink::CancelQuery

  Purpose: remove an event generator from the queue
*/

HRESULT CWin32Clock::CancelQuery(ULONG dwId)
{
  CInCritSec
    ics(&m_csWin32Clock);

  CScheduledEvent
    *pDeadEvent = NULL;

  HRESULT hr = WBEM_S_NO_ERROR;

  // ****  first find element in list and remove it

  pDeadEvent = m_EventArray(dwId, TRUE);

  if(NULL != pDeadEvent)
  {
    m_EventArray.Remove(pDeadEvent);
    m_EventArray.UnLock();

    hr = m_Timer.Remove(&CIdentityTest(pDeadEvent));

  // ****  now kill it dead

    pDeadEvent->Release();
    pDeadEvent = NULL;
  }

  return hr;
}

/*
  IWbemServices::CreateInstanceEnumAsync

  Purpose: Asynchronously enumerates the instances.  
*/

HRESULT CWin32Clock::CreateInstanceEnumAsync(const BSTR RefStr, 
                                             long lFlags, 
                                             IWbemContext *pCtx,
                                             IWbemObjectSink FAR* pHandler)
{
  HRESULT 
    sc = WBEM_E_FAILED;

  IWbemClassObject 
    FAR* pNewInst = NULL;

  SYSTEMTIME
    TheTime;

  // ****  Do a check of arguments and make sure we have pointer to Namespace

  if(NULL == pHandler)
  {
    sc = WBEM_E_INVALID_PARAMETER;
  }

  // ****  Create Win32_CurrentTime instance

  else if(0 == _wcsicmp(RefStr, WIN32LOCALTIMECLASS))
  {

    GetLocalTime(&TheTime);
    sc = SystemTimeToWin32_CurrentTime(m_pLocalTimeClassDef, &pNewInst, &TheTime);
 
    // ****  Send the object to the caller

    pHandler->Indicate(1,&pNewInst);
    pNewInst->Release();
  }

    // ****  Create Win32_CurrentTime instance

  else if(0 == _wcsicmp(RefStr, WIN32UTCTIMECLASS))
  {
    GetSystemTime(&TheTime);
    sc = SystemTimeToWin32_CurrentTime(m_pUTCTimeClassDef, &pNewInst, &TheTime);

    // ****  Send the object to the caller

    pHandler->Indicate(1,&pNewInst);
    pNewInst->Release();
  }
  else if(0 == _wcsicmp(RefStr, L"Win32_CurrentTime"))
  {}
  else
  {
    sc = WBEM_E_INVALID_CLASS;
  }

  // ****  Set status

  pHandler->SetStatus(0, sc, NULL, NULL);

  return sc;
}

/*
  IWbemServices::GetObjectByPathAsync

  Purpose: Creates an instance given a particular path value.
*/

HRESULT CWin32Clock::GetObjectAsync(const BSTR ObjectPath, 
                                    long lFlags,
                                    IWbemContext  *pCtx,
                                    IWbemObjectSink FAR* pHandler)
{
  HRESULT 
    sc = WBEM_E_FAILED;

  IWbemClassObject 
    FAR* pObj = NULL;

  WCHAR
    *pwcTest = NULL,
    *pwcVALUE = NULL;

  CObjectPathParser
    ObjPath(e_ParserAcceptRelativeNamespace);

  ParsedObjectPath
    *pParsedObjectPath = NULL;

  SYSTEMTIME
    SystemTime;

  // ****  Parse ObjectPath into a key member name and value
  // ****  <CLASS>.<MEMBER>="<VALUE>"

  if(NULL == ObjectPath)
    return WBEM_E_INVALID_OBJECT_PATH;

  // **** parse object path

  if((ObjPath.NoError != ObjPath.Parse(ObjectPath, &pParsedObjectPath)) || (NULL == pParsedObjectPath))
  {
    ERRORTRACE((LOG_ESS, "Win32_LocalTime: Parse error for object: %S\n", ObjectPath));
    sc = WBEM_E_INVALID_QUERY;
  }

  // ****  do the get, pass the object on to the notify
    
  if(0 == _wcsicmp(WIN32LOCALTIMECLASS, pParsedObjectPath->m_pClass))
  {
    GetLocalTime(&SystemTime);
    sc = SystemTimeToWin32_CurrentTime(m_pLocalTimeClassDef, &pObj, &SystemTime);

    if(WBEM_S_NO_ERROR == sc) 
    {
      pHandler->Indicate(1,&pObj);
      pObj->Release();
    }
  }
  else if(0 == _wcsicmp(WIN32UTCTIMECLASS, pParsedObjectPath->m_pClass))
  {
    GetSystemTime(&SystemTime);
    sc = SystemTimeToWin32_CurrentTime(m_pUTCTimeClassDef, &pObj, &SystemTime);

    if(WBEM_S_NO_ERROR == sc)
    {
      pHandler->Indicate(1,&pObj);
      pObj->Release();
    }
  }
  else
  {
    ERRORTRACE((LOG_ESS, "Win32_LocalTime: Parse error for object: %S\n", ObjectPath));
    sc = WBEM_E_INVALID_QUERY;
  }

  // ****  Set Status

  pHandler->SetStatus(0,sc, NULL, NULL);

  return sc;
}

/*
  CWin32Clock::CreateInstCurrentTime

  Purpose: creates an instance of the object Win32_CurrentTime representing
           the current time with the given offset UTCOffset
*/

HRESULT CWin32Clock::SystemTimeToWin32_CurrentTime(IWbemClassObject *pClassDef, IWbemClassObject ** pNewInst, SYSTEMTIME *TheTime)
{ 
  HRESULT 
    sc = WBEM_E_FAILED;

  VARIANT
    v;

  // ****  create blank instance of class InstTime

  sc = pClassDef->SpawnInstance(0, pNewInst);
 
  if(FAILED(sc))
    return sc;

  // ****  Create Win32_CurrentTime instance

  v.vt = VT_I4;

  v.lVal = TheTime->wYear; 
  sc = (*pNewInst)->Put(L"Year", 0, &v, 0);

  v.lVal = TheTime->wMonth; 
  sc = (*pNewInst)->Put(L"Month", 0, &v, 0);

  v.lVal = TheTime->wDay; 
  sc = (*pNewInst)->Put(L"Day", 0, &v, 0);

  v.lVal = TheTime->wDayOfWeek; 
  sc = (*pNewInst)->Put(L"DayOfWeek", 0, &v, 0);

  v.lVal = (((8 - (TheTime->wDay - TheTime->wDayOfWeek + 7) % 7) % 7) + TheTime->wDay -1) / 7 + 1; 
  sc = (*pNewInst)->Put(L"WeekInMonth", 0, &v, 0);

  v.lVal = (TheTime->wMonth - 1) / 3 + 1; 
  sc = (*pNewInst)->Put(L"Quarter", 0, &v, 0);

  v.lVal = TheTime->wHour; 
  sc = (*pNewInst)->Put(L"Hour", 0, &v, 0);

  v.lVal = TheTime->wMinute; 
  sc = (*pNewInst)->Put(L"Minute", 0, &v, 0);

  v.lVal = TheTime->wSecond; 
  sc = (*pNewInst)->Put(L"Second", 0, &v, 0);

  VariantClear(&v);

  return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaplug\precomp.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E0BE3C99_39FD_475E_9E68_B464C3C902B1__INCLUDED_)
#define AFX_STDAFX_H__E0BE3C99_39FD_475E_9E68_B464C3C902B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E0BE3C99_39FD_475E_9E68_B464C3C902B1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaplug\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VSAPlug.rc
//
#define IDS_PROJNAME                    100
#define IDR_VSAPLUGIN                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\profdef\makefile.inc ===
$(O)\profdef.dll: profdef_$(_BuildArch).dll
    copy profdef_$(_BuildArch).dll $(O)\profdef.dll
    copy profdef_$(_BuildArch).pdb $(O)\profdef.pdb
$(O)\appprof.mof $(O)\appprof.mfl: appprof.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\appprofTmp.mof -MFL:$(O)\appprofTmp.mfl appprof.mof
    copy copyright.mof+$(O)\appprofTmp.mof+$(O)\appprofTmp.mfl $(O)\appprof.mof
    copy copyright.mof+$(O)\appprofTmp.mfl $(O)\appprof.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaplug\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#endif

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "VSAPlug_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaplug\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__3EA5C592_3D48_472B_8C31_B83451097C6F__INCLUDED_)
#define AFX_DLLDATAX_H__3EA5C592_3D48_472B_8C31_B83451097C6F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__3EA5C592_3D48_472B_8C31_B83451097C6F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaplug\vsaplug.cpp ===
// VSAPlug.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for VSAPlug.idl by adding the following 
//      files to the Outputs.
//          VSAPlug_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f VSAPlugps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "VSAPlug.h"
#include "dlldatax.h"

#include "VSAPlug_i.c"
#include "VSAPlugIn.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_VSAPlugIn, CVSAPlugIn)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_VSAPLUGLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaplug\vsaplugin.cpp ===
// VSAPlugIn.cpp : Implementation of CVSAPlugIn
#include "precomp.h"
#include "VSAPlug.h"
#include "VSAPlugIn.h"

/////////////////////////////////////////////////////////////////////////////
// CVSAPlugIn


/////////////////////////////////////////////////////////////////////////////
// ISystemDebugPlugin

_COM_SMARTPTR_TYPEDEF(IVSAPluginControllerSink, __uuidof(IVSAPluginControllerSink));

HRESULT CVSAPlugIn::Startup(
    IN DWORD dwPluginId,
	IN IUnknown *punkUser,
	IN ISystemDebugPluginAttachment *pAttachment
    )
{
    // We've been started up by the plug-in controller.  Now try to get the
    // controller's 
    IVSAPluginControllerSinkPtr
            pSink;
    HRESULT hr;
    
    hr = 
        punkUser->QueryInterface(
            IID_IVSAPluginControllerSink, 
            (LPVOID*) &pSink);

    // If we get the controller, give it our plugin-attachment.
    if (pSink != NULL)
    {
        // Safe these for later use.
        m_dwPluginID = dwPluginId;
        m_pAttachment = pAttachment;

        // Give our controller our IVSAPluginController*.
        hr = pSink->SetPluginController(this, GetCurrentProcessId());

        // We don't need to talk to the controller anymore.
        //pSink->Release();

        // Tell the LEC we want to start firing.
        m_pAttachment->StartFiring(dwPluginId);
    }

    return S_OK;
}

HRESULT CVSAPlugIn::FireEvents(
    REFGUID guidFiringComponent,
    IN ULONG ulEventBufferSize,
	IN unsigned char ucEventBuffer[]
	)
{
    //_asm { int 3 }

    // Ship off the buffer to our provider.
    if (m_hPipeWrite)
    {
        DWORD dwToWrite = ulEventBufferSize + sizeof(guidFiringComponent),
              dwWritten;

        // Write the size of the message.
        WriteFile(
            m_hPipeWrite,
            &dwToWrite,
            sizeof(dwToWrite),
            &dwWritten,
            NULL);

        // Write the REFGUID.
        WriteFile(
            m_hPipeWrite,
            &guidFiringComponent,
            sizeof(guidFiringComponent),
            &dwWritten,
            NULL);

        // Write the actual message.
        WriteFile(
            m_hPipeWrite,
            ucEventBuffer,
            ulEventBufferSize,
            &dwWritten,
            NULL);
    }

    return S_OK;
}

HRESULT CVSAPlugIn::Shutdown()
{
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// IVSAPluginController

HRESULT CVSAPlugIn::SetWriteHandle(
    IN unsigned __int64 hWrite)
{
    m_hPipeWrite = (HANDLE) hWrite;

    return S_OK;
}

HRESULT CVSAPlugIn::ActivateEventSource(
	IN REFGUID guidEventSourceId
    )
{
    return m_pAttachment->ActivateEventSource(m_dwPluginID, guidEventSourceId);
}

HRESULT CVSAPlugIn::DeactivateEventSource(
	IN REFGUID guidEventSourceId
    )
{
    return m_pAttachment->DeactivateEventSource(m_dwPluginID, guidEventSourceId);
}
	
HRESULT CVSAPlugIn::SetBlockOnOverflow(
    IN BOOL fBlock
    )
{
    return m_pAttachment->SetBlockOnOverflow(fBlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__3EA5C592_3D48_472B_8C31_B83451097C60__INCLUDED_)
#define AFX_DLLDATAX_H__3EA5C592_3D48_472B_8C31_B83451097C60__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__3EA5C592_3D48_472B_8C31_B83451097C6F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#endif
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "VSAProv_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaplug\vsaplugin.h ===
// VSAPlugIn.h : Declaration of the CVSAPlugIn

#ifndef __VSAPLUGIN_H_
#define __VSAPLUGIN_H_

#include "resource.h"       // main symbols
#include "LecPlugIn.h"

_COM_SMARTPTR_TYPEDEF(ISystemDebugPluginAttachment, __uuidof(ISystemDebugPluginAttachment));

/////////////////////////////////////////////////////////////////////////////
// CVSAPlugIn
class ATL_NO_VTABLE CVSAPlugIn : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVSAPlugIn, &CLSID_VSAPlugIn>,
    public ISystemDebugPlugin,
    public IVSAPluginController
{
public:
	CVSAPlugIn() : 
        m_hPipeWrite(NULL)
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_VSAPLUGIN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVSAPlugIn)
	COM_INTERFACE_ENTRY(ISystemDebugPlugin)
	COM_INTERFACE_ENTRY(IVSAPluginController)
END_COM_MAP()

// ISystemDebugPlugin
public:
	HRESULT STDMETHODCALLTYPE Startup(
		IN DWORD dwPluginId,
		IN IUnknown *punkUser,
		IN ISystemDebugPluginAttachment *pAttachpoint
		);

	HRESULT STDMETHODCALLTYPE FireEvents(
		IN REFGUID guidFiringComponent,
        IN ULONG ulEventBufferSize,
		IN unsigned char ucEventBuffer[]
		);

	HRESULT STDMETHODCALLTYPE Shutdown();


// IVSAPluginController
// This gets called from our VSA Provider.
public:
	HRESULT STDMETHODCALLTYPE SetWriteHandle(
		IN unsigned __int64 hWrite);

	HRESULT STDMETHODCALLTYPE ActivateEventSource(
		IN REFGUID guidEventSourceId
        );

	HRESULT STDMETHODCALLTYPE DeactivateEventSource(
		IN REFGUID guidEventSourceId
        );
	
	HRESULT STDMETHODCALLTYPE SetBlockOnOverflow(
		IN BOOL fBlock
		);

protected:
    ISystemDebugPluginAttachmentPtr m_pAttachment;
    DWORD m_dwPluginID;
    HANDLE m_hPipeWrite;
};

#endif //__VSAPLUGIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\precomp.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CC61F827_AA97_44D3_BE05_D9D65917BDBF__INCLUDED_)
#define AFX_STDAFX_H__CC61F827_AA97_44D3_BE05_D9D65917BDBF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>
#include <tchar.h>

#define COUNTOF(x)  (sizeof(x)/sizeof(x[0]))

#ifdef _UNICODE
#define TOBSTRT(x)
#else
#define TOBSTRT(x)  _bstr_t(x)
#endif

#ifdef _ASSERT
#undef _ASSERT
#endif

#define VSA_EVENT_BASE L"MSFT_AppProfApplicationProfilingEvent"
#define GENERIC_VSA_EVENT   L"MSFT_AppProfGenericVSA"

//
// Use of the COREPROX_POLARITY will go away when ESSLIB is no longer
// dependent on COREPROX.
//

#define COREPROX_POLARITY __declspec( dllimport )

#ifndef _WIN64
#define DWORD_PTR   DWORD
#endif

//#include <analyser.h>
#include <ql.h>

_COM_SMARTPTR_TYPEDEF(IUnknown, __uuidof(IUnknown));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));


#undef _CRTIMP
#define _CRTIMP 
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

/*
#include "corepol.h"
#undef _CRTIMP
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <localloc.h>
*/

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CC61F827_AA97_44D3_BE05_D9D65917BDBF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VSAProv.rc
//
#define IDS_PROJNAME                    100
#define IDR_VSAPROVIDER                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\stllock.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STLLOCK.CPP

Abstract:

  Lock for STL

History:

--*/

#include "precomp.h"
//#include <stdio.h>
//#include <wbemcomn.h>
#include <sync.h>

/*
    This file implements the STL lockit class to avoid linking to msvcprt.dll
*/

CCritSec g_cs;

std::_Lockit::_Lockit()
{
    EnterCriticalSection(&g_cs);
}

std::_Lockit::~_Lockit()
{
    LeaveCriticalSection(&g_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\vsaevent.cpp ===
// VSAEvent.cpp

#include "precomp.h"
#include "VSAProv.h"
#include "VSAEvent.h"
#include "Buffer.h"
#include <list>
#include <wstlallc.h>

#define INVALID_INDEX   0xFFFFFFFF

// ***DO NOT*** move these around!!!  The order has to match the order of the
// VSA property indexes we get back from event buffers.
LPCWSTR szStandardParams[] =
{
    // Default params
    L"SourceMachine",      //  0
    L"SourceProcessId",    //  1
    L"SourceThreadId",     //  2
    L"SourceComponent",    //  3
    L"SourceSession",      //  4

    L"TargetMachine",      //  5
    L"TargetProcessId",    //  6
    L"TargetThreadId",     //  7
    L"TargetComponent",    //  8
    L"TargetSession",      //  9

    L"SecurityIdentity",   // 10
    L"CausalityId",        // 11

    L"SourceProcessName",  // 12
    L"TargetProcessName",  // 13

    // No default params
    L"SourceHandle",       // 14
    L"TargetHandle",       // 15

    L"Arguments",          // 16
    L"ReturnValue",        // 17
    L"Exception",          // 18
    L"CorrelationId",      // 19

    // Params specific to WMI classes
    L"GenericParamNames",  // 20
    L"GenericParamValues", // 21
    
    L"ProviderGUID",       // 22
};

// Taken from the above table
#define GEN_NAMES_INDEX     20
#define GEN_VALUES_INDEX    21
#define PROVIDER_GUID_INDEX 22


CIMTYPE typesStandardParams[] =
{
    // Default params
    CIM_STRING, // L"SourceMachine",      //  0
    CIM_UINT32, // L"SourceProcessId",    //  1
    CIM_UINT32, // L"SourceThreadId",     //  2
    CIM_STRING, // L"SourceComponent",    //  3
    CIM_STRING, // L"SourceSession",      //  4

    CIM_STRING, // L"TargetMachine",      //  5
    CIM_UINT32, // L"TargetProcessId",    //  6
    CIM_UINT32, // L"TargetThreadId",     //  7
    CIM_STRING, // L"TargetComponent",    //  8
    CIM_STRING, // L"TargetSession",      //  9

    CIM_STRING, // L"SecurityIdentity",   // 10
    CIM_STRING, // L"CausalityId",        // 11

    CIM_STRING, // L"SourceProcessName",  // 12
    CIM_STRING, // L"TargetProcessName",  // 13

    // No default params
    CIM_STRING, // L"SourceHandle",       // 14
    CIM_STRING, // L"TargetHandle",       // 15

    CIM_STRING, // L"Arguments",          // 16
    CIM_STRING, // L"ReturnValue",        // 17
    CIM_STRING, // L"Exception",          // 18
    CIM_STRING, // L"CorrelationId",      // 19

    CIM_STRING, //L"GenericParamNames",   // 20
    CIM_STRING, //L"GenericParamValues",  // 21
    
    CIM_STRING, //L"ProviderGUID",        // 22
};

#define NUM_STANDARD_PARAMS (sizeof(typesStandardParams)/sizeof(typesStandardParams[0]))

#define STANDARD_BASE_BEGIN 0x6c736d61
#define STANDARD_BASE_END   0x6c736d74

static GUID guidStandardBase = {0x6c736d61,0xbcbf,0x11d0,{0x8a,0x23,0x00,0xaa,0x00,0xb5,0x8e,0x10}};

LPCWSTR szStandardClassNames[] =
{
    L"MSFT_AppProfCall",
    L"MSFT_AppProfReturn",
    L"MSFT_AppProfComponentStart",
    L"MSFT_AppProfComponentStop",
    L"MSFT_AppProfCallData",
    L"MSFT_AppProfEnter",
    L"MSFT_AppProfEnterData",
    L"MSFT_AppProfLeaveNormal",
    L"MSFT_AppProfLeaveException",
    L"MSFT_AppProfLeaveData",
    L"MSFT_AppProfReturnData",
    L"MSFT_AppProfReturnNormal",
    L"MSFT_AppProfReturnException",
    L"MSFT_AppProfQuerySend",
    L"MSFT_AppProfQueryEnter",
    L"MSFT_AppProfQueryLeave",
    L"MSFT_AppProfQueryResult",
    L"MSFT_AppProfTransactionStart",
    L"MSFT_AppProfTransactionCommit",
    L"MSFT_AppProfTransactionRollback",
};

//#define USE_WMI

BOOL CVSAEvent::InitFromGUID(IWbemServices *pSvc, GUID *pGUID)
{
    WCHAR szGUID[100] = L"";
    WCHAR szClassName[256] = L"";
    BOOL  bRet = FALSE;

    StringFromGUID2(*pGUID, szGUID, COUNTOF(szGUID));

    // See if it's one of the standard GUIDs.
    if (!memcmp((DWORD*) &pGUID->Data2, &guidStandardBase.Data2, 
        sizeof(DWORD) * 3) &&
        pGUID->Data1 >= STANDARD_BASE_BEGIN && pGUID->Data1 <= STANDARD_BASE_END)
    {
        wcscpy(szClassName, szStandardClassNames[pGUID->Data1 - 
            STANDARD_BASE_BEGIN]);
    }
    else
    // Try to get it from WMI.
#ifdef USE_WMI
    // TODO: This is currently broken, due to a bug in the core.  Enable once we
    //      figure out what's wrong with the core.
    {
        LPWSTR szPath = new WCHAR[wcslen(szGUID) + 100];

        if (szPath)
        {
            IWbemClassObjectPtr pObj;

            swprintf(
                szPath,
                L"select * from MSFT_AppProfEventSetting where ClassName=\"%s\"",
                szGUID);
    
            IEnumWbemClassObjectPtr pEnum;
            DWORD                   nCount = 0;

            if (SUCCEEDED(
                pSvc->ExecQuery(
                    _bstr_t(L"WQL"),
                    _bstr_t(szPath),
                    WBEM_FLAG_FORWARD_ONLY,
                    NULL,
                    &pEnum)) &&
                SUCCEEDED(pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) && nCount)
            {
                _variant_t vClass;

                if (SUCCEEDED(pObj->Get(L"WmiClassName", 0, &vClass, NULL, NULL)) &&
                    vClass.vt == VT_BSTR)
                    wcscpy(szClassName, V_BSTR(&vClass));
            }
        }

        delete szPath;
    }
#else
    {
        HKEY  hKey;

        // Try to get it from the registry.
        char szEventKey[256];

        sprintf(
            szEventKey,
            "SOFTWARE\\Microsoft\\VisualStudio\\Analyzer\\Events\\%S",
            szGUID);

        if (RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            szEventKey,
            0,
            KEY_READ,
            &hKey) == 0)
        {
            char  szTempClassName[100] = "";
            DWORD dwSize = sizeof(szTempClassName);

            if (RegQueryValueExA(
                    hKey,
                    "WmiClassName", // To get an ANSI version.
                    NULL,
                    NULL,
                    (LPBYTE) &szTempClassName,
                    &dwSize) == 0)
            {
                mbstowcs(szClassName, szTempClassName, strlen(szTempClassName) + 1);
            }

            RegCloseKey(hKey);
        }
    }
#endif // #ifdef USE_WMI


    // If we weren't able to find the class name, we'll have to use
    // the generic class.
    if (!*szClassName)
        wcscpy(szClassName, GENERIC_VSA_EVENT);


    if (Init(
        pSvc, 
        szClassName, 
        szStandardParams, 
        NUM_STANDARD_PARAMS,
        FAILED_PROP_IGNORE))
    {
        // Set this property only for the generic event.  All other
        // events can get this out of the UUID.
        if (!_wcsicmp(GENERIC_VSA_EVENT, szClassName))
        {
            _variant_t vUUID = szGUID;

            m_pObj->Put(L"EventGUID", 0, &vUUID, NULL);
        }
                
        // We clone off a copy into m_pObjBase.  After every indicate
        // we'll use this copy to clone a new blank copy into m_pObj.
        if (SUCCEEDED(m_pObj->Clone(&m_pObjBase)))
            bRet = TRUE;
    }

    return bRet;
}

#define DWORD_ALIGNED(x)    (((x) + 3) & ~3)

HRESULT VSADataToCIMData(VSAParameterType typeVSA, LPBYTE pData, 
    CIMTYPE type, _variant_t &var, DWORD dwAccessIndex)
{
    VSAParameterType typeVSABase = (VSAParameterType) (typeVSA & 0xF0000);
    HRESULT          hr = S_OK;

    // If we're not using an IWbemObjectAccess handle, we'll need to convert
    // 64-bit values to strings since IWbemClassObject::Put only accepts
    // strings for 64-bit properties.
    if (dwAccessIndex == INVALID_INDEX && type == CIM_UINT64)
        type = CIM_STRING;

    switch(type)
    {
        case CIM_UINT64:
            var.vt = VT_I8;

            switch(typeVSABase)
            {
                case cVSAParameterValueUnicodeString:
                {
                    WCHAR *szBad;

                    *(DWORD64*) &var.iVal = 
                        (DWORD64) wcstoul((LPCWSTR) pData, &szBad, 0);
                    break;
                }

                case cVSAParameterValueANSIString:
                {
                    char *szBad;

                    *(DWORD64*) &var.iVal = 
                        (DWORD64) strtoul((LPCSTR) pData, &szBad, 0);
                    break;
                }

                case cVSAParameterValueDWORD:
                    *(DWORD64*) &var.iVal = *(long*) pData;
                    break;

                // No other conversions supported.
                // TODO: Should we add one for byte arrays or GUIDs?
                default:
                    hr = WBEM_E_FAILED;
            }

            break;

        case CIM_STRING:
            switch(typeVSABase)
            {
                case cVSAParameterValueUnicodeString:
                    var = (LPCWSTR) pData;
                    break;

                case cVSAParameterValueANSIString:
                    var = (LPCSTR) pData;
                    break;

                case cVSAParameterValueGUID:
                {
                    WCHAR szGUID[100];

                    StringFromGUID2(*(GUID*) pData, szGUID, COUNTOF(szGUID));

                    var = szGUID;
                    break;
                }

                case cVSAParameterValueDWORD:
                {
                    WCHAR szValue[100];

                    swprintf(szValue, _T("%u"), *(DWORD*) pData);

                    var = szValue;
                    break;
                }

                // No other conversions supported.
                // TODO: Should we add one for byte arrays?
                default:
                    hr = WBEM_E_FAILED;
            }

            break;

        case CIM_SINT32:
        case CIM_UINT32:
            switch(typeVSABase)
            {
                case cVSAParameterValueUnicodeString:
                {
                    WCHAR *szBad;

                    var = (long) wcstoul((LPCWSTR) pData, &szBad, 0);
                    break;
                }

                case cVSAParameterValueANSIString:
                {
                    char *szBad;

                    var = (long) strtoul((LPCSTR) pData, &szBad, 0);
                    break;
                }

                case cVSAParameterValueDWORD:
                    var = *(long*) pData;
                    break;

                // No other conversions supported.
                // TODO: Should we add one for byte arrays or GUIDs?
                default:
                    hr = WBEM_E_FAILED;
            }

            break;

        case CIM_UINT8 | CIM_FLAG_ARRAY:
            switch(typeVSABase)
            {
                case cVSAParameterValueBYTEArray: 
                {
                    SAFEARRAYBOUND bound;

                    var.vt = VT_UI1 | VT_ARRAY;

                    bound.lLbound = 0;
                    bound.cElements = typeVSA & 0xFFFF;

                    var.parray = SafeArrayCreate(VT_UI1, 1, &bound);

                    if (var.parray)
                        memcpy(var.parray->pvData, pData, typeVSA & 0xFFFF);
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;

                    break;
                }

                // No other conversions supported.
                default:
                    hr = WBEM_E_FAILED;
            }

            break;

        // No other conversions supported.
        default:
            hr = WBEM_E_FAILED;
            break;
    }                    
                    
    return hr;
}

DWORD CVSAEvent::GetVSADataLength(LPBYTE pBuffer, VSAParameterType typeVSA)
{
    VSAParameterType typeVSABase = (VSAParameterType) (typeVSA & 0xF0000);
    DWORD            dwRet = 0;

    // Move the buffer past the current data.
    switch(typeVSABase)
    {
        case cVSAParameterValueUnicodeString:
            dwRet = (wcslen((LPCWSTR) pBuffer) + 1) * sizeof(WCHAR);
            break;

        case cVSAParameterValueANSIString:
            dwRet = strlen((LPCSTR) pBuffer) + 1;
            break;

        case cVSAParameterValueGUID:
            dwRet = sizeof(GUID);
            break;

        case cVSAParameterValueBYTEArray: 
            dwRet = typeVSA & 0xFFFF;
            break;

        case cVSAParameterValueDWORD:
            dwRet = sizeof(DWORD);
            break;
    }

    return dwRet;
}

DWORD CVSAEvent::GetCIMDataLength(VARIANT *pVar, CIMTYPE type)
{
    DWORD dwRet = 0;

    // Move the buffer past the current data.
    switch(type)
    {
        case CIM_STRING:
            dwRet = (wcslen(V_BSTR(pVar)) + 1) * sizeof(WCHAR);
            break;

        case CIM_UINT32:
        case CIM_SINT32:
            dwRet = sizeof(DWORD);
            break;

        case CIM_UINT64:
        case CIM_SINT64:
            dwRet = sizeof(DWORD64);
            break;

        case CIM_UINT8 | CIM_FLAG_ARRAY:
            dwRet = pVar->parray->rgsabound[0].cElements;
            break;
    }

    return dwRet;
}

typedef std::list<_bstr_t, wbem_allocator<_bstr_t> > CBstrList;
typedef CBstrList::iterator CBstrListIterator;

BOOL CVSAEvent::AreTypesEquivalent(CIMTYPE type, VSAParameterType typeVSA)
{
    BOOL bRet;

    bRet =
        (type == CIM_STRING && typeVSA == cVSAParameterValueUnicodeString) ||
        ((type == CIM_UINT32 || type == CIM_SINT32) && 
            typeVSA == cVSAParameterValueDWORD) ||
        (type == (CIM_UINT8 | CIM_FLAG_ARRAY) && 
            typeVSA == cVSAParameterValueBYTEArray);

    return bRet;
}


HRESULT CVSAEvent::SetViaBuffer(LPCWSTR szProviderGuid, LPBYTE pBuffer)
{
    VSA_EVENT_HEADER *pHeader = (VSA_EVENT_HEADER*) pBuffer;
    LPBYTE           pEnd = pBuffer + pHeader->dwSize;
    CBuffer          bufferGenNames,
                     bufferGenValues;
    DWORD            nGenValues = 0;
    
    // Get past the header.
    pBuffer += sizeof(VSA_EVENT_HEADER);

    while (pBuffer < pEnd)
    {
        VSA_EVENT_FIELD *pField = (VSA_EVENT_FIELD*) pBuffer;
        LPCWSTR         szFieldName = NULL;
        DWORD           dwIndex = INVALID_INDEX;
        CIMTYPE         type;
        BOOL            bGeneric = FALSE;
        DWORD           dwDataLen;
        BOOL            bAlreadySet = FALSE;

        // Is this a standard field?
        if ((pField->dwType & 0x80000000) == 0)
        {
            dwIndex = pField->dwIndex;

            // Normalize the index to a zero-based value if it's in the
            // non-default range.
            if (dwIndex >= 0x4000)
                dwIndex = dwIndex - 0x4000 + cVSAStandardParameterDefaultLast + 1;

            // Get pBuffer to point at the data.
            pBuffer = ((LPBYTE) &pField->dwIndex) + sizeof(DWORD);

            // Get the length of the data.
            dwDataLen = GetVSADataLength(pBuffer, (VSAParameterType) pField->dwType);

            // If we find a valid IWbemObjectAccess handle, we'll use it,
            // otherwise we'll have to use our generic array.
            if (m_pProps[dwIndex].m_lHandle)
            {
                type = typesStandardParams[dwIndex];

                if (AreTypesEquivalent(type, (VSAParameterType) pField->dwType))
                {
                    WriteData(dwIndex, pBuffer, dwDataLen);

                    bAlreadySet = TRUE;
                }
            }
            else
            {
                // This is for the case where a standard parameter was used,
                // but this event class doesn't have that standard parameter.
                // So, it has to go into the generic property arrays.
                type = CIM_STRING;
                bGeneric = TRUE;
                szFieldName = szStandardParams[dwIndex];
            }
        }
        else
        // Must be a string field.
        {
            HRESULT hr;

            szFieldName = pField->szName;
            
            // Get past the field name so pBuffer points at the data.
            pBuffer = 
                (LPBYTE) DWORD_ALIGNED((DWORD_PTR) (szFieldName + wcslen(szFieldName) + 1));

            // Get the length of the data.
            dwDataLen = GetVSADataLength(pBuffer, (VSAParameterType) pField->dwType);

            // See if this property has a corresponding CIM property and get 
            // its type.
            hr = 
                m_pObj->Get(
                    szFieldName,
                    0,
                    NULL,
                    &type,
                    NULL);

            // If the property wasn't found we'll use our generic array.
            if (FAILED(hr))
            {
                type = CIM_STRING;
                bGeneric = TRUE;
            }
        }

        // Make sure we haven't already set the data using the index.
        if (!bAlreadySet)
        {
            // Convert the VSA data to the proper CIM type.
            _variant_t varData;

            if (SUCCEEDED(VSADataToCIMData(
                (VSAParameterType) pField->dwType, 
                pBuffer, 
                type, 
                varData, 
                dwIndex)))
            {
                if (bGeneric)
                {
                    //listParamNames.push_back(szFieldName);
                    //listParamValues.push_back(V_BSTR(&varData));
                    bufferGenNames.Write(szFieldName);
                    bufferGenValues.Write(V_BSTR(&varData));

                    nGenValues++;
                }
                else if (dwIndex != INVALID_INDEX)
                {
                    DWORD dwDataLen = GetCIMDataLength(&varData, type);

                    WriteData(
                        dwIndex,
                        type == CIM_STRING ? varData.bstrVal : (BSTR) &varData.iVal, 
                        dwDataLen);
                }
                else if (szFieldName)
                {
                    m_pObj->Put(
                        szFieldName,
                        0,
                        &varData,
                        NULL);
                }
            }

            // So the _variant_t destructor doesn't freak out.
            if (varData.vt == VT_I8)
                varData.vt = VT_I4;
        }

        pBuffer += DWORD_ALIGNED(dwDataLen);
    }


#define GUID_STR_LEN    39 * sizeof(WCHAR)
    
    // Add the provider GUID.
    WriteData(
        PROVIDER_GUID_INDEX,
        (LPVOID) szProviderGuid,
        GUID_STR_LEN);

    // Now add the generic properties, if any were found.
    if (nGenValues)
    {
        WriteNonPackedArrayData(
            GEN_NAMES_INDEX,
            bufferGenNames.m_pBuffer,
            nGenValues,
            bufferGenNames.GetUsedSize());
                        
        WriteNonPackedArrayData(
            GEN_VALUES_INDEX,
            bufferGenValues.m_pBuffer,
            nGenValues,
            bufferGenValues.GetUsedSize());
/*
        // Create the safe array.
        SAFEARRAYBOUND bound;
        VARIANT        var;

        var.vt = VT_BSTR | VT_ARRAY;

        bound.lLbound = 0;
        bound.cElements = listParamNames.size();

        var.parray = SafeArrayCreate(VT_BSTR, 1, &bound);

        if (var.parray)
        {
            // Set the names.
            BSTR *pNames = (BSTR*) var.parray->pvData;
            for (CBstrListIterator name = listParamNames.begin();
                name != listParamNames.end();
                name++)
            {
                *pNames = *name;
                pNames++;
            }

            m_pObj->Put(
                L"GenericParamNames",
                0,
                &var,
                NULL);


            // Set the values.
            BSTR *pValues = (BSTR*) var.parray->pvData;
            for (CBstrListIterator value = listParamValues.begin();
                value != listParamValues.end();
                value++)
            {
                *pValues = (*value).copy();
                pValues++;
            }

            m_pObj->Put(
                L"GenericParamValues",
                0,
                &var,
                NULL);

            // Get rid of the safe array.
            SafeArrayDestroy(var.parray);
        }
*/
    }

    _variant_t vVal;

    m_pObj->Get(
        L"BlobParam",
        0,
        &vVal,
        NULL,
        NULL);

    return S_OK;
}

HRESULT CVSAEvent::Indicate(IWbemObjectSink *pSink)
{
    HRESULT hr = pSink->Indicate(1, &m_pObj);

    Reset();

    return hr;
}

HRESULT CVSAEvent::Reset()
{
    HRESULT hr = m_pObjBase->Clone(&m_pObj);

    if (SUCCEEDED(hr))
        hr = 
            m_pObj->QueryInterface(
                IID_IWbemObjectAccess, 
                (LPVOID*) &m_pObjAccess);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\vsaprovider.cpp ===
// VSAProvider.cpp : Implementation of CVSAProvider
#include "precomp.h"

#ifdef _ASSERT
#undef _ASSERT
#endif

#include <wstlallc.h>
#include "VSAProv.h"
#include "VSAProvider.h"

// Forward declarations

typedef std::list<_bstr_t, wbem_allocator<_bstr_t> > CBstrList;
typedef CBstrList::iterator CBstrListIterator;

void* __cdecl operator new ( size_t size );
void __cdecl operator delete ( void* pv );

HRESULT GetValuesForProp(
    QL_LEVEL_1_RPN_EXPRESSION* pExpr,
    LPCWSTR szPropName, 
    CGuidList &listGuids);

/////////////////////////////////////////////////////////////////////////////
// CVSAProvider

CVSAProvider::CVSAProvider() :
    m_hthreadRead(NULL),
    m_hPipeRead(INVALID_HANDLE_VALUE),
    m_hPipeWrite(INVALID_HANDLE_VALUE),
    m_dwProcessID(0),
    m_pPluginControl(NULL),
    m_pSvc(NULL),
    m_pSink(NULL),
    m_dwPluginCookie(0)
{
}

CVSAProvider::~CVSAProvider()
{
    if(m_pPluginControl != NULL && m_dwPluginCookie != 0)
    {
        m_pPluginControl->UnloadPlugin(m_dwPluginCookie);
    }

    if (m_hPipeRead != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hPipeWrite);
        CloseHandle(m_hPipeRead);

        if (m_hthreadRead)
        {
            WaitForSingleObject(m_hthreadRead, INFINITE);

            CloseHandle(m_hthreadRead);
        }
    }
}


#define DEF_PIPE_SIZE   64000

HRESULT STDMETHODCALLTYPE CVSAProvider::Initialize( 
    /* [in] */ LPWSTR pszUser,
    /* [in] */ LONG lFlags,
    /* [in] */ LPWSTR pszNamespace,
    /* [in] */ LPWSTR pszLocale,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    DWORD   dwID;
    HRESULT hr = WBEM_E_FAILED;

    if(m_hPipeRead == INVALID_HANDLE_VALUE)
    {
        if (CreatePipe(
            &m_hPipeRead,
            &m_hPipeWrite,
            NULL,
            DEF_PIPE_SIZE))
        {
            m_hthreadRead =
                CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) PipeReadThreadProc,
                    this,
                    0,
                    &dwID);
    
            if (m_hthreadRead)
                hr = S_OK;
        }
    }
    else
    {
        //
        // We were already initialized before.
        //  

        hr = S_OK;
    }
            
    // Save this for later.
    m_pSvc = pNamespace;

    m_mapEvents.SetNamespace(pNamespace);

    // Tell Windows Management our initialization status.
    pInitSink->SetStatus(SUCCEEDED(hr) ? WBEM_S_INITIALIZED : WBEM_E_FAILED, 0);
    
    return hr;
}

HRESULT STDMETHODCALLTYPE CVSAProvider::AccessCheck( 
    /* [in] */ WBEM_CWSTR wszQueryLanguage,
    /* [in] */ WBEM_CWSTR wszQuery,
    /* [in] */ long lSidLength,
    /* [unique][size_is][in] */ const BYTE __RPC_FAR *pSid)
{
    return S_OK;
}

// {2169E810-FE80-4107-AE18-798D50684A71}
static GUID guidOurPlugin = 
{ 0x2169E810, 0xFE80, 0x4107, { 0xAE, 0x18, 0x79, 0x8D, 0x50, 0x68, 0x4A, 0x71 } };

// Rem this out to make us use the real LEC.
//#define FAKE_LEC

static CLSID CLSID_FakeLEC = {0x25B61D2C,0x7A85,0x4F77,{0x95,0x87,0x3D,0xFA,0xB6,0x26,0x34,0xF0}};
static CLSID CLSID_LECObj =  {0x6c736d4F,0xCBD1,0x11D0,{0xB3,0xA2,0x00,0xA0,0xC9,0x1E,0x29,0xFE}};

HRESULT STDMETHODCALLTYPE CVSAProvider::NewQuery( 
    /* [in] */ DWORD dwID,
    /* [in] */ WBEM_WSTR wszQueryLanguage,
    /* [in] */ WBEM_WSTR wszQuery)
{
    HRESULT   hr = S_OK;
    CGuidList listEventSources;

    // Get the list of providers to which this query applies.
    hr = QueryToEventSourceList(wszQuery, listEventSources);

    if (SUCCEEDED(hr))
    {
        Lock();

        for (CGuidListIterator i = listEventSources.begin(); 
            i != listEventSources.end(); 
            i++)
        {
            CEventSource *pSrc;

            // Now that we have the name of the provider,
            // get a CProvInfo* so we can tell it about
            // the new query.
            pSrc = m_mapEventSources.FindEventSource(&(*i));

            if (pSrc)
            {
                // See if we need to load the LEC's plug-in control.
                if (m_pPluginControl == NULL)
                {
                    // HRESULT hr;

                    hr =
                        CoCreateInstance(
#ifdef FAKE_LEC
                            CLSID_FakeLEC,
#else
                            CLSID_LECObj,
#endif
                            NULL,
                            CLSCTX_LOCAL_SERVER,
                            IID_ISystemDebugPluginControl,
                            (LPVOID*) &m_pPluginControl);

                    if (SUCCEEDED(hr))
                    {
                        // HRESULT  hr;
                        IUnknown *pUnk = NULL;

                        // Because I can't seem to find a way to cast our this
                        // to IUnknown*.
                        hr = QueryInterface(IID_IUnknown, (LPVOID*) &pUnk);

                        if (pUnk)
                        {
                            hr = 
                                m_pPluginControl->LoadPlugin(
		                            guidOurPlugin,
		                            pUnk,
		                            &m_dwPluginCookie);

                            // We got this from the QI.  If the plug-in wants to
                            // keep us around it can AddRef us.
                            Release();
                        }
                    }
                    else
                        // Should we do something here to indicate we weren't able to
                        // CoCreate the LEC?
                        hr = S_OK;
                }

                m_mapEventSources.AddEventSourceRef(dwID, pSrc);
            }
        }

        Unlock();
    }

    return hr;
}
        
HRESULT STDMETHODCALLTYPE CVSAProvider::CancelQuery( 
    /* [in] */ DWORD dwID)
{
    Lock();

    // Get rid of the query item(s).
    m_mapEventSources.RemoveEventSourceRef(dwID);

    if (m_mapEventSources.IsMapEmpty() && m_pPluginControl != NULL)
    {
        if(m_dwPluginCookie != 0)
        {
            m_pPluginControl->UnloadPlugin(m_dwPluginCookie);
        }

        // This will release it too.
        m_pPluginControl = NULL;
    }

    Unlock();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CVSAProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags)
{
    // Save off the sink.
    m_pSink = pSink;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CVSAProvider::SetPluginController(
		/* [in] */ IVSAPluginController __RPC_FAR *pController,
        DWORD dwProcessID)
{
    CoRevertToSelf();

    m_mapEventSources.SetPlugin(m_dwPluginCookie, pController);

    HANDLE hprocessPlugin;

    hprocessPlugin = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessID);

    if (hprocessPlugin)
    {
        HANDLE hPipeWriteForPlugin;

        if (DuplicateHandle(
            GetCurrentProcess(),
            m_hPipeWrite,
            hprocessPlugin,
            &hPipeWriteForPlugin,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS))
        {
            pController->SetWriteHandle((DWORD64) hPipeWriteForPlugin);    
        }

        CloseHandle(hprocessPlugin);
    }

    return S_OK;
}


HRESULT CVSAProvider::EventGUIDToEventSourceList(
    LPCWSTR szEventGUID, 
    CGuidList &listSources)
{
    LPWSTR szQuery = new WCHAR[wcslen(szEventGUID) + 100];

    if (!szQuery)
        return WBEM_E_OUT_OF_MEMORY;

    swprintf(
        szQuery,
        L"select EventList, ProviderGUID from MSFT_AppProfEventProviderSetting "
        L"where ProviderGUID = \"%s\"",
        szEventGUID);
    
    IEnumWbemClassObjectPtr pEnum;

    if (SUCCEEDED(
        m_pSvc->ExecQuery(
            _bstr_t(L"WQL"),
            _bstr_t(szQuery),
            WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pEnum)))
    {
        DWORD               nReturned = 0;
        IWbemClassObjectPtr pObj;

        while(SUCCEEDED(pEnum->Next(WBEM_INFINITE, 1, &pObj, &nReturned)) && 
            nReturned)
        {
            _variant_t vEventList;
            
            if (SUCCEEDED(pObj->Get(L"EventList", 0, &vEventList, NULL, NULL)) &&
                vEventList.vt == (VT_ARRAY | VT_BSTR))
            {
                BSTR  *pstrEvents = (BSTR*) vEventList.parray->pvData;
                DWORD nElements = vEventList.parray->rgsabound[0].cElements;

                for (DWORD i = 0; i < nElements; i++)
                {
                    if (!wcscmp(szEventGUID, pstrEvents[i]))
                    {
                        _variant_t vSourceGUID;

                        if (SUCCEEDED(pObj->Get(
                            L"ProviderGUID", 0, &vSourceGUID, NULL, NULL)) &&
                            vSourceGUID.vt == VT_BSTR)
                        {
                            // This event source supports this event, so add the event 
                            // source GUID to the list.
                            GUID guidEventSource;

                            // Convert the event source to a guid and add it to the list.
                            if (CLSIDFromString(V_BSTR(&vSourceGUID), 
                                &guidEventSource) == 0)
                                listSources.push_back(guidEventSource);
                        }

                        break;
                    }
                }
            }
        }
    }

    delete szQuery;

    return S_OK;
}

HRESULT CVSAProvider::WmiClassToVSAGuid(
    LPCWSTR szClassName, 
    _bstr_t &strGuid)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR  szPath = new WCHAR[wcslen(szClassName) + 100];

    if (szPath)
    {
        IWbemClassObjectPtr pObj;

        swprintf(
            szPath,
            L"select ClassName from MSFT_AppProfEventSetting where WmiClassName=\"%s\"",
            szClassName);
    
        IEnumWbemClassObjectPtr pEnum;
        DWORD                   nCount = 0;

        if (SUCCEEDED(
            m_pSvc->ExecQuery(
                _bstr_t(L"WQL"),
                _bstr_t(szPath),
                WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pEnum)) &&
            SUCCEEDED(pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) && nCount)
        {
            _variant_t vClass;

            if (SUCCEEDED(pObj->Get(L"ClassName", 0, &vClass, NULL, NULL)) &&
                vClass.vt == VT_BSTR)
            {
                strGuid = V_BSTR(&vClass);

                hr = S_OK;
            }
        }
            
        delete szPath;
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

HRESULT CVSAProvider::QueryToEventSourceList(
    LPCWSTR szQuery, 
    CGuidList &listSources)
{
    HRESULT hr = WBEM_E_INVALID_QUERY;

    // Parse the query
    CTextLexSource lexSource(szQuery);
    QL1_Parser     parser(&lexSource);
    
    QL_LEVEL_1_RPN_EXPRESSION *pExpr = NULL;
    
    if (parser.Parse(&pExpr) == 0)
    {
        // See if any VSA event provivders were explicitly listed.
        hr = GetValuesForProp(pExpr, L"ProviderGUID", listSources);

        // It's OK if this property isn't in the query.
        if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            hr = S_OK;

        if (SUCCEEDED(hr))
        {
            // See if the class is our generic MSFT_AppProfGenericVSA.
            if (!_wcsicmp(pExpr->bsClassName, GENERIC_VSA_EVENT))
            {
                CGuidList listEvents;

                // See if any VSA events were explicitly listed.
                GetValuesForProp(pExpr, L"EventGUID", listEvents);

                for (CGuidListIterator event = listEvents.begin();
                    event != listEvents.end(); event++)
                {
                    WCHAR szGUID[100];

                    // For each event we find, add to the list of event sources by
                    // finding those event sources that support this event.
                    if (SUCCEEDED(StringFromGUID2(*event, szGUID, COUNTOF(szGUID))))
                    {
                        hr = 
                            EventGUIDToEventSourceList(
                                szGUID, 
                                listSources);
                    }
                }

                // If no VSA providers were specified, reject the query as too broad.
                if (listSources.size() == 0)
                    hr = WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            // Must be a descendent class.
            else
            {
                // If no VSA providers were explicitly listed, we'll have to 
                // find the components that support this event using VSA's
                // instance provider.
                if (listSources.size() == 0)
                {
                    _bstr_t strGuid;

                    // Get the VSA guid using the WMI class name.  If the guid
                    // exists this class isn't a VSA class, in which case we 
                    // can just ignore this query by not returning any VSA 
                    // provider GUIDs.

                    hr = WmiClassToVSAGuid(pExpr->bsClassName, strGuid);
                    if (SUCCEEDED(hr))
                    {
                        hr = 
                            EventGUIDToEventSourceList(
                                strGuid, 
                                listSources);
                    }
                    else if(hr == WBEM_E_NOT_FOUND)
                    {
                        //
                        // Perhaps make the return code better?
                        //

                        if(!_wcsicmp(pExpr->bsClassName, VSA_EVENT_BASE) ||
                           !_wcsicmp(pExpr->bsClassName, L"__ExtrinsicEvent") ||
                           !_wcsicmp(pExpr->bsClassName, L"__Event"))
                        {
                            hr = WBEMESS_E_REGISTRATION_TOO_BROAD;
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_CLASS;
                        }
                    }
                }
            }
        }

		delete pExpr;
    }

    return hr;
}

BOOL CVSAProvider::IsVSAEventSource(GUID *pGUID)
{
    CGuidMapItor i;
    BOOL         bRet = FALSE;

    // Find the event source in our map.  If it's not there, get the answer 
    // from WMI and add it to our map.
    if ((i = m_mapVSASources.find(pGUID)) == m_mapVSASources.end())
    {
        WCHAR szGUID[100] = L"",
              szPath[512];

        StringFromGUID2(*pGUID, szGUID, COUNTOF(szGUID));
    
        swprintf(
            szPath,
            //L"MSFT_AppProfEventProviderSetting=\"%s\"",
            L"select Infrastructure from MSFT_AppProfEventProviderSetting where ProviderGUID=\"%s\"",
            szGUID);
    
        // TODO: Change to GetObject once the VSA team implements GetObject in 
        // their provider.
        IEnumWbemClassObjectPtr pEnum;
        IWbemClassObjectPtr     pObj;
        DWORD                   nCount = 0;
        _variant_t              vInf;

        if (SUCCEEDED(
            m_pSvc->ExecQuery(
                _bstr_t(L"WQL"),
                _bstr_t(szPath),
                WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pEnum)))
        {
            if(SUCCEEDED(pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) && nCount)
            {
                _variant_t vClass;

                if (SUCCEEDED(pObj->Get(L"Infrastructure", 0, &vInf, NULL, NULL)) &&
                    vInf.vt == VT_BSTR)
                    bRet = !_wcsicmp(L"VSA", V_BSTR(&vInf));
            }
        }
            
        // Cache the answer so we don't have to ask WMI next time we see this 
        // provider.            
        m_mapVSASources[pGUID] = bRet;
    }
    else
        bRet = (*i).second;
            
    return bRet;
}

#define MAX_MSG_SIZE  65536

DWORD WINAPI CVSAProvider::PipeReadThreadProc(CVSAProvider *pThis)
{
    DWORD dwSize,
          dwRead;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // First get the size of the message.
    while (ReadFile(pThis->m_hPipeRead, &dwSize, sizeof(dwSize), &dwRead, NULL))
    {
        BYTE  cBuffer[MAX_MSG_SIZE];
        DWORD dwTotalRead = 0;
        BOOL  bRet;

        do
        {
            dwRead = 0;

            // Now read the message.
            bRet = 
                ReadFile(
                    pThis->m_hPipeRead, 
                    &cBuffer[dwTotalRead], 
                    dwSize - dwTotalRead, 
                    &dwRead, 
                    NULL);

            dwTotalRead += dwRead;

        } while (bRet && dwTotalRead < dwSize);

        if (dwTotalRead == dwSize)
        {
            LPBYTE pCurrent = cBuffer,
                   pEnd = pCurrent + dwRead;
            GUID   *pSrcGuid = (GUID*) pCurrent;

            if (pThis->IsVSAEventSource(pSrcGuid))
            {
                WCHAR szProviderGuid[100] = L"";

                StringFromGUID2(*pSrcGuid, szProviderGuid, COUNTOF(szProviderGuid));

                pCurrent += sizeof(GUID);

                while (pCurrent < pEnd)
                {
                    VSA_EVENT_HEADER *pHeader = (VSA_EVENT_HEADER*) pCurrent;
                    CVSAEvent        *pEvent = pThis->m_mapEvents.FindEvent(
                                                   &pHeader->guidEvent);

                    if (pEvent && SUCCEEDED(pEvent->SetViaBuffer(szProviderGuid, pCurrent)))
                        pEvent->Indicate(pThis->m_pSink);

                    pCurrent += pHeader->dwSize;
                }
            }
        }
        else
            break;
    }

    CoUninitialize();

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CEventMap

CEventMap::~CEventMap()
{
    for (CEventMapIterator i = begin(); i != end(); i++)
        delete ((*i).second);
}

CVSAEvent *CEventMap::FindEvent(GUID *pGuid)
{
    CEventMapIterator i;
    CVSAEvent         *pEvent;

    if ((i = find(pGuid)) != end())
        pEvent = (*i).second;
    else
    {
        pEvent = new CVSAEvent;

        if (pEvent)
        {
            if (pEvent->InitFromGUID(m_pNamespace, pGuid))
                (*this)[CGuid(pGuid)] = pEvent;
            else
            {
                delete pEvent;
                pEvent = NULL;
            }
        }
    }
            
    return pEvent;
}

/////////////////////////////////////////////////////////////////////////////
// CEventSourceMap

CEventSourceMap::~CEventSourceMap()
{
    for (CEventSourceMapIterator i = begin(); i != end(); i++)
        FreeEventSource((*i).second);
}

void CEventSourceMap::FreeEventSource(CEventSource *pSrc)
{
    if (m_pPlugin != NULL)
    {
        m_pPlugin->DeactivateEventSource(*pSrc->GetGUID());
        
        delete pSrc;
    }        
}

CEventSource *CEventSourceMap::FindEventSource(GUID *pGuid)
{
    CEventSource            *pSrc = NULL;
    CEventSourceMapIterator i;

    if ((i = find(pGuid)) == end())
    {
        pSrc = new CEventSource(pGuid);

        if (pSrc)
            (*this)[CGuid(pGuid)] = pSrc;
    }
    else
        pSrc = (*i).second;
            
    return pSrc;
}

const IID IID_ISystemDebugPluginControl = 
    {0x6c736d3F,0x7E40,0x41e2,{0x98,0x77,0x8C,0xA6,0x3B,0x49,0x34,0x64}};

BOOL CEventSourceMap::AddEventSourceRef(DWORD dwID, CEventSource *pSrc)
{
    CEventSourceListMapIterator i;
    CEventSourceList            *pList = NULL;

    // Find the list associated with this query ID.  If we don't find it,
    // we'll add a new list for this ID.
    if ((i = m_mapIdToSourceList.find(dwID)) == m_mapIdToSourceList.end())
    {
        CEventSourceList list;

        pList = &(m_mapIdToSourceList[dwID] = list);
    }
    else
        pList = &(*i).second;
            
    pList->push_back(pSrc);

    
    if (pSrc->AddRef() == 1)
    {
        if (m_pPlugin != NULL)
        {
            HRESULT hr;

            hr = m_pPlugin->ActivateEventSource(pSrc->m_guid);
        }
    }
    
    return TRUE;
}

BOOL CEventSourceMap::RemoveEventSourceRef(DWORD dwID)
{
    CEventSourceListMapIterator i;

    if ((i = m_mapIdToSourceList.find(dwID)) != m_mapIdToSourceList.end())
    {
        CEventSourceList &list = (*i).second;

        for (CEventSourceListIterator p = list.begin(); p != list.end(); p++)
        {
            CEventSource *pSrc = *p;

            if (!pSrc->Release())
                RemoveEventSource(pSrc);
        }

        m_mapIdToSourceList.erase(i);
    }

    return TRUE;
}

void CEventSourceMap::RemoveEventSource(CEventSource *pSrc)
{
    for (CEventSourceMapIterator i = begin(); i != end(); i++)
    {
        if ((*i).second == pSrc)
        {
            FreeEventSource(pSrc);
            
            i = erase(i);
            
            // If we don't check here i will get incremented past end(), which
            // would be bad.
            if (i == end())
                break;
        }
    }
}

void CEventSourceMap::SetPlugin(
    DWORD dwPluginID, 
    IVSAPluginController *pPlugin
    )
{
    m_pPlugin = pPlugin;

    // Now enable all the event sources we obtained through our queries.
    for (CEventSourceMapIterator i = begin(); i != end(); i++)
    {
        CGuid guid = (*i).first;

        m_pPlugin->ActivateEventSource(guid);
    }
}


// Query Helper
HRESULT GetValuesForProp(
    QL_LEVEL_1_RPN_EXPRESSION* pExpr,
    LPCWSTR szPropName, 
    CGuidList &listGuids)
{
    // Get the necessary query
    HRESULT hres = S_OK;

    // See if there are any tokens
    if (pExpr->nNumTokens > 0)
    {
        // Combine them all
        for (int i = 0; i < pExpr->nNumTokens && SUCCEEDED(hres); i++)
        {
            QL_LEVEL_1_TOKEN &token = pExpr->pArrayOfTokens[i];
        
            if (token.nTokenType == QL1_NOT)
                hres = WBEMESS_E_REGISTRATION_TOO_BROAD;
            else if (token.nTokenType == QL1_OP_EXPRESSION)
            {
                if (!_wcsicmp(token.PropertyName.GetStringAt(0), szPropName))
				{
					if (V_VT(&token.vConstValue) == VT_BSTR)
					{
						// This token is a string equality. Try to convert it to a GUID.
						GUID guid;

						if (CLSIDFromString(V_BSTR(&token.vConstValue), &guid) == 0)
							listGuids.push_back(guid);
						else
							hres = WBEM_E_INVALID_QUERY;
					}
					else
						hres = WBEM_E_INVALID_QUERY;
				}
            }
        }
    }
    else
        hres = WBEMESS_E_REGISTRATION_TOO_BROAD;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\vsaevent.h ===
// VSAEvent.h

#ifndef __VSAEVENT_H_
#define __VSAEVENT_H_

#include "vaevt.h" // For the VSA defines.
#include "ObjAccess.h"

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));

struct VSA_EVENT_HEADER
{
    DWORD dwSize;
    DWORD dwFlags;
    GUID  guidEvent;
    DWORD dwTimeHigh;
    DWORD dwTimeLow;
};

struct VSA_EVENT_FIELD
{
    DWORD dwType;
    union
    {
        DWORD dwIndex;
        WCHAR szName[1];
    };
};


class CVSAEvent : protected CObjAccess
{
public:
    BOOL InitFromGUID(IWbemServices *pSvc, GUID *pGUID);
    HRESULT SetViaBuffer(LPCWSTR szProviderGuid, LPBYTE pBuffer);
    HRESULT Indicate(IWbemObjectSink *pSink);

protected:
    IWbemClassObjectPtr m_pObjBase;

    // Get a copy from m_pObjBase and put it into our main object.
    HRESULT Reset();

    DWORD GetVSADataLength(LPBYTE pBuffer, VSAParameterType typeVSA);
    DWORD GetCIMDataLength(VARIANT *pVar, CIMTYPE type);
    BOOL AreTypesEquivalent(CIMTYPE type, VSAParameterType typeVSA);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\vsaprovider.h ===
// VSAProvider.h : Declaration of the CVSAProvider

#ifndef __VSAPROVIDER_H_
#define __VSAPROVIDER_H_

#include "resource.h"       // main symbols

#include <list>
#include <map>
#include <wstlallc.h>

#include "LecPlugIn.h"
#include "VSAEvent.h"

class CGuid : public GUID
{
public:
    CGuid(GUID *pGuid) { *(GUID*) this = *pGuid; }

    BOOL operator==(const CGuid& other) const 
    { 
        return !memcmp(this, &other, sizeof(GUID));
    }

    bool operator < (const CGuid& other) const
    { 
        return memcmp(this, &other, sizeof(GUID)) < 0;
    }
};

class CEventSource
{
public:
    CEventSource(GUID *pGuid) : m_dwRef(0)
    {
        memcpy(&m_guid, pGuid, sizeof(m_guid));
    }

    BOOL operator==(GUID *pGUID)
    {
        return !memcmp(this, pGUID, sizeof(GUID));
    }

    int AddRef() { return ++m_dwRef; }
    int Release() { return --m_dwRef; }
    GUID *GetGUID() { return &m_guid; }

public:
    DWORD m_dwRef;
    GUID  m_guid;
};

typedef std::list<GUID, wbem_allocator<GUID> > CGuidList;
typedef CGuidList::iterator CGuidListIterator;

typedef std::list<CEventSource*, wbem_allocator<CEventSource*> > CEventSourceList;
typedef CEventSourceList::iterator CEventSourceListIterator;

typedef std::map<DWORD, CEventSourceList, std::less<DWORD>, wbem_allocator<CEventSourceList> > CEventSourceListMap;
typedef CEventSourceListMap::iterator CEventSourceListMapIterator;

typedef std::map<CGuid, BOOL, std::less<CGuid>, wbem_allocator<BOOL> > CGuidMap;
typedef CGuidMap::iterator CGuidMapItor;

_COM_SMARTPTR_TYPEDEF(ISystemDebugPluginControl, __uuidof(ISystemDebugPluginControl));
_COM_SMARTPTR_TYPEDEF(IVSAPluginController, __uuidof(IVSAPluginController));

class CEventSourceMap : protected std::map<CGuid, CEventSource*, std::less<CGuid>, wbem_allocator<CEventSource*> >
{
public:
    ~CEventSourceMap();

    void SetPlugin(DWORD dwPluginID, IVSAPluginController *pPlugin);

    CEventSource *FindEventSource(GUID *pGuid);

    BOOL AddEventSourceRef(DWORD dwID, CEventSource *pSrc);
    BOOL RemoveEventSourceRef(DWORD dwID);
    void RemoveEventSource(CEventSource *pSrc);
    BOOL IsMapEmpty() { return m_mapIdToSourceList.empty(); }

protected:
    CEventSourceListMap    m_mapIdToSourceList;

    // Information passed to us by the plug-in.
    IVSAPluginControllerPtr m_pPlugin;
    DWORD   m_dwPluginID;

    void FreeEventSource(CEventSource *pSrc);

    typedef CEventSourceMap::iterator CEventSourceMapIterator;
};

class CEventMap : protected std::map<CGuid, CVSAEvent*, std::less<CGuid>, wbem_allocator<CVSAEvent*> >
{
public:
    ~CEventMap();

    void SetNamespace(IWbemServices *pNamespace) 
    { 
        m_pNamespace = pNamespace;
    }

    CVSAEvent *FindEvent(GUID *pGuid);

protected:
    // We'll use this to create CVSAEvents.
    IWbemServicesPtr m_pNamespace;

    typedef CEventMap::iterator CEventMapIterator;
};



/////////////////////////////////////////////////////////////////////////////
// CVSAProvider
class ATL_NO_VTABLE CVSAProvider : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CVSAProvider, &CLSID_VSAToWMIEventProvider>,
	public IWbemProviderInit,
    public IWbemEventProviderSecurity,
    public IWbemEventProviderQuerySink,
    public IWbemEventProvider,
    public IVSAPluginControllerSink
{
public:
	CVSAProvider();
    ~CVSAProvider();

DECLARE_REGISTRY_RESOURCEID(IDR_VSAPROVIDER)
DECLARE_NOT_AGGREGATABLE(CVSAProvider)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVSAProvider)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
	COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
	COM_INTERFACE_ENTRY(IWbemEventProvider)
	COM_INTERFACE_ENTRY(IVSAPluginControllerSink)
END_COM_MAP()

// IWbemProviderInit
public:
    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);


// IWbemEventProviderSecurity
public:
    HRESULT STDMETHODCALLTYPE AccessCheck( 
        /* [in] */ WBEM_CWSTR wszQueryLanguage,
        /* [in] */ WBEM_CWSTR wszQuery,
        /* [in] */ long lSidLength,
        /* [unique][size_is][in] */ const BYTE __RPC_FAR *pSid);


// IWbemEventProviderQuerySink
public:
    HRESULT STDMETHODCALLTYPE NewQuery( 
        /* [in] */ unsigned long dwId,
        /* [in] */ WBEM_WSTR wszQueryLanguage,
        /* [in] */ WBEM_WSTR wszQuery);
        
    HRESULT STDMETHODCALLTYPE CancelQuery( 
        /* [in] */ unsigned long dwId);


// IWbemEventProvider
public:
    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags);


// IVSAPluginControllerSink
public:
	HRESULT STDMETHODCALLTYPE SetPluginController(
		/* [in] */ IVSAPluginController __RPC_FAR *pSink,
        DWORD dwProcessID);

// Implementation
protected:
    CEventSourceMap m_mapEventSources;
    CGuidMap        m_mapVSASources;
    CEventMap       m_mapEvents;
    HANDLE          m_hthreadRead,
                    m_hPipeRead,
                    m_hPipeWrite;
    DWORD           m_dwProcessID;
    
    // The LEC we CoCreated.
    ISystemDebugPluginControlPtr m_pPluginControl;
    
    // Our interface to talk to our plug-in.
    //IVSAPluginControllerPtr m_pPlugin;

    // The IWbemServices WMI gave us.
    IWbemServicesPtr m_pSvc;

    // The event sink WMI gave us.
    IWbemObjectSinkPtr m_pSink;

    DWORD m_dwPluginCookie;

    HRESULT QueryToEventSourceList(
        LPCWSTR szQuery, 
        CGuidList &listSources);

    HRESULT EventGUIDToEventSourceList(
        LPCWSTR szEventGUID, 
        CGuidList &listSources);

    BOOL IsVSAEventSource(GUID *pGUID);

    HRESULT WmiClassToVSAGuid(
        LPCWSTR szClassName, 
        _bstr_t &strGuid);

    static DWORD WINAPI PipeReadThreadProc(CVSAProvider *pThis);
};

#endif //__VSAPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\vsaprov.cpp ===
// VSAProv.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f VSAProvps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "VSAProv.h"
#include "dlldatax.h"

#include "VSAProv_i.c"
#include "VSAProvider.h"


#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_VSAToWMIEventProvider, CVSAProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_VSAPROVLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\vsa\vsaprov\vaevt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Mon May 25 22:01:08 1998
 */
/* Compiler settings for vaevt.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vaevt_h__
#define __vaevt_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISystemDebugEventFire_FWD_DEFINED__
#define __ISystemDebugEventFire_FWD_DEFINED__
typedef interface ISystemDebugEventFire ISystemDebugEventFire;
#endif 	/* __ISystemDebugEventFire_FWD_DEFINED__ */


#ifndef __ISystemDebugEventFireAuto_FWD_DEFINED__
#define __ISystemDebugEventFireAuto_FWD_DEFINED__
typedef interface ISystemDebugEventFireAuto ISystemDebugEventFireAuto;
#endif 	/* __ISystemDebugEventFireAuto_FWD_DEFINED__ */


#ifndef __ISystemDebugEventInstall_FWD_DEFINED__
#define __ISystemDebugEventInstall_FWD_DEFINED__
typedef interface ISystemDebugEventInstall ISystemDebugEventInstall;
#endif 	/* __ISystemDebugEventInstall_FWD_DEFINED__ */


#ifndef __ISystemDebugEventInstallAuto_FWD_DEFINED__
#define __ISystemDebugEventInstallAuto_FWD_DEFINED__
typedef interface ISystemDebugEventInstallAuto ISystemDebugEventInstallAuto;
#endif 	/* __ISystemDebugEventInstallAuto_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISystemDebugEventFire_INTERFACE_DEFINED__
#define __ISystemDebugEventFire_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISystemDebugEventFire
 * at Mon May 25 22:01:08 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 


typedef /* [v1_enum] */ 
enum VSAParameterType
    {	cVSAParameterKeyMask	= 0x80000000,
	cVSAParameterKeyString	= 0x80000000,
	cVSAParameterValueMask	= 0x7ffff,
	cVSAParameterValueTypeMask	= 0x70000,
	cVSAParameterValueUnicodeString	= 0,
	cVSAParameterValueANSIString	= 0x10000,
	cVSAParameterValueGUID	= 0x20000,
	cVSAParameterValueDWORD	= 0x30000,
	cVSAParameterValueBYTEArray	= 0x40000,
	cVSAParameterValueLengthMask	= 0xffff
    }	VSAParameterFlags;

typedef /* [v1_enum] */ 
enum VSAStandardParameter
    {	cVSAStandardParameterDefaultFirst	= 0,
	cVSAStandardParameterSourceMachine	= 0,
	cVSAStandardParameterSourceProcess	= 1,
	cVSAStandardParameterSourceThread	= 2,
	cVSAStandardParameterSourceComponent	= 3,
	cVSAStandardParameterSourceSession	= 4,
	cVSAStandardParameterTargetMachine	= 5,
	cVSAStandardParameterTargetProcess	= 6,
	cVSAStandardParameterTargetThread	= 7,
	cVSAStandardParameterTargetComponent	= 8,
	cVSAStandardParameterTargetSession	= 9,
	cVSAStandardParameterSecurityIdentity	= 10,
	cVSAStandardParameterCausalityID	= 11,
	cVSAStandardParameterSourceProcessName	= 12,
	cVSAStandardParameterTargetProcessName	= 13,
	cVSAStandardParameterDefaultLast	= 13,
	cVSAStandardParameterNoDefault	= 0x4000,
	cVSAStandardParameterSourceHandle	= 0x4000,
	cVSAStandardParameterTargetHandle	= 0x4001,
	cVSAStandardParameterArguments	= 0x4002,
	cVSAStandardParameterReturnValue	= 0x4003,
	cVSAStandardParameterException	= 0x4004,
	cVSAStandardParameterCorrelationID	= 0x4005,
	cVSAStandardParameterDynamicEventData	= 0x4006,
	cVSAStandardParameterNoDefaultLast	= 0x4006
    }	VSAStandardParameters;

typedef /* [v1_enum] */ 
enum eVSAEventFlags
    {	cVSAEventStandard	= 0,
	cVSAEventDefaultSource	= 1,
	cVSAEventDefaultTarget	= 2,
	cVSAEventForceSend	= 8
    }	VSAEventFlags;

#if defined(__cplusplus)
inline VSAEventFlags operator | (const VSAEventFlags &left, const VSAEventFlags &right)
{
  return (VSAEventFlags)((int)left|(int)right);
}
inline VSAEventFlags operator + (const VSAEventFlags &left, const VSAEventFlags &right)
{
  return (VSAEventFlags)((int)left+(int)right);
}
#endif

EXTERN_C const IID IID_ISystemDebugEventFire;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6c736dC1-AB0D-11d0-A2AD-00A0C90F27E8")
    ISystemDebugEventFire : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginSession( 
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ LPCOLESTR strSessionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSession( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireEvent( 
            /* [in] */ REFGUID guidEvent,
            /* [in] */ int nEntries,
            /* [size_is][in] */ LPDWORD rgKeys,
            /* [size_is][in] */ LPDWORD rgValues,
            /* [size_is][in] */ LPDWORD rgTypes,
            /* [in] */ DWORD dwTimeLow,
            /* [in] */ LONG dwTimeHigh,
            /* [in] */ VSAEventFlags dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemDebugEventFireVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISystemDebugEventFire __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISystemDebugEventFire __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISystemDebugEventFire __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginSession )( 
            ISystemDebugEventFire __RPC_FAR * This,
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ LPCOLESTR strSessionName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndSession )( 
            ISystemDebugEventFire __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            ISystemDebugEventFire __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireEvent )( 
            ISystemDebugEventFire __RPC_FAR * This,
            /* [in] */ REFGUID guidEvent,
            /* [in] */ int nEntries,
            /* [size_is][in] */ LPDWORD rgKeys,
            /* [size_is][in] */ LPDWORD rgValues,
            /* [size_is][in] */ LPDWORD rgTypes,
            /* [in] */ DWORD dwTimeLow,
            /* [in] */ LONG dwTimeHigh,
            /* [in] */ VSAEventFlags dwFlags);
        
        END_INTERFACE
    } ISystemDebugEventFireVtbl;

    interface ISystemDebugEventFire
    {
        CONST_VTBL struct ISystemDebugEventFireVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemDebugEventFire_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISystemDebugEventFire_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISystemDebugEventFire_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISystemDebugEventFire_BeginSession(This,guidSourceID,strSessionName)	\
    (This)->lpVtbl -> BeginSession(This,guidSourceID,strSessionName)

#define ISystemDebugEventFire_EndSession(This)	\
    (This)->lpVtbl -> EndSession(This)

#define ISystemDebugEventFire_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define ISystemDebugEventFire_FireEvent(This,guidEvent,nEntries,rgKeys,rgValues,rgTypes,dwTimeLow,dwTimeHigh,dwFlags)	\
    (This)->lpVtbl -> FireEvent(This,guidEvent,nEntries,rgKeys,rgValues,rgTypes,dwTimeLow,dwTimeHigh,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISystemDebugEventFire_BeginSession_Proxy( 
    ISystemDebugEventFire __RPC_FAR * This,
    /* [in] */ REFGUID guidSourceID,
    /* [in] */ LPCOLESTR strSessionName);


void __RPC_STUB ISystemDebugEventFire_BeginSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventFire_EndSession_Proxy( 
    ISystemDebugEventFire __RPC_FAR * This);


void __RPC_STUB ISystemDebugEventFire_EndSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventFire_IsActive_Proxy( 
    ISystemDebugEventFire __RPC_FAR * This);


void __RPC_STUB ISystemDebugEventFire_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventFire_FireEvent_Proxy( 
    ISystemDebugEventFire __RPC_FAR * This,
    /* [in] */ REFGUID guidEvent,
    /* [in] */ int nEntries,
    /* [size_is][in] */ LPDWORD rgKeys,
    /* [size_is][in] */ LPDWORD rgValues,
    /* [size_is][in] */ LPDWORD rgTypes,
    /* [in] */ DWORD dwTimeLow,
    /* [in] */ LONG dwTimeHigh,
    /* [in] */ VSAEventFlags dwFlags);


void __RPC_STUB ISystemDebugEventFire_FireEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISystemDebugEventFire_INTERFACE_DEFINED__ */


#ifndef __ISystemDebugEventFireAuto_INTERFACE_DEFINED__
#define __ISystemDebugEventFireAuto_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISystemDebugEventFireAuto
 * at Mon May 25 22:01:08 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_ISystemDebugEventFireAuto;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6c736dee-AB0e-11d0-A2AD-00A0C90F27E8")
    ISystemDebugEventFireAuto : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginSession( 
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR strSessionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSession( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ VARIANT_BOOL __RPC_FAR *pbIsActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireEvent( 
            /* [in] */ BSTR guidEvent,
            /* [in] */ VARIANT rgKeys,
            /* [in] */ VARIANT rgValues,
            /* [in] */ long rgCount,
            /* [in] */ VSAEventFlags dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemDebugEventFireAutoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISystemDebugEventFireAuto __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISystemDebugEventFireAuto __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISystemDebugEventFireAuto __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginSession )( 
            ISystemDebugEventFireAuto __RPC_FAR * This,
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR strSessionName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndSession )( 
            ISystemDebugEventFireAuto __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            ISystemDebugEventFireAuto __RPC_FAR * This,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pbIsActive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireEvent )( 
            ISystemDebugEventFireAuto __RPC_FAR * This,
            /* [in] */ BSTR guidEvent,
            /* [in] */ VARIANT rgKeys,
            /* [in] */ VARIANT rgValues,
            /* [in] */ long rgCount,
            /* [in] */ VSAEventFlags dwFlags);
        
        END_INTERFACE
    } ISystemDebugEventFireAutoVtbl;

    interface ISystemDebugEventFireAuto
    {
        CONST_VTBL struct ISystemDebugEventFireAutoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemDebugEventFireAuto_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISystemDebugEventFireAuto_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISystemDebugEventFireAuto_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISystemDebugEventFireAuto_BeginSession(This,guidSourceID,strSessionName)	\
    (This)->lpVtbl -> BeginSession(This,guidSourceID,strSessionName)

#define ISystemDebugEventFireAuto_EndSession(This)	\
    (This)->lpVtbl -> EndSession(This)

#define ISystemDebugEventFireAuto_IsActive(This,pbIsActive)	\
    (This)->lpVtbl -> IsActive(This,pbIsActive)

#define ISystemDebugEventFireAuto_FireEvent(This,guidEvent,rgKeys,rgValues,rgCount,dwFlags)	\
    (This)->lpVtbl -> FireEvent(This,guidEvent,rgKeys,rgValues,rgCount,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISystemDebugEventFireAuto_BeginSession_Proxy( 
    ISystemDebugEventFireAuto __RPC_FAR * This,
    /* [in] */ BSTR guidSourceID,
    /* [in] */ BSTR strSessionName);


void __RPC_STUB ISystemDebugEventFireAuto_BeginSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventFireAuto_EndSession_Proxy( 
    ISystemDebugEventFireAuto __RPC_FAR * This);


void __RPC_STUB ISystemDebugEventFireAuto_EndSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventFireAuto_IsActive_Proxy( 
    ISystemDebugEventFireAuto __RPC_FAR * This,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pbIsActive);


void __RPC_STUB ISystemDebugEventFireAuto_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventFireAuto_FireEvent_Proxy( 
    ISystemDebugEventFireAuto __RPC_FAR * This,
    /* [in] */ BSTR guidEvent,
    /* [in] */ VARIANT rgKeys,
    /* [in] */ VARIANT rgValues,
    /* [in] */ long rgCount,
    /* [in] */ VSAEventFlags dwFlags);


void __RPC_STUB ISystemDebugEventFireAuto_FireEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISystemDebugEventFireAuto_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_vaevt_0140
 * at Mon May 25 22:01:08 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 



enum __MIDL___MIDL_itf_vaevt_0140_0001
    {	DEBUG_EVENT_TYPE_FIRST	= 0,
	DEBUG_EVENT_TYPE_OUTBOUND	= 0,
	DEBUG_EVENT_TYPE_INBOUND	= 1,
	DEBUG_EVENT_TYPE_GENERIC	= 2,
	DEBUG_EVENT_TYPE_DEFAULT	= 2,
	DEBUG_EVENT_TYPE_MEASURED	= 3,
	DEBUG_EVENT_TYPE_BEGIN	= 4,
	DEBUG_EVENT_TYPE_END	= 5,
	DEBUG_EVENT_TYPE_LAST	= 5
    };


extern RPC_IF_HANDLE __MIDL_itf_vaevt_0140_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vaevt_0140_v0_0_s_ifspec;

#ifndef __ISystemDebugEventInstall_INTERFACE_DEFINED__
#define __ISystemDebugEventInstall_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISystemDebugEventInstall
 * at Mon May 25 22:01:08 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_ISystemDebugEventInstall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6c736dC0-AB0D-11d0-A2AD-00A0C90F27E8")
    ISystemDebugEventInstall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterSource( 
            /* [in] */ LPCOLESTR strVisibleName,
            /* [in] */ REFGUID guidSourceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSourceRegistered( 
            /* [in] */ REFGUID guidSourceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterStockEvent( 
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ REFGUID guidEventID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterCustomEvent( 
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ REFGUID guidEventID,
            /* [in] */ LPCOLESTR strVisibleName,
            /* [in] */ LPCOLESTR strDescription,
            /* [in] */ long nEventType,
            /* [in] */ REFGUID guidCategory,
            /* [in] */ LPCOLESTR strIconFile,
            /* [in] */ long nIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterEventCategory( 
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ REFGUID guidCategoryID,
            /* [in] */ REFGUID guidParentID,
            /* [in] */ LPCOLESTR strVisibleName,
            /* [in] */ LPCOLESTR strDescription,
            /* [in] */ LPCOLESTR strIconFile,
            /* [in] */ long nIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterSource( 
            /* [in] */ REFGUID guidSourceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterDynamicSource( 
            /* [in] */ LPCOLESTR strVisibleName,
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ LPCOLESTR strDescription,
            /* [in] */ REFGUID guidClsid,
            /* [in] */ long inproc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterDynamicSource( 
            /* [in] */ REFGUID guidSourceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDynamicSourceRegistered( 
            /* [in] */ REFGUID guidSourceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemDebugEventInstallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISystemDebugEventInstall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISystemDebugEventInstall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterSource )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ LPCOLESTR strVisibleName,
            /* [in] */ REFGUID guidSourceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSourceRegistered )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ REFGUID guidSourceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterStockEvent )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ REFGUID guidEventID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCustomEvent )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ REFGUID guidEventID,
            /* [in] */ LPCOLESTR strVisibleName,
            /* [in] */ LPCOLESTR strDescription,
            /* [in] */ long nEventType,
            /* [in] */ REFGUID guidCategory,
            /* [in] */ LPCOLESTR strIconFile,
            /* [in] */ long nIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterEventCategory )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ REFGUID guidCategoryID,
            /* [in] */ REFGUID guidParentID,
            /* [in] */ LPCOLESTR strVisibleName,
            /* [in] */ LPCOLESTR strDescription,
            /* [in] */ LPCOLESTR strIconFile,
            /* [in] */ long nIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterSource )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ REFGUID guidSourceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterDynamicSource )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ LPCOLESTR strVisibleName,
            /* [in] */ REFGUID guidSourceID,
            /* [in] */ LPCOLESTR strDescription,
            /* [in] */ REFGUID guidClsid,
            /* [in] */ long inproc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterDynamicSource )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ REFGUID guidSourceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDynamicSourceRegistered )( 
            ISystemDebugEventInstall __RPC_FAR * This,
            /* [in] */ REFGUID guidSourceID);
        
        END_INTERFACE
    } ISystemDebugEventInstallVtbl;

    interface ISystemDebugEventInstall
    {
        CONST_VTBL struct ISystemDebugEventInstallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemDebugEventInstall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISystemDebugEventInstall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISystemDebugEventInstall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISystemDebugEventInstall_RegisterSource(This,strVisibleName,guidSourceID)	\
    (This)->lpVtbl -> RegisterSource(This,strVisibleName,guidSourceID)

#define ISystemDebugEventInstall_IsSourceRegistered(This,guidSourceID)	\
    (This)->lpVtbl -> IsSourceRegistered(This,guidSourceID)

#define ISystemDebugEventInstall_RegisterStockEvent(This,guidSourceID,guidEventID)	\
    (This)->lpVtbl -> RegisterStockEvent(This,guidSourceID,guidEventID)

#define ISystemDebugEventInstall_RegisterCustomEvent(This,guidSourceID,guidEventID,strVisibleName,strDescription,nEventType,guidCategory,strIconFile,nIcon)	\
    (This)->lpVtbl -> RegisterCustomEvent(This,guidSourceID,guidEventID,strVisibleName,strDescription,nEventType,guidCategory,strIconFile,nIcon)

#define ISystemDebugEventInstall_RegisterEventCategory(This,guidSourceID,guidCategoryID,guidParentID,strVisibleName,strDescription,strIconFile,nIcon)	\
    (This)->lpVtbl -> RegisterEventCategory(This,guidSourceID,guidCategoryID,guidParentID,strVisibleName,strDescription,strIconFile,nIcon)

#define ISystemDebugEventInstall_UnRegisterSource(This,guidSourceID)	\
    (This)->lpVtbl -> UnRegisterSource(This,guidSourceID)

#define ISystemDebugEventInstall_RegisterDynamicSource(This,strVisibleName,guidSourceID,strDescription,guidClsid,inproc)	\
    (This)->lpVtbl -> RegisterDynamicSource(This,strVisibleName,guidSourceID,strDescription,guidClsid,inproc)

#define ISystemDebugEventInstall_UnRegisterDynamicSource(This,guidSourceID)	\
    (This)->lpVtbl -> UnRegisterDynamicSource(This,guidSourceID)

#define ISystemDebugEventInstall_IsDynamicSourceRegistered(This,guidSourceID)	\
    (This)->lpVtbl -> IsDynamicSourceRegistered(This,guidSourceID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_RegisterSource_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ LPCOLESTR strVisibleName,
    /* [in] */ REFGUID guidSourceID);


void __RPC_STUB ISystemDebugEventInstall_RegisterSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_IsSourceRegistered_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ REFGUID guidSourceID);


void __RPC_STUB ISystemDebugEventInstall_IsSourceRegistered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_RegisterStockEvent_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ REFGUID guidSourceID,
    /* [in] */ REFGUID guidEventID);


void __RPC_STUB ISystemDebugEventInstall_RegisterStockEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_RegisterCustomEvent_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ REFGUID guidSourceID,
    /* [in] */ REFGUID guidEventID,
    /* [in] */ LPCOLESTR strVisibleName,
    /* [in] */ LPCOLESTR strDescription,
    /* [in] */ long nEventType,
    /* [in] */ REFGUID guidCategory,
    /* [in] */ LPCOLESTR strIconFile,
    /* [in] */ long nIcon);


void __RPC_STUB ISystemDebugEventInstall_RegisterCustomEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_RegisterEventCategory_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ REFGUID guidSourceID,
    /* [in] */ REFGUID guidCategoryID,
    /* [in] */ REFGUID guidParentID,
    /* [in] */ LPCOLESTR strVisibleName,
    /* [in] */ LPCOLESTR strDescription,
    /* [in] */ LPCOLESTR strIconFile,
    /* [in] */ long nIcon);


void __RPC_STUB ISystemDebugEventInstall_RegisterEventCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_UnRegisterSource_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ REFGUID guidSourceID);


void __RPC_STUB ISystemDebugEventInstall_UnRegisterSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_RegisterDynamicSource_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ LPCOLESTR strVisibleName,
    /* [in] */ REFGUID guidSourceID,
    /* [in] */ LPCOLESTR strDescription,
    /* [in] */ REFGUID guidClsid,
    /* [in] */ long inproc);


void __RPC_STUB ISystemDebugEventInstall_RegisterDynamicSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_UnRegisterDynamicSource_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ REFGUID guidSourceID);


void __RPC_STUB ISystemDebugEventInstall_UnRegisterDynamicSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstall_IsDynamicSourceRegistered_Proxy( 
    ISystemDebugEventInstall __RPC_FAR * This,
    /* [in] */ REFGUID guidSourceID);


void __RPC_STUB ISystemDebugEventInstall_IsDynamicSourceRegistered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISystemDebugEventInstall_INTERFACE_DEFINED__ */


#ifndef __ISystemDebugEventInstallAuto_INTERFACE_DEFINED__
#define __ISystemDebugEventInstallAuto_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISystemDebugEventInstallAuto
 * at Mon May 25 22:01:08 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_ISystemDebugEventInstallAuto;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6c736ded-AB0D-11d0-A2AD-00A0C90F27E8")
    ISystemDebugEventInstallAuto : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterSource( 
            /* [in] */ BSTR strVisibleName,
            /* [in] */ BSTR guidSourceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSourceRegistered( 
            /* [in] */ BSTR guidSourceID,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pbIsRegistered) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterStockEvent( 
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR guidEventID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterCustomEvent( 
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR guidEventID,
            /* [in] */ BSTR strVisibleName,
            /* [in] */ BSTR strDescription,
            /* [in] */ long nEventType,
            /* [in] */ BSTR guidCategory,
            /* [in] */ BSTR strIconFile,
            /* [in] */ long nIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterEventCategory( 
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR guidCategoryID,
            /* [in] */ BSTR guidParentID,
            /* [in] */ BSTR strVisibleName,
            /* [in] */ BSTR strDescription,
            /* [in] */ BSTR strIconFile,
            /* [in] */ long nIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterSource( 
            /* [in] */ BSTR guidSourceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterDynamicSource( 
            /* [in] */ BSTR strVisibleName,
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR strDescription,
            /* [in] */ BSTR guidClsid,
            /* [in] */ long inproc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterDynamicSource( 
            /* [in] */ BSTR guidSourceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDynamicSourceRegistered( 
            /* [in] */ BSTR guidSourceID,
            /* [out] */ VARIANT_BOOL __RPC_FAR *boolRegistered) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemDebugEventInstallAutoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterSource )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR strVisibleName,
            /* [in] */ BSTR guidSourceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSourceRegistered )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR guidSourceID,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pbIsRegistered);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterStockEvent )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR guidEventID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCustomEvent )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR guidEventID,
            /* [in] */ BSTR strVisibleName,
            /* [in] */ BSTR strDescription,
            /* [in] */ long nEventType,
            /* [in] */ BSTR guidCategory,
            /* [in] */ BSTR strIconFile,
            /* [in] */ long nIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterEventCategory )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR guidCategoryID,
            /* [in] */ BSTR guidParentID,
            /* [in] */ BSTR strVisibleName,
            /* [in] */ BSTR strDescription,
            /* [in] */ BSTR strIconFile,
            /* [in] */ long nIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterSource )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR guidSourceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterDynamicSource )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR strVisibleName,
            /* [in] */ BSTR guidSourceID,
            /* [in] */ BSTR strDescription,
            /* [in] */ BSTR guidClsid,
            /* [in] */ long inproc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterDynamicSource )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR guidSourceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDynamicSourceRegistered )( 
            ISystemDebugEventInstallAuto __RPC_FAR * This,
            /* [in] */ BSTR guidSourceID,
            /* [out] */ VARIANT_BOOL __RPC_FAR *boolRegistered);
        
        END_INTERFACE
    } ISystemDebugEventInstallAutoVtbl;

    interface ISystemDebugEventInstallAuto
    {
        CONST_VTBL struct ISystemDebugEventInstallAutoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemDebugEventInstallAuto_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISystemDebugEventInstallAuto_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISystemDebugEventInstallAuto_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISystemDebugEventInstallAuto_RegisterSource(This,strVisibleName,guidSourceID)	\
    (This)->lpVtbl -> RegisterSource(This,strVisibleName,guidSourceID)

#define ISystemDebugEventInstallAuto_IsSourceRegistered(This,guidSourceID,pbIsRegistered)	\
    (This)->lpVtbl -> IsSourceRegistered(This,guidSourceID,pbIsRegistered)

#define ISystemDebugEventInstallAuto_RegisterStockEvent(This,guidSourceID,guidEventID)	\
    (This)->lpVtbl -> RegisterStockEvent(This,guidSourceID,guidEventID)

#define ISystemDebugEventInstallAuto_RegisterCustomEvent(This,guidSourceID,guidEventID,strVisibleName,strDescription,nEventType,guidCategory,strIconFile,nIcon)	\
    (This)->lpVtbl -> RegisterCustomEvent(This,guidSourceID,guidEventID,strVisibleName,strDescription,nEventType,guidCategory,strIconFile,nIcon)

#define ISystemDebugEventInstallAuto_RegisterEventCategory(This,guidSourceID,guidCategoryID,guidParentID,strVisibleName,strDescription,strIconFile,nIcon)	\
    (This)->lpVtbl -> RegisterEventCategory(This,guidSourceID,guidCategoryID,guidParentID,strVisibleName,strDescription,strIconFile,nIcon)

#define ISystemDebugEventInstallAuto_UnRegisterSource(This,guidSourceID)	\
    (This)->lpVtbl -> UnRegisterSource(This,guidSourceID)

#define ISystemDebugEventInstallAuto_RegisterDynamicSource(This,strVisibleName,guidSourceID,strDescription,guidClsid,inproc)	\
    (This)->lpVtbl -> RegisterDynamicSource(This,strVisibleName,guidSourceID,strDescription,guidClsid,inproc)

#define ISystemDebugEventInstallAuto_UnRegisterDynamicSource(This,guidSourceID)	\
    (This)->lpVtbl -> UnRegisterDynamicSource(This,guidSourceID)

#define ISystemDebugEventInstallAuto_IsDynamicSourceRegistered(This,guidSourceID,boolRegistered)	\
    (This)->lpVtbl -> IsDynamicSourceRegistered(This,guidSourceID,boolRegistered)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_RegisterSource_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR strVisibleName,
    /* [in] */ BSTR guidSourceID);


void __RPC_STUB ISystemDebugEventInstallAuto_RegisterSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_IsSourceRegistered_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR guidSourceID,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pbIsRegistered);


void __RPC_STUB ISystemDebugEventInstallAuto_IsSourceRegistered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_RegisterStockEvent_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR guidSourceID,
    /* [in] */ BSTR guidEventID);


void __RPC_STUB ISystemDebugEventInstallAuto_RegisterStockEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_RegisterCustomEvent_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR guidSourceID,
    /* [in] */ BSTR guidEventID,
    /* [in] */ BSTR strVisibleName,
    /* [in] */ BSTR strDescription,
    /* [in] */ long nEventType,
    /* [in] */ BSTR guidCategory,
    /* [in] */ BSTR strIconFile,
    /* [in] */ long nIcon);


void __RPC_STUB ISystemDebugEventInstallAuto_RegisterCustomEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_RegisterEventCategory_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR guidSourceID,
    /* [in] */ BSTR guidCategoryID,
    /* [in] */ BSTR guidParentID,
    /* [in] */ BSTR strVisibleName,
    /* [in] */ BSTR strDescription,
    /* [in] */ BSTR strIconFile,
    /* [in] */ long nIcon);


void __RPC_STUB ISystemDebugEventInstallAuto_RegisterEventCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_UnRegisterSource_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR guidSourceID);


void __RPC_STUB ISystemDebugEventInstallAuto_UnRegisterSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_RegisterDynamicSource_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR strVisibleName,
    /* [in] */ BSTR guidSourceID,
    /* [in] */ BSTR strDescription,
    /* [in] */ BSTR guidClsid,
    /* [in] */ long inproc);


void __RPC_STUB ISystemDebugEventInstallAuto_RegisterDynamicSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_UnRegisterDynamicSource_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR guidSourceID);


void __RPC_STUB ISystemDebugEventInstallAuto_UnRegisterDynamicSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemDebugEventInstallAuto_IsDynamicSourceRegistered_Proxy( 
    ISystemDebugEventInstallAuto __RPC_FAR * This,
    /* [in] */ BSTR guidSourceID,
    /* [out] */ VARIANT_BOOL __RPC_FAR *boolRegistered);


void __RPC_STUB ISystemDebugEventInstallAuto_IsDynamicSourceRegistered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISystemDebugEventInstallAuto_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\eventconsshell\evcons.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  EVCONS.CPP
//
//  Test event consumer shell.
//
//  raymcc  4-Jun-98
//
//***************************************************************************


#include <windows.h>
#include <stdio.h>

#include <wbemidl.h>

#include "oahelp.inl"
#include "evcons.h"


//***************************************************************************
//
//***************************************************************************

CMyEventConsumer::CMyEventConsumer()
{
    m_cRef = 0;
    
    m_pConsumer1 = new CMySink("Log1");
    m_pConsumer1->AddRef();

    m_pConsumer2 = new CMySink("Log2");
    m_pConsumer2->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CMyEventConsumer::~CMyEventConsumer()
{
    m_pConsumer1->Release();
    m_pConsumer2->Release();
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMyEventConsumer::FindConsumer( 
   /* [in] */ IWbemClassObject __RPC_FAR *pLogicalConsumer,
   /* [out] */ IWbemUnboundObjectSink __RPC_FAR *__RPC_FAR *ppConsumer
   )
{
    // Examine the logical consumer to see which one it is.
    // ====================================================

    VARIANT v;    
    VariantInit(&v);

    HRESULT hRes = WBEM_E_NOT_FOUND;
    *ppConsumer = 0;
            
    pLogicalConsumer->Get(CBSTR(L"Name"), 0, &v, 0, 0);

    // Decide which of the two logical consumers to send back.
    // =======================================================
    
    if (_wcsicmp(V_BSTR(&v), L"Consumer1") == 0)
    {
        m_pConsumer1->AddRef();
        *ppConsumer = m_pConsumer1;
        hRes = WBEM_S_NO_ERROR;
    }
    else if (_wcsicmp(V_BSTR(&v), L"Consumer2") == 0)
    {
        m_pConsumer1->AddRef();
        *ppConsumer = m_pConsumer2;
        hRes =WBEM_S_NO_ERROR;    
    }


    VariantClear(&v);
    return hRes;
} 


//***************************************************************************
//
//***************************************************************************
// ok


HRESULT CMyEventConsumer::Initialize( 
    /* [in] */ LPWSTR pszUser,
    /* [in] */ LONG lFlags,
    /* [in] */ LPWSTR pszNamespace,
    /* [in] */ LPWSTR pszLocale,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);
    return WBEM_S_NO_ERROR;
}
    

//***************************************************************************
//
//***************************************************************************
// ok

HRESULT CMyEventConsumer::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemEventConsumerProvider==riid)
    {
        *ppv = (IWbemEventConsumerProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventConsumer::AddRef()
{
    return ++m_cRef;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventConsumer::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
}



//***************************************************************************
//
//***************************************************************************
// ok


HRESULT CMySink::IndicateToConsumer( 
   /* [in] */ IWbemClassObject __RPC_FAR *pLogicalConsumer,
   /* [in] */ long lNumObjects,
   /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects
   )
{
    FILE *f = fopen(m_pszLogFile, "at");
    
    for (long i = 0; i < lNumObjects; i++)
    {
        IWbemClassObject *pObj = apObjects[i];
        
        VARIANT v;
        VariantInit(&v);


        // Verify the events are of the class we expect.
        // =============================================

        pObj->Get(CBSTR(L"__CLASS"), 0, &v, 0, 0);

        if (_wcsicmp(V_BSTR(&v), L"MyEvent") != 0)
        {
            VariantClear(&v);
            continue;
        }        

        VariantClear(&v);
        
        // Get the properties and log them to a file.
        // ==========================================
        
        VARIANT v2;
        VariantInit(&v2);
                        
        pObj->Get(CBSTR(L"Name"), 0, &v, 0, 0);        
        pObj->Get(CBSTR(L"Value"), 0, &v2, 0, 0);
        
        fprintf(f, "Event %S value = %d\n", V_BSTR(&v), V_I4(&v2));
        
        VariantClear(&v);
        VariantClear(&v2);
    }

    fclose(f);
    
    return WBEM_S_NO_ERROR;
}
   

//***************************************************************************
//
//***************************************************************************
// ok

STDMETHODIMP CMySink::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemUnboundObjectSink==riid)
    {
        *ppv = (IWbemUnboundObjectSink *) this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMySink::AddRef()
{
    return ++m_cRef;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMySink::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\eventconsshell\evcons.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



//***************************************************************************
//
//  EVCONS.H
//
//  Test event consumer shell.
//
//  raymcc  4-Jun-98
//
//***************************************************************************


#ifndef _EVCONS_H_
#define _EVCONS_H_

class CMySink;

class CMyEventConsumer : public IWbemEventConsumerProvider, public IWbemProviderInit
{
    
    ULONG               m_cRef;
    CMySink            *m_pConsumer1;
    CMySink            *m_pConsumer2;

public:

    CMyEventConsumer();
   ~CMyEventConsumer();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    virtual HRESULT STDMETHODCALLTYPE FindConsumer( 
        /* [in] */ IWbemClassObject __RPC_FAR *pLogicalConsumer,
        /* [out] */ IWbemUnboundObjectSink __RPC_FAR *__RPC_FAR *ppConsumer
        );


    virtual HRESULT STDMETHODCALLTYPE CMyEventConsumer::Initialize( 
        /* [in] */ LPWSTR pszUser,
        /* [in] */ LONG lFlags,
        /* [in] */ LPWSTR pszNamespace,
        /* [in] */ LPWSTR pszLocale,
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
        );

};


class CMySink : public IWbemUnboundObjectSink 
{
    ULONG               m_cRef;
    char               *m_pszLogFile;

public:
    CMySink(char *pLogFile) { m_cRef = 0; m_pszLogFile = strcpy(new char[128], pLogFile); }
   ~CMySink() { delete [] m_pszLogFile; }

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    virtual HRESULT STDMETHODCALLTYPE IndicateToConsumer( 
        /* [in] */ IWbemClassObject __RPC_FAR *pLogicalConsumer,
        /* [in] */ long lNumObjects,
        /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\eventconsshell\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework, adapted for the NT perf counter sample
//
//  This module contains nothing specific to the NT perf counter provider
//  except what is defined in the section bracketed by the CLSID SPECIFIC
//  comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>

#include <evcons.h>


// {4916157B-FBE7-11d1-AEC4-00C04FB68820}
DEFINE_GUID(CLSID_MyEventConsumer, 
0x4916157b, 0xfbe7, 0x11d1, 0xae, 0xc4, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_MyEventConsumer
#define SERVER_REGISTRY_COMMENT     L"WBEM Test Consumer"
#define CPP_CLASS_NAME              CMyEventConsumer
#define INTERFACE_CAST              (IWbemProviderInit *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\eventprovshell\evprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  EVPROV.H
//
//  Sample event provider.
//
//  raymcc      14-Aug-97
//
//***************************************************************************

#ifndef _EVPROV_H_
#define _EVPROV_H_


#define EVENTCLASS  L"MyEvent"


class CMyEventProvider : public IWbemEventProvider, public IWbemProviderInit
{
    ULONG               m_cRef;
    IWbemServices       *m_pNs;
    IWbemObjectSink     *m_pSink;
    IWbemClassObject    *m_pEventClassDef;
    int                 m_eStatus;
    HANDLE              m_hThread;
            
    static DWORD WINAPI EventThread(LPVOID pArg);
    void InstanceThread();

public:
    enum { Pending, Running, PendingStop, Stopped };

    CMyEventProvider();
   ~CMyEventProvider();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // Inherited from IWbemEventProvider
    // =================================

    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags
            );

    // Inherited from IWbemProviderInit
    // ================================

    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\heaptrak\alloctrk.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __WMI_ALLOC_TRACK__H_
#define __WMI_ALLOC_TRACK__H_

void POLARITY StartTrackingAllocations();
void POLARITY StopTrackingAllocations();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\heaptrak\hookheap.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>

#include <arena.h>
#include <hookheap.h>

#define HOOK_CALLOUT_SIZE 6
#define HEAP_ALLOC_REPLACED_LENGTH 7
#define HEAP_FREE_REPLACED_LENGTH 7
#define HEAP_REALLOC_REPLACED_LENGTH 6


void* g_pHeapAllocCont = NULL;
void* g_pHeapFreeCont = NULL;
void* g_pHeapReallocCont = NULL;

__declspec(naked) void* WINAPI CallRealHeapAlloc(HANDLE hHeap, DWORD dwFlags, 
                                            DWORD dwSize)
{
	__asm
	{
		push ebp
		mov eax,dword ptr [esp+0Ch]
		mov ebp,esp
		jmp [g_pHeapAllocCont]
	}
}

__declspec(naked) BOOL WINAPI CallRealHeapFree(HANDLE hHeap, DWORD dwFlags, void* p)
{
	__asm
	{
		push ebp
		mov edx,dword ptr [esp+10h]
		mov ebp,esp
		jmp [g_pHeapFreeCont]
	}
}

__declspec(naked) void* WINAPI CallRealHeapRealloc(HANDLE hHeap, DWORD dwFlags, 
												void* p, DWORD dwBytes)
{
	__asm
	{
		mov eax, fs:[00000000]
		jmp [g_pHeapReallocCont]
	}
}


void* g_pHeapFreeHookWrapper = NULL;
void* g_pHeapAllocHookWrapper = NULL;
void* g_pHeapReallocHookWrapper = NULL;

BOOL HookProc(void* fpProcToHook, void** pfpHookProcWrapper)
{
	DWORD dw;
	BYTE pbHookCode[HOOK_CALLOUT_SIZE];
	pbHookCode[0] = 0xff;
	pbHookCode[1] = 0x25;
	*(DWORD*)(pbHookCode+2) = (DWORD)pfpHookProcWrapper;
	return WriteProcessMemory(GetCurrentProcess(), fpProcToHook, pbHookCode, 
                    HOOK_CALLOUT_SIZE, &dw);
}

void HookHeap(void* pHeapAllocHook, void* pHeapFreeHook, void* pHeapReallocHook)
{
	g_pHeapAllocHookWrapper = pHeapAllocHook;
	g_pHeapFreeHookWrapper = pHeapFreeHook;
	g_pHeapReallocHookWrapper = pHeapReallocHook;
	g_pHeapAllocCont = (char*)HeapAlloc + HEAP_ALLOC_REPLACED_LENGTH;
	g_pHeapFreeCont = (char*)HeapFree + HEAP_FREE_REPLACED_LENGTH;
	g_pHeapReallocCont = (char*)HeapReAlloc + HEAP_REALLOC_REPLACED_LENGTH;
	HookProc(HeapAlloc, &g_pHeapAllocHookWrapper);
	HookProc(HeapFree, &g_pHeapFreeHookWrapper);
	HookProc(HeapReAlloc, &g_pHeapReallocHookWrapper);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\eventprovshell\evprov.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  EVPROV
//
//  Sample event provider.
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>

#include <wbemidl.h>

#include "oahelp.inl"
#include "evprov.h"


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::CMyEventProvider()
{
    m_pNs = 0;
    m_pSink = 0;
    m_cRef = 0;
    m_pEventClassDef = 0;
    m_eStatus = Pending;
    m_hThread = 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::~CMyEventProvider()
{
    if (m_hThread)
        CloseHandle(m_hThread);

    if (m_pNs)
        m_pNs->Release();

    if (m_pSink)
        m_pSink->Release();

    if (m_pEventClassDef)
        m_pEventClassDef->Release();        
}


//***************************************************************************
//
//***************************************************************************
// ok

STDMETHODIMP CMyEventProvider::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemEventProvider==riid)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::AddRef()
{
    return ++m_cRef;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    // If here, we are shutting down.
    // ==============================

    m_eStatus = PendingStop;

    return 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

HRESULT CMyEventProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags
    )
{
    // Copy the sink.
    // ==============
    
    m_pSink = pSink;
    m_pSink->AddRef();

    // Create the event thread.
    // ========================
    
    DWORD dwTID;
    
    m_hThread = CreateThread(
        0,
        0,
        CMyEventProvider::EventThread,
        this,
        0,
        &dwTID
        );


    // Wait for provider to be 'ready'.
    // ================================
    
    while (m_eStatus != Running)
        Sleep(100);

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//  This particular provider, being in a DLL operates via its own thread.  
//
//  In practice, such a provider would probably be implemented within a 
//  separate EXE.
//
//***************************************************************************
// ok

DWORD WINAPI CMyEventProvider::EventThread(LPVOID pArg)
{
    // Make transition to the per-instance method.
    // ===========================================
    
    ((CMyEventProvider *)pArg)->InstanceThread();
    return 0;
}

//***************************************************************************
//
//  Events are generated from here
//
//***************************************************************************
// ok

void CMyEventProvider::InstanceThread()
{
    int nIteration = 0;

    m_eStatus = Running;
        
    while (m_eStatus == Running)
    {
        Sleep(2000);    // Provide an event every two seconds
        
        
        // Generate a new event object.
        // ============================
        
        IWbemClassObject *pEvt = 0;

        HRESULT hRes = m_pEventClassDef->SpawnInstance(0, &pEvt);
        if (hRes != 0)
            continue;   // Failed
            

        // Generate some values to put in the event.
        // =========================================
                
        wchar_t Buf[128];
        swprintf(Buf, L"Test Event <%d>", nIteration);
 
        CVARIANT vName(Buf);
        pEvt->Put(CBSTR(L"Name"), 0, vName, 0);        

        CVARIANT vCount((LONG) nIteration);
        pEvt->Put(CBSTR(L"Value"), 0, vCount, 0);        

        // Deliver the event to WinMgmt.
        // ============================
        
        hRes = m_pSink->Indicate(1, &pEvt);
        
        if (hRes)
        {
            // If here, delivery failed.  Do something to report it.
        }

        pEvt->Release();                    
        nIteration++;
    }

    // When we get to here, we are no longer interested in the
    // provider and Release() has long since returned.
    
    m_eStatus = Stopped;
    delete this;
}





//***************************************************************************
//
//***************************************************************************

    // Inherited from IWbemProviderInit
    // ================================

HRESULT CMyEventProvider::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            )
{
    // We don't care about most of the incoming parameters in this
    // simple sample.  However, we will save the namespace pointer
    // and get our event class definition.
    // ===========================================================

    m_pNs = pNamespace;
    m_pNs->AddRef();    

    // Grab the class definition for the event.
    // ======================================
    
    IWbemClassObject *pObj = 0;

    HRESULT hRes = m_pNs->GetObject(
        CBSTR(EVENTCLASS),          
        0,                          
        pCtx,  
        &pObj,
        0
        );

    if (hRes != 0)
        return WBEM_E_FAILED;

    m_pEventClassDef = pObj;

    // Tell WinMgmt that we're up and running.
    // =====================================

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);
    
    return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\eventprovshell\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework, adapted for the NT perf counter sample
//
//  This module contains nothing specific to the NT perf counter provider
//  except what is defined in the section bracketed by the CLSID SPECIFIC
//  comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>

#include <evprov.h>


// {4916157A-FBE7-11d1-AEC4-00C04FB68820}
DEFINE_GUID(CLSID_MyEventProvider, 
0x4916157a, 0xfbe7, 0x11d1, 0xae, 0xc4, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_MyEventProvider
#define SERVER_REGISTRY_COMMENT     L"WBEM Test Provider"
#define CPP_CLASS_NAME              CMyEventProvider
#define INTERFACE_CAST              (IWbemProviderInit *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\heaptrak\hookheap.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

void* WINAPI CallRealHeapAlloc(HANDLE hHeap, DWORD dwFlags, DWORD dwSize);
BOOL WINAPI CallRealHeapFree(HANDLE hHeap, DWORD dwFlags, void* p);
void* WINAPI CallRealHeapRealloc(HANDLE hHeap, DWORD dwFlags, void* p, 
								 DWORD dwBytes);

void HookHeap(void* pHeapAllocHook, void* pHeapFreeHook, 
			  void* pHeapReallocHook);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\heaptrak\alloctrk.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  ALLOCTRK.CPP
//
//***************************************************************************

#pragma warning(disable: 4786)

#include <windows.h>
#include <stdio.h>
#include "arena.h"
#include "sync.h"

#include "flexarry.h"
#include <time.h>
#include <stdio.h>
#include <arrtempl.h>
#include <sync.h>
#include <malloc.h>
#include <imagehlp.h>
#include <map>

#include "stackcom.h"
#include "hookheap.h"

#include "alloctrk.h"

void* WINAPI HeapAllocHook(HANDLE hHeap, DWORD dwFlags, DWORD dwSize);
BOOL WINAPI HeapFreeHook(HANDLE hHeap, DWORD dwFlags, void* pBlock);
void* WINAPI HeapReallocHook(HANDLE hHeap, DWORD dwFlags, void* pBlock,
							 DWORD dwNewSize);

#define NUM_IGNORE_STACK_FRAMES 3
#define MAX_SYMBOL_NAME_LEN 1024


#pragma warning(disable: 4786)
class CAllocationTracker
{
protected:
	typedef std::map<PStackRecord, PAllocRecord, CStackRecord::CLess> 
        TMapByStack;
	typedef TMapByStack::iterator TByStackIterator;
	TMapByStack m_mapByStack;

	typedef std::map<void*, PAllocRecord> TMapByPointer;
	typedef TMapByPointer::iterator TByPointerIterator;
	TMapByPointer m_mapByPointer;

    CCritSec m_cs;
	DWORD m_dwTotalInternal;
	DWORD m_dwCurrentThread;
	DWORD m_dwCurrentId;
	HANDLE m_hThread;
	DWORD m_dwTotalExternal;
    DWORD m_dwTls;

protected:
	void RecordInternalAlloc(DWORD dwSize) { m_dwTotalInternal += dwSize;}
	void RecordInternalFree(DWORD dwSize) {m_dwTotalInternal -= dwSize;}

    CAllocRecord* FindRecord(CStackRecord& Stack);
	CAllocRecord* FindRecord(void* p);
    static DWORD DumpThread(void* p);

    void DumpStatistics();
    void InnerDumpStatistics(FILE* f);

public:
    CAllocationTracker();
	~CAllocationTracker();
    void RecordAllocation(void* p, DWORD dwAlloc);
    void RecordDeallocation(void* p, DWORD dwAlloc);
    void RecordReallocation(void* pOld, DWORD dwOldSize, void* pNew, 
                                DWORD dwNewSize);

	static BOOL IsValidId(CAllocationId Id);
    void Start();
    void Stop();

    BOOL StartInternal();
    void EndInternal();
};

CAllocationTracker g_Tracker;
#pragma warning(disable: 4786)

void POLARITY StartTrackingAllocations()
{
    g_Tracker.Start();
}

void POLARITY StopTrackingAllocations()
{
    g_Tracker.Stop();
}

CAllocationTracker::CAllocationTracker() 
		: m_dwTotalInternal(0), m_dwCurrentThread(0), m_dwCurrentId(0x80000000)
{
    m_dwTls = TlsAlloc();
    m_hThread = NULL;
}

void CAllocationTracker::Start()
{
    DWORD dwId;
	SymInitialize(GetCurrentProcess(), "c:\\winnt\\symbols\\dll;c:\\winnt\\system32\\wbem", TRUE);
    m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&DumpThread, this, 0, &dwId);
    HookHeap(HeapAllocHook, HeapFreeHook, HeapReallocHook);
}

void CAllocationTracker::Stop()
{
	TerminateThread(m_hThread, 0);
	CloseHandle(m_hThread);
    m_hThread = NULL;
}
    

BOOL CAllocationTracker::IsValidId(CAllocationId Id)
{
	return (Id == 0 || (Id & 0x80000000));
}

CAllocationTracker::~CAllocationTracker()
{
    TlsFree(m_dwTls);
}

BOOL CAllocationTracker::StartInternal()
{
    if(TlsGetValue(m_dwTls))
        return FALSE;
    else
    {
        TlsSetValue(m_dwTls, (void*)1);
        return TRUE;
    }
}

void CAllocationTracker::EndInternal()
{
    TlsSetValue(m_dwTls, NULL);
}

void CAllocationTracker::RecordAllocation(void* p, DWORD dwAlloc)
{
    if(m_hThread == NULL)
        return;

    if(!StartInternal())
    {
		RecordInternalAlloc(dwAlloc);
		return;
	}

	_Lockit l;
	m_dwTotalExternal += dwAlloc;

	CStackRecord Stack;
	Stack.Create(NUM_IGNORE_STACK_FRAMES, TRUE);

    CAllocRecord* pRecord = FindRecord(Stack);
	if(pRecord == NULL)
    {
        pRecord = new CAllocRecord(Stack);
		//m_setRecords.insert(pRecord);
		m_mapByStack[&pRecord->m_Stack] = pRecord;
    }

    pRecord->AddAlloc(p, dwAlloc);
    m_mapByPointer[p] = pRecord;
    EndInternal();
}

void CAllocationTracker::RecordReallocation(void* pOld, DWORD dwOldSize, 
                        void* pNew, DWORD dwNewSize)
{
    RecordDeallocation(pOld, dwOldSize);
    RecordAllocation(pNew, dwNewSize);
}

void CAllocationTracker::RecordDeallocation(void* p, DWORD dwAlloc)
{
    if(m_hThread == NULL)
        return;

    if(!StartInternal())
    {
		RecordInternalFree(dwAlloc);
		return;
	}

	_Lockit l;
    //CInCritSec ics(&m_cs);
    TlsSetValue(m_dwTls, (void*)1);
	m_dwTotalExternal -= dwAlloc;

	CAllocRecord* pRecord = FindRecord(p);
	if(pRecord == NULL)
	{
		// DebugBreak();
        EndInternal();
		return;
	}

    pRecord->RemoveAlloc(p, dwAlloc);

	if(pRecord->IsEmpty())
	{
		m_mapByStack.erase(&pRecord->m_Stack);
		m_mapByPointer.erase(p);
		//m_setRecords.erase(pRecord);
		delete pRecord;
	}

    EndInternal();
}
        


CAllocRecord* CAllocationTracker::FindRecord(CStackRecord& Stack)
{
	TByStackIterator it = m_mapByStack.find(&Stack);
	if(it == m_mapByStack.end())
		return NULL;
	else
		return it->second;
}
	
CAllocRecord* CAllocationTracker::FindRecord(void* p)
{
	TByPointerIterator it = m_mapByPointer.find(p);
	if(it == m_mapByPointer.end())
		return NULL;
	else
		return it->second;
}

void CAllocationTracker::DumpStatistics()
{
    _Lockit l;
    FILE* f = fopen("c:\\memdump.bin", "wb");

    fwrite(&m_dwTotalInternal, sizeof(DWORD), 1, f);

    StartInternal();
    InnerDumpStatistics(f);
    EndInternal();
    fclose(f);
}

void CAllocationTracker::InnerDumpStatistics(FILE* f)
{
	SymInitialize(GetCurrentProcess(), "c:\\winnt\\symbols\\dll;c:\\winnt\\system32\\wbem", TRUE);

	TByStackIterator it;
    for(it = m_mapByStack.begin(); it != m_mapByStack.end(); it++)
    {
        const CAllocRecord* pRecord = it->second;
		if(!pRecord->IsEmpty())
			pRecord->Dump(f);
	}
	DWORD dwZero = 0;
	fwrite(&dwZero, sizeof(DWORD), 1, f);

	std::map<DWORD, char> mapAddresses;
    for(it = m_mapByStack.begin(); it != m_mapByStack.end(); it++)
    {
        const CAllocRecord* pRecord = it->second;
		if(!pRecord->IsEmpty())
		{
			for(int j = 0; j < pRecord->m_Stack.GetNumItems(); j++)
				mapAddresses[(DWORD)pRecord->m_Stack.GetItem(j)] = 0;
		}
		else
		{
			DebugBreak();
		}
	}

	BYTE aBuffer[MAX_SYMBOL_NAME_LEN + sizeof(IMAGEHLP_SYMBOL)];
	IMAGEHLP_SYMBOL* psymbol = (IMAGEHLP_SYMBOL*)aBuffer;
	psymbol->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
	psymbol->MaxNameLength = MAX_SYMBOL_NAME_LEN;

	IMAGEHLP_MODULE module;
	module.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

	char szSymbol[2048];

	for(std::map<DWORD, char>::iterator it1 = mapAddresses.begin(); 
			it1 != mapAddresses.end(); it1++)
	{
		void* p = (void*)it1->first;
		fwrite(&p, sizeof(DWORD), 1, f);

		DWORD dwDisp;
		if(SymGetSymFromAddr(GetCurrentProcess(), (DWORD)p, &dwDisp, psymbol))
		{
			sprintf(szSymbol, "%s+%d(%p) ", psymbol->Name, dwDisp, p);
		}
		else
		{
			if(SymGetModuleInfo(GetCurrentProcess(), (DWORD)p, &module))
			{
				if(SymLoadModule(GetCurrentProcess(), NULL, module.ImageName, module.ModuleName,
					module.BaseOfImage, module.ImageSize))
				{
					if(SymGetSymFromAddr(GetCurrentProcess(), (DWORD)p, &dwDisp, psymbol))
					{
						sprintf(szSymbol, "%s+%d(%p) ", psymbol->Name, dwDisp, p);
					}
					else
					{	
						sprintf(szSymbol, "[%s] (%p) [sym: %d (%d)] ", module.LoadedImageName, p, 
							module.SymType, GetLastError());
					}
				}
				else
				{	
					sprintf(szSymbol, "[%s] (%p) [sym: %d (%d)] ", module.LoadedImageName, p, 
						module.SymType, GetLastError());
				}
			}
			else
			{
				sprintf(szSymbol, "%p (%d)", p, GetLastError());
			}
		}

		DWORD dwLen = strlen(szSymbol);
		fwrite(&dwLen, sizeof(DWORD), 1, f);
		fwrite(szSymbol, 1, dwLen, f);
	}

	SymCleanup(GetCurrentProcess());
}


 
DWORD CAllocationTracker::DumpThread(void* p)
{
    CAllocationTracker* pThis = (CAllocationTracker*)p;

	char szEvent[100];
	sprintf(szEvent, "Dump Memory Event %d", GetCurrentProcessId());
    HANDLE hEvent = CreateEventA(NULL, FALSE, FALSE, szEvent);

	sprintf(szEvent, "Dump Memory Done Event %d", GetCurrentProcessId());
    HANDLE hEventDone = CreateEventA(NULL, FALSE, FALSE, szEvent);
    while(1)
    {
        WaitForSingleObject(hEvent, INFINITE);
        pThis->DumpStatistics();
		SetEvent(hEventDone);
    }
    return 0;
}
    

void* WINAPI HeapAllocHook(HANDLE hHeap, DWORD dwFlags, DWORD dwSize)
{
    void* pBuffer = CallRealHeapAlloc(hHeap, dwFlags, dwSize);
    
    if(pBuffer)
    {
		g_Tracker.RecordAllocation(pBuffer, dwSize);
    }
    
	
	return pBuffer;
}

BOOL WINAPI HeapFreeHook(HANDLE hHeap, DWORD dwFlags, void* pBlock)
{
    
	if(pBlock == NULL)
		return TRUE;

    g_Tracker.RecordDeallocation(pBlock,
			HeapSize(hHeap, 0, pBlock));

    return CallRealHeapFree(hHeap, dwFlags, pBlock);
}
    
void* WINAPI HeapReallocHook(HANDLE hHeap, DWORD dwFlags, void* pBlock,
							 DWORD dwNewSize)
{
    BOOL bStarted = g_Tracker.StartInternal();

    DWORD dwPrevSize = HeapSize(hHeap, 0, pBlock);
    void* pNewBlock = CallRealHeapRealloc(hHeap, dwFlags, pBlock, dwNewSize);
    
    if(pNewBlock == NULL)
        return NULL;

    if(bStarted)
        g_Tracker.EndInternal();
    g_Tracker.RecordReallocation(pBlock, dwPrevSize, pNewBlock, dwNewSize);
    
    return pNewBlock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\heaptrak\analyzer\main.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>

#ifdef _MT
  #undef _MT
  #include <yvals.h>
  #define _MT
#endif

#include "arena.h"
#include "sync.h"
#include "flexarry.h"
#include <time.h>
#include <stdio.h>
#include <arrtempl.h>
#include <sync.h>
#include <malloc.h>
#include <imagehlp.h>
#include <stackcom.h>
#include <wstring.h>
#include <arrtempl.h>

typedef std::map<DWORD, WString> TSymbolMap;
TSymbolMap g_mapSymbols;

struct CSubAllocRecord : public CAllocRecord
{
	CPointerArray<CSubAllocRecord> m_apCallers;

	CSubAllocRecord(){}
	CSubAllocRecord(CStackRecord& Stack) : CAllocRecord(Stack){}

	void AddCaller(CSubAllocRecord* p);
	void AddAlloc(DWORD dwAlloc, DWORD dwNumAlloc)
	{
		m_dwTotalAlloc += dwAlloc;
		m_dwNumTimes += dwNumAlloc;
	}
    void AddBuffer(void *p)
    {
        m_apBuffers.Add(p);
    }
	void Print(int nIndent, TSymbolMap& Symbols, int nLevels = 100000);
    void PrintBuffers();

	static int __cdecl CompareRecords(const void* p1, const void* p2);
};

typedef std::map<PStackRecord, PAllocRecord, CStackRecord::CLess> TByStackMap;
TByStackMap g_mapSubRecords;
CSubAllocRecord* g_pRootRecord = NULL;

void CSubAllocRecord::AddCaller(CSubAllocRecord* p)
{
	for(int i = 0; i < m_apCallers.GetSize(); i++)
	{
		if(m_apCallers[i] == p)
			return;
	}
	m_apCallers.Add(p);
}


void CSubAllocRecord::Print(int nIndent, TSymbolMap& Symbols, int nLevels)
{
	if(m_dwTotalAlloc)
	{
		char* szIndent = (char*)_alloca(nIndent+1);
		memset(szIndent, ' ', nIndent);
		szIndent[nIndent] = 0;
		printf("%s[%p]: %d in %d at %S\n", szIndent, this, m_dwTotalAlloc, m_dwNumTimes,
			(LPCWSTR)Symbols[(DWORD)m_Stack.GetItem(m_Stack.GetNumItems()-1)]);
	}

	if(nLevels > 0 && m_apCallers.GetSize() > 0)
	{
		qsort(m_apCallers.GetArrayPtr(), m_apCallers.GetSize(), sizeof(void*), 
			CompareRecords);
		for(int i = 0; i < m_apCallers.GetSize(); i++)
		{
			m_apCallers[i]->Print(nIndent+1, Symbols, nLevels-1);
		}
	}
}

void CSubAllocRecord::PrintBuffers()
{
    m_apBuffers.Sort();
    for(int i = 0; i < m_apBuffers.Size(); i++)
        printf("%p ", m_apBuffers[i]);
    printf("\n");
}

int __cdecl CSubAllocRecord::CompareRecords(const void* p1, const void* p2)
{
	CSubAllocRecord* pRecord1 = *(CSubAllocRecord**)p1;
	CSubAllocRecord* pRecord2 = *(CSubAllocRecord**)p2;

	return pRecord2->m_dwTotalAlloc - pRecord1->m_dwTotalAlloc;
}
   


void Dump()
{
	int nPid;
    char ch;
	scanf("%d%c", &nPid, &ch);

    char szFileName[1000];
    if(ch == ' ')
        scanf("%s", szFileName);
    else
        szFileName[0] = 0;
			
    char szEvent[100];
    sprintf(szEvent, "Dump Memory Event %d", nPid);
    HANDLE hEvent = CreateEventA(NULL, FALSE, FALSE, szEvent);

    sprintf(szEvent, "Dump Memory Done Event %d", nPid);
    HANDLE hEvent2 = CreateEventA(NULL, FALSE, FALSE, szEvent);
    SetEvent(hEvent);
    CloseHandle(hEvent);
	WaitForSingleObject(hEvent2, INFINITE);
	CloseHandle(hEvent2);

    if(szFileName[0] != 0)
    {
        if(!MoveFileEx("c:\\memdump.bin", szFileName,
            MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING))
        {
            printf("Failed to rename!\n");
        }
    }
}

BOOL Read(LPCSTR szFileName, TSymbolMap& mapSymbols, TByStackMap& mapRecords)
{
    FILE* f = fopen(szFileName, "rb");
    if(f == NULL)
    {
        printf("File %s not found\n", szFileName);
        return FALSE;
    }

    DWORD dwTotalInternal;
    fread(&dwTotalInternal, sizeof(DWORD), 1, f);

    DWORD dwTotalAlloc;
	while(fread(&dwTotalAlloc, sizeof(DWORD), 1, f) && dwTotalAlloc)
	{
        CSubAllocRecord* pRecord = new CSubAllocRecord;

		DWORD dwNumAlloc;
		fread(&dwNumAlloc, sizeof(DWORD), 1, f);
		pRecord->AddAlloc(dwTotalAlloc, dwNumAlloc);

		pRecord->m_Stack.Read(f, FALSE);

        DWORD dwNumBuffers;
		fread(&dwNumBuffers, sizeof(DWORD), 1, f);
        for(int b = 0; b < dwNumBuffers; b++)
        {
            void* p;
            fread(&p, sizeof(void*), 1, f);
            pRecord->m_apBuffers.Add(p);
        }

        mapRecords[&pRecord->m_Stack] = pRecord;
    }

	void* p = NULL;
	char szSymbol[1000];
	while(fread(&p, sizeof(void*), 1, f))
	{
		DWORD dwLen;
		fread(&dwLen, sizeof(DWORD), 1, f);
		fread(szSymbol, 1, dwLen, f);
		szSymbol[dwLen] = 0;
		mapSymbols[(DWORD)p] = WString(szSymbol);
	}

    fclose(f);

    return TRUE;
}
    

        
    

void Diff()
{
    char szFileName1[1000], szFileName2[1000], szFileName3[1000];
    scanf("%s%s%s", szFileName1, szFileName2, szFileName3);

    TSymbolMap mapSymbols1;
    TByStackMap mapRecords1;
    if(!Read(szFileName1, mapSymbols1, mapRecords1))
        return;

    TSymbolMap mapSymbols2;
    TByStackMap mapRecords2;
    if(!Read(szFileName2, mapSymbols2, mapRecords2))
        return;

    TByStackMap::iterator it;
    for(it = mapRecords1.begin(); it != mapRecords1.end(); it++)
    {
        TByStackMap::iterator it2 = mapRecords2.find(it->first);
        if(it2 == mapRecords2.end())
            continue;

        it2->second->Subtract(*it->second);
    }

    FILE* f = fopen(szFileName3, "wb");
    DWORD dwInternal = 0;
    fwrite(&dwInternal, sizeof(DWORD), 1, f);

    for(it = mapRecords2.begin(); it != mapRecords2.end(); it++)
    {
        if(!it->second->IsEmpty())
            it->second->Dump(f);
    }

    dwInternal = 0;
    fwrite(&dwInternal, sizeof(DWORD), 1, f);

    for(TSymbolMap::iterator its = mapSymbols2.begin(); 
            its != mapSymbols2.end(); its++)
    {
		void* p = (void*)its->first;
		fwrite(&p, sizeof(DWORD), 1, f);

        char* szSymbol = its->second.GetLPSTR();
		DWORD dwLen = strlen(szSymbol);
		fwrite(&dwLen, sizeof(DWORD), 1, f);
		fwrite(szSymbol, 1, dwLen, f);
    }

    fclose(f);
}
    
    

    
    
    
    
    

void Open()
{
	char szFileName[1000];
    *szFileName = 0;
	char ch = getchar();
    if(ch == ' ')
	    gets(szFileName);

	if(*szFileName == 0)
		strcpy(szFileName, "c:\\memdump.bin");

	FILE* f = fopen(szFileName, "rb");
	if(f == NULL)
	{
		printf("File '%s' not found\n", szFileName);
		return;
	}

    DWORD dwTotalInternal;
    fread(&dwTotalInternal, sizeof(DWORD), 1, f);

	g_mapSymbols.clear();
	g_mapSubRecords.clear();
	delete g_pRootRecord;
	g_pRootRecord = new CSubAllocRecord;

	DWORD dwGrandTotal = 0, dwGrandNumAlloc = 0;

	DWORD dwTotalAlloc = 0;
	while(fread(&dwTotalAlloc, sizeof(DWORD), 1, f) && dwTotalAlloc)
	{
		dwGrandTotal += dwTotalAlloc;
		dwGrandNumAlloc++;

		DWORD dwNumAlloc;
		fread(&dwNumAlloc, sizeof(DWORD), 1, f);
		CStackRecord Stack;
		Stack.Read(f, TRUE);

        DWORD dwNumBuffers;
		fread(&dwNumBuffers, sizeof(DWORD), 1, f);
        CFlexArray apBuffers;
        for(int b = 0; b < dwNumBuffers; b++)
        {
            void* p;
            fread(&p, sizeof(void*), 1, f);
            apBuffers.Add(p);
        }

		CSubAllocRecord* pPrevRecord = g_pRootRecord;
		for(int j = 1; j <= Stack.GetNumItems(); j++)
		{
			CStackRecord SubStack(Stack, j);

			std::map<PStackRecord, PAllocRecord, CStackRecord::CLess>::iterator it = 
				g_mapSubRecords.find(&SubStack);
			CSubAllocRecord* pSubRecord = NULL;
			if(it == g_mapSubRecords.end())
			{
				pSubRecord = new CSubAllocRecord(SubStack);
				g_mapSubRecords[&pSubRecord->m_Stack] = pSubRecord;
			}
			else	
			{
				pSubRecord = (CSubAllocRecord*)(CAllocRecord*)it->second;
			}

			pSubRecord->AddAlloc(dwTotalAlloc, dwNumAlloc);

            for(int b = 0; b < dwNumBuffers; b++)
                pSubRecord->AddBuffer(apBuffers[b]);

			if(pPrevRecord)
				pPrevRecord->AddCaller(pSubRecord);
			pPrevRecord = pSubRecord;
		}
	}

	DWORD dwNumSymbols = 0;
	void* p = NULL;
	char szSymbol[1000];
	while(fread(&p, sizeof(void*), 1, f))
	{
		dwNumSymbols++;
		DWORD dwLen;
		fread(&dwLen, sizeof(DWORD), 1, f);
		fread(szSymbol, 1, dwLen, f);
		szSymbol[dwLen] = 0;
		g_mapSymbols[(DWORD)p] = WString(szSymbol);
	}

    fclose(f);

	printf("%d overhead, %d bytes in %d blocks.  %d symbols\n", 
        dwTotalInternal, dwGrandTotal, dwGrandNumAlloc, dwNumSymbols);
}

void Print()
{
	if(g_pRootRecord)
		g_pRootRecord->Print(0, g_mapSymbols);
	else
	{
		printf("No dump opened\n");
	}
}

void Expand(CSubAllocRecord* pRecord = NULL)
{
    if(pRecord == NULL)
    {
	    scanf("%p", &pRecord);
    }

	char ch;
	scanf("%c", &ch);
	int nLevels = 1;
	if(ch == ' ')
		scanf("%d%*c", &nLevels);
	pRecord->Print(0, g_mapSymbols, nLevels);
}

void Buffers()
{
    CSubAllocRecord* pRecord;
    scanf("%p", &pRecord);

    pRecord->PrintBuffers();
}

void Top()
{
	char ch;
	scanf("%c", &ch);
	int nLevels = 1;
	if(ch == ' ')
		scanf("%d%*c", &nLevels);
	g_pRootRecord->Print(0, g_mapSymbols, nLevels);
}

void main(int argc, char** argv)
{
    BOOL bRes;
    char szCommand[1000];
    CSubAllocRecord* p;
	while(1)
	{
		printf("> ");
		scanf("%s", szCommand);

		try
		{
			if(!strcmp(szCommand, "dump"))
				Dump();
			else if(!strcmp(szCommand, "quit") || !strcmp(szCommand, "exit"))
				break;
			else if(!strcmp(szCommand, "open"))
				Open();
			else if(!strcmp(szCommand, "print"))
				Print();
			else if(!strcmp(szCommand, "expand"))
				Expand();
			else if(!strcmp(szCommand, "buffers"))
				Buffers();
			else if(!strcmp(szCommand, "diff"))
				Diff();
			else if(!strcmp(szCommand, "top"))
				Top();
            else if(sscanf(szCommand, "%p", &p) == 1)
                Expand(p);
			else
				printf("Invalid command\n");
		}
		catch(...)
		{
			printf("recovered!\n");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\heaptrak\stackcom.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __WBEM_STACK_COM__H_
#define __WBEM_STACK_COM__H_

template<class T>
struct Ptr
{
	T* m_p;
	Ptr(T* p) : m_p(p){}
	Ptr() : m_p(NULL){}
	Ptr(const Ptr<T>& Other) :m_p(Other.m_p){}
	operator T*() {return m_p;}
	operator const T*() const {return m_p;}
	T* operator->() {return m_p;}
	const T* operator->() const {return m_p;}
	bool operator<(const Ptr<T>& Other) const {return m_p < Other.m_p;}
};

typedef DWORD CAllocationId;

struct POLARITY CStackRecord
{
    DWORD m_dwNumItems;
    void** m_apReturns;
	BOOL m_bDelete;

	static void* mstatic_apReturns[1000];

public:
	CStackRecord() : m_dwNumItems(0), m_apReturns(NULL), m_bDelete(FALSE){}
	CStackRecord(CStackRecord& Parent, DWORD dwNumItems) : 
		m_dwNumItems(dwNumItems), m_apReturns(Parent.m_apReturns), 
		m_bDelete(FALSE)
	{}
	DWORD GetNumItems() const {return m_dwNumItems;}
	void* GetItem(int nIndex) const {return m_apReturns[nIndex];}
	void** GetItems() {return m_apReturns;}
	void** const GetItems() const {return m_apReturns;}

	~CStackRecord();
	void Create(int nIgnore, BOOL bStatic);
	void MakeCopy(CStackRecord& Other);

	int Compare(const CStackRecord& Other) const;
	BOOL operator==(const CStackRecord& Other) const
		{return Compare(Other) == 0;}

	static DWORD GetStackLen();
	static void ReadStack(int nIgnore, void** apBuffer);
	void Dump(FILE* f) const;
	BOOL Read(FILE* f, BOOL bStatid);
	DWORD GetInternal() {return sizeof(void*) * m_dwNumItems;}

public:
	class CLess
	{
	public:
		bool operator()(const CStackRecord* p1, const CStackRecord* p2) const
		{
			return p1->Compare(*p2) < 0;
		}
	};
};

struct POLARITY CAllocRecord
{
	CStackRecord m_Stack;
    DWORD m_dwTotalAlloc;
	DWORD m_dwNumTimes;
    CFlexArray m_apBuffers;

	CAllocRecord() : m_dwTotalAlloc(0), m_dwNumTimes(0){}
    CAllocRecord(CStackRecord& Stack) : m_dwTotalAlloc(0), m_dwNumTimes(0)
    {
		m_Stack.MakeCopy(Stack);
	}

    void AddAlloc(void* p, DWORD dwAlloc) 
        {m_dwTotalAlloc += dwAlloc; m_dwNumTimes++; m_apBuffers.Add(p);}
    void RemoveAlloc(void* p, DWORD dwAlloc) 
        {m_dwTotalAlloc -= dwAlloc; m_dwNumTimes--; RemoveBuffer(p);}
    void ReduceAlloc(DWORD dwAlloc) {m_dwTotalAlloc -= dwAlloc;}
	void Dump(FILE* f) const;
	DWORD GetInternal() {return sizeof(CAllocRecord) + m_Stack.GetInternal();}
	BOOL IsEmpty() const {return (m_dwTotalAlloc == 0);}

    void RemoveBuffer(void* p)
    {
        for(int i = 0; i < m_apBuffers.Size(); i++)
            if(m_apBuffers[i] == p) {m_apBuffers.RemoveAt(i); return;}
    }

    void Subtract(CAllocRecord& Other);
};

typedef Ptr<CAllocRecord> PAllocRecord;
typedef Ptr<CStackRecord> PStackRecord;

class POLARITY CTls
{
protected:
    DWORD m_dwIndex;
public:
    CTls() {m_dwIndex = TlsAlloc();}
    ~CTls() {TlsFree(m_dwIndex);}
    operator void*() {return (m_dwIndex)?TlsGetValue(m_dwIndex):NULL;}
    void operator=(void* p) {if(m_dwIndex)TlsSetValue(m_dwIndex, p);}
};

struct POLARITY CStackContinuation
{
    CStackRecord* m_pPrevStack;
    void* m_pThisStackEnd;

    static CTls mtls_CurrentCont;

public:
    static CStackContinuation* Set(CStackContinuation* pNew);
    static CStackContinuation* Get();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\agents.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	StressOps.h
//
//////////////////////////////////////////////////////////////////////

#ifndef _STRESSOPS_H_
#define _STRESSOPS_H_

class CBasicRefreshAgent
{
public:
	CRefresher	*m_pRef;			// The refresher to stress
	DWORD		m_dwIterations;		// Total number of cycles	
	DWORD		m_dwPeriod;			// Wait between cycles
	HANDLE		m_hThread;			// Stress thread
	HANDLE		m_hRefreshEvent;
	BOOL		m_bInfinite;

	static DWORD WINAPI StressThreadEntry(LPVOID lpParameter);
	virtual void StressLoop();

public:
	CBasicRefreshAgent();
	virtual ~CBasicRefreshAgent();

	BOOL Create(CRefresher *pRef, DWORD dwIterations, DWORD dwPeriod, HANDLE hRefreshEvent);
	void BeginStress();
};

#define MAX_INST 100
#define MIN_INST 50

class CRandomOpRefreshAgent : public CBasicRefreshAgent
{
	HANDLE	m_hThreadAddRefs;
	HANDLE	m_hThreadRemoveRefs;

	virtual void StressLoop();

	static DWORD WINAPI AddRefThreadEntry(LPVOID lpParameter);
	static DWORD WINAPI RemRefThreadEntry(LPVOID lpParameter);

public:
	BOOL Create(CRefresher *pRef, DWORD dwPeriod);
	void BeginStress();
};

#endif // _STRESSOPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\heaptrak\stackcom.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>


#ifdef _MT
  #undef _MT
  #include <yvals.h>
  #define _MT
#endif

#include <arena.h>

#include <sync.h>
#include <flexarry.h>
#include <time.h>
#include <stdio.h>
#include <arrtempl.h>
#include <sync.h>
#include <malloc.h>
#include <imagehlp.h>
#include <execq.h>
#include "stackcom.h"

void* CStackRecord::mstatic_apReturns[1000];

void CStackRecord::Create(int nIgnore, BOOL bStatic)
{
	m_dwNumItems = GetStackLen() - nIgnore;
	if(bStatic)
	{
		m_apReturns = (void**)mstatic_apReturns;
		m_bDelete = FALSE;
	}
	else
	{
		m_apReturns = new void*[m_dwNumItems];
		m_bDelete = TRUE;
	}

	ReadStack(nIgnore, m_apReturns);
}

CStackRecord::~CStackRecord() 
{
	if(m_bDelete)
		delete m_apReturns;
}

void CStackRecord::MakeCopy(CStackRecord& Other)
{
	m_dwNumItems = Other.GetNumItems();
	DWORD dwLen = Other.GetNumItems() * sizeof(void*);
	m_apReturns = new void*[Other.GetNumItems()];
	memcpy(m_apReturns, Other.GetItems(), dwLen);
	m_bDelete = TRUE;
}

int CStackRecord::Compare(const CStackRecord& Other) const
{
	int nDiff = GetNumItems()- Other.GetNumItems();
	if(nDiff)
		return nDiff;

	return memcmp(GetItems(), Other.GetItems(), sizeof(void*) * GetNumItems());
}

DWORD CStackRecord::GetStackLen()
{
    void* pFrame;
    __asm
    {
        mov pFrame, ebp
    }

    CStackContinuation* pPrev = CStackContinuation::Get();
    void* pEnd = NULL;
    if(pPrev)
        pEnd = pPrev->m_pThisStackEnd;

	DWORD dwLen = 0;
    while(!IsBadReadPtr(pFrame, sizeof(DWORD)))
    {
		dwLen++;
        void** ppReturn = (void**)pFrame + 1;
        void* pReturn = *ppReturn;
		if(pReturn == pEnd)
			break;
        void* pNewFrame = *(void**)pFrame;
		if(pNewFrame <= pFrame)
			break;
		pFrame = pNewFrame;
    }

    if(pPrev != NULL)
        dwLen += pPrev->m_pPrevStack->GetNumItems();

	return dwLen;
}

void CStackRecord::ReadStack(int nIgnore, void** apReturns)
{
    void* pFrame;
    __asm
    {
        mov pFrame, ebp
    }

    CStackContinuation* pPrev = CStackContinuation::Get();
	void* pEnd = NULL;
    if(pPrev)
        pEnd = pPrev->m_pThisStackEnd;

    while(!IsBadReadPtr(pFrame, sizeof(DWORD)))
    {
        void** ppReturn = (void**)pFrame + 1;
        void* pReturn = *ppReturn;
		if(pReturn == pEnd)
			break;

		if(nIgnore == 0)
			*(apReturns++) = pReturn;
		else
			nIgnore--;

        void* pNewFrame = *(void**)pFrame;
		if(pNewFrame <= pFrame)
			break;
		pFrame = pNewFrame;
    }

    if(pPrev != NULL)
    {
        memcpy(apReturns, pPrev->m_pPrevStack->m_apReturns, 
                sizeof(void*) * pPrev->m_pPrevStack->GetNumItems());
    }
}

void CStackRecord::Dump(FILE* f) const
{
	fwrite(&m_dwNumItems, sizeof(DWORD), 1, f);
	fwrite(m_apReturns, sizeof(void*), m_dwNumItems, f);
}

BOOL CStackRecord::Read(FILE* f, BOOL bStatic)
{
	if(fread(&m_dwNumItems, sizeof(DWORD), 1, f) == 0)
		return FALSE;

	if(bStatic)
	{
		m_apReturns = (void**)mstatic_apReturns;
		m_bDelete = FALSE;
	}
	else
	{
		m_apReturns = new void*[m_dwNumItems];
		m_bDelete = TRUE;
	}

	return (fread(m_apReturns, sizeof(void*), m_dwNumItems, f) != 0);
}



void CAllocRecord::Dump(FILE* f) const
{
	fwrite(&m_dwTotalAlloc, sizeof(DWORD), 1, f);
	fwrite(&m_dwNumTimes, sizeof(DWORD), 1, f);
	m_Stack.Dump(f);
    DWORD dwNumBuffers = m_apBuffers.Size();
    fwrite(&dwNumBuffers, sizeof(DWORD), 1, f);
    fwrite(m_apBuffers.GetArrayPtr(), sizeof(void*), dwNumBuffers, f);
}

void CAllocRecord::Subtract(CAllocRecord& Other)
{
    m_dwTotalAlloc -= Other.m_dwTotalAlloc;
    m_dwNumTimes -= Other.m_dwNumTimes;
    for(int i = 0; i < m_apBuffers.Size(); i++)
    {
        for(int j = 0; j < Other.m_apBuffers.Size(); j++)
            if(Other.m_apBuffers[j] == m_apBuffers[i])
                break;
        if(j < Other.m_apBuffers.Size())
        {
            m_apBuffers.RemoveAt(i);
            i--;
        }
    }
}

CTls CStackContinuation::mtls_CurrentCont;
CStackContinuation* CStackContinuation::Set(CStackContinuation* pNew)
{
    CStackContinuation* pPrev = (CStackContinuation*)(void*)mtls_CurrentCont;
    mtls_CurrentCont = pNew;
	if(pNew)
	{
		void* p;
		__asm
		{
			mov eax, [ebp]
			mov eax, [eax+4]
			mov p, eax
		}
		pNew->m_pThisStackEnd = p;
	}
    return pPrev;
}
    
CStackContinuation* CStackContinuation::Get()
{
    CStackContinuation* pPrev = (CStackContinuation*)(void*)mtls_CurrentCont;
    return pPrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\hiperstress.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	HiperStress.h
//
//////////////////////////////////////////////////////////////////////

#ifndef _HIPERSTRESS_H_
#define _HIPERSTRESS_H_

#define _WIN32_WINNT    0x0400
#define UNICODE

#define KEY_REFROOT L"Software\\Microsoft\\HiPerStress\\"

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "Locator.h"

extern long g_lRefThreadCount;
extern class CLocator *g_pLocator;


#endif //_HIPERSTRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\locator.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	Locator.cpp
//
//	Created by a-dcrews, Oct. 6, 1998
//
//////////////////////////////////////////////////////////////////////

#include "HiPerStress.h"
#include "Locator.h"


CLocator::CLocator()
{
	m_pLoc = 0;
	m_nNumSvcs = 0;
}

CLocator::~CLocator()
{
	if (m_pLoc)
		m_pLoc->Release();

	for (int i = 0; i < m_nNumSvcs; i++)
		delete m_apServices[i];
}

BOOL CLocator::Create()
{
	DWORD dwRes = CoCreateInstance (CLSID_WbemLocator, 0, 
									CLSCTX_INPROC_SERVER, 
									IID_IWbemLocator, (LPVOID *) &m_pLoc);
	return (SUCCEEDED(dwRes));
}

IWbemServices* CLocator::GetService(WCHAR* wcsNameSpace)
{
	IWbemServices *pSvc = 0;

	// Search the list of server/namespaces to check for existence
	for (int i = 0; i < m_nNumSvcs; i++)
	{
		WCHAR wcsSvcName[1024];
		m_apServices[i]->GetName(wcsSvcName);

		if (!_wcsicmp(wcsNameSpace, wcsSvcName))
		{	
			IWbemServices *pSvc = m_apServices[i]->GetService();
			pSvc->AddRef();
			return pSvc;
		}
	}

	// Namespace not found, so create a new service
	BSTR strNSPath = SysAllocString(wcsNameSpace);

    HRESULT hRes = m_pLoc->ConnectServer (strNSPath, NULL, NULL,
										  0, 0, 0, 0, &pSvc);
    SysFreeString(strNSPath);

    if (FAILED(hRes))
    {
        printf("Could not connect. Error code = 0x%X\n", hRes);
        CoUninitialize();
        return NULL;
    }

    // Save service
	CService *pService = new CService(wcsNameSpace, pSvc);
	m_apServices[m_nNumSvcs++] = pService;

	// NOTE: pSvc->Release() not called because it is passed back
	// as a return value.  The caller must call Release().

	return pSvc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\hiperstress.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

/////////////////////////////////////////////////////////
//
//	HiPerStress.cpp
//
//	Created by a-dcrews, Oct. 6, 1998
//
/////////////////////////////////////////////////////////

#include "HiPerStress.h"
#include "Main.h"
#include <cominit.h>

long g_lRefThreadCount = 0;	// Thread synchronization device
BOOL gbPound = FALSE;
CLocator *g_pLocator;

void test();
void DisplayWbemError(HRESULT hRes);
void UpdateSecurity(IUnknown* pUnk);


void main(int argc, char *argv[ ])
{
	// Evaluate command line param's

	if (argc > 1)
	{
		if (!strcmp(argv[1], "/pound"))
			gbPound = TRUE;
	}

	printf("         WBEM Hi Performance Provider Stress Tool\n");
	printf("==========================================================\n\n");

	//Initialize DCOM
    HRESULT hr = InitializeCom();
    if (hr != S_OK)
    {
        printf("Failed to initialize COM\n");
        return;
    }

	//Process level security
	hr = InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );
    if (hr != S_OK)
    {
        printf("Failed to initialize COM security.\n");
        goto end;
    }

	// Create Locator
	g_pLocator = new CLocator;
	if(!g_pLocator->Create())
		goto end;

	if (gbPound)
	{
		
	}
	else
	{
		// Run the controled test
		CRefTreeMain *pMain = new CRefTreeMain;

		pMain->Create(KEY_REFROOT);
		pMain->Go();
		
		delete pMain;
	}

	delete g_pLocator;

end:
	CoUninitialize();
}















void test()
{
	// Create locator
	IWbemLocator *pLoc;
	DWORD dwRes = CoCreateInstance (CLSID_WbemLocator, 0, 
									CLSCTX_INPROC_SERVER, 
									IID_IWbemLocator, (LPVOID *) &pLoc);
	if (FAILED(dwRes))
	{
		printf("Failed to create locator\n");
		return;
	}

	// Connect to NameSpace
	BSTR strNSPath = SysAllocString(L"\\\\a-dcrews1\\root\\default");
	IWbemServices *pSvc;
	dwRes = pLoc->ConnectServer (strNSPath, NULL, NULL, 0, 0, 0, 0, &pSvc);
    SysFreeString(strNSPath);

	if (FAILED(dwRes))
	{
		printf("Failed to create service\n");
		return;
	}

    // Create an empty refresher.
	IWbemRefresher			*pRef;
	IWbemConfigureRefresher	*pCfg;

    dwRes = CoCreateInstance(CLSID_WbemRefresher, 0, CLSCTX_SERVER,
            IID_IWbemRefresher, (LPVOID *) &pRef);
 
	if (FAILED(dwRes))
	{
		printf("Failed to create the refresher.\n");
		return;
	}

    // Create the refresher manager.
    dwRes = pRef->QueryInterface(IID_IWbemConfigureRefresher, 
        (LPVOID *) &pCfg);

	if (FAILED(dwRes))
	{
		printf("**ERROR** Failed to create the refresher manager.");
		return;
	}

    // Create an empty child-refresher.
	IWbemRefresher			*pChildRef;
	IWbemConfigureRefresher	*pChildCfg;

    dwRes = CoCreateInstance(CLSID_WbemRefresher, 0, CLSCTX_SERVER,
            IID_IWbemRefresher, (LPVOID *) &pChildRef);
 
	if (FAILED(dwRes))
	{
		printf("Failed to create the Child refresher.\n");
		return;
	}

    // Create the refresher manager.
    dwRes = pChildRef->QueryInterface(IID_IWbemConfigureRefresher, 
        (LPVOID *) &pChildCfg);

	if (FAILED(dwRes))
	{
		printf("**ERROR** Failed to create the Child refresher manager.");
		return;
	}

	//Add object to child refresher
	IWbemClassObject *pObj;
	LONG lID;
	dwRes = pChildCfg->AddObjectByPath(pSvc, L"Win32_Nt5PerfTest.Name=\"Inst_0\"", 0, 0,
								&pObj, &lID);
	if (FAILED(dwRes))
    {
        printf("**ERROR** Failed to add object to refresher");
        return;
    }

	// Add the child to the parent refresher
    dwRes = pCfg->AddRefresher(pChildRef, 0, &lID);
    if (FAILED(dwRes))
    {
        printf("**ERROR** Failed to add refresher to refresher");
        return;
    }

	BSTR strName = SysAllocString(L"Counter2");
	VARIANT v;
	VariantInit(&v);
	LONG vt, flavor;

	dwRes = pObj->Get(strName, 0, &v, &vt, &flavor);
	if (FAILED(dwRes))
	{
		printf("Could not get counter value");
		return;
	}
	printf("Initial counter value: %S\n", V_BSTR(&v));
	VariantClear(&v);

	// Refresh!
	pRef->Refresh(0);

	dwRes = pObj->Get(strName, 0, &v, &vt, &flavor);
	if (FAILED(dwRes))
	{
		printf("Could not get counter value");
		return;
	}
	printf("Final counter value: %S\n", V_BSTR(&v));
	VariantClear(&v);

    SysFreeString(strNSPath);

	pChildRef->Release();
	pChildCfg->Release();
	pRef->Release();
	pCfg->Release();
	pSvc->Release();
	pLoc->Release();
}

void UpdateSecurity(IUnknown* pUnk)
{
	HRESULT hRes;

	wprintf(L"\nUpdating Server Security...\n");

//Get Security Interface

	IClientSecurity *pSecurity = 0;

	hRes = pUnk->QueryInterface(IID_IClientSecurity, (LPVOID*)&pSecurity);
	
	if (S_OK != hRes)
	{
		wprintf(L"Client Security Interface error.\n");
		return;
	}
//Change security states - echo pre- & post-change states of security

//	TestSecurity(pSecurity, pUnk);
	
	hRes = pSecurity->SetBlanket(pUnk,
								 RPC_C_AUTHN_WINNT,
								 RPC_C_AUTHZ_NONE,
								 NULL,
								 RPC_C_AUTHN_LEVEL_CONNECT,
								 RPC_C_IMP_LEVEL_IMPERSONATE,
								 NULL,
								 EOAC_NONE);
	if (S_OK == hRes)
	{
		wprintf(L"Security Level Modified.\n");
//		TestSecurity(pSecurity, pUnk);
	}
	else
		wprintf(L"Security Modification Failed.\n");

	pSecurity->Release();

	return;
}

void DisplayWbemError(HRESULT hRes)
{
	switch (hRes)
	{
	case WBEM_S_NO_ERROR:
		break;
	case WBEM_E_ACCESS_DENIED:
		wprintf(L"WBEM_E_ACCESS_DENIED\n");
		break;
	case WBEM_E_FAILED:
		wprintf(L"WBEM_E_FAILED\n");
		break;
	case WBEM_E_INVALID_CLASS:
		wprintf(L"WBEM_E_INVALID_CLASS\n");
		break;
	case WBEM_E_INVALID_PARAMETER:
		wprintf(L"WBEM_E_INVALID_PARAMETER\n");
		break;
	case WBEM_E_INVALID_OBJECT_PATH:
		wprintf(L"WBEM_E_INVALID_OBJECT_PATH\n");
		break;
	case WBEM_E_NOT_FOUND:
		wprintf(L"WBEM_E_NOT_FOUND\n");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		wprintf(L"WBEM_E_OUT_OF_MEMORY\n");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		wprintf(L"WBEM_E_TRANSPORT_FAILURE\n");
		break;
	default:
		wprintf(L"Unknown WBEM Error\n");
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\agents.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


///////////////////////////////////////////////////////////////////
//
//	StressOps.cpp
//
///////////////////////////////////////////////////////////////////

#include "Refresher.h"
#include "Agents.h"


CBasicRefreshAgent::CBasicRefreshAgent()
{
	m_pRef = 0;
	m_dwIterations = 0;
	m_dwPeriod = 0;
	m_hThread = 0;
}

CBasicRefreshAgent::~CBasicRefreshAgent()
{
}

BOOL CBasicRefreshAgent::Create(CRefresher *pRef, DWORD dwIterations, DWORD dwPeriod, HANDLE hRefreshEvent)
{
	m_hRefreshEvent = hRefreshEvent;

	m_pRef = pRef;
	m_dwPeriod = dwPeriod;
	m_dwIterations = dwIterations;
	m_bInfinite = (0 == dwIterations);

	if (m_dwIterations)
	{
		DWORD dwTID;
		m_hThread = CreateThread(NULL, 0, CBasicRefreshAgent::StressThreadEntry, 
								 (LPVOID)this, CREATE_SUSPENDED, 
								 &dwTID);
		InterlockedIncrement(&g_lRefThreadCount);
	}
	return (NULL != m_hThread);
}

void CBasicRefreshAgent::BeginStress()
{
	if (m_hThread)
		ResumeThread(m_hThread);
}

void CBasicRefreshAgent::StressLoop()
{
	DWORD dw = 0;
	while ((dw < m_dwIterations) || m_bInfinite)
	{
		if (!m_bInfinite)
			dw++;

		if (!m_pRef->Refresh())
			break;

		if (m_dwPeriod)
			Sleep(m_dwPeriod);
	}
}

DWORD WINAPI CBasicRefreshAgent::StressThreadEntry(LPVOID lpParameter)
{
	CBasicRefreshAgent *pStress = (CBasicRefreshAgent*)lpParameter;

	pStress->StressLoop();

	if (InterlockedDecrement(&g_lRefThreadCount) == 0)
		if (pStress->m_hRefreshEvent)
			SetEvent(pStress->m_hRefreshEvent);

	return 0;
}

BOOL CRandomOpRefreshAgent::Create(CRefresher *pRef, DWORD dwPeriod)
{
	CBasicRefreshAgent::Create(pRef, 0, dwPeriod, NULL);

	DWORD dwTID;
	m_hThreadAddRefs	= CreateThread(NULL, 0, CRandomOpRefreshAgent::AddRefThreadEntry, 
								 (LPVOID)this, CREATE_SUSPENDED, 
								 &dwTID);
	m_hThreadRemoveRefs = CreateThread(NULL, 0, CRandomOpRefreshAgent::RemRefThreadEntry, 
								 (LPVOID)this, CREATE_SUSPENDED, 
								 &dwTID);
	return TRUE;
}

void CRandomOpRefreshAgent::BeginStress()
{
	CBasicRefreshAgent::BeginStress();
}

void CRandomOpRefreshAgent::StressLoop()
{
	DWORD dw = 0;
	while ((dw < m_dwIterations) || m_bInfinite)
	{
		if (!m_bInfinite)
			dw++;

		if (!m_pRef->Refresh())
			break;

		if (m_dwPeriod)
			Sleep(m_dwPeriod);
	}
}

DWORD WINAPI CRandomOpRefreshAgent::AddRefThreadEntry(LPVOID lpParameter)
{
	CRandomOpRefreshAgent *pAgent = (CRandomOpRefreshAgent*)lpParameter;

	// If number of instances are lower than MAX_INST, then add instance then sleep for random period
	if (pAgent->m_pRef->GetNumObjects() < MAX_INST)
		pAgent->m_pRef->AddObject(L"root\\default", L"Win32_HiPerfCounter.Name=\"Inst_1\"");

	Sleep(0);

	return 0;
}

DWORD WINAPI CRandomOpRefreshAgent::RemRefThreadEntry(LPVOID lpParameter)
{
	CRandomOpRefreshAgent *pAgent = (CRandomOpRefreshAgent*)lpParameter;

	// If number of instances are greater than MIN_INST, then remove instance then sleep for random period
	int nNumObj = pAgent->m_pRef->GetNumObjects();
	if (nNumObj > MIN_INST)
		pAgent->m_pRef->RemoveObject(GetTickCount() % nNumObj);

	Sleep(0);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\main.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	Main.h
//
//	CRefTreeMain contains the logic to manage the stress test.
//	After constructing the object, call create() to create the 
//	locator, build the refresher structure from the registry and
//	set up the stress objects.  Every refresher that has an Iteration
//	value in the registry will be stressed by an object running in a 
//	seperate thread, calling refreshes at a rate controlled by the 
//	Wait value in the registry.  The Wait value dictates the amount 
//	of time, in miliseconds, to pause between successive refreshes.
//	All threads are created in suspended mode.
//
//	Once Create has completed, call Go to start all the stress threads.
//	
//////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H_
#define _MAIN_H_

#include <windows.h>
#include "Refresher.h"
#include "Agents.h"
#include "arrtempl.h"

class CMain
{
protected:
	CUniquePointerArray<CRefresher>	m_apRootRef;

public:
	CMain();
	virtual ~CMain();

	BOOL Create();

	virtual BOOL Go() = 0;
};


class CRefTreeMain : public CMain 
{
	CUniquePointerArray<CBasicRefreshAgent> m_apAgent;

	HANDLE		m_hRefreshEvent;

	BOOL AddChildren(HKEY hKey, WCHAR* wcsRegPath, CRefresher *pRef);
	BOOL AddObject(WCHAR *wcsNewPath, CRefresher *pRef);
	CRefresher* CreateChildRefresher(WCHAR *wcsRegPath);

	BOOL SetStressInfo(HKEY hKey, CRefresher *pRef);

	void DumpTree();
	void DumpStats(DWORD dwDelta);

public:
	CRefTreeMain();
	virtual ~CRefTreeMain();

	BOOL Create(WCHAR *wcsRoot);
	BOOL Go();
};


class CPoundMain : public CMain
{
	LONG	m_lNumRefs;

public:
	CPoundMain(long lNumRefs);
	virtual ~CPoundMain();

	BOOL Create();
	BOOL Go();
};

#endif //_MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\locator.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	Locator.h
//
//	CLocator is a wrapper class for an IWbemLocator object.
//	The Wbem object is created on a call to Create().  Calls
//	to GetService will return a pointer to any valid namespace.
//
//////////////////////////////////////////////////////////////////////

#ifndef	_LOCATOR_H_
#define _LOCATOR_H_

#include "HiPerStress.h"
#include "Service.h"

#define MAX_SVCS	255

class CLocator  
{
	IWbemLocator	*m_pLoc;
	CService*		m_apServices[MAX_SVCS];
	int				m_nNumSvcs;

public:
	CLocator();
	virtual ~CLocator();

	BOOL Create();

	IWbemServices* GetService(WCHAR* wcsNameSpace);
};

#endif // _LOCATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\main.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


///////////////////////////////////////////////////////////////////
//
//	CRefTreeMain.cpp
//
//	Created by a-dcrews, Oct. 6, 1998
//
///////////////////////////////////////////////////////////////////

#include "HiPerStress.h"
#include "Main.h"

///////////////////////////////////////////////////////////////////
//
//	CMain
//
///////////////////////////////////////////////////////////////////

CMain::CMain()
{
}

CMain::~CMain()
{
	m_apRootRef.RemoveAll();
}

BOOL CMain::Create()
{
	return TRUE;
}

///////////////////////////////////////////////////////////////////
//
//	CRefTreeMain
//
///////////////////////////////////////////////////////////////////

CRefTreeMain::CRefTreeMain()
{
}

CRefTreeMain::~CRefTreeMain()
{
	m_apAgent.RemoveAll();
}

BOOL CRefTreeMain::Create(WCHAR *wcsRoot)
////////////////////////////////////////////////////////////////////
//
//	Create locator and all root refreshers 
//
////////////////////////////////////////////////////////////////////
{
	if (!CMain::Create())
		return FALSE;

	// Create event
	m_hRefreshEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// Create all root refreshers
	HKEY hKey;
	WCHAR wcsSubKey[512];
	DWORD dwIndex = 0,
		  dwSize = 512,
		  dwSubKey = dwSize;

	// Enumerate all keys
	HRESULT hRes = RegOpenKeyEx(HKEY_CURRENT_USER, wcsRoot, 0, KEY_READ, &hKey);
	while (ERROR_NO_MORE_ITEMS != RegEnumKeyEx(hKey, dwIndex++, wcsSubKey, &dwSubKey, 0, NULL, 0, NULL))
	{
		// Look for refreshers
		switch(*(_wcsupr(wcsSubKey)))
		{
			case L'R':
			{
				WCHAR wcsRefRoot[1024];
				swprintf(wcsRefRoot, L"%s%s\\", wcsRoot, wcsSubKey);
				CRefresher *pRef = CreateChildRefresher(wcsRefRoot);

				m_apRootRef.Add(pRef);
			}
		}
		dwSubKey = dwSize;
	}
	RegCloseKey(hKey);

	return TRUE;
}

CRefresher* CRefTreeMain::CreateChildRefresher(WCHAR *wcsRegPath)
////////////////////////////////////////////////////////////////////
//
//	Create refresher hierarchy and the stress object  
//
////////////////////////////////////////////////////////////////////
{
	CRefresher *pRef = new CRefresher;
	if (!pRef->Create())
	{
		delete pRef;
		return NULL;
	}

	HKEY hKey;
	HRESULT hRes = RegOpenKeyEx(HKEY_CURRENT_USER, wcsRegPath, 0, 
								KEY_READ, &hKey);
	if (hRes != ERROR_SUCCESS)
	{
		printf("**ERROR** Could not open the registry key: %s\n", wcsRegPath);
		delete pRef;
		return NULL;
	}

	AddChildren(hKey, wcsRegPath, pRef);
	SetStressInfo(hKey, pRef);

	RegCloseKey(hKey);

	return pRef;
}

BOOL CRefTreeMain::AddChildren(HKEY hKey, WCHAR *wcsRegPath, CRefresher *pRef)
////////////////////////////////////////////////////////////////////
//
//	Add all child objects and refreshers
//
////////////////////////////////////////////////////////////////////
{
	WCHAR	wcsSubKey[1024];

	const DWORD dwSize = 1024;
	DWORD	dwIndex = 0,
			dwSubKey = dwSize;

	while (ERROR_NO_MORE_ITEMS != RegEnumKeyEx(hKey, dwIndex++, wcsSubKey, &dwSubKey, 0, NULL, 0, NULL))
	{
		WCHAR wch;
		swscanf(wcsSubKey, L"%c", &wch);

		WCHAR wcsNewPath[1024];
		swprintf(wcsNewPath, L"%s%s\\", wcsRegPath, wcsSubKey);

		switch (*(_wcsupr(&wch)))
		{
		case L'R':
			if (!pRef->AddRefresher(CreateChildRefresher(wcsNewPath)))
				return FALSE;
			break;
		case L'O':
			if (!AddObject(wcsNewPath, pRef))
				return FALSE; 
			break;
		}
		dwSubKey = dwSize;
	}

	return TRUE;
}

BOOL CRefTreeMain::AddObject(WCHAR *wcsNewPath, CRefresher *pRef)
////////////////////////////////////////////////////////////////////
//
//	Obtain object and add it to refresher
//
////////////////////////////////////////////////////////////////////
{
	HRESULT hRes;
	HKEY hKey;

	// Open the object's key
	hRes = RegOpenKeyEx(HKEY_CURRENT_USER, wcsNewPath, 0, KEY_READ, &hKey);
	if (hRes != ERROR_SUCCESS)
	{
		printf("**ERROR** Could not open the registry key: %s\n", wcsNewPath);
		return FALSE;
	}

	WCHAR	wcsName[512],
			wcsNameSpace[1024];

	DWORD	dwType,
			dwName = 512,
			dwNameSpace = 1024;

	// Get the name of the object
	hRes = RegQueryValueEx (hKey, 0, 0, &dwType, 
					(LPBYTE)wcsName, &dwName);
	if (hRes != ERROR_SUCCESS)
	{
		printf("**ERROR** Could not open the registry key: %S%S\n", wcsNewPath, L"<default>");
		return FALSE;
	}

	// Get the name of the namespace
	hRes = RegQueryValueEx (hKey, L"NameSpace", 0, &dwType, 
					(LPBYTE)wcsNameSpace, &dwNameSpace);
	if (hRes != ERROR_SUCCESS)
	{
		printf("**ERROR** Could not open the registry key: %s\n", wcsNewPath);
		return FALSE;
	}

	RegCloseKey(hKey);

	return pRef->AddObject(wcsNameSpace, wcsName);
}

BOOL CRefTreeMain::SetStressInfo(HKEY hKey, CRefresher *pRef)
////////////////////////////////////////////////////////////////////
//
//	Get the stress information
//
////////////////////////////////////////////////////////////////////
{
	DWORD	dwIterations = 0,
			dwWait = 0,
			dwType = 0,
			dwSize = 1024;

	// Get the number of iterations for this refresher
	RegQueryValueEx (hKey, L"Iterations", 0, &dwType, 
					(LPBYTE)&dwIterations, &dwSize);
	dwSize = 4;

	// Get the wait period between iterations
	RegQueryValueEx (hKey, L"Wait", 0, &dwType, 
					(LPBYTE)&dwWait, &dwSize);

	// Create the stress object and add it to the array

	CBasicRefreshAgent *pAgent = new CBasicRefreshAgent;
	pAgent->Create(pRef, dwIterations, dwWait, m_hRefreshEvent); 
	m_apAgent.Add(pAgent);

	return TRUE;
}

BOOL CRefTreeMain::Go()
////////////////////////////////////////////////////////////////////
//
//	Print the refresher tree with all of the object parameters 
//	and values.  Start the threads, wait for them all to terminate,
//	and then print out the refresher tree and parameters again.
//
////////////////////////////////////////////////////////////////////
{
	DumpTree();

	printf("\nStressing...");
	DWORD dwFinish,
		  dwStart = GetTickCount();

	for (int i = 0; i < m_apAgent.GetSize(); i++)
		m_apAgent[i]->BeginStress();

	WaitForSingleObject(m_hRefreshEvent, INFINITE);

	dwFinish = GetTickCount();

	printf("Done Stressing.\n\n\n");

	DumpTree();

	DumpStats(dwFinish - dwStart);

	return TRUE;
}

void CRefTreeMain::DumpTree()
{
	for (int i = 0; i < m_apRootRef.GetSize(); i++)
	{
		WCHAR wcsPrefix[16];
		if (i < (m_apRootRef.GetSize() - 1))
			wcscpy(wcsPrefix, L"|");
		else
			wcscpy(wcsPrefix, L" ");
	
		m_apRootRef[i]->DumpTree(wcsPrefix);
		printf("%S\n", wcsPrefix);
	}
}

void CRefTreeMain::DumpStats(DWORD dwDelta)
{

	printf("\n\n\n");
	printf("                         Refresh Stats\n");
	printf("==========================================================================\n");
	printf(" Elapsed Time: %d msec\n", dwDelta);
	printf("==========================================================================\n\n\n");
	for (int i = 0; i < m_apRootRef.GetSize(); i++)
		m_apRootRef[i]->DumpStats();

	printf("\n\n");
}

///////////////////////////////////////////////////////////////////
//
//	CRefTreeMain
//
///////////////////////////////////////////////////////////////////

CPoundMain::CPoundMain(long lNumRefs)
{
	m_lNumRefs = lNumRefs;
}

CPoundMain::~CPoundMain()
{
}

BOOL CPoundMain::Create()
{
	CMain::Create();

	return TRUE;
}

BOOL CPoundMain::Go()
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\object.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	Object.h
//
//	CObject is a wrapper class for an IWbemClassObject.
//	The Wbem object must be created, and then passed as
//	a parameter upon CObject construction
//	
//////////////////////////////////////////////////////////////////////

#ifndef	_OBJECT_H_
#define _OBJECT_H_

//#define MAX_PARAMS 128
#include <arrtempl.h>

class CInstance  
{
	IWbemClassObject *m_pObj;		// WBEM object pointer

	WCHAR	m_wcsNameSpace[1024];	// NameSpace for object
	WCHAR	m_wcsName[512];			// Name of object
	long	m_lID;					// Refresher object ID

	class CParameter
	{
		CInstance*	m_pInst;
		BSTR		m_bstrParaName;
		VARIANT		m_vInitValue;
		DWORD		m_dwNumRefs;

	public:
		CParameter(CInstance* pInst, BSTR bstrName, VARIANT vInitValue);
		~CParameter();

		void DumpStats(LONG lNumRefs);
	};
	CUniquePointerArray<CParameter> m_apParameter;
	friend CParameter;

public:
	CInstance(WCHAR *wcsNameSpace, WCHAR *wcsName, IWbemClassObject *pObj, long lID);
	virtual ~CInstance();

	long	GetID(){return m_lID;}
	void	DumpObject(const WCHAR *wcsPrefix);
	void	DumpStats(LONG lNumRefs);
};

#endif // _OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\object.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	Object.cpp
//
//	Created by a-dcrews, Oct. 6, 1998
//
//////////////////////////////////////////////////////////////////////

#include "HiPerStress.h"
#include "Object.h"

//////////////////////////////////////////////////////////////////////
//
//	CInstance
//
//////////////////////////////////////////////////////////////////////

CInstance::CInstance(WCHAR *wcsNameSpace, WCHAR *wcsName, IWbemClassObject *pObj, long lID)
{
	pObj->AddRef();
	m_pObj = pObj;

	wcscpy(m_wcsNameSpace, wcsNameSpace);
	wcscpy(m_wcsName, wcsName);

	m_lID = lID;

    // Enumerate through the non-system object properties
    m_pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);

    BSTR bstrName = 0;
    VARIANT v;
    VariantInit(&v);

    // Create parameter array
    while (WBEM_NO_ERROR ==  m_pObj->Next(0, &bstrName, &v, 0, 0))
    {
		m_apParameter.Add(new CParameter(this, bstrName, v));

		SysFreeString(bstrName);
		VariantClear(&v);
	}

	m_pObj->EndEnumeration();
}

CInstance::~CInstance()
{
	if (m_pObj)
		m_pObj->Release();
}

void CInstance::DumpObject(const WCHAR *wcsPrefix)
{
    BSTR bstrName = 0;
    LONG vt = 0;
    VARIANT v;
    VariantInit(&v);
	HRESULT hRes;

    // Print out the object path to identify it.
	printf("%.*S|\n", (wcslen(wcsPrefix)-1), wcsPrefix);
	printf("%.*S+--Object: %S\\%S\n", (wcslen(wcsPrefix)-1), 
									   wcsPrefix, m_wcsNameSpace, 
									   m_wcsName);

    // Enumerate through the non-system object properties
    hRes = m_pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
	if (FAILED(hRes))
	{
		printf("Could not begin enumerating %S\n", m_wcsName);
		return;
	}

    // Print out each property 
    while (WBEM_NO_ERROR ==  m_pObj->Next(0, &bstrName, &v, &vt, 0))
    {
		printf("%S  |--%S: ", wcsPrefix, bstrName);
		switch (v.vt)
		{
			case VT_NULL:
				printf("<NULL>\n");break;
			case VT_I4:
				printf("%d\n", V_I4(&v)); break;
            case VT_UI4:
				printf("%u\n", V_I4(&v)); break;
			case VT_BSTR:
			case VT_I8:
			case VT_UI8:
				printf("%S\n", V_BSTR(&v)); break;
			default:
				printf("Type = complex\n");
		}
		SysFreeString(bstrName);
		VariantClear(&v);
	}

	m_pObj->EndEnumeration();
}

void CInstance::DumpStats(LONG lNumRefs)
{
    BSTR bstrName = 0;
    LONG vt = 0;
    VARIANT v;
    VariantInit(&v);

	// Print out the object path to identify it.
	printf("                  %S\n", m_wcsName);
	printf("----------------------------------------------------------------------------\n");
	printf("Refreshes:\n");
	printf("                Expected: %-5d               Recieved: %-5d\n", 0, lNumRefs);
	printf("----------------------------------------------------------------------------\n");
	printf(" Parameter    | Initial Val  | Expected Val | Final Value    \n");
	printf("----------------------------------------------------------------------------\n");

	for (int i = 0; i < m_apParameter.GetSize(); i++)
	{
		m_apParameter[i]->DumpStats(lNumRefs);
	}
	printf("\n\n\n");
}

//////////////////////////////////////////////////////////////////////
//
//	CParameter
//
//////////////////////////////////////////////////////////////////////

CInstance::CParameter::CParameter(CInstance* pInst, BSTR bstrName, VARIANT vInitValue) 
{
	m_pInst = pInst;
	m_bstrParaName = SysAllocString(bstrName);
	VariantInit(&m_vInitValue);
	VariantCopy(&m_vInitValue, &vInitValue);
	m_dwNumRefs = 0; 
}

CInstance::CParameter::~CParameter() 
{
	SysFreeString(m_bstrParaName);
	VariantClear(&m_vInitValue);
}

void CInstance::CParameter::DumpStats(LONG lRefCount)
{
	HRESULT hRes;

	// Determine if this parameter is a counter by checking the qualifier set
	IWbemQualifierSet *pQS;
	hRes = m_pInst->m_pObj->GetPropertyQualifierSet(m_bstrParaName, &pQS);
	if (FAILED(hRes))
	{
		printf("Could not get property qualifier set\n");
		return;
	}

	hRes = pQS->Get(BSTR(L"countertype"), 0, 0, 0);
	pQS->Release();

	// If it found the countertype qualifier, then we output the counter info
	if (hRes == WBEM_S_NO_ERROR)
	{
		LONG vt;
		VARIANT v;
		VariantInit(&v);
		LONG f;

		// Get the current value
		m_pInst->m_pObj->Get(m_bstrParaName, 0, &v, &vt, &f);

		// Output based on variant type.  Output is in the following format
		// Parameter Name, Initial Value, Tot Refreshes Rec'd, Expected value, Current Value
		switch (m_vInitValue.vt)
		{
			case VT_I4:
			{
				int nInitVal = V_I4(&m_vInitValue),
					nExpVal = nInitVal + lRefCount,
					nFinalVal = V_I4(&v);

				printf("%c%-14.14S", (nExpVal == nFinalVal)?' ':'*', m_bstrParaName);
				printf(" %-14d %-14d %-14d", nInitVal, nExpVal, nFinalVal);
			}break;
			case VT_UI4:
			{
				long lInitVal	= V_I4(&m_vInitValue),
					 lExpVal	= lInitVal + lRefCount,
					 lFinalVal	= V_I4(&v);

				printf("%c%-14.14S", (lExpVal == lFinalVal)?' ':'*', m_bstrParaName);
				printf(" %-14u %-14u %-14u", lInitVal, lExpVal, lFinalVal); 
			}break;
			case VT_BSTR:
			case VT_I8:
			case VT_UI8:
			{
				long lInitVal	= _wtol(V_BSTR(&m_vInitValue)),
					 lExpVal	= lInitVal + lRefCount,
					 lFinalVal	= _wtol(V_BSTR(&v));

				printf("%c%-14.14S", (lExpVal == lFinalVal)?' ':'*', m_bstrParaName);
				printf(" %-14.13S %-14d %-14.13S", V_BSTR(&m_vInitValue), lExpVal, V_BSTR(&v)); 
			}break;
			default:
				printf(" %-14.14S", m_bstrParaName);
				printf(" complex        %-14.14S complex       ", L"0");
		}
		printf("\n");

		VariantClear(&v);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\service.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	Service.cpp
//
//	Created by a-dcrews, Oct. 6, 1998
//
//////////////////////////////////////////////////////////////////////

#include "HiPerStress.h"
#include "Service.h"

CService::CService(WCHAR* wcsNameSpace, IWbemServices* pSvc)
{
	pSvc->AddRef();
	m_pService = pSvc;

	wcscpy(m_wcsNameSpace, wcsNameSpace);
}

CService::~CService()
{
	if (m_pService)
		m_pService->Release();
}

void CService::GetName(WCHAR *wcsNameSpace)
{
	wcscpy(wcsNameSpace, m_wcsNameSpace);
}

IWbemServices* CService::GetService() 
{
	return m_pService;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\refresher.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
//	Refresher.h
//
//	CRefresher is a wrapper class for IWbemRefresher and 
//	IWbemConfigureRefresher.  It uses a two phase initialization
//	to create the refresher and refresher manager.
//
//////////////////////////////////////////////////////////////////////

#ifndef _REFRESHER_H_
#define _REFRESHER_H_

#include "HiPerStress.h"
#include "Object.h"
#include "arrtempl.h"

class CRefresher  
{
	IWbemRefresher			*m_pRef;			// WBEM refresher pointer
	IWbemConfigureRefresher	*m_pCfg;			// WBEM refresher mgr pointer

	CUniquePointerArray<CInstance>	m_apObj;	// Array of refresher's objects
	CUniquePointerArray<CRefresher>	m_apRef;	// Array of child refreshers

	long		m_lID;							// Parent refresher ID
	LONG		m_lRefCount;					// Number of Refs Rec'd

public:
	CRefresher();
	virtual ~CRefresher();

	BOOL Create();

	BOOL AddObject(WCHAR *wcsNameSpace, WCHAR *wcsName);
	BOOL RemoveObject(int nIndex);
	int  GetNumObjects() {return m_apObj.GetSize();}

	BOOL AddRefresher(CRefresher *pRef);
	BOOL RemoveRefresher(int nIndex);
	int  GetNumRefreshers() {return m_apRef.GetSize();}

	BOOL Refresh();

	long GetID(){return m_lID;}
	void DumpTree(const WCHAR *wcsPrefix = L"");
	void DumpStats();
};

#endif // _REFRESHER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\refresher.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//////////////////////////////////////////////////////////////////////
//
// Refresher.cpp: implementation of the CRefresher class.
//
//////////////////////////////////////////////////////////////////////

#include "HiPerStress.h"
#include "Refresher.h"

//////////////////////////////////////////////////////////////////////
//
// CRefresher
//
//////////////////////////////////////////////////////////////////////

CRefresher::CRefresher()
{
	m_pRef = 0;				
	m_pCfg = 0;
	m_lRefCount = 0;
}

CRefresher::~CRefresher()
//////////////////////////////////////////////////////////////////////
//
//	Remove all objects from the refresher, delete the objects, and 
//	release the refresher & refresher manager
//
//////////////////////////////////////////////////////////////////////
{
	int i;
    for (i = 0; i < m_apObj.GetSize(); i++)
		m_pCfg->Remove(m_apObj[i]->GetID(), 0);

	m_apObj.RemoveAll();

    for (i = 0; i < m_apRef.GetSize(); i++)
		m_pCfg->Remove(m_apRef[i]->GetID(), 0);

	m_apRef.RemoveAll();

	if (m_pRef)
		m_pRef->Release();

	if (m_pCfg)
		m_pCfg->Release();
}

BOOL CRefresher::Create()
//////////////////////////////////////////////////////////////////////
//
//	Create a refresher and refresher manager
//
//	Returns TRUE if no error.
//
//////////////////////////////////////////////////////////////////////
{
    // Create an empty refresher.
    DWORD dwRes = CoCreateInstance(CLSID_WbemRefresher, 0, CLSCTX_SERVER,
            IID_IWbemRefresher, (LPVOID *) &m_pRef);
	if (FAILED(dwRes))
	{
		printf("**ERROR** Failed to create the refresher.");
		return FALSE;
	}

    // Create the refresher manager.
    dwRes = m_pRef->QueryInterface(IID_IWbemConfigureRefresher, 
        (LPVOID *) &m_pCfg);
	if (FAILED(dwRes))
	{
		printf("**ERROR** Failed to create the refresher manager.");
		m_pRef->Release();
		m_pRef = 0;
		return FALSE;
	}

	return TRUE;
}

BOOL CRefresher::Refresh()
//////////////////////////////////////////////////////////////////////
//
//	Refresh!
//
//	Returns TRUE if no error.
//
//////////////////////////////////////////////////////////////////////
{
	m_lRefCount++;

    if (m_pRef == 0)
    {
        printf("**ERROR** No active refresher!\n");
        return FALSE;
    }

    HRESULT hRes = m_pRef->Refresh(0);  
    if (FAILED(hRes))
	{
		printf("**ERROR** Failed to refresh.");
        return FALSE;
	}
    return TRUE;
}

BOOL CRefresher::AddObject(WCHAR *wcsNameSpace, WCHAR *wcsName)
//////////////////////////////////////////////////////////////////////
//
//	Add an instance to the refresher
//
//	Parameters:
//		<wcsNameSpace>	A string identifying the namespace of the object
//		<wcsName>		A string identifying the object
//
//	Returns TRUE if no error.
//
//////////////////////////////////////////////////////////////////////
{
	LONG lObjID;

	// Get the namespace service
	IWbemServices *pSvc = g_pLocator->GetService(wcsNameSpace);
	if (!pSvc)
	{
        printf("**ERROR** Failed to resolve namespace %S.\n", wcsNameSpace);
        return FALSE;
	}

    // Add the object to the refresher.
	IWbemClassObject *pRefreshableCopy = 0;

    HRESULT hRes = m_pCfg->AddObjectByPath(pSvc, wcsName, 0, 0,
								&pRefreshableCopy, &lObjID);
	if (hRes)
    {
        printf("**ERROR** Failed to add object %S\\%S to refresher. WBEM error code = 0x%X\n", wcsNameSpace, wcsName, hRes);
		pSvc->Release();
        return FALSE;
    }

    // Record the object and its id.
	CInstance *pInst = new CInstance(wcsNameSpace, wcsName, pRefreshableCopy, lObjID);
	m_apObj.Add(pInst);

	pRefreshableCopy->Release();
	pSvc->Release();

    return TRUE;
}

BOOL CRefresher::RemoveObject(int nIndex)
{
	m_pCfg->Remove(m_apObj[nIndex]->GetID(), 0);
	m_apObj.RemoveAt(nIndex);

	return TRUE;
}

BOOL CRefresher::AddRefresher(CRefresher *pRef)
//////////////////////////////////////////////////////////////////////
//
//	Add a child refresher to the refresher 
//
//	Parameters:
//		<pRef>		An existing refresher 
//
//	Returns TRUE if no error.
//
//////////////////////////////////////////////////////////////////////
{
	// Add refresher
    HRESULT hRes = m_pCfg->AddRefresher(pRef->m_pRef, 0, &m_lID);
    if (FAILED(hRes))
    {
        printf("**ERROR** Failed to add refresher to refresher. WBEM error code = 0x%X\n", hRes);
        return FALSE;
    }

	m_apRef.Add(pRef);

	return TRUE;
}

BOOL CRefresher::RemoveRefresher(int nIndex)
{
	m_pCfg->Remove(m_apRef[nIndex]->GetID(), 0);
	m_apRef.RemoveAt(nIndex);

	return TRUE;
}

void CRefresher::DumpTree(const WCHAR *wcsPrefix)
//////////////////////////////////////////////////////////////////////
//
//	Print out the contents of the refresher
//
//	Parameters:
//		<wcsPrefix>	A string representing the "branches" of the tree 
//
//////////////////////////////////////////////////////////////////////
{
	printf("%.*S+--Refresher\n", (wcslen(wcsPrefix)-1), wcsPrefix);

	int i;
	WCHAR wcsRefPrefix[1024];

	if (m_apRef.GetSize() > 0)
		swprintf(wcsRefPrefix, L"%s  |", wcsPrefix);
	else
		swprintf(wcsRefPrefix, L"%s   ", wcsPrefix);

	for (i = 0; i < m_apObj.GetSize(); i++)
		m_apObj[i]->DumpObject(wcsRefPrefix);

	for (i = 0; i < m_apRef.GetSize(); i++)
	{
		if (i == (m_apRef.GetSize() - 1))
			swprintf(wcsRefPrefix, L"%s   ", wcsPrefix);

		printf("%S  |\n", wcsPrefix);
		m_apRef[i]->DumpTree(wcsRefPrefix);
	}
}

void CRefresher::DumpStats()
{
	int i;
	for (i = 0; i < m_apObj.GetSize(); i++)
		m_apObj[i]->DumpStats(m_lRefCount);

	for (i = 0; i < m_apRef.GetSize(); i++)
		m_apRef[i]->DumpStats();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\kernel33\stktrace.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    STKTRACE.H

Abstract:

	Symbolic stack trace

History:

	raymcc    27-May-99

--*/


#ifndef _STKTRACE_H_
#define _STKTRACE_H_

struct StackTrace
{
    static BOOL   m_bActive;
    DWORD  m_dwCount;
    DWORD  m_dwAddresses[1];
};

BOOL StackTrace_Init();
void StackTrace_Delete(StackTrace *pMem);
StackTrace *StackTrace__NewTrace();
char *StackTrace_Dump(StackTrace *pTrace);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\kernel33\kernel33.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


typedef LPVOID (__stdcall *PFN_HeapAlloc)(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN SIZE_T dwBytes
    );

typedef LPVOID (__stdcall *PFN_HeapReAlloc)(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpMem,
    IN SIZE_T dwBytes
    );

typedef BOOL (__stdcall *PFN_HeapFree)(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpMem
    );

typedef DWORD (__stdcall *PFN_HeapSize)(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPCVOID lpMem
    );


extern PFN_HeapAlloc pfnHeapAlloc;
extern PFN_HeapReAlloc pfnHeapReAlloc;
extern PFN_HeapFree pfnHeapFree;
extern PFN_HeapSize pfnHeapSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\hiperstress\service.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//////////////////////////////////////////////////////////////////////
//
//	Service.h
//
//	CService is a wrapper class for an IWbemServices object.
//	The object must be created, and then passed to the constructor 
//	as an argument. 
//
//////////////////////////////////////////////////////////////////////

#ifndef _SERVICE_H_
#define _SERVICE_H_

class CService  
{
	IWbemServices*	m_pService;
	WCHAR			m_wcsNameSpace[1024];

public:
	CService(WCHAR* wcsNameSpace, IWbemServices* pSvc);
	virtual ~CService();

	void GetName(WCHAR *wcsNameSpace);
	IWbemServices* GetService();
};

#endif // _SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\kernel33\kernel33.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


// WMI Debugging DLL -- Kernel33 wrapper for memory allocations

#include <windows.h>
#include <kernel33.h>
#include <stktrace.h>


PFN_HeapAlloc pfnHeapAlloc = 0;
PFN_HeapReAlloc pfnHeapReAlloc = 0;
PFN_HeapFree pfnHeapFree = 0;
PFN_HeapSize pfnHeapSize = 0;

CRITICAL_SECTION cs;
CRITICAL_SECTION s_cs;


void _strcat(char *p1, char *p2)
{
    while (*++p1);
    while (*p2) *p1++=*p2++;
    *p1 = 0;
}

void TrackingInit();
void TrackBlock(
    size_t nSize,
    LPVOID pAddr
    );

HMODULE hLib = 0;
void Setup();
BOOL g_bMemTracking = FALSE;

BOOL UntrackBlock(LPVOID pBlock);
BOOL TestForWinMgmt();
BOOL g_bWinMgmt = FALSE;

///////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI DllEntry(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    static BOOL bInit = FALSE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        if (bInit == FALSE)
        {
            bInit = TRUE;
            BOOL bWinMgmt = TestForWinMgmt();
            char buf[256];
            *buf = 0;
            GetSystemDirectory(buf, 256);
            _strcat(buf, "\\kernel32.dll");
            hLib = LoadLibrary(buf);
            InitializeCriticalSection(&cs);

            if (bWinMgmt)
                TrackingInit();

            pfnHeapAlloc = (PFN_HeapAlloc) GetProcAddress(hLib, "HeapAlloc");
            pfnHeapReAlloc = (PFN_HeapReAlloc) GetProcAddress(hLib, "HeapReAlloc");
            pfnHeapFree = (PFN_HeapFree) GetProcAddress(hLib, "HeapFree");
            pfnHeapSize = (PFN_HeapSize) GetProcAddress(hLib, "HeapSize");

            if (bWinMgmt)
                Setup();

            bInit = TRUE;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DeleteCriticalSection(&cs);
    }

    return TRUE;

}

extern "C"
LPVOID WINAPI HeapAlloc(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN SIZE_T dwBytes
    )
{

    LPVOID p = pfnHeapAlloc(hHeap, dwFlags, dwBytes);

    if (p && g_bMemTracking)
    {
        TrackBlock(dwBytes, p);
    }

    return p;
}

extern "C"
LPVOID WINAPI HeapReAlloc(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpMem,
    IN SIZE_T dwBytes
    )
{
    if (g_bMemTracking)
        UntrackBlock(lpMem);

    LPVOID p = pfnHeapReAlloc(hHeap, dwFlags, lpMem, dwBytes);

    if (p && g_bMemTracking)
        TrackBlock(dwBytes, p);

    return p;
}

extern "C"
BOOL WINAPI HeapFree(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpMem
    )
{
    if (g_bMemTracking)
        UntrackBlock(lpMem);

    return pfnHeapFree(hHeap, dwFlags, lpMem);
}




//***************************************************************************
//
//***************************************************************************

struct TrackingLink
{
    TrackingLink *pNext;
    DWORD dwThreadId;
    size_t nSize;
	DWORD dwSysTime;
    StackTrace *pTrace;
    void *pBlock;
};


TrackingLink *s_pHead;
HANDLE s_hTrackingHeap;

//******************************************************************************
//
//******************************************************************************

void TrackingInit()
{
    InitializeCriticalSection(&s_cs);
    EnterCriticalSection(&s_cs);
    s_hTrackingHeap = HeapCreate(0, 0x8000, 0);
    s_pHead = 0;
    LeaveCriticalSection(&s_cs);
}

//******************************************************************************
//
//******************************************************************************

void TrackingReset()
{
    EnterCriticalSection(&s_cs);

    TrackingLink *pTracer, *pTemp;

    for (pTracer = s_pHead; pTracer; pTracer = pTemp)
    {
        pTemp = pTracer->pNext;
        //if (pTracer->pTrace)
        //    pTracer->pTrace->Delete();
        pfnHeapFree(s_hTrackingHeap, 0, pTracer);
    }

    s_pHead = 0;

    LeaveCriticalSection(&s_cs);
}

//******************************************************************************
//
//******************************************************************************

void TrackBlock(
    size_t nSize,
    LPVOID pAddr
    )
{
    EnterCriticalSection(&s_cs);

    // Allocate new memory blocks.

    TrackingLink *pNew = (TrackingLink *) pfnHeapAlloc(s_hTrackingHeap, HEAP_ZERO_MEMORY,
        sizeof(TrackingLink));

    if (!pNew)
    {
        LeaveCriticalSection(&s_cs);
        return;
    }

    StackTrace *pTrace = StackTrace__NewTrace();

    // Attach to list.
    // ===============

    pNew->nSize = nSize;
    pNew->pTrace = pTrace;
    pNew->pNext = s_pHead;
    pNew->pBlock = pAddr;
	pNew->dwSysTime = GetCurrentTime();
    pNew->dwThreadId = GetCurrentThreadId();
    s_pHead = pNew;

    LeaveCriticalSection(&s_cs);
}

BOOL UntrackBlock(LPVOID pBlock)
{
    if (!pBlock)
        return FALSE;

    // Special case the head.
    // ======================

    EnterCriticalSection(&s_cs);

    if (s_pHead == 0)
    {
        LeaveCriticalSection(&s_cs);
        return FALSE;
    };

    if (s_pHead->pBlock == pBlock)
    {
        TrackingLink *pTemp = s_pHead;
        s_pHead = s_pHead->pNext;
        if (pTemp->pTrace)
            StackTrace_Delete(pTemp->pTrace);
        pfnHeapFree(s_hTrackingHeap, 0, pTemp);
        LeaveCriticalSection(&s_cs);
        return TRUE;
    }

    TrackingLink *pTracer , *pPrevious = 0;

    for (pTracer = s_pHead; pTracer; pTracer = pTracer->pNext)
    {
        if (pTracer->pBlock == pBlock)
        {
            pPrevious->pNext = pTracer->pNext;
            if (pTracer->pTrace)
                StackTrace_Delete(pTracer->pTrace);
            pfnHeapFree(s_hTrackingHeap, 0, pTracer);
            LeaveCriticalSection(&s_cs);
            return TRUE;
        }

        pPrevious = pTracer;
    }

    LeaveCriticalSection(&s_cs);
    return FALSE;
}


extern "C" VOID WINAPI StartHeapTracking()
{
    StackTrace_Init();
}

extern "C" DWORD WINAPI GetTotalHeap()
{
    EnterCriticalSection(&s_cs);
    TrackingLink *pTracer;
    DWORD dwTotal = 0;
    for (pTracer = s_pHead; pTracer; pTracer = pTracer->pNext)
        dwTotal += pTracer->nSize;
    LeaveCriticalSection(&s_cs);
    return dwTotal;
}

extern "C" DWORD WINAPI DumpHeapStacks()
{
    HANDLE hFile = CreateFile("c:\\temp\\heap.log", GENERIC_WRITE, 0, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return 0;
    }
    SetFilePointer(hFile, 0, 0, FILE_END);

    DWORD dwWritten;
    char *pStr = "*************** Dump *******************\r\n";
    WriteFile(hFile, pStr, lstrlen(pStr), &dwWritten, 0);

    EnterCriticalSection(&s_cs);

    TrackingLink *pTracer;
    DWORD dwTotal = 0;
    for (pTracer = s_pHead; pTracer; pTracer = pTracer->pNext)
    {
        char *pStr = " --Block ";
        WriteFile(hFile, pStr, lstrlen(pStr), &dwWritten, 0);

        char Buf[256];
        wsprintf(Buf, " Size=%d Address=0x%X Thread=%d Time=%d\r\n",
            pTracer->nSize, pTracer->pBlock, pTracer->dwThreadId,
            pTracer->dwSysTime
            );
        WriteFile(hFile, Buf, lstrlen(Buf), &dwWritten, 0);

        StackTrace *pTrace = pTracer->pTrace;
        char *pDump = 0;
        if (pTrace)
            pDump = StackTrace_Dump(pTrace);
        if (pDump)
        {
            WriteFile(hFile, pDump, lstrlen(pDump), &dwWritten, 0);
        }
    }

    CloseHandle(hFile);
    LeaveCriticalSection(&s_cs);
    return 0;
}



    typedef enum { H_ENABLE_LEAK_TRACKING = 0,
           H_DISABLE_LEAK_TRACKING = 1,
           H_RESET_LEAK_TRACKING = 2,
           H_DUMP_LEAK_TRACKING = 3,
           H_FAIL_ALLOCATOR = 4,
           H_RESTORE_ALLOCATOR = 5,
           H_FAIL_NEXT_ALLOC = 6,
           H_ENABLE_EXCEPTION_TRACKING = 7,
           H_DISABLE_EXCEPTION_TRACKING = 8,
           H_ENABLE_OBJECT_VALIDATION = 9,
           H_DISABLE_OBJECT_VALIDATION = 10,
           H_DEBUG_BREAK = 11,
           H_LAST
         } eTypes;


static HANDLE m_hArray[H_LAST];

static DWORD WINAPI ThreadProc(LPVOID pArg);


void Setup()
{
    PSECURITY_DESCRIPTOR pSD;

    // Initialize a security descriptor.

    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
        SECURITY_DESCRIPTOR_MIN_LENGTH);   // defined in WINNT.H
    if (pSD == NULL)
        return;

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;

    if (!InitializeSecurityDescriptor(pSD,
        SECURITY_DESCRIPTOR_REVISION))
            return;

    // Add a NULL disc. ACL to the security descriptor.

    if (!SetSecurityDescriptorDacl(pSD,
        TRUE,     // specifying a disc. ACL
        (PACL) NULL,
        FALSE))
        return;

    // Set up the IPC signals.
    // =======================

    m_hArray[H_ENABLE_LEAK_TRACKING] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_ENABLE_LEAK_TRACKING");
    m_hArray[H_DISABLE_LEAK_TRACKING] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_DISABLE_LEAK_TRACKING");
    m_hArray[H_RESET_LEAK_TRACKING] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_RESET_LEAK_TRACKING");
    m_hArray[H_DUMP_LEAK_TRACKING] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_DUMP_LEAK_TRACKING");

    m_hArray[H_FAIL_ALLOCATOR] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_FAIL_ALLOCATOR");
    m_hArray[H_RESTORE_ALLOCATOR] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_RESTORE_ALLOCATOR");
    m_hArray[H_FAIL_NEXT_ALLOC] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_FAIL_NEXT_ALLOCATION");

    m_hArray[H_ENABLE_EXCEPTION_TRACKING] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_ENABLE_EXCEPTION_TRACKING");
    m_hArray[H_DISABLE_EXCEPTION_TRACKING] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_DISABLE_EXCEPTION_TRACKING");

    m_hArray[H_ENABLE_OBJECT_VALIDATION] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_ENABLE_OBJECT_VALIDATION");
    m_hArray[H_DISABLE_OBJECT_VALIDATION] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_DISABLE_OBJECT_VALIDATION");

    m_hArray[H_DEBUG_BREAK] =
        CreateEventW(&sa, FALSE, 0, L"EVENT_WINMGMT_DEBUG_BREAK");

    // Create the waiting thread.
    // ==========================

    DWORD dwId;
    HANDLE hThread = CreateThread(0, 0, ThreadProc, 0, 0, &dwId);
    CloseHandle(hThread);

    LocalFree(pSD);
}


//***************************************************************************
//
//***************************************************************************

static DWORD WINAPI ThreadProc(LPVOID pArg)
{
    static bool bInitialized = false;
    if (g_bWinMgmt == FALSE)
    {
        return 0;
    }
    for (;;)
    {
        DWORD dwRes = WaitForMultipleObjects(H_LAST, m_hArray, FALSE, INFINITE);

        dwRes -= WAIT_OBJECT_0;

        switch(dwRes)
        {
            case H_ENABLE_LEAK_TRACKING:
                if (!bInitialized)
                {
                    StartHeapTracking();
                    bInitialized = true;
                }
                g_bMemTracking = true;
                break;

            case H_DUMP_LEAK_TRACKING:
                if (g_bMemTracking)
                    DumpHeapStacks();
                break;
        }
    }

    return 0;
}

BOOL TestForWinMgmt()
{
    char mod[128];

    GetModuleFileName(0, mod, 128);

    // Upcase.
    char *p = mod;
    while (*p)
    {
        if (*p >= 'a' && *p <= 'z')
        {
            *p -= 32;
        }
        p++;
    }

    // Ensure WINMGMT.EXE

    p = mod;
    while (*p)
    {
        if  (  p[0] != 0 && p[0] == 'W'
            && p[1] != 0 && p[1] == 'I'
            && p[2] != 0 && p[2] == 'N'
            && p[3] != 0 && p[3] == 'M'
            && p[4] != 0 && p[4] == 'G'
            && p[5] != 0 && p[5] == 'M'
            && p[6] != 0 && p[6] == 'T'
            )
        {
            g_bWinMgmt = TRUE;
            return TRUE;
        }
        p++;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\kernel33\stktrace.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    STKTRACE.CPP

Abstract:

	Symbolic stack trace

History:

	raymcc    27-May-99

--*/

#include <windows.h>
#include <imagehlp.h>

#include "kernel33.h"
#include "stktrace.h"


// Compiler bug workaround

void xstrcat(TCHAR *p1, TCHAR *p2)
{
    while (*p1++); p1--;
    while (*p1++ = *p2++);
}

static HANDLE s_hProcess = 0;
static HANDLE s_hPrivateHeap = 0;

// IMAGHLP.DLL Function pointers
// =============================

typedef BOOL (__stdcall *PFN_SymInitialize)(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    );

typedef PVOID (__stdcall *PFN_SymFunctionTableAccess)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef BOOL (__stdcall *PFN_SymGetSymFromAddr)(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );

typedef BOOL (__stdcall *PFN_SymGetLineFromAddr)(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    );

typedef DWORD (__stdcall *PFN_SymGetModuleBase)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    );

typedef BOOL (__stdcall *PFN_StackWalk)(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );


static PFN_SymInitialize            pfSymInitialize = 0;
static PFN_SymFunctionTableAccess   pfSymFunctionTableAccess = 0;
static PFN_SymGetSymFromAddr        pfSymGetSymFromAddr = 0;
static PFN_SymGetLineFromAddr       pfSymGetLineFromAddr = 0;
static PFN_SymGetModuleBase         pfSymGetModuleBase = 0;
static PFN_StackWalk                pfStackWalk = 0;

//***************************************************************************
//
//***************************************************************************

BOOL m_bActive = FALSE;

BOOL StackTrace_Init()
{
    if (m_bActive)          // Already running
        return TRUE;

    m_bActive = FALSE;

    TCHAR IniPath[MAX_PATH], buf[MAX_PATH], SymPath[MAX_PATH];
    *IniPath = 0;
    *buf = 0;
    *SymPath = 0;
    GetSystemDirectory(IniPath, MAX_PATH);
    xstrcat(IniPath, __TEXT("\\WBEM\\WMIDBG.INI"));  // Compiler bug workaround

    DWORD dwRes = GetPrivateProfileString(
        __TEXT("WMI DEBUG"),
        __TEXT("DLLNAME"),
        __TEXT(""),
        buf,
        MAX_PATH,
        IniPath
        );


    dwRes = GetPrivateProfileString(
        __TEXT("WMI DEBUG"),
        __TEXT("SYMPATH"),
        __TEXT(""),
        SymPath,
        MAX_PATH,
        IniPath
        );


    HMODULE hMod = LoadLibrary(buf);

    if (hMod == 0)
        return FALSE;

    pfSymInitialize = (PFN_SymInitialize) GetProcAddress(hMod, "SymInitialize");
    pfSymFunctionTableAccess = (PFN_SymFunctionTableAccess) GetProcAddress(hMod, "SymFunctionTableAddress");
    pfSymGetSymFromAddr = (PFN_SymGetSymFromAddr) GetProcAddress(hMod, "SymGetSymFromAddr");
    pfSymGetLineFromAddr = (PFN_SymGetLineFromAddr) GetProcAddress(hMod, "SymGetLineFromAddr");
    pfSymGetModuleBase = (PFN_SymGetModuleBase) GetProcAddress(hMod, "SymGetModuleBase");
    pfStackWalk = (PFN_StackWalk) GetProcAddress(hMod, "StackWalk");

    if (pfStackWalk == 0 || pfSymInitialize == 0 || pfSymGetSymFromAddr == 0)
    {
        FreeLibrary(hMod);
        return FALSE;
    }

    s_hProcess = GetCurrentProcess();
    s_hPrivateHeap = HeapCreate(0, 0x8000, 0);
	char chSymPath[MAX_PATH];
	lstrcpy(chSymPath, SymPath);

    BOOL bRes = pfSymInitialize(s_hProcess, chSymPath, TRUE);
    if (!bRes)
        return FALSE;
    m_bActive = TRUE;
    return TRUE;
}


//***************************************************************************
//
//***************************************************************************

//***************************************************************************
//
//***************************************************************************


BOOL StackTrace_GetSymbolByAddr(
    LPVOID pAddr,
    DWORD *pdwDisp,
    int nBufSize,
    char *pBuf
    )
{
    if (!m_bActive)
        return FALSE;

    BYTE Buf[256];
    char File[256];
    IMAGEHLP_SYMBOL *pSym = (IMAGEHLP_SYMBOL *) Buf;

    pSym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    pSym->Address = 0;
    pSym->Size = 0;
    pSym->Flags = 0;
    pSym->MaxNameLength = 128;
    pSym->Name[0] = 0;

    BOOL bRes = pfSymGetSymFromAddr(s_hProcess, DWORD(pAddr), pdwDisp, pSym);

    if (!bRes)
    {
        DWORD dwRes = GetLastError();
        if (dwRes == ERROR_INVALID_ADDRESS)
            lstrcpy(pBuf, "Invalid Address");
        else if (dwRes == ERROR_MOD_NOT_FOUND)
            lstrcpy(pBuf, "Error: Module Not Found");
        else
            wsprintf(pBuf, "Error: GetLastError() = %d\n", dwRes);
        return FALSE;
    }

    IMAGEHLP_LINE Line;
    Line.SizeOfStruct = sizeof(IMAGEHLP_LINE);
    Line.Key = 0;
    Line.LineNumber = 0;
    Line.FileName = File;
    Line.Address = 0;

    /*if (pfSymGetLineFromAddr)
    {
        bRes = pfSymGetLineFromAddr(s_hProcess, DWORD(pAddr), pdwDisp,  &Line);
        if (!bRes)
            return FALSE;
    }
    */

    lstrcpyn(pBuf, pSym->Name, nBufSize);

    return TRUE;
}

void StackTrace_Delete(StackTrace *pMem)
{
    pfnHeapFree(s_hPrivateHeap, 0, pMem);
}


//***************************************************************************
//
//***************************************************************************

void _FillMemory(LPVOID pMem, LONG lCount, BYTE b)
{
    LPBYTE pArray = LPBYTE(pMem);

    for (int i = 0; i < lCount; i++)
    {
        pArray[i] = b;
    }
}

//***************************************************************************
//
//***************************************************************************

StackTrace *StackTrace__NewTrace()
{
    if (!m_bActive)
        return NULL;

    HANDLE hThread = GetCurrentThread();

    // Get the thread context, registers, etc.
    // =======================================
    CONTEXT ctx;
    _FillMemory(&ctx, sizeof(ctx), 0);

    ctx.ContextFlags = CONTEXT_FULL;
    GetThreadContext(hThread, &ctx);

    // Set up the starting stack frame.
    // ================================
    STACKFRAME sf;
    _FillMemory(&sf, sizeof(sf), 0);

    sf.AddrPC.Offset       = ctx.Eip;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = ctx.Esp;
    sf.AddrStack.Mode      = AddrModeFlat;
    sf.AddrFrame.Offset    = ctx.Ebp;
    sf.AddrFrame.Mode      = AddrModeFlat;

    // Walk the stack.
    // ===============

    const  DWORD dwMaxAddresses = 128;
    DWORD Addresses[dwMaxAddresses];
    DWORD  dwNumAddresses = 0;

    for (int i = 0; ;i++)
    {
        BOOL bRes = pfStackWalk(
            IMAGE_FILE_MACHINE_I386,
            s_hProcess,
            hThread,
            &sf,
            &ctx,
            0,
            pfSymFunctionTableAccess,
            pfSymGetModuleBase,
            NULL
            );

        if (bRes == FALSE)
            break;

        if (i == 0)
            continue;   // Skip the StackWalk frame itself

        if (sf.AddrPC.Offset == 0)
            break;

        Addresses[dwNumAddresses++] = sf.AddrPC.Offset;
        if (dwNumAddresses == dwMaxAddresses)
            break;
    }

    // Now, allocate a StackTrace struct to return to user.
    // ====================================================

    StackTrace *pTrace = (StackTrace *) pfnHeapAlloc(s_hPrivateHeap, HEAP_ZERO_MEMORY,
        sizeof(StackTrace) + sizeof(DWORD) * dwNumAddresses - 1);

    pTrace->m_dwCount = dwNumAddresses;

    for (DWORD dwIx = 0; dwIx < dwNumAddresses; dwIx++)
        pTrace->m_dwAddresses[dwIx] = Addresses[dwIx];

    return pTrace;
}

//***************************************************************************
//
//***************************************************************************


char *StackTrace_Dump(StackTrace *pTrace)
{
    if (!m_bActive)
        return 0;

    char Buf[64];
    char Buf2[256];
    static char Buf3[8192];
    *Buf3 = 0;

    lstrcat(Buf, "---block---\r\n");

    for (DWORD dwIx = 0; dwIx < pTrace->m_dwCount; dwIx++)
    {
        DWORD dwAddress = pTrace->m_dwAddresses[dwIx];

        wsprintf(Buf, "      0x%08x ", dwAddress);

        ///////////////

        char Name[128];
        lstrcpy(Name, "<no symbol>\n");
        DWORD dwDisp;
        *Name = 0;
        StackTrace_GetSymbolByAddr(LPVOID(dwAddress), &dwDisp, 127, Name);

        ////////////

        wsprintf(Buf2, "%s disp=0x%04x <%s>\r\n", Buf, dwDisp, Name);
        lstrcat(Buf3, Buf2);
    }

    return Buf3;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\conscript\conscript.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADDRESLV.H

Abstract:

History:

--*/

//***************************************************************************
//
//  test.cpp 
//
//  Module: test.exe
//
//
//***************************************************************************

#include <windows.h>                                     
#include <stdio.h>
#include <initguid.h> 
#include "script.h"
#include <activscp.h>
#include <string.h>
#include <io.h> 
#include <fcntl.h>
#include <sys/stat.h>

#define LOCATOR L"Locator"


class CScriptSite : public IActiveScriptSite, public IActiveScriptSiteWindow
{
protected:
    long m_lRef;
    HWND m_hWnd;
    IDispatch* m_pObject;
//    CScriptSink* m_pSink;
public:
    CScriptSite(HWND hWnd, IDispatch * pObject); 
    ~CScriptSite();

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    
    virtual HRESULT STDMETHODCALLTYPE GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid);

    virtual HRESULT STDMETHODCALLTYPE GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);

    virtual HRESULT STDMETHODCALLTYPE GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion);

    virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);

    virtual HRESULT STDMETHODCALLTYPE OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState);

    virtual HRESULT STDMETHODCALLTYPE OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror);

    virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void);

    virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void);

    virtual HRESULT STDMETHODCALLTYPE GetWindow(
        /* [out] */ HWND __RPC_FAR *phwnd);

    virtual HRESULT STDMETHODCALLTYPE EnableModeless(
        /* [in] */ BOOL fEnable);

};

CScriptSite::CScriptSite(HWND hWnd, IDispatch * pObject)
{
    m_hWnd = hWnd;
    m_lRef = 0;
    m_pObject = pObject;
    pObject->AddRef();
}

CScriptSite::~CScriptSite()
{
    m_pObject->Release();
}

HRESULT STDMETHODCALLTYPE CScriptSite::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IActiveScriptSite)
        *ppv = (IActiveScriptSite*)this;
    else if(riid == IID_IActiveScriptSiteWindow)
        *ppv = (IActiveScriptSiteWindow*)this;
    else
        return E_NOINTERFACE;
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CScriptSite::AddRef() 
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CScriptSite::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}
        


HRESULT STDMETHODCALLTYPE CScriptSite::GetLCID(
        /* [out] */ LCID __RPC_FAR *plcid)
{ 
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CScriptSite::GetItemInfo(
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti)
{ 
    if(_wcsicmp(pstrName, LOCATOR))
        return TYPE_E_ELEMENTNOTFOUND;
    if(ppti)
        *ppti = NULL;
    if(ppiunkItem)
        *ppiunkItem = NULL;

    if(dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if(ppiunkItem == NULL)
            return E_POINTER;
        m_pObject->QueryInterface(IID_IUnknown, (void**)ppiunkItem);
    }
    
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::GetDocVersionString(
        /* [out] */ BSTR __RPC_FAR *pbstrVersion)
{ return E_NOTIMPL;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnScriptTerminate(
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnStateChange(
        /* [in] */ SCRIPTSTATE ssScriptState)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnScriptError(
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror)
{ 
    HRESULT hres;
    EXCEPINFO ei;
    hres = pscripterror->GetExceptionInfo(&ei);
    if(SUCCEEDED(hres))
    {

        printf("\nGot Error from source %S", ei.bstrSource);
        printf("\nDescription is %S", ei.bstrDescription);
        printf("\nThe error code is 0x%x", ei.scode);
        DWORD dwLine, dwCookie;
        long lChar;
        pscripterror->GetSourcePosition(&dwCookie, &dwLine, &lChar);
        printf("\nError occured on line %d, character %d", dwLine, lChar);
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::OnEnterScript( void)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::OnLeaveScript( void)
{ return S_OK;}

HRESULT STDMETHODCALLTYPE CScriptSite::GetWindow(
    /* [out] */ HWND __RPC_FAR *phwnd)
{
    *phwnd = NULL;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CScriptSite::EnableModeless(
    /* [in] */ BOOL fEnable)
{return S_OK;}

LPWSTR pScriptText = L"MsgBox(\"hello\")\n"
                   L"dim services\n"
                   L"dim class\n"
                   L"dim property\n"
                   L"dim vartype\n"
                   L"Text = \"root\"\n"
                   L"Set services = nothing\n"
                   L"Set Class = nothing\n"
                   L"Locator.ConnectServer Text, \"\" , \"\", \"\", 0, VT_Null, nothing, services\n"
                   L"services.GetObject \"__win32provider\", 0, nothing, Class, nothing\n"
                   L"class.Get \"__Class\",0, property, vartype, 0\n"
                   L"MsgBox(vartype)";


WCHAR * ReadFile(char * pFileName)
{
    FILE *fp;
    BOOL bUnicode = FALSE;
    BOOL bBigEndian = FALSE;

    // Make sure the file exists and can be opened

    fp = fopen(pFileName, "rb");
    if (!fp)
    {
        printf("\nCant open file %s", pFileName);
        return NULL;
    }

    // Determine the size of the file
    // ==============================
    
    fseek(fp, 0, SEEK_END);
    long lSize = ftell(fp) + 4; // add a bit extra for ending space and null NULL
    fseek(fp, 0, SEEK_SET);

    // Check for UNICODE source file.
    // ==============================

    BYTE UnicodeSignature[2];
    if (fread(UnicodeSignature, sizeof(BYTE), 2, fp) != 2)
    {
        printf("\nNothing in file %s", pFileName);
        fclose(fp);
        return NULL;
    }

    if (UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE)
    {
        LPWSTR pRet = new WCHAR[lSize/2 +2];
        if(pRet == NULL)
            return NULL;
        fread(pRet, 1, lSize-2, fp);
        fclose(fp);
        return pRet;
    }

    else
    {
        fseek(fp, 0, SEEK_SET);
        LPSTR pTemp = new char[lSize+1];
        LPWSTR pRet = new WCHAR[lSize+1];
        if(pRet == NULL || pTemp == NULL)
            return NULL;
        fread(pTemp, 1, lSize, fp);
        fclose(fp);
        mbstowcs(pRet, pTemp, lSize);
        delete pTemp;
        return pRet;

    }

    return NULL;

}


//***************************************************************************
//
// main
//
// Purpose: Initialized Ole, calls some test code, cleans up and exits.
//
//***************************************************************************
 
int main(int iArgCnt, char ** argv)
{

    if(iArgCnt != 2)
    {
        printf("\nUsage c:\\conscript scriptfile");
        return 1;
    }

    LPWSTR pScriptText = ReadFile(argv[1]);
    if(pScriptText == NULL)
        return 1;

    HRESULT sc = CoInitialize(0);

    CLSID clsid;

    // Get the DIWbemLocator

    IDispatch * pLocator = NULL;

    sc = CLSIDFromString(L"{CB7CA032-F729-11D0-9E4D-00C04FC324A8}", &clsid);  
    sc = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IDispatch, (void **)&pLocator);
    if(FAILED(sc))
        return 1;

    // Get the scripting engine

    sc = CLSIDFromString(L"{B54F3741-5B07-11cf-A4B0-00AA004A55E8}", &clsid);

    IClassFactory * pFactory = NULL;
    sc = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                NULL, IID_IClassFactory, (void**)&pFactory);
    if(FAILED(sc))
        return 1;

    IActiveScript* pScript;
    sc = pFactory->CreateInstance(NULL, IID_IActiveScript,
            (void**)&pScript);
    if(FAILED(sc))
        return 1;

    IActiveScriptParse* pParse;
    sc = pScript->QueryInterface(IID_IActiveScriptParse, (void**)&pParse);
    if(FAILED(sc))
        return 1;

    sc = pParse->InitNew();

    // Create the scripting site

    CScriptSite* pSite = new CScriptSite(NULL, pLocator);
    pSite->AddRef();
    pLocator->Release();
    sc = pScript->SetScriptSite(pSite);
    pSite->Release();
    
    sc = pScript->AddNamedItem(LOCATOR, 
        SCRIPTITEM_ISVISIBLE | SCRIPTITEM_NOCODE);
    if(FAILED(sc))
        return 1;

  
    EXCEPINFO ei;
    sc = pParse->ParseScriptText(
        pScriptText,
        NULL, NULL, NULL, 
        0, 0, 0, NULL, &ei);
    if(FAILED(sc))
        return 1;

    pParse->Release();

    sc = pScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if(FAILED(sc))
        return 1;

    pScript->Release();

    CoUninitialize();
    printf("Terminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\addrrslv\ipx\addreslv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ADDRESLV.H

Abstract:

History:

--*/

#ifndef __ADDRESLV_H__
#define __ADDRESLV_H__

// {1721389E-974F-11d1-AB80-00C04FD9159E}
DEFINE_GUID(UUID_IPXAddrType, 
0x1721389e, 0x974f, 0x11d1, 0xab, 0x80, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);

// {1721389F-974F-11d1-AB80-00C04FD9159E}
DEFINE_GUID(CLSID_IWbemIPXAddressReolver, 
0x1721389f, 0x974f, 0x11d1, 0xab, 0x80, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);


class CIPXAddressResolver : public IWbemAddressResolution
{
protected:

	long            m_cRef;         //Object reference count

public:
    
    CIPXAddressResolver () ;
    ~CIPXAddressResolver () ;

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* IWbemAddressResolution methods */
 
    HRESULT STDMETHODCALLTYPE Resolve ( 

		LPWSTR pszNamespacePath,
        LPWSTR pszAddressType,
        DWORD __RPC_FAR *pdwAddressLength,
        BYTE __RPC_FAR **pbBinaryAddress
	) ;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\addrrslv\ipx\addreslv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ADDRESLV.CPP

Abstract:

History:

--*/

#include <winsock.h>
#include <windows.h>
#include "addreslv.h"

#define IsSlash(x)			(x == L'\\' || x== L'/')

#define MAX_IPX_TEXT_LEN	22
#define IPX_ADDR_LEN		10
#define IPX_MAX_PACKET		576
#define SAP_ENTRY_LEN		66
#define SAP_OPERATION_LEN	2
#define SAP_SRVCTYP_LEN		4
#define SAP_NAME_LEN		48
#define SAP_SOCK_AND_HOP	4

//***************************************************************************
//
//  WCHAR *ExtractMachineName
//
//  DESCRIPTION:
//
//  Takes a path of form "\\machine\xyz... and returns the
//  "machine" portion in a newly allocated WCHAR.  The return value should
//  be freed via delete. NULL is returned if there is an error.
//
//
//  PARAMETERS:
//
//  pPath               Path to be parsed.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

WCHAR *ExtractMachineName ( IN BSTR a_Path )
{
    WCHAR *t_MachineName = NULL;

#if 0
//the function which calls this function returns before calling this
//function if the path is NULL, so we don't need to check for this!

    //todo, according to the help file, the path can be null which is
    // default to current machine, however Ray's mail indicated that may
    // not be so.

    if ( a_Path == NULL )
    {
        t_MachineName = new WCHAR [ 2 ] ;
        if ( t_MachineName )
		{
           wcscpy ( t_MachineName , L"." ) ;
		}

        return t_MachineName ;
    }
#endif

    // First make sure there is a path and determine how long it is.

    if ( ! IsSlash ( a_Path [ 0 ] ) || ! IsSlash ( a_Path [ 1 ] ) || wcslen ( a_Path ) < 3 )
    {
        t_MachineName = new WCHAR [ 2 ] ;

        if ( t_MachineName )
		{
             wcscpy ( t_MachineName , L"." ) ;
		}

        return t_MachineName ;
    }

    WCHAR *t_ThirdSlash ;

    for ( t_ThirdSlash = a_Path + 2 ; *t_ThirdSlash ; t_ThirdSlash ++ )
	{
        if ( IsSlash ( *t_ThirdSlash ) )
            break ;
	}

    if ( t_ThirdSlash == &a_Path [2] )
	{
        return NULL;
	}

    // allocate some memory

    t_MachineName = new WCHAR [ t_ThirdSlash - a_Path - 1 ] ;

    if ( t_MachineName == NULL )
	{
        return t_MachineName ;
	}

    // temporarily replace the third slash with a null and then copy

	WCHAR t_SlashCharacter = *t_ThirdSlash ;
    *t_ThirdSlash = NULL;

    wcscpy ( t_MachineName , a_Path + 2 ) ;

    *t_ThirdSlash  = t_SlashCharacter ;        // restore it.

    return t_MachineName ;
}

static UCHAR HexToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else if ( token >= 'a' && token <= 'f' )
	{
		return token - 'a' + 10 ;
	}
	else if ( token >= 'A' && token <= 'F' )
	{
		return token - 'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

BOOL DoBroadcastMatchResult(const char* a_machine, BYTE* field)
{
	BOOL ret = FALSE;
	SOCKET ipxSocket = socket (AF_IPX, SOCK_DGRAM, PF_IPX);
	int retry_val = 1;
	int timeout_val = 5;

	if (ipxSocket != SOCKET_ERROR) 
	{
		int broadcast = TRUE ;

		UINT status = setsockopt(ipxSocket, SOL_SOCKET,
								SO_BROADCAST, (char *)&broadcast,
								sizeof(int));

		if (status != SOCKET_ERROR)
		{
			struct sockaddr addr;
			addr.sa_family = AF_IPX;
			memset(addr.sadata, 0, 14);
			status = bind(ipxSocket, &addr, sizeof(sockaddr));

			if (status != SOCKET_ERROR)
			{
				USHORT sapQuery[2];
				sapQuery[0] = htons(1); //all servers
				sapQuery[1] = -1;		//wildcard
				addr.sadata = {0x00, 0x00, 0x00, 0x00,					//network
								0xff, 0xff, 0xff , 0xff , 0xff , 0xff,	//node
								0x04, 0x52};							//socket

				for (int x = 0; (x < (1 + retry_val)) && !ret; x++)
				{
					status = sendto(ipxSocket ,(char *)sapQuery, 4,
									0, &addr, sizeof(sockaddr));

					if (status != SOCKET_ERROR)
					{
						struct _timeb timeStart;
						_ftime(&timeStart);
						fd_set stRd;
						FD_ZERO((fd_set *)&stRd);
						FD_SET(ipxSocket, &stRd);
						struct timeval stTimeOut;
						stTimeOut.tv_sec = timeout_val;
						stTimeOut.tv_usec = 0;
						status = select(-1,NULL, &stRd, NULL, &stTimeOut); 

						while ((status != SOCKET_ERROR) && (status != 0))
						{
							//get results of select...
							char packet [IPX_MAX_PACKET];
							int datalen = recv(ipxSocket, (char FAR*)&packet, IPX_MAX_PACKET, 0);
							
							//ignore operation(2bytes)
							datalen -= SAP_OPERATION_LEN;
							char* sapEntry = packet + SAP_OPERATION_LEN; 

							while ((datalen > 0) && (datalen != SOCKET_ERROR))
							{
								//ignore service type(4bytes)
								sapEntry += SAP_SRVCTYP_LEN;

								//skip to the name
								if (strnicmp(sapEntry, a_machine, SAP_NAME_LEN) == 0)
								{
									if (!ret)
									{
										sapEntry += SAP_NAME_LEN;
										memcpy((void*) field, (void*)sapEntry, IPX_ADDR_LEN);
										sapEntry += IPX_ADDR_LEN + SAP_SOCK_AND_HOP;
										ret = TRUE;
									}
									else
									{
										MessageBox(NULL, "IPX RESOLUTION: Multiple addresses", a_machine, MB_OK);
									}
								}
								else
								{
									sapEntry += (SAP_NAME_LEN + IPX_ADDR_LEN + SAP_SOCK_AND_HOP);
								}

								//set datalen and sapEntry to next entry
								datalen -= SAP_ENTRY_LEN;
							}

							struct _timeb timeNow;
							_ftime(&timeNow);
							
							if (timeNow.millitm < timeStart.millitm)
							{
								timeNow.time -= 1;
								timeNow.millitm += 1000;
							}
							
							timeNow.millitm -= timeStart.millitm;
							timeNow.time -= timeStart.time;

							if (stTimeOut.tv_usec < timeNow.millitm)
							{
								if (stTimeOut.tv_sec < 1)
								{
									break;
								}

								stTimeOut.tv_sec -= 1;
								stTimeOut.tv_usec += 1000;
							}

							if (stTimeOut.tv_sec < timeNow.time)
							{
								break;
							}
							else
							{
								stTimeOut.tv_sec -= timeNow.time
							}
							
							stTimeOut.tv_usec -= timeNow.millitm;

							if (stTimeOut.tv_usec == 0) && (stTimeOut.tv_sec== 0))
							{
								break;
							}

							status = select(-1,NULL, &stRd, NULL, &stTimeOut); 
						}
					}
				}
			}
		}

		closesocket(ipxSocket);
	}
	
	return ret;
}

BOOL GetIPXAddress (const wchar_t *w_addr, BYTE* field )
{

	if ( (w_addr == NULL) || (wcslen(w_addr) > MAX_IPX_TEXT_LEN))
	{
		return NULL;
	}

	char ch_addr[MAX_IPX_TEXT_LEN];
	
	if (-1 == wcstombs(ch_addr, w_addr))
	{
		return NULL;
	}
	
	// create a stream to read the fields from
	istrstream address_stream(ch_addr);
	address_stream.setf ( ios :: hex ) ;
	BOOL is_valid = TRUE ;
	ULONG t_NetworkAddress ;
	address_stream >> t_NetworkAddress ;

	if ( address_stream.good() )
	{
		field [ 0 ] = ( t_NetworkAddress >> 24 ) & 0xff ;
		field [ 1 ] = ( t_NetworkAddress >> 16 ) & 0xff ;
		field [ 2 ] = ( t_NetworkAddress >> 8 ) & 0xff ;
		field [ 3 ] = t_NetworkAddress & 0xff ;

	// consecutive fields must be separated by a
	// FIELD_SEPARATOR
		char separator;

		address_stream >> separator;
		if ( separator == ':' )
		{
			ULONG t_StationOctets = 0 ;

			while ( is_valid && t_StationOctets < 6 )
			{
				int t_OctetHigh = address_stream.get () ;
				int t_OctetLow = address_stream.get () ;

				if ( isxdigit ( t_OctetHigh ) && isxdigit ( t_OctetLow ) )
				{
					UCHAR t_Octet = ( HexToDecInteger ( t_OctetHigh ) << 4 ) + HexToDecInteger ( t_OctetLow ) ;
					field [ 4 + t_StationOctets ] = t_Octet ;
					t_StationOctets ++ ;
				}
				else
				{
					is_valid = FALSE ;
				}
			}

			if ( t_StationOctets != 6 )
			{
				is_valid = FALSE ;
			}
		}

		if ( address_stream.eof() )
		{
			is_valid = TRUE;
		}
	}
	else
	{
		is_valid = FALSE ;
	}

	return is_valid ;
}


//***************************************************************************
//
//  CIPXAddressResolver::CIPXAddressResolver
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CIPXAddressResolver::CIPXAddressResolver()
{
    m_cRef=0;
}

//***************************************************************************
//
//  CIPXAddressResolver::~CIPXAddressResolver
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CIPXAddressResolver::~CIPXAddressResolver(void)
{
}

//***************************************************************************
// HRESULT CIPXAddressResolver::QueryInterface
// long CIPXAddressResolver::AddRef
// long CIPXAddressResolver::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CIPXAddressResolver::QueryInterface (

	IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    
    if (IID_IUnknown==riid || riid == IID_IWbemAddressResolution)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CIPXAddressResolver::AddRef(void)
{
    return(InterlockedIncrement(&m_cRef));
}

STDMETHODIMP_(ULONG) CIPXAddressResolver::Release(void)
{
	ULONG ret = InterlockedDecrement(&m_cRef);

    if (0 == ret)
	{
		delete this;
	}

    return ret;
}

SCODE CIPXAddressResolver::Resolve (
 
	LPWSTR pszNamespacePath,
	LPWSTR pszAddressType,
	DWORD __RPC_FAR *pdwAddressLength,
	BYTE __RPC_FAR **pbBinaryAddress
)
{
	BOOL t_Status = (pszNamespacePath == NULL) || 
					(pdwAddressLength== NULL) || 
					(pbBinaryAddress == NULL) ||
					(pszAddressType == NULL);

    if ( t_Status )
	{
        return WBEM_E_INVALID_PARAMETER;
	}

    GUID gAddr;
    CLSIDFromString(pszAddressType, &gAddr);
	t_Status = (gAddr != UUID_LocalAddrType) && (gAddr != UUID_IPXAddrType);
 
	if ( t_Status )
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	WCHAR *t_ServerMachine = ExtractMachineName (pszNamespacePath) ;

	if ( t_ServerMachine == NULL )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	HRESULT t_Result = S_OK ;

	if ( wcscmp ( t_ServerMachine , L"." ) == 0 )
	{
		if ( gAddr == UUID_LocalAddrType )
		{
			*pbBinaryAddress = (BYTE *)CoTaskMemAlloc(8);

			if(*pbBinaryAddress == NULL)
			{
				delete [] t_ServerMachine ;
				return WBEM_E_FAILED;
			}

			wcscpy((LPWSTR)*pbBinaryAddress, L"\\\\.");
			*pdwAddressLength = 8;
			delete [] t_ServerMachine ;
			return t_Result ;
		}
		else
		{
			delete [] t_ServerMachine ;
			return WBEM_E_FAILED ;
		}
	}

	char t_LocalMachine [MAX_PATH];
	DWORD t_LocalMachineSize = MAX_PATH;

	if ( !GetComputerName ( t_LocalMachine , & t_LocalMachineSize ) )
	{
		return WBEM_E_FAILED;
	}

	char *t_AsciiServer = new char [ wcslen ( t_ServerMachine ) * 2 + 1 ] ;
	sprintf ( t_AsciiServer , "%S" , t_ServerMachine ) ;

    delete [] t_ServerMachine;

	BOOL status = FALSE ;
	WORD wVersionRequested;  
	WSADATA wsaData; 

	wVersionRequested = MAKEWORD(1, 1); 
	status = ( WSAStartup ( wVersionRequested , &wsaData ) == 0 ) ;
	BOOL blocal = TRUE;
	
	if ( status ) 
	{
		BYTE ipxAddr[IPX_ADDR_LEN];

		if ( GetIPXAddress(t_AsciiServer, ipxAddr) ) 
		{
			//do directed ping

			if ( //got response from directed ping ) 
			{
				if ( stricmp ( t_LocalMachine , //respond_machine ) == 0 )
				{
					if ( gAddr == UUID_LocalAddrType )
					{
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
					}
				}
				else
				{
					if ( gAddr == UUID_IPXAddrType )
					{
						blocal = FALSE;
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
					}
				}
			}
		}
		else
		{
			if ( stricmp (t_LocalMachine, t_AsciiServer) == 0 ) 
			{
				if ( gAddr == UUID_LocalAddrType )
				{
				}
				else
				{
					t_Result = WBEM_E_FAILED ;
				}
			}
			else if (gAddr == UUID_IWbemAddressResolver_Tcpip)
			{
				//Do Broadcast, match t_AsciiServer, ipxAddr

				if ( //got a match )
				{
					blocal = FALSE;
				}
				else
				{
					t_Result = WBEM_E_FAILED ;
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
		}

		WSACleanup () ;
	}

	delete [] t_AsciiServer ;

	if (S_OK == t_Result)
	{
		if (blocal)
		{
			*pbBinaryAddress = (BYTE *)CoTaskMemAlloc(8);

			if(*pbBinaryAddress == NULL)
			{
				delete [] t_ServerMachine ;
				return WBEM_E_FAILED;
			}

			wcscpy((LPWSTR)*pbBinaryAddress, L"\\\\.");
			*pdwAddressLength = 8;
		}
		else
		{
			//copy address and return it
			*pbBinaryAddress = (BYTE *)CoTaskMemAlloc(IPX_ADDR_LEN);

			if(*pbBinaryAddress == NULL)
			{
				delete [] t_AsciiServer ;
				return WBEM_E_FAILED;
			}

			memcpy((void*)*pbBinaryAddress, (void*)ipxAddr, IPX_ADDR_LEN);
			*pdwAddressLength = IPX_ADDR_LEN;
		}
	}

    return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\callsec.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.H

Abstract:


History:

    raymcc      29-Jul-98        First draft.

--*/


#ifndef _CALLSEC_H_
#define _CALLSEC_H_

// {4551AB1A-C16F-40f3-A192-6A6264FE89D6}
DEFINE_GUID(IID_CWbemCallSecurity, 
0x4551ab1a, 0xc16f, 0x40f3, 0xa1, 0x92, 0x6a, 0x62, 0x64, 0xfe, 0x89, 0xd6);

// {60B9F5CA-036E-4795-BB7C-017B9807E9B3}
DEFINE_GUID(IID_CWbemThreadSecurityHandle, 
0x60b9f5ca, 0x36e, 0x4795, 0xbb, 0x7c, 0x1, 0x7b, 0x98, 0x7, 0xe9, 0xb3);


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl ;

class COREPROX_POLARITY CWbemThreadSecurityHandle : public _IWmiThreadSecHandle
{
private:

    LONG m_ReferenceCount ;

    HANDLE m_ThreadToken ;
    DWORD m_ImpersonationLevel ;
	DWORD m_AuthenticationService ;
	DWORD m_AuthorizationService ;
	DWORD m_AuthenticationLevel ;
	LPWSTR m_ServerPrincipalName ;
	LPWSTR m_Identity ;

	WMI_THREAD_SECURITY_ORIGIN m_Origin ;

	CLifeControl *m_Control ;

public:

    CWbemThreadSecurityHandle ( CLifeControl *a_Control ) ;
	CWbemThreadSecurityHandle ( const CWbemThreadSecurityHandle &a_Copy ) ;
   ~CWbemThreadSecurityHandle () ;

    CWbemThreadSecurityHandle &operator= ( const CWbemThreadSecurityHandle &a_Copy ) ;

	HRESULT CloneRpcContext (

		IServerSecurity *a_Security
	) ;

	HRESULT CloneThreadContext () ;

	HRESULT CloneProcessContext () ;

/*
 * IUnknown.
 */

    ULONG STDMETHODCALLTYPE AddRef () ;
    ULONG STDMETHODCALLTYPE Release () ;
    HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID a_Riid , void **a_Void ) ;

/*
 *
 */

	HRESULT STDMETHODCALLTYPE GetHandleType ( ULONG *a_Type ) { return WMI_HANDLE_THREAD_SECURITY; }

	HRESULT STDMETHODCALLTYPE GetTokenOrigin ( WMI_THREAD_SECURITY_ORIGIN *a_Origin ) { return m_Origin ; }

/*
 *	_IWmiThreadSecHandle
 */

    HRESULT STDMETHODCALLTYPE GetImpersonation (

		DWORD *a_Level
	) ;

	HRESULT STDMETHODCALLTYPE GetAuthentication (
	
		DWORD *a_Level
	) ;

    HRESULT STDMETHODCALLTYPE GetUser (

        ULONG *a_Size ,
        LPWSTR a_Buffer
	) ;

    HRESULT STDMETHODCALLTYPE GetUserSid (

		ULONG *a_Size ,
		PSID a_Sid
	) ;

    HRESULT STDMETHODCALLTYPE GetToken ( HANDLE *a_ThreadToken ) ;

    HRESULT STDMETHODCALLTYPE GetAuthenticationLuid ( LPVOID a_Luid ) ;

/*
 * Implementation publics
 */

    HANDLE GetThreadToken () { return m_ThreadToken ; }
    DWORD GetImpersonationLevel () { return m_ImpersonationLevel ; }
	DWORD GetAuthenticationService () { return m_AuthenticationService ; }
	DWORD GetAuthorizationService () { return m_AuthorizationService ; }
	DWORD GetAuthenticationLevel () { return m_AuthenticationLevel ; }
	LPWSTR GetServerPrincipalName () { return m_ServerPrincipalName ; }
	LPWSTR GetIdentity () { return m_Identity ; }

	void SetOrigin ( WMI_THREAD_SECURITY_ORIGIN a_Origin ) { m_Origin = a_Origin ; }

	static CWbemThreadSecurityHandle *New () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl ;

class COREPROX_POLARITY CWbemCallSecurity : public IServerSecurity  , public _IWmiCallSec
{
private:

    LONG m_ReferenceCount ;
	DWORD m_ImpersonationLevel ;
	CWbemThreadSecurityHandle *m_ThreadSecurityHandle ;
	HANDLE m_ThreadToken ;

	CLifeControl *m_Control ;

public:

	CWbemCallSecurity ( CLifeControl *a_Control ) ;
   ~CWbemCallSecurity () ;

    CWbemCallSecurity &operator= ( const CWbemCallSecurity &a_Copy ) ;

public:

	CWbemThreadSecurityHandle *GetThreadSecurityHandle () { return m_ThreadSecurityHandle ; }

/*
 * IUnknown.
 */

    ULONG STDMETHODCALLTYPE AddRef () ;
    ULONG STDMETHODCALLTYPE Release () ;
    HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID a_Riid , void **a_Void ) ;

/*
 * IServerSecurity.
 */

    HRESULT STDMETHODCALLTYPE QueryBlanket (

		DWORD *a_AuthenticationService ,
		DWORD *a_AuthorizationService ,
		OLECHAR **a_ServerPrincipleName ,
		DWORD *a_AuthorizationLevel ,
		DWORD *a_ImpersonationLevel ,
		void **a_Privileges ,
		DWORD *a_Capabilities
	) ;

	HRESULT STDMETHODCALLTYPE ImpersonateClient () ;

	HRESULT STDMETHODCALLTYPE RevertToSelf () ;

	BOOL STDMETHODCALLTYPE IsImpersonating () ;

/*
 *	_IWmiCallSec
 */

    HRESULT STDMETHODCALLTYPE GetImpersonation (

        DWORD *a_Level
	) ;

	HRESULT STDMETHODCALLTYPE GetAuthentication (
	
		DWORD *a_Level
	) ;

    HRESULT STDMETHODCALLTYPE GetUser (

        ULONG *a_Size ,
        LPWSTR a_Buffer
	) ;

    HRESULT STDMETHODCALLTYPE GetUserSid (

		ULONG *a_Size ,
		PSID a_Sid
	) ;

    HRESULT STDMETHODCALLTYPE GetAuthenticationLuid ( LPVOID a_Luid ) ;

    HRESULT STDMETHODCALLTYPE GetThreadSecurity ( WMI_THREAD_SECURITY_ORIGIN a_Origin , _IWmiThreadSecHandle **a_ThreadSecurity ) ;

    HRESULT STDMETHODCALLTYPE SetThreadSecurity ( _IWmiThreadSecHandle *a_ThreadSecurity ) ;

	static CWbemCallSecurity *New () ;
} ;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\callsec.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.CPP

Abstract:

History:

    raymcc      29-Jul-98        First draft.

--*/

#include "precomp.h"
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <stdio.h>
#include <Aclapi.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include "CallSec.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT IsNetworkLogin (

	HANDLE a_Token ,
	BOOL &a_Truth 
)
{
	HRESULT t_Result = S_OK ;

	PSID t_NetworkSid = NULL ;

    SID_IDENTIFIER_AUTHORITY t_NtAuthority = SECURITY_NT_AUTHORITY ;
    BOOL t_Status = AllocateAndInitializeSid (

        &t_NtAuthority,
        1,
        SECURITY_NETWORK_RID,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        & t_NetworkSid
    ) ;

    if ( t_Status )
    {
		t_Status = CheckTokenMembership ( a_Token, t_NetworkSid, & a_Truth ) ;
		if ( t_Status ) 
		{
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}

		FreeSid ( t_NetworkSid ) ;
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetImpersonationLevel (

	HANDLE a_Token ,
	SECURITY_IMPERSONATION_LEVEL &a_Level ,
	TOKEN_TYPE &a_TokenType
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_ReturnLength = 0 ;
	BOOL t_TokenStatus = GetTokenInformation (

		a_Token ,
		TokenType ,
		( void * ) & a_TokenType ,
		sizeof ( a_TokenType ) ,
		& t_ReturnLength
	) ;

	if ( t_TokenStatus )
	{
		if ( a_TokenType == TokenImpersonation )
		{
			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				TokenImpersonationLevel ,
				( void * ) & a_Level ,
				sizeof ( a_Level ) ,
				& t_ReturnLength
			) ;

			if ( t_TokenStatus )
			{
				t_Result = S_OK ;
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetUserSid (

	HANDLE a_Token ,
	ULONG *a_Size ,
	PSID a_Sid
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( a_Token )
	{
		if ( a_Size ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						if ( a_Sid )
						{
							if ( *a_Size >= t_ReturnLength )
							{
								t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;
								if ( t_TokenUser )
								{
									t_TokenStatus = GetTokenInformation (

										a_Token ,
										t_TokenInformationClass ,
										t_TokenUser ,
										t_ReturnLength ,
										& t_ReturnLength
									) ;

									if ( t_TokenStatus )
									{
										DWORD t_SidLength = GetLengthSid ( t_TokenUser->User.Sid ) ;
										*a_Size = t_SidLength ;

										CopyMemory ( a_Sid , t_TokenUser->User.Sid , t_SidLength ) ;

										t_Result = S_OK ;
									}

									delete [] t_TokenUser ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_BUFFER_TOO_SMALL ;
							}
						}
						else
						{
							*a_Size = t_ReturnLength ;

							t_Result = S_OK ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetUser (

	HANDLE a_Token ,
    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

    if ( a_Token )
	{
		if ( a_Size && a_Buffer ) 
		{
			TOKEN_USER *t_TokenUser = NULL ;
			DWORD t_ReturnLength = 0 ;
			TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

			BOOL t_TokenStatus = GetTokenInformation (

				a_Token ,
				t_TokenInformationClass ,
				t_TokenUser ,
				t_ReturnLength ,
				& t_ReturnLength
			) ;

			if ( ! t_TokenStatus )
			{
				DWORD t_LastError = GetLastError () ;
				switch ( t_LastError ) 
				{
					case ERROR_INSUFFICIENT_BUFFER:
					{
						t_TokenUser = ( TOKEN_USER * ) new BYTE [ t_ReturnLength ] ;

						t_TokenStatus = GetTokenInformation (

							a_Token ,
							t_TokenInformationClass ,
							t_TokenUser ,
							t_ReturnLength ,
							& t_ReturnLength
						) ;
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

			if ( t_TokenStatus )
			{
				SID_NAME_USE t_SidNameUse ;
				wchar_t *t_Domain = NULL ;
				wchar_t *t_User = NULL ;
				ULONG t_DomainSize = 0 ;
				ULONG t_UserSize = 0 ;

				BOOL t_LookupStatus = LookupAccountSidW (

					NULL ,
					t_TokenUser->User.Sid ,
					t_User ,
					& t_UserSize ,
					t_Domain ,
					& t_DomainSize ,
					& t_SidNameUse
				) ;

				if ( ! t_LookupStatus )
				{
					DWORD t_LastError = GetLastError () ;

					switch ( t_LastError ) 
					{
						case ERROR_INSUFFICIENT_BUFFER:
						{
							t_User = new wchar_t [ t_UserSize ] ;
							if ( t_User )
							{
								t_Domain = new wchar_t [ t_DomainSize ] ;
								if ( t_Domain ) 
								{
									t_LookupStatus = LookupAccountSidW (

										NULL ,
										t_TokenUser->User.Sid ,
										t_User ,
										& t_UserSize ,
										t_Domain ,
										& t_DomainSize ,
										& t_SidNameUse
									) ;

									if ( t_LookupStatus )
									{
										ULONG t_Size = wcslen ( t_User ) + wcslen ( t_Domain ) + 2 ;

										if ( *a_Size >= t_Size )
										{
											swprintf ( a_Buffer , L"%s\\%s" , t_Domain , t_User ) ;
										}
										else
										{
											t_Result = WBEM_E_BUFFER_TOO_SMALL ;
										}

										*a_Size = t_Size ;
									}
									else
									{
										if ( GetLastError () == ERROR_NONE_MAPPED )
										{
											t_Result = WBEM_E_NOT_FOUND ;
										}
										else
										{
											t_Result = WBEM_E_FAILED ;
										}
									}

									delete [] t_Domain ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								delete [] t_User ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						break ;

						case ERROR_NONE_MAPPED:
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_FAILED ;
						}
						break ;
					}
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
				DWORD t_LastError = GetLastError () ;
			}

			if ( t_TokenUser )
			{
				delete [] ( ( BYTE * ) t_TokenUser ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
        t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetAuthenticationLuid ( 

	HANDLE a_Token ,
	LPVOID a_Luid
)
{
    if ( a_Token )
	{
		TOKEN_STATISTICS t_Statistics ;

		DWORD t_Returned = 0 ;
		BOOL t_Status = GetTokenInformation (

			a_Token, 
			TokenStatistics, 
			( void * ) & t_Statistics , 
			sizeof ( t_Statistics ) , 
			& t_Returned 
		) ;

		if ( t_Status )
		{
			* ( ( LUID * ) a_Luid ) = t_Statistics.AuthenticationId ;
		}
		else
		{
			return WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
        return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: CWbemThreadSecurityHandle ( CLifeControl *a_Control ) : 

	m_ReferenceCount ( 0 ) ,
	m_ThreadToken ( NULL ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_AuthorizationService ( 0 ) ,
	m_AuthenticationService ( 0 ) ,
	m_AuthenticationLevel ( 0 ) ,
	m_ServerPrincipalName ( 0 ) ,
	m_Identity ( NULL ) ,
	m_Origin ( WMI_ORIGIN_UNDEFINED ) ,
	m_Control ( a_Control ) 
{
    if ( m_Control )
    {
        m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: CWbemThreadSecurityHandle ( 

	const CWbemThreadSecurityHandle &a_Copy

) : m_ReferenceCount ( 0 ) ,
	m_ThreadToken ( NULL ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_AuthorizationService ( 0 ) ,
	m_AuthenticationService ( 0 ) ,
	m_AuthenticationLevel ( 0 ) ,
	m_ServerPrincipalName ( 0 ) ,
	m_Identity ( NULL ) ,
	m_Origin ( WMI_ORIGIN_UNDEFINED ) ,
	m_Control ( NULL ) 
{
    *this = a_Copy ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle :: ~CWbemThreadSecurityHandle ()
{
    if ( m_ThreadToken )
	{
        CloseHandle ( m_ThreadToken ) ;
	}

    if ( m_ServerPrincipalName )
	{
        CoTaskMemFree ( m_ServerPrincipalName ) ;
	}

    if ( m_Identity )
	{
        CoTaskMemFree ( m_Identity ) ;
	}

    if ( m_Control )
    {
        m_Control->ObjectDestroyed ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle &CWbemThreadSecurityHandle :: operator= ( const CWbemThreadSecurityHandle &a_Copy )
{
    if ( m_ThreadToken )
	{
        CloseHandle ( m_ThreadToken ) ;
		m_ThreadToken = NULL ;
	}

	if ( a_Copy.m_ThreadToken )
	{
		BOOL t_Status = DuplicateHandle (

			GetCurrentProcess () ,
			a_Copy.m_ThreadToken ,
			GetCurrentProcess () ,
			& m_ThreadToken ,
			0 ,
			TRUE ,
			DUPLICATE_SAME_ACCESS
		) ;
	}

	m_Origin = a_Copy.m_Origin ;
    m_ImpersonationLevel = a_Copy.m_ImpersonationLevel ;

    m_AuthenticationService = a_Copy.m_AuthenticationService ;
    m_AuthorizationService = a_Copy.m_AuthorizationService ;
    m_AuthenticationLevel = a_Copy.m_AuthenticationLevel ;
 
    if ( m_ServerPrincipalName )
    {
        CoTaskMemFree ( m_ServerPrincipalName ) ;
        m_ServerPrincipalName = NULL ;
    }

    if ( a_Copy.m_ServerPrincipalName )
    {        
        m_ServerPrincipalName = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( a_Copy.m_ServerPrincipalName ) + 1 ) * 2	) ;
        if ( m_ServerPrincipalName )
		{
            wcscpy ( m_ServerPrincipalName , a_Copy.m_ServerPrincipalName ) ;
		}
    }

    if ( m_Identity )
    {
        CoTaskMemFree ( m_Identity ) ;
        m_Identity = NULL ;
    }

    if ( a_Copy.m_Identity )
    {
        m_Identity = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( a_Copy.m_Identity ) + 1 ) * 2 ) ;
        if ( m_Identity )
		{
            wcscpy ( m_Identity , a_Copy.m_Identity ) ;
		}
    }

    if ( a_Copy.m_Control )
    {
        m_Control = a_Copy.m_Control ;

        if ( m_Control )
        {
            m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
        }
    }

    return *this ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemThreadSecurityHandle :: AddRef ()
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemThreadSecurityHandle :: Release ()
{
    LONG t_ReferenceCount = InterlockedDecrement( & m_ReferenceCount ) ;
    if ( t_ReferenceCount == 0 )
	{
        delete this ;
	}

    return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: QueryInterface ( REFIID a_Riid , void **a_Void )
{
    if ( a_Riid == IID_IUnknown )
    {
        *a_Void = ( void ** ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID__IWmiThreadSecHandle )
    {
        *a_Void = ( void ** ) ( _IWmiThreadSecHandle * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_CWbemThreadSecurityHandle )
    {
        *a_Void = ( void ** ) ( CWbemThreadSecurityHandle * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else 
	{
		return E_NOINTERFACE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
    
HRESULT CWbemThreadSecurityHandle :: GetToken ( HANDLE *a_ThreadToken )
{
	HRESULT t_Result = S_OK ;

	if ( a_ThreadToken )
	{
		if ( m_ThreadToken )
		{
			HANDLE t_ThreadToken = NULL ;

			BOOL t_Status = DuplicateHandle (

				GetCurrentProcess () ,
				m_ThreadToken ,
				GetCurrentProcess () ,
				& t_ThreadToken ,
				0 ,
				TRUE ,
				DUPLICATE_SAME_ACCESS
			) ;

			if ( t_Status )
			{
				*a_ThreadToken = t_ThreadToken ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
		else
		{
			t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetUser ( 

    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetUser ( m_ThreadToken , a_Size , a_Buffer ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetUserSid ( 

    ULONG *a_Size ,
    PSID a_Sid
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetUserSid ( m_ThreadToken , a_Size , a_Sid ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetAuthenticationLuid ( LPVOID a_Luid )
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{
		t_Result = :: GetAuthenticationLuid ( m_ThreadToken , a_Luid ) ;
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetImpersonation ( DWORD *a_Level )
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadToken )
	{		
		if ( a_Level )
		{
			SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel = SecurityAnonymous ;
			TOKEN_TYPE t_TokenType = TokenImpersonation ;

			t_Result = :: GetImpersonationLevel ( 

				m_ThreadToken , 
				t_ImpersonationLevel ,
				t_TokenType 		
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				switch ( t_ImpersonationLevel )
				{
					case SecurityAnonymous:
					{
						*a_Level = RPC_C_IMP_LEVEL_ANONYMOUS ;
					}
					break ;
    
					case SecurityIdentification:
					{
						*a_Level = RPC_C_IMP_LEVEL_IDENTIFY ;
					}
					break ;

					case SecurityImpersonation:
					{
						*a_Level = RPC_C_IMP_LEVEL_IMPERSONATE ;
					}
					break ;

					case SecurityDelegation:
					{
						*a_Level = RPC_C_IMP_LEVEL_DELEGATE ;
					}
					break ;

					default:
					{
						*a_Level = 0 ;
					}
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		t_Result = ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: GetAuthentication (

	DWORD *a_Level
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		*a_Level = GetAuthenticationLevel () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
    
HRESULT CWbemThreadSecurityHandle :: CloneRpcContext ( 

	IServerSecurity *a_Security 
)
{
	HRESULT t_Result = S_OK ;

	// If here, we are not impersonating and we want to gather info
	// about the client's call.
	// ============================================================

	RPC_AUTHZ_HANDLE t_Authorization = NULL ;

	// Ensures auto release of the mutex if we crash

//	CAutoSecurityMutex t_SecurityMutex ;

	DWORD t_ImpersonationLevel = 0 ;

	t_Result = a_Security->QueryBlanket (

		& m_AuthenticationService ,
		& m_AuthorizationService ,
		& m_ServerPrincipalName ,
		& m_AuthenticationLevel ,
		& t_ImpersonationLevel ,
		& t_Authorization ,
		NULL
	) ;

	if ( FAILED ( t_Result ) )
	{

		// In some cases, we cant get the name, but the rest is ok.  In particular
		// the temporary SMS accounts have that property.  Or nt 4 after IPCONFIG /RELEASE

		t_Result = a_Security->QueryBlanket (

			& m_AuthenticationService ,
			& m_AuthorizationService ,
			& m_ServerPrincipalName ,
			& m_AuthenticationLevel ,
			& t_ImpersonationLevel ,
			NULL ,
			NULL
		) ;

		t_Authorization = NULL ;
	}

	// We don't need this anymore.

//	t_SecurityMutex.Release () ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Authorization )
		{
			m_Identity = LPWSTR ( CoTaskMemAlloc ( ( wcslen ( LPWSTR ( t_Authorization ) ) + 1 ) * 2 ) ) ;
			if ( m_Identity )
			{
				wcscpy ( m_Identity , LPWSTR ( t_Authorization ) ) ;
			}
		}

		// Impersonate the client long enough to clone the thread token.
		// =============================================================

		BOOL t_Impersonating = a_Security->IsImpersonating () ;
		if ( ! t_Impersonating )
		{
			t_Result = a_Security->ImpersonateClient () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CloneThreadContext () ;

			if ( ! t_Impersonating )
			{
				a_Security->RevertToSelf () ;
			}
		}
	}
	else
	{        
		// THIS IS A WORKAROUND FOR COM BUG:
		// This failure is indicative of an anonymous-level client. 
		// ========================================================

		m_ImpersonationLevel = 0 ;

		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: CloneThreadContext ()
{
	HRESULT t_Result = S_OK ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& m_ThreadToken
	) ;

    if ( t_Status ) 
	{
		// Find out token info.
		// =====================

		DWORD t_ImpersonationLevel = 0 ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			m_ThreadToken ,
			TokenImpersonationLevel ,
			& t_ImpersonationLevel ,
			sizeof ( DWORD ) ,
			& t_Returned
		) ;

		if ( t_Status )
		{
			switch ( t_ImpersonationLevel )
			{
				case SecurityAnonymous:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
            
				case SecurityIdentification:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					m_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					m_ImpersonationLevel = 0 ;
				}
				break ;
			}
		}
		else
		{
			if ( GetLastError () == ERROR_ACCESS_DENIED )
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
	}
	else
	{
		if ( GetLastError () == ERROR_ACCESS_DENIED )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
		
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemThreadSecurityHandle :: CloneProcessContext ()
{
	HRESULT t_Result = S_OK ;

	m_AuthenticationService = RPC_C_AUTHN_WINNT ;
	m_AuthorizationService = RPC_C_AUTHZ_NONE ;
	m_AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY ;
	m_ServerPrincipalName = NULL ;
	m_Identity = NULL ;

	HANDLE t_ProcessToken = NULL ;
	BOOL t_Status = OpenProcessToken (

		GetCurrentProcess () ,
		TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
		& t_ProcessToken
	) ;

	if ( t_Status ) 
	{
		t_Status = DuplicateTokenEx (

			t_ProcessToken,
			MAXIMUM_ALLOWED ,
			NULL ,
			( SECURITY_IMPERSONATION_LEVEL ) SecurityImpersonation ,
			TokenImpersonation ,
			& m_ThreadToken
		) ;

		if ( t_Status ) 
		{
			// This is the basic process thread. 
			// =================================

			m_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

			t_Result = S_OK ;
		}
		else
		{
			// Unknown error
			// =============

			m_ImpersonationLevel = 0 ;

			t_Result = E_FAIL ;
		}

		CloseHandle ( t_ProcessToken ) ;
	}
	else
	{
		// Unknown error
		// =============

		m_ImpersonationLevel = 0 ;

		t_Result = E_FAIL ;
	}
		
	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemThreadSecurityHandle  *CWbemThreadSecurityHandle :: New ()
{
	return new CWbemThreadSecurityHandle ( NULL ) ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity :: CWbemCallSecurity ( 

	CLifeControl *a_Control

) : m_ReferenceCount ( 0 ) ,
	m_ImpersonationLevel ( 0 ) ,
	m_ThreadSecurityHandle ( NULL ) ,
	m_ThreadToken ( NULL ) ,
	m_Control ( a_Control ) 
{
	if ( m_Control ) 
	{
		m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity :: ~CWbemCallSecurity ()
{
	if ( m_ThreadToken )
	{
		CloseHandle ( m_ThreadToken ) ;
	}

    if ( m_ThreadSecurityHandle )
	{
        m_ThreadSecurityHandle->Release () ;
	}

	if ( m_Control ) 
	{
		m_Control->ObjectDestroyed ( ( IServerSecurity * ) this ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity &CWbemCallSecurity :: operator= ( const CWbemCallSecurity &a_Copy )
{
	if ( m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle->Release () ;
		m_ThreadSecurityHandle = NULL ;
	}

	if ( a_Copy.m_Control )
	{
		m_Control = a_Copy.m_Control ;

                if ( m_Control )
                {
                    m_Control->ObjectCreated ( ( IServerSecurity * ) this ) ;
                }
	}

	if ( a_Copy.m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle = new CWbemThreadSecurityHandle ( * ( a_Copy.m_ThreadSecurityHandle ) ) ;
	}

	m_ImpersonationLevel = a_Copy.m_ImpersonationLevel ;

	m_ReferenceCount = 1 ;

	return *this ;
}
    
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemCallSecurity :: AddRef ()
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CWbemCallSecurity :: Release ()
{
    LONG t_ReferenceCount = InterlockedDecrement( & m_ReferenceCount ) ;
    if ( t_ReferenceCount == 0 )
	{
        delete this ;
	}

    return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: QueryInterface ( REFIID a_Riid , void **a_Void )
{
    if ( a_Riid == IID_IUnknown )
    {
        *a_Void = ( void ** ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_IServerSecurity )
    {
        *a_Void = ( void ** ) ( IServerSecurity * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID_CWbemCallSecurity )
    {
        *a_Void = ( void ** ) ( CWbemCallSecurity * ) this ;

        AddRef () ;

        return S_OK ;
    }
    else if ( a_Riid == IID__IWmiCallSec )
    {
        *a_Void = ( void ** ) ( _IWmiCallSec  *) this ;

        AddRef () ;

        return S_OK ;
    }
    else 
	{
		return E_NOINTERFACE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: QueryBlanket ( 

	DWORD *a_AuthenticationService ,
	DWORD *a_AuthorizationService ,
	OLECHAR **a_ServerPrincipalName ,
	DWORD *a_AuthenticationLevel ,
	DWORD *a_ImpersonationLevel ,
	void **a_Privileges ,
	DWORD *a_Capabilities
)
{
	if ( m_ThreadSecurityHandle )
	{
		if ( m_ThreadSecurityHandle->GetImpersonationLevel () == 0 )
		{
			return E_FAIL ;
		}

		if ( a_AuthenticationService )
		{
			*a_AuthenticationService = m_ThreadSecurityHandle->GetAuthenticationService () ;
		}

		if ( a_AuthorizationService )
		{
			*a_AuthorizationService = m_ThreadSecurityHandle->GetAuthorizationService () ;
		}

		if ( a_ImpersonationLevel )
		{
			*a_ImpersonationLevel = m_ThreadSecurityHandle->GetImpersonationLevel () ;
		}

		if ( a_AuthenticationLevel )
		{
			*a_AuthenticationLevel = m_ThreadSecurityHandle->GetAuthenticationLevel () ;
		}

		if ( a_ServerPrincipalName )
		{
			*a_ServerPrincipalName = 0 ;
        
			if ( m_ThreadSecurityHandle->GetServerPrincipalName () )
			{        
				*a_ServerPrincipalName = ( LPWSTR ) CoTaskMemAlloc ( ( wcslen ( m_ThreadSecurityHandle->GetServerPrincipalName () ) + 1 ) * 2 ) ;
				if ( a_ServerPrincipalName )
				{
					wcscpy ( *a_ServerPrincipalName , m_ThreadSecurityHandle->GetServerPrincipalName () ) ;	
				}
				else
				{
					return E_OUTOFMEMORY ;
				}
			}
		}        

		if ( a_Privileges )
		{
			*a_Privileges = m_ThreadSecurityHandle->GetIdentity () ;  // Documented to point to an internal!!
		}
	}
	else
	{
		return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
	}

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CWbemCallSecurity :: ImpersonateClient ()
{
	if ( m_ImpersonationLevel != 0 )
	{
		return S_OK ;
	}
	else
	{
		if ( m_ThreadSecurityHandle )
		{
			if ( m_ThreadSecurityHandle->GetImpersonationLevel () == 0 )
			{
				return ( ERROR_CANT_OPEN_ANONYMOUS | 0x80070000 ) ;
			}

			BOOL t_Status = OpenThreadToken (

				GetCurrentThread () ,
				TOKEN_IMPERSONATE ,
				TRUE ,
				& m_ThreadToken
			) ;

			if ( t_Status == FALSE ) 
			{
				DWORD t_LastError = GetLastError () ;
				if ( ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
				{
				}
				else
				{
					return ( ERROR_ACCESS_DENIED | 0x80070000 ) ;
				}
			}

			t_Status = SetThreadToken ( NULL , m_ThreadSecurityHandle->GetThreadToken () ) ;
			if ( t_Status )
			{
				m_ImpersonationLevel = m_ThreadSecurityHandle->GetImpersonationLevel () ; 

				return S_OK ;
			}
			else
			{
				CloseHandle ( m_ThreadToken ) ;

				m_ThreadToken = NULL ;	
			}
		}
		else
		{
			return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}

    return E_FAIL ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: RevertToSelf ()
{
	if ( m_ImpersonationLevel == 0 )
	{
		return S_OK ;
	}
	else
	{
		if ( m_ThreadSecurityHandle )
		{
			// If here,we are impersonating and can definitely revert.
			// =======================================================

			BOOL t_Status = SetThreadToken ( NULL , m_ThreadToken ) ;
			if ( t_Status == FALSE )
			{
				return ( GetLastError () |  0x80070000 ) ;
			}

			CloseHandle ( m_ThreadToken ) ;

			m_ThreadToken = NULL ;

			m_ImpersonationLevel = 0 ;
		}
		else
		{
			return ( ERROR_INVALID_HANDLE | 0x80070000 ) ;
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
BOOL CWbemCallSecurity :: IsImpersonating ()
{
	if ( m_ImpersonationLevel != 0 )
	{
		return TRUE ;
	}

	return FALSE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetThreadSecurity ( 

	WMI_THREAD_SECURITY_ORIGIN a_Origin , 
	_IWmiThreadSecHandle **a_ThreadSecurity
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_ValidOrigin = ( ( a_Origin & WMI_ORIGIN_THREAD ) || ( a_Origin & WMI_ORIGIN_EXISTING ) || ( a_Origin & WMI_ORIGIN_RPC ) ) ;

	if ( a_ThreadSecurity && t_ValidOrigin )
	{
		if ( a_Origin & WMI_ORIGIN_THREAD )
		{
			*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
			if ( *a_ThreadSecurity )
			{
				( *a_ThreadSecurity )->AddRef () ;

				( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

				t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneThreadContext () ;
				if ( FAILED ( t_Result ) )
				{	
					( *a_ThreadSecurity )->Release () ;
					*a_ThreadSecurity = NULL;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			if ( a_Origin & WMI_ORIGIN_RPC || a_Origin & WMI_ORIGIN_EXISTING )
			{
				// Figure out if the call context is ours or RPCs
				// ==============================================

				IServerSecurity *t_Security = NULL ;
				t_Result = CoGetCallContext ( IID_IServerSecurity , ( void ** ) & t_Security ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemCallSecurity *t_Internal = NULL ;
					if ( SUCCEEDED ( t_Security->QueryInterface ( IID_CWbemCallSecurity , ( void ** ) & t_Internal ) ) )
					{
						
						// This is our own call context --- this must be an in-proc object
						// calling us from our thread.  Behave depending on the flags
						// ===============================================================

						if ( a_Origin & WMI_ORIGIN_EXISTING ) 
						{
							*a_ThreadSecurity = new CWbemThreadSecurityHandle ( *t_Internal->GetThreadSecurityHandle () ) ;
							if ( *a_ThreadSecurity )
							{
								(*a_ThreadSecurity)->AddRef () ;

								t_Result = S_OK ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}

						t_Internal->Release () ;
					}
					else
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}

					if ( t_Result == WBEM_E_NOT_FOUND ) 
					{
						if ( a_Origin & WMI_ORIGIN_RPC )
						{
							*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
							if ( *a_ThreadSecurity )
							{
								( *a_ThreadSecurity )->AddRef () ;

								t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneRpcContext ( 

									t_Security 
								) ;

								if ( SUCCEEDED( t_Result ) )
								{
									( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity) ->SetOrigin ( WMI_ORIGIN_RPC ) ;
								}
								else
								{	
									( *a_ThreadSecurity )->Release ();
									*a_ThreadSecurity = NULL;
								}

							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}

					t_Security->Release();
				}
				else
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					if ( a_Origin & WMI_ORIGIN_THREAD )
					{
						*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
						if ( *a_ThreadSecurity )
						{
							( *a_ThreadSecurity )->AddRef () ;

							( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

							t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneProcessContext () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
			else
			{
				if ( a_Origin & WMI_ORIGIN_THREAD )
				{
					*a_ThreadSecurity = new CWbemThreadSecurityHandle ( m_Control ) ;
					if ( *a_ThreadSecurity )
					{
						( *a_ThreadSecurity )->AddRef () ;

						( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity )->SetOrigin ( WMI_ORIGIN_THREAD ) ;

						t_Result = ( ( CWbemThreadSecurityHandle * ) *a_ThreadSecurity)->CloneProcessContext () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: SetThreadSecurity ( 

	_IWmiThreadSecHandle *a_ThreadSecurity
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ThreadSecurityHandle )
	{
		m_ThreadSecurityHandle->Release () ;
		m_ThreadSecurityHandle = NULL ;
	}

	if ( a_ThreadSecurity ) 
	{
		CWbemThreadSecurityHandle *t_ThreadHandle = NULL ; 
		t_Result = a_ThreadSecurity->QueryInterface ( IID_CWbemThreadSecurityHandle , ( void ** ) & t_ThreadHandle ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			m_ThreadSecurityHandle = t_ThreadHandle ;

			IUnknown *t_Unknown = NULL ;
			IUnknown *t_SwitchUnknown = NULL ;
			t_Result = this->QueryInterface ( IID_IUnknown , ( void **) & t_SwitchUnknown ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoSwitchCallContext ( t_SwitchUnknown, & t_Unknown ) ;
		
				t_SwitchUnknown->Release () ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetUser ( 

    ULONG *a_Size ,
    LPWSTR a_Buffer
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess() ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetUser ( t_Token , a_Size , a_Buffer ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetUserSid ( 

    ULONG *a_Size ,
    PSID a_Sid
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetUserSid ( t_Token , a_Size , a_Sid ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetAuthenticationLuid ( LPVOID a_Luid )
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Token = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
        TOKEN_QUERY,
		TRUE ,
        & t_Token
	) ;

	DWORD t_LastError = GetLastError () ;
	if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess () ,
            TOKEN_QUERY,
            & t_Token
		) ;

		if ( ! t_Status )
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		if ( ! t_Status ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( t_Status )
	{
		t_Result = :: GetAuthenticationLuid ( t_Token , a_Luid ) ;

		CloseHandle ( t_Token ) ;
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetImpersonation ( DWORD *a_Level )
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		HANDLE t_Token = NULL ;

		BOOL t_Status = OpenThreadToken (

			GetCurrentThread () ,
			TOKEN_QUERY,
			TRUE ,
			& t_Token
		) ;

		DWORD t_LastError = GetLastError () ;
		if ( ! t_Status && ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN ) )
		{
			*a_Level = 0 ;
		}
		else
		{
			if ( t_Status ) 
			{
				SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel = SecurityAnonymous ;
				TOKEN_TYPE t_TokenType = TokenImpersonation ;
 
				t_Result = :: GetImpersonationLevel ( 

					t_Token , 
					t_ImpersonationLevel ,
					t_TokenType 		
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					switch ( t_ImpersonationLevel )
					{
						case SecurityAnonymous:
						{
							*a_Level = RPC_C_IMP_LEVEL_ANONYMOUS ;
						}
						break ;
            
						case SecurityIdentification:
						{
							*a_Level = RPC_C_IMP_LEVEL_IDENTIFY ;
						}
						break ;

						case SecurityImpersonation:
						{
							*a_Level = RPC_C_IMP_LEVEL_IMPERSONATE ;
						}
						break ;

						case SecurityDelegation:
						{
							*a_Level = RPC_C_IMP_LEVEL_DELEGATE ;
						}
						break ;

						default:
						{
							*a_Level = 0 ;
						}
						break ;
					}
				}

				CloseHandle ( t_Token ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWbemCallSecurity :: GetAuthentication (

	DWORD *a_Level
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Level ) 
	{
		if ( m_ThreadSecurityHandle )
		{
			*a_Level = m_ThreadSecurityHandle->GetAuthenticationLevel () ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemCallSecurity  *CWbemCallSecurity :: New ()
{
	// NULL instead of g_pLifeControl
	// provider subsystem links statically
	return new CWbemCallSecurity ( NULL ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\cloadhpenum.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLOADHPENUM.H

Abstract:

    Client Loadable Hi-Perf Enumerator

History:

--*/

#ifndef __CLIENTLOADABLEHPENUM__H_
#define __CLIENTLOADABLEHPENUM__H_

#include <unk.h>
#include <wbemcomn.h>

// All we need to do is implement and do some tweaking to GarbageCollect and implement
// ClearElements (we garbage collect from the rear)
class CHPRemoteObjectArray : public CGarbageCollectArray
{
public:
    CHPRemoteObjectArray() :
        CGarbageCollectArray( FALSE )
    {};
    ~CHPRemoteObjectArray()
    {};

    void ClearElements( int nNumToClear );

};

class CClientLoadableHiPerfEnum : public CHiPerfEnum
{
public:

    CClientLoadableHiPerfEnum( CLifeControl* pLifeControl );
    ~CClientLoadableHiPerfEnum();

    // Our own function for copying objects into an allocated array
    HRESULT Copy( CClientLoadableHiPerfEnum* pEnumToCopy );
    HRESULT Copy( long lBlobType, long lBlobLen, BYTE* pBlob );
	HRESULT Replace( BOOL fRemoveAll, LONG uNumObjects, long* apIds, IWbemObjectAccess** apObj );

protected:

    // Ensure that we have enough objects and object data pointers to handle
    // the specified number of objects
    HRESULT EnsureObjectData( DWORD dwNumRequestedObjects, BOOL fClone = TRUE );

    CLifeControl*               m_pLifeControl;
    CHPRemoteObjectArray        m_apRemoteObj;
};

class CReadOnlyHiPerfEnum : public CClientLoadableHiPerfEnum
{
public:

    CReadOnlyHiPerfEnum( CLifeControl* pLifeControl );
    ~CReadOnlyHiPerfEnum();

    STDMETHOD(AddObjects)( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj );
    STDMETHOD(RemoveObjects)( long lFlags, ULONG uNumObjects, long* apIds );
    STDMETHOD(RemoveAll)( long lFlags );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\conscript\script.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADDRESLV.H

Abstract:

History:

--*/
#ifndef __WBEM_SCRIPT_CONSUMER__H_
#define __WBEM_SCRIPT_CONSUMER__H_

#include <unk.h>

#include <wbemidl.h>

#include <c:\pandorang\hmom\ess\stdcons\txttempl.h>
#include <stdio.h>
#include <activscp.h>

class CScriptConsumer : public CUnk
{
protected:
    class XProvider : public CImpl<IWbemEventConsumerProvider, CScriptConsumer>
    {
    public:
        XProvider(CScriptConsumer* pObj)
            : CImpl<IWbemEventConsumerProvider, CScriptConsumer>(pObj){}
    
        HRESULT STDMETHODCALLTYPE FindConsumer(
                    IWbemClassObject* pLogicalConsumer,
                    IWbemUnboundObjectSink** ppConsumer);
    } m_XProvider;
    friend XProvider;

public:
    CScriptConsumer(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XProvider(this)
    {}
    ~CScriptConsumer(){}
    void* GetInterface(REFIID riid);
};


class CScriptSink : public CUnk
{
protected:
    class XSink : public CImpl<IWbemUnboundObjectSink, CScriptSink>
    {
    public:
        XSink(CScriptSink* pObj) : 
            CImpl<IWbemUnboundObjectSink, CScriptSink>(pObj){}

        HRESULT STDMETHODCALLTYPE IndicateToConsumer(
            IWbemClassObject* pLogicalConsumer, long lNumObjects, 
            IWbemClassObject** apObjects);
    } m_XSink;
    friend XSink;

protected:
    WString m_wsScript;
    IClassFactory* m_pEngineFac;

    HMODULE m_hMod;
    typedef HRESULT (APIENTRY *WRAPPROC)(IDispatch**, IWbemClassObject*);
    WRAPPROC m_pWrapProc;

    WString m_wsErrorMessage;

    friend class CScriptSite;
public:
    CScriptSink(CLifeControl* pControl = NULL) 
        : CUnk(pControl), m_XSink(this)
    {}
    HRESULT Initialize(IWbemClassObject* pLogicalConsumer);
    ~CScriptSink();

    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\cloadhpenum.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLOADHPENUM.CPP

Abstract:

    Client Loadable Hi-Perf Enumerator

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <hiperfenum.h>
#include "cloadhpenum.h"

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::CClientLoadableHiPerfEnum
//
//  Purpose:
//      Constructor.
//
//  Inputs:
//      CLifeControl*   pLifeControl - Controls the DLL lifetime.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CClientLoadableHiPerfEnum::CClientLoadableHiPerfEnum( CLifeControl* pLifeControl )
:   CHiPerfEnum(),
    m_pLifeControl( pLifeControl ),
    m_apRemoteObj()
{
    m_pLifeControl->ObjectCreated( this );
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::~CClientLoadableHiPerfEnum
//
//  Purpose:
//      Destructor.
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CClientLoadableHiPerfEnum::~CClientLoadableHiPerfEnum()
{
    // Release all the pointers in this array
    IWbemClassObject*   pObj = NULL;
    for( DWORD dwCtr = 0; dwCtr < m_apRemoteObj.Size(); dwCtr++ )
    {
        pObj = (IWbemClassObject*) m_apRemoteObj[dwCtr];
        if ( NULL != pObj )
        {
            pObj->Release();
        }
    }
    m_pLifeControl->ObjectDestroyed( this );
}


/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::Copy
//
//  Purpose:
//      Copies objects from one enumerator into this one.
//
//  Inputs:
//      CClientLoadableHiPerfEnum*  pEnumToCopy - Enumerator to copy.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      New Objects are cloned from a template.
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::Copy( CClientLoadableHiPerfEnum* pEnumToCopy )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( &m_Lock );
    CHiPerfLockAccess   lockSrc( &pEnumToCopy->m_Lock );

    // Get through both locks first
    if ( lock.IsLocked() && lockSrc.IsLocked() )
    {
        // Make sure we have enough object data and BLOBs to handle data copying
        hr = EnsureObjectData( pEnumToCopy->m_aIdToObject.Size() );

        // Now copy out the BLOBs
        if ( SUCCEEDED( hr ) )
        {

            DWORD   dwCtr = 0;

            // Write the objects and ids out to the array
            for ( dwCtr = 0; SUCCEEDED( hr ) && dwCtr < pEnumToCopy->m_aIdToObject.Size(); dwCtr++ )
            {
                // Make sure the object is not-NULL, otherwise we need to clone the supplied
                // object.  It may be NULL because someone used the standard Remove methods
                // on the HiPerf Enumerator

                if ( ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj != NULL )
                {
                    hr = ((CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj)->CopyBlobOf(
                            (CWbemObject*) ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_pObj );
                }
                else
                {
                    // Clone the object
                    IWbemClassObject*   pObj = NULL;
                    IWbemObjectAccess*  pAccess = NULL;
                    hr = ((CWbemObject*)
                            ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_pObj)->Clone( &pObj );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pAccess );

                        // Clean up the objects
                        pObj->Release();

                        if ( SUCCEEDED( hr ) )
                        {
                            // It's sleazy, but quicker than a QI
                            ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->SetObject( pAccess );

                            // Data object should have the AddRef() here.
                            pAccess->Release();
                        }
                    }
                }

                ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_lId = 
                    ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_lId;
            }

            // if everything is okay, go ahead and do any necessary garbage collection on
            // our arrays.

            if ( SUCCEEDED( hr ) )
            {
                m_aReusable.GarbageCollect();
                pEnumToCopy->m_aReusable.GarbageCollect();

                // We don't use remote objects here, so don't worry about garbage
                // collecting that array here.


            }

        }   // IF EnsureObjectData

    }
    else
    {
        // If we can't get access to the enumerator to figure out the objects
        // we need to add to enumeration, something is pretty badly wrong.

        hr = WBEM_E_REFRESHER_BUSY;
    }


    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::Copy
//
//  Purpose:
//      Resets this enumerator using a transfer BLOB and other
//      data.  This is so we can support remote refreshable
//      enumerations.
//
//  Inputs:
//      long                lBlobType - Blob Type
//      long                lBlobLen - Blob Length
//      BYTE*               pBlob - Raw Data to initialize from
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Internal function
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::Copy( long lBlobType, long lBlobLen, BYTE* pBlob )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( &m_Lock );

    if ( lock.IsLocked() )
    {

        long    lNumObjects = 0;

        hr = CWbemInstance::CopyTransferArrayBlob( m_pInstTemplate, lBlobType, lBlobLen, pBlob, m_apRemoteObj, &lNumObjects );

        if ( SUCCEEDED( hr ) )
        {
            // The objects cloned above will do quite nicely
            hr = EnsureObjectData( lNumObjects, FALSE );

            if ( SUCCEEDED( hr ) )
            {
                // Now walk the array of remote objects and the Object-To-ID Array, and reset objects
                // and ids

                IWbemObjectAccess*  pAccess = NULL;

                for ( long  lCtr = 0; lCtr < lNumObjects; lCtr++ )
                {
                    // It's sleazy, but quicker than a QI
                    ((CHiPerfEnumData*) m_aIdToObject[lCtr])->SetObject(
                                        (IWbemObjectAccess*) m_apRemoteObj[lCtr] );
                    ((CHiPerfEnumData*) m_aIdToObject[lCtr])->SetId( lCtr );
                }

                // if everything is okay, go ahead and do any necessary garbage collection on
                // our arrays.

                m_aReusable.GarbageCollect();

                // On this one, since the remote object array should contain the same
                // number of objects as what is in the main array the number of objects
                // to garbage collect is the difference between the two.
                m_apRemoteObj.GarbageCollect(
                    m_apRemoteObj.Size() - m_aIdToObject.Size() );


            }   // IF EnsureObjectData

        }   // IF CopyTransferArray Blob

    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::Replace
//
//  Purpose:
//      Resets this enumerator if appropriate and adds elements.
//
//  Inputs:
//      BOOL			fRemoveAll - Flag whether or not to remove
//										all elements.
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//      IWbemObjectAccess** apObj   -   Array of object pointers
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      Internal functions
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::Replace( BOOL fRemoveAll, LONG uNumObjects, long* apIds, IWbemObjectAccess** apObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( &m_Lock );

    if ( lock.IsLocked() )
    {

		// Use the base class implementations so we actually update the enumerator
		if ( fRemoveAll )
		{
			CHiPerfEnum::RemoveAll( 0L );
		}

		hr = CHiPerfEnum::AddObjects( 0L, uNumObjects, apIds, apObj );

    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::EnsureObjectData
//
//  Purpose:
//      Ensures that we have enough objects and object data
//      pointers to handle the requested number of objects.
//
//  Inputs:
//      DWORD   dwNumRequestedObjects - Number of requested objects.
//      BOOL    fClone -    Indicates whether we should clone objects
//                          when we allocate object data pointers.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      New Objects are cloned from a template if necessary.
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::EnsureObjectData( DWORD dwNumRequestedObjects, BOOL fClone /*=TRUE*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwNumObjects = m_aIdToObject.Size() + m_aReusable.Size();

    // See if we will have enough hiperfenum data pointers to handle the objects
    if ( dwNumRequestedObjects > dwNumObjects )
    {
        DWORD               dwNumNewObjects = dwNumRequestedObjects - dwNumObjects;
        CHiPerfEnumData*    pData = NULL;
        IWbemClassObject*   pObj = NULL;
        IWbemObjectAccess*  pAccess = NULL;

        // Clone new instance objects and stick them in the id to object array
        for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumNewObjects; dwCtr++ )
        {
            if ( fClone )
            {
                hr = m_pInstTemplate->Clone( &pObj );

                if ( SUCCEEDED( hr ) )
                {
                    hr = pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pAccess );

                    // Release the object
                    pObj->Release();
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                pData = new CHiPerfEnumData( 0, pAccess );

                // Should be AddRefd by data objects
                if ( NULL != pAccess )
                {
                    pAccess->Release();
                }

                if ( NULL != pData )
                {
                    if ( m_aIdToObject.Add( (void*) pData ) != CFlexArray::no_error )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // IF Clone

        }   // FOR allocate new objects

    }   // IF we need new objects

    if ( SUCCEEDED( hr ) )
    {
        // Move objects from the reusable array if we don't have enough
        // or move them into the reusable array if we have to many

        if ( dwNumRequestedObjects > m_aIdToObject.Size() )
        {
            DWORD   dwNumObjectsNeeded = dwNumRequestedObjects - m_aIdToObject.Size();

/*
            // Copy from the end, so we just need to zero out and set size
            DWORD   dwReusableIndex = m_aReusable.Size() - dwNumObjectsNeeded;

            // This means we can pull the pointers en masse from m_aReusable
            void**  pReusable = m_aReusable.GetArrayPtr();
            void**  pIdToObject = m_aIdToObject.GetArrayPtr();

            // A Quick append, then zero out the memory and set the size
            // accounting for the pointers we just "stole".
            CopyMemory( &pIdToObject[m_aIdToObject.Size()],
                    &pReusable[dwReusableIndex],
                    dwNumObjectsNeeded * sizeof(void*) );

            ZeroMemory( &pReusable[dwReusableIndex], dwNumObjectsNeeded * sizeof(void*) );
            m_aReusable.SetSize( m_aReusable.Size() - dwNumObjectsNeeded );
            m_aIdToObject.SetSize( m_aIdToObject.Size() + dwNumObjectsNeeded );
*/
            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumObjectsNeeded; dwCtr++ )
            {
                if ( m_aIdToObject.Add( m_aReusable[m_aReusable.Size() - 1] ) != CFlexArray::no_error )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    m_aReusable.RemoveAt( m_aReusable.Size() - 1 );
                }
            }

        }
        else if ( dwNumRequestedObjects < m_aIdToObject.Size() )
        {
            DWORD   dwNumExtraObjects = m_aIdToObject.Size() - dwNumRequestedObjects;

/*
            // Copy from the end, so we just need to zero out and set size
            DWORD   dwExtraIndex = m_aIdToObject.Size() - dwNumExtraObjects;

            // This means we can pull the pointers en masse from m_aReusable
            void**  pReusable = m_aReusable.GetArrayPtr();
            void**  pIdToObject = m_aIdToObject.GetArrayPtr();

            // A Quick append, then zero out the memory and set the size
            // accounting for the pointers we just "stole".
            CopyMemory( &pReusable[m_aReusable.Size()],
                    &pIdToObject[dwExtraIndex],
                    dwNumExtraObjects * sizeof(void*) );

            ZeroMemory( &pIdToObject[dwExtraIndex], dwNumExtraObjects * sizeof(void*) );
            m_aIdToObject.SetSize( m_aIdToObject.Size() - dwNumExtraObjects );
            m_aReusable.SetSize( m_aReusable.Size() + dwNumExtraObjects );
*/
            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumExtraObjects; dwCtr++ )
            {
                if ( m_aReusable.Add( m_aIdToObject[m_aIdToObject.Size() - 1] ) != CFlexArray::no_error )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    m_aIdToObject.RemoveAt( m_aIdToObject.Size() - 1 );
                }
            }

        }

    }   // IF we ensured enough Object Data Pointers

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::CReadOnlyHiPerfEnum
//
//  Purpose:
//      Constructor.
//
//  Inputs:
//      CLifeControl*   pLifeControl - Controls the DLL lifetime.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CReadOnlyHiPerfEnum::CReadOnlyHiPerfEnum( CLifeControl* pLifeControl )
:   CClientLoadableHiPerfEnum( pLifeControl )
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::~CReadOnlyHiPerfEnum
//
//  Purpose:
//      Destructor.
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CReadOnlyHiPerfEnum::~CReadOnlyHiPerfEnum()
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::AddObjects
//
//  Purpose:
//      Adds new objects to the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//      IWbemObjectAccess** apObj   -   Array of object pointers
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::AddObjects( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj )
{
    return WBEM_E_ACCESS_DENIED;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::Remove
//
//  Purpose:
//      Removes specified objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::RemoveObjects( long lFlags, ULONG uNumObjects, long* apIds )
{
    return WBEM_E_ACCESS_DENIED;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::RemoveAll
//
//  Purpose:
//      Removes all objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::RemoveAll( long lFlags )
{
    return WBEM_E_ACCESS_DENIED;
}

// Walks the array and cleans up the specified number of elements
void CHPRemoteObjectArray::ClearElements( int nNumToClear )
{

    // We need to clear from the end
    for ( int nCtr = ( m_nSize - nNumToClear ); nCtr < m_nSize; nCtr++ )
    {
        IWbemObjectAccess* pAcc = (IWbemObjectAccess*) GetAt(nCtr);

        _ASSERT( NULL != pAcc, "Tried to clear a NULL Element!" );
        if ( NULL != pAcc )
        {
            pAcc->Release();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\context.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CONTEXT.H

Abstract:

    CWbemContext Implementation

History:

--*/

#ifndef __WBEM_CONTEXT__H_
#define __WBEM_CONTEXT__H_

#include <arrtempl.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <unk.h>
#include <sync.h>
#include <comdef.h>
#include <corex.h>


class auto_bstr
{
public:
  explicit auto_bstr (BSTR str = 0) _THROW0();
  auto_bstr (auto_bstr& ) _THROW0();

  ~auto_bstr() _THROW0();

  BSTR release() _THROW0();
  BSTR get() const _THROW0();
  size_t len() const { return SysStringLen (bstr_);};
  auto_bstr& operator=(auto_bstr&);

private:
  BSTR	bstr_;
};

inline
auto_bstr::auto_bstr (auto_bstr& other)
{ 
  bstr_ = other.release();
};

inline
auto_bstr::auto_bstr (BSTR str)
{
  bstr_ = str;
};

inline
auto_bstr::~auto_bstr()
{ SysFreeString (bstr_);};

inline BSTR
auto_bstr::release()
{ BSTR _tmp = bstr_;
  bstr_ = 0;
  return _tmp; };

inline BSTR
auto_bstr::get() const
{ return bstr_; };

inline 
auto_bstr& auto_bstr::operator=(auto_bstr& src)
{
  auto_bstr tmp(src); 
  swap(bstr_, tmp.bstr_);
  return *this;
};


inline auto_bstr clone(LPCWSTR str = NULL)
{
  BSTR bstr = SysAllocString(str);
  if (bstr == 0 && str != 0)
    throw CX_MemoryException();
  return auto_bstr (bstr);
}

class CWbemContext : public IWbemContext, public IMarshal, 
                    public IWbemCausalityAccess
{
protected:
    long m_lRef;
    DWORD m_dwCurrentIndex;
	CLifeControl*	m_pControl;

    struct CContextObj
    {
        auto_bstr m_strName;
        long m_lFlags;
        _variant_t m_vValue;
	    static int legalTypes[];
        static bool supportedType(const VARIANT&);
    public:
        CContextObj();
        CContextObj(LPCWSTR wszName, long lFlags, VARIANT* pvValue);
        CContextObj(const CContextObj& Obj);
        CContextObj(IStream* pStream,DWORD & dwStreamSize);
        ~CContextObj();

        HRESULT GetMarshalSizeMax ( DWORD* pdwSize );
        HRESULT Marshal(IStream* pStream);
    };

    CUniquePointerArray<CContextObj> m_aObjects;
    DWORD m_dwNumRequests;
    GUID *m_aRequests;

    long m_lNumParents;
    long m_lNumSiblings;
    long m_lNumChildren;
    CCritSec m_cs;

private:
    DWORD FindValue(LPCWSTR wszIndex);
    void AssignId();

public:
    CWbemContext(CLifeControl* pControl = NULL);
    CWbemContext(const CWbemContext& Other, DWORD dwExtraSpace = 0);
    ~CWbemContext();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)() 
    {
        return InterlockedIncrement(&m_lRef);
    }
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0) delete this;
        return lRef;
    }

    // IWbemContext methods

    STDMETHOD(Clone)(IWbemContext** ppCopy);
    STDMETHOD(GetNames)(long lFlags, SAFEARRAY** pNames);
    STDMETHOD(BeginEnumeration)(long lFlags);
    STDMETHOD(Next)(long lFlags, BSTR* pName, VARIANT* pVal);
    STDMETHOD(EndEnumeration)();
    STDMETHOD(SetValue)(LPCWSTR NameIndex, long lFlags, VARIANT* pValue);
    STDMETHOD(GetValue)(LPCWSTR NameIndex, long lFlags, VARIANT* pValue);
    STDMETHOD(DeleteValue)(LPCWSTR NameIndex, long lFlags);
    STDMETHOD(DeleteAll)();

    // IWbemCausalityAccess methods

    STDMETHOD(GetRequestId)(GUID* pId);
    STDMETHOD(IsChildOf)(GUID Id);
    STDMETHOD(CreateChild)(IWbemCausalityAccess** ppChild);
    STDMETHOD(GetParentId)(GUID* pId);
    STDMETHOD(GetHistoryInfo)(long* plNumParents, long* plNumSiblings);
    STDMETHOD(MakeSpecial)();
    STDMETHOD(IsSpecial)();

    // IMarshal methods

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastall.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTALL.H

Abstract:

    This is the include file for all clients of fastobj functionality.
    See member header files for documentation.

History:

    3/10/97     a-levn  Fully documented

--*/

#ifndef _FASTALL_H_
#define _FASTALL_H_

//************************** WARNING ***************************************
// STL collections insist on protecting themselves against multi-threaded
// access. We don't want that --- we protect ourselves. This protection
// involves an extra DLL (msvcp50.dll) which we don't want to deal with. So
// we trick it into believing that we are compiling single-threaded.
//**************************************************************************
/*
#ifdef _MT
  #undef _MT
  #include <yvals.h>
  #define _MT
#endif
*/

//#include <dbgalloc.h>
#include <corex.h>

// Parameter flow indicators.
// ==========================

#define READONLY
    // The value should be treated as read-only

#define ACQUIRED
    // Ownership of the object/pointer is acquired.

#define COPIED
    // The function makes a copy of the object/pointer.

#define PREALLOCATED
    // The out-param uses caller's memory.

#define NEWOBJECT
    // The return value or out parameter is a new
    // allocation which must be deallocated by
    // the caller if the call succeeds.

#define READWRITE
    // The in-param is will be treated as read-write,
    // but will not be deallocated.

#define INTERNAL
    // Returns a pointer to internal memory object
    // which should not be deleted.

#define ADDREF
    // On a parameter, indicates that the called
    // function will do an AddRef() on the interface
    // and retain it after the call completes.

#define TYPEQUAL L"CIMTYPE"

#include "fastcls.h"
#include "fastinst.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastcls.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTCLS.H

Abstract:

  This file defines the classes related to class representation
  in WbemObjects

  Classes defined: 
      CClassPart              Derived class definition
      CClassPartContainer     Anything that contains CClassPart
      CWbemClass               Complete class definition.

History:

    3/10/97     a-levn  Fully documented
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_WBEM_CLASS__H_
#define __FAST_WBEM_CLASS__H_

#include "fastobj.h"
#include "fastmeth.h"

//#pragma pack(push, 1)

    
//*****************************************************************************
//*****************************************************************************
//
//  class CClassPartContainer
//
//  See CClassPart definition first.
//
//  This class defines the functionality required by CClassPart of any object
//  whose memory block contains that of the CClassPart.
//
//*****************************************************************************
//
//  ExtendClassPartSpace
//
//  Called by CClassPart when it needs more memory for its memory block. The
//  container may have to relocate the entire memory block to get more memory. 
//  In this case, it will have to notify CClassPart of its new location using
//  Rebase.
//
//  PARAMETERS:
//
//      CClassPart* pClassPart      The class part making the request
//      length_t nNewLength         The required length
//
//*****************************************************************************
//
//  ReduceClassPartSpace
//
//  Called by CClassPart wen it wants to return some memory to the container.
//  The container may NOT relocate the class part's memory block in response to
//  this call.
//
//  PARAMETERS:
//
//      CClassPart* pClassPart      The class part making the request
//      length_t nDecrement         The amount of space to return
//
//*****************************************************************************
//
//  GetWbemObjectUnknown
//
//  Must return the pointer to the IUnknown of the containing CWbemObject
//  This is used by qualifier sets to ensure that the main object lasts at
//  least as long as they do.
//  
//  RETURN VALUES:
//
//      IUnknown*:   the pointer to the controlling IUnknown
//
//*****************************************************************************


class CClassPart;
class COREPROX_POLARITY CClassPartContainer
{
public:
    virtual BOOL ExtendClassPartSpace(CClassPart* pPart, 
        length_t nNewLength) = 0;
    virtual void ReduceClassPartSpace(CClassPart* pPart,
        length_t nDecrement) = 0;
    virtual IUnknown* GetWbemObjectUnknown() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CClassPart
//
//  This object represents information about a class. A complete class
//  definition consists of two of these: a part describing the class itself
//  as well as the part describing the parent. See CWbemClass (below) for 
//  more explanations.
//
//  The memory block of CClassPart has the following format:
//
//      The header:
//          length_t nLength            The length of the whole structure
//          BYTE fFlags                 Reserved
//          heapptr_t ptrClassName      The heap pointer to the name of the
//                                      class. INVALID_HEAP_POINTER if no name
//                                      has been assigned yet.
//          heapptr_t ptrParentName     The heap pointer to the name of the
//                                      parent class. INVALID_HEAP_POINTER if
//                                      top-level.
//          heapptr_t ptrDynasty        The heap pointer to the name of the
//                                      dynasty (top-level class we are derived
//                                      from).
//          length_t nDataLength        The length of the data table for this
//                                      class (CDataTable itself does not know)
//
//      Class Qualifiers: see CBasicQualfiierSet (fastqual.h) for details.
//      Property lookup table: see CPropertyLookupTable (fastprop.h)
//      Default values: see CDataTable (fastprop.h) for details
//      The heap where all the variable-length data is kept: see CFastHeap
//          in fastheap.h for details.
//
//*****************************************************************************
//
//  SetData
//
//  Initialization function.
//
//  PARAMETERS:
//
//      LPMEMORY pStart                 The memory block where we live.
//      CClassPartContainer* pContainer Out container (class or instance)
//      CClassPart* pParent = NULL      The parent's class part. Instances
//                                      don't have it. Classes do --- see 
//                                      CWbemClass (below) for details.
//
//*****************************************************************************
//
//  SetData
//
//  Overloaded Initialization function.
//
//  PARAMETERS:
//
//      LPMEMORY pStart                 The memory block where we live.
//      CClassPartContainer* pContainer Out container (class or instance)
//		DWORD dwNumProperties			Number of properties to initialize
//										DataTable with ( for CompareExactMatch()
//										and Update() ).
//      CClassPart* pParent = NULL      The parent's class part. Instances
//                                      don't have it. Classes do --- see 
//                                      CWbemClass (below) for details.
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   the pointer to our memory block
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t;   the length of our memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Informs CClassPart that its memory block has moved.
//
//  PARAMETERS:
//
//      LPMEMORY pMemory        The new location of the memory block
//
//*****************************************************************************
//
//  GetPropertyLookup
//
//  Finds the property's CPropertyLookup structure by its index in the lookup
//  table. This function is only useful in the context of enumerating all 
//  properties. See fastprop.h for CPropertyLookup.
//
//  PARAMETERS:
//
//      int nIndex      The index of the property in the property lookup table.
//                      This is NOT the index in the data table!
//  RETURN VALUES:
//
//      CPropertyLookup*:   if the index is within range --- the property's
//                          lookup structure. Otherwise, NULL.
//
//*****************************************************************************
//
//  FindPropertyInfo
//
//  Finds the property information structure based on the name. See fastprop.h
//  for CPropertyInformation definition. The name is treated case-insensitively
//
//  PARAMETERS:
//
//      LPCWSTR wszName     The name of the property to find.
//  
//  RETURN VALUES:
//
//      CPropertyInformation*:  the information structure of the property or
//                              NULL if not found.
//
//*****************************************************************************
//
//  GetDefaultValue
//
//  Retrieves the deafult value of the property based on its information. See 
//  FindPropertyInfo for looking up information. There is also another flavor
//  of GetDefaultValue below.
//
//  PARAMETERS:
//
//      IN CPropertyInformation* pInfo  The information structure for the
//                                      property.
//      OUT CVar* pVar                  Destination for the value. Must not
//                                      already contain any value.
//
//*****************************************************************************
//
//  GetDefaultValue
//
//  Retrieves the default value of the property based on its name. 
//
//  PARAMETERS:
//
//      IN LPWCWSTR wszName             The name of the property.
//      OUT CVar* pVar                  Destination for the value. Must not
//                                      already contain any value.
//  RETURN VALUES:
//  
//      WBEM_S_NO_ERROR          success
//      WBEM_E_NOT_FOUND         property not found in this class
//
//*****************************************************************************
//
//  GetPropertyQualifierSetData
//
//  Finds the qualifier set data (see fastqual.h) for a given property.
//
//  PARAMETERS:
//
//      IN LPWCWSTR wszName             The name of the property.
//      
//  RETURN VALUES:
//
//      LPMEMORY:   the memory block of that property's qualifier set or NULL
//                  if property is not found.
//
//*****************************************************************************
//
//  EnsureProperty
//
//  Makes sure that a property with a given name and a given type exists. The
//  type is the actual VARIANT (CVar) type, and not our internal type.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the property
//      IN VARTYPE vtType       The type of the VARIANT used as the value
//      IN CIMTYPE ctType       The type of the property
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      The property of the right name and type is now in
//                          the class.
//      WBEM_E_INVALID_PARAMETER     The name violates identifier naming rules.
//      WBEM_E_PROPAGATER_PROEPRTY   The parent class has the property with the
//                                  same name but different type.
//      WBEM_E_INVALID_PROPERTY_TYPE This type cannot be used as a property type.
//
//*****************************************************************************
//
//  SetDefaultValue
//
//  Sets the default value of a given property. The value must match the type
//  of the property precisely --- no coersion is attempted. The property must
//  already exist (see EnsureProperty).
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the property to set.
//      IN CVar* pVar           The value to store.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              The value has been set.
//      WBEM_E_NOT_FOUND             The property does not exist.
//      WBEM_E_TYPE_MISMATCH         The value does not match the property type
//      WBEM_E_INVALID_PROPERTY_TYPE This type cannot be used as a property type.
//
//*****************************************************************************
//
//  GetClassQualifier
//
//  Gets the value of a class qualifier based on the qualifier name.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName         The name of the qualifier (insensitive).
//      OUT CVar* pVal             Destination for the value. Must not already
//                                 contain a value.
//      OUT long* plFlavor = NULL  Destination for the flavor
//                                 If NULL, not supplied
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success         
//      WBEM_E_NOT_FOUND     The qualifier was not found.
//
//*****************************************************************************
//
//  SetClassQualifier
//
//  Sets the value of a class qualifier.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the qualifier to set.
//      IN CVar* pVal           The value to assign to the qualifier. This must
//                              be of one of the valid qualifier types (see
//                              IsValidQualifierType in fastqual.h).
//      IN long lFlavor         The flavor to set.
//
//  RETURN VALUES:
//
//  Same values as CQualifierSet::SetQualifierValue, namely:
//      WBEM_S_NO_ERROR          The value was successfully changed
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//      
//*****************************************************************************
//
//  GetQualifier
//
//  Retrieves a class or parent qualifier by its name.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve
//      OUT CVar* pVar          Destination for the value. Must not already 
//                              contain a value.
//      OUT long* plFlavor      Destinatino for the flavor. May be NULL if not
//                              required.
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_NOT_FOUND         No such qualifier
//
//*****************************************************************************
//
//  InitPropertyQualifierSet
//  
//  Class property qualifier sets take several tricky initialization
//  parameters (see CClassPropertyQualifierSet in fastqual.h). This function
//  initializes a qualifier set object to point to the qualifier set of a given
//  property. 
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName                      The name of the property.
//      OUT CClassPropertyQualifierSet* pSet    Destination set. this function
//                                              will call SetData on it.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_S_NOT_FOUND     No such property.
//
//*****************************************************************************
//
//  DeleteProperty
//
//  Deletes a property from the class definition. The property is removed from
//  the property lookup table as well as from the data table, changing the
//  locations of the other properties. See CDataTable fastdata.h for details.
//  If the property was an overriden parent property, deleting it will simply
//  restore parent's settings --- qualifiers and the default value.
//
//  PARAMETERS:
//
//      LPCWSTR wszName         The property to delete.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_S_NOT_FOUND     No such property.
//
//*****************************************************************************
//      
//  CopyParentProperty
//
//  Copies all the information for a property from the parent class part. This
//  function is invoked when an overriden property is deleted, thus restoring
//  parent's settings.
//
//  PARAMETERS:
//
//      IN READ_ONLY CClassPart& ParentPart The parent's class part.
//      IN LPCWSTR wszName                  The name of the property
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_S_NOT_FOUND     No such property.
//
//*****************************************************************************
//      
//  GetPropertyType
//
//  Retrieves the type and the flavor of a given property. The flavor is either
//  WBEM_FLAVOR_FLAG_LOCAL or WBEM_FLAVOR_FLAG_PROPAGATED.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName  The name of the property to retrieve
//      OUT CIMTYPE* pctType Destination for the type. If NULL, not filled in
//      OUT long* plFlags   Destination for the flavor as described above. If
//                          NULL, not filled in.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      CPropertyInformation*	pInfo - Identifies property to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//
//*****************************************************************************
//      
//  GetClassName
//
//  Retrieves the name of the class.
//
//  PARAMETERS:
//
//      OUT CVar* pVar          Destination for the name of the class.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     Class name hasn't been assigned yet.
//
//*****************************************************************************
//
//  GetSuperclassName
//
//  Retrieves the name of the superclass.
//
//  PARAMETERS:
//
//      OUT CVar* pVar          Destination for the name of the superclass.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     Top-level class.
//
//*****************************************************************************
//
//  GetDynasty
//
//  Retrieves the name of the dynasty --- the top-level class we are derived
//  from.
//
//  PARAMETERS:
//
//      OUT CVar* pVar          Destination for the name of the dynasty.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     Class name hasn't been assigned yet.
//
//*****************************************************************************
//
//  GetPropertyCount
//
//  Retrieves the number of properties in the class as a CVar
//
//  PARAMETERS:
//
//      OUT CVar* pVar          Destination for the number of properties.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//
//*****************************************************************************
//
//  SetClassName
//  
//  Sets the class name. 
//
//  PARAMETERS:
//
//      IN CVar* pVar           Contains the name of the class. 
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_TYPE_MISMATCH     pVar is not a string.
//
//*****************************************************************************
//
//  IsKeyed
//
//  Checks if this class has a key. A class has a key if at least one of its
//  properties has a 'key' qualifier or if it has the 'singleton' qualifier.
//
//  RETURN VALUES:
//
//      TRUE iff it has a key.
//
//*****************************************************************************
//
//  IsTopLevel
//
//  Check if a class is top-level. That is, if the parent name is not set.
//
//  RETURN VALUES:
//
//      TRUE iff it is top-level
//
//*****************************************************************************
//
//  IsDynamic
//
//  Check if a class is dynamic, that is, has a 'dynamic' qualifier.
//
//  RETURN VALUES:
//
//      TRUE iff it is dynamic
//
//*****************************************************************************
//
//  GetIndexedProps
//
//  Produces an array of names of the properties which are indexed, that is,
//  have the 'index' qualifier.
//
//  PARAMETERS:
//
//      CWStringArray& awsNames     Destination for the array of names. Assumed
//                                  to be empty.
//
//*****************************************************************************
//
//  GetKeyProps
//
//  Produces an array of names of the properties which are keys, that is,
//  have the 'key' qualifier.
//
//  PARAMETERS:
//
//      CWStringArray& awsNames     Destination for the array of names. Assumed
//                                  to be empty.
//
//*****************************************************************************
//
//  GetKeyOrigin
//
//  Returns the name of the class of origin of the keys.
//
//  PARAMETERS:
//
//      OUT CWString& wsClass       Destination for the name.
//
//*****************************************************************************
//
//  IsPropertyKeyed
//
//  Returns whether or not the specified property is a keyed property.
//
//  PARAMETERS:
//
//      LPCWSTR pwcsKeyProp - Property to check.
//
//	Returns:
//		BOOL TRUE if the property is keyed.
//
//*****************************************************************************
//
//  IsPropertyIndexed
//
//  Returns whether or not the specified property is an indexed property.
//
//  PARAMETERS:
//
//      LPCWSTR pwcsIndexProp - Property to check.
//
//	Returns:
//		BOOL TRUE if the property is indexed.
//
//*****************************************************************************
//
//  CanBeReconciledWith
//
//  This method is called when a definition of a class is about to be replaced 
//  with another one. If the class has no instances or derived classes, such
//  an operation presents no difficulties. If it does, however, we need to be
//  careful not to break them. Thus, only the following changes are allowed:
//
//      1) Qualifier changes
//      2) Default value changes
//
//  PARAMETERS:
//
//      IN READONLY CClassPart& NewPart The new definition to compare to.
//
//  RETURN VALUES:
//
//  EReconciliation:
//      e_Reconcilable          Can be reconciled --- i.e., compatible.
//      e_DiffClassName         The class name is different
//      e_DiffParentName        The parent class name is different.
//      e_DiffNumProperties     The number of properties is different
//      e_DiffPropertyName      A property has a different name
//      e_DiffPropertyType      A property has a different type
//      e_DiffPropertyLocation  A property has a different location in the 
//                              data table.
//      e_DiffKeyAssignment     A property that is a key in one class is not
//                              in the other.
//      e_DiffIndexAssignment   A property which is indexed in one class is not
//                              in the other.
//      
//*****************************************************************************
//
//  ReconcileWith
//
//  See CanBeReconciledWith above. This method is the same, except that if
//  reconciliation is possible (e_Reconcilable is returned) this class part is
//  replaced with the new one (the size is adjusted accordingly).
//
//
//  PARAMETERS:
//
//      IN READONLY CClassPart& NewPart The new definition to compare to.
//
//  RETURN VALUES:
//
//  EReconciliation:
//      e_Reconcilable          We have been replaced with the new part.
//      e_DiffClassName         The class name is different
//      e_DiffParentName        The parent class name is different.
//      e_DiffNumProperties     The number of properties is different
//      e_DiffPropertyName      A property has a different name
//      e_DiffPropertyType      A property has a different type
//      e_DiffPropertyLocation  A property has a different location in the 
//                              data table.
//      e_DiffKeyAssignment     A property that is a key in one class is not
//                              in the other.
//      e_DiffIndexAssignment   A property which is indexed in one class is not
//                              in the other.
//      
//*****************************************************************************
//
//  CanContainKey
//
//  Required by qualifier sets. Clearly, a class cannot be marked with 'key',
//  so this function
//
//  RETURN VALUES:
//
//      WBEM_E_INVALID_QUALIFIER
//
//*****************************************************************************
//
//  CanContainKeyedProps
//
//  Checks if this class can have keyed properties. It can unless the parent
//  class already has some.
//
//  RETURN VALUES:
//
//      TRUE if the parent class has no keys
//
//*****************************************************************************
//
//  GetTotalRealLength
//
//  Calculates how much space is really needed to store all the information in
//  the part. This may be less that what it currently takes up because of
//  holes between individual components.
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes required to store us.
//
//*****************************************************************************
//
//  Compact
//
//  Removes any holes that might have developped between components.
//
//*****************************************************************************
//
//  ReallocAndCompact
//
//  Compacts (see Compact) and ensures that our memory block is at least the
//  given size (requesting more memory from our container if necessary.
//
//  PARAMETERS:
//
//      length_t nNewTotalLength        Required length of the memory block
//
//*****************************************************************************
//
//  ExtendHeapSize, ReduceHeapSize
//
//  Heap container functionality. See CFastHeapContainer in fastheap.h for
//  details. 
//
//*****************************************************************************
//
//  ExtendQualfierSetSpace, ReduceQualifierSetSpace
//
//  Qualifier set container functionality for the class qualifier set. See
//  CQualifierSetContainer in fastqual.h for details.
//
//*****************************************************************************
//
//  ExtendPropertyTableSpace, ReducePropertyTableSpace
//
//  Property table container functionality for the property table. See
//  CPropertyTableContainer in fastprop.h for details.
//
//*****************************************************************************
//
//  ExtendDataTableSpace, ReduceDataTableSpace
//
//  Data table container functionality. See CDataTableContainer in fastprop.h
//  for details.
//
//*****************************************************************************
//
//  GetQualifierSetStart
//
//  Returns the memory block of the class qualifier set.
//
//  Returns;
//
//      LPMEMORY:   the memory block of the qualifier set.
//
//*****************************************************************************
//
//  GetMinLength
//
//  Computes the minimum length of a class part --- one with no properties or
//  qualifiers or even a name.
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes required
//
//*****************************************************************************
//
//  CreateEmpty
//
//  Creates an empty class part --- one with no properties or qualifiers --- 
//  on a given memory block.
//
//  PARAMETERS:
//
//      LPMEMORY pStart     The memory to write on.
//
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the class part
//
//*****************************************************************************
//
//  static EstimateMergeSpace
//  
//  When a class is stored in the database, only the parts of it that are 
//  particular to that class (not inherited from the parent) are stored. So, 
//  when it is loaded back out, a "merge" between it and the parent needs to 
//  occur.
//
//  This function (over-)estimates how much space the merge is going to take.
//
//  PARAMETERS:
//
//      CClassPart& ParentPart      The parent class class part.
//      CClassPart& ChildPart       The child class class part.
//
//  RETURN VALUES:
//
//      length_t:   the (over-)estimate of the required space for the merge.
//
//*****************************************************************************
//
//  static Merge
//
//  See EstimateMergeSpace for an explanation of the merge process.
//
//  PARAMETERS:
//
//      CClassPart& ParentPart      The parent class class part.
//      CClassPart& ChildPart       The child class class part.
//      LPMEMORY pDest              Destination memory block
//      int nAllocatedLength        The size of the memory block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   pointer to the first byte after the merge
//
//*****************************************************************************
//
//  static Update
//
//  When a class object is Put to our database and it has derived classes
//	if we will unmerged derived classes with their new parents, which must
//	be done checking for conflicts and failing where necessary.
//
//  PARAMETERS:
//
//      CClassPart& ParentPart      The parent class class part.
//      CClassPart& ChildPart       The child class class part.
//      LPMEMORY pDest              Destination memory block
//      int nAllocatedLength        The size of the memory block.
//		long lFlags					Must be WBEM_FLAG_UPDATE_SAFE_MODE
//									or WBEM_FLAG_UPDATE_FORCE_MODE.
//		DWORD*						pdwMemUsed - Storage for memory used
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR if success.
//
//*****************************************************************************
//
//  EstimateUnmergeSpace
//
//  
//  When a class is stored in the database, only the parts of it that are 
//  particular to that class (not inherited from the parent) are stored. 
//  This function (over-)estimates how much space the unmerge is going to take.
//
//  RETURN VALUES:
//
//      length_t:   the (over-)estimate of the amount of space required.
//
//*****************************************************************************
//
//  Unmerge
//
//  See EstimateUnmergeSpace for an explanation of the unmerge process.
//
//  PARAMETERS:
//
//      LPMEMORY pDest              Destination memory block
//      int nAllocatedLength        The size of the memory block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   pointer to the first byte after the unmerge
//
//*****************************************************************************
//
//  EstimateDerivedPartSpace
//
//  When a derived class is created, its class part is created as a version
//  of the parent's. This function estimates the amount of space required for
//  the child's class part
//
//  RETURN VALUES:
//
//      length_t:   (over-)estimate of the number of bytes required.
//
//*****************************************************************************
//
//  CreateDerivedPart
//
//  When a derived class is created, its class part is created as a version
//  of the parent's. This function writes the child's class part to a given
//  memory block.
//
//  PARAMETERS:
//
//      LPMEMORY pDest              Destination memory block
//      int nAllocatedLength        The size of the memory block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   pointer to the first byte after the new part.
//
//*****************************************************************************
//
//  MapLimitation
//
//  Produces an object representing a particular limitation on the objects, i.e.
//  which properties and what kinds of qualifiers should be in it.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to 
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      OUT CLimitationMapping* pMap    This mapping object (see fastprop.h) 
//                                      will be changed to reflect the 
//                                      parameters of the limitation. It can
//                                      then be used in CWbemInstance::
//                                      GetLimitedVersion function.
//  RETURNS:
//
//      BOOL:   TRUE.
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Creates a limited representation of this class part on a given block of 
//  memory as described in EstimateLimitedRepresentationLength in fastobj.h.
//
//  PARAMETERS:
//
//      IN CLimitationMapping* pMap The mapping of the limitation to produce.
//                                  Obtained from CWbemClass::MapLimitation.
//      IN nAllocatedSize           The size of the memory block allocated for
//                                  the operation --- pDest.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************
//
//  SetPropQualifier
//
//  Sets the value of a given qualifier on a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      IN long lFlavor         The flavor for the qualifier (see fastqual.h)
//      IN CVar *pVal           The value of the qualifier
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property.
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  SetInheritanceChain
//
//  Configures the derivation of the class. This function is only used in rare
//  circumstances where an object is constructed not from its standard transport
//  form.
//
//  PARAMETERS:
//
//      IN long lNumAntecendents    The number of antecendets this class will
//                                  have. This includes all the classes this
//                                  class is derived from, but NOT itself
//
//      IN LPWSTR* awszAntecedents  The array of the names of the antecedent
//                                  classes. Starts from the top-most class.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR             On Success
//
//*****************************************************************************
//
//  SetPropertyOrigin
//
//  Sets the origin class of a property.  This function is only used in rare
//  circumstances where an object is constructed not from its standard transport
//  form.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszPropertyName   The name of the property tochange
//      IN long lOriginIndex        The index of the class of origin of this
//                                  property. Top-most class has index 0.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR             On Success
//      WBEM_E_NOT_FOUND            No such property
//      WBEM_E_INVALID_PARAMETER    Index out of range
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not a localization bit has been set.  The localization
//	bit is set in the class part header.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL	TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the class part header.  This bit is not
//	written out by Unmerge.
//
//  PARAMETERS:
//
//      BOOL	TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************

// Maximum number of properties we can have in a class object.  This is only
// because the handle returned by the IWbemObjectAccess only allows for 10-bits
// in order to store the data table index.

#define MAXNUM_CLASSOBJ_PROPERTIES	0x400

class COREPROX_POLARITY CClassPart : public CQualifierSetContainer, 
                   public CPropertyTableContainer,
                   public CDataTableContainer,
                   public CHeapContainer
{
public:
    CClassPartContainer* m_pContainer;
    CClassPart* m_pParent;

    friend CClassPQSContainer;

// The data in this structure is unaligned
#pragma pack(push, 1)
    struct CClassPartHeader
    {
        length_t nLength;
        BYTE fFlags;
        heapptr_t ptrClassName;
        length_t nDataLength;
    public:
         LPMEMORY CreateEmpty();
    };
#pragma pack(pop)

	CClassPartHeader* m_pHeader;

    CDerivationList m_Derivation;
    CClassQualifierSet m_Qualifiers;
    CPropertyLookupTable m_Properties;
    CDataTable m_Defaults;
    CFastHeap m_Heap;

public:
    CClassPart() : m_Qualifiers(1){}
     void SetData(LPMEMORY pStart, CClassPartContainer* pContainer,
        CClassPart* pParent = NULL );
     void SetDataWithNumProps(LPMEMORY pStart, CClassPartContainer* pContainer,
		 DWORD dwNumProperties, CClassPart* pParent = NULL );
     LPMEMORY GetStart() {return LPMEMORY(m_pHeader);}
     length_t GetLength() {return m_pHeader->nLength;}
     void Rebase(LPMEMORY pMemory);

	 LPMEMORY ResolveHeapPointer( heapptr_t ptr ) { return m_Heap.ResolveHeapPointer( ptr ); }
	 CCompressedString* ResolveHeapString( heapptr_t ptr ) { return m_Heap.ResolveString( ptr ); }

public:
     CCompressedString* GetSuperclassName()
    {
        return m_Derivation.GetFirst();
    }
     CCompressedString* GetDynasty()
    {
        CCompressedString* pcs = m_Derivation.GetLast();
        if(pcs == NULL)
            return GetClassName();
        else
            return pcs;
    }
     CCompressedString* GetClassName()
    {
        if(m_pHeader->ptrClassName == INVALID_HEAP_ADDRESS)
            return NULL;
        else 
            return m_Heap.ResolveString(m_pHeader->ptrClassName);
    }
        
     CPropertyLookup* GetPropertyLookup(int nIndex)
    {
        if(nIndex < m_Properties.GetNumProperties())
            return m_Properties.GetAt(nIndex);
        else 
            return NULL;
    }
     CPropertyInformation* FindPropertyInfo(LPCWSTR wszName);
     HRESULT GetDefaultValue(CPropertyInformation* pInfo, CVar* pVar);
     LPMEMORY GetPropertyQualifierSetData(LPCWSTR wszName);
     HRESULT GetDefaultValue(LPCWSTR wszName, CVar* pVar);
     HRESULT EnsureProperty(LPCWSTR wszName, VARTYPE vtValueType, 
                                CIMTYPE ctNativeType, BOOL fForce);
     HRESULT SetDefaultValue(LPCWSTR wszName, CVar* pVar);
     HRESULT GetClassQualifier(LPCWSTR wszName, CVar* pVal, 
                                    long* plFlavor = NULL, CIMTYPE* pct = NULL);
     HRESULT GetClassQualifier(LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedValue,
									CFastHeap** ppHeap, BOOL fValidateSet);
     HRESULT SetClassQualifier(LPCWSTR wszName, CVar* pVal, 
                                    long lFlavor = 0);
     HRESULT SetClassQualifier(LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue );
     HRESULT GetQualifier(LPCWSTR wszName, CVar* pVal, 
					         long* plFlavor = NULL, CIMTYPE* pct = NULL);
     HRESULT InitPropertyQualifierSet(LPCWSTR wszName, 
                                            CClassPropertyQualifierSet* pSet);
     HRESULT DeleteProperty(LPCWSTR wszName);
     HRESULT CopyParentProperty(CClassPart& ParentPart, LPCWSTR wszName);
     HRESULT GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                   long* plFlags);
     HRESULT GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                   long* plFlags);

     HRESULT GetClassName(CVar* pVar);
     HRESULT GetSuperclassName(CVar* pVar);
     HRESULT GetDynasty(CVar* pVar);
     HRESULT GetPropertyCount(CVar* pVar);
     HRESULT GetDerivation(CVar* pVar);
     HRESULT SetClassName(CVar* pVar);
     BOOL IsKeyed();                                                         
     BOOL IsTopLevel() {return m_Derivation.IsEmpty();}
     BOOL CheckLocalBoolQualifier( LPCWSTR pwszName );
     BOOL CheckBoolQualifier( LPCWSTR pwszName );

     BOOL GetIndexedProps(CWStringArray& awsNames);
     BOOL GetKeyProps(CWStringArray& awsNames);
     HRESULT GetKeyOrigin(WString& wsClass);
     BOOL IsPropertyKeyed(LPCWSTR pwcsKeyProp);
     BOOL IsPropertyIndexed(LPCWSTR pwcsIndexProp);
     HRESULT GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName);
     BOOL InheritsFrom(LPCWSTR wszClassName);

    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);

    void DeleteProperty(int nIndex)
    {
        m_Properties.DeleteProperty(m_Properties.GetAt(nIndex), 
                                    CPropertyLookupTable::e_UpdateDataTable);
    }

	BOOL IsLocalized( void )
	{
		return m_pHeader->fFlags & WBEM_FLAG_CLASSPART_LOCALIZATION_MASK;
	}

	void SetLocalized( BOOL fLocalized )
	{
		m_pHeader->fFlags &= ~WBEM_FLAG_CLASSPART_LOCALIZATION_MASK;
		m_pHeader->fFlags |= ( fLocalized ? WBEM_FLAG_CLASSPART_LOCALIZED :
								WBEM_FLAG_CLASSPART_NOT_LOCALIZED );
	}

public:
    EReconciliation CanBeReconciledWith(CClassPart& NewPart);
    EReconciliation ReconcileWith(CClassPart& NewPart);

	EReconciliation CompareExactMatch(CClassPart& thatPart, BOOL fLocalized = FALSE );

	BOOL CompareDefs(CClassPart& OtherPart);
    BOOL IsIdenticalWith(CClassPart& OtherPart);
protected:
     HRESULT SetDefaultValue(CPropertyInformation* pInfo, CVar* pVar);

public: // container functionality

    CFastHeap* GetHeap() {return &m_Heap;}
    HRESULT CanContainKey() {return WBEM_E_INVALID_QUALIFIER;}
     BOOL IsDynamic()
	 {
		 return CheckLocalBoolQualifier( L"Dynamic" );
	 }

     BOOL IsSingleton()
    {
        return CheckBoolQualifier(L"singleton");
    }

    BOOL IsAbstract()
    {
        return CheckBoolQualifier(L"abstract");
    }

    BOOL IsAssociation()
    {
        return CheckBoolQualifier(L"association");
    }

    BOOL IsAmendment()
    {
        return CheckBoolQualifier(L"amendment");
    }

    BOOL IsHiPerf()
    {
        return CheckBoolQualifier(L"HiPerf");
    }

    BOOL IsAutocook()
    {
        return CheckBoolQualifier(L"AutoCook");
    }

    BYTE GetAbstractFlavor();
    BOOL IsCompressed()
    {
        return m_Qualifiers.GetQualifier(L"compress") != NULL;
    }
    BOOL CanContainKeyedProps() 
    {
        return !m_pParent->IsKeyed() && !IsSingleton();
    }
    HRESULT CanContainSingleton() 
    {
		if ( !m_pParent->IsKeyed() && (IsSingleton() || !IsKeyed() ) )
		{
			return WBEM_S_NO_ERROR;
		}
		return WBEM_E_CANNOT_BE_SINGLETON;
    }
    HRESULT CanContainAbstract( BOOL fValue );
    HRESULT CanContainDynamic( void )
	{
		return WBEM_S_NO_ERROR;
	}
    BOOL CanHaveCimtype(LPCWSTR) 
    {
        return FALSE;
    }

    IUnknown* GetWbemObjectUnknown() 
        {return m_pContainer->GetWbemObjectUnknown();}

     length_t GetTotalRealLength()
    {
        return sizeof(CClassPartHeader) + m_Derivation.GetLength() +
            m_Qualifiers.GetLength() + 
            m_Properties.GetLength() + m_Defaults.GetLength() + 
            m_Heap.GetLength();
    }

     void SetDataLength(length_t nDataLength)
        {m_pHeader->nDataLength = nDataLength;}

     void Compact();
     BOOL ReallocAndCompact(length_t nNewTotalLength);

    BOOL ExtendHeapSize(LPMEMORY pStart, length_t nOldLength, length_t nExtra);
    void ReduceHeapSize(LPMEMORY pStart, length_t nOldLength, 
        length_t nDecrement){}
        
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nNewLength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement){}

    BOOL ExtendPropertyTableSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nNewLength);
    void ReducePropertyTableSpace(LPMEMORY pOld, length_t nOldLength,
        length_t nDecrement){}

    BOOL ExtendDataTableSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nNewLength);
    void ReduceDataTableSpace(LPMEMORY pOld, length_t nOldLength,
        length_t nDecrement);

    CDataTable* GetDataTable() {return &m_Defaults;}
	classindex_t GetClassIndex( LPCWSTR	pwszClassName )	{ return m_Derivation.Find( pwszClassName ); }
    classindex_t GetCurrentOrigin() {return m_Derivation.GetNumStrings();}
    LPMEMORY GetQualifierSetStart() {return m_Qualifiers.GetStart();}

    HRESULT GetPropQualifier(CPropertyInformation* pInfo, 
        LPCWSTR wszQualifier, CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);

    HRESULT GetPropQualifier(LPCWSTR wszName,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet);

public:
    static  GetMinLength()
    {
        return sizeof(CClassPartHeader) + CDerivationList::GetHeaderLength()
            + CClassQualifierSet::GetMinLength()
            + CPropertyLookupTable::GetMinLength() 
            + CDataTable::GetMinLength() + CFastHeap::GetMinLength();
    }
    static  LPMEMORY CreateEmpty(LPMEMORY pStart);

    static length_t EstimateMergeSpace(CClassPart& ParentPart, 
                                       CClassPart& ChildPart);

    static LPMEMORY Merge(CClassPart& ParentPart, CClassPart& ChildPart, 
        LPMEMORY pDest, int nAllocatedLength);    

    static HRESULT Update(CClassPart& ParentPart, CClassPart& ChildPart, long lFlags ); 
    static HRESULT UpdateProperties(CClassPart& ParentPart, CClassPart& ChildPart,
									long lFlags );
	HRESULT TestCircularReference( LPCWSTR pwcsClassName )
	{
		// Basically if the name is in the derivation list, we gots a
		// circular reference
		return ( m_Derivation.Find( pwcsClassName ) >= 0 ?
					WBEM_E_CIRCULAR_REFERENCE : WBEM_S_NO_ERROR );
	}

    length_t EstimateUnmergeSpace();
    LPMEMORY Unmerge(LPMEMORY pDest, int nAllocatedLength);

    length_t EstimateDerivedPartSpace();
    LPMEMORY CreateDerivedPart(LPMEMORY pDest, int nAllocatedLength);

    BOOL MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        OUT CLimitationMapping* pMap);

    LPMEMORY CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pWhere, 
        BOOL& bRemovedKeys);

    HRESULT GetPropertyHandle(LPCWSTR wszName, CIMTYPE* pvt, long* plHandle);
    HRESULT GetPropertyHandleEx(LPCWSTR wszName, CIMTYPE* pvt, long* plHandle);
    HRESULT GetPropertyInfoByHandle(long lHandle, BSTR* pstrName, 
                                    CIMTYPE* pct);
    HRESULT IsValidPropertyHandle( long lHandle );

	HRESULT GetDefaultByHandle(long lHandle, long lNumBytes,
                                        long* plRead, BYTE* pData );
	HRESULT GetDefaultPtrByHandle(long lHandle, void** ppData );
	heapptr_t GetHeapPtrByHandle( long lHandle )
	{ return *(PHEAPPTRT)(m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))); }

    HRESULT SetInheritanceChain(long lNumAntecedents, LPWSTR* awszAntecedents);
    HRESULT SetPropertyOrigin(LPCWSTR wszPropertyName, long lOriginIndex);

	HRESULT IsValidClassPart( void );
};

//*****************************************************************************
//*****************************************************************************
//
//  class CClassPartPtr
//
//  See CPtrSource in fastsprt.h for explanation of pointer sourcing. This one
//  is for a given offset from the start of a class part (see CClassPart above)
//  and is used to reference objects in the class part of an instance. The 
//  layout of such a class part never changes, but the memory block itself can
//  move, hence the source.
//
//*****************************************************************************

class CClassPartPtr : public CPtrSource
{
protected:
    CClassPart* m_pPart;
    offset_t m_nOffset;
public:

	// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
	// signed/unsigned 32-bit value. (m_nOffset)  We do not
	// support length > 0xFFFFFFFF so cast is ok.

     CClassPartPtr(CClassPart* pPart, LPMEMORY pCurrent) 
        : m_pPart(pPart), m_nOffset( (offset_t) ( pCurrent - pPart->GetStart() ) ) {}
     LPMEMORY GetPointer() {return m_pPart->GetStart() + m_nOffset;}
};





class COREPROX_POLARITY CClassAndMethods : public CMethodPartContainer, 
                                    public CClassPartContainer
{
public:
    CClassPart m_ClassPart;
    CMethodPart m_MethodPart;
    CWbemClass* m_pClass;

public:
    LPMEMORY GetStart() {return m_ClassPart.GetStart();}

	// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
	// signed/unsigned 32-bit value.  We do not support length
	// > 0xFFFFFFFF so cast is ok.

    length_t GetLength() {return (length_t) ( EndOf(m_MethodPart) - GetStart() );}
    static length_t GetMinLength();

    void SetData(LPMEMORY pStart, CWbemClass* pClass, 
                    CClassAndMethods* pParent = NULL );
    void SetDataWithNumProps(LPMEMORY pStart, CWbemClass* pClass, 
			DWORD dwNumProperties, CClassAndMethods* pParent = NULL );
    void Rebase(LPMEMORY pStart);
    static LPMEMORY CreateEmpty(LPMEMORY pStart);
	static BOOL GetIndexedProps(CWStringArray& awsNames, LPMEMORY pStart);
	static HRESULT GetClassName( WString& wsClassName, LPMEMORY pStart);
	static HRESULT GetSuperclassName( WString& wsSuperClassName, LPMEMORY pStart);


    length_t EstimateDerivedPartSpace();
    LPMEMORY CreateDerivedPart(LPMEMORY pStart, length_t nAllocatedLength);

    length_t EstimateUnmergeSpace();
    LPMEMORY Unmerge(LPMEMORY pStart, length_t nAllocatedLength);

    static length_t EstimateMergeSpace(CClassAndMethods& ParentPart, 
                                       CClassAndMethods& ChildPart);

    static LPMEMORY Merge(CClassAndMethods& ParentPart, 
                          CClassAndMethods& ChildPart, 
                          LPMEMORY pDest, int nAllocatedLength);    

    static HRESULT Update(CClassAndMethods& ParentPart, 
                          CClassAndMethods& ChildPart,
						  long lFlags );

    EReconciliation CanBeReconciledWith(CClassAndMethods& NewPart);
    EReconciliation ReconcileWith(CClassAndMethods& NewPart);

	EReconciliation CompareTo( CClassAndMethods& thatPart );

    LPMEMORY CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pWhere, 
        BOOL& bRemovedKeys);

    void Compact();
public: // container functionality
    BOOL ExtendClassPartSpace(CClassPart* pPart, length_t nNewLength);
    void ReduceClassPartSpace(CClassPart* pPart, length_t nDecrement){}
    BOOL ExtendMethodPartSpace(CMethodPart* pPart, length_t nNewLength);
    void ReduceMethodPartSpace(CMethodPart* pPart, length_t nDecrement){}
    IUnknown* GetWbemObjectUnknown();

    classindex_t GetCurrentOrigin();
};

//*****************************************************************************
//*****************************************************************************
//
//  class CWbemClass
//
//  Represents an WinMgmt class. Derived from CWbemObject and much of the
//  functionality is inherited.
//
//  The memory block of CWbemClass consists of three parts, one after another:
//
//  1) Decoration part (as described in CDecorationPart in fastobj.h) with the
//      information about the origins of the object. m_DecorationPart member
//      of CWbemObject mapos this data.
//  2) Parent class part containing all the information about my parent. Even
//      if this is a top-level class, this part is still present and pretends
//      that my parent is an unnamed class with no proeprties or qualifiers.
//      m_ParentPart member maps this data.
//  3) Actual class part containing all the information about this class.
//      m_CombinedPart member maps this data. It is called "combined" because
//      when a class is stored in the database, it is also in the form of a 
//      class part, but this one contains only the information that is 
//      different from my parent. Thus, when a class is loaded from the
//      database, the parent's part and the child's part are merged to produce
//      the combined part which becomes part of the in-memory object.
//
//  Since this class is derived from CWbemObject, it inherits all its functions.
//  Here, we describe only the functions implemented in CWbemClass.
//
//*****************************************************************************
//
//  SetData
//
//  Initialization function
//
//  PARAMETERS:
//
//      LPMEMORY pStart         The start of the memory block
//      int nTotalLength        The length of the memory block.
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t:       the length of the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object that its memory block has moved.
//
//  PARAMETERS:
//
//      LPMEMORY pBlock     The new location of the memory block
//
//*****************************************************************************
//
//  static GetMinLength
//
//  Computes the number of bytes required to hold an empty class definition.
//
//  RETURN VALUES:
//
//      length_t
//
//*****************************************************************************
//
//  CreateEmpty
//
//  Creates an empty class definition (without even a name) on a given block
//  of memory.
//
//  PARAMETERS:
//
//      LPMEMORY pStart     The memory block to create on.
//
//*****************************************************************************
//
//  EstimateDerivedClassSpace
//
//  Used when a derived class is created, this function (over-)estimates the
//  required space for a derived class (without any extra properties).
//
//  PARAMETERS:
//
//      CDecorationPart* pDecortation   Origin information to use. If NULL, the
//                                      estimate is for an undecorated class.
//  RETURN VALUES:
//
//      length_t;   the number of bytes required.
//
//*****************************************************************************
//
//  WriteDerivedClass
//
//  Creates the memory representation for a derived class with no extra 
//  properties or qualifiers (compared to ourselves).
//
//  PARAMETERS:
//
//      LPMEMORY pStart                 The memory block to write on. Assumed
//                                      to be large enough 
//                                      (see EstimateDerivedClassSpace)
//      CDecorationPart* pDecortation   Origin information to use. If NULL, the
//                                      estimate is for an undecorated class.
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the written data.
//
//*****************************************************************************
//
//  CreateDerivedClass
//
//  Initializes ourselves as a derived class of a given one. Allocates the
//  memory block.
//
//  PARAMETERS:
//
//      CWbemClass* pParent              Our parent class.
//      int nExtraSpace                 Extra space to pad the memory block.
//                                      This is for optimization only.
//      CDecorationPart* pDecortation   Origin information to use. If NULL, the
//                                      estimate is for an undecorated class.
//
//*****************************************************************************
//
//  EstimateUnmergeSpace
//
//  When a class is written to the database, only the information that is
//  different from the parent is written. That means that not only is 
//  m_CombinedPart the only part that is considered, but even it is further
//  "unmerged" to remove all the parent data.
//  This function estimates the amount of space that an unmerge would take.
//
//  RETURN VALUES:
//
//      length_t:   an (over-)estimate of the amount of space needed.
//
//*****************************************************************************
//
//  Unmerge
//
//  When a class is written to the database, only the information that is
//  different from the parent is written. That means that not only is 
//  m_CombinedPart the only part that is considered, but even it is further
//  "unmerged" to remove all the parent data.
//  This function creates this "unmerged" data which takes a form of a class
//  part.
//
//  PARAMETERS:
//
//      LPMEMORY pDest              Where to write to.
//      int nAllocatedLength        The size of the allocated block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   points to the first byte after the data written.
//
//*****************************************************************************
//
//  EstimateMergeSpace
//
//  As descrined in Unmerge, only a fraction of the class data is written to
//  the database. To recreate the class, one needs to take the parent class
//  (this) and merge it with the data from the database. This function
//  (over-)estimates the amount of space needed for the merge.
//
//  PARAMETERS:
//
//      LPMEMORY pChildPart             The data in the database
//      CDecorationPart* pDecoration    Origin information to use for the new
//                                      class. If NULL, create undecorated.
//  RETURN VALUES:
//
//      length_t:   (over-)estimate of the amount of space.
//
//*****************************************************************************
//
//  Merge
//
//  As descrined in Unmerge, only a fraction of the class data is written to
//  the database. To recreate the class, one needs to take the parent class
//  (this) and merge it with the data from the database. This function
//  creates the memory representation for the class given the parent (this) and
//  the database (unmerged) data.
//
//  PARAMETERS:
//
//      LPMEMORY pChildPart             The unmerged data in the database
//      LPMEMORY pDest                  Destination memory. Assumed to be large
//                                      enough (see EstimateMergeSpace)
//      int nAllocatedLength            Allocated size of the memory block.
//      CDecorationPart* pDecoration    Origin information to use for the new
//                                      class. If NULL, create undecorated.
//  RETURN VALUES:
//
//      LPMEMORY:   first byte after the data written
//
//*****************************************************************************
//
//  Update
//
//  As described in Unmerge, only a fraction of the class data is written to
//  the database. During an Update operation, a class may be reparented, in
//	which case its unmerged data needs to be merged with a potentially
//	destructive	class, so we will need to check what we are merging for potential
//	conflicts.
//
//  PARAMETERS:
//
//      CWbemClass*						pOldChild - Old Child class to update from.
//		long lFlags						Must be WBEM_FLAG_UPDATE_FORCE_MODE
//										or WBEM_FLAG_UPDATE_SAFE_MODE.
//		CWbemClass**					ppUpdatedChild - Storage for pointer to
//										updated child class.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR if successful
//
//*****************************************************************************
//
//  static CreateFromBlob
//
//  Helper function encapsulating Merge. Takes the parent class and the 
//  unmerged child class data from the database (see Merge and Unmerge for more
//  details) and creates the child class (allocating memory).
//
//  Parameters;
//
//      CWbemClass* pParent              The parent class
//      LPMEMORY pChildData             The unmerged child class data.
//
//  RETURN VALUES:
//
//      CWbemClass*: the newely created class. The caller must delete this
//          object when done.
//
//*****************************************************************************
//
//  InitEmpty
//
//  Creates an empty class. Allocates the data for the memory block. See
//  GetMinSpace for details.
//
//  PARAMETERS:
//
//      int nExtraMem       The amount of padding to add to the memory block.
//                          This is for optimization only.
//
//*****************************************************************************
//
//  CanBeReconciledWith
//
//  This method is called when a definition of a class is about to be replaced 
//  with another one. If the class has no instances or derived classes, such
//  an operation presents no difficulties. If it does, however, we need to be
//  careful not to break them. Thus, only the following changes are allowed:
//
//      1) Qualifier changes
//      2) Default value changes
//
//  PARAMETERS:
//
//      IN READONLY CWbemClass* pNewClass    The new definition to compare to.
//
//  RETURN VALUES:
//
//  EReconciliation:
//      e_Reconcilable          Can be reconciled --- i.e., compatible.
//      e_DiffClassName         The class name is different
//      e_DiffParentName        The parent class name is different.
//      e_DiffNumProperties     The number of properties is different
//      e_DiffPropertyName      A property has a different name
//      e_DiffPropertyType      A property has a different type
//      e_DiffPropertyLocation  A property has a different location in the 
//                              data table.
//      e_DiffKeyAssignment     A property that is a key in one class is not
//                              in the other.
//      e_DiffIndexAssignment   A property which is indexed in one class is not
//                              in the other.
//      
//*****************************************************************************
//
//  ReconcileWith
//
//  See CanBeReconciledWith above. This method is the same, except that if
//  reconciliation is possible (e_Reconcilable is returned) this class part is
//  replaced with the new one (the size is adjusted accordingly).
//
//  PARAMETERS:
//
//      IN READONLY CWbemClass* pNewClass    The new definition to compare to.
//
//  RETURN VALUES:
//
//  EReconciliation:
//      e_Reconcilable          We have been replaced with the new part.
//      e_DiffClassName         The class name is different
//      e_DiffParentName        The parent class name is different.
//      e_DiffNumProperties     The number of properties is different
//      e_DiffPropertyName      A property has a different name
//      e_DiffPropertyType      A property has a different type
//      e_DiffPropertyLocation  A property has a different location in the 
//                              data table.
//      e_DiffKeyAssignment     A property that is a key in one class is not
//                              in the other.
//      e_DiffIndexAssignment   A property which is indexed in one class is not
//                              in the other.
//      
//*****************************************************************************
//
//  CompareMostDerivedClass
//
//  This method is called when one needs to know if the most derived class
//	in a CWbemClass is different from the data contained in the supplied
//	class.  We do this by unmerging most derived class information from
//	the local class and the supplied class, and then performing a value by
//	value comparison of properties, methods and qualifiers.  All items must
//	match and be in	the same order.
//
//  PARAMETERS:
//
//      IN READONLY CWbemClass*	pOldClass - Class Data to compare to.
//
//  RETURN VALUES:
//
//  BOOL - TRUE if it has changed, FALSE if not
//      
//*****************************************************************************
//
//  MapLimitation
//
//  Produces an object representing a particular limitation on the objects, i.e.
//  which properties and what kinds of qualifiers should be in it.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to 
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      OUT CLimitationMapping* pMap    This mapping object (see fastprop.h) 
//                                      will be changed to reflect the 
//                                      parameters of the limitation. It can
//                                      then be used in CWbemInstance::
//                                      GetLimitedVersion function.
//  RETURNS:
//
//      BOOL:   TRUE.
//
//*****************************************************************************
//
//  FindLimitationError
//
//  Verifies if a limitation (based on the select clause) is a valid one, i.e.
//  that all the mentioned properties are indeed the properties of the class.
//
//  PARAMETERS:
//      
//      IN long lFlags              The flags specifying what information to 
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//  RETURNS:
//
//      WString:    empty if no errors were found. If an invalid property was
//                  found, the name of that property is returned.
//
//*****************************************************************************
//
//  GetClassPart
//
//  Returns the pointer to the m_CombinedPart
//
//  RETURN VALUES:
//
//      CClassPart*: pointer to the class part describing this class.
//
//*****************************************************************************
//
//  GetProperty
//
//  Gets the value of the property referenced
//  by a given CPropertyInformation structure (see fastprop.h). CWbemObject
//  can obtain this structure from the CClassPart it can get from GetClassPart,
//  so these two methods combined give CWbemObject own methods full access to
//  object properties, without knowing where they are stored.
//
//  PARAMETERS:
//
//      IN CPropertyInformation* pInfo  The information structure for the 
//                                      desired property.
//      OUT CVar* pVar                  Destination for the value. Must NOT
//                                      already contain a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      (No errors can really occur at this stage, since the property has 
//      already been "found").
//
//*****************************************************************************
//
//  GetProperty
//
//  Returns the value of a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the property to access.
//      OUT CVar* pVar          Destination for the value. Must not already
//                              contain a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the proeprty to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      CPropertyInformation*	pInfo - Identifies property to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  SetPropValue
//
//  Sets the value of the property. The property will be added if not already 
//  present.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property to set.
//      IN CVar *pVal           The value to store in the property.
//      IN CIMTYPE ctType       Specifies the actual type of the property. If 0
//                              no type changes are required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_TYPE_MISMATCH     The value does not match the property type
//
//*****************************************************************************
//
//  SetPropQualifier
//
//  Sets the value of a given qualifier on a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      IN long lFlavor         The flavor for the qualifier (see fastqual.h)
//      IN CVar *pVal           The value of the qualifier
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property.
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  GetPropQualifier
//
//  Retrieves the value of a given qualifier on a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      OUT CVar* pVar          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property or no such qualifier.
//
//*****************************************************************************
//
//  GetMethodQualifier
//
//  Retrieves the value of a given qualifier on a given method.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszMethod       The name of the method.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      OUT CVar* pVar          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such method or no such qualifier.
//
//*****************************************************************************
//
//  GetQualifier
//
//  Retrieves a qualifier from the class itself.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve.
//      OUT CVar* pVal          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//		BOOL fLocalOnly			Only get locals (default is TRUE)
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such qualifier.
//
//*****************************************************************************
//
//  GetNumProperties
//
//  Retrieves the number of properties in the object
//
//  RETURN VALUES:
//
//      int:
//
//*****************************************************************************
//
//  GetPropName
//
//  Retrieves the name of the property at a given index. This index has no 
//  meaning except inthe context of this enumeration. It is NOT the v-table
//  index of the property.
//
//  PARAMETERS:
//
//      IN int nIndex        The index of the property to retrieve. Assumed to
//                           be within range (see GetNumProperties).
//      OUT CVar* pVar       Destination for the name. Must not already contain
//                           a value.
//
//*****************************************************************************
//
//  IsKeyed
//
//  Verifies if this class has keys.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if the object either has 'key' properties or is singleton.
//
//*****************************************************************************
//
//  IsKeyLocal
//
//  Verifies if the specified property is keyed locally.
//
//  RETURN VALUES:
//
//		BOOL:   TRUE if the property is a key and is defined as such locally
//
//*****************************************************************************
//
//  IsIndexLocal
//
//  Verifies if the specified property is Indexed locally.
//
//  RETURN VALUES:
//
//		BOOL:   TRUE if the property is an index and is defined as such locally
//
//*****************************************************************************
//
//  GetRelPath
//
//  Returns the class name --- that's the relative path to a class.
//  
//  RETURN VALUES:
//
//      LPCWSTR: the newnely allocated string containing the path or NULL on 
//              errors. The caller must delete this string.
//
//*****************************************************************************
//
//  Decorate
//
//  Sets the origin information for the object.
//
//  PARAMETERS:
//
//      LPCWSTR wszServer       the name of the server to set.
//      LPCWSTR wszNamespace    the name of the namespace to set.
//
//*****************************************************************************
//
//  Undecorate
//
//  Removes the origin informaiton from the object
//
//*****************************************************************************
//
//  CompactAll
//
//  Compacts memory block removing any
//  holes between components. This does not include heap compaction and thus
//  is relatively fast.
//
//*****************************************************************************
//
//  GetGenus
//
//  Retrieves the genus of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetClassName
//
//  Retrieves the class name of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  GetDynasty
//
//  Retrieves the dynasty of the object, i.e. the name of the top-level class
//  its class is derived from.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  GetSuperclassName
//
//  Retrieves the parent class name of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class is a top-levle class.
//
//*****************************************************************************
//
//  GetPropertyCount
//
//  Retrieves the number of proerpties in the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetIndexedProps
//
//  Returns the array of the names of all the proeprties that are indexed.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyProps
//
//  Returns the array of the names of all the proeprties that are keys.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyOrigin
//
//  Returns the name of the class of origin of the keys.
//
//  PARAMETERS:
//
//      OUT CWString& wsClass       Destination for the name.
//
//*****************************************************************************
//
//  GetLimitedVersion
//
//  Produces a new CWbemClass based on this one and a limitation map 
//  (obtained from CWbemClass::MapLimitation, see fastcls.h).
//
//  PARAMETERS:
//
//      IN CLimitationMapping* pMap     The map to use to limit the properties
//                                      and qualifiers to use in the new
//                                      instance.
//      OUT CWbemClass** ppNewClass    Destination for the new object May
//                                      not be NULL. The caller is responsible
//                                      for calling Release on this pointer 
//                                      when no longer needed.
//  RETURNS:
//
//      WBEM_S_NO_ERROR            On success
//      WBEM_E_FAILED              On errors (none to date).
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not any localization bits have been set.  Localization
//	bits can be in either the parent or the combined part.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL	TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the combined part.
//
//  PARAMETERS:
//
//      BOOL	TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************
//**************************** IWbemClassObject interface **********************
//
//  Most members of this interface are implemented in CWbemObject. Others are
//  implemented here. For the description of these methods and their return
//  values, see help
//
//*****************************************************************************

typedef CPropertyInformation CPropertyLocation;


class COREPROX_POLARITY CWbemClass : public CWbemObject
{
protected:
    length_t m_nTotalLength;
    //CDecorationPart m_DecorationPart;
    CClassAndMethods m_ParentPart;
    CClassAndMethods m_CombinedPart;

    int  m_nCurrentMethod;
    LONG m_FlagMethEnum;
	CLimitationMapping*	m_pLimitMapping;
    friend class CWbemInstance;

public:
     CWbemClass() 
        : m_ParentPart(), m_CombinedPart(), 
            CWbemObject(m_CombinedPart.m_ClassPart.m_Defaults, 
                        m_CombinedPart.m_ClassPart.m_Heap,
                        m_CombinedPart.m_ClassPart.m_Derivation),
        m_FlagMethEnum(WBEM_FLAG_PROPAGATED_ONLY|WBEM_FLAG_LOCAL_ONLY),
        m_nCurrentMethod(-1), m_pLimitMapping( NULL )
     {}
	 ~CWbemClass();
     void SetData(LPMEMORY pStart, int nTotalLength);
     length_t GetLength() {return m_nTotalLength;}
     void Rebase(LPMEMORY pMemory);

protected:
    HRESULT GetProperty(CPropertyInformation* pInfo, CVar* pVar)
	{ return m_CombinedPart.m_ClassPart.GetDefaultValue(pInfo, pVar); }

    DWORD GetBlockLength() {return m_nTotalLength;}
    CClassPart* GetClassPart() {return &m_CombinedPart.m_ClassPart;}
public:
    HRESULT GetProperty(LPCWSTR wszName, CVar* pVal);
    HRESULT SetPropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType);
    HRESULT ForcePropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType);
    HRESULT GetQualifier(LPCWSTR wszName, CVar* pVal, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    virtual HRESULT GetQualifier(LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet);
    HRESULT SetQualifier(LPCWSTR wszName, CVar* pVal, long lFlavor = 0);
    HRESULT SetQualifier(LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue);
    HRESULT GetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, CVar* pVar,
        long* plFlavor = NULL, CIMTYPE* pct = NULL);

    HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, 
        CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet);
    HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);
	HRESULT FindMethod( LPCWSTR pwszMethod );

    HRESULT GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType, 
							long* plFlavor = NULL);
     HRESULT GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                   long* plFlags);


    HRESULT GetPropQualifier(CPropertyInformation* pInfo, 
        LPCWSTR wszQualifier, CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);

    HRESULT GetPropQualifier(LPCWSTR wszName, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet);

    HRESULT GetPropQualifier(CPropertyInformation* pInfo,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet);


	BOOL IsLocalized( void );
	void SetLocalized( BOOL fLocalized );

     int GetNumProperties()
    {
        return m_CombinedPart.m_ClassPart.m_Properties.GetNumProperties();
    }
    HRESULT GetPropName(int nIndex, CVar* pVal)
    {
		// Check for allocation failures
		 if ( !m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
				 m_CombinedPart.m_ClassPart.m_Properties.GetAt(nIndex)->ptrName)->
					StoreToCVar(*pVal) )
		 {
			 return WBEM_E_OUT_OF_MEMORY;
		 }

		 return WBEM_S_NO_ERROR;
    }

    HRESULT Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace);
    void Undecorate();

    BOOL IsKeyed() {return m_CombinedPart.m_ClassPart.IsKeyed();}
    BOOL IsDynamic() {return m_CombinedPart.m_ClassPart.IsDynamic();}
    BOOL IsSingleton() {return m_CombinedPart.m_ClassPart.IsSingleton();}
    BOOL IsAbstract() {return m_CombinedPart.m_ClassPart.IsAbstract();}
    BOOL IsAmendment() {return m_CombinedPart.m_ClassPart.IsAmendment();}
    BYTE GetAbstractFlavor() 
        {return m_CombinedPart.m_ClassPart.GetAbstractFlavor();}
    BOOL IsCompressed() {return m_CombinedPart.m_ClassPart.IsCompressed();}
    LPWSTR GetRelPath( BOOL bNormalized=FALSE );

    BOOL MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        OUT CLimitationMapping* pMap);

    WString FindLimitationError(
        IN long lFlags,
        IN CWStringArray* pwsNames);
        
	HRESULT CreateDerivedClass( CWbemClass** ppNewClass );

	virtual HRESULT	IsValidObj( void );

public:
    static  length_t GetMinLength() 
    {
        return CDecorationPart::GetMinLength() + 
                    2* CClassAndMethods::GetMinLength();
    }
    static  LPMEMORY CreateEmpty(LPMEMORY pStart);
    void CompactAll();

    HRESULT CopyBlobOf(CWbemObject* pSource);

     length_t EstimateDerivedClassSpace(
        CDecorationPart* pDecoration = NULL);
    HRESULT WriteDerivedClass(LPMEMORY pStart, int nAllocatedLength,
        CDecorationPart* pDecoration = NULL);
     HRESULT CreateDerivedClass(CWbemClass* pParent, int nExtraSpace = 0, 
        CDecorationPart* pDecoration = NULL);

     length_t EstimateUnmergeSpace();
     HRESULT Unmerge(LPMEMORY pDest, int nAllocatedLength, length_t* pnUnmergedLength);

    static  CWbemClass* CreateFromBlob(CWbemClass* pParent, LPMEMORY pChildPart);

     length_t EstimateMergeSpace(LPMEMORY pChildPart, 
        CDecorationPart* pDecoration = NULL);
     LPMEMORY Merge(LPMEMORY pChildPart, 
        LPMEMORY pDest, int nAllocatedLength,
        CDecorationPart* pDecoration = NULL);

     HRESULT Update( CWbemClass* pOldChild, long lFlags, CWbemClass** pUpdatedChild );

     HRESULT InitEmpty( int nExtraMem = 0, BOOL fCreateSystemProps = TRUE );

     EReconciliation CanBeReconciledWith(CWbemClass* pNewClass);
     EReconciliation ReconcileWith(CWbemClass* pNewClass);

	// This function will throw an exception in OOM scenarios.
	HRESULT CompareMostDerivedClass( CWbemClass* pOldClass );

    BOOL IsChildOf(CWbemClass* pClass);
public:
     HRESULT GetClassName(CVar* pVar)
        {return m_CombinedPart.m_ClassPart.GetClassName(pVar);}
     HRESULT GetSuperclassName(CVar* pVar)
        {return m_CombinedPart.m_ClassPart.GetSuperclassName(pVar);}
     HRESULT GetDynasty(CVar* pVar);
     HRESULT GetPropertyCount(CVar* pVar)
        {return m_CombinedPart.m_ClassPart.GetPropertyCount(pVar);}
     HRESULT GetGenus(CVar* pVar)
    {
        pVar->SetLong(WBEM_GENUS_CLASS);
        return WBEM_NO_ERROR;
    }

     BOOL GetIndexedProps(CWStringArray& awsNames)
        {return m_CombinedPart.m_ClassPart.GetIndexedProps(awsNames);}
     BOOL GetKeyProps(CWStringArray& awsNames)
        {return m_CombinedPart.m_ClassPart.GetKeyProps(awsNames);}
     HRESULT GetKeyOrigin(WString& wsClass)
        {return m_CombinedPart.m_ClassPart.GetKeyOrigin( wsClass );}

    HRESULT AddPropertyText(WString& wsText, CPropertyLookup* pLookup,
                                    CPropertyInformation* pInfo, long lFlags);
    HRESULT WritePropertyAsMethodParam(WString& wsText, int nIndex, 
                    long lFlags, CWbemClass* pDuplicateParamSet, BOOL fIgnoreDups );
    HRESULT GetIds(CFlexArray& adwIds, CWbemClass* pDupParams = NULL);
    HRESULT EnsureQualifier(LPCWSTR wszQual);

    HRESULT GetLimitedVersion(IN CLimitationMapping* pMap, 
                              NEWOBJECT CWbemClass** ppNewObj);

	BOOL IsKeyLocal( LPCWSTR pwcsKeyProp );
	BOOL IsIndexLocal( LPCWSTR pwcsIndexedProp );

public: // container functionality
    BOOL ExtendClassAndMethodsSpace(length_t nNewLength);
    void ReduceClassAndMethodsSpace(length_t nDecrement){}
    IUnknown* GetWbemObjectUnknown() 
        {return (IUnknown*)(IWbemClassObject*)this;}
    classindex_t GetCurrentOrigin() {return m_CombinedPart.m_ClassPart.GetCurrentOrigin();}

    HRESULT ForcePut(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);

public:
    STDMETHOD(GetQualifierSet)(IWbemQualifierSet** ppQualifierSet);
    //STDMETHOD(Get)(BSTR Name, long lFlags, VARIANT* pVal, long* plType, long* plFlavor);
    STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
    STDMETHOD(Delete)(LPCWSTR wszName);
    //STDMETHOD(GetNames)(LPCWSTR wszQualifierName, long lFlags, VARIANT* pVal, 
    //                    SAFEARRAY** pNames);
    //STDMETHOD(BeginEnumeration)(long lEnumFlags)
    //STDMETHOD(Next)(long lFlags, BSTR* pstrName, VARIANT* pVal)
    //STDMETHOD(EndEnumeration)()
    STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty, 
                                       IWbemQualifierSet** ppQualifierSet);        
    STDMETHOD(Clone)(IWbemClassObject** ppCopy);
    STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax);
    STDMETHOD(SpawnDerivedClass)(long lFlags, IWbemClassObject** ppNewClass);
    STDMETHOD(SpawnInstance)(long lFlags, IWbemClassObject** ppNewInstance);
    STDMETHOD(CompareTo)(long lFlags, IWbemClassObject* pCompareTo);

    STDMETHOD(GetMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                            IWbemClassObject** ppOutSig);
    STDMETHOD(PutMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                            IWbemClassObject* pOutSig);
    STDMETHOD(DeleteMethod)(LPCWSTR wszName);
    STDMETHOD(BeginMethodEnumeration)(long lFlags);
    STDMETHOD(NextMethod)(long lFlags, BSTR* pstrName, 
                       IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig);
    STDMETHOD(EndMethodEnumeration)();
    STDMETHOD(GetMethodQualifierSet)(LPCWSTR wszName, IWbemQualifierSet** ppSet);
    STDMETHOD(GetMethodOrigin)(LPCWSTR wszMethodName, BSTR* pstrClassName);

    STDMETHOD(SetInheritanceChain)(long lNumAntecedents, 
        LPWSTR* awszAntecedents);
    STDMETHOD(SetPropertyOrigin)(LPCWSTR wszPropertyName, long lOriginIndex);
    STDMETHOD(SetMethodOrigin)(LPCWSTR wszMethodName, long lOriginIndex);

	// _IWmiObject Methods
    STDMETHOD(SetObjectParts)( LPVOID pMem, DWORD dwMemSize, DWORD dwParts )
	{ return E_NOTIMPL; }

    STDMETHOD(GetObjectParts)( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed )
	{ return E_NOTIMPL; }

    STDMETHOD(StripClassPart)()		{ return E_NOTIMPL; }

    STDMETHOD(GetClassPart)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
	{ return E_NOTIMPL; }
    STDMETHOD(SetClassPart)( LPVOID pClassPart, DWORD dwSize )
	{ return E_NOTIMPL; }
    STDMETHOD(MergeClassPart)( IWbemClassObject *pClassPart )
	{ return E_NOTIMPL; }

	STDMETHOD(ClearWriteOnlyProperties)(void)
	{ return WBEM_E_INVALID_OPERATION; }

	// _IWmiObject Methods
	STDMETHOD(CloneEx)( long lFlags, _IWmiObject* pDestObject );
    // Clones the current object into the supplied one.  Reuses memory as
	// needed

	STDMETHOD(CopyInstanceData)( long lFlags, _IWmiObject* pSourceInstance );
	// Copies instance data from source instance into current instance
	// Class Data must be exactly the same

    STDMETHOD(IsParentClass)( long lFlags, _IWmiObject* pClass );
	// Checks if the current object is a child of the specified class (i.e. is Instance of,
	// or is Child of )

    STDMETHOD(CompareDerivedMostClass)( long lFlags, _IWmiObject* pClass );
	// Compares the derived most class information of two class objects.

    STDMETHOD(GetClassSubset)( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass );
	// Creates a limited representation class for projection queries

    STDMETHOD(MakeSubsetInst)( _IWmiObject *pInstance, _IWmiObject** pNewInstance );
	// Creates a limited representation instance for projection queries
	// "this" _IWmiObject must be a limited class

	STDMETHOD(Merge)( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj );
	// Merges a blob with the current object memory and creates a new object

	STDMETHOD(ReconcileWith)( long lFlags, _IWmiObject* pNewObj );
	// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
	// is specified this will only perform a test

	STDMETHOD(Upgrade)( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild );
	// Upgrades class and instance objects

	STDMETHOD(Update)( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass );
	// Updates derived class object using the safe/force mode logic

	STDMETHOD(SpawnKeyedInstance)( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst );
	// Spawns an instance of a class and fills out the key properties using the supplied
	// path.

	STDMETHOD(GetParentClassFromBlob)( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass );
	// Returns the parent class name from a BLOB

};

//#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\enummrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    ENUMMRSH.CPP

Abstract:

    Object Enumerator Marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "enummrsh.h"
#include <fastall.h>
#include <cominit.h>

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CEnumFactoryBuffer::XEnumFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CEnumFactoryBuffer::XEnumFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IEnumWbemClassObject)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CEnumProxyBuffer* pProxy = new CEnumProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CEnumFactoryBuffer::XEnumFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IEnumWbemClassObject 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CEnumFactoryBuffer::XEnumFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IEnumWbemClassObject)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CEnumStubBuffer* pStub = new CEnumStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {

        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CEnumFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CEnumFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CEnumFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XEnumFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CEnumProxyBuffer::CEnumProxyBuffer
//  ~CEnumProxyBuffer::CEnumProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CEnumProxyBuffer::CEnumProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IEnumWbemClassObject ),
        m_XEnumFacelet(this), m_pOldProxyEnum( NULL ), m_fTriedSmartEnum( FALSE ),
        m_fUseSmartEnum( FALSE ), m_hSmartNextMutex( INVALID_HANDLE_VALUE ),
        m_pSmartEnum( NULL )
{
    InitializeCriticalSection( &m_cs );
}

CEnumProxyBuffer::~CEnumProxyBuffer()
{
    if ( NULL != m_pSmartEnum )
    {
        m_pSmartEnum->Release();
    }

    // This MUST be released before releasing
    // the Proxy pointer
    if ( NULL != m_pOldProxyEnum )
    {
        m_pOldProxyEnum->Release();
    }

    // Cleanup the mutex
    if ( INVALID_HANDLE_VALUE != m_hSmartNextMutex )
    {
        CloseHandle( m_hSmartNextMutex );
    }

    DeleteCriticalSection( &m_cs );

}

void* CEnumProxyBuffer::GetInterface( REFIID riid )
{
    if(riid == IID_IEnumWbemClassObject)
        return &m_XEnumFacelet;
    else return NULL;
}

void** CEnumProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return (void**) &m_pOldProxyEnum;
}

void CEnumProxyBuffer::ReleaseOldProxyInterface( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pOldProxyEnum )
    {
        m_pOldProxyEnum->Release();
        m_pOldProxyEnum = NULL;
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}


//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return our security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

        // Make sure we have a smart enumerator and that we are going to
        // be using it.  If so, make sure the values applied to us are also
        // applied to it's proxy

        if ( SUCCEEDED( m_pObject->InitSmartEnum( TRUE, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities ) ) && m_pObject->m_fUseSmartEnum )
        {
            // Now repeat the above operation for the smart enumerator
            // Set the proxy blanket, ignore IUnknown if we are not going remote
            hr = WbemSetProxyBlanket( m_pObject->m_pSmartEnum, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_pObject->m_fRemote );

        }   // If initialized smart enumerator

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//////////////////////////////////////////////
//////////////////////////////////////////////

//  IEnumWbemClassObject Methods -- Pass Thrus for now

//////////////////////////////////////////////
//////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Reset()
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Reset();

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Next(long lTimeout, ULONG uCount, IWbemClassObject** apObj, ULONG FAR* puReturned)
{

    // At this point we will Query for the new, improved IEnumWCOSmartNext interface.
    // If we get it, we will maintain a pointer to that interface and
    // pass through to that interface.  We will also call CoCreateGuid() so
    // we get a unique identifier on the other end for sending wbem objects
    // back and forth cleanly.

    // The interface will have a single method IEnumWCOSmartNext::Next
    // This will take a GUID identifying this proxy, lTimeout, uCount,
    // puReturned, then dwBuffSize and BYTE**.

    // The other end will allocate memory via CoTaskMemAlloc and this side will
    // Free it via CoTaskMemFree.

    // The other side will Marshal returned objects into the memory block.
    // This side will Unmarshal it (and then free the block).

    //
    //  SAMPLE IDL:
    //  IEnumWCOSmartNext::Next(    [in] GUID proxyGUID,
    //                              [in] LONG lTimeout,
    //                              [in] unsigned long uCount,
    //                              [in, out] DWORD* puReturned,
    //                              [in, out] DWORD* pdwBuffSize,
    //                              [in, out, size_is[,*pdwBuffSize] BYTE** pBuffer
    //

    // Also, we will need to queue calls into this proxy, preserving timeouts,
    // so I'm thinking a mutex would come in handy about now...

    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure the timeout value makes sense and that puReturned and apObj are non-NULL
    if ( ( lTimeout < 0 && lTimeout != WBEM_INFINITE )  ||
        ( NULL == puReturned ) ||
        ( NULL == apObj ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Check that puReturned and apObj are non-NULL

    // Make sure we have a smart enumerator if we can get one
    m_pObject->InitSmartEnum();

    // If we have a smart enumerator, go behind everyone's back and use this guy (nobody
    // will be the wiser...

    if ( m_pObject->m_fUseSmartEnum && NULL != m_pObject->m_pSmartEnum )
    {
        DWORD   dwOldTick = GetTickCount();
        DWORD   dwReturn = WaitForSingleObject( m_pObject->m_hSmartNextMutex, lTimeout );

        if (  WAIT_OBJECT_0 == dwReturn )
        {
            BYTE*   pBuffer = NULL;
            ULONG   uSizeOfBuffer = 0;

            // Adjust timeout (if it was > 0) for any milliseconds we may
            // have just been waiting.

            if ( lTimeout > 0 )
            {
                // Get the current tick count.  Be aware that a tick count will
                // rollover every 30 some odd days, so trap for this case by
                // checking that the new tick count >= the old one
                
                DWORD   dwCurrTick = GetTickCount();
                dwCurrTick = ( dwCurrTick >= dwOldTick ? dwCurrTick : dwOldTick );

                // Adjust the timeout, but don't let it fall below 0
                lTimeout -= ( dwCurrTick - dwOldTick );
                lTimeout = ( lTimeout < 0 ? 0 : lTimeout );
            }

            // Ask the server for objects
            hr = m_pObject->m_pSmartEnum->Next( m_pObject->m_guidSmartEnum, lTimeout, uCount, puReturned, &uSizeOfBuffer, &pBuffer );

            // Only need to unmarshal if objects are in the buffer
            if ( SUCCEEDED( hr ) && *puReturned > 0 )
            {

                CWbemSmartEnumNextPacket packet( (LPBYTE) pBuffer, uSizeOfBuffer );
                long lObjectCount = 0L; 
                IWbemClassObject ** pObjArray = NULL;

                // hr will contain the call's proper return code.  Make sure we don't override it unless
                // the unmarshaling fails.
                HRESULT hrUnmarshal = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

                if ( SUCCEEDED( hrUnmarshal ) && lObjectCount > 0 && NULL != pObjArray )
                {
                    // Copy *puReturned pointers from the allocated pObjArray into apObj.
                    CopyMemory( apObj, pObjArray, ( *puReturned * sizeof(IWbemClassObject*) ) );

                    // Clean up pObjArray  It is the caller's responsibility to free
                    // the IWbemClassObject* pointers.
                    delete [] pObjArray;

                }   // IF UnmarshalPacket
				else if ( SUCCEEDED( hr ) )
				{
					// If the unmarshal succeeded but we got no objects or no array,
					// something is badly wrong
					hr = WBEM_E_UNEXPECTED;
				}
                else
                {
                    hr = hrUnmarshal;
                }

                // Free the memory buffer (allocated by WinMgmt via CoTaskMemAlloc)
                CoTaskMemFree( pBuffer );

            }   // IF Next

            ReleaseMutex( m_pObject->m_hSmartNextMutex );

        }   // IF WAIT_OBJECT_0
        else if ( WAIT_TIMEOUT == dwReturn )
        {
            // Timed out on the mutex
            hr = WBEM_S_TIMEDOUT;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

    }   // IF using Smart Enumeration
    else
    {
        // No Smart enumerator (doh!), so use the old one
        hr = m_pObject->m_pOldProxyEnum->Next( lTimeout, uCount, apObj, puReturned );
    }

    return hr;

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      NextAsync(ULONG uCount, IWbemObjectSink* pSink)
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->NextAsync( uCount, pSink );

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Clone(IEnumWbemClassObject** pEnum)
{

	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == pEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Clone( pEnum );

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Skip(long lTimeout, ULONG nNum)
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Skip( lTimeout, nNum );

}

//***************************************************************************
//
//  HRESULT CEnumProxyBuffer::InitSmartEnum(void)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  This function sets up
//  the smart enumerator pointer so we can perform intelligent marshaling.
//  This cannot be called during a Connect operation.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CEnumProxyBuffer::InitSmartEnum( BOOL fSetBlanket, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Function MUST be thread safe
    CInCritSec ics(&m_cs);

    // If we haven't tried to estalish smart enumeration, do so now

    // If we haven't tried to get a smart enumerator, try to get one.  If
    // we are able to get one, initialize member data we will use in all
    // operations from this proxy.

    if ( NULL == m_pSmartEnum )
    {

        // We'll only get this interface pointer if the server is a new
        // version that understands this interface.  If it does, the pointer
        // will be marshaled through for us.  To get to this pointer,
        // we go directly through our punkOuter.  From the "fetcher" interface
        // we will then get the actual smart enumerator.  We can then free up
        // the fetcher and release it's lock on the proxy manager.  The
        // smart enumerator will be handled on its own.

        IWbemFetchSmartEnum*    pFetchSmartEnum;

        hr = m_pUnkOuter->QueryInterface( IID_IWbemFetchSmartEnum, (void**) &pFetchSmartEnum );

        // Generate a GUID to identify us when we call the smart enumerator
        if ( SUCCEEDED( hr ) )
        {

            // If we need to, set the blanket on the proxy, otherwise, the call to GetSmartEnum
            // may fail.
            if ( fSetBlanket )
            {
                // Ignore the IUnknown if we are not remoting
                hr = WbemSetProxyBlanket( pFetchSmartEnum, AuthnSvc, AuthzSvc, pServerPrincName,
                            AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_fRemote );
            }

            if ( SUCCEEDED( hr ) )
            {

                hr = pFetchSmartEnum->GetSmartEnum( &m_pSmartEnum );

                if ( SUCCEEDED( hr ) )
                {
                    // We need a GUID
                    hr = CoCreateGuid( &m_guidSmartEnum );

                    if ( SUCCEEDED( hr ) )
                    {
                        // We'll also need a Mutex (so we can timeout) here

                        m_hSmartNextMutex = CreateMutex( NULL, FALSE, NULL );

                        if ( INVALID_HANDLE_VALUE != m_hSmartNextMutex )
                        {
                            // We have everything we need to do things smartly
                            m_fUseSmartEnum = TRUE;
                        }
                    }   // IF CoCreateGuid

                }   // IF got Smart Enumerator

            }   // IF security OK
            
            // Done with the fetcher interface
            pFetchSmartEnum->Release();

        }   // IF QueryInterface
        else
        {
            hr = WBEM_S_NO_ERROR;
        }

    }   // IF NULL == m_pSmartEnum

    return hr;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CEnumFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CEnumFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CEnumStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XEnumStublet;
    else
        return NULL;
}

CEnumStubBuffer::XEnumStublet::XEnumStublet(CEnumStubBuffer* pObj) 
    : CBaseStublet( pObj, IID_IEnumWbemClassObject ), m_pServer(NULL)
{
}

CEnumStubBuffer::XEnumStublet::~XEnumStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CEnumStubBuffer::XEnumStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CEnumStubBuffer::XEnumStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CEnumStubBuffer::XEnumStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastcls.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTCLS.CPP

Abstract:

  This file implements out-of-line functions for the classes related to
  class representation in WbemObjects. See fastcls.inc for the implementations
  of  functions.

    For complete documentation of all classes and methods, see fastcls.h

  Classes implemented:
      CClassPart              Derived class definition
      CWbemClass               Complete class definition.

History:

    3/10/97     a-levn  Fully documented
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
//#include "dbgalloc.h"
#include "wbemutil.h"
#include "fastall.h"
#include <wbemint.h>
#include "olewrap.h"
#include <arrtempl.h>

// For the WbemClassObject Factory
extern ULONG g_cLock;

#define TYPEQUAL L"CIMTYPE"

LPMEMORY CDerivationList::CreateLimitedRepresentation(CLimitationMapping* pMap,
                                            LPMEMORY pWhere)
{
    if(pMap->ShouldIncludeDerivation())
    {
        memcpy(pWhere, GetStart(), GetLength());
        return pWhere + GetLength();
    }
    else
    {
        return CreateEmpty(pWhere);
    }
}


 LPMEMORY CClassPart::CClassPartHeader::CreateEmpty()
{
    nLength = CClassPart::GetMinLength();
    fFlags = 0;
    ptrClassName = INVALID_HEAP_ADDRESS;
    nDataLength = 0;
    return LPMEMORY(this) + sizeof CClassPartHeader;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 LPMEMORY CClassPart::CreateEmpty(LPMEMORY pStart)
{
    LPMEMORY pCurrent;
    pCurrent = ((CClassPartHeader*)pStart)->CreateEmpty();
    pCurrent = CDerivationList::CreateEmpty(pCurrent);
    pCurrent = CClassQualifierSet::CreateEmpty(pCurrent);
    pCurrent = CPropertyLookupTable::CreateEmpty(pCurrent);
    pCurrent = CDataTable::CreateEmpty(pCurrent);
    pCurrent = CFastHeap::CreateEmpty(pCurrent);

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF so cast is ok

    ((CClassPartHeader*)pStart)->nLength = (length_t) (pCurrent - pStart);

    return pCurrent;
}


//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************

 void CClassPart::SetData(LPMEMORY pStart,
                                CClassPartContainer* pContainer,
                                CClassPart* pParent)
{
    m_pContainer = pContainer;
    m_pParent = pParent;

    m_pHeader = (CClassPartHeader*)pStart;

    m_Derivation.SetData(pStart + sizeof(CClassPartHeader));
    m_Qualifiers.SetData(EndOf(m_Derivation), this,
        (pParent) ? &pParent->m_Qualifiers : NULL);
    m_Properties.SetData( EndOf(m_Qualifiers), this);
    m_Defaults.SetData( EndOf(m_Properties),
        m_Properties.GetNumProperties(), m_pHeader->nDataLength, this);
    m_Heap.SetData( EndOf(m_Defaults), this);
}

 //******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************

 void CClassPart::SetDataWithNumProps(LPMEMORY pStart,
                                CClassPartContainer* pContainer,
                                DWORD dwNumProperties,
                                CClassPart* pParent)
{
    m_pContainer = pContainer;
    m_pParent = pParent;

    m_pHeader = (CClassPartHeader*)pStart;

    m_Derivation.SetData(pStart + sizeof(CClassPartHeader));
    m_Qualifiers.SetData(EndOf(m_Derivation), this,
        (pParent) ? &pParent->m_Qualifiers : NULL);
    m_Properties.SetData( EndOf(m_Qualifiers), this);

    // The datatable in this case is initialized with the
    // total number of properties, so we will be able to
    // access the default values.
    m_Defaults.SetData( EndOf(m_Properties),
        ( dwNumProperties == 0 ? m_Properties.GetNumProperties() : dwNumProperties ),
        m_pHeader->nDataLength, this);

    m_Heap.SetData( EndOf(m_Defaults), this);
}
//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 void CClassPart::Rebase(LPMEMORY pNewMemory)
{
    m_pHeader = (CClassPartHeader*)pNewMemory;

    m_Derivation.Rebase(pNewMemory + sizeof(CClassPartHeader));
    m_Qualifiers.Rebase( EndOf(m_Derivation));
    m_Properties.Rebase( EndOf(m_Qualifiers));
    m_Defaults.Rebase( EndOf(m_Properties));
    m_Heap.Rebase( EndOf(m_Defaults));
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CClassPart::ReallocAndCompact(length_t nNewTotalLength)
{
    BOOL    fReturn = TRUE;

    Compact();

    // Reallocate if required (will call rebase)
    // =========================================

    if(nNewTotalLength > m_pHeader->nLength)
    {
        // Check the return in case of allocation failure.
        fReturn = m_pContainer->ExtendClassPartSpace(this, nNewTotalLength);

        if ( fReturn )
        {
            m_pHeader->nLength = nNewTotalLength;
        }
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 void CClassPart::Compact()
{
    // Compact
    // =======

    CopyBlock(m_Derivation, GetStart() + sizeof(CClassPartHeader));
    CopyBlock(m_Qualifiers, EndOf(m_Derivation));
    CopyBlock(m_Properties, EndOf(m_Qualifiers));
    CopyBlock(m_Defaults, EndOf(m_Properties));
    CopyBlock(m_Heap, EndOf(m_Defaults));
    m_Heap.Trim();
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 CPropertyInformation* CClassPart::FindPropertyInfo(LPCWSTR wszName)
{
    CPropertyLookup* pLookup = m_Properties.FindProperty(wszName);
    if(pLookup == NULL) return NULL;
    return (CPropertyInformation*)
        m_Heap.ResolveHeapPointer(pLookup->ptrInformation);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetDefaultValue(CPropertyInformation* pInfo,
                                        CVar* pVar)
{
    if(m_Defaults.IsNull(pInfo->nDataIndex))
    {
        pVar->SetAsNull();
        return WBEM_S_NO_ERROR;
    }
    CUntypedValue* pValue = m_Defaults.GetOffset(pInfo->nDataOffset);

    if ( !pValue->StoreToCVar(pInfo->GetType(), *pVar, &m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetDefaultValue(LPCWSTR wszName, CVar* pVar)
{
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;
    return GetDefaultValue(pInfo, pVar);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::SetDefaultValue(CPropertyInformation* pInfo,
                                           CVar* pVar)
{
    // If new value is NULL, set the bit and return
    // ============================================

    m_Defaults.SetDefaultness(pInfo->nDataIndex, FALSE);
    m_Defaults.SetNullness(pInfo->nDataIndex, TRUE);

    if(pVar->IsNull() || pVar->IsDataNull())
    {
    }
    else
    {
        // Check the type
        // ==============

        if(!CType::DoesCIMTYPEMatchVARTYPE(pInfo->GetType(),
                                            (VARTYPE) pVar->GetOleType()))
        {
            // Attempt coercion
            // ================

            if(!pVar->ChangeTypeTo(CType::GetVARTYPE(pInfo->GetType())))
                return WBEM_E_TYPE_MISMATCH;
        }

        // Create a value pointing to the right offset in the data table
        // =============================================================

        int nDataIndex = pInfo->nDataIndex;
        CDataTablePtr ValuePtr(&m_Defaults, pInfo->nDataOffset);

        // Load it (types have already been checked)
        // =========================================

        // Check return values (this may fail in a memory allocation)
        Type_t  nReturnType;
        HRESULT hr = CUntypedValue::LoadFromCVar(&ValuePtr, *pVar,
                        CType::GetActualType(pInfo->GetType()), &m_Heap, nReturnType, FALSE); // reuse old
        if ( FAILED( hr ) )
        {
            // 
            // BUG: in the perfect world, we should remove the property if it
            // wasn't there before since the value supplied for it was invalid
            // But as it is, we'll simply leave the property there and the 
            // value default

            return hr;
        }

        // Check for invalid return types
        if ( CIM_ILLEGAL == nReturnType )
            return WBEM_E_TYPE_MISMATCH;

        pInfo = NULL; // invalidated

        // Reset special bits
        // ==================

        m_Defaults.SetNullness(nDataIndex, FALSE);
        m_Defaults.SetDefaultness(nDataIndex, FALSE);
    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::EnsureProperty(LPCWSTR wszName, VARTYPE vtValueType,
                                        CIMTYPE ctNativeType, BOOL fForce)
{
    if((CIMTYPE)CType::GetActualType(ctNativeType) != ctNativeType)
        return WBEM_E_INVALID_PROPERTY_TYPE;

    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo)
    {
        // Make sure it is of the right property type
        // ==========================================

        if(ctNativeType &&
            ctNativeType != (CIMTYPE)CType::GetActualType(pInfo->nType))
        {
            // Wrong type. Delete the property and start from scratch
            // ======================================================

            if(CType::IsParents(pInfo->nType))
                return WBEM_E_PROPAGATED_PROPERTY;

            CPropertyLookup* pLookup = m_Properties.FindProperty(wszName);
            m_Properties.DeleteProperty(pLookup,
                CPropertyLookupTable::e_UpdateDataTable);
        }
        else
        {
            return WBEM_S_NO_ERROR;
        }
    }

    // Make sure we will not exceed the maximum number of properties
    // Remember that we haven't added the new property yet, so we need
    // to check that we are not already at the property limit.
    if ( m_Properties.GetNumProperties() >= CSystemProperties::MaxNumProperties() )
    {
        return WBEM_E_TOO_MANY_PROPERTIES;
    }

    // =====================================
    // The property does not exist (anymore)

    if(ctNativeType == 0)
        ctNativeType = CType::VARTYPEToType(vtValueType);

    // Check the name for validity
    // ===========================

	// Each check below will be ignored if the fForce flag is TRUE

	// We allow underscores now
    if(!IsValidElementName2(wszName, TRUE) && !fForce)
        return WBEM_E_INVALID_PARAMETER;

    // Check type for validity
    // =======================

    CType Type = ctNativeType;
    if(CType::GetLength(Type.GetBasic()) == 0 && !fForce)
    {
        return WBEM_E_INVALID_PROPERTY_TYPE;
    }

    // Insert it (automatically set to NULL)
    // =====================================

    int nLookupIndex = 0;

    // Check for failure (out of memory)
    HRESULT hr = m_Properties.InsertProperty(wszName, Type, nLookupIndex );
    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropertyLookup* pLookup = m_Properties.GetAt(nLookupIndex);
    pInfo = (CPropertyInformation*)
        GetHeap()->ResolveHeapPointer(pLookup->ptrInformation);

    // Add "cimtype" qualifier to it
    // ============================

    LPWSTR wszSyntax = CType::GetSyntax(pInfo->nType);
    if(wszSyntax == NULL) return WBEM_S_NO_ERROR;

    CVar vSyntax;
    vSyntax.SetBSTR(wszSyntax, FALSE);
    return SetPropQualifier(wszName, TYPEQUAL,
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE, &vSyntax);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::DeleteProperty(LPCWSTR wszName)
{
    CPropertyLookup* pLookup = m_Properties.FindProperty(wszName);
    if(pLookup == NULL) return WBEM_E_NOT_FOUND;
    m_Properties.DeleteProperty(pLookup,
        CPropertyLookupTable::e_UpdateDataTable);
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::CopyParentProperty(CClassPart& ParentPart,
                                              LPCWSTR wszName)
{
    // Find the property in the parent
    // ===============================

    CPropertyInformation* pParentInfo = ParentPart.FindPropertyInfo(wszName);
    if(pParentInfo == NULL) return WBEM_E_NOT_FOUND;

    propindex_t nDataIndex = pParentInfo->nDataIndex;
    offset_t nDataOffset = pParentInfo->nDataOffset;
    Type_t nParentType = pParentInfo->nType;

    // Create a property information sturcture on our heap, large enough to
    // accomodate the part of the parent's qualifier set that propagates to
    // us.
    // ====================================================================

    length_t nNewInfoLen = pParentInfo->ComputeNecessarySpaceForPropagation();

    // Check for allocation failure
    heapptr_t ptrNewInfo;
    if ( !m_Heap.Allocate(nNewInfoLen, ptrNewInfo) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // NOTE: invalidated pParentInfo
    pParentInfo = ParentPart.FindPropertyInfo(wszName);

    CPropertyInformation* pNewInfo =
        (CPropertyInformation*)m_Heap.ResolveHeapPointer(ptrNewInfo);

    // Create propagated property information structure
    // ================================================

    CClassPartPtr ParentInfoPtr(&ParentPart, (LPMEMORY)pParentInfo);
    CHeapPtr NewInfoPtr(&m_Heap, ptrNewInfo);

    // Check for allocation failure
    if ( !CPropertyInformation::WritePropagatedVersion(
            &ParentInfoPtr, &NewInfoPtr,
            &ParentPart.m_Heap, &m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pParentInfo = NULL; // became invalid

    CPropertyLookup Lookup;

    // Check for allocation failures
    if ( !m_Heap.CreateNoCaseStringHeapPtr(wszName, Lookup.ptrName) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    Lookup.ptrInformation = ptrNewInfo;

    // Now, insert a new property into the property table
    // ==================================================
    int nIndex = 0;

    // Check for failure (out of memory)
    HRESULT hr = m_Properties.InsertProperty(Lookup, nIndex);

    if ( FAILED(hr) )
    {
        return hr;
    }

    // Set the value to the parent's one and mark as DEFAULT
    // =====================================================

    if(ParentPart.m_Defaults.IsNull(nDataIndex))
    {
        m_Defaults.SetNullness(nDataIndex, TRUE);
    }
    else
    {
        m_Defaults.SetNullness(nDataIndex, FALSE);

        CDataTablePtr ParentValuePtr(&ParentPart.m_Defaults, nDataOffset);
        CDataTablePtr NewValuePtr(&m_Defaults, nDataOffset);

        // Check for allocation errors.
        if ( !CUntypedValue::CopyTo(&ParentValuePtr, nParentType,
                &NewValuePtr, &ParentPart.m_Heap, &m_Heap) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    m_Defaults.SetDefaultness(nDataIndex, TRUE);

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::SetDefaultValue(LPCWSTR wszName, CVar* pVar)
{
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;
    return SetDefaultValue(pInfo, pVar);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetClassQualifier(LPCWSTR wszName, CVar* pVar,
                                    long* plFlavor /*=NULL*/, CIMTYPE* pct /*=NULL*/)
{
    int nKnownIndex; // garbage
    CQualifier* pQual = m_Qualifiers.GetQualifierLocally(wszName, nKnownIndex);
    if(pQual == NULL) return WBEM_E_NOT_FOUND;
    if(plFlavor) *plFlavor = pQual->fFlavor;

	if ( NULL != pct )
	{
		*pct = pQual->Value.GetType();
	}

    // Check for allocation failure
    if ( NULL != pVar )
    {
        if ( !pQual->Value.StoreToCVar(*pVar, &m_Heap) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_NO_ERROR;
}

HRESULT CClassPart::GetClassQualifier( LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedValue,
									CFastHeap** ppHeap, BOOL fValidateSet )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

    int nKnownIndex; // garbage
    CQualifier* pQual = m_Qualifiers.GetQualifierLocally(wszName, nKnownIndex);
    if(pQual == NULL) return WBEM_E_NOT_FOUND;

	// Make sure a set will actually work - Ostensibly we are calling this API because we need
	// direct access to a qualifier's underlying data before actually setting (possibly because
	// the qualifier is an array).
	if ( fValidateSet )
	{
		hr = m_Qualifiers.ValidateSet( wszName, pQual->fFlavor, pTypedValue, TRUE, TRUE );
	}

	if ( SUCCEEDED( hr ) )
	{
		if(plFlavor)
		{
			*plFlavor = pQual->fFlavor;
		}

		// Copy out the qualifier data
		// ==============

		// Local, so it's our heap
		*ppHeap = &m_Heap;

		if ( NULL != pTypedValue )
		{
			pQual->Value.CopyTo( pTypedValue );
		}

	}

    return hr;
}


//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::SetClassQualifier(LPCWSTR wszName, CVar* pVar,
                                    long lFlavor)
{
    if(pVar->IsDataNull())
        return WBEM_E_INVALID_PARAMETER;

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Grab errors directly from this call
    HRESULT hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVar, &m_Heap);
    if ( SUCCEEDED( hr ) )
    {
        hr = m_Qualifiers.SetQualifierValue(wszName, (BYTE)lFlavor,
            &Value, TRUE);
    }

    return hr;
}

 // Helper that deals directly with a typed value
HRESULT CClassPart::SetClassQualifier(LPCWSTR wszName,long lFlavor, CTypedValue* pTypedValue )
{
	 return m_Qualifiers.SetQualifierValue( wszName, (BYTE)lFlavor, pTypedValue, TRUE);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetQualifier(LPCWSTR wszName, CVar* pVar,
                                    long* plFlavor, CIMTYPE* pct /*=NULL*/)
{
    return m_Qualifiers.GetQualifier( wszName, pVar, plFlavor, pct );
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 LPMEMORY CClassPart::GetPropertyQualifierSetData(LPCWSTR wszName)
{
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL) return NULL;
    return pInfo->GetQualifierSetData();
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::InitPropertyQualifierSet(LPCWSTR wszName,
                                            CClassPropertyQualifierSet* pSet)
{
    CPropertyLookup* pLookup = m_Properties.FindProperty(wszName);
    if(pLookup == NULL) return WBEM_E_NOT_FOUND;

    CPropertyInformation* pInfo = (CPropertyInformation*)
        m_Heap.ResolveHeapPointer(pLookup->ptrInformation);

    pSet->SetData(pInfo->GetQualifierSetData(), this, pLookup->ptrName, NULL);
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                           long* plFlags)
{
    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL)
    {
        return CSystemProperties::GetPropertyType(wszName, pctType, plFlags);
    }

    HRESULT	hr = GetPropertyType( pInfo, pctType, plFlags );

	// Flavor is always System if this is a system property
	/*
	if ( plFlags && CSystemProperties::IsExtProperty( wszName ) )
	{
		*plFlags = WBEM_FLAVOR_ORIGIN_SYSTEM;
	}
	*/

	return hr;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                           long* plFlags)
{
    if(pctType)
    {
        *pctType = CType::GetActualType(pInfo->nType);
    }
    if(plFlags)
    {
        *plFlags = (CType::IsParents(pInfo->nType))?
                        WBEM_FLAVOR_ORIGIN_PROPAGATED:
                        WBEM_FLAVOR_ORIGIN_LOCAL;
    }
    return WBEM_NO_ERROR;
}

HRESULT CClassPart::GetPropQualifier(CPropertyInformation* pInfo,
                                    LPCWSTR wszQualifier,
                                    CVar* pVar, long* plFlavor, CIMTYPE* pct)
{
    // Access that property's qualifier set
    // ====================================

    CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
        pInfo->GetQualifierSetData(), &m_Heap, wszQualifier);

    if(pQual == NULL) return WBEM_E_NOT_FOUND;

    // Convert to CVar
    // ===============

    if(plFlavor) *plFlavor = pQual->fFlavor;

	// Store the type if requested
	if ( NULL != pct )
	{
		*pct = pQual->Value.GetType();
	}

    // Check for possible allocation failure
	if ( NULL != pVar )
	{
		if ( !pQual->Value.StoreToCVar(*pVar, &m_Heap) )
		{
			return WBEM_E_OUT_OF_MEMORY;
	    }
	}

    return WBEM_NO_ERROR;
}

HRESULT CClassPart::GetPropQualifier(LPCWSTR wszProp,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet)
{
    // Access that property's qualifier set
    // ====================================

	HRESULT	hr = WBEM_S_NO_ERROR;

    CClassPropertyQualifierSet PQSet;
    if(InitPropertyQualifierSet(wszProp, &PQSet) != WBEM_NO_ERROR)
    {
        return WBEM_E_NOT_FOUND;
    }

    int nKnownIndex; // garbage
    CQualifier* pQual = PQSet.GetQualifierLocally(wszQualifier, nKnownIndex);

    if(pQual == NULL) return WBEM_E_NOT_FOUND;

	// Make sure a set will actually work - Ostensibly we are calling this API because we need
	// direct access to a qualifier's underlying data before actually setting (possibly because
	// the qualifier is an array).
	if ( fValidateSet )
	{
		hr = PQSet.ValidateSet( wszQualifier, pQual->fFlavor, pTypedVal, TRUE, TRUE );
	}

    // Store the flavor
    // ===============

    if(plFlavor) *plFlavor = pQual->fFlavor;

	// This class's heap since we're getting locally
	*ppHeap = &m_Heap;

    // Check for possible allocation failure
	if ( NULL != pTypedVal )
	{
		pQual->Value.CopyTo( pTypedVal );
	}

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetClassName(CVar* pVar)
{
    if(m_pHeader->ptrClassName != INVALID_HEAP_ADDRESS)
    {
        // Check for possible allocation failure
        if ( !m_Heap.ResolveString(m_pHeader->ptrClassName)->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetSuperclassName(CVar* pVar)
{
    CCompressedString* pcs = GetSuperclassName();
    if(pcs != NULL)
    {
        // Check for possible allocation failure
        if ( !pcs->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetDynasty(CVar* pVar)
{
    CCompressedString* pcs = GetDynasty();
    if(pcs != NULL)
    {
        // Check for possible allocation failure
        if ( !pcs->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if(m_pHeader->ptrClassName != INVALID_HEAP_ADDRESS)
    {
        // Check for possible allocation failure
        if ( !m_Heap.ResolveString(m_pHeader->ptrClassName)->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetPropertyCount(CVar* pVar)
{
	int	nNumProperties = m_Properties.GetNumProperties();

	// Enumerate the properties and for each one we find, if the property starts
	// with a "__", then it is a system property and does not count against the
	// actual property count.
	for( int nCtr = 0, nTotal = nNumProperties; nCtr < nTotal; nCtr++ )
	{
        CPropertyLookup* pLookup;
        CPropertyInformation* pInfo;

        pLookup = GetPropertyLookup(nCtr);

		if ( m_Heap.ResolveString(pLookup->ptrName)->StartsWithNoCase( L"__" ) )
		{
			nNumProperties--;
		}
	}

    pVar->SetLong(nNumProperties);
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::GetDerivation(CVar* pVar)
{
    try
    {
        CVarVector* pvv = new CVarVector(VT_BSTR);

        if ( NULL != pvv )
        {
            CCompressedString* pcsCurrent = m_Derivation.GetFirst();

            while(pcsCurrent != NULL)
            {
                CVar* pv = new CVar;

                // Check for allocation failures

                if ( NULL == pv )
                {
                    delete pvv;
                    return WBEM_E_OUT_OF_MEMORY;
                }

                if ( !pcsCurrent->StoreToCVar(*pv) )
                {
                    delete pvv;
                    delete pv;
                    return WBEM_E_OUT_OF_MEMORY;
                }

                if ( pvv->Add(pv) != CVarVector::no_error )
                {
                    delete pvv;
                    delete pv;
                    return WBEM_E_OUT_OF_MEMORY;
                }

                pcsCurrent = m_Derivation.GetNext(pcsCurrent);
            }

            pVar->SetVarVector(pvv, TRUE);
            return WBEM_S_NO_ERROR;

        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 HRESULT CClassPart::SetClassName(CVar* pVar)
{
    if( pVar->GetType() != VT_BSTR &&
		pVar->GetType() != VT_LPWSTR )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    // Check that this is not a reserved word
    if ( CReservedWordTable::IsReservedWord( pVar->GetLPWSTR() ) )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // returns a circular reference if 'this' class and
    // the super class name are the same.

    if ( NULL != pVar->GetLPWSTR() )
    {
        CVar    var;
        GetSuperclassName( &var );

        if ( var == *pVar )
        {
            return WBEM_E_CIRCULAR_REFERENCE;
        }
    }

    if(m_pHeader->ptrClassName != INVALID_HEAP_ADDRESS)
    {
        m_Heap.FreeString(m_pHeader->ptrClassName);
    }

    // Check for allocation errors
    heapptr_t   ptrClassName;
    if ( !m_Heap.AllocateString(pVar->GetLPWSTR(), ptrClassName) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_pHeader->ptrClassName = ptrClassName;

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 BOOL CClassPart::IsKeyed()
{
    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        if(m_Properties.GetAt(i)->GetInformation(&m_Heap)->IsKey())
            return TRUE;
    }
    // perhaps it's singleton
    if(m_Qualifiers.GetQualifier(L"singleton") != NULL)
    {
        return TRUE;
    }

    return FALSE;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 
BOOL CClassPart::CheckLocalBoolQualifier( LPCWSTR pwszName )
{
    CQualifier* pQual = m_Qualifiers.GetQualifierLocally( pwszName );
    return (pQual &&
            pQual->Value.GetType().GetActualType() == VT_BOOL &&
            pQual->Value.GetBool()
            );
}

BOOL CClassPart::CheckBoolQualifier( LPCWSTR pwszName )
{
    CQualifier* pQual = m_Qualifiers.GetQualifier( pwszName );

    return (pQual &&
            pQual->Value.GetType().GetActualType() == VT_BOOL &&
            pQual->Value.GetBool()
            );
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 BOOL CClassPart::GetKeyProps(CWStringArray& awsNames)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    BOOL bFound = FALSE;
    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_Properties.GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
        if(pInfo->IsKey())
        {
            bFound = TRUE;

            if ( awsNames.Add(m_Heap.ResolveString(pLookup->ptrName)->
                CreateWStringCopy()) != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
        }       
    }

    return bFound;

}

 //******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetKeyOrigin(WString& wsClass)
{
    // Check for out of memory
    try
    {
        BOOL bFound = FALSE;

        // Look for keys.  When we find one, get it's class of origin and
        // stuff it in the wsClass parameter.

        for(int i = 0; i < m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = m_Properties.GetAt(i);
            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
            if(pInfo->IsKey())
            {
                CCompressedString* pcs = m_Derivation.GetAtFromLast(pInfo->nOrigin);
                if(pcs == NULL)
                    pcs = GetClassName();
                if(pcs == NULL)
                    return WBEM_E_INVALID_OBJECT;

                // Check for out of memory
                wsClass = pcs->CreateWStringCopy();

                bFound = TRUE;
            }
        }

        return ( bFound ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 BOOL CClassPart::GetIndexedProps(CWStringArray& awsNames)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    BOOL bFound = FALSE;
    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_Properties.GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
        if(pInfo->IsKey())
            continue;

        CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
            pInfo->GetQualifierSetData(), &m_Heap, L"indexed");

        if(pQual != NULL)
        {
            bFound = TRUE;

            // Check for OOM
            if ( awsNames.Add(m_Heap.ResolveString(pLookup->ptrName)->
                CreateWStringCopy()) != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
    return bFound;

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CClassPart::IsPropertyKeyed( LPCWSTR pwcsKeyProp )
{
    BOOL    fReturn = FALSE;

    // Only do this if we have a property to work with
    if ( NULL != pwcsKeyProp )
    {
        // Find the key in the local property table.  If we find it,
        // then see if it's keyed.

        CPropertyLookup* pLookup = m_Properties.FindProperty(pwcsKeyProp);

        if ( NULL != pLookup )
        {

            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);

            fReturn = ( NULL != pInfo && pInfo->IsKey() );

        }   // If we got a local lookup

    }   // IF NULL != pwcsKeyProp

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CClassPart::IsPropertyIndexed( LPCWSTR pwcsIndexProp )
{
    BOOL    fReturn = FALSE;

    // Only do this if we have a property to work with
    if ( NULL != pwcsIndexProp )
    {
        // Find the key in the local property table.  If we find it,
        // then see if it's indexed.

        CPropertyLookup* pLookup = m_Properties.FindProperty(pwcsIndexProp);

        if ( NULL != pLookup )
        {

            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);

            if ( NULL != pInfo )
            {
                // Look for the "indexed" qualifier
                CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
                    pInfo->GetQualifierSetData(), &m_Heap, L"indexed");

                fReturn = ( pQual != NULL );
            }

        }   // If we got a local lookup

    }   // IF NULL != pwcsKeyProp

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CClassPart::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
    try
    {
        CPropertyInformation* pInfo = FindPropertyInfo(wszProperty);
        if(pInfo == NULL)
        {
            if(CSystemProperties::FindName(wszProperty) >= 0)
            {
                *pstrClassName = COleAuto::_SysAllocString(L"___SYSTEM");
                return WBEM_S_NO_ERROR;
            }
            else
            {
                return WBEM_E_NOT_FOUND;
            }
        }
        else
        {
            CCompressedString* pcs = m_Derivation.GetAtFromLast(pInfo->nOrigin);
            if(pcs == NULL)
                pcs = GetClassName();
            if(pcs == NULL)
                return WBEM_E_INVALID_OBJECT;

            *pstrClassName = pcs->CreateBSTRCopy();

            // check for allocation failures
            if ( NULL == *pstrClassName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            return WBEM_S_NO_ERROR;
        }
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CClassPart::InheritsFrom(LPCWSTR wszClassName)
{
	CCompressedString*	pClsName = GetClassName();

	if ( NULL != pClsName )
	{
		if( pClsName->CompareNoCase(wszClassName) == 0 )
			return TRUE;
	}

    return (m_Derivation.Find(wszClassName) >= 0);
}

HRESULT CClassPart::GetPropertyHandle(LPCWSTR wszName, CIMTYPE* pct, long* plHandle)
{
    // Check required params
    if ( NULL == wszName || NULL == plHandle )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	// If the value is an extended system property, this is not
	// an allowed operation (only works through GetPropertyHandleEx).
	/*
	if ( CSystemProperties::IsExtProperty( wszName ) )
	{
		return WBEM_E_NOT_FOUND;	// To
	}
	*/

    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL)
        return WBEM_E_NOT_FOUND;

    // We don't support arrays or embedded objects
    if( CType::IsArray(pInfo->nType) ||
        CType::GetBasic(pInfo->nType) == CIM_OBJECT )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    // Retrieve the handle from the property info object
    *plHandle = pInfo->GetHandle();

    if(pct)
    {
        *pct = CType::GetActualType(pInfo->nType);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::GetPropertyHandleEx(LPCWSTR wszName, CIMTYPE* pct, long* plHandle)
{
    // This helper function does not filter ot any properties.

	// If the value starts with an underscore see if it's a System Property
	// DisplayName, and if so, switch to a property name - otherwise, this
	// will just return the string we passed in
	
	//wszName = CSystemProperties::GetExtPropName( wszName );

    CPropertyInformation* pInfo = FindPropertyInfo(wszName);
    if(pInfo == NULL)
	{
		if ( wbem_wcsicmp( wszName, L"__CLASS" ) == 0 )
		{
			*plHandle = FASTOBJ_CLASSNAME_PROP_HANDLE;
		}
		else if ( wbem_wcsicmp( wszName, L"__SUBCLASS" ) == 0 )
		{
			*plHandle = FASTOBJ_SUPERCLASSNAME_PROP_HANDLE;
		}
		else
		{
			return WBEM_E_NOT_FOUND;
		}

		if ( NULL != pct )
		{
			*pct = CIM_STRING;
		}

		return WBEM_S_NO_ERROR;
	}

    // Retrieve the handle from the property info object

    // This function will NOT perform any special filtering of handles.  It
    // is assumed that if somebody comes in from this route, they will know to
    // special case handles for embedded objects and arrays, since the normal
    // IWbemObjectAccess functions will not handle those types.

    *plHandle = pInfo->GetHandle();

	// Store the type if it was requested
    if(pct)
    {
        *pct = CType::GetActualType(pInfo->nType);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::GetPropertyInfoByHandle(long lHandle,
                                        BSTR* pstrName, CIMTYPE* pct)
{
    CPropertyLookup* pLookup =
        m_Properties.FindPropertyByOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle));

    if(pLookup == NULL)
        return WBEM_E_NOT_FOUND;

    CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);

    if(pct)
        *pct = CType::GetActualType(pInfo->nType);
    if(pstrName)
    {
        *pstrName = m_Heap.ResolveString(pLookup->ptrName)->CreateBSTRCopy();

        // Check for allocation failures
        if ( NULL == *pstrName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::IsValidPropertyHandle ( long lHandle )
{
    BOOL    fFound = FALSE;

    for ( int nIndex = 0; !fFound && nIndex < m_Properties.GetNumProperties(); nIndex++ )
    {
        CPropertyLookup* pLookup = m_Properties.GetAt( nIndex );

        if ( NULL != pLookup )
        {
            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);

            if ( NULL != pInfo )
            {
                fFound = ( lHandle == pInfo->GetHandle() );
            }   // IF pInfo

        }   // IF pLookup

    }   // FOR enum properties

    return ( fFound ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );
}

HRESULT CClassPart::GetDefaultByHandle(long lHandle, long lNumBytes,
                                        long* plRead, BYTE* pData )
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
    {
        // Handle strings.

        CCompressedString* pcs = m_Heap.ResolveString(
            *(PHEAPPTRT)(m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));

        long lNumChars = pcs->GetStringLength();
        *plRead = (lNumChars + 1) * 2;
        if(*plRead > lNumBytes)
        {
            return E_OUTOFMEMORY;
        }

        if(pcs->IsUnicode())
        {
            memcpy(pData, pcs->GetRawData(), lNumChars * 2);
        }
        else
        {
            WCHAR* pwcDest = (WCHAR*)pData;
            char* pcSource = (char*)pcs->GetRawData();
            long lLeft = lNumChars;
            while(lLeft--)
            {
                *(pwcDest++) = (WCHAR)*(pcSource++);
            }
        }

        ((LPWSTR)pData)[lNumChars] = 0;

        return WBEM_S_NO_ERROR;
    }
    else
    {
        // Just copy
        // =========

        *plRead = WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle);
        memcpy(pData, (void*) m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)),
                *plRead);
        return WBEM_S_NO_ERROR;
    }
}


HRESULT CClassPart::GetDefaultPtrByHandle(long lHandle, void** ppData )
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
    {
        *ppData = (void*) m_Heap.ResolveHeapPointer(
            *(PHEAPPTRT)(m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
    }
    else
    {
		// Set the value properly
        *ppData = m_Defaults.GetOffset(WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle));
    }

    return WBEM_S_NO_ERROR;

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::ExtendHeapSize(LPMEMORY pStart, length_t nOldLength,
    length_t nExtra)
{
    if(EndOf(*this) - EndOf(m_Heap) > (int)nExtra)
        return TRUE;

    int nNeedTotalLength = GetTotalRealLength() + nExtra;

    // Check for allocation failure
    return ReallocAndCompact(nNeedTotalLength);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::ExtendDataTableSpace(LPMEMORY pOld, length_t nOldLength,
    length_t nNewLength)
{
    m_pHeader->nDataLength = nNewLength;

    if(m_Heap.GetStart() - pOld > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength-nOldLength;
    BOOL    fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);

    // Check for allocation failure
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
void CClassPart::ReduceDataTableSpace(LPMEMORY pOld, length_t nOldLength,
        length_t nDecrement)
{
    m_pHeader->nDataLength -= nDecrement;
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::ExtendPropertyTableSpace(LPMEMORY pOld, length_t nOldLength,
    length_t nNewLength)
{
    if(m_Defaults.GetStart() - pOld > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength-nOldLength;
    BOOL    fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);

    // Check for allocation failure
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
        MoveBlock(m_Defaults, m_Defaults.GetStart() + nExtra);
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
    length_t nNewLength)
{
    if(m_Properties.GetStart() - pSet->GetStart() > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength - pSet->GetLength();

    BOOL    fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);

    // Check for allocation failure
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
        MoveBlock(m_Defaults, m_Defaults.GetStart() + nExtra);
        MoveBlock(m_Properties, m_Properties.GetStart() + nExtra);
    }

    return fReturn;
}

//*****************************************************************************
//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

length_t CClassPart::EstimateMergeSpace(CClassPart& ParentPart,
                                       CClassPart& ChildPart)
{
    // TBD better
    length_t nLength = ParentPart.GetLength() + ChildPart.GetLength();
    return nLength;
}
//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

LPMEMORY CClassPart::Merge(CClassPart& ParentPart, CClassPart& ChildPart,
        LPMEMORY pDest, int nAllocatedLength)
{
    // Allocate a header
    // =================

    CClassPartHeader* pHeader = (CClassPartHeader*)pDest;
    LPMEMORY pCurrentEnd = pDest + sizeof(CClassPartHeader);

    // Place our heap at the end of the allocated area. Make it as large as
    // the sum of the other two
    // ====================================================================

    int nHeapSize = ParentPart.m_Heap.GetUsedLength() +
                    ChildPart.m_Heap.GetUsedLength();

    LPMEMORY pHeapStart = pDest + nAllocatedLength - nHeapSize -
                                                    CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name and superclass name
    // ===================================

    // Check for memory allocation failures
    if ( !CCompressedString::CopyToNewHeap(
            ChildPart.m_pHeader->ptrClassName,
            &ChildPart.m_Heap, &Heap,
            pHeader->ptrClassName) )
    {
        return NULL;
    }

    // Create merged derivation list
    // =============================

    pCurrentEnd = CDerivationList::Merge(
        ParentPart.m_Derivation, ChildPart.m_Derivation, pCurrentEnd);

    // Check for memory allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create merged class qualifier set
    // =================================

    pCurrentEnd = CClassQualifierSet::Merge(
        ParentPart.m_Qualifiers.GetStart(), &ParentPart.m_Heap,
        ChildPart.m_Qualifiers.GetStart(), &ChildPart.m_Heap,
        pCurrentEnd, &Heap);

    // Check for memory allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create merged property lookup table
    // ===================================

    LPMEMORY pLookupTable = pCurrentEnd;
    pCurrentEnd = CPropertyLookupTable::Merge(
        &ParentPart.m_Properties, &ParentPart.m_Heap,
        &ChildPart.m_Properties, &ChildPart.m_Heap,
        pCurrentEnd, &Heap);

    // Check for memory allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create merged data table
    // ========================

    CPropertyLookupTable LookupTable;
    LookupTable.SetData(pLookupTable, NULL);

    pCurrentEnd = CDataTable::Merge(
        &ParentPart.m_Defaults, &ParentPart.m_Heap,
        &ChildPart.m_Defaults, &ChildPart.m_Heap,
        &LookupTable,
        pCurrentEnd, &Heap);

    // Check for memory allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }
    
    // Now, relocate the heap to its actual location
    // =============================================

    CopyBlock(Heap, pCurrentEnd);

    // Finish up tbe header
    // ====================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok

    pHeader->nLength = (length_t) ( EndOf(Heap) - pDest );

    pHeader->nDataLength = ChildPart.m_pHeader->nDataLength;

    return EndOf(Heap);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

HRESULT CClassPart::Update(CClassPart& UpdatePart, CClassPart& ChildPart, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // First set the class name of the Update part

    CVar    vTemp;

    hr = ChildPart.GetClassName( &vTemp );

    if ( SUCCEEDED( hr ) )
    {
        // Check that we're not about to create a circular reference
        hr = UpdatePart.TestCircularReference( (LPCWSTR) vTemp );

        if ( SUCCEEDED( hr ) )
        {
            hr = UpdatePart.SetClassName( &vTemp );

            // Next update the class qualifiers and the properties
            if ( SUCCEEDED( hr ) )
            {

                hr = UpdatePart.m_Qualifiers.Update( ChildPart.m_Qualifiers, lFlags );

                if ( SUCCEEDED( hr ) )
                {
                    hr = CClassPart::UpdateProperties( UpdatePart, ChildPart, lFlags );

                }   // IF succeeded setting class qualifiers

            }   // IF succeeded setting class name

        }   // IF passed TestCircularReference

    }   // IF retrieved class name

    return hr;
}

HRESULT CClassPart::UpdateProperties(CClassPart& UpdatePart, CClassPart& ChildPart, long lFlags )
{
    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;
        WString wstrPropName;

        // Now try to upgrade the property table by walking the child class part's
        // property table which should only have local properties.  For each property
        // found, get the name and try to get it's type from the parent class.  If
        // we can't because the property can't be found, add the property and value
        // to the new class, otherwise check for type mismatch errors and resolve
        // accordingly.

        for(int i = 0; SUCCEEDED( hr ) && i < ChildPart.m_Properties.GetNumProperties(); i++)
        {
            CIMTYPE ctUpdateProperty, ctChildPropType;

            CPropertyLookup* pLookup = ChildPart.m_Properties.GetAt(i);
            CPropertyInformation* pInfo = pLookup->GetInformation(&ChildPart.m_Heap);

            wstrPropName = ChildPart.m_Heap.ResolveString(pLookup->ptrName)->CreateWStringCopy();

            // This is the type of the child class property
            ctChildPropType = CType::GetActualType(pInfo->nType);

            HRESULT hrProp = UpdatePart.GetPropertyType( wstrPropName, &ctUpdateProperty, NULL );

            // If this succeeded, and types are different, we have a problem.  Otherwise
            // if types match, we can safely store default values, or if we couldn't
            // get the property, then it must be added.

            if ( SUCCEEDED( hrProp ) && ctChildPropType != ctUpdateProperty )
            {
                hr = WBEM_E_TYPE_MISMATCH;
            }
            else
            {
                hr = WBEM_S_NO_ERROR;

                CVar        vVal;

                // Get the property default value, then add the property
                // to 'this' class part.  If the property already existed,
                // this won't cause any problems.

                hr = ChildPart.GetDefaultValue( wstrPropName, &vVal );

                if ( SUCCEEDED( hr ) )
                {
                    // Makes sure the property exists, adding if necessary
                    hr = UpdatePart.EnsureProperty( wstrPropName, (VARTYPE) vVal.GetOleType(),
                                                    ctChildPropType, FALSE );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = UpdatePart.SetDefaultValue( wstrPropName, &vVal );
                    }

                }   // IF GotDefaultValue

            }   // IF GotPropertyType

            // At this point if we have a success, we should have properties in both
            // classes, so now check out the qualifiers for each.

            if ( SUCCEEDED( hr ) )
            {
                CClassPropertyQualifierSet qsUpdateProp;
                CBasicQualifierSet qsChildProp;

                hr = UpdatePart.InitPropertyQualifierSet( wstrPropName, &qsUpdateProp );

                if ( SUCCEEDED( hr ) )
                {
                    // We already have everything we need
                    qsChildProp.SetData( pInfo->GetQualifierSetData(), &ChildPart.m_Heap );

                    // Update the new class property qualifier set

                    // Make sure CIMTYPE is copied here as well, since for "ref"
                    // type properties, it's value will override what was specified
                    // in the base class.

                    hr = qsUpdateProp.Update( qsChildProp, lFlags, NULL );
                }   // IF Got PQS for UpdatePart

            }   // IF ok

        }   // FOR enum properties

        return hr;

    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
length_t CClassPart::EstimateUnmergeSpace()
{
    return GetLength();
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
LPMEMORY CClassPart::Unmerge(LPMEMORY pDest, int nAllocatedLength)
{
    // Allocate the header
    // ===================

    CClassPartHeader* pHeader = (CClassPartHeader*)pDest;

    LPMEMORY pCurrentEnd = pDest + sizeof(CClassPartHeader);

    // Note that no flags are written out here, so we don't need to do any
    // fancy behind the back switching with the localization flags.

    // Place our heap at the end of the allocated area. Make it as large as
    // the sum of the other two
    // ====================================================================

    int nHeapSize = m_Heap.GetUsedLength();
    LPMEMORY pHeapStart = pDest + nAllocatedLength - nHeapSize -
                                                    CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name and superclass name
    // ===================================

    // Check for allocation failures
    if ( !CCompressedString::CopyToNewHeap(
            m_pHeader->ptrClassName,
            &m_Heap, &Heap,
            pHeader->ptrClassName) )
    {
        return NULL;
    }

    // Create unmerged deirvation list (just the superclass)
    // =====================================================

    // This does not perform any allocations
    pCurrentEnd = m_Derivation.Unmerge(pCurrentEnd);

    // Create unmerged class qualifier set
    // ===================================

    pCurrentEnd = CClassQualifierSet::Unmerge(
        m_Qualifiers.GetStart(), &m_Heap,
        pCurrentEnd, &Heap);

    // Check for allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create unmerged property lookup table (overriden and new)
    // =========================================================

    pCurrentEnd = m_Properties.Unmerge(&m_Defaults, &m_Heap,
        pCurrentEnd, &Heap);

    // Check for allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Unmerge defaults table: copy only overriden values
    // ==================================================

    pCurrentEnd = m_Defaults.Unmerge(&m_Properties, &m_Heap,
        pCurrentEnd, &Heap);

    // Check for allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Now, relocate the heap to its actual location
    // =============================================

    Heap.Trim();
    CopyBlock(Heap, pCurrentEnd);

    // Finish up tbe header
    // ====================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting length
    // > 0xFFFFFFFF so cast is ok

    pHeader->nLength = (length_t) ( EndOf(Heap) - pDest );

    pHeader->nDataLength = m_pHeader->nDataLength;

    return EndOf(Heap);
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
length_t CClassPart::EstimateDerivedPartSpace()
{
    return GetLength() + CDerivationList::EstimateExtraSpace(GetClassName());
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
LPMEMORY CClassPart::CreateDerivedPart(LPMEMORY pDest,
                                       int nAllocatedLength)
{
    // Allocate the header
    // ===================

    CClassPartHeader* pHeader = (CClassPartHeader*)pDest;

    LPMEMORY pCurrentEnd = pDest + sizeof(CClassPartHeader);

    // Place our heap at the end of the allocated area. Make it as large as
    // the sum of the other two
    // ====================================================================

    int nHeapSize = m_Heap.GetUsedLength();
    LPMEMORY pHeapStart = pDest + nAllocatedLength - nHeapSize -
                                              CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name and superclass name
    // ===================================

    pHeader->ptrClassName = INVALID_HEAP_ADDRESS;

    // Create propagated derivation list
    // =================================

    // This call performs no allocations
    pCurrentEnd = m_Derivation.CreateWithExtra(pCurrentEnd, GetClassName());

    // Create propagated qualifier set
    // ===============================

    CStaticPtr OriginalStartPtr(m_Qualifiers.GetStart());
    CStaticPtr CurrentEndPtr(pCurrentEnd);
    pCurrentEnd = CBasicQualifierSet::WritePropagatedVersion(
        &OriginalStartPtr,
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS,
        &CurrentEndPtr, &m_Heap, &Heap);

    // Check for allocation failure.
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create combined property lookup table
    // =====================================

    pCurrentEnd = m_Properties.WritePropagatedVersion(
        &m_Heap, pCurrentEnd, &Heap);

    // Check for allocation failure.
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create propagated data table
    // ============================

    pCurrentEnd = m_Defaults.WritePropagatedVersion(
        &m_Properties, &m_Heap, pCurrentEnd, &Heap);

    // Check for allocation failure.
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Now, relocate the heap to its actual location
    // =============================================

    CopyBlock(Heap, pCurrentEnd);
    Heap.Trim();

    // Finish up tbe header
    // ====================

    pHeader->nLength = nAllocatedLength; // save overallocation for lated
    pHeader->nDataLength = m_pHeader->nDataLength;

    return pDest + nAllocatedLength;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

EReconciliation CClassPart::CanBeReconciledWith(CClassPart& NewPart)
{
    // Check that the class names match
    // ================================

    if(m_Heap.ResolveString(m_pHeader->ptrClassName)->CompareNoCase(
         *NewPart.m_Heap.ResolveString(NewPart.m_pHeader->ptrClassName)) != 0)
    {
        return e_DiffClassName;
    }

    // Check that the superclass names match
    // =====================================

    CCompressedString* pcsOldSuperclass = GetSuperclassName();
    CCompressedString* pcsNewSuperclass = NewPart.GetSuperclassName();
    if(pcsOldSuperclass == NULL || pcsNewSuperclass == NULL)
    {
        if(pcsOldSuperclass != pcsNewSuperclass)
            return e_DiffParentName;
    }
    else
    {
        if(pcsOldSuperclass->CompareNoCase(*pcsNewSuperclass) != 0)
        {
            return e_DiffParentName;
        }
    }

    // Check singleton-ness
    // ====================

    if((IsSingleton() == TRUE) != (NewPart.IsSingleton() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Check abstract-ness
    // ===================

    if((IsAbstract() == TRUE) != (NewPart.IsAbstract() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Check amendment-ness
    // ===================

    if((IsAmendment() == TRUE) != (NewPart.IsAmendment() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    if((GetAbstractFlavor() == TRUE) != (NewPart.GetAbstractFlavor() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Check compress-ness
    // ===================

    if((IsCompressed() == TRUE) != (NewPart.IsCompressed() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Check dynamic-ness
    // ==================

    if((IsDynamic() == TRUE) != (NewPart.IsDynamic() == TRUE))
    {
        return e_DiffKeyAssignment;
    }

    // Make sure that the unimportant qualifiers can be reconciled with
    // each other

    CBasicQualifierSet* pqsBasicThis = &m_Qualifiers;
    CBasicQualifierSet* pqsBasicThat = &NewPart.m_Qualifiers;

    // Make sure we filter out the conflict qualifier
    if ( !pqsBasicThis->CanBeReconciledWith( *pqsBasicThat ) )
    {
        return e_DiffClassQualifier;
    }

    // Check that all the properties are the same
    // ==========================================

    if(m_Properties.GetNumProperties() !=
        NewPart.m_Properties.GetNumProperties())
    {
        return e_DiffNumProperties;
    }

    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_Properties.GetAt(i);
        CPropertyLookup* pNewLookup = NewPart.m_Properties.GetAt(i);

        // Compare names
        // =============

        if(m_Heap.ResolveString(pLookup->ptrName)->CompareNoCase(
            *NewPart.m_Heap.ResolveString(pNewLookup->ptrName)) != 0)
        {
            return e_DiffPropertyName;
        }

        // Get property information structures
        // ===================================

        CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
        CPropertyInformation* pNewInfo =
            pNewLookup->GetInformation(&NewPart.m_Heap);

        // Compare types
        // =============

        if(pInfo->nType != pNewInfo->nType)
        {
            return e_DiffPropertyType;
        }

        // Compare vtable information
        // ==========================

        if(pInfo->nDataIndex != pNewInfo->nDataIndex ||
            pInfo->nDataOffset != pNewInfo->nDataOffset)
        {
            return e_DiffPropertyLocation;
        }

        // Compare 'key'-ness and 'index'-ness
        // ===================================

        BOOL bIsKey = pInfo->IsKey();
        BOOL bNewIsKey = pNewInfo->IsKey();
        if((bIsKey && !bNewIsKey) || (!bIsKey && bNewIsKey))
        {
            return e_DiffKeyAssignment;
        }

        BOOL bIsIndexed = pInfo->IsIndexed(&m_Heap);
        BOOL bNewIsIndexed = pNewInfo->IsIndexed(&NewPart.m_Heap);
        if((bIsIndexed && !bNewIsIndexed) || (!bIsIndexed && bNewIsIndexed))
        {
            return e_DiffIndexAssignment;
        }

        // Compare CIMTYPE qualifiers
        // ==========================

        CVar vCimtype;
        GetPropQualifier(pInfo, L"cimtype", &vCimtype);
        CVar vNewCimtype;
        NewPart.GetPropQualifier(pNewInfo, L"cimtype", &vNewCimtype);

        if(wbem_wcsicmp(vCimtype.GetLPWSTR(), vNewCimtype.GetLPWSTR()))
        {
            return e_DiffPropertyType;
        }

        // Compare property values
        // ==========================

        CVar    vThisProp,
                vThatProp;

        // Check for allocation failures
        HRESULT hr = GetDefaultValue( pInfo, &vThisProp );

        if ( FAILED(hr) )
        {
            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                return e_OutOfMemory;
            }

            return e_WbemFailed;
        }

        // Check for allocation failures
        hr = NewPart.GetDefaultValue( pNewInfo, &vThatProp );

        if ( FAILED(hr) )
        {
            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                return e_OutOfMemory;
            }

            return e_WbemFailed;
        }

        if ( !( vThisProp == vThatProp ) )
        {
            return e_DiffPropertyValue;
        }

        // Make sure that unimportant qualifiers can be reconciled with
        // each other

        // Compare qualifier values
        // ==========================

        CBasicQualifierSet  qsThisProp,
                            qsThatProp;

        qsThisProp.SetData( pInfo->GetQualifierSetData(), &m_Heap );
        qsThatProp.SetData( pNewInfo->GetQualifierSetData(), &NewPart.m_Heap );

        if ( !qsThisProp.CanBeReconciledWith( qsThatProp ) )
        {
            return e_DiffPropertyQualifier;
        }

    }

    return e_Reconcilable;
}

BYTE CClassPart::GetAbstractFlavor()
{
    CQualifier* pQual = m_Qualifiers.GetQualifier(L"abstract");
    if(pQual == NULL)
        return 0;
    else
        return pQual->GetFlavor();
}
//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

EReconciliation CClassPart::ReconcileWith( CClassPart& NewPart )
{
    // Check if we can
    // ===============

    EReconciliation eRes = CanBeReconciledWith(NewPart);
    if(eRes != e_Reconcilable)
        return eRes;

    // Compact NewPart and replace ourselves with it
    // =============================================

    NewPart.Compact();

    if(NewPart.GetLength() > GetLength())
    {
        if (!m_pContainer->ExtendClassPartSpace(this, NewPart.GetLength()))
        	return e_OutOfMemory;
    }

    memcpy(GetStart(), NewPart.GetStart(), NewPart.GetLength());
    SetData(GetStart(), m_pContainer, m_pParent);

    return eRes;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

EReconciliation CClassPart::CompareExactMatch(CClassPart& thatPart, BOOL fLocalized /* = FALSE */ )
{
    // Check for out of memory
    try
    {
        // Check that the class names match
        // ================================

        if(m_Heap.ResolveString(m_pHeader->ptrClassName)->CompareNoCase(
             *thatPart.m_Heap.ResolveString(thatPart.m_pHeader->ptrClassName)) != 0)
        {
            return e_DiffClassName;
        }

        // Check that the superclass names match
        // =====================================

        CCompressedString* pcsOldSuperclass = GetSuperclassName();
        CCompressedString* pcsNewSuperclass = thatPart.GetSuperclassName();
        if(pcsOldSuperclass == NULL || pcsNewSuperclass == NULL)
        {
            if(pcsOldSuperclass != pcsNewSuperclass)
                return e_DiffParentName;
        }
        else
        {
            if(pcsOldSuperclass->CompareNoCase(*pcsNewSuperclass) != 0)
            {
                return e_DiffParentName;
            }
        }


        // Set up the array of filters to use while dealing with qualifiers
        // We must NOT filter out the CIMTYPE qualifier for properties, since
        // that qualifier is where we will find out if a reference changed
        // for a "ref" types property.

        LPCWSTR apFilters[1];
        apFilters[0] = UPDATE_QUALIFIER_CONFLICT;

        // Check that qualifiers are the same
        CBasicQualifierSet* pqsBasicThis = &m_Qualifiers;
        CBasicQualifierSet* pqsBasicThat = &thatPart.m_Qualifiers;

        if ( fLocalized )
        {
            // The CompareLocalized function will create a special set of filters
            // based on localization rules
            if ( !pqsBasicThis->CompareLocalizedSet( *pqsBasicThat ) )
            {
                return e_DiffClassQualifier;
            }
        }
        else
        {
            // Make sure we filter out the conflict qualifier

            if ( !pqsBasicThis->Compare( *pqsBasicThat, WBEM_FLAG_LOCAL_ONLY, apFilters, 1 ) )
            {
                return e_DiffClassQualifier;
            }
        }

        // Check that all the properties are the same
        // ==========================================

        if(m_Properties.GetNumProperties() !=
            thatPart.m_Properties.GetNumProperties())
        {
            return e_DiffNumProperties;
        }

        // Construct this once
        WString wstrPropertyName;

        for(int i = 0; i < m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = m_Properties.GetAt(i);
            CPropertyLookup* pNewLookup = thatPart.m_Properties.GetAt(i);

            // Compare names
            // =============

            if(m_Heap.ResolveString(pLookup->ptrName)->CompareNoCase(
                *thatPart.m_Heap.ResolveString(pNewLookup->ptrName)) != 0)
            {
                return e_DiffPropertyName;
            }

            // Store the name for later
            wstrPropertyName = m_Heap.ResolveString(pLookup->ptrName)->CreateWStringCopy();

            // Get property information structures
            // ===================================

            CPropertyInformation* pInfo = pLookup->GetInformation(&m_Heap);
            CPropertyInformation* pNewInfo =
                pNewLookup->GetInformation(&thatPart.m_Heap);

            // Compare types
            // =============

            if(pInfo->nType != pNewInfo->nType)
            {
                return e_DiffPropertyType;
            }

            // Compare vtable information
            // ==========================

            if(pInfo->nDataIndex != pNewInfo->nDataIndex ||
                pInfo->nDataOffset != pNewInfo->nDataOffset)
            {
                return e_DiffPropertyLocation;
            }

            // Compare values
            // ==========================

            CVar    vThisProp,
                    vThatProp;

            // Check for allocation failures
            HRESULT hr = GetDefaultValue( wstrPropertyName, &vThisProp );

            if ( FAILED(hr) )
            {
                if ( WBEM_E_OUT_OF_MEMORY == hr )
                {
                    return e_OutOfMemory;
                }

                return e_WbemFailed;
            }

            // Check for allocation failures
            hr = thatPart.GetDefaultValue( wstrPropertyName, &vThatProp );

            if ( FAILED(hr) )
            {
                if ( WBEM_E_OUT_OF_MEMORY == hr )
                {
                    return e_OutOfMemory;
                }

                return e_WbemFailed;
            }

            if ( !( vThisProp == vThatProp ) )
            {
                return e_DiffPropertyValue;
            }

            // Compare qualifier values
            // ==========================

            CBasicQualifierSet  qsThisProp,
                                qsThatProp;

            qsThisProp.SetData( pInfo->GetQualifierSetData(), &m_Heap );
            qsThatProp.SetData( pNewInfo->GetQualifierSetData(), &thatPart.m_Heap );

            // Remember, do NOT filter out "CIMTYPE"

            if ( fLocalized )
            {
                // The CompareLocalized function will create a special set of filters
                // based on localization rules
                if ( !qsThisProp.CompareLocalizedSet( qsThatProp ) )
                {
                    return e_DiffClassQualifier;
                }
            }
            else
            {
                if ( !qsThisProp.Compare( qsThatProp, WBEM_FLAG_LOCAL_ONLY, apFilters, 1 ) )
                {
                    return e_DiffPropertyQualifier;
                }

            }

        }   // FOR EnumProperties

        return e_ExactMatch;
    }
    catch (CX_MemoryException)
    {
        return e_OutOfMemory;
    }
    catch (...)
    {
        return e_WbemFailed;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CClassPart::CompareDefs(CClassPart& OtherPart)
{
    // Check that the class names match
    // ================================

    // Check that the class names match
    // ================================
    CCompressedString* pcsOld = GetClassName();
    CCompressedString* pcsNew = OtherPart.GetClassName();
    if(pcsOld == NULL || pcsNew == NULL)
    {
        if(pcsOld != pcsNew)
	        return FALSE;
    }
    else
    {
        if(pcsOld->CompareNoCase(*pcsNew) != 0)
        {
	        return FALSE;
        }
    }

    // Check that the superclass names match
    // =====================================

    pcsOld = GetSuperclassName();
    pcsNew = OtherPart.GetSuperclassName();
    if(pcsOld == NULL || pcsNew == NULL)
    {
        if(pcsOld != pcsNew)
	        return FALSE;
    }
    else
    {
        if(pcsOld->CompareNoCase(*pcsNew) != 0)
        {
	        return FALSE;
        }
    }

    // Check that the number of properties is the same
    // ===============================================

    if(m_Properties.GetNumProperties() !=
        OtherPart.m_Properties.GetNumProperties())
    {
        return FALSE;
    }

    return TRUE;
}

//*****************************************************************************
//
//  See fastcls.h for documentation
//
//*****************************************************************************

BOOL CClassPart::IsIdenticalWith(CClassPart& OtherPart)
{
    Compact();
    OtherPart.Compact();

    if(GetLength() != OtherPart.GetLength())
    {
        DEBUGTRACE((LOG_WBEMCORE, "Class parts have different lengths: "
                        "%d != %d\n", GetLength(), OtherPart.GetLength()));
        return FALSE;
    }

    if(memcmp(GetStart(), OtherPart.GetStart(), GetLength()))
    {
        ERRORTRACE((LOG_WBEMCORE, "FATAL ERROR: Client application provided a "
            "mismatched class part!!!!\n"));

/* TOO HEAVY
        DEBUGTRACE((LOG_WBEMCORE, "Class parts are different:\n"));
        int i;
        char* sz = new char[GetLength() * 10 + 10];
        for(i = 0; i < GetLength(); i++)
        {
            sprintf(sz + i*2, "%02X", (long)(GetStart()[i]));
            if(GetStart()[i] != OtherPart.GetStart()[i])
                ERRORTRACE((LOG_WBEMCORE, "DIFF: %d\n", i));
        }
        sz[i*2-1] = 0;
        DEBUGTRACE((LOG_WBEMCORE, "First: %sEND\n", sz));
        for(i = 0; i < GetLength(); i++)
        {
            sprintf(sz + i*2, "%02X", (long)(OtherPart.GetStart()[i]));
        }
        sz[i*2-1] = 0;

        DEBUGTRACE((LOG_WBEMCORE, "Second: %sEND\n", sz));
        DEBUGTRACE((LOG_WBEMCORE, "\n"));

        delete [] sz;
*/
        return FALSE;
    }


    return TRUE;
}

//*****************************************************************************
//
//  See fastcls.h for documentation
//
//*****************************************************************************
BOOL CClassPart::MapLimitation(
    IN long lFlags,
    IN CWStringArray* pwsNames,
    OUT CLimitationMapping* pMap)
{
    if(!m_Properties.MapLimitation(lFlags, pwsNames, pMap)) return FALSE;

    // Optimization: if this class is keyed, then clear "include child keys"
    // bit since children can't have any
    // =====================================================================

    if(pMap->ShouldAddChildKeys() && IsKeyed())
    {
        pMap->SetAddChildKeys(FALSE);
    }

    // Check whether to include derivation
    // ===================================

    BOOL bIncludeDerivation;
    if(pwsNames->FindStr(L"__DERIVATION", CWStringArray::no_case) !=
                                                CWStringArray::not_found ||
       pwsNames->FindStr(L"__SUPERCLASS", CWStringArray::no_case) !=
                                                CWStringArray::not_found ||
       pwsNames->FindStr(L"__DYNASTY", CWStringArray::no_case) !=
                                                CWStringArray::not_found
      )
    {
        bIncludeDerivation = TRUE;
    }
    else
    {
        bIncludeDerivation = FALSE;
    }

    pMap->SetIncludeDerivation(bIncludeDerivation);

    return TRUE;
}
//*****************************************************************************
//
//  See fastcls.h for documentation
//
//*****************************************************************************

LPMEMORY CClassPart::CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pDest,
        BOOL& bRemovedKeys)
{
    // Clear any specific into in the map --- we may need to store our own
    // for the instance part's sake.
    // ===================================================================

    pMap->RemoveSpecific();

    // Allocate the header
    // ===================

    CClassPartHeader* pHeader = (CClassPartHeader*)pDest;

    LPMEMORY pCurrentEnd = pDest + sizeof(CClassPartHeader);

    // Place new heap at the end of the allocated area. Make it as large as
    // the current one.
    // ====================================================================

    int nHeapSize = m_Heap.GetUsedLength();
    LPMEMORY pHeapStart = pDest + nAllocatedSize - nHeapSize -
                                              CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name and superclass name
    // ===================================

    // Check for allocation problems
    if ( !CCompressedString::CopyToNewHeap(
            m_pHeader->ptrClassName,
            &m_Heap, &Heap,
            pHeader->ptrClassName) )
    {
        return NULL;
    }

    // Create limited derivation list
    // ==============================

    pCurrentEnd = m_Derivation.CreateLimitedRepresentation(pMap, pCurrentEnd);

    // Check for allocation failures
    if ( NULL == pCurrentEnd )
    {
        return NULL;
    }

    // Create limited qualifier set
    // ============================

    if(pMap->GetFlags() & WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS)
    {
        // No qualifiers need to be written
        // ================================

        pCurrentEnd = CBasicQualifierSet::CreateEmpty(pCurrentEnd);
    }
    else
    {
        // Copy them all
        // =============

        int nLength = m_Qualifiers.GetLength();
        memcpy(pCurrentEnd, m_Qualifiers.GetStart(), nLength);

        CStaticPtr CurrentEndPtr(pCurrentEnd);

        // Check for allocation failures
        if ( !CBasicQualifierSet::TranslateToNewHeap(&CurrentEndPtr, &m_Heap, &Heap) )
        {
            return NULL;
        }

        pCurrentEnd += nLength;
    }

    // Create limited property lookup table and data table
    // ===================================================

    // Check for allocation failures
    pCurrentEnd = m_Properties.CreateLimitedRepresentation(pMap, &Heap,
                                        pCurrentEnd, bRemovedKeys);
    if ( NULL == pCurrentEnd ) return NULL;

    // Create limited data table
    // =========================

    // Check for allocation failures
    LPMEMORY pNewEnd = m_Defaults.CreateLimitedRepresentation(pMap, TRUE,
                                            &m_Heap, &Heap, pCurrentEnd);
    if(pNewEnd == NULL) return NULL;

    // Set the data length in the part header
    // ======================================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok.

    pHeader->nDataLength = (length_t) ( pNewEnd - pCurrentEnd );

    pCurrentEnd = pNewEnd;

    // Now, relocate the heap to its actual location
    // =============================================

    CopyBlock(Heap, pCurrentEnd);
    Heap.Trim();

    // Finish up tbe header
    // ====================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok.

    pHeader->nLength = (length_t) ( EndOf(Heap) - pDest );

    return EndOf(Heap);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

HRESULT CClassPart::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                    long lFlavor, CVar *pVal)
{
    if(pVal->IsDataNull())
        return WBEM_E_INVALID_PARAMETER;

    // Access that property's qualifier set
    // ====================================

    CClassPropertyQualifierSet PQSet;
    if(InitPropertyQualifierSet(wszProp, &PQSet) != WBEM_NO_ERROR)
    {
        return WBEM_E_NOT_FOUND;
    }

    // Create the value
    // ================

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Grab errors directly from this call
    HRESULT hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVal, &m_Heap);

    if ( SUCCEEDED( hr ) )
    {
        // The last call may have moved us --- rebase
        // ==========================================

        PQSet.SelfRebase();
        hr = PQSet.SetQualifierValue(wszQualifier, (BYTE)lFlavor, &Value, TRUE);
    }

    return hr;
}

HRESULT CClassPart::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
									long lFlavor, CTypedValue* pTypedVal)
{
    // Access that property's qualifier set
    // ====================================

    CClassPropertyQualifierSet PQSet;
    if(InitPropertyQualifierSet(wszProp, &PQSet) != WBEM_NO_ERROR)
    {
        return WBEM_E_NOT_FOUND;
    }

	HRESULT hr = PQSet.SetQualifierValue(wszQualifier, (BYTE)lFlavor, pTypedVal, TRUE);

    return hr;
}

HRESULT CClassPart::SetInheritanceChain(long lNumAntecedents,
                        LPWSTR* awszAntecedents)
{
    // The underlying functions should handle any OOM exceptions, so we don't
    // need to add any OOM handling here.  Everything else is just playing
    // with memory that's already been alloced.

    classindex_t nOldClassOrigin = m_Derivation.GetNumStrings();

    // Compute the necessary space
    // ===========================

    length_t nDerLength = CDerivationList::GetHeaderLength();
    long i;
    for(i = 0; i < lNumAntecedents; i++)
    {
        nDerLength += CDerivationList::EstimateExtraSpace(awszAntecedents[i]);
    }

    // Move everything forward
    // =======================

    int nExtra = nDerLength - m_Derivation.GetLength();

    // Check for an allocation error
    if ( !ReallocAndCompact(GetTotalRealLength() + nExtra) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
    MoveBlock(m_Defaults, m_Defaults.GetStart() + nExtra);
    MoveBlock(m_Properties, m_Properties.GetStart() + nExtra);
    MoveBlock(m_Qualifiers, m_Qualifiers.GetStart() + nExtra);

    // Reset the derivation table
    // ==========================

    m_Derivation.Reset();

    // Add all the strings in reverse order
    // ====================================

    for(i = lNumAntecedents - 1; i >= 0; i--)
    {
        m_Derivation.AddString(awszAntecedents[i]);
    }

    // Go through all the properties and reset the origin
    // ==================================================

    int nNewClassOrigin = m_Derivation.GetNumStrings();
    for(i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyInformation* pInfo =
                m_Properties.GetAt(i)->GetInformation(&m_Heap);
        if(pInfo->nOrigin == nOldClassOrigin)
            pInfo->nOrigin = nNewClassOrigin;
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::SetPropertyOrigin(LPCWSTR wszPropertyName, long lOriginIndex)
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    // Find the property
    // =================

    CPropertyInformation* pInfo = FindPropertyInfo(wszPropertyName);
    if(pInfo == NULL)
        return WBEM_E_NOT_FOUND;

    pInfo->nOrigin = lOriginIndex;
    return WBEM_S_NO_ERROR;
}

HRESULT CClassPart::CanContainAbstract( BOOL fValue )
{
    // The following code should be uncommented when we determine it is safe to
    // let this code go in.

    // Can add "abstract" ONLY if we are a top level class or the parent is
    // also abstract
    if ( IsTopLevel() )
    {
        return WBEM_S_NO_ERROR;
    }

    long    lFlavor = 0;
    BOOL    bIsLocal = FALSE;
    CVar    var;

    // If we didn't get a qualifier or it wasn't local and it doesn't propagate to
    // derived classes, we're done.

    // In each case, since the located qualifier is not local or propagated to classes,
    // assume our parent class is non-abstract, hence our return is indicated by the
    // abstractness we are trying to set

    if ( FAILED( m_pParent->m_Qualifiers.GetQualifier( L"abstract", &var, &lFlavor ) ) )
    {
        return ( fValue ? WBEM_E_CANNOT_BE_ABSTRACT : WBEM_S_NO_ERROR );
    }

    if ( !CQualifierFlavor::IsLocal( (BYTE) lFlavor ) &&
        !CQualifierFlavor::DoesPropagateToDerivedClass( (BYTE) lFlavor ) )
    {
        return ( fValue ? WBEM_E_CANNOT_BE_ABSTRACT : WBEM_S_NO_ERROR );
    }

    // If the parent was abstract, then the child can also be abstract or shut this off.

    if ( var.GetBool() == VARIANT_TRUE )
    {
        return WBEM_S_NO_ERROR;
    }

    // If the parent is non-abstract, then the child can only be abstract if this
    // is to be non-abstract (basically a redundant qualifier at this point).
    return ( fValue ? WBEM_E_CANNOT_BE_ABSTRACT : WBEM_S_NO_ERROR );
}

HRESULT CClassPart::IsValidClassPart( void )
{

    LPMEMORY    pClassPartStart = GetStart();
    LPMEMORY    pClassPartEnd = GetStart() + GetLength();

    // Check that the header is in the BLOB
    if ( !( (LPMEMORY) m_pHeader >= pClassPartStart && (LPMEMORY) m_pHeader < pClassPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Class Part Header!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Class Part Header!" ));
        return WBEM_E_FAILED;
    }


    // Check the derivation
    LPMEMORY    pTestStart = m_Derivation.GetStart();
    LPMEMORY    pTestEnd = m_Derivation.GetStart() + m_Derivation.GetLength();

    if ( !( pTestStart == (pClassPartStart + sizeof(CClassPartHeader)) &&
            pTestEnd > pTestStart && pTestEnd < pClassPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Derivation List in Class Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Derivation List in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Check the qualifier set
    pTestStart = m_Qualifiers.GetStart();
    pTestEnd = m_Qualifiers.GetStart() + m_Qualifiers.GetLength();

    if ( !( pTestStart == EndOf(m_Derivation) &&
            pTestEnd > pTestStart && pTestEnd < pClassPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Qualifier Set in Class Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Qualifier Set in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Check the Property lookup table
    pTestStart = m_Properties.GetStart();
    pTestEnd = m_Properties.GetStart() + m_Properties.GetLength();

    // A delete qualifier on a class part, can cause a gap between it and the
    // lookup table, so as long as this is in the BLOB, we'll call it okay.

    if ( !( pTestStart >= EndOf(m_Qualifiers) &&
            pTestEnd > pTestStart && pTestEnd < pClassPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Property Lookup Table in Class Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Property Lookup Table in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Check the Defaults
    pTestStart = m_Defaults.GetStart();
    pTestEnd = m_Defaults.GetStart() + m_Defaults.GetLength();

    // We could have a zero property object, or during a delete property on a class part,
    // the property lookup table can shrink, causing a gap between it and the
    // data table, so as long as this is in the BLOB, we'll call it okay.

    if ( !( pTestStart >= EndOf(m_Properties) &&
            pTestEnd >= pTestStart && pTestEnd < pClassPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Default Property Table Set in Class Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Default Property Table Set in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Check the Heap
    LPMEMORY    pHeapStart = m_Heap.GetStart();
    LPMEMORY    pHeapEnd = m_Heap.GetStart() + m_Heap.GetLength();

    // the data table can shrink, causing a gap between it and the
    // heap when a property is deleted.  So as long as this is in
    // the BLOB, we'll call it okay.

    if ( !( pHeapStart >= EndOf(m_Defaults) &&
            pHeapEnd > pHeapStart && pHeapEnd <= pClassPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Heap in Class Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Heap in Class Part!" ));
        return WBEM_E_FAILED;
    }

    // Get the heap data start
    pHeapStart = m_Heap.GetHeapData();

    // Check that the classname pointer is in the BLOB (if it's not 0xFFFFFFFF)
    if ( m_pHeader->ptrClassName != INVALID_HEAP_ADDRESS )
    {
        LPMEMORY    pClassName = m_Heap.ResolveHeapPointer( m_pHeader->ptrClassName );
        if ( !( pClassName >= pHeapStart && pClassName < pHeapEnd ) )
        {
            OutputDebugString(__TEXT("Winmgmt: Bad Class Name Pointer in Class Part Header!"));
            FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Class Name Pointer in Class Part Header!" ));
            return WBEM_E_FAILED;
        }
    }

    // Now check the qualifier set
    HRESULT hres = m_Qualifiers.IsValidQualifierSet();
    if ( FAILED(hres) )
    {
        return hres;
    }

    // We're going to walk the instance property list and for every property
    // we find, if it's not NULL or DEFAULT , and a string, array or object,
    // verify that it actually points into a location in our heap.

    for(int i = 0; i < m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_Properties.GetAt(i);

        // This should be within the bounds of the class part as well.
        if ( !( (LPBYTE) pLookup >= pClassPartStart && (LPBYTE) pLookup < pClassPartEnd  ) )
        {
            OutputDebugString(__TEXT("Winmgmt: Bad Property Lookup Pointer!"));
            FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Property Lookup Pointer!" ));
            return WBEM_E_FAILED;
        }

        // Check the property name
        LPMEMORY    pPropName = NULL;
        
        if ( !CFastHeap::IsFakeAddress( pLookup->ptrName ) )
        {
            pPropName = m_Heap.ResolveHeapPointer( pLookup->ptrName );
        }
        
        // This should be within the bounds of the class part as well.
        if ( !( NULL == pPropName || ( pPropName >= pClassPartStart && pPropName < pClassPartEnd  ) ) )
        {
            OutputDebugString(__TEXT("Winmgmt: Bad Property Name Pointer!"));
            FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Property Name Pointer!" ));
            return WBEM_E_FAILED;
        }

        CPropertyInformation* pInfo =
            pLookup->GetInformation(&m_Heap);

        // This should be within the bounds of the class part as well.
        if ( !( (LPBYTE) pInfo >= pClassPartStart && (LPBYTE) pInfo < pClassPartEnd  ) )
        {
            OutputDebugString(__TEXT("Winmgmt: Bad Property Info Pointer!"));
            FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Property Info Pointer!" ));
            return WBEM_E_FAILED;
        }

        // We only do this for non-NULL values
        if( !m_Defaults.IsNull(pInfo->nDataIndex) )
        {
            if ( CType::IsPointerType( pInfo->nType ) )
            {
                CUntypedValue*  pValue = m_Defaults.GetOffset( pInfo->nDataOffset );

                if ( (LPMEMORY) pValue >= pClassPartStart && (LPMEMORY) pValue < pClassPartEnd )
                {
                    LPMEMORY    pData = m_Heap.ResolveHeapPointer( pValue->AccessPtrData() );

                    if ( pData >= pHeapStart && pData < pHeapEnd  )
                    {
                        // We could, if an embedded object, validate the object,
                        // or if an array of ptr values, validate those as well

                        if ( CType::IsArray( pInfo->nType ) )
                        {
                            hres = ((CUntypedArray*) pData)->IsArrayValid( pInfo->nType, &m_Heap );

                            if ( FAILED( hres ) )
                            {
                                return hres;
                            }
                        }

                    }
                    else
                    {
                        OutputDebugString(__TEXT("Winmgmt: Bad Property Value Heap Pointer!"));
                        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Property Value Heap Pointer!" ));
                        return WBEM_E_FAILED;
                    }
                }
                else
                {
                    OutputDebugString(__TEXT("Winmgmt: Bad Untyped Value pointer in m_Defaults!"));
                    FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Untyped Value pointer in m_Defaults!" ));
                    return WBEM_E_FAILED;
                }

            }   // IF is Pointer

        }   // IF not NULL or default

        // Now check the qualifier set.
        CBasicQualifierSet  qsProp;

        qsProp.SetData( pInfo->GetQualifierSetData(), &m_Heap );
        hres = qsProp.IsValidQualifierSet();

        if ( FAILED( hres ) )
        {
            return hres;
        }

    }   // FOR iterate properties

    return WBEM_S_NO_ERROR;

}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

length_t CClassAndMethods::GetMinLength()
{
    return CClassPart::GetMinLength() + CMethodPart::GetMinLength();
}

void CClassAndMethods::SetData(LPMEMORY pStart, CWbemClass* pClass,
                CClassAndMethods* pParent)
{
    m_pClass = pClass;
    m_ClassPart.SetData(pStart, this,
        (pParent ? &pParent->m_ClassPart : NULL));

    m_MethodPart.SetData(EndOf(m_ClassPart), this,
        (pParent ? &pParent->m_MethodPart : NULL));
}

void CClassAndMethods::SetDataWithNumProps(LPMEMORY pStart, CWbemClass* pClass,
                DWORD dwNumProperties, CClassAndMethods* pParent)
{
    m_pClass = pClass;

    // Initialize the class part with the total number of properties
    // so we will be able to access default values
    m_ClassPart.SetDataWithNumProps(pStart, this, dwNumProperties,
        (pParent ? &pParent->m_ClassPart : NULL));

    m_MethodPart.SetData(EndOf(m_ClassPart), this,
        (pParent ? &pParent->m_MethodPart : NULL));
}

// A "workaround" for an apparent compiler bug that is not setting
// the offset correctly.

#ifdef _WIN64
static int g_nTempOffset;
#endif;

void CClassAndMethods::Rebase(LPMEMORY pStart)
{
    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok.

    int nOffset = (int) ( m_MethodPart.GetStart() - m_ClassPart.GetStart() );

	// This apparently forces the nOffset value to be used, guaranteeing that
	// the IA64 compiler doesn't leave the value full of junk, causing a very
	// difficult to find AV.

#ifdef _WIN64
	g_nTempOffset = nOffset;
#endif;

    m_ClassPart.Rebase(pStart);
    m_MethodPart.Rebase(pStart + nOffset);
}

LPMEMORY CClassAndMethods::CreateEmpty(LPMEMORY pStart)
{
    LPMEMORY pCurrent = CClassPart::CreateEmpty(pStart);
    return CMethodPart::CreateEmpty(pCurrent);
}

length_t CClassAndMethods::EstimateDerivedPartSpace()
{
    return m_ClassPart.EstimateDerivedPartSpace() +
            m_MethodPart.EstimateDerivedPartSpace();
}

LPMEMORY CClassAndMethods::CreateDerivedPart(LPMEMORY pStart,
                                            length_t nAllocatedLength)
{
    LPMEMORY pCurrent = m_ClassPart.CreateDerivedPart(pStart,
        nAllocatedLength - m_MethodPart.EstimateDerivedPartSpace());

    // Check for allocation failure
    if ( NULL == pCurrent )
    {
        return NULL;
    }

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (pStart + nAllocatedLength) - pStart).
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    return m_MethodPart.CreateDerivedPart(pCurrent,
                                        (length_t) ( (pStart + nAllocatedLength) - pStart ) );
}

length_t CClassAndMethods::EstimateUnmergeSpace()
{
    return m_ClassPart.EstimateUnmergeSpace() +
            m_MethodPart.EstimateUnmergeSpace();
}

LPMEMORY CClassAndMethods::Unmerge(LPMEMORY pStart, length_t nAllocatedLength)
{
    LPMEMORY pCurrent = m_ClassPart.Unmerge(pStart,
        nAllocatedLength - m_MethodPart.EstimateUnmergeSpace());

    // Check for allocation failures
    if ( NULL == pCurrent )
    {
        return NULL;
    }

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value ( pStart + nAllocatedLength) - pStart).
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    return m_MethodPart.Unmerge(pCurrent,
                                (length_t) ( (pStart + nAllocatedLength) - pStart) );
}

length_t CClassAndMethods::EstimateMergeSpace(CClassAndMethods& ParentPart,
                                   CClassAndMethods& ChildPart)
{
    return CClassPart::EstimateMergeSpace(ParentPart.m_ClassPart,
                                            ChildPart.m_ClassPart) +
           CMethodPart::EstimateMergeSpace(ParentPart.m_MethodPart,
                                            ChildPart.m_MethodPart);
}

LPMEMORY CClassAndMethods::Merge(CClassAndMethods& ParentPart,
                      CClassAndMethods& ChildPart,
                      LPMEMORY pDest, int nAllocatedLength)
{
    int nMethodEstimate = CMethodPart::EstimateMergeSpace(
                        ParentPart.m_MethodPart, ChildPart.m_MethodPart);

    LPMEMORY pCurrent = CClassPart::Merge(ParentPart.m_ClassPart,
                        ChildPart.m_ClassPart, pDest,
                        nAllocatedLength - nMethodEstimate);

    // Check for memory allocation failures
    if ( NULL == pCurrent )
    {
        return NULL;
    }

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (pDest + nAllocatedLength) - pCurrent.
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    return CMethodPart::Merge(ParentPart.m_MethodPart, ChildPart.m_MethodPart,
                        pCurrent, (length_t) ( (pDest + nAllocatedLength) - pCurrent ) );
}

HRESULT CClassAndMethods::Update(CClassAndMethods& ParentPart,
                      CClassAndMethods& ChildPart, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Update the class part first
    hr =  CClassPart::Update( ParentPart.m_ClassPart, ChildPart.m_ClassPart, lFlags );

    // Successfully updated the class part, so update the method part
    if ( SUCCEEDED( hr ) )
    {
        hr = CMethodPart::Update( ParentPart.m_MethodPart, ChildPart.m_MethodPart, lFlags );
    }

    return hr;
}

EReconciliation CClassAndMethods::CanBeReconciledWith(
                                            CClassAndMethods& NewPart)
{
    EReconciliation eRes = m_ClassPart.CanBeReconciledWith(NewPart.m_ClassPart);
    if(eRes != e_Reconcilable)
        return eRes;
    return m_MethodPart.CanBeReconciledWith(NewPart.m_MethodPart);
}

EReconciliation CClassAndMethods::ReconcileWith(CClassAndMethods& NewPart)
{
    EReconciliation eRes = m_ClassPart.ReconcileWith(NewPart.m_ClassPart);
    if(eRes != e_Reconcilable)
        return eRes;
    return m_MethodPart.ReconcileWith(NewPart.m_MethodPart);
}

EReconciliation CClassAndMethods::CompareTo( CClassAndMethods& thatPart )
{
    EReconciliation eRes = m_ClassPart.CompareExactMatch( thatPart.m_ClassPart );
    if(eRes != e_ExactMatch)
        return eRes;
    return m_MethodPart.CompareExactMatch(thatPart.m_MethodPart);
}

void CClassAndMethods::Compact()
{
    m_ClassPart.Compact();
    m_MethodPart.Compact();
    MoveBlock(m_MethodPart, EndOf(m_ClassPart));
}

BOOL CClassAndMethods::ExtendClassPartSpace(CClassPart* pPart,
                                            length_t nNewLength)
{
    Compact();

    // No need to extend
    if(nNewLength <=
        (length_t)(m_MethodPart.GetStart() - m_ClassPart.GetStart()))
    {
        return TRUE;
    }

    BOOL    fReturn = m_pClass->ExtendClassAndMethodsSpace(nNewLength + m_MethodPart.GetLength());

    if ( fReturn )
    {
        MoveBlock(m_MethodPart, m_ClassPart.GetStart() + nNewLength);
    }

    return fReturn;
}

BOOL CClassAndMethods::ExtendMethodPartSpace(CMethodPart* pPart,
                                                length_t nNewLength)
{
    Compact();
    return m_pClass->ExtendClassAndMethodsSpace(nNewLength + m_ClassPart.GetLength());
}

IUnknown* CClassAndMethods::GetWbemObjectUnknown()
{
    return m_pClass->GetWbemObjectUnknown();
}

classindex_t CClassAndMethods::GetCurrentOrigin()
{
    return m_pClass->GetCurrentOrigin();
}

LPMEMORY CClassAndMethods::CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pDest,
        BOOL& bRemovedKeys)
{

    LPMEMORY    pCurrent = pDest,
                pEnd = pCurrent + nAllocatedSize;

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (pEnd - pCurrent).
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    // Create a Limited representation of our class part, and if
    // that is successful then do the same for our method part
    pCurrent = m_ClassPart.CreateLimitedRepresentation(pMap,
                    (length_t) ( pEnd - pCurrent ), pCurrent, bRemovedKeys);

    if ( pCurrent != NULL )
    {
        // For now, just copy the method block.  We'll worry about creating an
        // actual limited representation, or remove them altogether at a later time.

        // Ensure we will have enough memory to do this

        if ( m_MethodPart.GetLength() <= (length_t) ( pEnd - pCurrent ) )
        {
            CopyMemory( pCurrent, m_MethodPart.GetStart(), m_MethodPart.GetLength() );

            // Add to pCurrent, accounting for the method part
            pCurrent += m_MethodPart.GetLength();
        }
        else
        {
            pCurrent = NULL;
        }

    }

    return pCurrent;
}

BOOL CClassAndMethods::GetIndexedProps( CWStringArray& awsNames, LPMEMORY pStart )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    // Create a temporary stack object on the BLOB and, then ask the class part
    // for indexed properties

    CClassAndMethods    tempClassAndMethods;
    tempClassAndMethods.SetData( pStart, NULL, NULL );

    return tempClassAndMethods.m_ClassPart.GetIndexedProps( awsNames );
}

HRESULT CClassAndMethods::GetClassName( WString& wsClassName, LPMEMORY pStart )
{
    // Check for out of memory
    try
    {
        // Create a temporary stack object on the BLOB and, then ask the class part
        // for class name

        CClassAndMethods    tempClassAndMethods;
        tempClassAndMethods.SetData( pStart, NULL, NULL );

        CVar    var;
        HRESULT hr = tempClassAndMethods.m_ClassPart.GetClassName( &var );

        if ( SUCCEEDED( hr ) )
        {
            wsClassName = (LPCWSTR) var;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CClassAndMethods::GetSuperclassName( WString& wsSuperclassName, LPMEMORY pStart )
{
    // Check for out of memory
    try
    {
        // Create a temporary stack object on the BLOB and, then ask the class part
        // for class name

        CClassAndMethods    tempClassAndMethods;
        tempClassAndMethods.SetData( pStart, NULL, NULL );

        CVar    var;
        HRESULT hr = tempClassAndMethods.m_ClassPart.GetSuperclassName( &var );

        if ( SUCCEEDED( hr ) )
        {
			if ( !var.IsNull() )
			{
				wsSuperclassName = (LPCWSTR) var;
			}
			else
			{
				hr = WBEM_E_NOT_FOUND;
			}
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Destructor
CWbemClass::~CWbemClass( void )
{
	// Cleanup any allocated memory
	if ( NULL != m_pLimitMapping )
	{
		delete m_pLimitMapping;
	}
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetPropQualifier(CPropertyInformation* pInfo,
                                    LPCWSTR wszQualifier,
                                    CVar* pVar, long* plFlavor, CIMTYPE* pct)
{
    return m_CombinedPart.m_ClassPart.GetPropQualifier(pInfo, wszQualifier,
                pVar, plFlavor, pct);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
BOOL CWbemClass::ExtendClassAndMethodsSpace(length_t nNewLength)
{
    // (can only happen for m_CombinedPart --- m_ParentPart is read-only)

    // Check if there is enough space
    // ==============================

    if(GetStart() + m_nTotalLength >= m_CombinedPart.GetStart() + nNewLength)
        return TRUE;

    // Reallocate
    // ==========

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok.

    int nNewTotalLength = (int) ( (m_CombinedPart.GetStart() + nNewLength) - GetStart() );

    LPMEMORY pNew = Reallocate(nNewTotalLength);

    // Make sure the memory allocation didn't fail
    if ( NULL != pNew )
    {
        Rebase(pNew);
        m_nTotalLength = nNewTotalLength;
    }

    return ( NULL != pNew );
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::WriteDerivedClass(LPMEMORY pStart, int nAllocatedLength,
                                    CDecorationPart* pDecoration)
{
    // Copy the decoration
    // ===================

    LPMEMORY pCurrentEnd;
    if(pDecoration)
    {
        memcpy(pStart, pDecoration, pDecoration->GetLength());
        *(BYTE*)pStart = OBJECT_FLAG_CLASS & OBJECT_FLAG_DECORATED;
        pCurrentEnd = pStart + pDecoration->GetLength();
    }
    else
    {
        *(BYTE*)pStart = OBJECT_FLAG_CLASS;
        pCurrentEnd = pStart + sizeof(BYTE);
    }

    // Copy the parent part
    // ====================

    memcpy(pCurrentEnd, m_CombinedPart.GetStart(), m_CombinedPart.GetLength());
    pCurrentEnd += m_CombinedPart.GetLength();

    // Create derived class part
    // =========================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (nAllocatedLength - (pCurrentEnd - pStart).
    // We are not supporting length > 0xFFFFFFFF, so cast is ok.

    pCurrentEnd = m_CombinedPart.CreateDerivedPart(pCurrentEnd,
        (length_t) ( nAllocatedLength - (pCurrentEnd - pStart) ) );

    if ( NULL == pCurrentEnd )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        return WBEM_NO_ERROR;
    }
}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

HRESULT CWbemClass::Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace)
{
    CompactAll();

    Undecorate();

    // Check if there is enough space
    // ==============================

    length_t nDecorationSpace =
        CDecorationPart::ComputeNecessarySpace(wszServer, wszNamespace);

    length_t nNeededSpace =  nDecorationSpace +
        m_ParentPart.GetLength() + m_CombinedPart.GetLength();

    LPMEMORY pDest;
    if(nNeededSpace > m_nTotalLength)
    {
        m_CombinedPart.Compact();

        // Check that this succeeded.  If not, return an error
        pDest = Reallocate(nNeededSpace);

        if ( NULL == pDest )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        Rebase(pDest);
        m_nTotalLength = nNeededSpace;
    }
    else pDest = GetStart();

    // Move combined part
    // ==================

    MoveBlock(m_CombinedPart,
        pDest + nDecorationSpace + m_ParentPart.GetLength());

    // Move parent part
    // ================

    MoveBlock(m_ParentPart, pDest + nDecorationSpace);

    // Create decoration part
    // ======================

    m_DecorationPart.Create(OBJECT_FLAG_CLASS, wszServer, wszNamespace, pDest);

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
void CWbemClass::Undecorate()
{
    if(!m_DecorationPart.IsDecorated())
        return;
    // Create empty decoration
    // ========================

    LPMEMORY pStart = GetStart();
    m_DecorationPart.CreateEmpty(OBJECT_FLAG_CLASS, pStart);

    // Copy parent part back
    // =====================

    CopyBlock(m_ParentPart, EndOf(m_DecorationPart));

    // Copy combinedPart back
    // ======================

    CopyBlock(m_CombinedPart, EndOf(m_ParentPart));
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

LPWSTR CWbemClass::GetRelPath( BOOL bNormalized )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    if ( bNormalized == TRUE )
    {
        return NULL;
    }

    if(m_CombinedPart.m_ClassPart.m_pHeader->ptrClassName ==
                                                        INVALID_HEAP_ADDRESS)
        return NULL;

    // Start with the class name
    // =========================

    return m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
        m_CombinedPart.m_ClassPart.m_pHeader->ptrClassName)->
            CreateWStringCopy() . UnbindPtr();
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************

BOOL CWbemClass::MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        OUT CLimitationMapping* pMap)
{
    // Get the decoration part to map its info
    // =======================================

    if(!CDecorationPart::MapLimitation(pwsNames, pMap)) return FALSE;

    // Get the combined part to do most of the work
    // ============================================

    if ( !m_CombinedPart.m_ClassPart.MapLimitation(lFlags, pwsNames, pMap) )
    {
        return FALSE;
    }

#ifdef DEBUG_CLASS_MAPPINGS
    // Finally, store 'this' class in the limitation mapping so we can verify that
    // instances that get passed through are kosher.

    pMap->SetClassObject( this );
#endif

    return TRUE;

}


//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::GetQualifierSet(IWbemQualifierSet** ppQualifierSet)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        // This function doesn't cause any allocations so so need to perform out of memory
        // exception handling.

        if(ppQualifierSet == NULL)
            return WBEM_E_INVALID_PARAMETER;

        return m_CombinedPart.m_ClassPart.m_Qualifiers.QueryInterface(
            IID_IWbemQualifierSet, (void**)ppQualifierSet);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                            CIMTYPE ctType)
{
    // Check for out of memory
    try
    {
        CLock lock(this);

        if(wszName == NULL || 0L != ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
            return WBEM_E_INVALID_PARAMETER;

        // Check that the name is not a reserved word
        if ( CReservedWordTable::IsReservedWord( wszName ) )
        {
            return WBEM_E_INVALID_OPERATION;
        }

        if((pVal == NULL || V_VT(pVal) == VT_NULL) && ctType == 0)
        {
            CVar    vTemp;
            // The above cases are only a failure if the property does not exist
            // If the property exists, this will clear the property without
            // changing the type.

            HRESULT hr = GetProperty(wszName, &vTemp );
            if( FAILED(hr) ) return WBEM_E_INVALID_PARAMETER;
        }

        if(CType::GetActualType(ctType) != (Type_t) ctType)
            return WBEM_E_INVALID_PROPERTY_TYPE;

        if ( wbem_wcsicmp(wszName, L"__CLASS") )
		{
			if ( CSystemProperties::FindName(wszName) >= 0)
				return WBEM_E_READ_ONLY;

			// The property name MUST be a valid element name (note that
			// this will preclude all of our new system properties).
			if ( !IsValidElementName( wszName ) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}
		}
        else
        {
            // Make sure there are no bad characters
            // We must allow underscores, though.

            if (!IsValidElementName2(pVal->bstrVal, TRUE))
                return WBEM_E_INVALID_PARAMETER;
        }

        CVar Var;
        if(Var.SetVariant(pVal, TRUE) != CVar::no_error)
            return WBEM_E_TYPE_MISMATCH;

        HRESULT hres = SetPropValue(wszName, &Var, ctType);
        EndEnumeration();

        // Perform object validation here
        if ( FAILED( ValidateObject( 0L ) ) )
		{
			hres = WBEM_E_FAILED;
		}

        return hres;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::ForcePut(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType)
{
    // Check for out of memory
    try
    {
		// This will force a property in.
        CLock lock(this);

        CVar Var;
        if(Var.SetVariant(pVal, TRUE) != CVar::no_error)
            return WBEM_E_TYPE_MISMATCH;

        HRESULT hres = ForcePropValue(wszName, &Var, ctType);
        EndEnumeration();

        // Perform object validation here
        if ( FAILED( ValidateObject( 0L ) ) )
		{
			hres = WBEM_E_FAILED;
		}

        return hres;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::Delete(LPCWSTR wszName)
{
    // Check for out of memory.  The CopyParentProperty function could potentially cause
    // buffer reallocations to occur, so there is a chance we could hit an unhandled OOM,
    // but I strongly doubt it.

    try
    {
        CLock lock(this);

        if(wszName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Find the property
        // =================

        CPropertyInformation* pInfo = m_CombinedPart.m_ClassPart.FindPropertyInfo(wszName);
        if(pInfo == NULL)
        {
            if(CSystemProperties::FindName(wszName) >= 0)
                return WBEM_E_SYSTEM_PROPERTY;
            else
                return WBEM_E_NOT_FOUND;
        }

        // Check if it is ours or parent's
        // ===============================

        EndEnumeration();

        if(!CType::IsParents(pInfo->nType))
        {
            m_CombinedPart.m_ClassPart.DeleteProperty(wszName);

            // Perform object validation here
			if ( FAILED( ValidateObject( 0L ) ) )
			{
				return WBEM_E_FAILED;
			}

            return WBEM_NO_ERROR;
        }
        else
        {
            // It is our parent's. Deleting it means simply that we remove all
            // overriden qualifiers and reset the value to the default
            // ===============================================================

            m_CombinedPart.m_ClassPart.CopyParentProperty(m_ParentPart.m_ClassPart,
                                                            wszName);

            // Perform object validation here
			if ( FAILED( ValidateObject( 0L ) ) )
			{
				return WBEM_E_FAILED;
			}

            return WBEM_S_RESET_TO_DEFAULT;
        }
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** ppQualifierSet)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszProperty == NULL || wcslen(wszProperty) == 0)
            return WBEM_E_INVALID_PARAMETER;

        if(wszProperty[0] == L'_')
            return WBEM_E_SYSTEM_PROPERTY;

        CClassPropertyQualifierSet* pSet = new CClassPropertyQualifierSet;

        if ( NULL == pSet )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        HRESULT hres = m_CombinedPart.m_ClassPart.InitPropertyQualifierSet(wszProperty,
                                                                pSet);
        if(FAILED(hres))
        {
            delete pSet;
            *ppQualifierSet = NULL;
            return hres;
        }
        return pSet->QueryInterface(IID_IWbemQualifierSet,
                                    (void**)ppQualifierSet);
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::Clone(IWbemClassObject** ppCopy)
{
    CWbemClass* pNewClass = NULL;

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppCopy == NULL)
            return WBEM_E_INVALID_PARAMETER;
        m_CombinedPart.Compact();
        
        LPMEMORY pNewData = m_pBlobControl->Allocate(m_nTotalLength);

        if ( NULL != pNewData )
        {
            memcpy(pNewData, GetStart(), m_nTotalLength);

            // If we throw an exception here, we need to clean up the
            // byte array

            // Check for out of memory

            pNewClass = new CWbemClass;

            if ( NULL != pNewClass )
            {
                // There is a WString underneath this in a method part, so an exception
                // could get thrown here.  However, data buffer pointers will have been set
                // in the class by the time we get to the exception, so deleting
                // the class will effectively free the memory (yes it's a subtle behavior).

                pNewClass->SetData(pNewData, m_nTotalLength);
                pNewClass->CompactAll();
                pNewClass->m_nRef = 0;
                return pNewClass->QueryInterface(IID_IWbemClassObject, (void**)ppCopy);
            }
            else
            {
                m_pBlobControl->Delete(pNewData);
                return WBEM_E_OUT_OF_MEMORY;
            }

        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    catch (CX_MemoryException)
    {
        if ( NULL != pNewClass )
        {
            delete pNewClass;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        if ( NULL != pNewClass )
        {
            delete pNewClass;
        }

        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::SpawnInstance(long lFlags,
                                      IWbemClassObject** ppNewInstance)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppNewInstance == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        *ppNewInstance = NULL;

        m_CombinedPart.Compact();

        HRESULT hr = WBEM_E_OUT_OF_MEMORY;
        CWbemInstance* pNewInstance = new CWbemInstance;

        if ( NULL != pNewInstance )
        {
            hr = pNewInstance->InitNew(this);

            // Cleanup if initialization failed
            if( FAILED( hr ) )
            {
                delete pNewInstance;
                return hr;
            }

			// Since we don't allow the new System Properties to be written to classes, no
			// need to initialize them on instances
			//hr = pNewInstance->InitSystemTimeProps();

			if ( SUCCEEDED( hr ) )
			{
				pNewInstance->m_nRef = 0;
				if(!m_DecorationPart.IsDecorated())
				{
					pNewInstance->SetClientOnly();
				}
				hr = pNewInstance->QueryInterface(IID_IWbemClassObject,
					(void**)ppNewInstance);
			}
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::SpawnDerivedClass(long lFlags,
                                          IWbemClassObject** ppNewClass)
{
    // The functions underneath us will handle any OOM exceptions, so no need for us
    // to do any exception handling at this level.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppNewClass == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(!m_DecorationPart.IsDecorated())
        {
            *ppNewClass = NULL;
            return WBEM_E_INCOMPLETE_CLASS;
        }
       
        CWbemClass* pNewClass = NULL;

        // Use the helper function to actually spawn the class
        HRESULT hr = CreateDerivedClass( &pNewClass );

        if ( SUCCEEDED( hr ) )
        {
			if ( SUCCEEDED( hr ) )
			{
				// This set the refcount on the object to 0 and do a QI
				pNewClass->m_nRef = 0;
				hr = pNewClass->QueryInterface(IID_IWbemClassObject,
												(void**)ppNewClass);
			}
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::CreateDerivedClass( CWbemClass** ppNewClass )
{
    CWbemClass* pNewClass = NULL;

    try
    {
        HRESULT hr;

        // Allocate a memory block, write a derived class into the block,
        // then allocate a class object, sit it on the new blob and send that
        // back.

        m_CombinedPart.Compact();
        int nLength = EstimateDerivedClassSpace();

        LPMEMORY pNewData = m_pBlobControl->Allocate(nLength);

        if ( NULL != pNewData )
        {
            // Check for allocation errors
            memset(pNewData, 0, nLength);
            hr = WriteDerivedClass(pNewData, nLength, NULL);

            if ( SUCCEEDED( hr ) )
            {
                pNewClass = new CWbemClass;

                if ( NULL != pNewClass )
                {
                    pNewClass->SetData(pNewData, nLength);

					// Add the three new system properties (we should allocate enough memory to cover them
					// as well)
					//hr = pNewClass->InitSystemTimeProps();

					if ( SUCCEEDED( hr ) )
					{
						// Store the class.  It is already AddRef'd
						*ppNewClass = pNewClass;
					}
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // IF WriteDerivedClass
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        if ( NULL != pNewClass )
        {
            delete pNewClass;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        if ( NULL != pNewClass )
        {
            delete pNewClass;
        }

        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemClass::GetObjectText(long lFlags, BSTR* pstrText)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(pstrText == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if((lFlags & ~WBEM_FLAG_NO_SEPARATOR & ~WBEM_FLAG_NO_FLAVORS) != 0)
            return WBEM_E_INVALID_PARAMETER;

        *pstrText = NULL;

        WString wsText;

        // start by writing the qualifiers
        // ===============================

        HRESULT	hres = m_CombinedPart.m_ClassPart.m_Qualifiers.GetText(lFlags, wsText);

		if ( FAILED( hres ) )
		{
			return hres;
		}

        // append the class header
        // =======================

        wsText += L"\nclass ";
        CVar varClass;
        if(FAILED(m_CombinedPart.m_ClassPart.GetClassName(&varClass)) ||
            varClass.IsNull())
        {
            // invalid class
            // =============
            *pstrText = NULL;
            return WBEM_E_INCOMPLETE_CLASS;
        }
        wsText += varClass.GetLPWSTR();

        // append derivation information
        // =============================

        CVar varSuper;
        if(SUCCEEDED(m_CombinedPart.m_ClassPart.GetSuperclassName(&varSuper)) &&
            !varSuper.IsNull())
        {
            wsText += L" : ";
            wsText += varSuper.GetLPWSTR();
        }

        wsText += L"\n{\n";

        // Go through all properties one by one
        // ====================================

        CPropertyLookupTable& Properties = m_CombinedPart.m_ClassPart.m_Properties;
        for(int i = 0; i < Properties.GetNumProperties(); i++)
        {
            // Search for the property with this data index
            // ============================================

            CPropertyLookup* pLookup = NULL;
            CPropertyInformation* pInfo = NULL;
            for(int j = 0; j < Properties.GetNumProperties(); j++)
            {
                pLookup = Properties.GetAt(j);
                pInfo = pLookup->GetInformation(&m_CombinedPart.m_ClassPart.m_Heap);

                if(pInfo->nDataIndex == i)
                    break;
            }

            // Check if it is overriden, or simply inherited from the parent
            // =============================================================

            if(pInfo->IsOverriden(&m_CombinedPart.m_ClassPart.m_Defaults))
            {
				// We will ignore apparent system properties
				if ( !GetClassPart()->GetHeap()->ResolveString(pLookup->ptrName)->StartsWithNoCase( L"__" ) )
				{
					wsText += L"\t";
					hres = AddPropertyText(wsText, pLookup, pInfo, lFlags);
					wsText += L";\n";
					if(FAILED(hres)) return hres;
				}
            }
        }

        // Append method information
        // =========================

        hres = m_CombinedPart.m_MethodPart.AddText(wsText, lFlags);

		if ( FAILED( hres ) )
		{
			return hres;
		}

        // finish the class
        // ================

        wsText += L"}";

        if((lFlags & WBEM_FLAG_NO_SEPARATOR) == 0)
        {
            wsText += L";\n";
        }

        *pstrText = COleAuto::_SysAllocString((LPCWSTR)wsText);
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::AddPropertyText(WString& wsText, CPropertyLookup* pLookup,
                                    CPropertyInformation* pInfo, long lFlags)
{
    // Check for out of memory
    try
    {
        // start with qualifiers
        // =====================

        WString wsTemp;
        HRESULT	hr = CBasicQualifierSet::GetText(pInfo->GetQualifierSetData(),
					&m_CombinedPart.m_ClassPart.m_Heap, lFlags, wsTemp);

		if ( FAILED( hr ) )
		{
			return hr;
		}

        wsText += wsTemp;

        if(wsTemp.Length() != 0) wsText += L" ";

        // continue with the type
        // ======================

        CQualifier* pSyntaxQual = CBasicQualifierSet::GetQualifierLocally(
            pInfo->GetQualifierSetData(), &m_CombinedPart.m_ClassPart.m_Heap,
            TYPEQUAL);
        if(pSyntaxQual)
        {
            CVar varSyntax;

            // Check for possible allocation failures
            if ( !pSyntaxQual->Value.StoreToCVar(varSyntax,
                                                &m_CombinedPart.m_ClassPart.m_Heap) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            if(varSyntax.GetType() != VT_BSTR)
            {
                return WBEM_E_INVALID_CIM_TYPE;
            }

            LPWSTR wszSyntax = varSyntax.GetLPWSTR();
            CType::AddPropertyType(wsText, wszSyntax);
        }
        else
        {
            wsText += L"invalid";
        }
        wsText += L" ";

        // continue with the name
        // ======================

        wsText += m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
            pLookup->ptrName)->CreateWStringCopy();

        if(CType::IsArray(pInfo->nType))
        {
            wsText += L"[]";
        }

        // only specify the default value if it is not the same as parent's
        // ================================================================

        CDataTable& Defaults = m_CombinedPart.m_ClassPart.m_Defaults;
        if(!Defaults.IsDefault(pInfo->nDataIndex))
        {
            // Check if it is local and NULL
            // =============================

            if(CType::IsParents(pInfo->nType) ||!Defaults.IsNull(pInfo->nDataIndex))
            {
                wsText += L" = ";
                if(Defaults.IsNull(pInfo->nDataIndex))
                {
                    wsText += L"NULL";
                }
                else
                {
                    CVar varProp;

                    // Check for allocation failures
                    if ( !Defaults.GetOffset(pInfo->nDataOffset)
                            ->StoreToCVar(CType::GetActualType(pInfo->nType),
                                          varProp,
                                          &m_CombinedPart.m_ClassPart.m_Heap) )
                    {
                        return WBEM_E_OUT_OF_MEMORY;
                    }

                    // Get rid of any flags we may have munged in during
                    // method parameter evaluation.

                    LPWSTR wsz = GetValueText(lFlags & ~( WBEM_FLAG_IGNORE_IDS | WBEM_FLAG_IS_INOUT ),
                                    varProp,
                                    CType::GetActualType(pInfo->nType));

                    // We need to special case this one clean up wsz
                    try
                    {
                        if ( NULL != wsz )
                        {
                            wsText += wsz;
                            delete [] wsz;
                        }
                    }
                    catch (CX_MemoryException)
                    {
                        delete [] wsz;
                        return WBEM_E_OUT_OF_MEMORY;
                    }
                    catch (...)
                    {
                        delete [] wsz;
                        return WBEM_E_FAILED;
                    }

                }
            }
        }

        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::EnsureQualifier(LPCWSTR wszQual)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and changed to return an HRESULT

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        CVar vTrue(VARIANT_TRUE, VT_BOOL);
        CPropertyLookupTable& Properties = m_CombinedPart.m_ClassPart.m_Properties;
        for(int i = 0; SUCCEEDED( hr ) && i < Properties.GetNumProperties(); i++)
        {
            WString wsPropName =
                m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
                               Properties.GetAt(i)->ptrName)->CreateWStringCopy();

            hr = SetPropQualifier(wsPropName, wszQual, 0, &vTrue);
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::WritePropertyAsMethodParam(WString& wsText, int nIndex,
                    long lFlags, CWbemClass* pDuplicateParamSet, BOOL fIgnoreDups )
{

    // Check for out of memory
    try
    {
        HRESULT hres;

        CPropertyLookupTable& Properties = m_CombinedPart.m_ClassPart.m_Properties;
        for(int i = 0; i < Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = NULL;
            CPropertyInformation* pInfo = NULL;

            pLookup = Properties.GetAt(i);
            pInfo = pLookup->GetInformation(&m_CombinedPart.m_ClassPart.m_Heap);

            WString wsPropName = m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
                                    pLookup->ptrName)->CreateWStringCopy();
            if(wsPropName.EqualNoCase(L"ReturnValue"))
                continue;

			// Ignore if a system property
			//if ( CSystemProperties::IsExtProperty( wsPropName ) )
			//	continue;

            // Store the flags as we will be modifying them as necessary
            // e.g. IGNORE_IDS and IS_INOUT
            long lParamFlags = lFlags | WBEM_FLAG_IGNORE_IDS;

            // If we have a duplicate parameter set to check, look for the same property name
            // in the duplicate paramater set.  If it succeeds, the parameter is an [in,out]
            // parameter.  The assumption we make here is that this object and the duplicate
            // set have been validated for dupliate parameters.  If fIgnoreDuplicates is set
            // then we should just ignore the parameter, and get on with our lives.

            if ( NULL != pDuplicateParamSet )
            {
                CVar    vTemp;
                if ( SUCCEEDED( pDuplicateParamSet->GetProperty( wsPropName, &vTemp ) ) )
                {
                    if ( fIgnoreDups )
                    {
                        continue;
                    }
                    else
                    {
                        lParamFlags |= WBEM_FLAG_IS_INOUT;
                    }
                }
            }

			// Check its ID qualifier
			// ======================

			CVar vId;
			hres = GetPropQualifier(wsPropName, L"id", &vId);
			if(FAILED(hres))
				return WBEM_E_MISSING_PARAMETER_ID;
			if(vId.GetType() != VT_I4)
				return WBEM_E_INVALID_PARAMETER_ID;
			if(vId.GetLong() == nIndex)
			{
				return AddPropertyText(wsText, pLookup, pInfo, lParamFlags );
			}
        }

        return WBEM_E_NOT_FOUND;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

HRESULT CWbemClass::GetIds(CFlexArray& adwIds, CWbemClass* pDupParams /* = NULL */ )
{

    // Check for out of memory
    try
    {
        HRESULT hres;
        CPropertyLookupTable& Properties = m_CombinedPart.m_ClassPart.m_Properties;

        for(int i = 0; i < Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = NULL;
            CPropertyInformation* pInfo = NULL;
            pLookup = Properties.GetAt(i);
            pInfo = pLookup->GetInformation(&m_CombinedPart.m_ClassPart.m_Heap);

            WString wsPropName = m_CombinedPart.m_ClassPart.m_Heap.ResolveString(
                                    pLookup->ptrName)->CreateWStringCopy();
            if(wsPropName.EqualNoCase(L"ReturnValue"))
            {
                // Check that there is no ID qualifier
                // ===================================

                CVar vId;
                hres = GetPropQualifier(wsPropName, L"id", &vId);
                if(SUCCEEDED(hres))
                    return WBEM_E_PARAMETER_ID_ON_RETVAL;
            }
			// Don't do this if this appears to be a system property
			else if ( !CSystemProperties::IsPossibleSystemPropertyName( wsPropName ) )
            {
                // Check its ID qualifier
                // ======================

                CVar vId;
                hres = GetPropQualifier(wsPropName, L"id", &vId);
                if(FAILED(hres))
                    return WBEM_E_MISSING_PARAMETER_ID;
                if(vId.GetType() != VT_I4)
                    return WBEM_E_INVALID_PARAMETER_ID;
                if(vId.GetLong() < 0)
                    return WBEM_E_INVALID_PARAMETER_ID;

                // If the pDupParams parameter is non-NULL, try to get the property we
                // are working on from the pDupParams object.  If we get it, the property
                // is a dup (previously identified), so ignore it.  If pDupParams is NULL,
                // add all properties

                if ( NULL != pDupParams )
                {
                    // Destructor will empty this out
                    CVar    vTemp;

                    if ( FAILED( pDupParams->GetProperty( wsPropName, &vTemp ) ) )
                    {
                        // DEVNOTE:WIN64:SJS - Casting 32-bit value to 64-bit size.
                        if ( adwIds.Add((void*) (__int64) vId.GetLong()) != CFlexArray::no_error )
                        {
                            return WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }
                else
                {
                    // DEVNOTE:WIN64:SJS - Casting 32-bit value to 64-bit size.

                    // Add all properties found, regardless
                    if ( adwIds.Add((void*) (__int64) vId.GetLong()) != CFlexArray::no_error )
                    {
                        return WBEM_E_OUT_OF_MEMORY;
                    }
                }

            }   // ELSE Property !ReturnValue

        }   // FOR enuming properties

        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


WString CWbemClass::FindLimitationError(IN long lFlags,
                                  IN CWStringArray* pwsNames)
{
    try
    {
        // Verify that all property names are either in the class or are system
        // ====================================================================

        for(int i = 0; i < pwsNames->Size(); i++)
        {
            LPCWSTR wszProp = pwsNames->GetAt(i);
            if(FAILED(GetPropertyType(wszProp, NULL, NULL)))
            {
                return wszProp;
            }
        }

        return L"";
    }
    catch (CX_MemoryException)
    {
        throw;
    }
    catch (...)
    {
        throw;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 LPMEMORY CWbemClass::CreateEmpty(LPMEMORY pStart)
{
    CDecorationPart DecPart;
    LPMEMORY pCurrent = DecPart.CreateEmpty(OBJECT_FLAG_CLASS, pStart);

    pCurrent = CClassAndMethods::CreateEmpty(pCurrent);
    pCurrent = CClassAndMethods::CreateEmpty(pCurrent);
    return pCurrent;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 void CWbemClass::SetData(LPMEMORY pStart, int nTotalLength)
{
    m_DecorationPart.SetData(pStart);
    m_ParentPart.SetData(EndOf(m_DecorationPart), this, NULL);
    m_CombinedPart.SetData(EndOf(m_ParentPart), this, &m_ParentPart);

    m_nTotalLength = nTotalLength;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 void CWbemClass::Rebase(LPMEMORY pMemory)
{
    m_DecorationPart.Rebase(pMemory);
    m_ParentPart.Rebase(EndOf(m_DecorationPart));
    m_CombinedPart.Rebase(EndOf(m_ParentPart));
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 length_t CWbemClass::EstimateDerivedClassSpace(
        CDecorationPart* pDecoration)
{
    return m_CombinedPart.GetLength() +
        m_CombinedPart.EstimateDerivedPartSpace() +
        ((pDecoration)?
                pDecoration->GetLength()
                :CDecorationPart::GetMinLength());
}


//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CWbemClass::InitEmpty( int nExtraMem/* = 0*/, BOOL fCreateSystemProps/* = TRUE*/ )
{
	HRESULT	hr = WBEM_S_NO_ERROR;
	
     // Throws an exception in OOM
    int nLength = GetMinLength();

	// Slip in 128 extra bytes for the new system properties
	if ( fCreateSystemProps )
	{
		nLength += 128;
	}

    LPMEMORY pMem = m_pBlobControl->Allocate(nLength + nExtraMem);

    if ( NULL != pMem )
    {
		memset(pMem, 0, nLength + nExtraMem);
		CreateEmpty(pMem);

		SetData(pMem, nLength + nExtraMem);

		// Add the three new system properties (we should allocate enough memory to cover them
		// as well).  We'll probably want to make a binary snapshot of this class and just set
		// it in order to speed things up.

        /*
		if ( fCreateSystemProps )
		{
			hr = InitSystemTimeProps();
		}
		*/
    }
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
 length_t CWbemClass::EstimateMergeSpace(LPMEMORY pChildPart,
                                        CDecorationPart* pDecoration)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    CClassAndMethods ChildPart;
    ChildPart.SetData(pChildPart, this);
    return m_CombinedPart.GetLength() +
        CClassAndMethods::EstimateMergeSpace(m_CombinedPart, ChildPart) +
        ((pDecoration)?
                pDecoration->GetLength()
                :CDecorationPart::GetMinLength());
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************

LPMEMORY CWbemClass::Merge(LPMEMORY pChildPart,
                                 LPMEMORY pDest, int nAllocatedLength,
                                 CDecorationPart* pDecoration)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    CClassAndMethods ChildPart;
    ChildPart.SetData(pChildPart, this);

    LPMEMORY pCurrentEnd = pDest;
    // Start with the decoration
    // =========================

    if(pDecoration)
    {
        memcpy(pDest, pDecoration, pDecoration->GetLength());
        *(BYTE*)pDest = OBJECT_FLAG_CLASS & OBJECT_FLAG_DECORATED;
        pCurrentEnd = pDest + pDecoration->GetLength();
    }
    else
    {
        *(BYTE*)pDest = OBJECT_FLAG_CLASS;
        pCurrentEnd = pDest + sizeof(BYTE);
    }

    // Copy our combined part as his parent part
    // =========================================

    memcpy(pCurrentEnd, m_CombinedPart.GetStart(), m_CombinedPart.GetLength());
    pCurrentEnd += m_CombinedPart.GetLength();

    // Merge our combined part with the child part for his combined part
    // =================================================================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (nAllocatedLength - (pCurrentEnd - pDest).
    // We do not support length > 0xFFFFFFFF, so cast is ok.

    // This will return NULL if anything beefs
    pCurrentEnd = CClassAndMethods::Merge(m_CombinedPart, ChildPart,
        pCurrentEnd, (length_t) ( nAllocatedLength - (pCurrentEnd - pDest) ));

    return pCurrentEnd;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CWbemClass::Update( CWbemClass* pOldChild, long lFlags, CWbemClass** ppUpdatedChild )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    try
    {
        HRESULT hr = WBEM_E_INVALID_PARAMETER;

        // Safe Mode or Force Mode MUST be specified.

        if (    WBEM_FLAG_UPDATE_SAFE_MODE == ( lFlags & WBEM_MASK_UPDATE_MODE )
            ||  WBEM_FLAG_UPDATE_FORCE_MODE == ( lFlags & WBEM_MASK_UPDATE_MODE ) )
        {

            // To get to "local" data for our child class, Unmerge into a BLOB

            int nChildUnmergeSpace = pOldChild->EstimateUnmergeSpace();
            LPBYTE  pbUnmergedChild = new BYTE[ALIGN_FASTOBJ_BLOB(nChildUnmergeSpace)];
            CVectorDeleteMe<BYTE> vdm( pbUnmergedChild );

            if ( NULL != pbUnmergedChild )
            {
                // Handle out of memory here
                hr = pOldChild->Unmerge( pbUnmergedChild, nChildUnmergeSpace, NULL );

                if ( SUCCEEDED( hr ) )
                {

                    CWbemClass* pNewClass;

                    // Spawn a derived class.  From there, we can walk the combined part of the
                    // child and try to write "local" information from the child combined part
                    // into the new class.  If we have no class name, then we should simply make
					// a clone.  The child class is a base class which we will update

					CVar	varClass;

					GetClassName( &varClass );

					if ( varClass.IsNull() )
					{
						hr = Clone( (IWbemClassObject**) &pNewClass );
					}
					else
					{
						hr = CreateDerivedClass( &pNewClass );
					}

                    if ( SUCCEEDED( hr ) )
                    {
                        // Make sure we pass in dwNumProperties so we can initialize the class
                        // part's data table with the total number of properties and thereby
                        // correctly access the default values.

                        CClassAndMethods ChildPart;
                        ChildPart.SetDataWithNumProps( pbUnmergedChild, pOldChild,
                            pOldChild->m_CombinedPart.m_ClassPart.m_Properties.GetNumProperties() );

                        hr = CClassAndMethods::Update( pNewClass->m_CombinedPart, ChildPart, lFlags );

                        if ( SUCCEEDED( hr ) )
                        {
                            *ppUpdatedChild = pNewClass;
                        }
                        else
                        {
							// The following errors are indicative of conflicts in derived
							// classes, so tweak the error code to be more descriptive.
							switch ( hr )
							{
								case WBEM_E_TYPE_MISMATCH :			hr = WBEM_E_UPDATE_TYPE_MISMATCH;			break;
								case WBEM_E_OVERRIDE_NOT_ALLOWED :	hr = WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED;	break;
								case WBEM_E_PROPAGATED_METHOD :		hr = WBEM_E_UPDATE_PROPAGATED_METHOD;		break;
							};

                            pNewClass->Release();
                        }

                    }   // IF CreateDerivedClass()

                }   // IF Unmerge()

            }   // if NULL != pbUnmergedChild
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }


        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************

// We will throw exceptions in OOM scenarios
CWbemClass* CWbemClass::CreateFromBlob(CWbemClass* pParent,
                                            LPMEMORY pChildPart)
{
    CWbemClass* pClass = NULL;

    try
    {
        pClass = new CWbemClass;

        if ( NULL != pClass )
        {

            CWbemClass LocalParent;
            if(pParent == NULL)
            {
                if ( FAILED( LocalParent.InitEmpty(0) ) )
				{
					throw CX_MemoryException();
				}

                pParent = &LocalParent;
            }

            int nSpace =  pParent->EstimateMergeSpace(pChildPart, NULL);

            LPMEMORY pNewMem = pClass->m_pBlobControl->Allocate(nSpace);

            if ( NULL != pNewMem )
            {
                memset(pNewMem, 0, nSpace);

                // Check for allocation errors
                if ( pParent->Merge(pChildPart, pNewMem, nSpace, NULL) != NULL )
                {
                    // If an exception is thrown here, the decoration part should have
                    // the BLOB, so deleting the class should free the BLOB.
                    pClass->SetData(pNewMem, nSpace);

                    // Perform object validation here
			        if ( FAILED( pClass->ValidateObject( 0L ) ) )
					{
						pClass->Release();
						pClass = NULL;
					}

                }
                else
                {
                    pClass->m_pBlobControl->Delete(pNewMem);
                }

            }
            else
            {
                throw CX_MemoryException();
            }

        }
        else
        {
            throw CX_MemoryException();
        }

        return pClass;
    }
    catch (CX_MemoryException)
    {
        // Cleanup the class and rethrow the exception

        if ( NULL != pClass )
            delete pClass;
        throw;
    }
    catch (...)
    {
        // Cleanup the class and rethrow the exception
        if ( NULL != pClass )
            delete pClass;
        throw;
    }



}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetProperty(LPCWSTR wszName, CVar* pVal)
{
    HRESULT hres = GetSystemPropertyByName(wszName, pVal);
    if(hres == WBEM_E_NOT_FOUND)
        return m_CombinedPart.m_ClassPart.GetDefaultValue(wszName, pVal);
    else
        return hres;
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                    long* plFlavor)
{
    return m_CombinedPart.m_ClassPart.GetPropertyType(wszName, pctType, plFlavor);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                    long* plFlavor)
{
    return m_CombinedPart.m_ClassPart.GetPropertyType(pInfo, pctType, plFlavor);
}


HRESULT CWbemClass::SetPropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType)
{
    if(!wbem_wcsicmp(wszName, L"__CLASS"))
        return m_CombinedPart.m_ClassPart.SetClassName(pVal);

	// If the value starts with an underscore see if it's a System Property
	// DisplayName, and if so, switch to a property name - otherwise, this
	// will just return the string we passed in
	
	//wszName = CSystemProperties::GetExtPropName( wszName );

    if(!CUntypedValue::CheckCVar(*pVal, ctType))
        return WBEM_E_TYPE_MISMATCH;

    HRESULT hres = m_CombinedPart.m_ClassPart.EnsureProperty(wszName,
                        (VARTYPE) pVal->GetOleType(), ctType, FALSE);
    if(FAILED(hres)) return hres;
    return m_CombinedPart.m_ClassPart.SetDefaultValue(wszName, pVal);
}

HRESULT CWbemClass::ForcePropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType)
{
    if(!wbem_wcsicmp(wszName, L"__CLASS"))
        return m_CombinedPart.m_ClassPart.SetClassName(pVal);

	// If the value starts with an underscore see if it's a System Property
	// DisplayName, and if so, switch to a property name - otherwise, this
	// will just return the string we passed in
	
	// wszName = CSystemProperties::GetExtPropName( wszName );

    if(!CUntypedValue::CheckCVar(*pVal, ctType))
        return WBEM_E_TYPE_MISMATCH;

	// Force the property into existence if at all possible
    HRESULT hres = m_CombinedPart.m_ClassPart.EnsureProperty(wszName,
                        (VARTYPE) pVal->GetOleType(), ctType, TRUE);
    if(FAILED(hres)) return hres;
    return m_CombinedPart.m_ClassPart.SetDefaultValue(wszName, pVal);
}

HRESULT CWbemClass::GetQualifier(LPCWSTR wszName, CVar* pVal,
                                    long* plFlavor, CIMTYPE* pct /*=NULL*/ )
{
    //  We may want to separate this later...however for now, we'll only get
    //  local values.

    return m_CombinedPart.m_ClassPart.GetClassQualifier(wszName, pVal, plFlavor, pct);

//  if ( fLocalOnly )
//  {
//      return m_CombinedPart.m_ClassPart.GetClassQualifier(wszName, pVal, plFlavor);
//  }
//  else
//  {
//      return m_CombinedPart.m_ClassPart.GetQualifier(wszName, pVal, plFlavor);
//  }
}

HRESULT CWbemClass::GetQualifier( LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedValue,
								 CFastHeap** ppHeap, BOOL fValidateSet )
{
    //  We may want to separate this later...however for now, we'll only get
    //  local values.

    return m_CombinedPart.m_ClassPart.GetClassQualifier( wszName, plFlavor, pTypedValue,
														ppHeap, fValidateSet );

}

HRESULT CWbemClass::SetQualifier(LPCWSTR wszName, CVar* pVal, long lFlavor)
{
    if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    return m_CombinedPart.m_ClassPart.SetClassQualifier(wszName, pVal, lFlavor);
}

HRESULT CWbemClass::SetQualifier( LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue )
{
    if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    return m_CombinedPart.m_ClassPart.SetClassQualifier(wszName, lFlavor, pTypedValue);
}

HRESULT CWbemClass::GetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                        CVar* pVar, long* plFlavor, CIMTYPE* pct)
{
    CPropertyInformation* pInfo =
        m_CombinedPart.m_ClassPart.FindPropertyInfo(wszProp);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;
    return GetPropQualifier(pInfo, wszQualifier, pVar, plFlavor, pct);
}

HRESULT CWbemClass::GetPropQualifier(LPCWSTR wszName, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet)
{
	return m_CombinedPart.m_ClassPart.GetPropQualifier(wszName, wszQualifier,
					plFlavor, pTypedVal, ppHeap, fValidateSet);
}

HRESULT CWbemClass::GetPropQualifier(CPropertyInformation* pPropInfo, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet)
{
	return E_NOTIMPL;;
}

HRESULT CWbemClass::FindMethod( LPCWSTR wszMethodName )
{
    classindex_t nIndex;
    return m_CombinedPart.m_MethodPart.GetMethodOrigin(wszMethodName, &nIndex);
}

HRESULT CWbemClass::GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
                                        CVar* pVar, long* plFlavor, CIMTYPE* pct)
{
    // Get the qualifier set. TBD: more efficiently
    // ============================================

    IWbemQualifierSet* pSet;
    HRESULT hres =
        m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszMethod, &pSet);
    if(FAILED(hres)) return hres;

    CQualifier* pQual = ((CQualifierSet*)pSet)->GetQualifier(wszQualifier);
    if(pQual == NULL)
    {
        pSet->Release();
        return WBEM_E_NOT_FOUND;
    }

	// Store the type if requested
	if ( NULL != pct )
	{
		*pct = pQual->Value.GetType();
	}

    // Convert to CVar
    // ===============

    if(plFlavor) *plFlavor = pQual->fFlavor;

    // Check for allocation failure
    if ( !pQual->Value.StoreToCVar(*pVar, &m_CombinedPart.m_ClassPart.m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pSet->Release();
    return WBEM_NO_ERROR;
}

HRESULT CWbemClass::GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long* plFlavor,
									CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet)
{
    // Get the qualifier set. TBD: more efficiently
    // ============================================

    IWbemQualifierSet* pSet;
    HRESULT hr =
        m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszMethod, &pSet);
    if(FAILED(hr)) return hr;

    CQualifier* pQual = ((CQualifierSet*)pSet)->GetQualifier(wszQualifier);
    if(pQual == NULL)
    {
        pSet->Release();
        return WBEM_E_NOT_FOUND;
    }

	// Make sure a set will actually work - Ostensibly we are calling this API because we need
	// direct access to a qualifier's underlying data before actually setting (possibly because
	// the qualifier is an array).
	if ( fValidateSet )
	{
		hr = ((CQualifierSet*)pSet)->ValidateSet( wszQualifier, pQual->fFlavor, pTypedVal, TRUE, TRUE );
	}

    // Store the flavor
    // ===============

    if(plFlavor) *plFlavor = pQual->fFlavor;

	// This class's heap since we're getting locally
	*ppHeap = &m_CombinedPart.m_ClassPart.m_Heap;

    // Check for possible allocation failure
	if ( NULL != pTypedVal )
	{
		pQual->Value.CopyTo( pTypedVal );
	}

    pSet->Release();
    return WBEM_NO_ERROR;
}

HRESULT CWbemClass::SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
										CVar *pVal)
{
    // Access that method's qualifier set
    // ====================================

    IWbemQualifierSet* pSet;
    HRESULT hr =
        m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszMethod, &pSet);
    if(FAILED(hr)) return hr;

    // Create the value
    // ================

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Grab errors directly from this call
    hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVal, m_CombinedPart.m_MethodPart.GetHeap());

    if ( SUCCEEDED( hr ) )
    {
        // The last call may have moved us --- rebase
        // ==========================================

        ((CQualifierSet*)pSet)->SelfRebase();
        hr = ((CQualifierSet*)pSet)->SetQualifierValue(wszQualifier, (BYTE)lFlavor, &Value, TRUE);
    }

    return hr;
}

HRESULT CWbemClass::SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
									long lFlavor, CTypedValue* pTypedVal)
{
    // Access that method's qualifier set
    // ====================================

    IWbemQualifierSet* pSet;
    HRESULT hr =
        m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszMethod, &pSet);
    if(FAILED(hr)) return hr;

	hr = ((CQualifierSet*)pSet)->SetQualifierValue(wszQualifier, (BYTE)lFlavor, pTypedVal, TRUE);

    return hr;
}

HRESULT CWbemClass::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
                                        long lFlavor, CVar *pVal)
{
    return m_CombinedPart.m_ClassPart.SetPropQualifier(wszProp, wszQualifier,
                lFlavor, pVal);
}

HRESULT CWbemClass::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
									long lFlavor, CTypedValue* pTypedVal)
{
    return m_CombinedPart.m_ClassPart.SetPropQualifier(wszProp, wszQualifier,
                lFlavor, pTypedVal);
}

STDMETHODIMP CWbemClass::GetMethod(LPCWSTR wszName, long lFlags,
                        IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
{
    // The lower level functions should handle any OOM exceptions, so no
    // need to do it up here.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszName == NULL || lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(ppInSig) *ppInSig = NULL;
        if(ppOutSig) *ppOutSig = NULL;

        CWbemObject* pInSig, *pOutSig;
        HRESULT hres = m_CombinedPart.m_MethodPart.GetMethod(wszName, lFlags, &pInSig, &pOutSig);
        if(FAILED(hres)) return hres;

        if(ppInSig)
            *ppInSig = pInSig;
        else if(pInSig)
            pInSig->Release();

        if(ppOutSig)
            *ppOutSig = pOutSig;
        else if(pOutSig)
            pOutSig->Release();
        return hres;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::PutMethod(LPCWSTR wszName, long lFlags,
                        IWbemClassObject* pInSig, IWbemClassObject* pOutSig)
{
    // Check for out of memory.  This function will perform allocations under
    // the covers, but I believe the lower levels should do the OOM handling.
    // Since I'm not sure, I'm adding handling here.

    try
    {
        CLock lock(this);

        if(wszName == NULL || lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

		CWbemObject*	pWmiInSig = NULL;
		CWbemObject*	pWmiOutSig = NULL;

		// Check that these are our objects, or this don't fly
		HRESULT	hres = WbemObjectFromCOMPtr( pInSig, &pWmiInSig );
		CReleaseMe	rm1( (IWbemClassObject*) pWmiInSig );

		if ( SUCCEEDED( hres ) )
		{
			hres = WbemObjectFromCOMPtr( pOutSig, &pWmiOutSig );
			CReleaseMe	rm2( (IWbemClassObject*) pWmiOutSig );

			if ( SUCCEEDED( hres ) )
			{
				hres = m_CombinedPart.m_MethodPart.PutMethod( wszName, lFlags,
														   pWmiInSig, pWmiOutSig );
			}

		}	// IF gor WBEM Objects

        EndMethodEnumeration();

        // Perform object validation here
        if ( FAILED( ValidateObject( 0L ) ) )
		{
			hres = WBEM_E_FAILED;
		}

        return hres;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

STDMETHODIMP CWbemClass::DeleteMethod(LPCWSTR wszName)
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        CLock lock(this);

        if(wszName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        HRESULT hres = m_CombinedPart.m_MethodPart.DeleteMethod(wszName);
        EndMethodEnumeration();

        // Perform object validation here
        if ( FAILED( ValidateObject( 0L ) ) )
		{
			hres = WBEM_E_FAILED;
		}

        return hres;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::BeginMethodEnumeration(long lFlags)
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        CLock lock(this);
             
        if ((lFlags == WBEM_FLAG_LOCAL_ONLY) ||
            (lFlags == WBEM_FLAG_PROPAGATED_ONLY) ||
            (lFlags == (WBEM_FLAG_PROPAGATED_ONLY|WBEM_FLAG_LOCAL_ONLY)) ||            
            (lFlags == 0)) // old compatibility case
        {
	        m_nCurrentMethod = 0;
	        m_FlagMethEnum = (lFlags == 0)?(WBEM_FLAG_LOCAL_ONLY|WBEM_FLAG_PROPAGATED_ONLY):lFlags;
	        return WBEM_S_NO_ERROR;        
        }
        else
            return WBEM_E_INVALID_PARAMETER;


    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::EndMethodEnumeration()
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        CLock lock(this);

        if(m_nCurrentMethod == -1)
            return WBEM_E_UNEXPECTED;
            
        m_nCurrentMethod = -1;
        m_FlagMethEnum = (WBEM_FLAG_PROPAGATED_ONLY|WBEM_FLAG_LOCAL_ONLY);
        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::NextMethod(long lFlags, BSTR* pstrName,
                   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
{
    // The lower level functions should be correctly handling any OOM exceptions,
    // so we should be okay at this level.

    try
    {
        CLock lock(this);

        if(pstrName) *pstrName = NULL;
        if(ppInSig) *ppInSig = NULL;
        if(ppOutSig) *ppOutSig = NULL;

        if(m_nCurrentMethod == -1)
            return WBEM_E_UNEXPECTED;

        CWbemObject* pInSig = NULL;
        CWbemObject* pOutSig = NULL;
        BSTR LocalBstrName = NULL;        
        HRESULT hres;

InnerNext:
        
        hres = m_CombinedPart.m_MethodPart.GetMethodAt(m_nCurrentMethod++, &LocalBstrName,
                                    &pInSig, &pOutSig);
        if (WBEM_S_NO_ERROR == hres)
        {
            if ((WBEM_FLAG_LOCAL_ONLY|WBEM_FLAG_PROPAGATED_ONLY) == (m_FlagMethEnum & (WBEM_FLAG_LOCAL_ONLY|WBEM_FLAG_PROPAGATED_ONLY)))
            {
                // both bit set, both kind of properties
            }
            else
            {
                BOOL bValid = FALSE;
                // is touched == Is Local or is Locally Overridden
                BOOL bRet = m_CombinedPart.m_MethodPart.IsTouched(m_nCurrentMethod-1,&bValid); //LocalBstrName);

                if (!bValid)
                    DebugBreak();

                // DEBUG
                char pBuff[128];
                sprintf(pBuff," %S %d fl %d\n",LocalBstrName,bRet,m_FlagMethEnum);
                OutputDebugStringA(pBuff);
                // DEBUG
                
                if (bRet && (m_FlagMethEnum & WBEM_FLAG_LOCAL_ONLY))
                {
                    // OK
                } 
                else if (!bRet && (m_FlagMethEnum & WBEM_FLAG_PROPAGATED_ONLY))
                {
                    // OK
                }
                else 
                {
                    if (pInSig){
                        pInSig->Release();
                        pInSig = NULL;
                    }
                    if (pOutSig){
                        pOutSig->Release();
                        pOutSig = NULL;
                    }
                    if (LocalBstrName) {
                        SysFreeString(LocalBstrName);
                        LocalBstrName = NULL;
                    }
                    goto InnerNext;
                }               
            }
        }
        
        if(hres != WBEM_S_NO_ERROR) return hres;

        if(ppInSig)
            *ppInSig = pInSig;
        else if(pInSig)
            pInSig->Release();

        if(ppOutSig)
            *ppOutSig = pOutSig;
        else if(pOutSig)
            pOutSig->Release();

        if (pstrName) {
            *pstrName = LocalBstrName;
        } else {
            if (LocalBstrName)
                SysFreeString(LocalBstrName);
        }
        return hres;
    }
    catch(...)
    {
        // In case something really blows.
        try
        {
        }
        catch(...)
        {
            m_nCurrentMethod = -1;
            m_FlagMethEnum = (WBEM_FLAG_PROPAGATED_ONLY|WBEM_FLAG_LOCAL_ONLY);
        }

        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::GetMethodQualifierSet(LPCWSTR wszName,
                    IWbemQualifierSet** ppSet)
{
    // The lower level functions should be correctly handling any OOM exceptions,
    // so we should be okay at this level.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszName == NULL || ppSet == NULL)
            return WBEM_E_INVALID_PARAMETER;
        *ppSet = NULL;

        return m_CombinedPart.m_MethodPart.GetMethodQualifierSet(wszName, ppSet);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemClass::GetMethodOrigin(LPCWSTR wszMethodName,
                    BSTR* pstrClassName)
{
    // I believe the underlying functions will handle the OOM exceptions.  The
    // only one where any allocations will occur, is when we get the BSTR, which
    // will handle an exception and return NULL (which we are checking for).

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszMethodName == NULL || pstrClassName == NULL)
            return WBEM_E_INVALID_PARAMETER;
        *pstrClassName = NULL;

        classindex_t nIndex;
        HRESULT hres = m_CombinedPart.m_MethodPart.GetMethodOrigin(wszMethodName, &nIndex);
        if(FAILED(hres)) return hres;

        CCompressedString* pcs = m_CombinedPart.m_ClassPart.m_Derivation.GetAtFromLast(nIndex);
        if(pcs == NULL)
            pcs = m_CombinedPart.m_ClassPart.GetClassName();
        if(pcs == NULL)
            *pstrClassName = NULL;
        else
        {
            *pstrClassName = pcs->CreateBSTRCopy();

            // Check for allocation failure
            if ( NULL == *pstrClassName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

STDMETHODIMP CWbemClass::SetInheritanceChain(long lNumAntecedents,
    LPWSTR* awszAntecedents)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        return m_CombinedPart.m_ClassPart.SetInheritanceChain(lNumAntecedents,
                                                              awszAntecedents);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}
STDMETHODIMP CWbemClass::SetPropertyOrigin(LPCWSTR wszPropertyName, long lOriginIndex)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        return m_CombinedPart.m_ClassPart.SetPropertyOrigin(wszPropertyName,
                                                            lOriginIndex);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}
STDMETHODIMP CWbemClass::SetMethodOrigin(LPCWSTR wszMethodName, long lOriginIndex)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        return m_CombinedPart.m_MethodPart.SetMethodOrigin(wszMethodName,
                                                            lOriginIndex);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

void CWbemClass::CompactAll()
{
    m_CombinedPart.Compact();
}

HRESULT CWbemClass::CreateDerivedClass(CWbemClass* pParent, int nExtraSpace,
    CDecorationPart* pDecoration)
{
    try
    {
        int nLength = pParent->EstimateDerivedClassSpace();

        HRESULT hr = WBEM_E_OUT_OF_MEMORY;
        
        LPMEMORY pNewData = m_pBlobControl->Allocate(nLength);

        // Check for allocation failure
        if ( NULL != pNewData )
        {
            memset(pNewData, 0, nLength);

            // Check for allocation failure
            hr = pParent->WriteDerivedClass(pNewData, nLength, pDecoration);
            SetData(pNewData, nLength);
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        // IF SetData threw and exception, we will still have the memory, so
        // cleaning us up will clean up the memory.
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        // IF SetData threw and exception, we will still have the memory, so
        // cleaning us up will clean up the memory.
        return WBEM_E_FAILED;
    }

}

length_t CWbemClass::EstimateUnmergeSpace()
{
    return m_CombinedPart.EstimateUnmergeSpace();
}

HRESULT CWbemClass::Unmerge(LPMEMORY pDest, int nAllocatedLength, length_t* pnUnmergedLength)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // See if the object looks okay before we pull it apart.
    hr = ValidateObject( 0L );

	if ( FAILED( hr ) )
	{
		return hr;
	}

    // Check that unmerge succeeded
    LPMEMORY pUnmergedEnd = m_CombinedPart.Unmerge(pDest, nAllocatedLength);

    if ( NULL != pUnmergedEnd )
    {
        // Return the length in the supplied variable
        if ( NULL != pnUnmergedLength )
        {
            // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
            // signed/unsigned 32-bit value.  We do not support length
            // > 0xFFFFFFFF, so cast is ok.

            *pnUnmergedLength = (length_t) ( pUnmergedEnd - pDest );
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

EReconciliation CWbemClass::CanBeReconciledWith(CWbemClass* pNewClass)
{
    try
    {
        return m_CombinedPart.CanBeReconciledWith(pNewClass->m_CombinedPart);
    }
    catch ( CX_MemoryException )
    {
        return e_OutOfMemory;
    }
    catch(...)
    {
        return e_WbemFailed;
    }
}

EReconciliation CWbemClass::ReconcileWith(CWbemClass* pNewClass)
{
    try
    {
        return m_CombinedPart.ReconcileWith(pNewClass->m_CombinedPart);
    }
    catch ( CX_MemoryException )
    {
        return e_OutOfMemory;
    }
    catch(...)
    {
        return e_WbemFailed;
    }
}

// This function should throw an exception in OOM conditions.

HRESULT CWbemClass::CompareMostDerivedClass( CWbemClass* pOldClass )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pOldClass )
    {
        // Allocate buffera for unmerging
        int nNewUnmergeSpace = EstimateUnmergeSpace(),
            nOldUnmergeSpace = pOldClass->EstimateUnmergeSpace();

        // These pointers will clean up when we go out of scope
        LPMEMORY    pbNewUnmerged = new BYTE[ALIGN_FASTOBJ_BLOB(nNewUnmergeSpace)];
        CVectorDeleteMe<BYTE> vdm1( pbNewUnmerged );

        LPMEMORY    pbOldUnmerged = new BYTE[ALIGN_FASTOBJ_BLOB(nOldUnmergeSpace)];
        CVectorDeleteMe<BYTE> vdm2( pbOldUnmerged );

        if (    NULL != pbNewUnmerged
            &&  NULL != pbOldUnmerged )
        {
            // This will give us "most derived" class data

            // Get HRESULTS and return failures here.  Throw exceptions in OOM

            hr = Unmerge( pbNewUnmerged, nNewUnmergeSpace, NULL );

            if ( SUCCEEDED( hr ) )
            {
                hr = pOldClass->Unmerge( pbOldUnmerged, nOldUnmergeSpace, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    CClassAndMethods    mostDerivedClassAndMethods,
                                        testClassAndMethods;

                    // Initializes objects for comparison.  Make sure we specify a number of
                    // properties that will allow the CDataTable member to initialize correctly
                    // so we can get default values.

                    mostDerivedClassAndMethods.SetDataWithNumProps( pbNewUnmerged, NULL,
                        m_CombinedPart.m_ClassPart.m_Properties.GetNumProperties(), NULL );

                    testClassAndMethods.SetDataWithNumProps( pbOldUnmerged, NULL,
                        pOldClass->m_CombinedPart.m_ClassPart.m_Properties.GetNumProperties(),
                        NULL );

                    // Do the comparison
                    EReconciliation eTest = mostDerivedClassAndMethods.CompareTo( testClassAndMethods );

                    // Check for OOM
                    if ( e_OutOfMemory == eTest )
                    {
                        return WBEM_E_OUT_OF_MEMORY;
                    }

                    hr = ( eTest == e_ExactMatch )?WBEM_S_NO_ERROR : WBEM_S_FALSE;
                }
            }
        }   // If both Unmerge buffers allocated
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

    }   // IF NULL != pOldClass

    return hr;
}

HRESULT CWbemClass::CopyBlobOf(CWbemObject* pSource)
{
    try
    {
        CWbemClass* pOther = (CWbemClass*)pSource;

        length_t nLen = pOther->m_CombinedPart.GetLength();
        if(nLen > m_CombinedPart.GetLength())
        {
            // Check for allocation failure
            if ( !ExtendClassAndMethodsSpace(nLen) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        memcpy(m_CombinedPart.GetStart(), pOther->m_CombinedPart.GetStart(), nLen);
        m_CombinedPart.SetData(m_CombinedPart.GetStart(), this, &m_ParentPart);

        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

STDMETHODIMP CWbemClass::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
    // The lower level functions should handle any OOM exceptions, so no
    // need to do it up here.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(pCompareTo == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // IMPORTANT: assumes that the other object was created by us as well.
        // ===================================================================

        CWbemObject* pOther = NULL;
		if ( FAILED( WbemObjectFromCOMPtr( pCompareTo, &pOther ) ) )
		{
			return WBEM_E_INVALID_OBJECT;
		}
		
		// Auto Release
		CReleaseMe	rmObj( (IWbemClassObject*) pOther );

        if( pOther->IsInstance() )
            return WBEM_S_FALSE;

        // Check the standard things first
        // ===============================

        HRESULT hres = CWbemObject::CompareTo(lFlags, pCompareTo);
        if(hres != WBEM_S_NO_ERROR)
            return hres;

        // Compare methods
        // ===============
        hres = m_CombinedPart.m_MethodPart.CompareTo(lFlags,
                                            ((CWbemClass*) pOther)->m_CombinedPart.m_MethodPart);
        return hres;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

BOOL CWbemClass::IsChildOf(CWbemClass* pClass)
{
    // This now reroutes if our class part is localized
    if ( m_ParentPart.m_ClassPart.IsLocalized() )
    {
        // We must perform an exhaustive comparison, filtering out localization data
        EReconciliation eTest = m_ParentPart.m_ClassPart.CompareExactMatch( pClass->m_CombinedPart.m_ClassPart, TRUE );

        if ( e_OutOfMemory == eTest )
        {
            throw CX_MemoryException();
        }

        return ( e_ExactMatch == eTest  );
    }
    
    return m_ParentPart.m_ClassPart.IsIdenticalWith(
                pClass->m_CombinedPart.m_ClassPart);
}

//******************************************************************************
//
//  See fastcls.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::GetLimitedVersion(IN CLimitationMapping* pMap,
                                      NEWOBJECT CWbemClass** ppNewClass)
{
    // Allocate memory for the new object
    // ==================================

    LPMEMORY pBlock = NULL;
    CWbemClass* pNew = NULL;

    try
    {
        pBlock = m_pBlobControl->Allocate(GetLength());

        if ( NULL == pBlock )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memset(pBlock, 0, GetLength());
        LPMEMORY pCurrent = pBlock;
        LPMEMORY pEnd = pBlock + GetLength();

        // Write limited decoration part
        // =============================

        pCurrent = m_DecorationPart.CreateLimitedRepresentation(pMap, pCurrent);
        if(pCurrent == NULL)
        {
            m_pBlobControl->Delete(pBlock);
            return WBEM_E_OUT_OF_MEMORY;
        }

        // We do NOT write a limited parent part.  We just splat the whole
        // thing down

        CopyMemory( pCurrent, m_ParentPart.GetStart(), m_ParentPart.GetLength() );
        pCurrent += m_ParentPart.GetLength();

        BOOL    fRemovedKeysCombined;

        // Write limited combined part, since this is where the property values, etc. will
        // actually be read from.

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  (pEnd - pCurrent)
        // We do not support length > 0xFFFFFFFF, so cast is ok.

        pCurrent = m_CombinedPart.CreateLimitedRepresentation(pMap,
                        (length_t) ( pEnd - pCurrent ), pCurrent, fRemovedKeysCombined);

        if(pCurrent == NULL)
        {
            m_pBlobControl->Delete(pBlock);;
            return WBEM_E_OUT_OF_MEMORY;
        }

        if ( fRemovedKeysCombined )
        {
            CDecorationPart::MarkKeyRemoval(pBlock);
        }

        // Now that we have the memory block for the new class, create the
        // actual class object itself
        // ==================================================================

        pNew = new CWbemClass;

        if ( NULL == pNew )
        {
            m_pBlobControl->Delete(pBlock);;
            return WBEM_E_OUT_OF_MEMORY;
        }

        pNew->SetData(pBlock, GetLength());

        *ppNewClass = pNew;
        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        if ( NULL != pNew )
        {
            delete pNew;
        }

        if ( NULL != pBlock )
        {
            m_pBlobControl->Delete(pBlock);
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        if ( NULL != pNew )
        {
            delete pNew;
        }

        if ( NULL != pBlock )
        {
            m_pBlobControl->Delete(pBlock);
        }

        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CWbemClass::IsKeyLocal( LPCWSTR pwcsKeyProp )
{
    BOOL    fReturn = FALSE;

    // Only do this if we have a property to work with
    if ( NULL != pwcsKeyProp )
    {
        BOOL            fFoundInParent = FALSE;

        // Find the key in the combined class part.  If we find it there
        // and it is keyed, then see if it is keyed in the parent part.
        // If it is not keyed there, then it is keyed locally.

        if ( m_CombinedPart.m_ClassPart.IsPropertyKeyed( pwcsKeyProp ) )
        {
            fReturn = !m_ParentPart.m_ClassPart.IsPropertyKeyed( pwcsKeyProp );
        }

    }   // IF NULL != pKeyProp
    
    return fReturn;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CWbemClass::IsIndexLocal( LPCWSTR pwcsIndexProp )
{
    BOOL    fReturn = FALSE;

    // Only do this if we have a property to work with
    if ( NULL != pwcsIndexProp )
    {
        BOOL            fFoundInParent = FALSE;

        // Find the index in the combined class part.  If we find it there
        // and it is indexed, then see if it is indexed in the parent part.
        // If it is not indexed there, then it is indexed locally.

        if ( m_CombinedPart.m_ClassPart.IsPropertyIndexed( pwcsIndexProp ) )
        {
            fReturn = !m_ParentPart.m_ClassPart.IsPropertyIndexed( pwcsIndexProp );
        }

    }   // IF NULL != pwcsIndexProp
    
    return fReturn;
}

HRESULT CWbemClass::IsValidObj()
{
    HRESULT hres = m_CombinedPart.m_ClassPart.IsValidClassPart();

    if ( FAILED( hres ) )
    {
        return hres;
    }

    return m_CombinedPart.m_MethodPart.IsValidMethodPart();
}

HRESULT CWbemClass::GetDynasty( CVar* pVar )
{
    // We don't do this for Limited Representations
    if ( m_DecorationPart.IsLimited() )
    {
        pVar->SetAsNull();
        return WBEM_NO_ERROR;
    }

    return m_CombinedPart.m_ClassPart.GetDynasty(pVar);
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CWbemClass::IsLocalized( void )
{
    return ( m_ParentPart.m_ClassPart.IsLocalized() ||
            m_CombinedPart.m_ClassPart.IsLocalized() );
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
void CWbemClass::SetLocalized( BOOL fLocalized )
{
    m_CombinedPart.m_ClassPart.SetLocalized( fLocalized );
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::CloneEx( long lFlags, _IWmiObject* pDestObject )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		CWbemClass*	pClassDest = (CWbemClass*) pDestObject;
		LPMEMORY pNewData = NULL;

		// See how big the class is.  If the underlying BLOB is big enough,
		// we'll just splat ourselves into it, if not, it should be reallocated

		BYTE* pMem = NULL;
		CompactAll();

		if ( NULL != pClassDest->GetStart() )
		{
			if(pClassDest->GetLength() < GetLength())
			{
				pMem = pClassDest->Reallocate( GetLength() );
			}
			else
			{
				pMem = pClassDest->GetStart();
			}

		}
		else
		{
			// Oop, we need a new blob
			pMem = m_pBlobControl->Allocate(GetLength());
		}

		// bad
		if(pMem == NULL)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

		// SPLAT! - Code by Onomatopoeia
		memcpy(pMem, GetStart(), GetLength());

		pClassDest->SetData(pMem, GetLength());

		return WBEM_S_NO_ERROR;;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
HRESULT CWbemClass::CopyInstanceData( long lFlags, _IWmiObject* pSourceInstance )
{
	return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Checks if the current object is a child of the specified class (i.e. is Instance of,
// or is Child of )
STDMETHODIMP CWbemClass::IsParentClass( long lFlags, _IWmiObject* pClass )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		CLock	lock(this);

		return ( IsChildOf( (CWbemClass*) pClass ) ? WBEM_S_NO_ERROR : WBEM_S_FALSE );

	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Compares the derived most class information of two class objects.
STDMETHODIMP CWbemClass::CompareDerivedMostClass( long lFlags, _IWmiObject* pClass )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		CLock	lock(this);

		CWbemClass*	pObj = NULL;

		HRESULT	hr = WbemObjectFromCOMPtr( pClass, (CWbemObject**) &pObj );
		CReleaseMe	rm( (_IWmiObject*) pObj );

		if ( SUCCEEDED( hr ) )
		{
			hr = CompareMostDerivedClass( pObj );
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Creates a limited representation class for projection queries
STDMETHODIMP CWbemClass::GetClassSubset( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass )
{
	try
	{
		// Can't do this if we already have a limitation mapping.
		// This means that we're already limited.

		if ( NULL != m_pLimitMapping || IsLimited() )
		{
			return WBEM_E_INVALID_OPERATION;
		}

		HRESULT	hr = WBEM_S_NO_ERROR;

		// Create a new mapping
		CLimitationMapping*	pMapping = new CLimitationMapping;

		if ( NULL != pMapping )
		{
			// Initialize the new mapping
			CWStringArray	wstrPropArray;

			for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumNames; dwCtr++ )
			{
				if ( wstrPropArray.Add( pPropNames[dwCtr] ) != CWStringArray::no_error )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}

			if ( SUCCEEDED( hr ) )
			{

				// Initialize the map
				if ( MapLimitation( 0L, &wstrPropArray, pMapping ) )
				{
					CWbemClass*	pClass = NULL;

					// Now pony up a limited version
					hr = GetLimitedVersion( pMapping, &pClass );

					if ( SUCCEEDED( hr ) )
					{
						// New class is good to go
						pClass->m_pLimitMapping = pMapping;
						*pNewClass = (_IWmiObject*) pClass;
					}
				}
				else
				{
					// ??? Need to check appropriateness of this
					hr = WBEM_E_FAILED;
				}
			}

			if ( FAILED( hr ) )
			{
				delete pMapping;
			}
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Creates a limited representation instance for projection queries
// "this" _IWmiObject must be a limited class
STDMETHODIMP CWbemClass::MakeSubsetInst( _IWmiObject *pInstance, _IWmiObject** pNewInstance )
{
	try
	{
		CWbemInstance*	pRealInstance = NULL;

		HRESULT	hr = pInstance->_GetCoreInfo( 0L, (void**) &pRealInstance );
		CReleaseMe	rm( (_IWmiObject*) pRealInstance );

		// Can't do this if we don't have a limitation mapping, or the instance
		// is already limited

		if ( NULL != m_pLimitMapping && !pRealInstance->IsLimited() )
		{
			CWbemInstance*	pInst = NULL;

			hr = pRealInstance->GetLimitedVersion( m_pLimitMapping, &pInst );

			if ( SUCCEEDED( hr ) )
			{
				*pNewInstance = (_IWmiObject*) pInst;
			}

		}
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Merges a blob with the current object memory and creates a new object
STDMETHODIMP CWbemClass::Merge( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj )
{
	try
	{
		// Flags must be valid and pbData must be valid
		if ( !( WMIOBJECT_MERGE_FLAG_CLASS == lFlags || WMIOBJECT_MERGE_FLAG_INSTANCE == lFlags ) || NULL == pbData )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		if ( WMIOBJECT_MERGE_FLAG_CLASS == lFlags )
		{
			CWbemClass*	pClass = CWbemClass::CreateFromBlob( this, (LPBYTE) pbData );
			*ppNewObj = pClass;
		}
		else
		{
			CWbemInstance*	pInstance = CWbemInstance::CreateFromBlob( this, (LPBYTE) pbData );
			*ppNewObj = pInstance;
		}

		return WBEM_S_NO_ERROR;
	}

	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
// is specified this will only perform a test
STDMETHODIMP CWbemClass::ReconcileWith( long lFlags, _IWmiObject* pNewObj )
{
	try
	{
		// Get rid of invalid parameters now
		if ( NULL == pNewObj || ( 0L != lFlags && lFlags & ~WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE ) )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		CWbemClass*	pObj = NULL;

		HRESULT	hr = WbemObjectFromCOMPtr( pNewObj, (CWbemObject**) &pObj );
		CReleaseMe	rm( (_IWmiObject*) pObj );

		if ( SUCCEEDED( hr ) )
		{
			EReconciliation eRecon = CanBeReconciledWith( pObj );
			if ( eRecon == e_Reconcilable && lFlags != WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE )
			{
				eRecon = ReconcileWith( pObj );
			}

			if (eRecon == e_OutOfMemory)
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			else if ( eRecon != e_Reconcilable )
			{
				hr = WBEM_E_FAILED;
			}

		}	// IF Got a pointer

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Upgrades class and instance objects
STDMETHODIMP CWbemClass::Upgrade( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		HRESULT	hr = WBEM_S_NO_ERROR;

		// If the new parent class is NULL, then we need to create a new empty class we will
		// upgrade from (basically we will create a new base class to which the values
		// of the current class will be applied

		CWbemClass*	pParentClassObj = NULL;

		if ( NULL == pNewParentClass )
		{
			pParentClassObj = new CWbemClass;

			if ( NULL != pParentClassObj )
			{
				hr = pParentClassObj->InitEmpty();

				if ( FAILED( hr ) )
				{
					delete pParentClassObj;
					pParentClassObj = NULL;
				}

			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
		else
		{
			hr = WbemObjectFromCOMPtr( pNewParentClass, (CWbemObject**) &pParentClassObj );
		}

		CReleaseMe	rm((_IWmiObject*) pParentClassObj);

		if ( SUCCEEDED( hr ) )
		{
			hr = pParentClassObj->Update( this, WBEM_FLAG_UPDATE_FORCE_MODE, (CWbemClass**) ppNewChild );
		}

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Updates derived class object using the safe/force mode logic
STDMETHODIMP CWbemClass::Update( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass )
{
	if  ( ( lFlags != WBEM_FLAG_UPDATE_FORCE_MODE && lFlags != WBEM_FLAG_UPDATE_SAFE_MODE ) ||
			NULL == pOldChildClass )	
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CLock	lock( this );

	CWbemClass*	pOldChild = NULL;

	HRESULT	hr = WbemObjectFromCOMPtr( pOldChildClass, (CWbemObject**) &pOldChild );;
	CReleaseMe	rm((_IWmiObject*) pOldChild);

	if ( SUCCEEDED( hr ) )
	{
		CWbemClass*	pNewChild = NULL;

		hr = Update( pOldChild, lFlags, &pNewChild );

		if ( SUCCEEDED( hr ) )
		{
			*ppNewChildClass = (_IWmiObject*) pNewChild;
		}
	}

	return hr;
}

STDMETHODIMP CWbemClass::SpawnKeyedInstance( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst )
{
    // Validate parameters
    // ===================

    if( NULL == pwszPath || NULL == ppInst || 0L != lFlags )
        return WBEM_E_INVALID_PARAMETER;

    // Parse the path
    // ==============
    ParsedObjectPath* pOutput = 0;

    CObjectPathParser p;
    int nStatus = p.Parse((LPWSTR)pwszPath,  &pOutput);

    if (nStatus != 0 || !pOutput->IsInstance())
    {
        // Cleanup the output pointer if it was allocated
        if ( NULL != pOutput )
        {
            p.Free(pOutput);
        }

        return WBEM_E_INVALID_OBJECT_PATH;
    }

    // Spawn and fill the instance
    // ===========================

    _IWmiObject* pInst = NULL;
    HRESULT	hres = SpawnInstance(0, (IWbemClassObject**) &pInst);
	CReleaseMe	rmInst( pInst );

	// Enumerate the keys and fill out the properties
    for(DWORD i = 0; i < pOutput->m_dwNumKeys; i++)
    {
        KeyRef* pKeyRef = pOutput->m_paKeys[i];

        WString wsPropName;
        if(pKeyRef->m_pName == NULL)
        {
            // No key name --- get the key.
            // ============================

            CWStringArray awsKeys;
            ((CWbemInstance*)pInst)->GetKeyProps(awsKeys);
            if(awsKeys.Size() != 1)
            {
                pInst->Release();
                p.Free(pOutput);
                return WBEM_E_INVALID_OBJECT;
            }
            wsPropName = awsKeys[0];
        }
        else wsPropName = pKeyRef->m_pName;

        // Compute variant type of the property
        // ====================================

        CIMTYPE ctPropType;
        hres = pInst->Get(wsPropName, 0, NULL, &ctPropType, NULL);
        if(FAILED(hres))
        {
            pInst->Release();
            p.Free(pOutput);
            return WBEM_E_INVALID_PARAMETER;
        }

        VARTYPE vtVariantType = CType::GetVARTYPE(ctPropType);

        // Set the value into the instance
        // ===============================

        if(vtVariantType != V_VT(&pKeyRef->m_vValue))
        {
            hres = VariantChangeType(&pKeyRef->m_vValue, &pKeyRef->m_vValue, 0,
                        vtVariantType);
        }
        if(FAILED(hres))
        {
            pInst->Release();
            p.Free(pOutput);
            return WBEM_E_INVALID_PARAMETER;
        }

        hres = pInst->Put(wsPropName, 0, &pKeyRef->m_vValue, 0);
        if(FAILED(hres))
        {
            pInst->Release();
            p.Free(pOutput);
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    // Caller must free this guy up
    *ppInst = pInst;
	pInst->AddRef();

    // Cleanup the output pointer if it was allocated
    p.Free(pOutput);

    return hres;
}

// Returns the parent class name from a BLOB
STDMETHODIMP CWbemClass::GetParentClassFromBlob( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass )
{
	if ( NULL == pbData || NULL == pbstrParentClass )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	// We only support retrieving parent class information from unmerged class Blobs
	if ( WMIOBJECT_MERGE_FLAG_CLASS == lFlags )
	{
		// Use the static method to get the info
		WString	wsSuperclassName;

		hr = CClassAndMethods::GetSuperclassName( wsSuperclassName, (LPMEMORY) pbData );

		if ( SUCCEEDED( hr ) )
		{
			*pbstrParentClass = SysAllocString( wsSuperclassName );

			if ( NULL == *pbstrParentClass )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}

	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\enummrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    ENUMMRSH.H

Abstract:

    Object Enumerator Marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include "wbemclasscache.h"
#include "wbemclasstoidmap.h"
#include "smartnextpacket.h"
#include "mrshbase.h"

//***************************************************************************
//
//  class CEnumFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CEnumFactoryBuffer : public CUnkInternal
{

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XEnumFactory : public CImpl<IPSFactoryBuffer, CEnumFactoryBuffer>
    {
    public:
        XEnumFactory(CEnumFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CEnumFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XEnumFactory;
public:
    CEnumFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_XEnumFactory(this), m_pLifeControl( pControl )
    {
    }
    ~CEnumFactoryBuffer()
    {
    }

    void* GetInterface(REFIID riid);

	friend XEnumFactory;

};


//***************************************************************************
//
//  class CEnumProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CEnumProxyBuffer : public CBaseProxyBuffer
{
private:
	IEnumWbemClassObject*	m_pOldProxyEnum;
    CWbemClassToIdMap		m_ClassToIdMap;
    BOOL					m_fTriedSmartEnum;
    BOOL					m_fUseSmartEnum;
	HANDLE					m_hSmartNextMutex;
	GUID					m_guidSmartEnum;
	IWbemWCOSmartEnum*		m_pSmartEnum;
	CRITICAL_SECTION		m_cs;

protected:
    class XEnumFacelet : public IEnumWbemClassObject, IClientSecurity
    {
    protected:
        CEnumProxyBuffer*	m_pObject;
        CWbemClassCache		m_ClassCache;

    public:
        XEnumFacelet(CEnumProxyBuffer* pObject) : m_pObject(pObject){};
        ~XEnumFacelet(){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

		// IEnumWbemClassObject Methods

		STDMETHOD(Reset)();
		STDMETHOD(Next)(long lTimeout, ULONG uCount,  
			IWbemClassObject** apObj, ULONG FAR* puReturned);
		STDMETHOD(NextAsync)(ULONG uCount, IWbemObjectSink* pSink);
		STDMETHOD(Clone)(IEnumWbemClassObject** pEnum);
		STDMETHOD(Skip)(long lTimeout, ULONG nNum);

		// IClientSecurity Methods
		STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
			OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
			void** pAuthInfo, DWORD* pCapabilities );
		STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
			OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
			void* pAuthInfo, DWORD Capabilities );
		STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XEnumFacelet;
    friend XEnumFacelet;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

	// Initialize the smart enumerator
	HRESULT InitSmartEnum( BOOL fSetBlanket = FALSE, DWORD AuthnSvc = RPC_C_AUTHN_WINNT,
			DWORD AuthzSvc = RPC_C_AUTHZ_NONE, OLECHAR* pServerPrincName = NULL,
			DWORD AuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT, DWORD ImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE,
			void* pAuthInfo = NULL, DWORD Capabilities = EOAC_NONE );

public:
    CEnumProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CEnumProxyBuffer();
};

//***************************************************************************
//
//  class CEnumStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CEnumStubBuffer : public CBaseStubBuffer
{
protected:
    class XEnumStublet : public CBaseStublet
    {
        IWbemObjectSink* m_pServer;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

    public:
        XEnumStublet(CEnumStubBuffer* pObj);
        ~XEnumStublet();

        friend CEnumStubBuffer;
    } m_XEnumStublet;
    friend XEnumStublet;

public:
    CEnumStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer(pControl, pUnkOuter), m_XEnumStublet(this)
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\context.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CONTEXT.CPP

Abstract:

    CWbemContext Implementation

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "context.h"
#include <corex.h>
#include <algorithm>
#include <helper.h>
#include <fastobj.h>

#define MAX_VARIANT_SIZE 8 // sizeof UINT64

DWORD GetBSTRMarshalSize(BSTR str)
{
    return wcslen(str)*2 + sizeof(long);
}

HRESULT MarshalBSTR(IStream* pStream, BSTR str)
{
    HRESULT hres;
    long lLen = wcslen(str);
    hres = pStream->Write((void*)&lLen, sizeof(lLen), NULL);
    if(FAILED(hres)) return hres;
    return pStream->Write((void*)str, lLen*2, NULL);
}

auto_bstr UnmarshalBSTR (IStream* pStream,DWORD & dwStreamSize)
{
  long lLen;
  
  HRESULT hres;
  hres = pStream->Read((void*)&lLen, sizeof(lLen), NULL);
  _com_util::CheckError (hres);
  dwStreamSize -= sizeof(lLen);

  if ((lLen*2) > dwStreamSize ) throw CX_Exception();
  
  auto_bstr str (SysAllocStringLen (NULL, lLen));
  if (str.get() == NULL && lLen !=0)
    throw CX_MemoryException();
  hres = pStream->Read((void*)str.get(), lLen*2, NULL);
  _com_util::CheckError (hres);

  dwStreamSize -= (lLen*2);
  
  str.get()[lLen] = 0;
  return str;
}

HRESULT UnmarshalBSTR(IStream* pStream, BSTR& str,DWORD & dwStreamSize)
{
    long lLen;
    HRESULT hres;
    hres = pStream->Read((void*)&lLen, sizeof(lLen), NULL);
    if(FAILED(hres)) return hres;

    dwStreamSize -= sizeof(lLen);

    if ((lLen*2) > dwStreamSize) return E_FAIL;

    str = SysAllocStringLen(NULL, lLen);
	if (!str)
		return WBEM_E_OUT_OF_MEMORY;
    hres = pStream->Read((void*)str, lLen*2, NULL);
    if(FAILED(hres)) 
    {
        SysFreeString(str);
        return hres;
    }

    dwStreamSize -= (lLen*2);

    str[lLen] = 0;
    return S_OK;
}

DWORD GetSafeArrayMarshalSize(VARTYPE vt, SAFEARRAY* psa)
{
    HRESULT hres;

    DWORD dwLen = sizeof(long)*2; // num elements and size of element

    // Compute vital statistics
    // ========================

    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    long lNumElements = lUBound - lLBound + 1;
    DWORD dwElemSize = SafeArrayGetElemsize(psa);

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    CUnaccessMe um(psa);

    if(vt == VT_BSTR)
    {
        // Add all BSTR sizes
        // ==================

        BSTR* pstrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            dwLen += GetBSTRMarshalSize(pstrData[i]);
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            DWORD dwThis = 0;
            hres = CoGetMarshalSizeMax(&dwThis, IID_IWbemClassObject, 
                                apObjects[i], 
                                MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            if(FAILED(hres)) return hres;
            dwLen += dwThis;
        }
    }
    else
    {
        dwLen += lNumElements*dwElemSize;
    }

    return dwLen;
}
    

HRESULT MarshalSafeArray(IStream* pStream, VARTYPE vt, SAFEARRAY* psa)
{
    HRESULT hres;

    // First, write the number of elements
    // ===================================

    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    long lNumElements = lUBound - lLBound + 1;

    hres = pStream->Write((void*)&lNumElements, sizeof(lNumElements), NULL);
    if(FAILED(hres)) return hres;

    // Second, write element size
    // ==========================

    DWORD dwElemSize = SafeArrayGetElemsize(psa);
    hres = pStream->Write((void*)&dwElemSize, sizeof(dwElemSize), NULL);
    if(FAILED(hres)) return hres;

    // Now, write all the elements out
    // ===============================

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    CUnaccessMe um(psa);

    if(vt == VT_BSTR)
    {
        BSTR* astrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            MarshalBSTR(pStream, astrData[i]);
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            hres = CoMarshalInterface(pStream, IID_IWbemClassObject, 
                           apObjects[i], MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            if(FAILED(hres)) return hres;
        }
    }
    else
    {
        // Just dump the data
        // ==================

        hres = pStream->Write((void*)pData, dwElemSize*lNumElements, NULL);
        if(FAILED(hres)) return hres;
    }

    return S_OK;
}


HRESULT UnmarshalSafeArray(IStream* pStream, 
	                       VARTYPE vt, 
	                       SAFEARRAY*& psa,
	                       DWORD & dwStreamSize)
{
    HRESULT hres;

    // Read the number of elements
    // ===========================

    long lNumElements;
    hres = pStream->Read((void*)&lNumElements, sizeof(lNumElements), NULL);
    if(FAILED(hres)) return hres;
    dwStreamSize -= sizeof(lNumElements);
    
    // Read the size of an element
    // ===========================

    DWORD dwElemSize;
    hres = pStream->Read((void*)&dwElemSize, sizeof(dwElemSize), NULL);
    if(FAILED(hres)) return hres;
    dwStreamSize -= sizeof(dwElemSize);
    
    // Create the appropriate SafeArray
    // ================================

    SAFEARRAYBOUND sab;
    sab.lLbound = 0;
    sab.cElements = lNumElements;

    psa = SafeArrayCreate(vt, 1, &sab);
    if(psa == NULL) return E_FAIL;
    OnDeleteIf<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayDestroy> desme(psa);

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    OnDelete<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayUnaccessData> um(psa);

    
    if(vt == VT_BSTR)
    {
        // Read all the BSTRs
        // ==================

        BSTR* astrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            hres = UnmarshalBSTR(pStream, astrData[i], dwStreamSize);
            if (FAILED(hres)) return hres;
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        // Read all the objects
        // ====================

        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            hres = CoUnmarshalInterface(pStream, IID_IWbemClassObject, 
                           (void**)(apObjects + i));
            if(FAILED(hres)) return hres;
        } 
        
        STATSTG StatStg;
        if (FAILED(hres = pStream->Stat(&StatStg,STATFLAG_DEFAULT))) return hres;
        
		LARGE_INTEGER li; li.QuadPart = 0;
		ULARGE_INTEGER Position;
		hres = pStream->Seek(li,STREAM_SEEK_CUR,&Position);
		
		dwStreamSize = StatStg.cbSize.LowPart - Position.LowPart; 
    }
    else
    {
        // Read the block
        // ==============
        UINT ExpectedElemSize = SafeArrayGetElemsize(psa);
        if (ExpectedElemSize != dwElemSize) return E_FAIL;

        ULONG TotRead = dwElemSize*lNumElements;
        if (TotRead > dwStreamSize ) return E_FAIL;
        
        hres = pStream->Read((void*)pData,TotRead , NULL);
        if(FAILED(hres)) return hres;
        dwStreamSize -= TotRead;
    }
    desme.dismiss();
    return S_OK;
}
        

CWbemContext::CContextObj::CContextObj(LPCWSTR wszName, 
				       long lFlags, 
                                       VARIANT* pvValue)
    : m_lFlags(lFlags), m_strName (clone (wszName)), m_vValue (pvValue)
{
}

CWbemContext::CContextObj::CContextObj(const CContextObj& Obj)
    : m_lFlags(Obj.m_lFlags), m_strName (clone (Obj.m_strName.get ())), m_vValue (Obj.m_vValue)
{
}
    
CWbemContext::CContextObj::CContextObj(IStream* pStream,DWORD & dwStreamSize)
{
  HRESULT hres;
  // Read the name
  // =============
  m_strName = UnmarshalBSTR (pStream,dwStreamSize);

  // Read the flags
  // ==============
  hres = pStream->Read((void*)&m_lFlags, sizeof(m_lFlags), NULL);
  _com_util::CheckError (hres);

  dwStreamSize -= sizeof(m_lFlags);

  // Read the VARTYPE
  // ================
  VARIANT Var;

  hres = pStream->Read((void*)&(V_VT(&Var)), sizeof(VARTYPE), NULL);
  _com_util::CheckError (hres);

  dwStreamSize -= sizeof(VARTYPE);

  // Read the data
  // =============

  switch(V_VT(&Var))
  {
  case VT_NULL:
      break;
  case VT_BSTR:
      hres = UnmarshalBSTR(pStream, V_BSTR(&Var),dwStreamSize);
      break;
  case VT_EMBEDDED_OBJECT:
      hres = CoUnmarshalInterface(pStream, 
      	                          IID_IWbemClassObject, 
			                      (void**)&V_EMBEDDED_OBJECT(&Var));
      if (SUCCEEDED(hres))
      {
          STATSTG StatStg;
          _com_util::CheckError(pStream->Stat(&StatStg,STATFLAG_DEFAULT));
      
          LARGE_INTEGER li; li.QuadPart = 0;
          ULARGE_INTEGER Position;
          hres = pStream->Seek(li,STREAM_SEEK_CUR,&Position);
          
          dwStreamSize = StatStg.cbSize.LowPart - Position.LowPart; 
      }
      break;
  default:
	  if ( ( V_VT(&Var) & ~VT_ARRAY ) == VT_DISPATCH )
	  {
		  V_VT(&Var) = VT_EMPTY;
		  throw CX_ContextMarshalException();
	  }
      else if(V_VT(&Var) & VT_ARRAY)
      {
	  hres = UnmarshalSafeArray(pStream, 
	  	                        V_VT(&Var) & ~VT_ARRAY,
			                    V_ARRAY(&Var),
			                    dwStreamSize);
      }
      else
      {
    	  hres = pStream->Read(&V_UI1(&Var), MAX_VARIANT_SIZE, NULL);
	      dwStreamSize -= MAX_VARIANT_SIZE;
      }
      break;
  }
  _com_util::CheckError (hres);

  m_vValue.Attach(Var);
}


CWbemContext::CContextObj::~CContextObj()
{
}
    
int CWbemContext::CContextObj::legalTypes[]={ VT_NULL, VT_I2, VT_I4, VT_R4, VT_R8,
					      VT_BSTR, VT_BOOL, VT_UNKNOWN, VT_I1, 
					      VT_UI1, VT_UI2, VT_UI4 };

bool 
CWbemContext::CContextObj::supportedType(const VARIANT& var)
{
  const size_t size = sizeof(legalTypes)/sizeof(legalTypes[0]);
  return (std::find(legalTypes, legalTypes+size, V_VT(&var) & ~VT_ARRAY) != (legalTypes+size));
}


HRESULT CWbemContext::CContextObj::GetMarshalSizeMax( DWORD* pdwSize )
{
    // First, the name
    // ===============

    DWORD dwLength = GetBSTRMarshalSize(m_strName.get ());

    // Then the flags
    // ==============

    dwLength += sizeof(m_lFlags);

    // Then the VARTYPE
    // ================

    dwLength += sizeof(VARTYPE);

    // Then the actual data
    // ====================

    switch(V_VT(&m_vValue))
    {
    case VT_NULL:
        break;
    case VT_BSTR:
        dwLength += GetBSTRMarshalSize(V_BSTR(&m_vValue));
        break;
    case VT_EMBEDDED_OBJECT:
        {
            DWORD dwThis = 0;
            CoGetMarshalSizeMax(&dwThis, IID_IWbemClassObject, 
                                V_EMBEDDED_OBJECT(&m_vValue), 
                                MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            dwLength += dwThis;
        }
        break;
    default:

		// We will not allow VT_DISPATCH to marshal as it can cause
		// a crash
		if ( ( V_VT( &m_vValue ) & ~VT_ARRAY ) == VT_DISPATCH )
		{
			return E_FAIL;
		}
        else if(V_VT(&m_vValue) & VT_ARRAY)
        {
            dwLength += GetSafeArrayMarshalSize(V_VT(&m_vValue) & ~VT_ARRAY,
                                                V_ARRAY(&m_vValue));
        }
        else
        {
            dwLength += MAX_VARIANT_SIZE;
        }
    }

	*pdwSize = dwLength;

    return WBEM_S_NO_ERROR;
}
            
HRESULT CWbemContext::CContextObj::Marshal(IStream* pStream)
{
    HRESULT hres;  

    // Write the name
    // ==============
    hres = MarshalBSTR(pStream, m_strName.get());
    if (FAILED (hres)) return hres;
    // Write the flags
    // ===============

    hres = pStream->Write((void*)&m_lFlags, sizeof(m_lFlags), NULL);
    if (FAILED (hres)) return hres;
    // Write the VARTYPE
    // =================

    hres = pStream->Write((void*)&V_VT(&m_vValue), sizeof(VARTYPE), NULL);
    if (FAILED (hres)) return hres;

    // Write the data
    // ==============

    switch(V_VT(&m_vValue))
    {
    case VT_NULL:
        break;
    case VT_BSTR:
        hres = MarshalBSTR(pStream, V_BSTR(&m_vValue));
        break;
    case VT_EMBEDDED_OBJECT:
        hres = CoMarshalInterface(pStream, IID_IWbemClassObject, 
                           V_EMBEDDED_OBJECT(&m_vValue), 
                           MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
        break;
    default:
		// We will not allow VT_DISPATCH to marshal as it can cause
		// a crash
		if ( ( V_VT( &m_vValue ) & ~VT_ARRAY ) == VT_DISPATCH )
		{
			return E_FAIL;
		}
        else if(V_VT(&m_vValue) & VT_ARRAY)
        {
            hres = MarshalSafeArray(pStream, V_VT(&m_vValue) & ~VT_ARRAY,
                                V_ARRAY(&m_vValue));
        }
        else
        {
            hres = pStream->Write(&V_UI1(&m_vValue), MAX_VARIANT_SIZE, NULL);
        }
        break;
    }

    return hres;
}

CWbemContext::CWbemContext(CLifeControl* pControl) 
    : m_lRef(0), m_dwCurrentIndex(0xFFFFFFFF), m_lNumChildren(0),
        m_lNumParents(0), m_lNumSiblings(0), m_pControl( pControl )
{
    m_dwNumRequests = 1;
    m_aRequests = new GUID;

	if ( NULL == m_aRequests )
	{
		throw CX_MemoryException();
	}

    AssignId();

    m_pControl->ObjectCreated((IWbemContext*)this);
}

CWbemContext::CWbemContext(const CWbemContext& Other, DWORD dwExtraSpace) 
    : m_lRef(0), m_dwCurrentIndex(0xFFFFFFFF), m_lNumChildren(0),
        m_lNumParents(0), m_lNumSiblings(0), m_pControl(Other.m_pControl)
{
    // Copy data
    // =========

    for(int i = 0; i < Other.m_aObjects.GetSize(); i++)
    {
      CContextObj* pObj = new CContextObj(*Other.m_aObjects[i]);
      
      if (NULL == pObj || m_aObjects.Add( pObj ) == -1)
       	{
	delete pObj;
        throw CX_MemoryException();
	}
    }

    // Allocate causality string
    // =========================

    m_dwNumRequests = Other.m_dwNumRequests + dwExtraSpace;
    m_aRequests = new GUID[m_dwNumRequests];

    if ( NULL == m_aRequests )
      {
      throw CX_MemoryException();
      }

    // Copy the current string, leaving space
    // ======================================

    if(Other.m_dwNumRequests > 0)
    {
        memcpy(m_aRequests + dwExtraSpace, Other.m_aRequests, 
            Other.m_dwNumRequests * sizeof(GUID));
    }

    m_pControl->ObjectCreated((IWbemContext*)this);
}

CWbemContext::~CWbemContext()
{
    delete [] m_aRequests;
    m_pControl->ObjectDestroyed((IWbemContext*)this);
}

STDMETHODIMP CWbemContext::CreateChild(IWbemCausalityAccess** ppChild)
{
    CInCritSec ics(&m_cs);

	try
	{
		CWbemContext* pNewCtx = new CWbemContext(*this, 1);

		if ( NULL == pNewCtx )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

		pNewCtx->AssignId();
		pNewCtx->m_lNumSiblings = m_lNumSiblings + m_lNumChildren;
		pNewCtx->m_lNumParents = m_lNumParents + 1;

		m_lNumChildren++;
		return pNewCtx->QueryInterface(IID_IWbemCausalityAccess, (void**)ppChild);
	}
	catch ( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

STDMETHODIMP CWbemContext::GetRequestId(GUID* pId)
{
    CInCritSec ics(&m_cs);

    if(m_dwNumRequests == 0)
    {
        *pId = GUID_NULL;
        return S_FALSE;
    }
    else
    {
        *pId = m_aRequests[0];
        return S_OK;
    }
}

STDMETHODIMP CWbemContext::GetParentId(GUID* pId)
{
    CInCritSec ics(&m_cs);

    if(m_dwNumRequests < 2)
    {
        *pId = GUID_NULL;
        return S_FALSE;
    }
    else
    {
        *pId = m_aRequests[1];
        return S_OK;
    }
}

STDMETHODIMP CWbemContext::IsChildOf(GUID Id)
{
    CInCritSec ics(&m_cs);

    for(DWORD dw = 0; dw < m_dwNumRequests; dw++)
    {
        if(m_aRequests[dw] == Id)
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CWbemContext::GetHistoryInfo(long* plNumParents, 
                                            long* plNumSiblings)
{
    CInCritSec ics(&m_cs);

    *plNumParents = m_lNumParents;
    *plNumSiblings = m_lNumSiblings;
    return S_OK;
}

void CWbemContext::AssignId()
{
    CInCritSec ics(&m_cs);

    CoCreateGuid(m_aRequests);
}

DWORD CWbemContext::FindValue(LPCWSTR wszIndex)
{
  for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        if(!wbem_wcsicmp(wszIndex, m_aObjects[i]->m_strName.get()))
        {
            return i;
        }
    }
    return 0xFFFFFFFF;
}

STDMETHODIMP CWbemContext::QueryInterface(REFIID riid, void** ppv)
{
  if (ppv == 0)
    return E_POINTER;

  if (riid == IID_IUnknown || riid == IID_IWbemContext)
    {
        *ppv = static_cast<IWbemContext*>(this);
    }
  else if (riid == IID_IMarshal)
    {
        *ppv = static_cast<IMarshal*>(this);
    }
  else if (riid == IID_IWbemCausalityAccess)
    {
        *ppv = static_cast<IWbemCausalityAccess*>(this);
    }
  else
    {
      *ppv = NULL;
      return E_NOINTERFACE;
    };
  reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  return S_OK;
}
    


STDMETHODIMP CWbemContext::Clone(IWbemContext** ppCopy)
{
    if ( NULL == ppCopy )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CInCritSec ics(&m_cs);

	try
	{
		*ppCopy = new CWbemContext(*this);

		if ( NULL == *ppCopy )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

		(*ppCopy)->AddRef();
		return WBEM_S_NO_ERROR;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

STDMETHODIMP CWbemContext::GetNames(long lFlags, SAFEARRAY** pNames)
{
  HRESULT hres = WBEM_S_NO_ERROR;  
  CInCritSec ics(&m_cs);

    SAFEARRAYBOUND sab;
    if(lFlags != 0 || !pNames)
        return WBEM_E_INVALID_PARAMETER;
    sab.cElements = m_aObjects.GetSize();
    sab.lLbound = 0;
    
    SAFEARRAY* names = SafeArrayCreate(VT_BSTR, 1, &sab);
    
    if (names == 0) return WBEM_E_OUT_OF_MEMORY ;
    
    for(long i = 0; i < m_aObjects.GetSize(); i++)
    {
        if (FAILED (hres = SafeArrayPutElement(names, &i, m_aObjects[i]->m_strName.get())))
	    break;
    }

    if ( SUCCEEDED (hres))
      *pNames = names;
    else
      {
      SafeArrayDestroy(names);
      return WBEM_E_OUT_OF_MEMORY;
      }
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::BeginEnumeration(long lFlags)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;
    if(m_dwCurrentIndex != 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;
    m_dwCurrentIndex = 0;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::Next(long lFlags, BSTR* pName, VARIANT* pVal)
{
  HRESULT hres = S_OK;  
  CInCritSec ics(&m_cs);

    if(lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;
    if(m_dwCurrentIndex == 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;

    if(m_dwCurrentIndex >= m_aObjects.GetSize())
        return WBEM_S_NO_MORE_DATA;
    
    
    if(pName)
    {
        *pName = SysAllocString(m_aObjects[m_dwCurrentIndex]->m_strName.get());
	if (*pName == 0 && m_aObjects[m_dwCurrentIndex]->m_strName.get() != 0)
	  {
	  return WBEM_E_OUT_OF_MEMORY;
	  }
    }

    
    VARIANT local;
    
    VariantInit (&local);
    hres = VariantCopy (&local, &m_aObjects[m_dwCurrentIndex]->m_vValue);
    
    if (SUCCEEDED (hres))
      {
      memcpy(pVal, &local, sizeof(local));
      V_VT(&local) = VT_EMPTY;
      m_dwCurrentIndex++;
      }
    else
      return WBEM_E_OUT_OF_MEMORY;

    return hres;
}

STDMETHODIMP CWbemContext::EndEnumeration()
{
    CInCritSec ics(&m_cs);

    if(m_dwCurrentIndex == 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;
    m_dwCurrentIndex = 0xFFFFFFFF;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::SetValue(LPCWSTR NameIndex, long lFlags, 
                                    VARIANT* pValue)
{
    CInCritSec ics(&m_cs);

    // These are all invalid parameters
    if( lFlags != 0 || NULL == NameIndex || NULL == pValue)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	// Removed VT validation as it is causing too many problems for scripting.
/*
    if (CContextObj::supportedType(*pValue) == false)
      {
	return WBEM_E_INVALID_PARAMETER;
      }
*/

    DWORD dwIndex = FindValue(NameIndex);
    
    try{
      if(dwIndex == 0xFFFFFFFF)
      {
	CContextObj * newEntry = new CContextObj(NameIndex, lFlags, pValue);
	if (newEntry == 0 || m_aObjects.Add (newEntry) == -1)
	  {
	  delete newEntry;
	  return WBEM_E_OUT_OF_MEMORY;
	  }
      }
      else
      {
	  CContextObj* pObj = m_aObjects[dwIndex];
	  pObj->m_vValue = *pValue;
	  pObj->m_lFlags = lFlags;
      }
    }
    catch(...)
    {
      return WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}
        
STDMETHODIMP CWbemContext::GetValue(LPCWSTR NameIndex, long lFlags, 
                                    VARIANT* pValue)
{
  HRESULT hres = WBEM_S_NO_ERROR;
  
  CInCritSec ics(&m_cs);

    if(lFlags != 0 || NameIndex == NULL || pValue == NULL)
        return WBEM_E_INVALID_PARAMETER;
    DWORD dwIndex = FindValue(NameIndex);
    if(dwIndex == 0xFFFFFFFF)
        return WBEM_E_NOT_FOUND;

    VARIANT local;
    
    VariantInit (&local);
    hres = VariantCopy (&local, &m_aObjects[dwIndex]->m_vValue);
    
    if (SUCCEEDED (hres))
      {
      memcpy(pValue, &local, sizeof(local));
      V_VT(&local) = VT_EMPTY;
      return S_OK;
      }
    return hres;
}
    
STDMETHODIMP CWbemContext::DeleteValue(LPCWSTR NameIndex, long lFlags)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0 || NameIndex == NULL)
        return WBEM_E_INVALID_PARAMETER;
    DWORD dwIndex = FindValue(NameIndex);
    if(dwIndex == 0xFFFFFFFF)
    {
        return WBEM_S_FALSE;
    }

    m_aObjects.RemoveAt(dwIndex);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::DeleteAll()
{
    CInCritSec ics(&m_cs);

    m_aObjects.RemoveAll();
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::MakeSpecial()
{
    CInCritSec ics(&m_cs);

    // Make the ID of this context NULL
    // ================================

    m_aRequests[0] = CLSID_NULL;
    return S_OK;
}

STDMETHODIMP CWbemContext::IsSpecial()
{
    CInCritSec ics(&m_cs);

    // Check if the first GUID is NULL
    // ===============================

    if(m_aRequests[m_dwNumRequests-1] == CLSID_NULL)
        return S_OK;
    else
        return S_FALSE;
}

// IMarshal methods

STDMETHODIMP CWbemContext::GetUnmarshalClass(REFIID riid, void* pv, 
                             DWORD dwDestContext, void* pvReserved, 
                             DWORD mshlFlags, CLSID* pClsid)
{
    *pClsid = CLSID_WbemContext;
    return S_OK;
}
                                             
STDMETHODIMP CWbemContext::GetMarshalSizeMax(REFIID riid, void* pv, 
                             DWORD dwDestContext, void* pvReserved, 
                             DWORD mshlFlags, ULONG* plSize)
{
    CInCritSec ics(&m_cs);

    DWORD dwLength = sizeof(DWORD); // length of causality string
    dwLength += m_dwNumRequests * sizeof(GUID); // causality string

    dwLength += sizeof(DWORD); // number of objects
    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
		DWORD	dwSize = 0;
		HRESULT	hr = m_aObjects[i]->GetMarshalSizeMax( &dwSize );
		if ( FAILED( hr ) )
		{
			return hr;
		}

        dwLength += dwSize;
    }

    *plSize = dwLength;
    return S_OK;
}

STDMETHODIMP CWbemContext::MarshalInterface(IStream* pStream, REFIID riid, 
                            void* pv, DWORD dwDestContext, void* pvReserved, 
                            DWORD mshlFlags)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;
    hres = pStream->Write((void*)&m_dwNumRequests, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;
    hres = pStream->Write((void*)m_aRequests, sizeof(GUID) * m_dwNumRequests, 
                            NULL);
    if(FAILED(hres)) return hres;
    
    DWORD dwNum = m_aObjects.GetSize();
    hres = pStream->Write((void*)&dwNum, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;

    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        hres = m_aObjects[i]->Marshal(pStream);
        if(FAILED(hres)) return hres;
    }
    return S_OK;
}
    
STDMETHODIMP CWbemContext::UnmarshalInterface(IStream* pStream, REFIID riid, 
                            void** ppv)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;
    DWORD i;
    STATSTG StatStg;

    if (FAILED(hres = pStream->Stat(&StatStg,STATFLAG_DEFAULT))) return hres;

	LARGE_INTEGER li; li.QuadPart = 0;
	ULARGE_INTEGER Position;
	if (FAILED(hres = pStream->Seek(li,STREAM_SEEK_CUR,&Position))) return hres;

	// simply TotalBytesInStream - CurrentPosition
	// the stram will contain the MEOW header, ecc, ecc
	DWORD dwTotSizeStream = StatStg.cbSize.LowPart - Position.LowPart;
    
    
    if (FAILED(hres = pStream->Read((void*)&m_dwNumRequests, sizeof(DWORD), NULL))) return hres;
    dwTotSizeStream -= sizeof(DWORD);
    if(m_dwNumRequests > 0)
    {
        DWORD dwSizeToAlloc = sizeof(GUID) * m_dwNumRequests;
        if (dwSizeToAlloc > dwTotSizeStream) return E_FAIL;
    
        delete [] m_aRequests;
        if (NULL == (m_aRequests = new GUID[m_dwNumRequests])) return WBEM_E_OUT_OF_MEMORY;
      
		if(FAILED(hres = pStream->Read((void*)m_aRequests, 
				                 dwSizeToAlloc ,
				                 NULL))) return hres;
			
		dwTotSizeStream -= dwSizeToAlloc;
    }

    DWORD dwNum;
    if(FAILED(hres = pStream->Read((void*)&dwNum, sizeof(DWORD), NULL))) return hres;
    dwTotSizeStream -= sizeof(DWORD);

    try
    {
        for(i = 0; i < dwNum; i++)
        {
	        CContextObj * newEntry = new CContextObj(pStream,dwTotSizeStream);
		    if (newEntry == 0 || m_aObjects.Add (newEntry)==-1)
		    {
		        delete newEntry;
		        return E_FAIL;
		    }
        }
    }
    catch(...)
    {
        return E_FAIL;
    }
    return QueryInterface(riid, ppv);
}
    
STDMETHODIMP CWbemContext::ReleaseMarshalData(IStream* pStream)
{
    return S_OK;
}

STDMETHODIMP CWbemContext::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastembd.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTEMBD.H

Abstract:

    Embedded Objects

History:

    3/10/97     a-levn  Fully documented
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_EMBED__H_
#define __FAST_EMBED__H_

#include "fastsprt.h"

//#pragma pack(push, 1)

class CWbemObject;
class CFastHeap;
class CVar;

#pragma pack(push, 1)
class COREPROX_POLARITY CEmbeddedObject
{
private:
    length_t m_nLength;
    BYTE m_byFirstByte;
public:
    length_t GetLength() {return m_nLength + sizeof(m_nLength);}
    LPMEMORY GetStart() {return (LPMEMORY)this;}

public:
    CWbemObject* GetEmbedded();
    static length_t EstimateNecessarySpace(CWbemObject* pObject);
    void StoreEmbedded(length_t nLength, CWbemObject* pObject);

    void StoreToCVar(CVar& Var);
    void StoreEmbedded(length_t nLength, CVar& Var);
    static length_t EstimateNecessarySpace(CVar& Var);

    static BOOL CopyToNewHeap( heapptr_t ptrOld,
                             CFastHeap* pOldHeap,
                             CFastHeap* pNewHeap,
							 UNALIGNED heapptr_t& ptrResult );
};
#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\faster.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTER.H

Abstract:

  This is the include file for all clients of fastobj functionality.
  See member header files for documentation.

History:

  3/10/97     a-levn  Fully documented

--*/

#ifndef _FASTER_H_
#define _FASTER_H_

//************************** WARNING ***************************************
// STL collections insist on protecting themselves against multi-threaded
// access. We don't want that --- we protect ourselves. This protection
// involves an extra DLL (msvcp50.dll) which we don't want to deal with. So
// we trick it into believing that we are compiling single-threaded.
//**************************************************************************
/*
#ifdef _MT
  #undef _MT
  #include <yvals.h>
  #define _MT
#endif
*/

//#include <dbgalloc.h>


// Parameter flow indicators.
// ==========================

#define READONLY
    // The value should be treated as read-only

#define ACQUIRED
    // Ownership of the object/pointer is acquired.

#define COPIED
    // The function makes a copy of the object/pointer.

#define PREALLOCATED
    // The out-param uses caller's memory.

#define NEWOBJECT
    // The return value or out parameter is a new
    // allocation which must be deallocated by
    // the caller if the call succeeds.

#define READWRITE
    // The in-param is will be treated as read-write,
    // but will not be deallocated.

#define INTERNAL
    // Returns a pointer to internal memory object
    // which should not be deleted.

#define ADDREF
    // On a parameter, indicates that the called
    // function will do an AddRef() on the interface
    // and retain it after the call completes.

#define TYPEQUAL L"CIMTYPE"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastcls.inc ===
//=============================================================================
//
//                              FASTCLS.INC
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  This file implements inline functions for the classes related to 
//	class representation in WbemObjects. It is included from fastcls.h
//
//	For complete documentation of all classes and methods, see fastcls.h
//
//  Classes implemented: 
//      CClassPart              Derived class definition
//      CWbemClass               Complete class definition.
//      
//  History:
//
//      3/10/97     a-levn  Fully documented
//
//=============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastembd.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTEMBD.CPP

Abstract:

    This file implements out-of-line functions for the classes related to 
    embedded objects.

    For complete documentation of all classes and methods, see fastcls.h

History:

    3/10/97     a-levn  Fully documented
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
//#include "dbgalloc.h"
#include "wbemutil.h"
#include "fastall.h"
 
#include "fastembd.h"
#include "fastobj.h"
#include "corex.h"

CWbemObject* CEmbeddedObject::GetEmbedded()
{
    if(m_nLength == 0) return NULL;

    LPMEMORY pNewMemory = CBasicBlobControl::sAllocate(m_nLength);

    if ( NULL == pNewMemory )
    {
        throw CX_MemoryException();
    }

    memcpy(pNewMemory, &m_byFirstByte, m_nLength);

    CWbemObject*    pObj = CWbemObject::CreateFromMemory(pNewMemory, m_nLength, TRUE);

    // Check for OOM
    if ( NULL == pObj )
    {
        throw CX_MemoryException();
    }

    return pObj;
}

length_t CEmbeddedObject::EstimateNecessarySpace(CWbemObject* pObject)
{
    if(pObject == NULL) return sizeof(length_t);
    pObject->CompactAll();

    // If it's an instance, we need to worry that the class part could be merged
    if ( pObject->IsInstance() )
    {
        DWORD   dwParts;

        pObject->QueryPartInfo( &dwParts );

        // Check the flags
        if (    (   dwParts & WBEM_OBJ_CLASS_PART   )
            &&  (   dwParts & WBEM_OBJ_CLASS_PART_SHARED    )   )
        {
            DWORD   dwLength = 0;

            // This will get us the full lengths of these parts
            pObject->GetObjectParts( NULL, 0, WBEM_INSTANCE_ALL_PARTS, &dwLength );

            // Account for the additional length_t
            return ( dwLength + sizeof(length_t) );
        }
        else
        {
            return pObject->GetBlockLength() + sizeof(length_t);
        }
    }
    else
    {
        return pObject->GetBlockLength() + sizeof(length_t);
    }

}

void CEmbeddedObject::StoreEmbedded(length_t nLength, CWbemObject* pObject)
{
    if(pObject == NULL)
    {
        m_nLength = 0;
    }
    else
    {
        m_nLength = nLength - sizeof(m_nLength);

        if ( NULL != pObject )
        {
            if ( pObject->IsInstance() )
            {
                DWORD   dwParts;

                // Check the flags
                pObject->QueryPartInfo( &dwParts );

                if (    (   dwParts & WBEM_OBJ_CLASS_PART   )
                    &&  (   dwParts & WBEM_OBJ_CLASS_PART_SHARED    )   )
                {
                    DWORD   dwLength = 0;

                    // This will write out the ENTIRE object.  If it fails, throw and exception
                    if ( FAILED( pObject->GetObjectParts( &m_byFirstByte, m_nLength, WBEM_INSTANCE_ALL_PARTS, &dwLength ) ) )
                    {
                        throw CX_MemoryException();
                    }

                }
                else
                {
                    memcpy(&m_byFirstByte, pObject->GetStart(), pObject->GetBlockLength());
                }
            }
            else
            {
                memcpy(&m_byFirstByte, pObject->GetStart(), pObject->GetBlockLength());
            }

        }   // IF we got an object

    }   // redundant check
    
}





void CEmbeddedObject::StoreToCVar(CVar& Var)
{
    // No allocations performed here
    I_EMBEDDED_OBJECT* pEmbed = 
        (I_EMBEDDED_OBJECT*)(IWbemClassObject*)GetEmbedded();
    Var.SetEmbeddedObject(pEmbed);
    if(pEmbed) pEmbed->Release();
}

void CEmbeddedObject::StoreEmbedded(length_t nLength, CVar& Var)
{
    I_EMBEDDED_OBJECT* pEmbed = Var.GetEmbeddedObject();
    StoreEmbedded(nLength, (CWbemObject*)(IWbemClassObject*)pEmbed);
    if(pEmbed) pEmbed->Release();
}

length_t CEmbeddedObject::EstimateNecessarySpace(CVar& Var)
{
    I_EMBEDDED_OBJECT* pEmbed = Var.GetEmbeddedObject();
    length_t nLength = 
        EstimateNecessarySpace((CWbemObject*)(IWbemClassObject*)pEmbed);
    if(pEmbed) pEmbed->Release();
    return nLength;
}

BOOL CEmbeddedObject::CopyToNewHeap(heapptr_t ptrOld,
                                         CFastHeap* pOldHeap,
                                         CFastHeap* pNewHeap,
                                         UNALIGNED heapptr_t& ptrResult)
{
    CEmbeddedObject* pOld = (CEmbeddedObject*)
        pOldHeap->ResolveHeapPointer(ptrOld);
    length_t nLength = pOld->GetLength();

    // Check for meory allocation failure
    heapptr_t ptrNew;
    BOOL    fReturn = pNewHeap->Allocate(nLength, ptrNew);

    if ( fReturn )
    {
        memcpy(pNewHeap->ResolveHeapPointer(ptrNew), pOld, nLength);
        ptrResult = ptrNew;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastheap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTHEAP.H

Abstract:

  This file defines the heap class used in WbemObjects.

  Classes defined: 
      CFastHeap   Local movable heap class.

History:

  2/20/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_HEAP__H_
#define __FAST_HEAP__H_

#include "fastsprt.h"
#include "faststr.h"

//#pragma pack(push, 1)

#define FAKE_HEAP_ADDRESS_INDICATOR MOST_SIGNIFICANT_BIT_IN_DWORD
#define OUTOFLINE_HEAP_INDICATOR MOST_SIGNIFICANT_BIT_IN_DWORD

#define INVALID_HEAP_ADDRESS 0xFFFFFFFF

//*****************************************************************************
//
//  CHeapHeader
//
//  This pseudo-structure preceeds the actual heap data in the memory block.
//  It starts with:
// 
//      length_t nAllocatedSize     The total amount of bytes allocated for
//                                  the heap data (not including the header)
//
//  If the most significant bit is set in nAllocatedSize, then the heap header
//  is assumed to be in a compressed form: no data other than nAllocatedSize
//  is present. This is convinient for many small read-only heaps. Such a heap
//  is referred to as out-of-line.
//
//  Otherwise (the most significant bit is not set in nAllocatedSize), the 
//  following two fields come right after nAllocatedSize:
//
//      length_t nDataSize          The upper bound of the highest actual
//                                  allocation in the heap. In other words,
//                                  it is guaranteed that everything above
//                                  nDataSize (through nAllocatedSize) is 
//                                  currently unused.
//
//      DWORD dwTotalFree           The total number of "holes", i.e., 
//                                  wasted space in the first nDataSize bytes
//                                  of the heap.
//
//  Such a heap is called in-line.
//
//*****************************************************************************

// The data in this structure is unaligned
#pragma pack(push, 1)
struct CHeapHeader
{
    length_t nAllocatedSize; // if msb is set, next 3 fields are omitted
    length_t nDataSize;
#ifdef MAINTAIN_FREE_LIST
    heapptr_t ptrFirstFree;
#endif
    DWORD dwTotalEmpty;
};
#pragma pack(pop)

#ifdef MAINTAIN_FREE_LIST
// The data in this structure is unaligned
#pragma pack(push, 1)
struct CFreeBlock
{
    length_t nLenght;
    heapptr_t ptrNextFree;
};
#pragma pack(pop)
#endif


//*****************************************************************************
//*****************************************************************************
//
//  class CHeapContainer
//
//  This abstract base class represents the capabilities that the CFastHeap
//  object requires from its container (in the sense of memory blocks; for
//  instance, a class part will "contain" a heap).
//
//*****************************************************************************
//
//  ExtendHeapSize = 0
//
//  CFastHeap will call this function when it runs out of space in its 
//  nAllocatedSize bytes. If this function determines that there is empty
//  space at the end of the current heap, it can simply mark it as occupied by
//  the heap and return. Otherwise, it must move the heap to another, large
//  enough block and inform the heap about its new location (see MoveBlock and
//  CopyBlock functions in fastsprt.h).
//
//  CFastHeap will automatically augment its requests to optimize reallocation/
//  wasted memory.
//
//  Parameters:
//
//      LPMEMORY pStart     The beginning of the heap's current memory block
//      length_t nOldLength Current length of the memory block
//      length_t nNewLength Required length of the memory block.
//
//*****************************************************************************
//
//  ReduceHeapSize
//
//  CFastHeap might call this function when it wants to return some space to
//  the container, but it never does.
//
//  Parameters:
//
//      LPMEMORY pStart     The beginning of the heap's current memory block
//      length_t nOldLength Current length of the memory block
//      length_t nDecrement How much space to return.
//      
//*****************************************************************************


class COREPROX_POLARITY CHeapContainer
{
public:
    virtual BOOL ExtendHeapSize(LPMEMORY pStart, length_t nOldLength, 
        length_t nExtra) = 0;
    virtual void ReduceHeapSize(LPMEMORY pStart, length_t nOldLength,
        length_t nDecrement) = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CFastHeap
//
//  This class represents a local heap implementation. The heap is a part of
//  every class's or instance's memory block --- this is where variable-length
//  structures are stored. The heap as currently implemented is rather 
//  primitive and is optimized for speed of access, not memory conservation. It
//  as assumed that objects have rather short lifetimes and heap compression 
//  is always performed automatically during object Merge/Unmerge opearations,
//  so the inefficiency does not propagate to disk.
//
//  The structure of the heap is that CHeapHeader (described above) followed by
//  the actual heap data. 
//
//  Items on the heap are represented as 'heap pointers' of type heapptr_t.
//  In actuality, these 'pointers' are offsets from the beginning of the data.
//  Thus, 0 is a valid heapptr_t and points to the very first item created.
//
//  The most significant bit of a heapptr_t may not be set in a valid
//  address. These 'fake' heap pointers are often used to represents offsets
//  into the known string table (see faststr,h). Thus, while heapptr_t of 1 
//  would indicate data at offset 1, heapptr_t of -2 would indicate a known
//  string with index of 2.
//
//**************************** members ****************************************
//
//  LPMEMORY m_pHeapData            The actual data on the heap.
//  CHeapHeader* m_pHeapHeader      Points to the heap header currently in use.
//                                  If the heap's own header (in the block) is
//                                  complete, m_pHeapHeader points ot it. 
//                                  Otherwise, it points to m_LocalHeapHeader.
//  CHeapHeader m_LocalHeapHeader   If the heap's own header (in the block) is
//                                  complete, this structure is unused. 
//                                  Otherwise, it contains the temporary copy
//                                  of the complete heap header data, as it is
//                                  necessary for the day-to-day operations.
//  CHeapContainer* m_pContainer    Points to the object whose block contains
//                                  our block (class part or instance part).
//                                  This member may be NULL if the heap is
//                                  used as read-only (see CreateOutOfLine).
//
//*****************************************************************************
//
//  SetData
//
//  Used to bind the CFastHeap object to a particular memory block which 
//  already contains a heap.
//
//  Parameters:
//
//      LPMEMORY pData                  The memory block to bind to. CFastHeap
//                                      assumes this memory last until Rebase
//                                      is called or this object is destroyed.
//      CHeapContainer* pContainer      The object whose memory block contains
//                                      ours. Assumed to survive longer than we
//                                      do (CFastHeap will not delete it).
//
//*****************************************************************************
//
//  CreateOutOfLine
//
//  Creates an empty out-of-line heap on the memory provided. See CHeapHeader
//  for description of in-line vs. out-of-line heap.
//
//  Parameters:
//
//      LPMEMORY pStart                 Points to the memory block to party on.      
//                                      Must be large enough to contain nLength
//                                      bytes of data plus the out-of-line 
//                                      header (GetMinLength()).
//      length_t nLength                Desired size of the data area.
//
//  Note:
//
//      
//*****************************************************************************
//
//  static GetMinLength
//
//  Returns the minimum number of bytes required for an out-of-line heap.
//  See CHeapHeader for description of in-line vs. out-of-line heap.
//
//  Returns:
//
//      int 
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an out-of-line heap of length 0 on a piece of memory. See also
//  CreateOutOfLine.
//
//  Parameters:
//
//      LPMEMORY pMemory
//
//*****************************************************************************
//
//  SetContainer
//
//  Sets the container of the heap. The old container pointer is discarded.
//
//  Parameters:
//
//      CHeapContainer* pContainer      The new container pointer. 
//                                      Assumed to survive longer than we do 
//                                      (CFastHeap will not delete it).
//
//*****************************************************************************
//
//  GetStart
//
//  Returns the pointer to the beginning of the heap's memory block.
//
//  Returns:
//
//      LPMEMORY
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      the length of the heap's memory block.
//
//*****************************************************************************
//
//  Skip
//
//  Returns:
//
//      LPMEMORY:   the pointer to the first byte following the heap's memory
//                  block.
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object that its memory block has been moved.  The old memory
//  block may have already been deallocated, so the object will not touch the
//  old memory in any way.
//
//  Parameters:
//
//      LPMEMORY pMemory    Points to the new memory block. It is guaranteed to
//                          already cointain the heap's data. 
//
//*****************************************************************************
//
//  Empty
//
//  Remove all data allocations and bring the heap to the empty state.
//
//*****************************************************************************
//
//  GetUsedLength
//
//  Returns:
//
//      length_t    N such that all data allocations on the heap reside inside
//                  the first N bytes of the data area. In other words, the
//                  area above N is completely unused.
//
//*****************************************************************************
//
//  ResolveHeapPointer
//
//  'pointer' dereferencing function.
//
//  Parameters:
//
//      heapptr_t ptr       The 'pointer' to the data on the heap (see header
//                          for more information.
//  Returns:
//
//      LPMEMORY: the real pointer to the data referenced by ptr. Note, that,
//                  as with most real pointers to the inside of a block, it
//                  is temporary and will be invalidated the moment the block
//                  moves.
//
//*****************************************************************************
//
//  IsFakeAddress
//
//  Determines if a heapptr_t is not a real heap address but rather is
//  an index in the known string table (see faststr.h).
//
//  Parameters:
//
//      heapptr_t ptr   The heap pointer to examine.
//      
//  Returns:
//
//      BOOL:   TRUE iff the address is not a real heap address but rather is
//              an index in the known string table (see faststr.h).
//
//*****************************************************************************
//
//  GetIndexFromFake
//
//  Converts a fake heap address (see header) into the index in the known
//  string table.
//
//  Parameters:
//
//      heapptr_t ptr   The fake heap address to convert (must be fake,
//                      otherwise results are unpredictable. See IsFakeAddress)
//  Returns:
//      
//      int:    the index of the known string (see faststr.h) represented by 
//              this heap address.
//
//*****************************************************************************
//
//  MakeFakeFromIndex
//
//  Creates a fake heap address from an known string index (see class header 
//  and faststr.h).
//
//  Parameters:
//
//      int nIndex      The know string index to convert.
//
//  Returns:
//
//      heapptr_t:  a fake heap pointer representing that known string.
//
//*****************************************************************************
//
//  ResolveString
//
//  Returns a CCompressedString at a given heap pointer. This works whether the
//  pointer is real or fake.
//
//  Parameters:
//
//      heapptr_t ptr   
//
//  Returns:
//
//      CCompressedString*:     this pointer will point inside the heap if the
//          heap pointer was real (in which case the returned pointer is 
//          temporary) or into the known string table (see faststr.h) if the
//          heap pointer was fake.
//
//*****************************************************************************
//
//  Allocate
//
//  'Allocates' memory on the heap. If there is not enough room, the heap is
//  automatically grown (possibly causing the whole object to relocate).
//
//  Parameters:
//
//      length_t nLength    numbed of bytes to allocate.
//
//  Returns:
//
//      heapptr_t:  the heap pointer to the allocated area. There is no 
//                  not-enough-memory condition here.
//
//*****************************************************************************
//
//  Extend
//
//  Extends a given area on the heap if there is enough space at the end. See
//  also Reallocate.
//
//  Parameters:
//
//      heapptr_t ptr           The area to extend.
//      length_t nOldLength     Current length of the area.
//      length_t nNewLength     Desired length.
//      
//  Returns:
//
//      BOOL:   TRUE if successful, FALSE if there was not enough space.
//
//*****************************************************************************
//
//  Reduce
//
//  Reduces the size of a given area on the heap, allowing the heap to reclaim
//  the extra space.
//
//  Parameters:
//
//      heapptr_t ptr           The area to extend.
//      length_t nOldLength     Current length of the area.
//      length_t nNewLength     Desired length.
//      
//*****************************************************************************
//
//  Reallocate
//
//  Fulfills a request to increase the size of a given area on the heap, either
//  through growth (see Extend) or, if there is not enough space to extend it,
//  through reallocation. In the case of reallocation, the contents of the old
//  area are copied to the new and the old area is released. If there is not
//  enough room to allocate the data on the heap, the heap itself is grown.
//
//  Parameters:
//
//      heapptr_t ptr           The area to extend.
//      length_t nOldLength     Current length of the area.
//      length_t nNewLength     Desired length.
//      
//  Returns:
//
//      heapptr_t:  the heap pointer to the newely allocated area. No out-of-
//                  memory handling exists.
//
//*****************************************************************************
//
//  AllocateString
//
//  A helper function for allocating a compressed string on the heap based on
//  a conventional string. It allocates enough space for a compressed
//  representation of the string (see faststr.h) creates CCompressedString on
//  that area, and returns the heap pointer to it.
//
//  Parameters I:
//
//      LPCSTR szString
//
//  Parameters II:
//
//      LPCWSTR wszSting
//
//  Returns:
//
//      heapptr_t:  the heap pointer to the newely allocated area. No out-of-
//                  memory handling exists.
//
//*****************************************************************************
//      
//  CreateNoCaseStringHeapPtr
//
//  A helper function. Given a string, it looks it up in the known string
//  table (faststr.h) and, if successful returns a fake pointer representing 
//  the index (see class header). If not found, it allocates a 
//  CCompressedString on the heap and returns the real heap pointer to it.
//
//  Since known string table searches are case-insensitive, 'NoCase' appears
//  in the name. However, if the string is allocates on the heap, its case
//  is preserved.
//
//  Parameters:
//
//      LPCWSTR wszString
//
//  Returns:
//
//      heapptr_t:  the heap pointer. No out-of-memory handling exists.
//
//*****************************************************************************
//      
//  Free
//
//  Frees an area on the heap. Can be used with a fake pointer, in which case
//  it's a noop.
//
//  Parameters:
//
//      heapptr_t ptr       The heap pointer to free.
//      length_t nLength    The length of the area.
//
//*****************************************************************************
//
//  FreeString
//
//  Frees an area on the heap occupied by a string. The advantage of this 
//  function is that it determines the length of the area itself from the
//  string. Can be used with a fake pointer, in which case it's a noop.
//
//  Parameters:
//
//      heapptr_t ptr       The heap pointer to free.
//
//*****************************************************************************
//
//  Copy
//
//  Copies a given number of bytes from one heap location to another. Uses
//  memcpy, so THE AREAS MAY NOT OVERLAP!
//
//  Parameters:
//
//      heapptr_t ptrDest       Destination heap pointer.
//      heapptr_t ptrSrc        Source heap pointer.
//      length_t nLength        Numbed of bytes to copy.
//
//*****************************************************************************
//
//  Trim
//
//  Causes the heap to release all its unused memory (above GetUsedLength) to
//  its container (see CHeapContainer).
//
//*****************************************************************************

class COREPROX_POLARITY CFastHeap
{
protected:
    LPMEMORY m_pHeapData;
    CHeapHeader* m_pHeapHeader;
    CHeapHeader m_LocalHeapHeader;
    CHeapContainer* m_pContainer;

protected:
    BOOL IsOutOfLine() {return m_pHeapHeader == &m_LocalHeapHeader;}
    PLENGTHT GetInLineLength() {return ((PLENGTHT)m_pHeapData)-1;}
    void SetInLineLength(length_t nLength);

    length_t GetHeaderLength()
        {return (IsOutOfLine()) ? sizeof(length_t) : sizeof(CHeapHeader);}

public:
    BOOL SetData(LPMEMORY pData, CHeapContainer* pContainer);

	LPMEMORY GetHeapData( void )
	{ return m_pHeapData; }

    LPMEMORY CreateOutOfLine(LPMEMORY pStart, length_t nLength);
    void SetContainer(CHeapContainer* pContainer)
        {m_pContainer = pContainer;}

    LPMEMORY GetStart() 
    {
        return (IsOutOfLine()) ? 
            (LPMEMORY)GetInLineLength() : 
            (LPMEMORY)m_pHeapHeader;
    }

    length_t GetLength() 
        {return GetHeaderLength() + GetAllocatedDataLength();}

    length_t GetRealLength() 
        {return GetHeaderLength() + GetUsedLength();}

    LPMEMORY Skip() {return m_pHeapData + GetAllocatedDataLength();}

    void Rebase(LPMEMORY pMemory);

    void Empty() 
    {
        m_pHeapHeader->nDataSize = 0;
        m_pHeapHeader->dwTotalEmpty = 0;
    }
public:
    length_t GetUsedLength() 
    {
        return m_pHeapHeader->nDataSize;
    }

    void SetUsedLength( length_t nDataSize ) 
    {
        m_pHeapHeader->nDataSize = nDataSize;
    }

    length_t GetAllocatedDataLength()
        {return m_pHeapHeader->nAllocatedSize;}

    void SetAllocatedDataLength(length_t nLength);

    LPMEMORY ResolveHeapPointer(heapptr_t ptr)
    {
        return m_pHeapData + ptr;
    }

    static IsFakeAddress(heapptr_t ptr)
    {
        return (ptr & FAKE_HEAP_ADDRESS_INDICATOR);
    }

    static int GetIndexFromFake(heapptr_t ptr)
    {
        return (ptr ^ FAKE_HEAP_ADDRESS_INDICATOR);
    }

    static heapptr_t MakeFakeFromIndex(int nIndex)
    {
        return (nIndex | FAKE_HEAP_ADDRESS_INDICATOR);
    }

    CCompressedString* ResolveString(heapptr_t ptr)
    {
        if(IsFakeAddress(ptr))
            return &CKnownStringTable::GetKnownString(ptr & 
                                                ~FAKE_HEAP_ADDRESS_INDICATOR);
        else 
            return (CCompressedString*)ResolveHeapPointer(ptr);
    }

public:
    BOOL Allocate(length_t nLength, UNALIGNED heapptr_t& ptrResult );
    BOOL Extend(heapptr_t ptr, length_t nOldLength, length_t nNewLength);
    void Reduce(heapptr_t ptr, length_t nOldLength, length_t nNewLength);
    BOOL Reallocate(heapptr_t ptrOld, length_t nOldLength,
        length_t nNewLength, UNALIGNED heapptr_t& ptrResult);
    BOOL AllocateString(COPY LPCWSTR wszString, UNALIGNED heapptr_t& ptrResult);
    BOOL AllocateString(COPY LPCSTR szString, UNALIGNED heapptr_t& ptrResult);
    BOOL CreateNoCaseStringHeapPtr(COPY LPCWSTR wszString, UNALIGNED heapptr_t& ptrResult);
    void Free(heapptr_t ptr, length_t nLength);
    void FreeString(heapptr_t ptrString);
    void Copy(heapptr_t ptrDest, heapptr_t ptrSource, length_t nLength);
    void Trim();

public:
    static length_t GetMinLength() {return sizeof(length_t);}
    static LPMEMORY CreateEmpty(LPMEMORY pStart);
protected:
    length_t AugmentRequest(length_t nCurrentLength, length_t nNeed)
    {
        return nNeed + nCurrentLength + 32;
    }
    heapptr_t AbsoluteToHeap(LPMEMORY pMem)
    {
		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned longs.  We do not support length
		// > 0xFFFFFFFF so cast is ok.

        return (heapptr_t) ( pMem - m_pHeapData );
    }
};

//*****************************************************************************
//*****************************************************************************
//
//  class CHeapPtr : public CPtrSource
//
//  This CPtrSource derivative encapsulates a heap pointer as a pointer source.
//  See CPtrSource description in fastsprt.h for more information on pointer
//  source. Suffice it to say that pointer sources must be capable of returning
//  an actual pointer at any given time, but that pointer value may change 
//  overtime.
//
//  Heap pointers are a prime example of that --- since the heap's memory block
//  may move during its lifetime, the actual C pointer to an item on the heap
//  may change. CHeapPtr takes care of that by storing the heap and the heap
//  pointer together and calling ResolveHeapPointer every time it needs to get
//  a C pointer to the data.
//
//*****************************************************************************
//
//  Constructor
//
//  Parameters:
//
//      CFastHeap* pHeap        The heap on which the data resides. Assumed to
//                              last longer than this object itself.
//      heapptr_t ptr           The heap pointer to the desired item.
//
//*****************************************************************************
//
//  GetPointer
//
//  Retrieves the current value of the corresponding C pointer.
//
//  Returns:
//
//      LPMEMORY    this pointer is temporary (that's the whole purpose ofthis
//                  class, after all!)
//
//*****************************************************************************

class CHeapPtr : public CPtrSource
{
protected:
    CFastHeap* m_pHeap;
    heapptr_t m_ptr;
public:
    CHeapPtr(CFastHeap* pHeap, heapptr_t ptr) 
        : m_pHeap(pHeap), m_ptr(ptr) {}

    LPMEMORY GetPointer() {return m_pHeap->ResolveHeapPointer(m_ptr);}
};



//#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastext.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FASTEXT.H

Abstract:

  This file defines the classes related to instance representation
  in WbemObjects

  Classes defined: 
      CWbemExtendedPart		Extended Data.

History:

  4/3/00	sanjes -	Created

--*/

#ifndef __FAST_WBEM_FASTEXT__H_
#define __FAST_WBEM_FASTEXT__H_

// This way, we know the version of the Instance BLOB
#define	EXTENDEDDATA_CURRENTVERSION	1

// Flags to apply to the mask
#define	EXTENDEDDATA_TCREATED_FLAG		0x0000000000000001
#define	EXTENDEDDATA_TMODIFIED_FLAG		0x0000000000000002
#define	EXTENDEDDATA_EXPIRATION_FLAG	0x0000000000000004

class COREPROX_POLARITY CWbemExtendedPart
{

public:

// The data in this structure is unaligned
#pragma pack(push, 1)
    struct CExtendedData
    {
        length_t			m_nDataSize; 
		WORD				m_wVersion;
		unsigned __int64	m_ui64ExtendedPropMask;
		unsigned __int64	m_ui64TCreated;
		unsigned __int64	m_ui64TModified;
		unsigned __int64	m_ui64Expiration;
		// Add additional data down here so we don't cause any backwards
		// compatibility issues
    };
#pragma pack(pop)

	CExtendedData*	m_pExtData;

public:
	CWbemExtendedPart();
	~CWbemExtendedPart();

     LPMEMORY GetStart() {return LPMEMORY(m_pExtData);}
     static int GetLength(LPMEMORY pStart) 
    {
        return ((CExtendedData*)pStart)->m_nDataSize;
    }
     int GetLength() { return NULL != m_pExtData ? m_pExtData->m_nDataSize : 0;}
     void Rebase(LPMEMORY pNewMemory);
     void SetData(LPMEMORY pStart);
	 static length_t GetMinimumSize( void );
	 LPMEMORY Merge( LPMEMORY pData );
	 LPMEMORY Unmerge( LPMEMORY pData );

	void Init( void );
	void Copy( CWbemExtendedPart* pSrc );

	// Extended System Properties
    HRESULT GetTCreated( unsigned __int64* pui64 );
    HRESULT GetTModified( unsigned __int64* pui64 );
    HRESULT GetExpiration( unsigned __int64* pui64 );
    HRESULT SetExpiration( unsigned __int64* pui64 );
    HRESULT SetTModified( unsigned __int64* pui64 );
    HRESULT SetTCreated( unsigned __int64* pui64 );
    HRESULT GetTCreatedAddress( LPVOID* ppAddr );
    HRESULT GetTModifiedAddress( LPVOID* ppAddr );
    HRESULT GetExpirationAddress( LPVOID* ppAddr );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastext.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FASTEXT.CPP

Abstract:

  This file implements all the functions for the classes related to extended
  data in WbemObjects.

  The classes are defined in fastext.h where the documentation can be found.

  Classes implemented:
      CWbemExtendedPart           Instance data.

History:

  4/3/00 sanjes -    Created

--*/
#include "precomp.h"

#include <genlex.h>
#include <qllex.h>
#include <objpath.h>

//#include "dbgalloc.h"
#include "wbemutil.h"
#include "arrtempl.h"
#include "fastall.h"
#include "fastext.h"
#include "olewrap.h"

// Construction/Destruction
CWbemExtendedPart::CWbemExtendedPart( void )
:	m_pExtData( NULL )
{
}

CWbemExtendedPart::~CWbemExtendedPart( void )
{
}

void CWbemExtendedPart::Rebase(LPMEMORY pNewMemory)
{
	m_pExtData = ((CExtendedData*) pNewMemory );
}

void CWbemExtendedPart::SetData(LPMEMORY pStart)
{
	m_pExtData = ((CExtendedData*) pStart );
}

LPMEMORY CWbemExtendedPart::Merge( LPMEMORY pData )
{
	CopyMemory( m_pExtData, pData, ((CExtendedData*) pData )->m_nDataSize );
	return pData + m_pExtData->m_nDataSize;
}

LPMEMORY CWbemExtendedPart::Unmerge( LPMEMORY pData )
{
	CopyMemory( pData, m_pExtData, m_pExtData->m_nDataSize );
	return pData + m_pExtData->m_nDataSize;
}

length_t CWbemExtendedPart::GetMinimumSize( void )
{
	return sizeof( CExtendedData );
}

void CWbemExtendedPart::Init( void )
{
	m_pExtData->m_nDataSize = sizeof( CExtendedData );
	m_pExtData->m_wVersion = EXTENDEDDATA_CURRENTVERSION;
	m_pExtData->m_ui64ExtendedPropMask = EXTENDEDDATA_TCREATED_FLAG;

	//Get the system time, convert to filetime and set the create time
	SYSTEMTIME	st;
	FILETIME	ft;

	GetSystemTime( &st );
	SystemTimeToFileTime( &st, &ft );

	m_pExtData->m_ui64TCreated = *(unsigned __int64*) &ft;
	m_pExtData->m_ui64TModified = 0;
	m_pExtData->m_ui64Expiration = 0;
}

void CWbemExtendedPart::Copy( CWbemExtendedPart* pSrc )
{
	// Only copy data from the source that is indicative of the actual data size.
	// Need to make sure we won't cause any weird overwrites if a later version structure
	// shows up and we try to copy onto an older version structure.

	ZeroMemory( m_pExtData, sizeof( CExtendedData ) );
	m_pExtData->m_nDataSize = sizeof( CExtendedData );

	ULONG	uSizeToCopy = min( pSrc->m_pExtData->m_nDataSize, m_pExtData->m_nDataSize );

	// Account for the fact that we are not copying the DataSize
	CopyMemory( &m_pExtData->m_wVersion, &pSrc->m_pExtData->m_wVersion, uSizeToCopy - sizeof(m_pExtData->m_nDataSize) );
}

// Retrieve and set the special secret new properties
HRESULT CWbemExtendedPart::GetTCreated( unsigned __int64* pui64 )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( m_pExtData->m_ui64ExtendedPropMask & EXTENDEDDATA_TCREATED_FLAG )
		{
			*pui64 = m_pExtData->m_ui64TCreated;
		}
		else
		{
			hr = WBEM_S_FALSE;
		}
	}
	else
	{
		// Means this aoin't here
		hr= WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

// Retrieve and set the special secret new properties
HRESULT CWbemExtendedPart::GetTModified( unsigned __int64* pui64 )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( m_pExtData->m_ui64ExtendedPropMask & EXTENDEDDATA_TMODIFIED_FLAG )
		{
			*pui64 = m_pExtData->m_ui64TModified;
		}
		else
		{
			hr = WBEM_S_FALSE;
		}
	}
	else
	{
		// Means this aoin't here
		hr= WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CWbemExtendedPart::GetExpiration( unsigned __int64* pui64 )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( m_pExtData->m_ui64ExtendedPropMask & EXTENDEDDATA_EXPIRATION_FLAG )
		{
			*pui64 = m_pExtData->m_ui64Expiration;
		}
		else
		{
			hr = WBEM_S_FALSE;
		}
	}
	else
	{
		// Means this aoin't here
		hr= WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CWbemExtendedPart::SetTCreated( unsigned __int64* pui64 )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( NULL != pui64 )
		{
			m_pExtData->m_ui64ExtendedPropMask |= EXTENDEDDATA_TCREATED_FLAG;
			m_pExtData->m_ui64TCreated = *pui64;
		}
		else
		{
			m_pExtData->m_ui64ExtendedPropMask &= ~EXTENDEDDATA_TCREATED_FLAG;
			m_pExtData->m_ui64TCreated = 0;
		}
	}
	else
	{
		// Means this ain't here
		hr= WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CWbemExtendedPart::SetTModified( unsigned __int64* pui64 )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( NULL != pui64 )
		{
			m_pExtData->m_ui64ExtendedPropMask |= EXTENDEDDATA_TMODIFIED_FLAG;
			m_pExtData->m_ui64TModified = *pui64;
		}
		else
		{
			m_pExtData->m_ui64ExtendedPropMask &= ~EXTENDEDDATA_TMODIFIED_FLAG;
			m_pExtData->m_ui64TModified = 0;
		}
	}
	else
	{
		// Means this ain't here
		hr= WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CWbemExtendedPart::SetExpiration( unsigned __int64* pui64 )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( NULL != pui64 )
		{
			m_pExtData->m_ui64ExtendedPropMask |= EXTENDEDDATA_EXPIRATION_FLAG;
			m_pExtData->m_ui64Expiration = *pui64;
		}
		else
		{
			m_pExtData->m_ui64ExtendedPropMask &= ~EXTENDEDDATA_EXPIRATION_FLAG;
			m_pExtData->m_ui64Expiration = 0;
		}
	}
	else
	{
		// Means this aoin't here
		hr= WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CWbemExtendedPart::GetTCreatedAddress( LPVOID* ppAddr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( m_pExtData->m_ui64ExtendedPropMask & EXTENDEDDATA_TCREATED_FLAG )
		{
			*ppAddr = (LPVOID) &m_pExtData->m_ui64TCreated;
		}
		else
		{
			hr= WBEM_S_FALSE;
		}

	}
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CWbemExtendedPart::GetTModifiedAddress( LPVOID* ppAddr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( m_pExtData->m_ui64ExtendedPropMask & EXTENDEDDATA_TMODIFIED_FLAG )
		{
			*ppAddr = (LPVOID) &m_pExtData->m_ui64TModified;
		}
		else
		{
			hr= WBEM_S_FALSE;
		}

	}
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CWbemExtendedPart::GetExpirationAddress( LPVOID* ppAddr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pExtData )
	{
		if ( m_pExtData->m_ui64ExtendedPropMask & EXTENDEDDATA_TCREATED_FLAG )
		{
			*ppAddr = (LPVOID) &m_pExtData->m_ui64Expiration;
		}
		else
		{
			hr= WBEM_S_FALSE;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastheap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTHEAP.CPP

Abstract:

  This file defines the heap class used in WbemObjects.

  Classes defined: 
      CFastHeap   Local movable heap class.

History:

  2/20/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
//#include "dbgalloc.h"
#include "wbemutil.h" 
#include "faster.h"
#include "fastheap.h"

LPMEMORY CFastHeap::CreateEmpty(LPMEMORY pStart)
{
    *(PLENGTHT)pStart = OUTOFLINE_HEAP_INDICATOR;
    return pStart + sizeof(length_t);
}

LPMEMORY CFastHeap::CreateOutOfLine(LPMEMORY pStart, length_t nLength)
{
    m_pContainer = NULL;

    *(PLENGTHT)pStart = nLength | OUTOFLINE_HEAP_INDICATOR;

    m_pHeapData = pStart + sizeof(length_t);
    m_pHeapHeader = &m_LocalHeapHeader;

    m_pHeapHeader->nAllocatedSize = nLength;
#ifdef MAINTAIN_FREE_LIST
    m_pHeapHeader->ptrFirstFree = INVALID_HEAP_ADDRESS;
#endif
    m_pHeapHeader->nDataSize = 0;
    m_pHeapHeader->dwTotalEmpty = 0;

    return pStart + sizeof(length_t) + nLength;
}


BOOL CFastHeap::SetData(LPMEMORY pData, CHeapContainer* pContainer)
{
    m_pContainer = pContainer;

    if((*(PLENGTHT)pData) & OUTOFLINE_HEAP_INDICATOR)
    {
        m_pHeapData = pData + sizeof(length_t);
        m_pHeapHeader = &m_LocalHeapHeader;

        m_pHeapHeader->nAllocatedSize = 
            (*(PLENGTHT)pData) & ~OUTOFLINE_HEAP_INDICATOR;
#ifdef MAINTAIN_FREE_LIST
        m_pHeapHeader->ptrFirstFree = INVALID_HEAP_ADDRESS;
#endif
        m_pHeapHeader->nDataSize = m_pHeapHeader->nAllocatedSize;
        m_pHeapHeader->dwTotalEmpty = 0;
    }
    else
    {
        m_pHeapHeader = (CHeapHeader*)pData;
        m_pHeapData = pData + sizeof(CHeapHeader);
    }
    return TRUE;
}

void CFastHeap::SetInLineLength(length_t nLength)
{
    *(GetInLineLength()) = nLength | OUTOFLINE_HEAP_INDICATOR;
}

void CFastHeap::SetAllocatedDataLength(length_t nLength)
{
    m_pHeapHeader->nAllocatedSize = nLength;
    if(IsOutOfLine()) 
        SetInLineLength(nLength);
}

void CFastHeap::Rebase(LPMEMORY pNewMemory)
{
    if(IsOutOfLine())
    {
        m_pHeapData = pNewMemory + sizeof(length_t);
    }
    else
    {
        m_pHeapHeader = (CHeapHeader*)pNewMemory;
        m_pHeapData = pNewMemory + sizeof(CHeapHeader);
    }
}

BOOL CFastHeap::Allocate(length_t nLength, UNALIGNED heapptr_t& ptrResult )
{
#ifdef MAINTAIN_FREE_LIST
    // TBD
#endif
    // First, check if there is enough space at the end
    // ================================================

    length_t nLeft = m_pHeapHeader->nAllocatedSize - m_pHeapHeader->nDataSize;
    if(nLeft < nLength)
    {
        // Need more room!
        // ===============

        length_t nExtra = AugmentRequest(GetAllocatedDataLength(), nLength - nLeft);

        // Check for allocation failure
        if ( !m_pContainer->ExtendHeapSize(GetStart(), GetLength(), nExtra) )
        {
            return FALSE;
        }

        SetAllocatedDataLength(GetAllocatedDataLength() + nExtra);
    }

    // Now we have enough room at the end, allocate it
    // ===============================================

    ptrResult = m_pHeapHeader->nDataSize;
    m_pHeapHeader->nDataSize += nLength;

    return TRUE;
}

BOOL CFastHeap::Extend(heapptr_t ptr, length_t nOldLength, 
                          length_t nNewLength)
{
    // Check if we are at the end of used area
    // =======================================

    if(ptr + nOldLength == m_pHeapHeader->nDataSize)
    {
        // Check if there is enough allocated space
        // ========================================

        if(ptr + nNewLength <= m_pHeapHeader->nAllocatedSize)
        {
            m_pHeapHeader->nDataSize += nNewLength - nOldLength;
            return TRUE;
        }
        else return FALSE;
    }
    else return FALSE;
}

void CFastHeap::Reduce(heapptr_t ptr, length_t nOldLength, 
                          length_t nNewLength)
{
    // Check if we are at the end of used area
    // =======================================

    if(ptr + nOldLength == m_pHeapHeader->nDataSize)
    {
        m_pHeapHeader->nDataSize -= nOldLength - nNewLength;
    }
}

void CFastHeap::Copy(heapptr_t ptrDest, heapptr_t ptrSource, 
                            length_t nLength)
{
    memmove((void*)ResolveHeapPointer(ptrDest), 
        (void*)ResolveHeapPointer(ptrSource), nLength);
}

BOOL CFastHeap::Reallocate(heapptr_t ptrOld, length_t nOldLength,
        length_t nNewLength, UNALIGNED heapptr_t& ptrResult )
{
    if(nOldLength >= nNewLength)
    {
        Reduce(ptrOld, nOldLength, nNewLength);
        ptrResult = ptrOld;
        return TRUE;
    }
    if(Extend(ptrOld, nOldLength, nNewLength)) 
    {
        ptrResult = ptrOld;
        return TRUE;
    }
    else 
    {
        // TBD: wastes space if old area was at the end.

        heapptr_t ptrNew;

        // Check that this allocation succeeds
        BOOL fReturn = Allocate(nNewLength, ptrNew);

        if ( fReturn )
        {
            Copy(ptrNew, ptrOld, nOldLength);
            Free(ptrOld, nOldLength);
            ptrResult = ptrNew;
        }

        return fReturn;
    }
}

BOOL CFastHeap::AllocateString(COPY LPCWSTR wszString, UNALIGNED heapptr_t& ptrResult)
{
    int nSize = CCompressedString::ComputeNecessarySpace(wszString);

    // Check for allocation failure
    BOOL fReturn = Allocate(nSize, ptrResult);

    if ( fReturn )
    {
        CCompressedString* pcsString = (CCompressedString*)ResolveHeapPointer(ptrResult);
        pcsString->SetFromUnicode(wszString);
    }

    return fReturn;
}

BOOL CFastHeap::AllocateString(COPY LPCSTR szString, UNALIGNED heapptr_t& ptrResult)
{
    int nSize = CCompressedString::ComputeNecessarySpace(szString);

    // Check for allocation failure
    BOOL fReturn = Allocate(nSize, ptrResult);

    if ( fReturn )
    {
        CCompressedString* pcsString = (CCompressedString*)ResolveHeapPointer(ptrResult);
        pcsString->SetFromAscii(szString);
    }

    return fReturn;
}

BOOL CFastHeap::CreateNoCaseStringHeapPtr(COPY LPCWSTR wszString, UNALIGNED heapptr_t& ptrResult)
{
    int     nKnownIndex = CKnownStringTable::GetKnownStringIndex(wszString);
    BOOL    fReturn = TRUE;

    if(nKnownIndex < 0)
    {
        // Check for allocation failure
        fReturn = AllocateString(wszString, ptrResult);
        //ResolveString(ptr)->MakeLowercase();
    }
    else
    {
        ptrResult = CFastHeap::MakeFakeFromIndex(nKnownIndex);
    }

    return fReturn;
}

void CFastHeap::Free(heapptr_t ptr, length_t nSize)
{
    if(IsFakeAddress(ptr)) return;

    // Check if it is at the end of the allocated area
    // ===============================================

    if(ptr + nSize == m_pHeapHeader->nDataSize)
    {
        m_pHeapHeader->nDataSize = ptr;
        return;
    }

#ifdef MAINTAIN_FREE_LIST

    // Add it to the free list
    // =======================

    if(nSize >= sizeof(CFreeBlock))
    {
        CFreeBlock* pFreeBlock = (CFreeBlock*)ResolveHeapPointer(ptr);
        pFreeBlock->ptrNextFree = m_pHeapHeader->ptrFirstFree;
        pFreeBlock->nLength = nSize;

        m_pHeapHeader->ptrFirstFree = ptr;
    }
#endif
    m_pHeapHeader->dwTotalEmpty += nSize;
}

void CFastHeap::FreeString(heapptr_t ptrString)
{
    if(IsFakeAddress(ptrString)) return;
    CCompressedString* pcs = (CCompressedString*)ResolveHeapPointer(ptrString);
    Free(ptrString, pcs->GetLength());
}

void CFastHeap::Trim()
{
    if(m_pContainer)
        m_pContainer->ReduceHeapSize(GetStart(), GetLength(), 
            m_pHeapHeader->nAllocatedSize - m_pHeapHeader->nDataSize);

    SetAllocatedDataLength(m_pHeapHeader->nDataSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastinst.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTINST.H

Abstract:

  This file defines the classes related to instance representation
  in WbemObjects

  Classes defined: 
      CInstancePart           Instance data.
      CInstancePartContainer  Anything that contains CInstancePart
      CWbemInstance            Complete instance definition.

History:

  3/10/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_WBEM_INSTANCE__H_
#define __FAST_WBEM_INSTANCE__H_

#include "fastcls.h"

//#pragma pack(push, 1)

// This is the unicode character used to join compound keys.
// This is a non-used unicode character and so is safe.  It is 
// reserved for just this task.
#define WINMGMT_COMPOUND_KEY_JOINER 0xFFFF

//*****************************************************************************
//*****************************************************************************
//
//  class CInstancePartContainer
//
//  See CInstancePart definition first.
//
//  This class defines the functionality required by CInstancePart of any object
//  whose memory block contains that of the CInstancePart.
//
//*****************************************************************************
//
//  ExtendInstancePartSpace
//
//  Called by CInstancePart when it needs more memory for its memory block. The
//  container may have to relocate the entire memory block to get more memory. 
//  In this case, it will have to notify CInstancePart of its new location using
//  Rebase.
//
//  Parameters:
//
//      CInstancePart* pInstancePart      The instance part making the request
//      length_t nNewLength               The required length
//
//*****************************************************************************
//
//  ReduceInstancePartSpace
//
//  Called by CInstancePart wen it wants to return some memory to the container.
//  The container may NOT relocate the insatnce part's memory block in response
//  to this call.
//
//  Parameters:
//
//      CInstancePart* pInstancePart      The instance part making the request
//      length_t nDecrement               The amount of space to return
//
//*****************************************************************************
//
//  GetWbemObjectUnknown
//
//  Must return the pointer to the IUnknown of the containing CWbemObject
//  This is used by qualifier sets to ensure that the main object lasts at
//  least as long as they do.
//  
//  Returns:
//
//      IUnknown*:   the pointer to the controlling IUnknown
//
//*****************************************************************************
class CInstancePart;
class COREPROX_POLARITY CInstancePartContainer
{
public:
    virtual BOOL ExtendInstancePartSpace(CInstancePart* pPart, 
        length_t nNewLength) = 0;
    virtual void ReduceInstancePartSpace(CInstancePart* pPart,
        length_t nDecrement) = 0;
    virtual IUnknown* GetInstanceObjectUnknown() = 0;
    virtual void ClearCachedKeyValue() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CInstancePart
//
//  This class represents the data of an instance. While all the information
//  is there, this class cannot function alone without its class definition.
//
//  The memory block of the instance part has the following structure
//
//      Header:
//          length_t nLength        The length of the entire structure
//          BYTE fFlags             Reserved
//          heapptr_t ptrClassName  Heap pointer to the class name (on the 
//                                  heap of the instance part (below))
//      Data table (see CDataTable in fastprop.h) with property values
//      Instance qualifier set (see CQualifierSet in fastqual.h)
//      Instance property qualifier set (see CQualifierSetList in fastqual.h)
//      Heap for variable-length data (see CFastHeap in fastheap.h)
//
//*****************************************************************************
//
//  SetData
//
//  Initializer.
//
//  Parameters:
//
//      LPMEMORY pStart                     The memory block
//      CInstancePartContainer* pContainer  The container (CWbemInstance itself)
//      CClassPart& ClassPart               Out class definition.
//
//*****************************************************************************
//
//  GetStart
//
//  Returns:
//
//      LPMEMORY:   the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      length_t:   the length of the memory block.
//
//*****************************************************************************
//
//  Rebase
//
//  Informs this object that its memory block has moved.
//
//  Parameters:
//
//      LPMEMORY pMemory        The new location of the memory block
//
//*****************************************************************************
//
//  GetActualValue
//
//  Retrieves the value of a property based on its information structure (see
//  fastprop.h).
//
//  Parameters:
//
//      IN CPropertyInformation* pInfo  Property information structure
//      OUT  CVar* pVar                 Destination for the value. Must not
//                                      already contain a value.
//
//*****************************************************************************
//
//  SetActualValue
//
//  Sets the actual value of a property based on its information structure (see
//  fastprop.h). The value must match the property type --- no coersion is 
//  attempted.
//
//  Parameters:
//
//      IN CPropertyInformation* pInfo  Property information structure
//      IN   CVar* pVar                 the value to set
//
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_TYPE_MISMATCH     Type mismatch.   
//
//*****************************************************************************
//
//  GetObjectQualifier
//
//  Retrieves an instance qualifier by its name.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve
//      OUT CVar* pVar          Destination for the value. Must not already 
//                              contain a value.
//      OUT long* plFlavor      Destinatino for the flavor. May be NULL if not
//                              required.
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_NOT_FOUND         No such qualifier
//
//*****************************************************************************
//
//  SetInstanceQualifier
//
//  Sets the value of an instance qualifier.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to set
//      IN CVar* pVar           The value for the qualifier.
//      IN long lFlavor         The flavor for the qualifier.
//
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//      
//*****************************************************************************
//
//  GetQualifier
//
//  Retrieves a class or instance qualifier by its name.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve
//      OUT CVar* pVar          Destination for the value. Must not already 
//                              contain a value.
//      OUT long* plFlavor      Destinatino for the flavor. May be NULL if not
//                              required.
//  Returns:
//
//      WBEM_S_NO_ERROR          Success
//      WBEM_E_NOT_FOUND         No such qualifier
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Creates a limited representation of this instance part on a given block of 
//  memory as described in EstimateLimitedRepresentationLength in fastobj.h.
//
//  PARAMETERS:
//
//      IN CLimitationMapping* pMap The mapping of the limitation to produce.
//                                  Obtained from CWbemClass::MapLimitation.
//      IN nAllocatedSize           The size of the memory block allocated for
//                                  the operation --- pDest.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************
//
//  static GetDataTableData
//
//  Returns the pointer to the instance data table based on the instance part
//  starting pointer. This can be used in table scans
//
//  Parameters:
//
//      LPMEMORY pStart     Where the instance part memory block starts.
//
//  Returns:
//
//      LPMEMORY:   where the data table starts
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the amount of space required for an empty instance of a given 
//  class (i.e. with all default values and no additional qualifiers).
//
//  Parameters:
//
//      CClassPart* pClassDef       The class definition (see fastcls.h)
//
//  Returns:
//
//      length_t:    exact amount of space required for the instance part.
//
//*****************************************************************************
//
//  Create
//
//  Creates an empty instance part for a given class on a given memory block
//  and initializes this object to point to that instance.
//
//  Parameters:
//
//      LPMEMORY pMemory            The memory block to create on.
//      CClassPart* pClassDef       Our class definition
//      CInstancePartContainer* pContainer  The container (CWbemInstance)
//
//  Retutns:
//
//      LPMEMORY:   points to the first byte after the data written
//
//*****************************************************************************
//
//  TranslateToNewHeap
//
//  Moves all the data currently on the instance part heap to another heap. The
//  point of this operation is that it performs heap compaction --- the new
//  heap will not contain any holes. The data is NOT removed from the old heap.
//
//  Parameters:
//
//      READONLY CClassPart& ClassPart  Our class definition
//      READONLY CFastHeap* pOldHeap    The current heap.
//      CFastHeap* pNewHeap             The new heap.
//
//*****************************************************************************
//
//  CanContainKey
//
//  Qualifier sets ask this question of their container. Instance part's 
//  answer is always no --- instance cannot be keys!
//
//  Returns:
//
//      WBEM_E_INVALID_QUALIFIER
//
//*****************************************************************************
//
//  GetTotalRealLength
//
//  Computes how much space is needed to represent this instance if we were to
//  eliminate the holes between components (but without heap compaction).
//
//  Returns:
//
//      length_t:   how much the instance part will take after Compact.
//
//*****************************************************************************
//
//  Compact
//
//  Removes all holes between components by moving their memory blocks
//  together.
//
//*****************************************************************************
//
//  ReallocAndCompact
//
//  Compacts (see Compact) and grows the memory block to a given size, possibly
//  reallocating it.
//
//  Parameters:
//
//      length_t nNewTotalLength        Required length of the memory block
//
//*****************************************************************************
//
//  ExtendHeapSize, ReduceHeapSize
//
//  Heap container functionality. See CFastHeapContainer in fastheap.h for info
//
//*****************************************************************************
//
//  ExtendQualifierSetSpace, ReduceQualifierSetSpace
//
//  Qualifier set container functionality. See CQualifierSetConrainer in 
//  fastqual.h for info.
//
//*****************************************************************************
//
//  ExtendDataTableSpace, ReduceDataTableSpace
//
//  Data table container functionality. See CDataTableContainer in fastprop.h
//  for info.
//
//*****************************************************************************
//
//  ExtendQualifierSetListSpace, ReduceQualifierSetListSpace
//
//  Qualifier set list (property qualifier sets) container functionality. See
//  CQualifierSetListContainer in fastqual.h for info.
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not a localization bit has been set.  The localization
//	bit is set in the instance part header.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL	TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the instance part header. This bit is not
//	written out by Unmerge.
//
//  PARAMETERS:
//
//      BOOL	TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************

class COREPROX_POLARITY CInstancePart : public CHeapContainer, 
                      public CDataTableContainer,
                      public CQualifierSetContainer,
                      public CQualifierSetListContainer
{

public:
    CInstancePartContainer* m_pContainer;

// The data in this structure is unaligned
#pragma pack(push, 1)
    struct CInstancePartHeader
    {
        length_t nLength; 
        BYTE fFlags;
        heapptr_t ptrClassName;
        //short nProps; // used for static operations only
        //offset_t nHeapOffset; // used for static operations only
    };
#pragma pack(pop)

	CInstancePartHeader*	m_pHeader;

public:
    CDataTable m_DataTable;
    CInstanceQualifierSet m_Qualifiers;
    CInstancePropertyQualifierSetList m_PropQualifiers;
    CFastHeap m_Heap;

public:
    CInstancePart() : m_Qualifiers(1){}
     void SetData(LPMEMORY pStart, 
        CInstancePartContainer* pContainer, CClassPart& ClassPart);

	 HRESULT IsValidInstancePart( CClassPart* pClassPart );

     LPMEMORY GetStart() {return LPMEMORY(m_pHeader);}
     static int GetLength(LPMEMORY pStart) 
    {
        return ((CInstancePartHeader*)pStart)->nLength;
    }
     int GetLength() {return m_pHeader->nLength;}
     void Rebase(LPMEMORY pNewMemory);

public:
     HRESULT GetActualValue(CPropertyInformation* pInfo, CVar* pVar);
     HRESULT SetActualValue(CPropertyInformation* pInfo, CVar* pVar);
     HRESULT GetObjectQualifier(LPCWSTR wszName, CVar* pVar, 
        long* plFlavor);
     HRESULT SetInstanceQualifier(LPCWSTR wszName, CVar* pVar, 
        long lFlavor);
     HRESULT SetInstanceQualifier( LPCWSTR wszName, long lFlavor,
		 CTypedValue* pTypedValue );
     HRESULT GetQualifier(LPCWSTR wszName, CVar* pVar, 
        long* plFlavor, CIMTYPE* pct = NULL);
    HRESULT GetQualifier( LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedVal,
						CFastHeap** ppHeap, BOOL fValidateSet );

	BOOL IsLocalized( void )
	{
		return m_pHeader->fFlags & WBEM_FLAG_INSTANCEPART_LOCALIZATION_MASK;
	}

	void SetLocalized( BOOL fLocalized )
	{
		m_pHeader->fFlags &= ~WBEM_FLAG_INSTANCEPART_LOCALIZATION_MASK;
		m_pHeader->fFlags |= ( fLocalized ? WBEM_FLAG_INSTANCEPART_LOCALIZED :
								WBEM_FLAG_INSTANCEPART_NOT_LOCALIZED );
	}

public:
     static LPMEMORY GetDataTableData(LPMEMORY pStart)
    {
        return pStart + sizeof(CInstancePartHeader);
    }
public:
     static length_t ComputeNecessarySpace(CClassPart* pClassPart);
     LPMEMORY Create(LPMEMORY pStart, CClassPart* pClassPart,
        CInstancePartContainer* pContainer);

     BOOL TranslateToNewHeap(CClassPart& ClassPart,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap);

    LPMEMORY CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pDest);

    void DeleteProperty(CPropertyInformation* pInfo);
    LPMEMORY ConvertToClass(CClassPart& ClassPart, length_t nLen, 
                                        LPMEMORY pMemory);

public: // container functionality

    CFastHeap* GetHeap() {return &m_Heap;}
    HRESULT CanContainKey() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainSingleton() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainAbstract( BOOL fValue ) {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainDynamic() {return WBEM_E_INVALID_QUALIFIER;}
    BOOL CanHaveCimtype(LPCWSTR) {return FALSE;}
    IUnknown* GetWbemObjectUnknown() 
        {return m_pContainer->GetInstanceObjectUnknown();}

     length_t GetTotalRealLength()
    {
        return sizeof(CInstancePartHeader) + m_Qualifiers.GetLength() + 
            m_PropQualifiers.GetLength() + m_DataTable.GetLength() + m_Heap.GetLength();
    }

     void Compact( bool bTrim = true );
     BOOL ReallocAndCompact(length_t nNewTotalLength);

    BOOL ExtendHeapSize(LPMEMORY pStart, length_t nOldLength, length_t nExtra);
    void ReduceHeapSize(LPMEMORY pStart, length_t nOldLength, 
        length_t nDecrement){}
        
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nNewLength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement){}

    BOOL ExtendDataTableSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nNewLength){ return TRUE; } // never happens
    void ReduceDataTableSpace(LPMEMORY pOld, length_t nOldLength,
        length_t nDecrement){} // never happens
     void SetDataLength(length_t nDataLength){} // never happens

    BOOL ExtendQualifierSetListSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nNewLength);
    void ReduceQualifierSetListSpace(LPMEMORY pOld, length_t nOldLength, 
        length_t nDecrement){}

    CDataTable* GetDataTable() {return &m_DataTable;}
    LPMEMORY GetQualifierSetStart() {return m_Qualifiers.GetStart();}
    LPMEMORY GetQualifierSetListStart() {return m_PropQualifiers.GetStart();}
};

//*****************************************************************************
//*****************************************************************************
//
//  class CWbemInstance
//
//  Represents an WBEM instance. It is derived from CWbemObject (fastobj.h) and
//  much of the functionality is inherited from it.
//
//  The memory block of CWbemInstance consists of three parts:
//
//  1) Decoration part, containing the origin information for the object. It is
//      modeled by CDecorationPart class (see fastobj.h). m_DecorationPart 
//      member maps it.
//
//  2) Class part, containing the definition of the class, as described in 
//      CClassPart (see fastcls.h). m_ClassPart member maps it.
//
//  3) Instance part, containing all the instance data as descrined in 
//      CInstancePart (above). m_InstancePart maps it.
//
//  Here, we do not re-describe the methods implemented in CWbemObject, just the
//  ones implemented in this class.
//
//*****************************************************************************
//
//  SetData
//
//  Initialization function
//
//  Parameters:
//
//      LPMEMORY pStart         The start of the memory block
//      int nTotalLength        The length of the memory block.
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      length_t:       the length of the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object that its memory block has moved.
//
//  Parameters:
//
//      LPMEMORY pBlock     The new location of the memory block
//
//*****************************************************************************
//
//  GetProperty
//
//  Gets the value of the property referenced
//  by a given CPropertyInformation structure (see fastprop.h). CWbemObject
//  can obtain this structure from the CClassPart it can get from GetClassPart,
//  so these two methods combined give CWbemObject own methods full access to
//  object properties, without knowing where they are stored.
//
//  Parameters:
//
//      IN CPropertyInformation* pInfo  The information structure for the 
//                                      desired property.
//      OUT CVar* pVar                  Destination for the value. Must NOT
//                                      already contain a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      (No errors can really occur at this stage, since the property has 
//      already been "found").
//
//*****************************************************************************
//
//  GetClassPart
//
//  Returns the pointer to the m_ClassPart
//
//  Returns:
//
//      CClassPart*: pointer to the class part describing out class.
//
//*****************************************************************************
//
//  GetProperty
//
//  Gets the value of the property referenced
//  by a given CPropertyInformation structure (see fastprop.h). CWbemObject
//  can obtain this structure from the CClassPart it can get from GetClassPart,
//  so these two methods combined give CWbemObject own methods full access to
//  object properties, without knowing where they are stored.
//
//  Parameters:
//
//      IN CPropertyInformation* pInfo  The information structure for the 
//                                      desired property.
//      OUT CVar* pVar                  Destination for the value. Must NOT
//                                      already contain a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      (No errors can really occur at this stage, since the property has 
//      already been "found").
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the proeprty to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      CPropertyInformation*	pInfo - Identifies property to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required. 
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetProperty
//
//  Returns the value of a given property.
//
//  Parameters:
//
//      IN LPCWSTR wszName      The name of the property to access.
//      OUT CVar* pVar          Destination for the value. Must not already
//                              contain a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  SetPropValue
//
//  Sets the value of the property. 
//
//  Parameters:
//
//      IN LPCWSTR wszProp       The name of the property to set.
//      IN CVar *pVal           The value to store in the property.
//      IN CIMTYPE ctType       Should be 0
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//      WBEM_E_TYPE_MISMATCH     The value does not match the property type
//
//*****************************************************************************
//
//  SetPropQualifier
//
//  Sets the value of a given qualifier on a given property.
//
//  Parameters:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      IN long lFlavor         The flavor for the qualifier (see fastqual.h)
//      IN CVar *pVal           The value of the qualifier
//
//  Returns:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property.
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  GetPropQualifier
//
//  Retrieves the value of a given qualifier on a given property.
//
//  Parameters:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      OUT CVar* pVar          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//  Returns:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property or no such qualifier.
//
//*****************************************************************************
//
//  GetQualifier
//
//  Retrieves a qualifier from the instance itself.
//
//  Parameters:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve.
//      OUT CVar* pVal          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//		IN BOOL fLocalOnly		Only get locals (default is TRUE)
//  Returns:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such qualifier.
//
//*****************************************************************************
//
//  GetNumProperties
//
//  Retrieves the number of properties in the object
//
//  Returns:
//
//      int:
//
//*****************************************************************************
//
//  GetPropName
//
//  Retrieves the name of the property at a given index. This index has no 
//  meaning except inthe context of this enumeration. It is NOT the v-table
//  index of the property.
//
//  Parameters:
//
//      IN int nIndex        The index of the property to retrieve. Assumed to
//                           be within range (see GetNumProperties).
//      OUT CVar* pVar       Destination for the name. Must not already contain
//                           a value.
//
//*****************************************************************************
//
//  IsKeyed
//
//  Verifies if this class has keys.
//
//  Returns:
//
//      BOOL:   TRUE if the object either has 'key' properties or is singleton.
//
//*****************************************************************************
//
//  GetRelPath
//
//  Returns the relative path to the instance, or NULL if some of the key
//  values are not filled in or if the class is not keyed.
//  
//  Returns:
//
//      LPCWSTR: the newnely allocated string containing the path or NULL on 
//              errors. The caller must delete this string.
//
//*****************************************************************************
//
//  Decorate
//
//  Sets the origin information for the object.
//
//  Parameters:
//
//      LPCWSTR wszServer       the name of the server to set.
//      LPCWSTR wszNamespace    the name of the namespace to set.
//
//*****************************************************************************
//
//  Undecorate
//
//  Removes the origin informaiton from the object
//
//*****************************************************************************
//
//  GetGenus
//
//  Retrieves the genus of the object.
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetClassName
//
//  Retrieves the class name of the object
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  GetDynasty
//
//  Retrieves the dynasty of the object, i.e. the name of the top-level class
//  its class is derived from.
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  GetSuperclassName
//
//  Retrieves the parent class name of the object
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class is a top-levle class.
//
//*****************************************************************************
//
//  GetPropertyCount
//
//  Retrieves the number of proerpties in the object
//
//  Parameters:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  Returns:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  GetIndexedProps
//
//  Returns the array of the names of all the proeprties that are indexed.
//
//  Parameters:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyProps
//
//  Returns the array of the names of all the proeprties that are keys.
//
//  Parameters:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyOrigin
//
//  Returns the name of the class of origin of the keys.
//
//  PARAMETERS:
//
//      OUT CWString& wsClass       Destination for the name.
//
//*****************************************************************************
//
//  GetLimitedVersion
//
//  Produces a new CWbemInstance based on this one and a limitation map 
//  (obtained from CWbemClass::MapLimitation, see fastcls.h).
//
//  PARAMETERS:
//
//      IN CLimitationMapping* pMap     The map to use to limit the properties
//                                      and qualifiers to use in the new
//                                      instance.
//      OUT CWbemInstance** ppNewInst    Destination for the new instance. May
//                                      not be NULL. The caller is responsible
//                                      for calling Release on this pointer 
//                                      when no longer needed.
//  RETURNS:
//
//      WBEM_S_NO_ERROR            On success
//      WBEM_E_FAILED              On errors (none to date).
//
//*****************************************************************************
//
//  InitializePropQualifierSet
//
//  Instance property qualifier sets take several tricky arguments during
//  initialization. This function takes care of initializing an instance 
//  property qualifier set.
//
//  Parameters I:
//
//      CPropertyInformation* pInfo         Property information structure.
//      CInstancePropertyQualifierSet& IPQS Qualifier set to initialize.
//
//  Parameters II:
//
//      LPCWSTR wszProp                     Property name.
//      CInstancePropertyQualifierSet& IPQS Qualifier set to initialize.
//
//  Returns:
//
//      WBEM_S_NO_ERROR          On success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  Validate
//
//  Verifies that all the properties that must have non-null values do. Such
//  properties include those marked with 'key', 'index', or 'not_null' 
//  qualifiers.
//
//  Returns:
//
//      WBEM_S_NO_ERROR          On success
//      WBEM_E_ILLEGAL_NULL      One of the non-null properties is null.
//
//*****************************************************************************
//
//  static EstimateInstanceSpace
//
//  Estimates the amount of space needed to represent an empty instance of a 
//  given class.
//
//  Parameters:
//
//      CClassPart& ClassPart           The class definition
//      CDecorationPart* pDecoration    Origin info to use on the instance. If
//                                      NULL, undecorated space is estimated.
//  Returns:
//
//      length_t    (over-)estimate on the amount of space.
//
//*****************************************************************************
//
//  InitEmptyInstance
//
//  Creates an empty instance of a given class on a given memory block and sets
//  this object to point to that instance.
//
//  Parameters:
//
//      CClassPart& ClassPart           The class definition.
//      LPMEMORY pStart                 The memory block to create on.
//      int nAllocatedLength            Allocated size of the block
//      CDecorationPart* pDecoration    Origin information to use. If NULL, 
//                                      the instance is created undecorated.
//
//*****************************************************************************
//
//  EstimateUnmergeSpace
//
//  When an instance is stored into the database, only its instance part is
//  written. Thus, this function returns the size of the instance part.
//
//  Returns:
//
//      length_t:  the number of bytes needed in the database for this instance
//
//*****************************************************************************
//
//  Unmerge
//
//  When an instance is stored into the database, only its instance part is
//  written. This function writes the database representation of the instance
//  to a memory block. Before doing so, it completely compacts the heap.
//
//  Parameters:
//
//      LPMEMORY pStart         The memory block to write to. Assumed to be
//                              large enough (see EstimateUnmergeSpace).
//      int nAllocatedLength    Allocated length of the block.
//  
//  Returns:
//
//      length_t:   the length of the data written
//
//*****************************************************************************
//
//  static CreateFromBlob
//
//  Helper function. Given a class an database representation of the instance
//  (instance part), creates an instance object. Allocates memory for the block
//
//  Parameters:
//
//      CWbemClass* pClass       The class definition to use
//      LPMEMORY pInstPart      The instance data (as CInstancePart describes)
//
//  Returns;
//
//      CWbemInstance*:  the new instance object or NULL on errors. The caller
//          must delete this object when no longer needed.
//
//*****************************************************************************
//
//  InitNew
//
//  A wrapper for InitEmptyInstance. Allocates enough memory for a new instance
//  of a given class, creates the appropriate representation and attaches us
//  to it.
//
//  Parameters:
//
//      CWbemClass* pClass               The class definition
//      int nExtraMem                   Extra padding to allocate. This is for
//                                      optimization purposes only.
//      CDecorationPart* pDecoration    Origin information to use. If NULL, the
//                                      instance is created undecorated.
//  Returns:
//
//      BOOL:   FALSE if the class is not a valid one, TRUE on success
//
//*****************************************************************************
//
//  ClearCachedKey
//
//  Clears the value of the instance "key string" that the instance keeps
//  cached. The next time GetKey is called, the "key string" will be recomputed
//  from scratch.
//
//*****************************************************************************
//
//  GetKeyStr
//
//  Computes the "key string" for the instance. This is what the database
//  engine uses to order instances. 
//
//  Returns:
//
//      LPWSTR: the key string. Must be deleted by the caller.
//
//*****************************************************************************
//
//  GetKey
//
//  Retrieves the "key string" for the instance in the form of a CVar. This
//  function caches the string and does not recompute it until ClearCachedKey
//  is called.
//
//  Returns:
//
//      CVar*; containes the key string. THIS IS AN INTERNAL POINTER AND SHOULD
//          NOT BE MODIFIED OR DELETED.
//
//*****************************************************************************
//
//  Reparent
//
//  Reparents the supplied instance.  We do this by spawning an instance from
//	the supplied class and copying values for all local properties, all and all
//	local qualifiers (instance and property).
//
//  PARAMETERS:
//
//      IN CWbemClass* pNewParent	IWbemClassObject for new parent class.
//
//      OUT CWbemInstance** ppNewInst	Reparented instance.
//
//  RETURN VALUES:
//
//      HRESULT	WBEM_S_NO_ERROR if success.
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not any localization bits have been set.  Localization
//	bits can be in either the class part or the combined part.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL	TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the instance part.  This bit should not be
//	written out to the database.
//
//  PARAMETERS:
//
//      BOOL	TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************
//**************************** IWbemClassObject interface **********************
//
//  Most members of this interface are implemented in CWbemObject. Others are
//  implemented here. For the description of these methods and their return
//  values, see help
//
//*****************************************************************************

// The version of the array BLOB we are transfering during remote refresher operations
#define TXFRBLOBARRAY_PACKET_VERSION	1


class COREPROX_POLARITY CWbemInstance : public CWbemObject, 
                        public CInstancePartContainer, 
                        public CClassPartContainer
{
protected:
    length_t m_nTotalLength;
    CInstancePart m_InstancePart;
    CClassPart m_ClassPart;

    CVar m_CachedKey;

    friend class CWbemClass;
public:
    CWbemInstance() 
        : m_ClassPart(), m_InstancePart(), 
          CWbemObject(m_InstancePart.m_DataTable, m_InstancePart.m_Heap,
                        m_ClassPart.m_Derivation)
    {}
    ~CWbemInstance()
    {
    }
     void SetData(LPMEMORY pStart, int nTotalLength);
	 void SetData( LPMEMORY pStart, int nTotalLength, DWORD dwBLOBStatus );
     LPMEMORY GetStart() {return m_DecorationPart.GetStart();}
     length_t GetLength() {return m_nTotalLength;}
     void Rebase(LPMEMORY pMemory);

	 // Overrides CWbemObject implementation
	HRESULT WriteToStream( IStream* pStream );
	HRESULT GetMaxMarshalStreamSize( ULONG* pulSize );

protected:
    DWORD GetBlockLength() {return m_nTotalLength;}
    HRESULT GetProperty(CPropertyInformation* pInfo, CVar* pVar)
    {
		HRESULT	hr;

		// Check for allocation failures
        if(m_InstancePart.m_DataTable.IsDefault(pInfo->nDataIndex))
		{
			hr = m_ClassPart.GetDefaultValue(pInfo, pVar);
		}
        else
		{
            hr = m_InstancePart.GetActualValue(pInfo, pVar); 
		}
            
        return hr;
    }  

    CClassPart* GetClassPart() {return &m_ClassPart;}
     HRESULT InitializePropQualifierSet(
                                CPropertyInformation* pInfo,
                                CInstancePropertyQualifierSet& IPQS);

     HRESULT InitializePropQualifierSet(LPCWSTR wszProp, 
                                        CInstancePropertyQualifierSet& IPQS);

	 // _IWmiObject Support

	 BOOL IsDecorationPartAvailable( void )
	 {
		 // Must have the part
		 return ( m_dwInternalStatus & WBEM_OBJ_DECORATION_PART );
	 }

	 BOOL IsInstancePartAvailable( void )
	 {
		 // Must have the part
		 return ( m_dwInternalStatus & WBEM_OBJ_INSTANCE_PART );
	 }

	 BOOL IsClassPartAvailable( void )
	 {
		 // Must have the part
		 return ( m_dwInternalStatus & WBEM_OBJ_CLASS_PART );
	 }

	 BOOL IsClassPartInternal( void )
	 {
		 // Must have the part and it must be internal
		 return (	(	m_dwInternalStatus & WBEM_OBJ_CLASS_PART	)
				&&	(	m_dwInternalStatus & WBEM_OBJ_CLASS_PART_INTERNAL	)	);
	 }

	 BOOL IsClassPartShared( void )
	 {
		 // Must have the part and it must be shared
		 return (	(	m_dwInternalStatus & WBEM_OBJ_CLASS_PART	)
				&&	(	m_dwInternalStatus & WBEM_OBJ_CLASS_PART_SHARED	)	);
	 }

public:
     HRESULT GetNonsystemPropertyValue(LPCWSTR wszName, CVar* pVar)
    {
        CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
        if(pInfo == NULL) return WBEM_E_NOT_FOUND;
        return GetProperty(pInfo, pVar);
    }
    HRESULT GetProperty(LPCWSTR wszName, CVar* pVal)
    {
        HRESULT hres = GetSystemPropertyByName(wszName, pVal);
        if(hres == WBEM_E_NOT_FOUND)
            return GetNonsystemPropertyValue(wszName, pVal);
        else
            return hres;
    }
    HRESULT GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType, 
							long* plFlavor = NULL);
    HRESULT GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                   long* plFlags);

    HRESULT SetPropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType);
    HRESULT GetQualifier(LPCWSTR wszName, CVar* pVal, long* plFlavor = NULL, CIMTYPE* pct = NULL)
    {
		//	We may want to separate this later...however for now, we'll get
		//	local and propagated values.

		return m_InstancePart.GetQualifier(wszName, pVal, plFlavor, pct);

//		if ( fLocalOnly )
//		{
//			return m_InstancePart.GetObjectQualifier(wszName, pVal, plFlavor);
//		}
//		else
//		{
//			return m_InstancePart.GetQualifier(wszName, pVal, plFlavor);
//		}
    }

	HRESULT GetQualifier(LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedVal, CFastHeap** ppHeap,
						BOOL fValidateSet )
	{
		return m_InstancePart.GetQualifier( wszName, plFlavor, pTypedVal, ppHeap, fValidateSet );
	}

    HRESULT SetQualifier(LPCWSTR wszName, CVar* pVal, long lFlavor = 0)
    {
        if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        return m_InstancePart.SetInstanceQualifier(wszName, pVal, lFlavor);
    }

    HRESULT SetQualifier( LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue )
    {
        if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        return m_InstancePart.SetInstanceQualifier(wszName, lFlavor, pTypedValue);
    }

    HRESULT GetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, CVar* pVar,
        long* plFlavor = NULL, CIMTYPE* pct = NULL)
    {
        CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszProp);
        if(pInfo == NULL) return WBEM_E_NOT_FOUND;
        return GetPropQualifier(pInfo, wszQualifier, pVar, plFlavor, pct);
    }

    HRESULT GetPropQualifier(CPropertyInformation* pInfo, 
        LPCWSTR wszQualifier, CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);

    HRESULT GetPropQualifier(LPCWSTR wszName, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet)
    {
        CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
        if(pInfo == NULL) return WBEM_E_NOT_FOUND;
        return GetPropQualifier( pInfo, wszQualifier, plFlavor, pTypedVal, ppHeap, fValidateSet );
    }

    HRESULT GetPropQualifier(CPropertyInformation* pInfo,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet);

    HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL);
    HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet);
    HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal);
    HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal);

	BOOL IsLocalized( void );
	void SetLocalized( BOOL fLocalized );

     int GetNumProperties()
    {
        return m_ClassPart.m_Properties.GetNumProperties();
    }
    HRESULT GetPropName(int nIndex, CVar* pVal)
    {
		// Check for allocation failures
        if ( !m_ClassPart.m_Heap.ResolveString(
				 m_ClassPart.m_Properties.GetAt(nIndex)->ptrName)->
					StoreToCVar(*pVal) )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

		return WBEM_S_NO_ERROR;
    }
/*
    static  void GetPropertyByLocation(CWbemClass* pClass,
        LPMEMORY pInst, CPropertyLocation* pLoc, CVar* pVar)
    {
        LPMEMORY pDataTableData = CInstancePart::GetDataTableData(pInst);
        CInstancePart::CInstancePartHeader* pHeader = 
            (CInstancePart::CInstancePartHeader*)pInst;
        CNullnessTable* pNullness = (CNullnessTable*)pDataTableData;
        if(!pNullness->GetBit(pLoc->nDataIndex, e_DefaultBit))
        {
            pClass->GetProperty(pLoc, pVar);
        }
        else if(!pNullness->GetBit(pLoc->nDataIndex, e_NullnessBit))
        {
            pVar->SetAsNull();
        }
        else
        {
            LPMEMORY pActualData = pDataTableData + 
                CNullnessTable::GetNecessaryBytes(pHeader->nProps) + 
                pLoc->nDataOffset;

            CUntypedValue* pValue = (CUntypedValue*)pActualData;
            CFastHeap Heap;
            Heap.SetData(pInst + pHeader->nHeapOffset, NULL);
            pValue->StoreToCVar(pLoc->nType, *pVar, &Heap);
        }
    }
 */

    HRESULT Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace);
    void Undecorate();
    BOOL IsKeyed() {return m_ClassPart.IsKeyed();}
    LPWSTR GetRelPath( BOOL bNormalized=FALSE );

	virtual HRESULT	IsValidObj( void );

    HRESULT Validate();
    BOOL IsValidKey(LPCWSTR wszKey);
    HRESULT PlugKeyHoles();

    void CompactAll()
    {
        m_InstancePart.Compact();
    }

    void CompactClass();

    HRESULT CopyBlob(LPMEMORY pBlob, int nLength);
    HRESULT CopyBlobOf(CWbemObject* pSource);
    HRESULT CopyTransferBlob(long lBlobType, long lBlobLen, BYTE* pBlob);
    HRESULT CopyActualTransferBlob(long lBlobLen, BYTE* pBlob);
    HRESULT GetTransferBlob(long *plBlobType, long *plBlobLen, 
                                /* CoTaskAlloced! */ BYTE** ppBlob);
	void GetActualTransferBlob( BYTE* pBlob );

	// Support for remotely refreshable enumerations
    static long GetTransferArrayHeaderSize( void )
	{ return 2*sizeof(long); }

	// A RemoteRefresher transfer blob consists of the datatable
	// qualifier sets, used heap data and a long describing the
	// length of the used heap data.

	// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
	// signed/unsigned 32-bit value.  We do not support length
	// > 0xFFFFFFFF so cast is ok.

	long GetActualTransferBlobSize( void )
	{ return (long) ( m_InstancePart.m_Heap.GetStart() + 
                    m_InstancePart.m_Heap.GetRealLength() - 
                    m_InstancePart.m_DataTable.GetStart() ); }

	long GetTransferBlobSize( void )
	{ return GetActualTransferBlobSize() + sizeof(long); }

	// A RemoteRefresher Transfer Array Blob is the regular BLOB
	// plus a long to hold the Blob size.
    long GetTransferArrayBlobSize( void )
	{ return GetTransferBlobSize() + sizeof(long); }

    static void WriteTransferArrayHeader( long lNumObjects, BYTE** ppBlob )
	{
		BYTE*	pTemp = *ppBlob;

		// Version
		*((UNALIGNED long*) pTemp) = TXFRBLOBARRAY_PACKET_VERSION;
		pTemp += sizeof(long);

		// Number of objects
		*((UNALIGNED long*) pTemp) = lNumObjects;

		// Reset the memory pointer
		*ppBlob = pTemp + sizeof(long);
	}

	HRESULT GetTransferArrayBlob( long lBloblen, BYTE** ppBlob, long* plBlobLen);

	static HRESULT CopyTransferArrayBlob(CWbemInstance* pInstTemplate, long lBlobType, long lBlobLen, 
											BYTE* pBlob, CFlexArray& apObj, long* plNumArrayObj );

    static  length_t EstimateInstanceSpace(CClassPart& ClassPart,
        CDecorationPart* pDecoration = NULL);

    HRESULT InitEmptyInstance(CClassPart& ClassPart, LPMEMORY pStart,
        int nAllocatedLength, CDecorationPart* pDecoration = NULL);

     length_t EstimateUnmergeSpace()
        {return m_InstancePart.GetLength();}
        
     HRESULT Unmerge(LPMEMORY pStart, int nAllocatedLength, length_t* pnUnmergedLength );

    static  CWbemInstance* CreateFromBlob(CWbemClass* pClass, 
                                               LPMEMORY pInstPart);

     HRESULT InitNew(CWbemClass* pClass, int nExtraMem = 0,
        CDecorationPart* pDecoration = NULL);




public:
     HRESULT GetClassName(CVar* pVar)
        {return m_ClassPart.GetClassName(pVar);}
     HRESULT GetSuperclassName(CVar* pVar)
        {return m_ClassPart.GetSuperclassName(pVar);}
     HRESULT GetDynasty(CVar* pVar);
     HRESULT GetPropertyCount(CVar* pVar)
        {return m_ClassPart.GetPropertyCount(pVar);}
     HRESULT GetGenus(CVar* pVar)
    {
        pVar->SetLong(WBEM_GENUS_INSTANCE);
        return WBEM_NO_ERROR;
    }

     void ClearCachedKey() { m_CachedKey.Empty(); }
    LPWSTR GetKeyStr();
     INTERNAL CVar* GetKey()
    {
        if(m_CachedKey.GetType() == VT_EMPTY)
        {
            LPWSTR wszKey = GetKeyStr();
            if(wszKey != NULL)
                m_CachedKey.SetBSTR(wszKey);
            else
                return NULL;
            delete [] wszKey;
        }
        return &m_CachedKey;
    } 

     BOOL GetIndexedProps(CWStringArray& awsNames)
        {return m_ClassPart.GetIndexedProps(awsNames);}
     BOOL GetKeyProps(CWStringArray& awsNames)
        {return m_ClassPart.GetKeyProps(awsNames);}
     HRESULT GetKeyOrigin(WString& wsClass)
        {return m_ClassPart.GetKeyOrigin( wsClass );}

    HRESULT GetLimitedVersion(IN CLimitationMapping* pMap, 
                              NEWOBJECT CWbemInstance** ppNewInst);

    HRESULT DeleteProperty(int nIndex);
    BOOL IsInstanceOf(CWbemClass* pClass);
    static HRESULT AsymmetricMerge(CWbemInstance* pOldInstance,
                                       CWbemInstance* pNewInstance);
    HRESULT ConvertToClass(CWbemClass* pClass, CWbemInstance** ppInst);

	HRESULT Reparent( CWbemClass* pNewParent, CWbemInstance** pNewInst );

    HRESULT FastClone( CWbemInstance* pInst );

public: // container functionaliy
	// Class Part can't change once its in an instance
    BOOL ExtendClassPartSpace(CClassPart* pPart, length_t nNewLength){ return TRUE; }
    void ReduceClassPartSpace(CClassPart* pPart, length_t nDecrement){}
    BOOL ExtendInstancePartSpace(CInstancePart* pPart, length_t nNewLength);
    void ReduceInstancePartSpace(CInstancePart* pPart, length_t nDecrement){}
    IUnknown* GetWbemObjectUnknown() {return (IUnknown*)(IWbemClassObject*)this;}
    IUnknown* GetInstanceObjectUnknown()  {return (IUnknown*)(IWbemClassObject*)this;}

    void ClearCachedKeyValue() {ClearCachedKey();}

	// Creates an instance with class data, and merges with it.
	HRESULT ConvertToMergedInstance( void );

public:
    STDMETHOD(GetQualifierSet)(IWbemQualifierSet** ppQualifierSet);
    STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
    STDMETHOD(Delete)(LPCWSTR wszName);

    //STDMETHOD(Get)(LPCWSTR wszName, long lFlags, VARIANT* pVal)
    //STDMETHOD(GetNames)(LPCWSTR wszQualifierName, long lFlags, VARIANT* pVal, 
    //                    SAFEARRAY** pNames)
    // STDMETHOD(GetType)(LPCWSTR wszPropName, long* plType, long* plFlags)
    //STDMETHOD(BeginEnumeration)(long lEnumFlags)
    //STDMETHOD(Next)(long lFlags, BSTR* pstrName, VARIANT* pVal)
    //STDMETHOD(EndEnumeration)()

    STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty, 
                                       IWbemQualifierSet** ppQualifierSet);
    STDMETHOD(Clone)(IWbemClassObject** ppCopy);
    STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax);
    STDMETHOD(SpawnDerivedClass)(long lFlags, IWbemClassObject** ppNewClass);
    STDMETHOD(SpawnInstance)(long lFlags, IWbemClassObject** ppNewInstance);

    STDMETHOD(GetMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                            IWbemClassObject** ppOutSig)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(PutMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                            IWbemClassObject* pOutSig)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(DeleteMethod)(LPCWSTR wszName)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(BeginMethodEnumeration)(long lFlags)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(NextMethod)(long lFlags, BSTR* pstrName, 
                       IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(EndMethodEnumeration)()
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(GetMethodQualifierSet)(LPCWSTR wszName, IWbemQualifierSet** ppSet)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(GetMethodOrigin)(LPCWSTR wszMethodName, BSTR* pstrClassName)
        {return WBEM_E_ILLEGAL_OPERATION;}

    STDMETHOD(SetInheritanceChain)(long lNumAntecedents, 
        LPWSTR* awszAntecedents)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(SetPropertyOrigin)(LPCWSTR wszPropertyName, long lOriginIndex)
        {return WBEM_E_ILLEGAL_OPERATION;}
    STDMETHOD(SetMethodOrigin)(LPCWSTR wszMethodName, long lOriginIndex)
        {return WBEM_E_ILLEGAL_OPERATION;}

	// _IWmiObject Methods
    STDMETHOD(SetObjectParts)( LPVOID pMem, DWORD dwMemSize, DWORD dwParts );
    STDMETHOD(GetObjectParts)( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed );

    STDMETHOD(StripClassPart)();

    STDMETHOD(GetClassPart)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed );
    STDMETHOD(SetClassPart)( LPVOID pClassPart, DWORD dwSize );
    STDMETHOD(MergeClassPart)( IWbemClassObject *pClassPart );

	STDMETHOD(ClearWriteOnlyProperties)(void);

	// _IWmiObject Methods
	STDMETHOD(CloneEx)( long lFlags, _IWmiObject* pDestObject );
    // Clones the current object into the supplied one.  Reuses memory as
	// needed

	STDMETHOD(CopyInstanceData)( long lFlags, _IWmiObject* pSourceInstance );
	// Copies instance data from source instance into current instance
	// Class Data must be exactly the same

    STDMETHOD(IsParentClass)( long lFlags, _IWmiObject* pClass );
	// Checks if the current object is a child of the specified class (i.e. is Instance of,
	// or is Child of )

    STDMETHOD(CompareDerivedMostClass)( long lFlags, _IWmiObject* pClass );
	// Compares the derived most class information of two class objects.

    STDMETHOD(GetClassSubset)( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass );
	// Creates a limited representation class for projection queries

    STDMETHOD(MakeSubsetInst)( _IWmiObject *pInstance, _IWmiObject** pNewInstance );
	// Creates a limited representation instance for projection queries
	// "this" _IWmiObject must be a limited class

	STDMETHOD(Merge)( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj );
	// Merges a blob with the current object memory and creates a new object

	STDMETHOD(ReconcileWith)( long lFlags, _IWmiObject* pNewObj );
	// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
	// is specified this will only perform a test

	STDMETHOD(Upgrade)( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild );
	// Upgrades class and instance objects

	STDMETHOD(Update)( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass );
	// Updates derived class object using the safe/force mode logic

	STDMETHOD(SpawnKeyedInstance)( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst );
	// Spawns an instance of a class and fills out the key properties using the supplied
	// path.

};

//#pragma pack(pop)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastinst.inc ===
//=============================================================================
//
//                              FASTINST.INC
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  This file implements inline functions for the classes related to instance 
//	representation in WbemObjects. The classes are defined in fastinst.h where
//	the documentation can be found.
//
//	This file is included from fastinst.h
//
//  See fastinst.h for all documentation.
//
//  Classes implemented: 
//      CInstancePart           Instance data.
//      CWbemInstance            Complete instance definition.
//      
//  History:
//
//      3/10/97     a-levn  Fully documented
//
//=============================================================================


//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastmeth.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTMETH.H

Abstract:

    This file defines the method class used in WbemObjects.

History:

    12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __WBEM_FASTMETHOD__H_
#define __WBEM_FASTMETHOD__H_

#include <fastqual.h>
#include <fastheap.h>

typedef enum {METHOD_SIGNATURE_IN = 0, METHOD_SIGNATURE_OUT = 1,
                METHOD_NUM_SIGNATURES} METHOD_SIGNATURE_TYPE;

// DEVNOTE:WIN64:SJS - This may be backwards incompatible, so we
// may have to manually unalign method stuff in the BLOB

struct COREPROX_POLARITY CMethodDescription
{
    heapptr_t m_ptrName;
    BYTE m_nFlags;
    classindex_t m_nOrigin;
    heapptr_t m_ptrQualifiers;
    heapptr_t m_aptrSigs[METHOD_NUM_SIGNATURES];

public:
    static BOOL CreateDerivedVersion(
								 UNALIGNED CMethodDescription* pSource,
								 UNALIGNED CMethodDescription* pDest,
                                 CFastHeap* pOldHeap, CFastHeap* pNewHeap);
    static BOOL CreateUnmergedVersion(
								 UNALIGNED CMethodDescription* pSource,
								 UNALIGNED CMethodDescription* pDest,
                                 CFastHeap* pOldHeap, CFastHeap* pNewHeap);
    static BOOL IsTouched( UNALIGNED CMethodDescription* pThis, CFastHeap* pHeap);
    static HRESULT AddText(UNALIGNED CMethodDescription* pThis, WString& wsText, CFastHeap* pHeap, long lFlags);

	// Accessors
	void SetSig( int nIndex, heapptr_t ptr );
	heapptr_t GetSig( int nIndex );
};

typedef UNALIGNED CMethodDescription* PMETHODDESCRIPTION;

class CMethodPart;
class COREPROX_POLARITY CMethodPartContainer
{
public:
    virtual BOOL ExtendMethodPartSpace(CMethodPart* pPart, 
        length_t nNewLength) = 0;
    virtual void ReduceMethodPartSpace(CMethodPart* pPart,
        length_t nDecrement) = 0;
    virtual classindex_t GetCurrentOrigin() = 0;
    virtual IUnknown* GetWbemObjectUnknown() = 0;
};
    
class CWbemObject;
class COREPROX_POLARITY CMethodPart : public CHeapContainer
{

protected:

	// DEVNOTE:WIN64:SJS - This may be backwards incompatible, so we
	// may have to manually unalign method stuff in the BLOB

    struct CHeader
    {
        length_t m_nLength;
        propindex_t m_nNumMethods;

		static LPMEMORY EndOf( UNALIGNED CHeader* pHeader );
    };
	
	typedef UNALIGNED CHeader* PMETHODPARTHDR;

	PMETHODPARTHDR m_pHeader;
    PMETHODDESCRIPTION m_aDescriptions;

    CFastHeap m_Heap;
    CMethodPartContainer* m_pContainer;
    CMethodPart* m_pParent;

protected:
    int FindMethod(LPCWSTR wszName);
    int GetNumMethods() {return m_pHeader->m_nNumMethods;}
    CCompressedString* GetName(int nIndex);
    HRESULT CreateMethod(LPCWSTR wszName, CWbemObject* pInSig,
                    CWbemObject* pOutSig);
    BOOL DoSignaturesMatch(int nIndex, METHOD_SIGNATURE_TYPE nSigType, 
                                    CWbemObject* pSig);

    HRESULT SetSignature(int nIndex, METHOD_SIGNATURE_TYPE nSigType, 
                                    CWbemObject* pSig);
    void GetSignature(int nIndex, int nSigType, CWbemObject** ppObj);
    void DeleteSignature(int nIndex, int nSigType);
    BOOL IsPropagated(int nIndex);
    BOOL DoesSignatureMatchOther(CMethodPart& OtherPart, int nIndex, 
                                        METHOD_SIGNATURE_TYPE nType);
    HRESULT CheckIds(CWbemClass* pInSig, CWbemClass* pOutSig);
	HRESULT	CheckDuplicateParameters( CWbemObject* pObjInParams, CWbemObject* pOutParams );
	HRESULT	ValidateOutParams( CWbemObject* pOutParams );

    friend class CMethodQualifierSetContainer;
    friend class CMethodQualifierSet;
public:
    void SetData(LPMEMORY pStart, CMethodPartContainer* pContainer,
                    CMethodPart* pParent = NULL);
    LPMEMORY GetStart() {return LPMEMORY(m_pHeader);}
    length_t GetLength() {return m_pHeader->m_nLength;}
    void Rebase(LPMEMORY pMemory);

    static length_t GetMinLength();
    static LPMEMORY CreateEmpty(LPMEMORY pStart);
    length_t EstimateDerivedPartSpace();
    LPMEMORY CreateDerivedPart(LPMEMORY pStart, length_t nAllocatedLength);
    length_t EstimateUnmergeSpace();
    LPMEMORY Unmerge(LPMEMORY pStart, length_t nAllocatedLength);
    static length_t EstimateMergeSpace(CMethodPart& Parent, CMethodPart& Child);
    static LPMEMORY Merge(CMethodPart& Parent, CMethodPart& Child, 
                            LPMEMORY pDest, length_t nAllocatedLength);

    static HRESULT Update(CMethodPart& Parent, CMethodPart& Child, long lFlags );
    
    void Compact();
    EReconciliation CanBeReconciledWith(CMethodPart& NewPart);
    EReconciliation ReconcileWith(CMethodPart& NewPart);
	EReconciliation CompareExactMatch( CMethodPart& thatPart );

    HRESULT CompareTo(long lFlags, CMethodPart& OtherPart);
    HRESULT SetMethodOrigin(LPCWSTR wszMethodName, long lOriginIndex);

public:
    HRESULT PutMethod(LPCWSTR wszName, long lFlags, CWbemObject* pInSig,
                        CWbemObject* pOutSig);
    HRESULT GetMethod(LPCWSTR wszName, long lFlags, CWbemObject** ppInSig,
                        CWbemObject** ppOutSig);
    HRESULT GetMethodAt(int nIndex, BSTR* pstrName, CWbemObject** ppInSig,
                        CWbemObject** ppOutSig);
    HRESULT DeleteMethod(LPCWSTR wszName);
    HRESULT GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet);
    HRESULT GetMethodOrigin(LPCWSTR wszName, classindex_t* pnIndex);

    HRESULT AddText(WString& wsText, long lFlags);
    HRESULT EnsureQualifier(CWbemObject* pOrig, LPCWSTR wszQual, CWbemObject** pObj);

    BOOL CMethodPart::IsTouched(LPCWSTR wszName, BOOL * pbValid);
    BOOL CMethodPart::IsTouched(int nIndex, BOOL * pbValid);
    
public:
    BOOL ExtendHeapSize(LPMEMORY pStart, length_t nOldLength, length_t nExtra);
    void ReduceHeapSize(LPMEMORY pStart, length_t nOldLength, 
        length_t nDecrement){}
    IUnknown* GetWbemObjectUnknown() 
        {return m_pContainer->GetWbemObjectUnknown();}

	HRESULT IsValidMethodPart( void );
    CFastHeap* GetHeap() {return &m_Heap;}

};

class COREPROX_POLARITY CMethodQualifierSetContainer : public CQualifierSetContainer
{
protected:
    CMethodPart* m_pPart;
    CMethodPart* m_pParent;
    WString m_wsMethodName;
    heapptr_t m_ptrParentSet;

    CBasicQualifierSet m_SecondarySet;
public:
    void SetData(CMethodPart* pPart, CMethodPart* pParent, 
                    LPCWSTR wszMethodName);

    CFastHeap* GetHeap() {return &m_pPart->m_Heap;}
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,length_t nNewlength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet, length_t nReduceBy){}
    IUnknown* GetWbemObjectUnknown() {return m_pPart->GetWbemObjectUnknown();}
    HRESULT CanContainKey() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainSingleton() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainDynamic() {return WBEM_E_INVALID_QUALIFIER;}
    HRESULT CanContainAbstract( BOOL fValue ) {return WBEM_E_INVALID_QUALIFIER;}
    BOOL CanHaveCimtype(LPCWSTR) {return FALSE;}
    LPMEMORY GetQualifierSetStart();

    CBasicQualifierSet* GetSecondarySet();
};

class COREPROX_POLARITY CMethodQualifierSet : public CClassQualifierSet
{
protected:
    CMethodQualifierSetContainer m_Container;
public:
    void SetData(CMethodPart* pPart, CMethodPart* pParent, 
                    LPCWSTR wszMethodName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastmeth.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTMETH.CPP

Abstract:

  This file defines the method class used in WbemObjects.

History:

  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
//#include <dbgalloc.h>
#include <stdio.h>
#include <wbemutil.h>
#include <fastall.h>

#include "fastmeth.h"
#include "olewrap.h"
#include <arrtempl.h>

void CMethodDescription::SetSig( int nIndex, heapptr_t ptr )
{
	PHEAPPTRT	pHeapPtrTemp = (PHEAPPTRT) &m_aptrSigs[nIndex];
    *pHeapPtrTemp = ptr;
}

heapptr_t CMethodDescription::GetSig( int nIndex )
{
	PHEAPPTRT	pHeapPtrTemp = (PHEAPPTRT) &m_aptrSigs[nIndex];
    return *pHeapPtrTemp;
}

BOOL CMethodDescription::CreateDerivedVersion(
                                            UNALIGNED CMethodDescription* pSource,
                                            UNALIGNED CMethodDescription* pDest,
                                            CFastHeap* pOldHeap,
                                            CFastHeap* pNewHeap)
{
    pDest->m_nFlags = WBEM_FLAVOR_ORIGIN_PROPAGATED;
    pDest->m_nOrigin = pSource->m_nOrigin;

    // This function assumes that no reallocations will occur, and that the supplied heap is sufficiently
    // large enough to handle the operation!

    // Check for allocation failure
    if ( !CCompressedString::CopyToNewHeap(pSource->m_ptrName, pOldHeap,
                                      pNewHeap, pDest->m_ptrName) )
    {
        return FALSE;
    }

    // Check for allocation failure
    if ( !pNewHeap->Allocate(
            CBasicQualifierSet::ComputeNecessarySpaceForPropagation(
                pOldHeap->ResolveHeapPointer(pSource->m_ptrQualifiers),
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS), pDest->m_ptrQualifiers) )
    {
        return FALSE;
    }


    CHeapPtr OldQuals(pOldHeap, pSource->m_ptrQualifiers);
    CHeapPtr NewQuals(pNewHeap, pDest->m_ptrQualifiers);

    // Check for allocation failure
    if ( CBasicQualifierSet::WritePropagatedVersion(&OldQuals,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS,
                &NewQuals, pOldHeap, pNewHeap) == NULL )
    {
        return FALSE;
    }

    // Check for allocation failure
    if ( !CEmbeddedObject::CopyToNewHeap(pSource->GetSig( METHOD_SIGNATURE_IN ),
            pOldHeap, pNewHeap, pDest->m_aptrSigs[METHOD_SIGNATURE_IN]) )
    {
        return FALSE;
    }

    // Check for allocation failure
    if ( !CEmbeddedObject::CopyToNewHeap(pSource->GetSig( METHOD_SIGNATURE_OUT ),
            pOldHeap, pNewHeap, pDest->m_aptrSigs[METHOD_SIGNATURE_OUT]) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CMethodDescription::CreateUnmergedVersion(
                                            UNALIGNED CMethodDescription* pSource,
                                            UNALIGNED CMethodDescription* pDest,
                                            CFastHeap* pOldHeap,
                                            CFastHeap* pNewHeap)
{
    pDest->m_nFlags = pSource->m_nFlags;
    pDest->m_nOrigin = pSource->m_nOrigin;

    // This function assumes that no reallocations will occur, and that the supplied heap is sufficiently
    // large enough to handle the operation!

    // Check for allocation failures
    if ( !CCompressedString::CopyToNewHeap(pSource->m_ptrName, pOldHeap,
                                       pNewHeap, pDest->m_ptrName) )
    {
        return FALSE;
    }

    // Check for allocation failures
    if ( !pNewHeap->Allocate(
            CBasicQualifierSet::ComputeUnmergedSpace(
            pOldHeap->ResolveHeapPointer(pSource->m_ptrQualifiers)), pDest->m_ptrQualifiers) )
    {
        return FALSE;
    }

    // Check for allocation failures
    if ( CBasicQualifierSet::Unmerge(
                pOldHeap->ResolveHeapPointer(pSource->m_ptrQualifiers), pOldHeap,
                pNewHeap->ResolveHeapPointer(pDest->m_ptrQualifiers), pNewHeap) == NULL )
    {
        return FALSE;
    }

    // Check for allocation failures
    if ( !CEmbeddedObject::CopyToNewHeap(pSource->GetSig( METHOD_SIGNATURE_IN ),
            pOldHeap, pNewHeap, pDest->m_aptrSigs[METHOD_SIGNATURE_IN] ) )
    {
        return FALSE;
    }

    // Check for allocation failures
    if ( !CEmbeddedObject::CopyToNewHeap(pSource->GetSig( METHOD_SIGNATURE_OUT ),
            pOldHeap, pNewHeap, pDest->m_aptrSigs[METHOD_SIGNATURE_OUT]) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CMethodDescription::IsTouched(
                                   UNALIGNED CMethodDescription* pThis,
								   CFastHeap* pHeap)
{
    if((pThis->m_nFlags & WBEM_FLAVOR_ORIGIN_PROPAGATED) == 0)
        return TRUE; // local

    return CBasicQualifierSet::HasLocalQualifiers(
        pHeap->ResolveHeapPointer(pThis->m_ptrQualifiers));
}

HRESULT CMethodDescription::AddText(
								 UNALIGNED CMethodDescription* pThis,
								 WString& wsText, CFastHeap* pHeap, long lFlags)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

	try
	{
		HRESULT hres = WBEM_S_NO_ERROR;
		wsText += L"\t";

		// Get the qualifiers
		// ==================

		hres = CBasicQualifierSet::GetText(
			pHeap->ResolveHeapPointer(pThis->m_ptrQualifiers),
			pHeap, lFlags, wsText);

		if ( FAILED( hres ) )
		{
			return hres;
		}

		wsText += L" ";

		// Look for the return type
		// ========================

		CEmbeddedObject* pEmbed = (CEmbeddedObject*)pHeap->ResolveHeapPointer(
									pThis->GetSig( METHOD_SIGNATURE_OUT ) );

		// Release going out of scope
		CWbemClass* pOutSig = (CWbemClass*)pEmbed->GetEmbedded();
		CReleaseMe  rmOut( (IWbemClassObject*) pOutSig );

		CVar vType;
		if(pOutSig && SUCCEEDED(pOutSig->GetPropQualifier(L"ReturnValue", TYPEQUAL,
							&vType)) && vType.GetType() == VT_BSTR)
		{
			CType::AddPropertyType(wsText, vType.GetLPWSTR());
		}
		else
		{
			wsText += L"void";
		}

		// Write the name
		// ==============

		wsText += " ";
		wsText += pHeap->ResolveString(pThis->m_ptrName)->CreateWStringCopy();
		wsText += "(";

		// Write the params
		// ================

		pEmbed = (CEmbeddedObject*)pHeap->ResolveHeapPointer(
											pThis->GetSig( METHOD_SIGNATURE_IN ) );

		// Release going out of scope
		CWbemClass* pInSig = (CWbemClass*)pEmbed->GetEmbedded();
		CReleaseMe  rmIn( (IWbemClassObject*) pInSig );

		int nIndex = 0;
		BOOL bFirst = TRUE;
		BOOL bFound = TRUE;
		while(bFound)
		{
			bFound = FALSE;
			if(pInSig != NULL)
			{
				WString wsParam;

				// We should write out duplicate parameters as in,out this time
				hres = pInSig->WritePropertyAsMethodParam(wsParam, nIndex, lFlags, pOutSig, FALSE);
				if(FAILED(hres))
				{
					if(hres != WBEM_E_NOT_FOUND)
						return hres;
				}
				else
				{
					if(!bFirst)
						wsText += L", ";
					bFirst = FALSE;
					bFound = TRUE;
					wsText += wsParam;
				}
			}
			if(pOutSig != NULL)
			{
				WString wsParam;

				// This time, we want to ignore duplicate parameters
				hres = pOutSig->WritePropertyAsMethodParam(wsParam, nIndex, lFlags, pInSig, TRUE);
				if(FAILED(hres))
				{
					if(hres != WBEM_E_NOT_FOUND)
						return hres;
				}
				else
				{
					if(!bFirst)
						wsText += L", ";
					bFirst = FALSE;
					bFound = TRUE;
					wsText += wsParam;
				}
			}
			nIndex++;
		}

		wsText += ");\n";

		return WBEM_S_NO_ERROR;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}















LPMEMORY CMethodPart::CHeader::EndOf( UNALIGNED CHeader* pHeader )
{
	return ( (LPMEMORY) pHeader) + sizeof(CHeader);
}

void CMethodPart::SetData(LPMEMORY pStart, CMethodPartContainer* pContainer,
                    CMethodPart* pParent)
{
    m_pContainer = pContainer;
    m_pParent = pParent;
    m_pHeader = (PMETHODPARTHDR)pStart;
    m_aDescriptions = (PMETHODDESCRIPTION) CMethodPart::CHeader::EndOf(m_pHeader);
    m_Heap.SetData((LPMEMORY)(m_aDescriptions + GetNumMethods()), this);
}

void CMethodPart::Rebase(LPMEMORY pStart)
{
    m_pHeader = (PMETHODPARTHDR)pStart;
    m_aDescriptions = (PMETHODDESCRIPTION) CMethodPart::CHeader::EndOf(m_pHeader);
    m_Heap.Rebase((LPMEMORY)(m_aDescriptions + GetNumMethods()));
}

BOOL CMethodPart::ExtendHeapSize(LPMEMORY pStart, length_t nOldLength,
                    length_t nExtra)
{
    // Extend our own size by as much
    // ==============================

    BOOL fReturn = m_pContainer->ExtendMethodPartSpace(this, GetLength() + nExtra);

    // Check for allocation failure
    if ( fReturn )
    {
        m_pHeader->m_nLength += nExtra;
    }

    return fReturn;
}

int CMethodPart::FindMethod(LPCWSTR wszName)
{
    for(int i = 0; i < GetNumMethods(); i++)
    {
        CCompressedString* pcs =
            m_Heap.ResolveString(m_aDescriptions[i].m_ptrName);
        if(pcs->CompareNoCase(wszName) == 0)
            return i;
    }
    return -1;
}

CCompressedString* CMethodPart::GetName(int nIndex)
{
    return m_Heap.ResolveString(m_aDescriptions[nIndex].m_ptrName);
}

HRESULT CMethodPart::EnsureQualifier(CWbemObject* pOrig, LPCWSTR wszQual, CWbemObject** ppNew )
{
    // If NULL, we're still ok.  The parameter will just be ignored.
    if(pOrig == NULL)
    {
        *ppNew = NULL;
        return WBEM_S_NO_ERROR;
    }

    IWbemClassObject* pNewOle;
    HRESULT hr = pOrig->Clone(&pNewOle);

    if ( SUCCEEDED( hr ) )
    {

        CWbemClass* pNew = (CWbemClass*)pNewOle;

        // Make sure we got the qualifier
        hr = pNew->EnsureQualifier(wszQual);

        if ( SUCCEEDED( hr ) )
        {
            *ppNew = pNew;
        }
        else
        {
            pNew->Release();
        }

    }

    return hr;
}

HRESULT CMethodPart::CheckDuplicateParameters( CWbemObject* pInParams, CWbemObject* pOutParams )
{
    CFixedBSTRArray aExcludeNames;

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        // If either one is NULL, we can safely assume no duplicates

        if ( NULL != pInParams && NULL != pOutParams )
        {

            // Allocate an array of qualifier names excluded from qualifier set
            // comparisons.  In this case, we only ignore "in" and "out" qualifiers.

            aExcludeNames.Create( 2 );
            aExcludeNames[0] = COleAuto::_SysAllocString( L"in" );
            aExcludeNames[1] = COleAuto::_SysAllocString( L"out" );

            DWORD   dwNumInParams = pInParams->GetNumProperties(),
                    dwNumOutParams = pOutParams->GetNumProperties();

            CVar    vPropName,
                    vTemp;

            // We should do this for the least number of parameters possible
            CWbemObject*    pLeastPropsObject = ( dwNumInParams <= dwNumOutParams ?
                                                    pInParams : pOutParams );
            CWbemObject*    pMostPropsObject = ( dwNumInParams <= dwNumOutParams ?
                                                    pOutParams : pInParams );
            DWORD           dwLeastNumParams =  min( dwNumInParams, dwNumOutParams );

            // Enum the properties, and for each one that is in both the in and
            // out lists, we MUST have exact matches for the qualifier sets, in and
            // out qualifiers notwithstanding

            for ( int i = 0; SUCCEEDED(hr) && i < dwLeastNumParams; i++ )
            {
                // Pull out the property name (use the least number of params object)
                hr = pLeastPropsObject->GetPropName( i, &vPropName );

                if ( SUCCEEDED( hr ) )
                {
                    // Try to get the property from the other list (i.e. object with most params)
					// We ignore system properties - those with "_" parameters
                    if ( SUCCEEDED( pMostPropsObject->GetProperty( (LPCWSTR) vPropName, &vTemp ) ) &&
						!CSystemProperties::IsPossibleSystemPropertyName( (LPCWSTR) vPropName ) )
                    {
                        // Get the qualifier sets from each property
                        // Note that since we know the property is in each
                        // object we no longer need to do the least prop/
                        // most prop dance
                        
                        IWbemQualifierSet*  pInQS   =   NULL;
                        IWbemQualifierSet*  pOutQS  =   NULL;

                        if (    SUCCEEDED( pInParams->GetPropertyQualifierSet( (LPCWSTR) vPropName, &pInQS ) )
                            &&  SUCCEEDED( pOutParams->GetPropertyQualifierSet( (LPCWSTR) vPropName, &pOutQS ) ) )
                        {

                            // Cast to qualifier sets and do a direct comparison
                            CQualifierSet*  pInQualSet = (CQualifierSet*) pInQS;
                            CQualifierSet*  pOutQualSet = (CQualifierSet*) pOutQS;

                            // Test equality.  We don't care in this case, that the
                            // order of the qualifiers is exactly the same.  Just that
                            // the qualifier sets (aside from in,out) contain the
                            // same values (so they should at least contain the same
                            // number of qualifiers).
                            if ( !pInQualSet->Compare(*pOutQualSet, &aExcludeNames, FALSE ) )
                            {
                                hr = WBEM_E_INVALID_DUPLICATE_PARAMETER;
                            }

                        }   // IF got qualifiers
                        else
                        {
                            // We failed to get a qualifier set.  Something is badly wrong
                            hr = WBEM_E_INVALID_PARAMETER;
                        }

                        // Clean up the qualifier sets
                        if ( NULL != pInQS )
                        {
                            pInQS->Release();
                        }

                        // Clean up the qualifier sets
                        if ( NULL != pOutQS )
                        {
                            pOutQS->Release();
                        }

                    }   // IF property in both

                    vPropName.Empty();
                    vTemp.Empty();

                }   // IF GetPropName()

            }   // FOR enum properties

            // Clean up the array
            aExcludeNames.Free();

        }   // IF both params non-NULL

        return hr;
    }
    catch (CX_MemoryException)
    {
        aExcludeNames.Free();
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        aExcludeNames.Free();
        return WBEM_E_FAILED;
    }

}

HRESULT CMethodPart::CheckIds(CWbemClass* pInSig, CWbemClass* pOutSig)
{
    HRESULT hres;
    CFlexArray adwIds;

    // Assumption is that CheckDuplicateParameters has been called and
    // validated any and all duplicate parameters.

    // Collect IDs from both signature objects
    // =======================================

    if(pInSig)
    {
        // Add all properties here.  Since this is first, assume we will always add
        // duplicates
        hres = pInSig->GetIds( adwIds, NULL );
        if(FAILED(hres))
            return hres;
    }

    if(pOutSig)
    {
        // Ignore duplicate properties here if pInSig is non-NULL
        hres = pOutSig->GetIds( adwIds, pInSig );
        if(FAILED(hres))
            return hres;
    }

    // Sort them
    // =========

    adwIds.Sort();

    // Verify that they are consecutive and 0-based
    // ============================================

    for(int i = 0; i < adwIds.Size(); i++)
    {
        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value. (this one OK, since the the
        // flex array is being used as a placeholder for 32-bit values
        // here).  Use PtrToUlong() to lose the warning.

        if( PtrToUlong(adwIds[i]) != i )
            return WBEM_E_NONCONSECUTIVE_PARAMETER_IDS;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMethodPart::ValidateOutParams( CWbemObject* pOutSig )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    if ( NULL != pOutSig )
    {
        // If we get the return value property, make sure it is
        // not an array type.

        CIMTYPE ct;
        hres = pOutSig->GetPropertyType( L"ReturnValue", &ct, NULL );

        // IF the call failed, no return value, hence no error
        if ( SUCCEEDED( hres ) )
        {
            // It cannot be an array
            if ( CType::IsArray( ct ) )
            {
                hres = WBEM_E_INVALID_METHOD;
            }
        }
        else
        {
            hres = WBEM_S_NO_ERROR;
        }
    }

    return hres;
}

HRESULT CMethodPart::PutMethod(LPCWSTR wszName, long lFlags,
                    CWbemObject* pOrigInSig, CWbemObject* pOrigOutSig)
{
    if(pOrigInSig && pOrigInSig->IsInstance())
        return WBEM_E_INVALID_PARAMETER;

    if(pOrigOutSig && pOrigOutSig->IsInstance())
        return WBEM_E_INVALID_PARAMETER;

/*
    HRESULT hres = CheckIds((CWbemClass*)pOrigInSig, (CWbemClass*)pOrigOutSig);
    if(FAILED(hres))
        return hres;
*/

    CWbemObject* pInSig = NULL;
    CWbemObject* pOutSig = NULL;

    // Make sure we have in and out qualifiers in the right signatures
    HRESULT hres = EnsureQualifier(pOrigInSig, L"in", &pInSig);
    if ( FAILED( hres ) )
    {
        return hres;
    }
    CReleaseMe rmin((IWbemClassObject*)pInSig);


    hres = EnsureQualifier(pOrigOutSig, L"out", &pOutSig);
    if ( FAILED( hres ) )
    {
        return hres;
    }
    CReleaseMe rmout((IWbemClassObject*)pOutSig);

    // Check the out parameters for any anomalies
    hres = ValidateOutParams( pOutSig );
    if ( FAILED( hres ) )
    {
        return hres;
    }

    // Check for duplicate parameters
    hres = CheckDuplicateParameters( pInSig, pOutSig );

    if ( SUCCEEDED( hres ) )
    {

        // Now check that the ids are all consecutive
        hres = CheckIds((CWbemClass*)pOrigInSig, (CWbemClass*)pOrigOutSig);

        if ( SUCCEEDED( hres ) )
        {
            // Find it
            // =======

            int nIndex = FindMethod(wszName);
            if(nIndex < 0)
            {
                return CreateMethod(wszName, pInSig, pOutSig);
            }

            if(IsPropagated(nIndex))
            {
                if(!DoSignaturesMatch(nIndex, METHOD_SIGNATURE_IN, pInSig))
                {
                    return WBEM_E_PROPAGATED_METHOD;
                }

                if(!DoSignaturesMatch(nIndex, METHOD_SIGNATURE_OUT, pOutSig))
                {
                    return WBEM_E_PROPAGATED_METHOD;
                }
            }
            else
            {
                // Ensure signatures match
                // =======================

                SetSignature(nIndex, METHOD_SIGNATURE_IN, pInSig);
                SetSignature(nIndex, METHOD_SIGNATURE_OUT, pOutSig);
            }

        }   // IF CheckIds

    }   // IF CheckDuplicateParameters

    return hres;
}

HRESULT CMethodPart::CreateMethod(LPCWSTR wszName, CWbemObject* pInSig,
                    CWbemObject* pOutSig)
{
    // Validate the name
    // =================

    if(!IsValidElementName(wszName))
        return WBEM_E_INVALID_PARAMETER;


    length_t nLength;

    length_t nLengthName;
    length_t nLengthQualSet;
    length_t nLengthInSig;
    length_t nLengthOutSig;


    nLengthName = CCompressedString::ComputeNecessarySpace(wszName);
    nLengthQualSet = CQualifierSet::GetMinLength();
    nLengthInSig = CEmbeddedObject::EstimateNecessarySpace(pInSig);
    nLengthOutSig = CEmbeddedObject::EstimateNecessarySpace(pOutSig);


    nLength = nLengthName + nLengthQualSet + nLengthInSig + nLengthOutSig;
        
    // Grow our length by the size of a method
    // =======================================

    if (!m_pContainer->ExtendMethodPartSpace(this,
                    GetLength() + sizeof(CMethodDescription) + nLength))
    {
        return WBEM_E_OUT_OF_MEMORY;
    };

    m_pHeader->m_nLength += (sizeof(CMethodDescription) + nLength);

    // Move the heap over
    // ==================

    MoveBlock(m_Heap, m_Heap.GetStart() + sizeof(CMethodDescription));

    int nIndex = m_pHeader->m_nNumMethods;
    m_pHeader->m_nNumMethods++;

    m_Heap.SetAllocatedDataLength(m_Heap.GetAllocatedDataLength() + nLength);
    
	// Create all the bits on the heap
    // ===============================
        
    // Check for allocation failure
    heapptr_t ptrName;
    if ( !m_Heap.Allocate(nLengthName, ptrName) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    

    CCompressedString* pcs =
        (CCompressedString*)m_Heap.ResolveHeapPointer(ptrName);
    pcs->SetFromUnicode(wszName);
    pcs = NULL;

    // Check for allocation failure
    heapptr_t ptrQuals;
    if ( !m_Heap.Allocate(nLengthQualSet, ptrQuals) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CBasicQualifierSet::CreateEmpty(m_Heap.ResolveHeapPointer(ptrQuals));

    // Check for allocation failure
    heapptr_t ptrInSig;
    if ( !m_Heap.Allocate(nLengthInSig, ptrInSig) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CEmbeddedObject* pInSigEmbedding =
        (CEmbeddedObject*)m_Heap.ResolveHeapPointer(ptrInSig);
    pInSigEmbedding->StoreEmbedded(nLengthInSig, pInSig);
    pInSigEmbedding = NULL;

    // Check for allocation failure
    heapptr_t ptrOutSig;
    if ( !m_Heap.Allocate(nLengthOutSig, ptrOutSig) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CEmbeddedObject* pOutSigEmbedding =
        (CEmbeddedObject*)m_Heap.ResolveHeapPointer(ptrOutSig);
    pOutSigEmbedding->StoreEmbedded(nLengthOutSig, pOutSig);
    pOutSigEmbedding = NULL;

    // Create a new method in nIndex
    // =============================

    PMETHODDESCRIPTION pMethod = m_aDescriptions + nIndex;
    pMethod->m_ptrName = ptrName;
    pMethod->m_ptrQualifiers = ptrQuals;

	pMethod->SetSig( METHOD_SIGNATURE_IN, ptrInSig );
	pMethod->SetSig( METHOD_SIGNATURE_OUT, ptrOutSig );

    pMethod->m_nFlags = 0;
    pMethod->m_nOrigin = m_pContainer->GetCurrentOrigin();

    return WBEM_S_NO_ERROR;
}

BOOL CMethodPart::DoSignaturesMatch(int nIndex,
                                    METHOD_SIGNATURE_TYPE nSigType,
                                    CWbemObject* pSig)
{
    // Get the signature as it exists
    // ==============================

    heapptr_t ptrOldSig = m_aDescriptions[nIndex].GetSig( nSigType );
    CEmbeddedObject* pOldSigEmbedding = (CEmbeddedObject*)
        m_Heap.ResolveHeapPointer(ptrOldSig);
    CWbemObject* pOldSig = pOldSigEmbedding->GetEmbedded();

    // Compare
    // =======

    BOOL bRes = CWbemObject::AreEqual(pOldSig, pSig,
                                        WBEM_FLAG_IGNORE_OBJECT_SOURCE);
    if(pOldSig)
        pOldSig->Release();
    return bRes;
}

HRESULT CMethodPart::SetSignature(int nIndex, METHOD_SIGNATURE_TYPE nSigType,
                                    CWbemObject* pSig)
{
    // Get the signature as it exists
    // ==============================

    heapptr_t ptrOldSig = m_aDescriptions[nIndex].GetSig( nSigType );
    CEmbeddedObject* pOldSigEmbedding = (CEmbeddedObject*)
        m_Heap.ResolveHeapPointer(ptrOldSig);
    CWbemObject* pOldSig = pOldSigEmbedding->GetEmbedded();

    // Compare
    // =======

    if(!CWbemObject::AreEqual(pOldSig, pSig, WBEM_FLAG_IGNORE_OBJECT_SOURCE))
    {
        // Change it
        // =========

        int nLength = CEmbeddedObject::EstimateNecessarySpace(pSig);
        int nOldLength = pOldSigEmbedding->GetLength();

        pOldSigEmbedding = NULL; // about to be invalidated

        // Check for an allocation failure
        heapptr_t ptrSig;
        if ( !m_Heap.Reallocate( ptrOldSig, nOldLength, nLength, ptrSig ) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CEmbeddedObject* pSigEmbedding = (CEmbeddedObject*)
            m_Heap.ResolveHeapPointer(ptrSig);
        pSigEmbedding->StoreEmbedded(nLength, pSig);

        m_aDescriptions[nIndex].SetSig( nSigType, ptrSig );
    }

    if(pOldSig)
        pOldSig->Release();

    return WBEM_S_NO_ERROR;
}

void CMethodPart::GetSignature(int nIndex, int nSigType, CWbemObject** ppObj)
{
    if(ppObj)
    {
        CEmbeddedObject* pEmbed = (CEmbeddedObject*)m_Heap.ResolveHeapPointer(
                       m_aDescriptions[nIndex].GetSig( nSigType ) );
        *ppObj = pEmbed->GetEmbedded();
    }
}

void CMethodPart::DeleteSignature(int nIndex, int nSigType)
{
    CEmbeddedObject* pEmbed = (CEmbeddedObject*)m_Heap.ResolveHeapPointer(
                   m_aDescriptions[nIndex].GetSig( nSigType ) );
    m_Heap.Free(m_aDescriptions[nIndex].GetSig( nSigType ),
                   pEmbed->GetLength());
}

HRESULT CMethodPart::GetMethod(LPCWSTR wszName, long lFlags,
                                CWbemObject** ppInSig, CWbemObject** ppOutSig)
{
    // Find it
    // =======

    int nIndex = FindMethod(wszName);
    if(nIndex < 0)
        return WBEM_E_NOT_FOUND;

    // Get the data
    // ============

    GetSignature(nIndex, METHOD_SIGNATURE_IN, ppInSig);
    GetSignature(nIndex, METHOD_SIGNATURE_OUT, ppOutSig);

    return WBEM_S_NO_ERROR;
}

HRESULT CMethodPart::GetMethodAt(int nIndex, BSTR* pstrName,
                            CWbemObject** ppInSig, CWbemObject** ppOutSig)
{
    if(nIndex >= GetNumMethods())
        return WBEM_S_NO_MORE_DATA;

    // Get the data
    // ============

    if(pstrName)
    {
        CCompressedString* pcs =
            m_Heap.ResolveString(m_aDescriptions[nIndex].m_ptrName);
        *pstrName = pcs->CreateBSTRCopy();

        // Check for allocation failures
        if ( NULL == *pstrName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    GetSignature(nIndex, METHOD_SIGNATURE_IN, ppInSig);
    GetSignature(nIndex, METHOD_SIGNATURE_OUT, ppOutSig);

    return WBEM_S_NO_ERROR;
}

HRESULT CMethodPart::DeleteMethod(LPCWSTR wszName)
{
    // Find it first
    // =============

    int nIndex = FindMethod(wszName);
    if(nIndex < 0)
        return WBEM_E_NOT_FOUND;

    if(IsPropagated(nIndex))
    {
        // Replace the qualifier set
        // =========================

        heapptr_t ptrQuals = m_aDescriptions[nIndex].m_ptrQualifiers;
        length_t nOldLength = CBasicQualifierSet::GetLengthFromData(
            m_Heap.ResolveHeapPointer(ptrQuals));
        CBasicQualifierSet::Delete(m_Heap.ResolveHeapPointer(ptrQuals),&m_Heap);

        heapptr_t ptrParentQuals =
            m_pParent->m_aDescriptions[nIndex].m_ptrQualifiers;
        length_t nParentLength = CBasicQualifierSet::GetLengthFromData(
            m_pParent->m_Heap.ResolveHeapPointer(ptrParentQuals));

        // Check for allocation error
        if ( !m_Heap.Reallocate(ptrQuals, nOldLength, nParentLength, ptrQuals) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CHeapPtr ParentQuals(&m_pParent->m_Heap, ptrParentQuals);
        CHeapPtr Quals(&m_Heap, ptrQuals);

        // Check for allocation failure
        if ( CBasicQualifierSet::WritePropagatedVersion(&ParentQuals,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &Quals,
                &m_pParent->m_Heap, &m_Heap) == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_S_RESET_TO_DEFAULT;
    }
    else
    {
        // Remove the data from the heap
        // =============================

        m_Heap.FreeString(m_aDescriptions[nIndex].m_ptrName);
        DeleteSignature(nIndex, METHOD_SIGNATURE_IN);
        DeleteSignature(nIndex, METHOD_SIGNATURE_OUT);
        CBasicQualifierSet::Delete(
            m_Heap.ResolveHeapPointer(m_aDescriptions[nIndex].m_ptrQualifiers),
            &m_Heap);

        // Collapse the table
        // ==================

        memcpy((void*)(m_aDescriptions + nIndex),
                (void*)(m_aDescriptions + nIndex + 1),
                sizeof(CMethodDescription) * (GetNumMethods() - nIndex - 1));

        m_pHeader->m_nNumMethods--;

        // Move the heap
        // =============

        MoveBlock(m_Heap,
            (LPMEMORY)(m_aDescriptions + m_pHeader->m_nNumMethods));

        m_pContainer->ReduceMethodPartSpace(this, sizeof(CMethodDescription));
        m_pHeader->m_nLength -= sizeof(CMethodDescription);

        return WBEM_S_NO_ERROR;
    }
}


HRESULT CMethodPart::GetMethodQualifierSet(LPCWSTR wszName,
                            IWbemQualifierSet** ppSet)
{
    CMethodQualifierSet* pSet = NULL;

    // Check for out of memory
    try
    {
        // Find it first
        // =============

        int nIndex = FindMethod(wszName);
        if(nIndex < 0)
            return WBEM_E_NOT_FOUND;

        pSet = new CMethodQualifierSet;

        if ( NULL == pSet )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        // This may throw an exception natively, so we need to
        // make sure we clean up the allocated object above
        pSet->SetData(this, m_pParent, wszName);

        return pSet->QueryInterface(IID_IWbemQualifierSet, (void**)ppSet);
    }
    catch (CX_MemoryException)
    {
        // Cleanup the object in the event of OOM
        if ( NULL != pSet )
        {
            delete pSet;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        // Cleanup the object in the event of an exception
        if ( NULL != pSet )
        {
            delete pSet;
        }

        return WBEM_E_FAILED;
    }

}


HRESULT CMethodPart::GetMethodOrigin(LPCWSTR wszName, classindex_t* pnIndex)
{
    // Find it first
    // =============

    int nIndex = FindMethod(wszName);
    if(nIndex < 0)
        return WBEM_E_NOT_FOUND;

    *pnIndex = m_aDescriptions[nIndex].m_nOrigin;
    return WBEM_S_NO_ERROR;
}

BOOL CMethodPart::IsPropagated(int nIndex)
{
    return ((m_aDescriptions[nIndex].m_nFlags & WBEM_FLAVOR_ORIGIN_PROPAGATED)
                != 0);
}

//
//  TRUE if is Local of Locally overridden
//
BOOL CMethodPart::IsTouched(LPCWSTR wszName, BOOL * pbValid)
{
    int nIndex = FindMethod(wszName);
    if (nIndex < 0)
    {
        if (pbValid) { *pbValid = FALSE; };
        return FALSE;
    }

    if (pbValid) { *pbValid = TRUE; };
        
    if((m_aDescriptions[nIndex].m_nFlags & WBEM_FLAVOR_ORIGIN_PROPAGATED) == 0)
        return TRUE; // local

    return CBasicQualifierSet::HasLocalQualifiers(
        m_Heap.ResolveHeapPointer(m_aDescriptions[nIndex].m_ptrQualifiers));
}

//
//  TRUE if is Local of Locally overridden
//
BOOL CMethodPart::IsTouched(int nIndex, BOOL * pbValid)
{
    if ((nIndex < 0) || (nIndex >= GetNumMethods()))
    {
        if (pbValid) { *pbValid = FALSE; };
        return FALSE;
    }

    if (pbValid) { *pbValid = TRUE; };

    if((m_aDescriptions[nIndex].m_nFlags & WBEM_FLAVOR_ORIGIN_PROPAGATED) == 0)
        return TRUE; // local

    return CBasicQualifierSet::HasLocalQualifiers(
        m_Heap.ResolveHeapPointer(m_aDescriptions[nIndex].m_ptrQualifiers));
}


length_t CMethodPart::GetMinLength()
{
    return sizeof(CHeader) + CFastHeap::GetMinLength();
}

LPMEMORY CMethodPart::CreateEmpty(LPMEMORY pStart)
{
    PMETHODPARTHDR pHeader = (PMETHODPARTHDR)pStart;
    pHeader->m_nNumMethods = 0;
    pHeader->m_nLength = GetMinLength();

    return CFastHeap::CreateEmpty(CMethodPart::CHeader::EndOf(pHeader));
}

length_t CMethodPart::EstimateDerivedPartSpace()
{
    // Exactly the same
    // ================

    return m_pHeader->m_nLength;
}

LPMEMORY CMethodPart::CreateDerivedPart(LPMEMORY pStart,
                                        length_t nAllocatedLength)
{
    PMETHODPARTHDR pHeader = (PMETHODPARTHDR)pStart;
    *pHeader = *m_pHeader;
    PMETHODDESCRIPTION aDescriptions =
			(PMETHODDESCRIPTION)CMethodPart::CHeader::EndOf(pHeader);

    CFastHeap Heap;
    Heap.CreateOutOfLine((LPMEMORY)(aDescriptions + pHeader->m_nNumMethods),
                            m_Heap.GetUsedLength());

    for(int i = 0; i < GetNumMethods(); i++)
    {
        // Check for allocation failure
        if ( !CMethodDescription::CreateDerivedVersion(
													&m_aDescriptions[i],
													aDescriptions + i,
                                                    &m_Heap, &Heap) )
        {
            return NULL;
        }
    }

    Heap.Trim();
    pHeader->m_nLength = EndOf(Heap) - pStart;
    return EndOf(Heap);
}

length_t CMethodPart::EstimateUnmergeSpace()
{
    return GetLength();
}

LPMEMORY CMethodPart::Unmerge(LPMEMORY pStart, length_t nAllocatedLength)
{
    PMETHODPARTHDR pHeader = (PMETHODPARTHDR)pStart;
    PMETHODDESCRIPTION aDescriptions =
			(PMETHODDESCRIPTION)CMethodPart::CHeader::EndOf(pHeader);

    CFastHeap Heap;
    Heap.CreateOutOfLine((LPMEMORY)(aDescriptions + GetNumMethods()),
                            m_Heap.GetUsedLength());

    int nNewIndex = 0;
    for(int i = 0; i < GetNumMethods(); i++)
    {
        if(CMethodDescription::IsTouched(&m_aDescriptions[i], &m_Heap))
        {
            // Check for allocation failures
            if ( !CMethodDescription::CreateUnmergedVersion(
                    &m_aDescriptions[i], aDescriptions + nNewIndex++, &m_Heap, &Heap) )
            {
                return NULL;
            }
        }
    }

    Heap.Trim();
    MoveBlock(Heap, (LPMEMORY)(aDescriptions + nNewIndex));

    pHeader->m_nNumMethods = (propindex_t) nNewIndex;
    pHeader->m_nLength = EndOf(Heap) - pStart;
    return EndOf(Heap);
}

length_t CMethodPart::EstimateMergeSpace(CMethodPart& Parent,
                                         CMethodPart& Child)
{
    return Parent.GetLength() + Child.GetLength() - sizeof(CHeader);
}

LPMEMORY CMethodPart::Merge(CMethodPart& Parent, CMethodPart& Child,
                        LPMEMORY pDest, length_t nAllocatedLength)
{

    // This function assumes that no reallocations will occur, and that the supplied heap is sufficiently
    // large enough to handle the operation!

    PMETHODPARTHDR pHeader = (PMETHODPARTHDR)pDest;
    PMETHODDESCRIPTION aDescriptions =
			(PMETHODDESCRIPTION)CMethodPart::CHeader::EndOf(pHeader);

    CFastHeap Heap;
    length_t nHeapLength =
        Parent.m_Heap.GetLength() + Child.m_Heap.GetLength();
    LPMEMORY pHeapStart = pDest + nAllocatedLength - nHeapLength;

    Heap.CreateOutOfLine(pHeapStart, nHeapLength);

    int nChildIndex = 0;
    for(int i = 0; i < Parent.GetNumMethods(); i++)
    {

        // Check for memory allocation failures
        if ( !CCompressedString::CopyToNewHeap(
                Parent.m_aDescriptions[i].m_ptrName, &Parent.m_Heap, &Heap,
                aDescriptions[i].m_ptrName) )
        {
            return NULL;
        }

        aDescriptions[i].m_nFlags = WBEM_FLAVOR_ORIGIN_PROPAGATED;
        aDescriptions[i].m_nOrigin = Parent.m_aDescriptions[i].m_nOrigin;

        // Check for memory allocation failures
         if ( !CEmbeddedObject::CopyToNewHeap(
                        Parent.m_aDescriptions[i].GetSig( METHOD_SIGNATURE_IN ),
                        &Parent.m_Heap, &Heap, aDescriptions[i].m_aptrSigs[METHOD_SIGNATURE_IN]) )
         {
            return NULL;
         }

        // Check for memory allocation failures
        if ( !CEmbeddedObject::CopyToNewHeap(
                        Parent.m_aDescriptions[i].GetSig( METHOD_SIGNATURE_OUT ),
                        &Parent.m_Heap, &Heap, aDescriptions[i].m_aptrSigs[METHOD_SIGNATURE_OUT]) )
        {
            return NULL;
        }

        LPMEMORY pParentQuals = Parent.m_Heap.ResolveHeapPointer(
            Parent.m_aDescriptions[i].m_ptrQualifiers);

        // Compare names
        // =============

        if(nChildIndex < Child.GetNumMethods() &&
            Parent.GetName(i)->CompareNoCase(*Child.GetName(nChildIndex)) == 0)
        {
            // Same --- merge
            // ==============

            LPMEMORY pChildQuals = Child.m_Heap.ResolveHeapPointer(
                Child.m_aDescriptions[nChildIndex].m_ptrQualifiers);

            length_t nSize = CBasicQualifierSet::ComputeMergeSpace(
                pParentQuals, &Parent.m_Heap, pChildQuals, &Child.m_Heap, TRUE);

            // Check for memory allocation failures
            if ( !Heap.Allocate(nSize, aDescriptions[i].m_ptrQualifiers) )
            {
                return NULL;
            }

            LPMEMORY pDestQuals = Heap.ResolveHeapPointer(
                aDescriptions[i].m_ptrQualifiers);

            if ( CBasicQualifierSet::Merge(
                    pParentQuals, &Parent.m_Heap, pChildQuals, &Child.m_Heap,
                    pDestQuals, &Heap, FALSE) == NULL )
            {
                return NULL;
            }

            nChildIndex++;
        }
        else
        {
            // Different
            // =========

            length_t nLength =
                CBasicQualifierSet::ComputeNecessarySpaceForPropagation(
                    pParentQuals, WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

            // Check for memory allocation failures
            if ( !Heap.Allocate(nLength, aDescriptions[i].m_ptrQualifiers) )
            {
                return NULL;
            }

            LPMEMORY pDestQuals = Heap.ResolveHeapPointer(
                aDescriptions[i].m_ptrQualifiers);

            CHeapPtr ParentQuals(&Parent.m_Heap,
                                    Parent.m_aDescriptions[i].m_ptrQualifiers);
            CHeapPtr DestQuals(&Heap, aDescriptions[i].m_ptrQualifiers);

            // Check for memory allocation failures
            if ( !CBasicQualifierSet::WritePropagatedVersion(&ParentQuals,
                        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &DestQuals,
                        &Parent.m_Heap, &Heap) )
            {
                return NULL;
            }
        }
    }

    // Copy remaining child qualifiers
    // ===============================

    while(nChildIndex < Child.GetNumMethods())
    {
        // Check for memory allocation failures
        if ( !CCompressedString::CopyToNewHeap(
                Child.m_aDescriptions[nChildIndex].m_ptrName, &Child.m_Heap, &Heap,
                aDescriptions[i].m_ptrName) )
        {
            return NULL;
        }

        aDescriptions[i].m_nFlags = 0;
        aDescriptions[i].m_nOrigin = Child.m_aDescriptions[nChildIndex].m_nOrigin;

        // Check for memory allocation failures
        if ( !CEmbeddedObject::CopyToNewHeap(
                        Child.m_aDescriptions[nChildIndex].GetSig( METHOD_SIGNATURE_IN ),
                        &Child.m_Heap, &Heap, aDescriptions[i].m_aptrSigs[METHOD_SIGNATURE_IN]) )
        {
            return NULL;
        }

        // Check for memory allocation failures
        if ( !CEmbeddedObject::CopyToNewHeap(
                        Child.m_aDescriptions[nChildIndex].GetSig( METHOD_SIGNATURE_OUT ),
                        &Child.m_Heap, &Heap, aDescriptions[i].m_aptrSigs[METHOD_SIGNATURE_OUT]) )
        {
            return NULL;
        }

        LPMEMORY pChildQuals = Child.m_Heap.ResolveHeapPointer(
            Child.m_aDescriptions[nChildIndex].m_ptrQualifiers);

        length_t nLength = CBasicQualifierSet::GetLengthFromData(pChildQuals);

        // Check for memory allocation failures
        if ( !Heap.Allocate(nLength, aDescriptions[i].m_ptrQualifiers) )
        {
            return NULL;
        }

        memcpy(Heap.ResolveHeapPointer(aDescriptions[i].m_ptrQualifiers),
            pChildQuals, nLength);

        CHeapPtr DestQuals(&Heap, aDescriptions[i].m_ptrQualifiers);

        // Check for memory allocation failures
        if ( !CBasicQualifierSet::TranslateToNewHeap(&DestQuals, &Child.m_Heap,
                                                    &Heap) )
        {
            return NULL;
        }

        nChildIndex++;
        i++;
    }

    Heap.Trim();
    MoveBlock(Heap, (LPMEMORY)(aDescriptions + i));

    pHeader->m_nNumMethods = (propindex_t) i;
    pHeader->m_nLength = (EndOf(Heap) - pDest);
    return EndOf(Heap);
}

HRESULT CMethodPart::Update( CMethodPart& Parent, CMethodPart& Child, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Enum methods, adding them as appropriate
    for(int nChildIndex = 0; SUCCEEDED( hr ) && nChildIndex < Child.GetNumMethods();
        nChildIndex++)
    {
        BSTR            bstrName = NULL;
        CWbemObject*    pInSig = NULL;
        CWbemObject*    pOutSig = NULL;

        // Get the method from the child, and add it to the parent.  This will
        // fail if there are any problems/conflicts with the method

        hr = Child.GetMethodAt( nChildIndex, &bstrName, &pInSig, &pOutSig );

        // Scoping cleanup
        CReleaseMe      pigrm( (IUnknown*) (IWbemClassObject*) pInSig );
        CReleaseMe      pogrm( (IUnknown*) (IWbemClassObject*) pOutSig );
        CSysFreeMe      bsfm( bstrName );

        if ( SUCCEEDED( hr ) && NULL != bstrName )
        {
            hr = Parent.PutMethod( bstrName, 0L, pInSig, pOutSig );

            // Now we need to copy across any qualifiers
            if ( SUCCEEDED( hr ) )
            {
                CMethodQualifierSet qsUpdateMeth;
                CBasicQualifierSet qsChildMeth;

                // Use a helper function to set this up
                qsUpdateMeth.SetData( &Parent, Parent.m_pParent, bstrName );

                // We can access the child methods qualifier set directly
                qsChildMeth.SetData( Child.m_Heap.ResolveHeapPointer(
                                    Child.m_aDescriptions[nChildIndex].m_ptrQualifiers),
                                    &Child.m_Heap );

                // Update the method's qualifier set
                hr = qsUpdateMeth.Update( qsChildMeth, lFlags );

            }   // IF PutMethod

        }   // IF GetMethodAt
		else if ( SUCCEEDED( hr ) && NULL == bstrName )
		{
			// This means a valid index was unresolvable into a name
			// means we changed while operation was running - this should
			// never happen
			hr = WBEM_E_UNEXPECTED;
		}

    }   // FOR enum methods

    return hr;
}

void CMethodPart::Compact()
{
    m_Heap.Trim();
}

BOOL CMethodPart::DoesSignatureMatchOther(CMethodPart& OtherPart, int nIndex,
                                        METHOD_SIGNATURE_TYPE nType)
{
    CWbemObject* pThis;
    CWbemObject* pOther;

    GetSignature(nIndex, nType, &pThis);
    OtherPart.GetSignature(nIndex, nType, &pOther);
    BOOL bRes = CWbemObject::AreEqual(pThis, pOther,
                                        WBEM_FLAG_IGNORE_OBJECT_SOURCE);
    if(pThis)
        pThis->Release();
    if(pOther)
        pOther->Release();
    return bRes;
}

HRESULT CMethodPart::CompareTo(long lFlags, CMethodPart& OtherPart)
{
    // Check the sizes
    // ===============

    if(GetNumMethods() != OtherPart.GetNumMethods())
        return WBEM_S_FALSE;

    // Compare all methods
    // ===================

    for(int i = 0; i < GetNumMethods(); i++)
    {
        if(GetName(i)->CompareNoCase(*OtherPart.GetName(i)) != 0)
            return WBEM_S_FALSE;

        if(m_aDescriptions[i].m_nFlags != OtherPart.m_aDescriptions[i].m_nFlags)
            return WBEM_S_FALSE;

        if(m_aDescriptions[i].m_nOrigin !=
                                        OtherPart.m_aDescriptions[i].m_nOrigin)
            return WBEM_S_FALSE;

        if(!DoesSignatureMatchOther(OtherPart, i, METHOD_SIGNATURE_IN))
            return WBEM_S_FALSE;

        if(!DoesSignatureMatchOther(OtherPart, i, METHOD_SIGNATURE_OUT))
            return WBEM_S_FALSE;

    }
    return WBEM_S_NO_ERROR;
}

EReconciliation CMethodPart::CompareExactMatch( CMethodPart& thatPart )
{
    try
    {
        // Check the sizes
        // ===============

        if(GetNumMethods() != thatPart.GetNumMethods())
        {
            return e_DiffNumMethods;
        }

        // Set up the array of filters to use while dealing with qualifiers
        LPCWSTR apFilters[1];
        apFilters[0] = UPDATE_QUALIFIER_CONFLICT;

        // Compare all methods
        // ===================

        for(int i = 0; i < GetNumMethods(); i++)
        {

            // All Values MUST match
            if(GetName(i)->CompareNoCase(*thatPart.GetName(i)) != 0)
                return e_DiffMethodNames;

            if(m_aDescriptions[i].m_nFlags != thatPart.m_aDescriptions[i].m_nFlags)
                return e_DiffMethodFlags;

            if(m_aDescriptions[i].m_nOrigin !=
                                            thatPart.m_aDescriptions[i].m_nOrigin)
                return e_DiffMethodOrigin;

            if(!DoesSignatureMatchOther(thatPart, i, METHOD_SIGNATURE_IN))
                return e_DiffMethodInSignature;

            if(!DoesSignatureMatchOther(thatPart, i, METHOD_SIGNATURE_OUT))
                return e_DiffMethodOutSignature;

            // Check the qualifiers
            CBasicQualifierSet  qsThisMeth,
                                qsThatMeth;

            // We can access the child methods qualifier set directly
            qsThisMeth.SetData( m_Heap.ResolveHeapPointer(
                                m_aDescriptions[i].m_ptrQualifiers),
                                &m_Heap );
            qsThatMeth.SetData( thatPart.m_Heap.ResolveHeapPointer(
                                thatPart.m_aDescriptions[i].m_ptrQualifiers),
                                &thatPart.m_Heap );

            // Apply update conflict filter during comparison
            if ( !qsThisMeth.Compare( qsThatMeth, WBEM_FLAG_LOCAL_ONLY, apFilters, 1 ) )
            {
                return e_DiffMethodQualifier;
            }

        }

        return e_ExactMatch;

    }
    catch( CX_MemoryException )
    {
        return e_OutOfMemory;
    }
    catch(...)
    {
        return e_WbemFailed;
    }
}

EReconciliation CMethodPart::CanBeReconciledWith(CMethodPart& OtherPart)
{
    // Check the sizes
    // ===============

    if(GetNumMethods() != OtherPart.GetNumMethods())
        return e_DiffNumProperties;

    // Compare all methods
    // ===================

    for(int i = 0; i < GetNumMethods(); i++)
    {
        if(GetName(i)->CompareNoCase(*OtherPart.GetName(i)) != 0)
            return e_DiffPropertyName;

        if(m_aDescriptions[i].m_nFlags != OtherPart.m_aDescriptions[i].m_nFlags)
            return e_DiffPropertyType;

        if(m_aDescriptions[i].m_nOrigin !=
                                        OtherPart.m_aDescriptions[i].m_nOrigin)
            return e_DiffPropertyType;

        if(!DoesSignatureMatchOther(OtherPart, i, METHOD_SIGNATURE_IN))
            return e_DiffMethodInSignature;

        if(!DoesSignatureMatchOther(OtherPart, i, METHOD_SIGNATURE_OUT))
            return e_DiffMethodOutSignature;

        // Make sure that unimportant qualifiers can be reconciled with
        // each other

        CBasicQualifierSet  qsThisMeth,
                            qsThatMeth;

        // We can access the child methods qualifier set directly
        qsThisMeth.SetData( m_Heap.ResolveHeapPointer(
                            m_aDescriptions[i].m_ptrQualifiers),
                            &m_Heap );
        qsThatMeth.SetData( OtherPart.m_Heap.ResolveHeapPointer(
                            OtherPart.m_aDescriptions[i].m_ptrQualifiers),
                            &OtherPart.m_Heap );

        if ( !qsThisMeth.CanBeReconciledWith( qsThatMeth ) )
        {
            return e_DiffMethodQualifier;
        }


    }
    return e_Reconcilable;
}

EReconciliation CMethodPart::ReconcileWith(CMethodPart& NewPart)
{
    EReconciliation eRes = CanBeReconciledWith(NewPart);
    if(eRes != e_Reconcilable)
        return eRes;

    // Extend and copy
    // ===============

    if(NewPart.GetLength() > GetLength())
    {
        if (!m_pContainer->ExtendMethodPartSpace(this, NewPart.GetLength()))
        	return e_OutOfMemory;
    }

    memcpy(GetStart(), NewPart.GetStart(), NewPart.GetLength());

    SetData(GetStart(), m_pContainer, m_pParent);

    return e_Reconcilable; // TBD
}

HRESULT CMethodPart::SetMethodOrigin(LPCWSTR wszMethodName, long lOriginIndex)
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    // Find it first
    // =============

    int nIndex = FindMethod(wszMethodName);
    if(nIndex < 0)
        return WBEM_E_NOT_FOUND;

    m_aDescriptions[nIndex].m_nOrigin = lOriginIndex;
    return WBEM_S_NO_ERROR;
}

HRESULT CMethodPart::AddText(WString& wsText, long lFlags)
{
	HRESULT	hr = WBEM_S_NO_ERROR;

    // Any thrown exceptions should bubble out of here
    for(int i = 0; SUCCEEDED( hr ) && i < GetNumMethods(); i++)
    {
        if(CMethodDescription::IsTouched(&m_aDescriptions[i], &m_Heap))
        {
            hr = CMethodDescription::AddText(&m_aDescriptions[i], wsText, &m_Heap, lFlags);
        }
    }

	return hr;
}

HRESULT CMethodPart::IsValidMethodPart( void )
{
    // Check the sizes
    // ===============

    //  Enumerate the methods, and check that names and ptr data
    //  Are inside the heap
    // ================================================================

    LPMEMORY    pHeapStart = m_Heap.GetHeapData();
    LPMEMORY    pHeapEnd = m_Heap.GetStart() + m_Heap.GetLength();

    // Compare all methods
    // ===================

    for(int i = 0; i < GetNumMethods(); i++)
    {
        LPMEMORY pData = m_Heap.ResolveHeapPointer(m_aDescriptions[i].m_ptrName);

        if ( pData >= pHeapStart && pData < pHeapEnd  )
        {
            pData =  m_Heap.ResolveHeapPointer( m_aDescriptions[i].GetSig( METHOD_SIGNATURE_IN ) );

            if ( NULL == pData || ( pData >= pHeapStart && pData < pHeapEnd  ) )
            {
                // We could validate the signature object as well
                pData =  m_Heap.ResolveHeapPointer( m_aDescriptions[i].GetSig( METHOD_SIGNATURE_OUT ) );

                if ( NULL == pData || ( pData >= pHeapStart && pData < pHeapEnd  ) )
                {
                    // We could validate the signature object as well
                }
                else
                {
                    OutputDebugString(__TEXT("Winmgmt: Bad out signature pointer!"));
                    FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad out signature pointer!"));
                    return WBEM_E_FAILED;
                }

            }
            else
            {
                OutputDebugString(__TEXT("Winmgmt: Bad in signature pointer!"));
                FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad in signature pointer!") );
                return WBEM_E_FAILED;
            }

        }
        else
        {
            OutputDebugString(__TEXT("Winmgmt: Bad method name pointer!"));
            FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad method name pointer!") );
            return WBEM_E_FAILED;
        }

    }
    return WBEM_S_NO_ERROR;
}

void CMethodQualifierSetContainer::SetData(CMethodPart* pPart,
                                CMethodPart* pParent, LPCWSTR wszMethodName)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    m_pPart = pPart;
    m_pParent = pParent;
    m_wsMethodName = wszMethodName;

    int nIndex = pPart->FindMethod(wszMethodName);
    if(pPart->IsPropagated(nIndex))
    {
        m_ptrParentSet = pParent->m_aDescriptions[nIndex].m_ptrQualifiers;
        m_SecondarySet.SetData(pParent->m_Heap.ResolveHeapPointer(
                                                            m_ptrParentSet),
                            &pParent->m_Heap);
    }
    else
    {
        m_ptrParentSet = INVALID_HEAP_ADDRESS;
    }

}

BOOL CMethodQualifierSetContainer::ExtendQualifierSetSpace(
                                CBasicQualifierSet* pSet, length_t nNewLength)
{
    int nIndex = m_pPart->FindMethod(m_wsMethodName);

    // Check for allocation failure
    heapptr_t ptrNew;
    if ( !m_pPart->m_Heap.Reallocate(
            m_pPart->m_aDescriptions[nIndex].m_ptrQualifiers,
            pSet->GetLength(), nNewLength, ptrNew) )
    {
        return FALSE;
    }

    // Move the qualifier set there
    // ============================

    pSet->Rebase(m_pPart->m_Heap.ResolveHeapPointer(ptrNew));

    // Change the lookup
    // =================

    m_pPart->m_aDescriptions[nIndex].m_ptrQualifiers = ptrNew;

    // DEVNOTE:TODO:SANJ - This is a hack to get memalloc checks working
    return TRUE;
}

LPMEMORY CMethodQualifierSetContainer::GetQualifierSetStart()
{
    if(m_ptrParentSet != INVALID_HEAP_ADDRESS)
        m_SecondarySet.Rebase(m_pParent->m_Heap.ResolveHeapPointer(
                                                        m_ptrParentSet));

    int nIndex = m_pPart->FindMethod(m_wsMethodName);
    if(nIndex < 0) return NULL;

    return m_pPart->m_Heap.ResolveHeapPointer(
                            m_pPart->m_aDescriptions[nIndex].m_ptrQualifiers);
}

CBasicQualifierSet* CMethodQualifierSetContainer::GetSecondarySet()
{
    if(m_ptrParentSet != INVALID_HEAP_ADDRESS)
        return &m_SecondarySet;
    else
        return NULL;
}

void CMethodQualifierSet::SetData(CMethodPart* pPart, CMethodPart* pParent,
                    LPCWSTR wszMethodName)
{
    m_Container.SetData(pPart, pParent, wszMethodName);
    CQualifierSet::SetData(m_Container.GetQualifierSetStart(), &m_Container,
            m_Container.GetSecondarySet());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastinst.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTINST.CPP

Abstract:

  This file implements all the functions for the classes related to instance
  representation in WbemObjects.

  The classes are defined in fastinst.h where the documentation can be found.

  Classes implemented:
      CInstancePart           Instance data.
      CWbemInstance            Complete instance definition.

History:

  3/10/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/
#include "precomp.h"
#include "fastall.h"

#include <genlex.h>
#include <qllex.h>
#include <objpath.h>
#define QUALNAME_SINGLETON L"singleton"

//#include "dbgalloc.h"
#include "wbemutil.h"
#include "arrtempl.h"
#include "olewrap.h"

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
BOOL CInstancePart::ExtendHeapSize(LPMEMORY pStart, length_t nOldLength,
    length_t nExtra)
{
    if(EndOf(*this) - EndOf(m_Heap) > (int)nExtra)
        return TRUE;

    int nNeedTotalLength = GetTotalRealLength() + nExtra;

    // Check for allocation error
    return ReallocAndCompact(nNeedTotalLength);
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
BOOL CInstancePart::ExtendQualifierSetListSpace(LPMEMORY pOld,
    length_t nOldLength, length_t nNewLength)
{
    if(m_Heap.GetStart() - pOld > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength-nOldLength;

	// Get the amount of space free in the heap
	int	nFreeInHeap = m_Heap.GetAllocatedDataLength() - m_Heap.GetUsedLength();

	BOOL	fReturn = FALSE;

	// If the amount of free space in the heap is  >= nExtra, we'll steal the space
	// from it.

	if ( nFreeInHeap >= nExtra )
	{
		// Compact without trim
		Compact( false );
		m_Heap.SetAllocatedDataLength( m_Heap.GetAllocatedDataLength() - nExtra );
		fReturn = TRUE;
	}
	else
	{
		// True reallocation and compact
		fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);
	}

    // Check for allocation error
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
BOOL CInstancePart::ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
    length_t nNewLength)
{
    if(m_PropQualifiers.GetStart() - pSet->GetStart() > (int)nNewLength)
        return TRUE;

    int nExtra = nNewLength - pSet->GetLength();

	// Get the amount of space free in the heap
	int	nFreeInHeap = m_Heap.GetAllocatedDataLength() - m_Heap.GetUsedLength();

	BOOL	fReturn = FALSE;

	// If the amount of free space in the heap is  >= nExtra, we'll steal the space
	// from it.

	if ( nFreeInHeap >= nExtra )
	{
		// Compact without trim
		Compact( false );
		m_Heap.SetAllocatedDataLength( m_Heap.GetAllocatedDataLength() - nExtra );
		fReturn = TRUE;
	}
	else
	{
		// True reallocation and compact
		fReturn = ReallocAndCompact(GetTotalRealLength() + nExtra);
	}

    // Check for allocation error
    if ( fReturn )
    {
        MoveBlock(m_Heap, m_Heap.GetStart() + nExtra);
        MoveBlock(m_PropQualifiers, m_PropQualifiers.GetStart() + nExtra);
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
LPMEMORY CInstancePart::CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN int nAllocatedSize,
        OUT LPMEMORY pDest)
{
    // Allocate the header
    // ===================

    CInstancePartHeader* pHeader = (CInstancePartHeader*)pDest;

    LPMEMORY pCurrentEnd = pDest + sizeof(CInstancePartHeader);

    // Place new heap at the end of the allocated area. Make it as large as
    // the current one.
    // ====================================================================

    int nHeapSize = m_Heap.GetUsedLength();
    LPMEMORY pHeapStart = pDest + nAllocatedSize - nHeapSize -
                                              CFastHeap::GetMinLength();
    CFastHeap Heap;
    Heap.CreateOutOfLine(pHeapStart, nHeapSize);

    // Copy class name
    // ===============

    // Check for allocation errors
    if ( !CCompressedString::CopyToNewHeap(
            m_pHeader->ptrClassName,
            &m_Heap, &Heap, pHeader->ptrClassName) )
    {
        return NULL;
    }

    // Create limited data table
    // =========================

    pCurrentEnd = m_DataTable.CreateLimitedRepresentation(pMap, FALSE, &m_Heap,
                                                           &Heap, pCurrentEnd);
    if(pCurrentEnd == NULL) return NULL;

    // Create limited qualifier set
    // ============================

    if(pMap->GetFlags() & WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS)
    {
        // No qualifiers need to be written
        // ================================

        pCurrentEnd = CBasicQualifierSet::CreateEmpty(pCurrentEnd);
    }
    else
    {
        // Copy them all
        // =============

        int nLength = m_Qualifiers.GetLength();
        memcpy(pCurrentEnd, m_Qualifiers.GetStart(), nLength);

        CStaticPtr CurrentEndPtr(pCurrentEnd);

        // Check for allocation failures
        if ( !CBasicQualifierSet::TranslateToNewHeap(&CurrentEndPtr, &m_Heap, &Heap) )
        {
            return NULL;
        }

        pCurrentEnd += nLength;
    }

    // Create limited property qualifier set list
    // ==========================================

    // Check for allocation failures
    pCurrentEnd = m_PropQualifiers.CreateLimitedRepresentation(pMap, &m_Heap,
                                                           &Heap, pCurrentEnd);
    if(pCurrentEnd == NULL) return NULL;

    // Now, relocate the heap to its actual location
    // =============================================

    CopyBlock(Heap, pCurrentEnd);
    Heap.Trim();

    // Finish up tbe header
    // ====================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // lengths greater than 0xFFFFFFFF, so cast is ok

    pHeader->nLength = (length_t) ( EndOf(Heap) - pDest );

    return EndOf(Heap);
}

//******************************************************************************
//******************************************************************************


//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::InitEmptyInstance(CClassPart& ClassPart, LPMEMORY pStart,
                                      int nAllocatedLength,
                                      CDecorationPart* pDecoration)
{
    // Copy the decoration
    // ===================

    LPMEMORY pCurrentEnd;
    if(pDecoration)
    {
        memcpy(pStart, pDecoration, pDecoration->GetLength());
        *(BYTE*)pStart = OBJECT_FLAG_INSTANCE & OBJECT_FLAG_DECORATED;
        pCurrentEnd = pStart + pDecoration->GetLength();
    }
    else
    {
        *(BYTE*)pStart = OBJECT_FLAG_INSTANCE;
        pCurrentEnd = pStart + sizeof(BYTE);
    }

    m_DecorationPart.SetData(pStart);

    // Copy the class part
    // ===================

    memcpy(pCurrentEnd, ClassPart.GetStart(),
                ClassPart.GetLength());
    m_ClassPart.SetData(pCurrentEnd, this);

    pCurrentEnd += m_ClassPart.GetLength();

    // Create empty instance part
    // ==========================

    // Check for a memory allocation failure
    HRESULT hr = WBEM_S_NO_ERROR;
    pCurrentEnd = m_InstancePart.Create(pCurrentEnd, &m_ClassPart, this);

    if ( NULL != pCurrentEnd )
    {

        m_nTotalLength = nAllocatedLength;
        // Everything is internal now
        m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART |
                            WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL;
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
BOOL CWbemInstance::ExtendInstancePartSpace(CInstancePart* pPart,
                                           length_t nNewLength)
{
    // Check if there is enough space
    // ==============================

    if(GetStart() + m_nTotalLength >= m_InstancePart.GetStart() + nNewLength)
        return TRUE;

    // Reallocate
    // ==========

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // lengths > 0xFFFFFFFF, so cast is ok

    length_t nNewTotalLength = (length_t)
        ( (m_InstancePart.GetStart() + nNewLength) - GetStart() );

    LPMEMORY pNew = Reallocate(nNewTotalLength);

    // Check that the allocation succeeded
    if ( NULL != pNew )
    {
        Rebase(pNew);
        m_nTotalLength = nNewTotalLength;
    }

    return ( NULL != pNew );
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace)
{
    CompactAll();

    Undecorate();

    // Check if there is enough space
    // ==============================

    length_t nDecorationSpace =
        CDecorationPart::ComputeNecessarySpace(wszServer, wszNamespace);

    length_t nNeededSpace = nDecorationSpace + m_InstancePart.GetLength();

    // Only add the class part in here if it is internal
    if ( IsClassPartInternal() )
    {
        nNeededSpace += m_ClassPart.GetLength();
    }

    LPMEMORY pDest;
    if(nNeededSpace > m_nTotalLength)
    {
        m_InstancePart.Compact();

        // Check that the reallocation succeeded.  If not, return an error
        pDest = Reallocate(nNeededSpace);

        if ( NULL == pDest )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        Rebase(pDest);
        m_nTotalLength = nNeededSpace;
    }
    else pDest = GetStart();

    // Move is different based on whether class part is internal or not
    if ( IsClassPartInternal() )
    {
        // Move instance part
        // ==================

        MoveBlock(m_InstancePart,
            pDest + nDecorationSpace + m_ClassPart.GetLength());

        // Move class part
        // ===============

        MoveBlock(m_ClassPart, pDest + nDecorationSpace);
    }
    else
    {
        // Move instance part
        // ==================

        MoveBlock(m_InstancePart, pDest + nDecorationSpace);
    }

    // Create decoration part
    // ======================

    m_DecorationPart.Create(OBJECT_FLAG_INSTANCE, wszServer, wszNamespace, pDest);

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
void CWbemInstance::Undecorate()
{
    if(!m_DecorationPart.IsDecorated()) return;

    // Create empty decoration
    // ========================

    LPMEMORY pStart = GetStart();
    m_DecorationPart.CreateEmpty(OBJECT_FLAG_INSTANCE, pStart);

    // Copy is different based on whether class part is internal or not.  We only need to copy the
    // class part if it is internal.

    //  We only need to copy the instance part if it is available.
    if ( IsClassPartInternal() )
    {

        // Copy class part back
        // ====================

        CopyBlock(m_ClassPart, EndOf(m_DecorationPart));

        if ( IsInstancePartAvailable() )
        {
            // Copy the instance part back after the class part
            CopyBlock(m_InstancePart, EndOf(m_ClassPart));
        }
    }
    else if ( IsInstancePartAvailable() )
    {
        // Copy instance part back to the decoration part
        // =======================

        CopyBlock(m_InstancePart, EndOf(m_DecorationPart));

    }
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
LPWSTR CWbemInstance::GetKeyStr()
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    // Loop through all properties.
    // ============================

    CPropertyLookupTable& Properties = m_ClassPart.m_Properties;
    WString KeyStr;

    BOOL bFirst = TRUE;
    for (int i = 0; i < Properties.GetNumProperties(); i++)
    {
        CPropertyInformation* pInfo =
            Properties.GetAt(i)->GetInformation(&m_ClassPart.m_Heap);

        // Determine if this property is marked with a 'key' Qualifier.
        // ============================================================

        if(pInfo->IsKey())
        {
            if (!bFirst)
                KeyStr += WINMGMT_COMPOUND_KEY_JOINER;

            // Determine the type of the key property.
            // =======================================

            WString KeyStrValue;

            CVar Val;
            if (FAILED(GetProperty(pInfo, &Val)))
		return 0;

            WCHAR Tmp[64];

            // Special case char16 and uint32
            if(CType::GetActualType(pInfo->nType) == CIM_CHAR16)
            {
                Tmp[0] = (WCHAR)Val.GetShort();
                Tmp[1] = 0;
                KeyStrValue = Tmp;
            }
            else if( CType::GetActualType(pInfo->nType) == CIM_UINT32 )
            {
                swprintf(Tmp, L"%lu", (ULONG)Val.GetLong());
                KeyStrValue = Tmp;
            }
            else switch (Val.GetType())
            {
                case VT_I4:
                    swprintf(Tmp, L"%d", Val.GetLong());
                    KeyStrValue = Tmp;
                    break;

                case VT_I2:
                    swprintf(Tmp, L"%d", Val.GetShort());
                    KeyStrValue = Tmp;
                    break;

                case VT_UI1:
                    swprintf(Tmp, L"%d", Val.GetByte());
                    KeyStrValue = Tmp;
                    break;

                case VT_BOOL:
                    KeyStrValue = ( Val.GetBool() ? L"TRUE":L"FALSE");
                    break;

                case VT_BSTR:
                case VT_LPWSTR:
                    KeyStrValue = Val.GetLPWSTR();
                    break;
                case VT_LPSTR:
                    KeyStrValue = WString(Val.GetLPSTR());
                    break;
                case VT_NULL:
                    return NULL;
            }

            if(!IsValidKey(KeyStrValue))
                return NULL;

            KeyStr += KeyStrValue;
            bFirst = FALSE;
        }
    }

    if (bFirst)
    {
        // Perhaps it's singleton
        // ======================

        CVar vSingleton;
        if(SUCCEEDED(GetQualifier(QUALNAME_SINGLETON, &vSingleton, NULL))
            && vSingleton.GetBool())
        {
            KeyStr = OPATH_SINGLETON_STRING;
        }
        else
        {
            return 0;
        }
    }

    // Allocate a new string to return.
    // ================================

    return KeyStr.UnbindPtr();

}

BOOL CWbemInstance::IsValidKey(LPCWSTR wszKey)
{
    const WCHAR* pwc = wszKey;
    while(*pwc != 0)
    {
        if(*pwc < 32)
            return FALSE;
        pwc++;
    }
    return TRUE;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
LPWSTR CWbemInstance::GetRelPath( BOOL bNormalized )
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    WString RelPath;

    // Check if any of the keys have been removed
    // ==========================================

    if(m_DecorationPart.AreKeysRemoved())
    {
        return NULL;
    }

    // Start with the class name - if caller wants normalized path, then 
    // use KeyOrigin class.
    // =========================

    if ( !bNormalized )
    {
        RelPath += m_InstancePart.m_Heap.ResolveString(
                m_InstancePart.m_pHeader->ptrClassName)->CreateWStringCopy();
    }
    else
    {
        HRESULT hr = GetKeyOrigin(RelPath);
        if ( FAILED(hr) )
        {
            return NULL;
        }
    }

    // Loop through all properties.
    // ============================

    CPropertyLookupTable& Properties = m_ClassPart.m_Properties;

    BOOL bFirst = TRUE;
    DWORD cKeyProps = 0;

    for (int i = 0; i < Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&m_ClassPart.m_Heap);

        // Determine if this property is marked with a 'key' Qualifier.
        // ============================================================

        if(pInfo->IsKey())
        {
            if ( cKeyProps++ > 0 )
            {
                RelPath += L',';
            }
            else
            {
                RelPath += L".";
            }

            // Determine the type of the key property.
            // =======================================

            RelPath += m_ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                    CreateWStringCopy();

            RelPath += L"=";

            WString KeyStrValue;

            CVar Val;
            if (FAILED(GetProperty(pInfo, &Val)))
            	return NULL;

            BSTR strVal = Val.GetText(0, CType::GetActualType(pInfo->nType));

            // Make sure the BSTR is freed when we go out of scope.
            CSysFreeMe  sfm( strVal );

            if(strVal == NULL || !IsValidKey(strVal))
            {
                return NULL;
            }
            RelPath += strVal;
        }
    }

    if (cKeyProps == 0)
    {
        // Perhaps it's singleton
        // ======================

        CVar vSingleton;
        if(SUCCEEDED(GetQualifier(QUALNAME_SINGLETON, &vSingleton, NULL))
            && vSingleton.GetBool())
        {
            RelPath += L"=" OPATH_SINGLETON_STRING;
        }
        else
        {
            return NULL;
        }
    }
    else if ( cKeyProps == 1 && bNormalized )
    {
        //
        // we want to remove the property name from the first key value.
        //

        LPWSTR wszRelpath = RelPath.UnbindPtr();
 
        WCHAR* pwch1 = wcschr( wszRelpath, '.' );
        WCHAR* pwch2 = wcschr( pwch1, '=' );
        
        //
        // shift the entire relpath down over the first key value.
        //
        wcscpy( pwch1, pwch2 );
        return wszRelpath;
    }
        
    return RelPath.UnbindPtr();
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                    long* plFlags)
{

    CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
    // No Info, so try in the system properties
    if(pInfo == NULL)
    {
        return CSystemProperties::GetPropertyType(wszName, pctType, plFlags);
    }

    HRESULT	hr = GetPropertyType( pInfo, pctType, plFlags );

	// Flavor is always System if this is a system property
	/*
	if ( plFlags && CSystemProperties::IsExtProperty( wszName ) )
	{
		*plFlags = WBEM_FLAVOR_ORIGIN_SYSTEM;
	}
	*/

	return hr;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
HRESULT CWbemInstance::GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                           long* plFlags)
{
    if(pctType)
    {
        *pctType = CType::GetActualType(pInfo->nType);
    }

    if(plFlags)
    {

		// For an instance, check if the value is defaulted or not to set the
		// Propagated or Local value.  If it is default, then check if it has
		// local qualifiers.  If not then it is propagetd.

		*plFlags = WBEM_FLAVOR_ORIGIN_PROPAGATED;

		if ( m_InstancePart.m_DataTable.IsDefault(pInfo->nDataIndex) )
		{
			LPMEMORY pQualifierSetData = m_InstancePart.m_PropQualifiers.
						GetQualifierSetData(pInfo->nDataIndex);

			if( NULL != pQualifierSetData &&
					!CBasicQualifierSet::IsEmpty(pQualifierSetData) )
			{
				*plFlags = WBEM_FLAVOR_ORIGIN_LOCAL;
			}
		}
		else
		{
			*plFlags = WBEM_FLAVOR_ORIGIN_LOCAL;
		}

    }

    return WBEM_NO_ERROR;

}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** ppQualifierSet)
{
    // Check for out of memory
    try
    {
        CLock lock( this, WBEM_FLAG_ALLOW_READ );

        if(wszProperty == NULL || wcslen(wszProperty) == 0)
            return WBEM_E_INVALID_PARAMETER;

        if(wszProperty[0] == L'_')
            return WBEM_E_SYSTEM_PROPERTY;

        CInstancePropertyQualifierSet* pSet =
            new CInstancePropertyQualifierSet;

        if ( NULL == pSet )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        HRESULT hres = InitializePropQualifierSet(wszProperty, *pSet);
        if(FAILED(hres))
        {
            delete pSet;
            *ppQualifierSet = NULL;
            return hres;
        }
        return pSet->QueryInterface(IID_IWbemQualifierSet,
                                    (void**)ppQualifierSet);
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}
//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::GetObjectText(long lFlags, BSTR* pstrText)
{
    // Check for out of memory
    try
    {
		HRESULT	hr = WBEM_S_NO_ERROR;

        CLock lock( this, WBEM_FLAG_ALLOW_READ );

        if(pstrText == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if((lFlags & ~WBEM_FLAG_NO_SEPARATOR & ~WBEM_FLAG_NO_FLAVORS) != 0)
            return WBEM_E_INVALID_PARAMETER;

        *pstrText = NULL;

        WString wsText;

        // start by writing the qualifiers
        // ===============================

        hr = m_InstancePart.m_Qualifiers.GetText(lFlags, wsText);

		if ( FAILED( hr ) )
		{
			return hr;
		}

        // append the instance header
        // ==========================

        wsText += L"\ninstance of ";
        CVar varClass;
        if(FAILED(m_ClassPart.GetClassName(&varClass)))
        {
            // invalid class
            // =============
            *pstrText = NULL;
            return WBEM_E_INCOMPLETE_CLASS;
        }
        wsText += varClass.GetLPWSTR();

        wsText += L"\n{\n";

        // Go through all properties one by one
        // ====================================

        for(int i = 0; i < m_ClassPart.m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = m_ClassPart.m_Properties.GetAt(i);
            CPropertyInformation* pInfo =
                pLookup->GetInformation(&m_ClassPart.m_Heap);

            // Check if it has an actual value set, or  has instance
            // qualifiers
            // =====================================================

            LPMEMORY pQualifierSetData = m_InstancePart.m_PropQualifiers.
                GetQualifierSetData(pInfo->nDataIndex);

            if(!m_InstancePart.m_DataTable.IsDefault(pInfo->nDataIndex) ||
                (pQualifierSetData &&
                    !CBasicQualifierSet::IsEmpty(pQualifierSetData))
              )
            {
                // start with qualifiers
                // =====================

                wsText += L"\t";

                if(pQualifierSetData &&
                    !CBasicQualifierSet::IsEmpty(pQualifierSetData))
                {
                    WString wsTemp;
                    hr = CBasicQualifierSet::GetText(
							pQualifierSetData, &m_InstancePart.m_Heap, lFlags, wsTemp);

					if ( FAILED( hr ) )
					{
						return hr;
					}

                    wsText += wsTemp;
                    if(wsTemp.Length() != 0) wsText += L" ";
                }

                // then the name
                // =============

				BSTR strName = m_ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
					CreateBSTRCopy();
				// Check for allocation failures
				if ( NULL == strName )
				{
					return WBEM_E_OUT_OF_MEMORY;
				}

				// Check if it's an extended system prop.  If so, get the real name
				/*
				int	nExtPropIndex = CSystemProperties::FindExtPropName( strName );
				if ( nExtPropIndex > 0L )
				{
					SysFreeString( strName );
					strName = CSystemProperties::GetExtDisplayNameAsBSTR( nExtPropIndex );

					if ( NULL == strName )
					{
						return WBEM_E_OUT_OF_MEMORY;
					}

				}
				*/

				CSysFreeMe  sfm( strName );
				wsText += strName;

                // then the value, if present
                // ==========================

                if(!m_InstancePart.m_DataTable.IsDefault(pInfo->nDataIndex))
                {
                    wsText += L" = ";
                    if(m_InstancePart.m_DataTable.IsNull(pInfo->nDataIndex))
                    {
                        wsText += L"NULL";
                    }
                    else
                    {
                        CVar varProp;

                        // Check for allocation failures
                        if ( !m_InstancePart.m_DataTable.GetOffset(pInfo->nDataOffset)->
                                StoreToCVar(CType::GetActualType(pInfo->nType), varProp,
                                                             &m_InstancePart.m_Heap) )
                        {
                            return WBEM_E_OUT_OF_MEMORY;
                        }

                        // Cleanup the allocated string
                        LPWSTR wsz = NULL;
                        
                        try
                        {
                            wsz = GetValueText(lFlags, varProp,
                                            CType::GetActualType(pInfo->nType));

                            if ( NULL != wsz )
                            {
                                wsText += wsz;
                                delete [] wsz;
                            }
                        }
                        catch (CX_MemoryException)
                        {
                            delete [] wsz;
                            return WBEM_E_OUT_OF_MEMORY;
                        }
                        catch (...)
                        {
                            delete [] wsz;
                            return WBEM_E_FAILED;
                        }

                    }
                }

                wsText += L";\n";
            }
        }

        wsText += L"}";

        if((lFlags & WBEM_FLAG_NO_SEPARATOR) == 0)
        {
            wsText += L";\n";
        }

        *pstrText = COleAuto::_SysAllocString((LPCWSTR)wsText);
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::GetQualifierSet(IWbemQualifierSet** ppQualifierSet)
{
    // This function does not perform any allocations, so no need for any fancy
    // exception handling.

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppQualifierSet == NULL)
            return WBEM_E_INVALID_PARAMETER;
        return m_InstancePart.m_Qualifiers.QueryInterface(
            IID_IWbemQualifierSet, (void**)ppQualifierSet);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}
//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                                CIMTYPE ctType)
{
    // Check for out of memory
    try
    {
        CLock lock(this);

        if (NULL == wszName)
        	return WBEM_E_INVALID_PARAMETER;
        
		// Only flag we accept, and then only if the property
		// is one of the System Time properties
		if ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

        CVar Var;
        if(pVal)
        {
            if(Var.SetVariant(pVal, TRUE) != CVar::no_error)
                return WBEM_E_TYPE_MISMATCH;
        }
        else
        {
            Var.SetAsNull();
        }

		// Check the supplied name (we're more stringent in this function).
		if(	CSystemProperties::FindName(wszName) >= 0 )
			return WBEM_E_READ_ONLY;

        HRESULT hr = SetPropValue( wszName, &Var, ctType );

        // Perform object validation now
        if ( FAILED( ValidateObject( 0L ) ) )
		{
			hr = WBEM_E_FAILED;
		}

        return hr;

        // Original Code:       return SetPropValue(wszName, &Var, ctType);
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::SetPropValue(LPCWSTR wszName, CVar* pVal, CIMTYPE ctType)
{
	// If any other system property, this fails
    if(CSystemProperties::FindName(wszName) >= 0)
        return WBEM_E_READ_ONLY;

	// If the value starts with an underscore see if it's a System Property
	// DisplayName, and if so, switch to a property name - otherwise, this
	// will just return the string we passed in
	
	//wszName = CSystemProperties::GetExtPropName( wszName );

    CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;

    if(ctType != 0 && (Type_t)ctType != CType::GetActualType(pInfo->nType))
        return WBEM_E_TYPE_MISMATCH;

    // Do a special DateTime Check.  We know at this point, that
    // the value is one of the two valid date/time formats.
    // DMTF or DMTF Interval.  We now need to check that if the
    // "subtype" qualifier exists and is "interval" that the
    // datetime is an interval time.  We will, however, let VT_NULL
    // through, since that will effectively clear the property.

    if ( CType::GetActualType(pInfo->nType) == CIM_DATETIME &&
        !pVal->IsNull() )
    {
        CVar    var;

        if ( SUCCEEDED( GetPropQualifier( pInfo, L"SUBTYPE", &var, NULL ) ) )
        {
            if ( var.GetType() == VT_BSTR || var.GetType() == VT_LPWSTR )
            {
                if ( wbem_wcsicmp( var.GetLPWSTR(), L"interval" ) == 0 )
                {
                    if ( !CUntypedValue::CheckIntervalDateTime( *pVal ) )
                    {
                        return WBEM_E_TYPE_MISMATCH;
                    }
                }   // IF an interval

            }   // IF it was a string

        }   // IF we got a SUBTYPE Qualifier

    }   // IF a DATETIME

    return m_InstancePart.SetActualValue(pInfo, pVal);
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::Delete(LPCWSTR wszName)
{
    // This function doesn't cause any allocations to be performed, so no need
    // for any OutOfMemory exception handling.

    try
    {
        CLock lock(this);

        CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszName);
        if(pInfo == NULL)
        {
            if(CSystemProperties::FindName(wszName) >= 0)
                return WBEM_E_SYSTEM_PROPERTY;
            else
                return WBEM_E_NOT_FOUND;
        }

        // Delete the value
        // ================

        // Set the defaultness as well as nullness based on the class NULLness
        m_InstancePart.m_DataTable.SetDefaultness(pInfo->nDataIndex, TRUE);
        m_InstancePart.m_DataTable.SetNullness( pInfo->nDataIndex,
            m_ClassPart.m_Defaults.IsNull( pInfo->nDataIndex ) );

        // Delete the qualifier set
        // ========================

        if(!m_InstancePart.m_PropQualifiers.IsEmpty())
        {
            CBasicQualifierSet Set;
            LPMEMORY pData = m_InstancePart.m_PropQualifiers.
                                    GetQualifierSetData(pInfo->nDataIndex);
            Set.SetData(pData, &m_InstancePart.m_Heap);

            length_t nOldLength = Set.GetLength();
            CBasicQualifierSet::Delete(pData, &m_InstancePart.m_Heap);
            CBasicQualifierSet::CreateEmpty(pData);

            m_InstancePart.m_PropQualifiers.ReduceQualifierSetSpace(&Set,
                        nOldLength - CBasicQualifierSet::GetMinLength());
        }

        // Perform object validation now
        if ( FAILED( ValidateObject( 0L ) ) )
		{
			return WBEM_E_FAILED;
		}

        return WBEM_S_RESET_TO_DEFAULT;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::Clone(IWbemClassObject** ppCopy)
{
    LPMEMORY pNewData = NULL;

    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(ppCopy == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // We won't support this operation if the class part has been
        // stripped out
        if ( !IsClassPartAvailable() )
        {
            return WBEM_E_INVALID_OPERATION;
        }

        m_InstancePart.Compact();

        // We want to copy the entire memory block
        pNewData = m_pBlobControl->Allocate(m_nTotalLength);

        if ( NULL != pNewData ) 
        {
            memcpy(pNewData, GetStart(), m_nTotalLength);
            CWbemInstance* pNewInstance = new CWbemInstance;

            if ( NULL != pNewInstance )
            {
                // If the class part is internal, we can let SetData perform
                // normally.  Otherwise, we will need to setup our pointers with
                // that in mind.

                if ( IsClassPartInternal() )
                {
                    pNewInstance->SetData(pNewData, m_nTotalLength);
                }
                else if ( IsClassPartShared() )
                {
                    // Setup the New Instance.  Decoration and Instance both come from the
                    // data block.  We can just merge the new Instance's class part with the
                    // same `object we are merged with.

                    pNewInstance->m_DecorationPart.SetData( pNewData );

                    // Because pNewInstance will merge with the same class part as us, pass
                    // our class part member as the class part for parameter for SetData (it
                    // just uses it for informational purposes ).

                    // The m_InstancePart.m_Qualifier.m_pSecondarySet pointer will be incorrect after
                    // this call ( it will point to the cloning source's secondary set ).  By setting
                    // the internal status properly, in the next line, MergeClassPart() will fix
                    // everything up properly.
                    pNewInstance->m_InstancePart.SetData( EndOf( pNewInstance->m_DecorationPart ), pNewInstance, m_ClassPart );

                    // This will "fake out" the status so it fixes up the class part correctly
                    pNewInstance->m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART;

                    HRESULT hr = pNewInstance->MergeClassPart( m_pMergedClassObject );
                    if (FAILED(hr))
                    {
                        delete pNewInstance;
                        return hr;
                    }

                    // Copy the status and length variables.
                    pNewInstance->m_dwInternalStatus = m_dwInternalStatus;
                    pNewInstance->m_nTotalLength = m_nTotalLength;
                }

                pNewInstance->CompactAll();
                pNewInstance->m_nRef = 0;
                return pNewInstance->QueryInterface(IID_IWbemClassObject,
                    (void**)ppCopy);
            }
            else
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    catch (CX_MemoryException)
    {
        // Clean up the byte array
        if ( NULL != pNewData )
        {
            m_pBlobControl->Delete(pNewData);
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        // Clean up the byte array
        if ( NULL != pNewData )
        {
            m_pBlobControl->Delete(pNewData);
        }

        return WBEM_E_FAILED;
    }
    

}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::SpawnDerivedClass(long lFlags,
                                                IWbemClassObject** ppNewClass)
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemInstance::SpawnInstance(long lFlags,
                                IWbemClassObject** ppNewInstance)
{
    LPMEMORY pNewData = NULL;

    // Check for out of memory
    try
    {
        CLock lock( this, WBEM_FLAG_ALLOW_READ );

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(ppNewInstance == NULL)
            return WBEM_E_INVALID_PARAMETER;
        int nLength = EstimateInstanceSpace(m_ClassPart);

        HRESULT hr = WBEM_E_OUT_OF_MEMORY;

        pNewData = m_pBlobControl->Allocate(nLength);

        if ( NULL != pNewData )
        {
            memset(pNewData, 0, nLength);
            CWbemInstance* pNewInstance = new CWbemInstance;

            if ( NULL != pNewInstance )
            {
                // Checked the HRESULT
                hr = pNewInstance->InitEmptyInstance(m_ClassPart, pNewData, nLength);

                if ( SUCCEEDED(hr) )
                {
                    pNewInstance->m_nRef = 0;
                    hr =  pNewInstance->QueryInterface(IID_IWbemClassObject,
                        (void**)ppNewInstance);
                }
                else
                {
                    // Cleanup.  The Instance will have the data
                    delete pNewInstance;
                }

            }   // IF pNewInstance
            else
            {
                // Cleanup
                m_pBlobControl->Delete(pNewData);
            }

        }   // IF pNewData

        return hr;
    }
    catch (CX_MemoryException)
    {
        // Cleanup allocated byte array
        if ( NULL != pNewData )
        {
            m_pBlobControl->Delete(pNewData);
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        // Cleanup allocated byte array
        if ( NULL != pNewData )
        {
            m_pBlobControl->Delete(pNewData);
        }

        return WBEM_E_FAILED;
    }

}
//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::Validate()
{
    for(int i = 0; i < m_ClassPart.m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_ClassPart.m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&m_ClassPart.m_Heap);

        if(!pInfo->CanBeNull(&m_ClassPart.m_Heap))
        {
            // Make sure it is not null
            // ========================

            if(m_InstancePart.m_DataTable.IsNull(pInfo->nDataIndex))
            {
                return WBEM_E_ILLEGAL_NULL;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************

HRESULT CWbemInstance::IsValidObj()
{

    HRESULT hres = m_ClassPart.IsValidClassPart();

    if ( SUCCEEDED( hres ) )
    {
        hres = m_InstancePart.IsValidInstancePart( &m_ClassPart );
    }

    return hres;
}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::PlugKeyHoles()
{
    for(int i = 0; i < m_ClassPart.m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = m_ClassPart.m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&m_ClassPart.m_Heap);

        if(!pInfo->CanBeNull(&m_ClassPart.m_Heap))
        {
            // Make sure it is not null
            // ========================

            if(m_InstancePart.m_DataTable.IsNull(pInfo->nDataIndex))
            {
                if(pInfo->IsKey() &&
                    CType::GetActualType(pInfo->nType) == CIM_STRING)
                {
                    // Get a guid and put it there
                    // ===========================

                    GUID guid;
                    CoCreateGuid(&guid);
                    WCHAR wszBuffer[100];
                    StringFromGUID2(guid, wszBuffer, 100);
                    CVar v;
                    v.SetBSTR(wszBuffer);
                    if(SUCCEEDED(m_InstancePart.SetActualValue(pInfo, &v)))
                        continue;
                }
                return WBEM_E_ILLEGAL_NULL;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}


//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::GetLimitedVersion(IN CLimitationMapping* pMap,
                                        NEWOBJECT CWbemInstance** ppNewInst)
{
    // We may need to clean this up if an exception is thrown
    LPMEMORY pBlock = NULL;

    try
    {

/* LEVN: commented out until a fix for inheritance problem is found
#ifdef DEBUG_CLASS_MAPPINGS
        // Verify this instance has something to do with the map
        HRESULT hr = pMap->ValidateInstance( this );

        if ( FAILED( hr ) )
        {
            return hr;
        }
#endif
*/

        DWORD   dwLength = GetLength();

        // First, check if the class part is internal.  If not, then we
        // need to account for the class part when calculating the
        // length of the datablock for the new instance.

        // Exception handling will handle failure to allocate
        if ( !IsClassPartInternal() )
        {
            dwLength += m_ClassPart.GetLength();
        }

        // Allocate memory for the new object
        // ==================================

        pBlock = CBasicBlobControl::sAllocate(dwLength);

        if ( NULL == pBlock )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memset(pBlock, 0, dwLength);
        LPMEMORY pCurrent = pBlock;
        LPMEMORY pEnd = pBlock + dwLength;

        // Write limited decoration part
        // =============================

        pCurrent = m_DecorationPart.CreateLimitedRepresentation(pMap, pCurrent);
        if(pCurrent == NULL)
        {
            CBasicBlobControl::sDelete(pBlock);
            return WBEM_E_FAILED;
        }

        // Write limited class part. This will augment the map if necessary
        // ================================================================

        BOOL bRemovedKeys;

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value (pEnd - pCurrent).  We are
        // not supporting length > 0xFFFFFFFF so cast is ok.

        pCurrent = m_ClassPart.CreateLimitedRepresentation(pMap,
                        (length_t) ( pEnd - pCurrent ), pCurrent, bRemovedKeys);

        if(pCurrent == NULL)
        {
            CBasicBlobControl::sDelete(pBlock);
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(bRemovedKeys)
        {
            CDecorationPart::MarkKeyRemoval(pBlock);
        }

        // Write limited instance part.
        // ============================

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value (pEnd - pCurrent).  We are
        // not supporting length > 0xFFFFFFFF, so cast is ok

        pCurrent = m_InstancePart.CreateLimitedRepresentation(pMap,
                        (length_t) ( pEnd - pCurrent ), pCurrent);

        if(pCurrent == NULL)
        {
            CBasicBlobControl::sDelete(pBlock);
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Now that we have the memory block for the new instance, create the
        // actual instance object itself
        // ==================================================================

        CWbemInstance* pNew = new CWbemInstance;

        if ( NULL == pNew )
        {
            CBasicBlobControl::sDelete(pBlock);
            return WBEM_E_OUT_OF_MEMORY;
        }

        pNew->SetData(pBlock, dwLength);

        *ppNewInst = pNew;
        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        if ( NULL != pBlock )
        {
            CBasicBlobControl::sDelete(pBlock);
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

HRESULT CWbemInstance::AsymmetricMerge(CWbemInstance* pOldInstance,
                                       CWbemInstance* pNewInstance)
{
    // Verify that the new instance is derived from the old one
    // ========================================================

    CVar vOldName;
    pOldInstance->GetClassName(&vOldName);
    if(pNewInstance->InheritsFrom(vOldName.GetLPWSTR()) != S_OK)
    {
        return WBEM_E_INVALID_CLASS;
    }

    // Access data tables and the property definition table
    // ====================================================

    CDataTable& NewDataTable = pNewInstance->m_InstancePart.m_DataTable;
    CDataTable& OldDataTable = pOldInstance->m_InstancePart.m_DataTable;

    CPropertyLookupTable& LookupTable = pOldInstance->m_ClassPart.m_Properties;
    CFastHeap& ClassHeap = pOldInstance->m_ClassPart.m_Heap;

    CFastHeap& OldHeap = pOldInstance->m_InstancePart.m_Heap;
    CFastHeap& NewHeap = pNewInstance->m_InstancePart.m_Heap;


    // Go through all the properties of the old instance (base)
    // ========================================================

    for(int i = 0; i < LookupTable.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = LookupTable.GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(&ClassHeap);

        // Check if this property is NULL in the new instance ---- that means
        // we need to copy the old one
        // ==================================================================

        if(NewDataTable.IsDefault(pInfo->nDataIndex) &&
            !OldDataTable.IsDefault(pInfo->nDataIndex))
        {
            NewDataTable.SetDefaultness(pInfo->nDataIndex, FALSE);
            if(OldDataTable.IsNull(pInfo->nDataIndex))
            {
                NewDataTable.SetNullness(pInfo->nDataIndex, TRUE);
            }
            else
            {
                NewDataTable.SetNullness(pInfo->nDataIndex, FALSE);

                // Get the pointer sources to the old and new values
                // =================================================

                CDataTablePtr OldSource(&OldDataTable, pInfo->nDataOffset);
                CDataTablePtr NewSource(&NewDataTable, pInfo->nDataOffset);

                // Copy the old one over (nothing to erase)
                // ========================================

                // Check for allocation errors
                if ( !CUntypedValue::CopyTo(&OldSource, pInfo->nType, &NewSource,
                        &OldHeap, &NewHeap) )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}
 void CInstancePart::SetData(LPMEMORY pStart,
                                   CInstancePartContainer* pContainer,
                                   CClassPart& ClassPart)
{
    m_pContainer = pContainer;
    m_pHeader = (CInstancePartHeader*)pStart;

	LPMEMORY pCurrent = pStart + sizeof(CInstancePartHeader);

    m_DataTable.SetData(
        pCurrent,
        ClassPart.m_Properties.GetNumProperties(),
        ClassPart.m_pHeader->nDataLength,
        this);
    m_Qualifiers.SetData(
        EndOf(m_DataTable),
        this,
        &ClassPart.m_Qualifiers);
    m_PropQualifiers.SetData(
        EndOf(m_Qualifiers),
        ClassPart.m_Properties.GetNumProperties(),
        this);
    m_Heap.SetData(
        EndOf(m_PropQualifiers),
        this);
}

HRESULT CInstancePart::IsValidInstancePart( CClassPart* pClassPart )
{
    LPMEMORY    pInstPartStart = GetStart();
    LPMEMORY    pInstPartEnd = GetStart() + GetLength();

    // Check that the header is in the BLOB
    if ( !( (LPMEMORY) m_pHeader >= pInstPartStart &&
            (LPMEMORY) m_pHeader < pInstPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Instance Part Header!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Instance Part Header!") );
        return WBEM_E_FAILED;
    }

    // Check the datatable

    //End and Start can be equal if no properties
    LPMEMORY    pTestStart = m_DataTable.GetStart();
    LPMEMORY    pTestEnd = m_DataTable.GetStart() + m_DataTable.GetLength();

    if ( !( pTestStart == (pInstPartStart + sizeof(CInstancePartHeader)) &&
            pTestEnd >= pTestStart && pTestEnd < pInstPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad DataTable in Instance Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad DataTable in Instance Part!") );
        return WBEM_E_FAILED;
    }

    // Check the qualifier set
    pTestStart = m_Qualifiers.GetStart();
    pTestEnd = m_Qualifiers.GetStart() + m_Qualifiers.GetLength();

    if ( !( pTestStart == EndOf(m_DataTable) &&
            pTestEnd > pTestStart && pTestEnd < pInstPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Qualifier Set in Instance Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Qualifier Set in Instance Part!") );
        return WBEM_E_FAILED;
    }

    // Check the Property Qualifiers
    pTestStart = m_PropQualifiers.GetStart();
    pTestEnd = m_PropQualifiers.GetStart() + m_PropQualifiers.GetLength();

    // A delete qualifier on an instance part, can cause a gap between it and the
    // property qualifiers, so as long as this is in the BLOB, we'll call it okay.

    if ( !( pTestStart >= EndOf(m_Qualifiers) &&
            pTestEnd > pTestStart && pTestEnd < pInstPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Property Qualifier Set in Instance Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Property Qualifier Set in Instance Part!") );
        return WBEM_E_FAILED;
    }

    // Check the Heap
    LPMEMORY    pHeapStart = m_Heap.GetStart();
    LPMEMORY    pHeapEnd = m_Heap.GetStart() + m_Heap.GetLength();

    // A delete qualifier on an property qualifier, can cause a gap between it and the
    // heap, so as long as this is in the BLOB, we'll call it okay.

    if ( !( pHeapStart >= EndOf(m_PropQualifiers) &&
            pHeapEnd > pHeapStart && pHeapEnd <= pInstPartEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Heap in Instance Part!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Heap in Instance Part!") );
        return WBEM_E_FAILED;
    }

    // Get the heap data start
    pHeapStart = m_Heap.GetHeapData();

    // Check that the classname pointer is in the BLOB
    LPMEMORY    pClassName = m_Heap.ResolveHeapPointer( m_pHeader->ptrClassName );
    if ( !( pClassName >= pHeapStart && pClassName < pHeapEnd ) )
    {
        OutputDebugString(__TEXT("Winmgmt: Bad Class Name pointer in Instance Part Header!"));
        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Class Name pointer in Instance Part Header!") );
        return WBEM_E_FAILED;
    }

    // Now check the qualifier set
    HRESULT hres = m_Qualifiers.IsValidQualifierSet();
    if ( FAILED(hres) )
    {
        return hres;
    }

    // We're going to walk the instance property list and for every property
    // we find, if it's not NULL or DEFAULT , and a string, array or object,
    // verify that it actually points into a location in our heap.

    for(int i = 0; i < pClassPart->m_Properties.GetNumProperties(); i++)
    {
        // At this point, we know the class part is valid
        CPropertyLookup* pLookup = pClassPart->m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&pClassPart->m_Heap);

        if( !m_DataTable.IsNull(pInfo->nDataIndex) &&
            !m_DataTable.IsDefault(pInfo->nDataIndex) )
        {
            if ( CType::IsPointerType( pInfo->nType ) )
            {
                CUntypedValue*  pValue = m_DataTable.GetOffset( pInfo->nDataOffset );

                if ( (LPMEMORY) pValue >= pInstPartStart && (LPMEMORY) pValue < pInstPartEnd )
                {
                    LPMEMORY    pData = m_Heap.ResolveHeapPointer( pValue->AccessPtrData() );

                    if ( pData >= pHeapStart && pData < pHeapEnd  )
                    {
                        // We could, if an embedded object, validate the object,
                        // or if an array of ptr values, validate those as well

                        if ( CType::IsArray( pInfo->nType ) )
                        {
                            hres = ((CUntypedArray*) pData)->IsArrayValid( pInfo->nType, &m_Heap );

                            if ( FAILED( hres ) )
                            {
                                return hres;
                            }
                        }
                    }
                    else
                    {
                        OutputDebugString(__TEXT("Winmgmt: Bad Property Value in Instance Part!"));
                        FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Property Value in Instance Part!") );
                        return WBEM_E_FAILED;
                    }
                }
                else
                {
                    OutputDebugString(__TEXT("Winmgmt: Bad Untyped Value Pointer in Instance Part DataTable!"));
                    FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Untyped Value Pointer in Instance Part DataTable!") );
                    return WBEM_E_FAILED;
                }

            }   // IF is Pointer

        }   // IF not NULL or default

        // Now check the qualifier set.
        CInstancePropertyQualifierSet   ipqs;

         ipqs.SetData(&m_PropQualifiers, pInfo->nDataIndex,
            pClassPart, (length_t) ( pInfo->GetQualifierSetData() - pClassPart->GetStart() )
        );

        hres = ipqs.IsValidQualifierSet();

        if ( FAILED( hres ) )
        {
            return hres;
        }


    }   // FOR iterate properties

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 void CInstancePart::Rebase(LPMEMORY pNewMemory)
{
    m_pHeader = (CInstancePartHeader*)pNewMemory;

	LPMEMORY pCurrent = pNewMemory + sizeof(CInstancePartHeader);

    m_DataTable.Rebase( pCurrent );
    m_Qualifiers.Rebase( EndOf(m_DataTable) );
    m_PropQualifiers.Rebase( EndOf(m_Qualifiers) );
    m_Heap.Rebase( EndOf(m_PropQualifiers) );
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
BOOL CInstancePart::ReallocAndCompact(length_t nNewTotalLength)
{
    BOOL    fReturn = TRUE;
    Compact();

    // Reallocate if required (will call rebase)
    // =========================================

    if(nNewTotalLength > m_pHeader->nLength)
    {
        fReturn = m_pContainer->ExtendInstancePartSpace(this, nNewTotalLength);

        if ( fReturn )
        {
            m_pHeader->nLength = nNewTotalLength;
        }
    }

    return fReturn;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 void CInstancePart::Compact( bool bTrim /* = true */)
{
    // Compact
    // =======
	LPMEMORY pCurrent = GetStart() + sizeof(CInstancePartHeader);

    CopyBlock( m_DataTable, pCurrent );
    CopyBlock(m_Qualifiers, EndOf(m_DataTable));
    CopyBlock(m_PropQualifiers, EndOf(m_Qualifiers));
    CopyBlock(m_Heap, EndOf(m_PropQualifiers));

	if ( bTrim )
		m_Heap.Trim();
}


//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 length_t CInstancePart::ComputeNecessarySpace(CClassPart* pClassPart)
{
    return sizeof(CInstancePartHeader) +
        CDataTable::ComputeNecessarySpace(
                        pClassPart->m_Properties.GetNumProperties(),
                        pClassPart->m_pHeader->nDataLength) +
        CInstanceQualifierSet::GetMinLength() +
        CInstancePropertyQualifierSetList::ComputeNecessarySpace(
                        pClassPart->m_Properties.GetNumProperties()) +
        CFastHeap::GetMinLength() +
        pClassPart->m_Heap.ResolveString(
		pClassPart->m_pHeader->ptrClassName)->GetLength();
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 LPMEMORY CInstancePart::Create(LPMEMORY pStart, CClassPart* pClassPart,
                                      CInstancePartContainer* pContainer)
{
    m_pContainer = pContainer;

    // Create instance header
    // ======================

    LPMEMORY pCurrent = pStart + sizeof(CInstancePartHeader);
    m_pHeader = (CInstancePartHeader*)pStart;

    // Create data table appropriate for the class
    // ===========================================

    int nNumProps = pClassPart->m_Properties.GetNumProperties();
    m_DataTable.SetData(
        pCurrent,
        nNumProps,
        pClassPart->m_pHeader->nDataLength,
        this);
    m_DataTable.SetAllToDefault();
    m_DataTable.CopyNullness(&pClassPart->m_Defaults);

    // Create empty instance qualifier set
    // ===================================

    pCurrent = EndOf(m_DataTable);
    CInstanceQualifierSet::CreateEmpty(pCurrent);
    m_Qualifiers.SetData(
        pCurrent,
        this,
        &pClassPart->m_Qualifiers);

    // Create a list of empty qualifier sets for all properties
    // ========================================================

    pCurrent = EndOf(m_Qualifiers);
    CInstancePropertyQualifierSetList::CreateListOfEmpties(pCurrent,
        nNumProps
    );
    m_PropQualifiers.SetData(
        pCurrent,
        nNumProps,
        this);

    // Create a heap that is just large enough to contain the class name
    // =================================================================

    CCompressedString* pcsName =
        pClassPart->m_Heap.ResolveString(pClassPart->m_pHeader->ptrClassName);
    int nNameLen = pcsName->GetLength();

    pCurrent = EndOf(m_PropQualifiers);
    m_Heap.CreateOutOfLine(pCurrent, nNameLen);
    m_Heap.SetContainer(this);

    // Copy the name to the heap
    // =========================

    // Check for Allocation failure
    if ( !m_Heap.Allocate(nNameLen, m_pHeader->ptrClassName) )
    {
        return NULL;
    }
    
    memcpy(m_Heap.ResolveHeapPointer(m_pHeader->ptrClassName),
        pcsName, nNameLen );

    // Configure the instance header structure properly
    // ================================================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting
    // length > 0xFFFFFFFF, so cast is ok

    m_pHeader->nLength = (length_t) ( EndOf(m_Heap) - GetStart() );

    return pStart + m_pHeader->nLength;
}






//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CInstancePart::GetActualValue(CPropertyInformation* pInfo,
                                          CVar* pVar)
{
    if(m_DataTable.IsNull(pInfo->nDataIndex))
    {
        pVar->SetAsNull();
        return WBEM_S_NO_ERROR;
    }
    CUntypedValue* pValue = m_DataTable.GetOffset(pInfo->nDataOffset);

    // Check for allocation failure
    if ( !pValue->StoreToCVar(pInfo->GetType(), *pVar, &m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;

}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CInstancePart::SetActualValue(CPropertyInformation* pInfo,
                                             CVar* pVar)
{
    if(pVar->IsNull() || pVar->IsDataNull())
    {
        m_DataTable.SetNullness(pInfo->nDataIndex, TRUE);
        m_DataTable.SetDefaultness(pInfo->nDataIndex, FALSE);
    }
    else
    {
        if(!CUntypedValue::CheckCVar(*pVar, pInfo->GetType()))
            return WBEM_E_TYPE_MISMATCH;

        // Check the type
        // ==============

        VARTYPE vtTarget = CType::GetVARTYPE(pInfo->GetType());
        if(!CType::DoesCIMTYPEMatchVARTYPE(pInfo->GetType(),
                                            (VARTYPE) pVar->GetOleType()))
        {
            // Attempt coercion
            // ================

            if(!pVar->ChangeTypeTo(CType::GetVARTYPE(pInfo->GetType())))
                return WBEM_E_TYPE_MISMATCH;
        }

        // Check for special case of replacing a string with a shorted one
        // ===============================================================

        BOOL bUseOld = !m_DataTable.IsDefault(pInfo->nDataIndex) &&
                       !m_DataTable.IsNull(pInfo->nDataIndex);

        // Create a value pointing to the right offset in the data table
        // =============================================================

        CDataTablePtr ValuePtr(&m_DataTable, pInfo->nDataOffset);

        int nDataIndex = pInfo->nDataIndex;

        // Load it (types have already been checked)
        // =========================================

        // Check for possible memory allocation failures
        Type_t  nReturnType;
        HRESULT hr = CUntypedValue::LoadFromCVar(&ValuePtr, *pVar,
                        CType::GetActualType(pInfo->GetType()), &m_Heap, nReturnType, bUseOld);

        if ( FAILED( hr ) )
        {
            return hr;
        }

        if ( CIM_ILLEGAL == nReturnType )
        {
            return WBEM_E_TYPE_MISMATCH;
        }

        pInfo = NULL; // invalidated

        // Clear the special bits
        // ======================

        m_DataTable.SetNullness(nDataIndex, FALSE);
        m_DataTable.SetDefaultness(nDataIndex, FALSE);
        m_pContainer->ClearCachedKeyValue();

    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CInstancePart::GetObjectQualifier(LPCWSTR wszName, CVar* pVar,
                                    long* plFlavor)
{
    int nKnownIndex;    // garbage
    CQualifier* pQual = m_Qualifiers.GetQualifierLocally(wszName, nKnownIndex);

    if(pQual == NULL) return WBEM_E_NOT_FOUND;
    if(plFlavor) *plFlavor = pQual->fFlavor;

    // Check for allocation failures
    if ( !pQual->Value.StoreToCVar(*pVar, &m_Heap) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CInstancePart::SetInstanceQualifier(LPCWSTR wszName, CVar* pVar,
        long lFlavor)
{
    if(pVar->IsDataNull())
        return WBEM_E_INVALID_PARAMETER;

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Grab errors directly from this call
    HRESULT hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVar, &m_Heap);

    if ( SUCCEEDED( hr ) )
    {
        hr = m_Qualifiers.SetQualifierValue(wszName, (BYTE)lFlavor,
                &Value, TRUE);
    }

    return hr;
}

// Helper that sends a value directly into a qualifier
HRESULT CInstancePart::SetInstanceQualifier( LPCWSTR wszName, long lFlavor, CTypedValue* pTypedValue )
{        
    return  m_Qualifiers.SetQualifierValue( wszName, (BYTE)lFlavor, pTypedValue, TRUE );
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CInstancePart::GetQualifier(LPCWSTR wszName, CVar* pVar,
                                    long* plFlavor, CIMTYPE* pct /*=NULL*/)
{
    return m_Qualifiers.GetQualifier( wszName, pVar, plFlavor, pct /*=NULL*/ );
}

// Returns a copy of the live typed value
HRESULT CInstancePart::GetQualifier( LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedValue,
									CFastHeap** ppHeap, BOOL fValidateSet )
{
    return m_Qualifiers.GetQualifier( wszName, plFlavor, pTypedValue, ppHeap, fValidateSet );
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
BOOL CInstancePart::TranslateToNewHeap(CClassPart& ClassPart,
                                              CFastHeap* pOldHeap,
                                              CFastHeap* pNewHeap)
{
    // Use a stack variable, since a reallocation can occur here
    heapptr_t   ptrTemp;
    if ( !CCompressedString::CopyToNewHeap(
            m_pHeader->ptrClassName, pOldHeap, pNewHeap, ptrTemp ) )
    {
        return FALSE;
    }

    // Store the new value
    m_pHeader->ptrClassName = ptrTemp;

    // Check for allocation failure
    if ( !m_DataTable.TranslateToNewHeap(&ClassPart.m_Properties, FALSE,
                                         pOldHeap, pNewHeap) )
    {
        return FALSE;
    }

    CStaticPtr QualPtr(m_Qualifiers.GetStart());

    // Check for allocation failure
    if ( !CBasicQualifierSet::TranslateToNewHeap(&QualPtr, pOldHeap, pNewHeap) )
    {
        return FALSE;
    }

    // Check for allocation failure
    if ( !m_PropQualifiers.TranslateToNewHeap(pOldHeap, pNewHeap) )
    {
        return FALSE;
    }

    return TRUE;

}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************

void CInstancePart::DeleteProperty(CPropertyInformation* pInfo)
{
    m_DataTable.RemoveProperty(pInfo->nDataIndex, pInfo->nDataOffset,
                    CType::GetLength(pInfo->nType));
    m_PropQualifiers.DeleteQualifierSet(pInfo->nDataIndex);
    Compact();
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************

LPMEMORY CInstancePart::ConvertToClass(CClassPart& ClassPart, length_t nLen,
                                        LPMEMORY pMemory)
{
    LPMEMORY pCurrent = pMemory;
    memcpy(pCurrent, (LPMEMORY)m_pHeader, sizeof(CInstancePartHeader));
    CInstancePartHeader* pNewHeader = (CInstancePartHeader*)pCurrent;
    pNewHeader->nLength = nLen;

    // NOTE: class name is intentionally left old.

    pCurrent += sizeof(CInstancePartHeader);

    // Write the data table
    // ====================

    pCurrent = m_DataTable.WriteSmallerVersion(
                    ClassPart.m_Properties.GetNumProperties(),
                    ClassPart.m_pHeader->nDataLength,
                    pCurrent);

    // Write qualifiers
    // ================

    memcpy(pCurrent, m_Qualifiers.GetStart(), m_Qualifiers.GetLength());
    pCurrent += m_Qualifiers.GetLength();

    // Write property qualifiers
    // =========================

    pCurrent = m_PropQualifiers.WriteSmallerVersion(
                    ClassPart.m_Properties.GetNumProperties(), pCurrent);

    // Copy the heap
    // =============

    memcpy(pCurrent, m_Heap.GetStart(), m_Heap.GetLength());
    pCurrent += m_Heap.GetLength();

    return pCurrent;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 void CWbemInstance::SetData(LPMEMORY pStart, int nTotalLength)
{
    m_nTotalLength = nTotalLength;

    m_DecorationPart.SetData(pStart);
    m_ClassPart.SetData(
        m_DecorationPart.GetStart() + m_DecorationPart.GetLength(),
        this);
    m_InstancePart.SetData(
        m_ClassPart.GetStart() + m_ClassPart.GetLength(),
        this,
        m_ClassPart);

    // Everything is internal now
    m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART |
                        WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL;

}

 //******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
void CWbemInstance::SetData( LPMEMORY pStart, int nTotalLength, DWORD dwBLOBStatus )
{
    m_nTotalLength = nTotalLength;

    // Check for this, but don't fail, since this is internal, and only to prevent
    // lazy development
    _ASSERT( dwBLOBStatus & WBEM_OBJ_DECORATION_PART, __TEXT("CWbemInstance::SetData called without Decoration Part specified!"))

    // Decoration part is assumed
    m_DecorationPart.SetData(pStart);

    // Set Instance and Class only if they are available.  Note that for
    // Instance to work, we NEED to have the class, so even if the data is
    // available in the BLOB, without a class to describe it, the data
    // is effectively useless.

    if ( dwBLOBStatus & WBEM_OBJ_CLASS_PART )
    {
        m_ClassPart.SetData(
            m_DecorationPart.GetStart() + m_DecorationPart.GetLength(),
            this);

        if ( dwBLOBStatus & WBEM_OBJ_INSTANCE_PART )
        {
            m_InstancePart.SetData(
                m_ClassPart.GetStart() + m_ClassPart.GetLength(),
                this,
                m_ClassPart);
        }
    }

    // Save the local BLOB Status
    m_dwInternalStatus = dwBLOBStatus;

}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
void CWbemInstance::Rebase(LPMEMORY pMemory)
{
    m_DecorationPart.Rebase(pMemory);

    // Different based on whether the class is internal or not
    if ( IsClassPartInternal() )
    {
        m_ClassPart.Rebase( EndOf(m_DecorationPart));
        m_InstancePart.Rebase( EndOf(m_ClassPart));
    }
    else
    {
        m_InstancePart.Rebase( EndOf(m_DecorationPart));
    }
}



//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::InitializePropQualifierSet(LPCWSTR wszProp,
                                CInstancePropertyQualifierSet& IPQS)
{
    CPropertyInformation* pInfo = m_ClassPart.FindPropertyInfo(wszProp);
    if(pInfo == NULL) return WBEM_E_NOT_FOUND;

    return InitializePropQualifierSet(pInfo, IPQS);
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::InitializePropQualifierSet(
                                CPropertyInformation* pInfo,
                                CInstancePropertyQualifierSet& IPQS)
{
    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value (pInfo->GetQualifierSetData() - m_ClassPart.GetStart().
    // We are not supporting length > 0xFFFFFFFF, so cast is ok

     IPQS.SetData(&m_InstancePart.m_PropQualifiers, pInfo->nDataIndex,
        &m_ClassPart, (length_t) ( pInfo->GetQualifierSetData() - m_ClassPart.GetStart() )
    );
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::GetPropQualifier(CPropertyInformation* pInfo,
                                              LPCWSTR wszQualifier,
                                              CVar* pVar, long* plFlavor,
											  CIMTYPE* pct /*=NULL*/)
{
    // Access that property's qualifier set
    // ====================================
    CInstancePropertyQualifierSet IPQS;
    HRESULT hres = InitializePropQualifierSet(pInfo, IPQS);

    // Get the qualifier
    // =================

    BOOL bIsLocal;
    CQualifier* pQual = IPQS.GetQualifier(wszQualifier, bIsLocal);
    if(pQual == NULL) return WBEM_E_NOT_FOUND;

    // Convert to CVar
    // ===============

    if(plFlavor)
    {
        *plFlavor = pQual->fFlavor;
        CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, bIsLocal);
    }

	if ( NULL != pct )
	{
		*pct = pQual->Value.GetType();
	}

    // Check for allocation failures
	if ( NULL != pVar )
	{
		if ( !pQual->Value.StoreToCVar(*pVar,
				(bIsLocal)?&m_InstancePart.m_Heap:&m_ClassPart.m_Heap) )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

    return WBEM_NO_ERROR;
}

HRESULT CWbemInstance::GetPropQualifier(CPropertyInformation* pInfo,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet)
{
    // Access that property's qualifier set
    // ====================================
    CInstancePropertyQualifierSet IPQS;
    HRESULT hr = InitializePropQualifierSet(pInfo, IPQS);

	if ( FAILED(hr))
	{
		return hr;
	}

    // Get the qualifier
    // =================

    BOOL bIsLocal;
    CQualifier* pQual = IPQS.GetQualifier(wszQualifier, bIsLocal);
    if(pQual == NULL) return WBEM_E_NOT_FOUND;

	// Make sure a set will actually work - Ostensibly we are calling this API because we need
	// direct access to a qualifier's underlying data before actually setting (possibly because
	// the qualifier is an array).
	if ( fValidateSet )
	{
		hr = IPQS.ValidateSet( wszQualifier, pQual->fFlavor, pTypedVal, TRUE, TRUE );
	}

	// 
    // Convert to CVar
    // ===============

    if(plFlavor)
    {
        *plFlavor = pQual->fFlavor;
        CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, bIsLocal);
    }

	// Store the heap
	*ppHeap = (bIsLocal)?&m_InstancePart.m_Heap:&m_ClassPart.m_Heap;

	if ( NULL != pTypedVal )
	{
		pQual->Value.CopyTo( pTypedVal );
	}

    return hr;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::GetMethodQualifier(LPCWSTR wszMethodName,
                                              LPCWSTR wszQualifier,
                                              CVar* pVar, long* plFlavor,
											  CIMTYPE* pct /*=NULL*/)
{
    return WBEM_E_INVALID_OPERATION;
}

HRESULT CWbemInstance::GetMethodQualifier(LPCWSTR wszMethodName,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet)
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 HRESULT CWbemInstance::SetPropQualifier(LPCWSTR wszProp,
                                              LPCWSTR wszQualifier,
                                       long lFlavor, CVar *pVal)
{
    if(pVal->IsDataNull())
        return WBEM_E_INVALID_PARAMETER;

    // Access that property's qualifier set
    // ====================================

    CInstancePropertyQualifierSet IPQS;
    HRESULT hres = InitializePropQualifierSet(wszProp, IPQS);

    // Set the qualifier
    // =================

    CTypedValue Value;
    CStaticPtr ValuePtr((LPMEMORY)&Value);

    // Get errors directly from this call
    HRESULT hr = CTypedValue::LoadFromCVar(&ValuePtr, *pVal, &m_InstancePart.m_Heap);

    if ( SUCCEEDED( hr ) )
    {
        IPQS.SelfRebase();
        hr = IPQS.SetQualifierValue(wszQualifier, (BYTE)lFlavor, &Value, TRUE);
    }

    return hr;
}

HRESULT CWbemInstance::SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
										long lFlavor, CTypedValue* pTypedVal)
{
    // Access that property's qualifier set
    // ====================================

    CInstancePropertyQualifierSet IPQS;
    HRESULT hr = InitializePropQualifierSet(wszProp, IPQS);

    if ( SUCCEEDED( hr ) )
    {
        hr = IPQS.SetQualifierValue(wszQualifier, (BYTE)lFlavor, pTypedVal, TRUE);
    }

    return hr;
}

HRESULT CWbemInstance::SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
										CVar *pVal)
{
    return WBEM_E_INVALID_OPERATION;
}

HRESULT CWbemInstance::SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
										long lFlavor, CTypedValue* pTypedVal)
{
    return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 length_t CWbemInstance::EstimateInstanceSpace(
                               CClassPart& ClassPart,
                               CDecorationPart* pDecoration)
{
    return ClassPart.GetLength() +
        CInstancePart::ComputeNecessarySpace(&ClassPart) +
        ((pDecoration)?
            pDecoration->GetLength()
            :CDecorationPart::GetMinLength());
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CWbemInstance::InitNew(CWbemClass* pClass, int nExtraMem,
                    CDecorationPart* pDecoration)
{
    if(pClass->m_CombinedPart.m_ClassPart.m_pHeader->ptrClassName ==
                                                        INVALID_HEAP_ADDRESS)
        return WBEM_E_INCOMPLETE_CLASS;
    int nLength = EstimateInstanceSpace(pClass->m_CombinedPart.m_ClassPart) +
                                            nExtraMem;

    HRESULT hr = WBEM_E_OUT_OF_MEMORY;
    LPMEMORY pNewData = m_pBlobControl->Allocate(nLength);

    if ( NULL != pNewData )
    {
        memset(pNewData, 0, nLength);
        hr = InitEmptyInstance(pClass->m_CombinedPart.m_ClassPart, pNewData, nLength);
    }

    return hr;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
 CWbemInstance* CWbemInstance::CreateFromBlob(CWbemClass* pClass,
                                                  LPMEMORY pInstPart)
{
    CWbemInstance* pInstance = new CWbemInstance;

    if ( NULL != pInstance )
    {
        // Allocate new memory
        // ===================

        int nInstancePartLen = CInstancePart::GetLength(pInstPart);
        int nTotalLen = pClass->m_CombinedPart.m_ClassPart.GetLength() +
                                nInstancePartLen + CDecorationPart::GetMinLength();

        // Create decoration part
        // ======================

        LPMEMORY pNewMem =  pInstance->m_pBlobControl->Allocate(nTotalLen);

        if ( NULL != pNewMem )
        {
            memset(pNewMem, 0, nTotalLen);
            LPMEMORY pCurrentEnd = pInstance->m_DecorationPart.CreateEmpty(
                OBJECT_FLAG_INSTANCE, pNewMem);

            // Create class part
            // =================
            memcpy(pCurrentEnd, pClass->m_CombinedPart.m_ClassPart.GetStart(),
                        pClass->m_CombinedPart.m_ClassPart.GetLength());
            pInstance->m_ClassPart.SetData(pCurrentEnd, pInstance);

            pCurrentEnd += pInstance->m_ClassPart.GetLength();

            // Create instance part
            // ====================

            memcpy(pCurrentEnd, pInstPart, nInstancePartLen);
            pInstance->m_InstancePart.SetData(pCurrentEnd, pInstance,
                                              pInstance->m_ClassPart);

            pInstance->m_nTotalLength = nTotalLen;

            // Everything is internal
            pInstance->m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART |
                                            WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL;

            // Perform object validation here
	        if ( FAILED( pInstance->ValidateObject( 0L ) ) )
			{
				pInstance->Release();
				pInstance = NULL;
			}


        }   // IF NULL != pNewMem
        else
        {
            // Cleanup
            delete pInstance;
            pInstance = NULL;

            throw CX_MemoryException();
        }

    }   // IF NULL != pInstance
    else
    {
        throw CX_MemoryException();
    }

    return pInstance;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
HRESULT CWbemInstance::Unmerge(LPMEMORY pStart, int nAllocatedLength, length_t* pnUnmergedLength )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // See if the object looks okay before we pull it apart
    hr = ValidateObject( 0L );

	if ( FAILED( hr ) )
	{
		return hr;
	}

    // Before doing the memcpy, shut off the localization flag, then if it
    // was on, turn it back on again.

    BOOL    fLocalized = m_InstancePart.IsLocalized();

    // Turn it off
    if ( fLocalized )
    {
        m_InstancePart.SetLocalized( FALSE );
    }

    memcpy(pStart, m_InstancePart.GetStart(), m_InstancePart.GetLength());

    // Turn it back on
    if ( fLocalized )
    {
        m_InstancePart.SetLocalized( TRUE );
    }

    CInstancePart IP;
    IP.SetData(pStart, this, m_ClassPart);
    IP.m_Heap.Empty();

    // Check for allocation failurtes
    if ( IP.TranslateToNewHeap(m_ClassPart, &m_InstancePart.m_Heap, &IP.m_Heap) )
    {
        IP.m_Heap.Trim();

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  We are not supporting length
        // > 0xFFFFFFFF, so cast is ok

        IP.m_pHeader->nLength = (length_t) ( EndOf(IP.m_Heap) - IP.GetStart() );

        if ( NULL != pnUnmergedLength )
        {
            *pnUnmergedLength = IP.GetLength();
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

/*
    IP.m_pHeader->nProps = m_ClassPart.m_Properties.GetNumProperties();
    IP.m_pHeader->nHeapOffset = IP.m_Heap.GetStart() - IP.GetStart();
*/

    return hr;
}


HRESULT CWbemInstance::CopyBlob(LPMEMORY pBlob, int nLength)
{
    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
    // signed/unsigned 32-bit value.  We are not supporting length
    // > 0xFFFFFFFF, so cast is ok

    int nOffset = (int) ( m_InstancePart.GetStart() - GetStart() );

    if(nLength - nOffset > m_InstancePart.GetLength())
    {
        // Check for insufficient memory
        if ( !ExtendInstancePartSpace(&m_InstancePart, nLength - nOffset) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    memcpy(m_InstancePart.GetStart(), pBlob + nOffset, nLength - nOffset);
    m_InstancePart.SetData(m_InstancePart.GetStart(), this, m_ClassPart);
    return WBEM_S_NO_ERROR;
}

HRESULT CWbemInstance::CopyBlobOf(CWbemObject* pSource)
{
    try
    {
        // Lock both BLOBs during this operation
        CLock lock1(this);
        CLock lock2(pSource, WBEM_FLAG_ALLOW_READ);

        CWbemInstance* pOther = (CWbemInstance*)pSource;

        int nLen = pOther->m_InstancePart.GetLength();

        // We will need to call SetData if the used data sizes are different,
        // or qualifier data is different

        BOOL fSetData =     ( m_InstancePart.m_Heap.GetUsedLength() !=
                                pOther->m_InstancePart.m_Heap.GetUsedLength() )
                        ||  ( m_InstancePart.m_Qualifiers.GetLength() !=
                                pOther->m_InstancePart.m_Qualifiers.GetLength() )
                        ||  ( m_InstancePart.m_PropQualifiers.GetLength() !=
                                pOther->m_InstancePart.m_PropQualifiers.GetLength() );

        if(nLen > m_InstancePart.GetLength())
        {
            // Check for insufficient memory
            if ( !ExtendInstancePartSpace(&m_InstancePart, nLen) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            // This needs to reflect the new length (normally this
            // is done in ReallocAndCompact
            m_InstancePart.m_pHeader->nLength = nLen;

            // If the lengths didn't match, we should also call SetData
            fSetData = TRUE;
        }

        memcpy(m_InstancePart.GetStart(), pOther->m_InstancePart.GetStart(), nLen);

    #ifdef _DEBUG
        // During DEBUG HeapValidate our BLOB
        CWin32DefaultArena::ValidateHeap( 0, GetStart() );
    #endif

        // DEVNOTE:TODO:SANJ - Is this call too costly?

        // This call properly sets up our data if any lengths changed.
        if ( fSetData )
        {
            m_InstancePart.SetData(m_InstancePart.GetStart(), this, m_ClassPart);
        }

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        // Something bad happened
        return WBEM_E_CRITICAL_ERROR;
    }
}

// A transfer blob consists of long specifying the length of the used heap data, and then
// instance data.  The used heap data is necessary so the client side will be able to
// correctly set up the heap.

void CWbemInstance::GetActualTransferBlob( BYTE* pBlob )
{
    // Set the used data length, then skip over that
    (*(UNALIGNED long*) pBlob) = m_InstancePart.m_Heap.GetUsedLength();
    pBlob += sizeof(long);

    // Only copies actual BLOB data
    memcpy( pBlob, m_InstancePart.m_DataTable.GetStart(), GetActualTransferBlobSize() );
}

HRESULT CWbemInstance::GetTransferBlob(long *plBlobType, long *plBlobLen,
                                /* CoTaskAlloced! */ BYTE** ppBlob)
{
    try
    {
        // Lock this BLOB during this operation
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        *plBlobType = WBEM_BLOB_TYPE_ALL;
        *plBlobLen = GetTransferBlobSize();



        // Check for insufficient memory
        *ppBlob = (LPMEMORY)CoTaskMemAlloc(*plBlobLen);
        if ( NULL == *ppBlob )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        // This will setup the actual blob correctly
        GetActualTransferBlob( *ppBlob );

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

HRESULT CWbemInstance::GetTransferArrayBlob( long lBlobLen, BYTE** ppBlob, long* plBlobLen)
{
    try
    {
        // Lock this BLOB during this operation
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        HRESULT hr = WBEM_S_NO_ERROR;
        BYTE*   pTemp = *ppBlob;

        *plBlobLen = GetTransferArrayBlobSize();

        // Make sure the buffer is big enough to hold the BLOB plus the long
        if ( *plBlobLen <= lBlobLen )
        {
            // This should indicate the actual size of the tramsfer blob.
            *((UNALIGNED long*) pTemp) = GetTransferBlobSize();

            // Now skip the long and set the heap used data value, then copy the blob data
            pTemp += sizeof(long);

            // This will setup the actual Transfer Blob portion correctly
            GetActualTransferBlob( pTemp );

            // Point ppBlob at the next available blob
            *ppBlob += *plBlobLen;
        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

HRESULT CWbemInstance::CopyActualTransferBlob(long lBlobLen, BYTE* pBlob)

{
    try
    {
        // Lock this BLOB during this operation
        CLock lock(this);

        // The actual data is preceded by a long indicating the size of the
        // used data in the heap so we can set values correctly after copying data
        UNALIGNED long*   pUsedDataLen = (UNALIGNED long*) pBlob;
        pBlob += sizeof(long);

        // Make sure we adjust lBlobLen appropriately as well
        lBlobLen -= sizeof(long);

        HRESULT hr = WBEM_S_NO_ERROR;

        // Make sure we will be big enough to copy the BLOB into

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  We are not supporting
        // length > 0xFFFFFFFF, so cast is ok

        long lCurrentLength = (long) ( m_InstancePart.m_Heap.GetStart() +
                        m_InstancePart.m_Heap.GetRealLength() -
                        m_InstancePart.m_DataTable.GetStart() );

        if ( lBlobLen > lCurrentLength )
        {
            length_t    nNewLength = m_InstancePart.GetLength() + ( lBlobLen - lCurrentLength );

            if ( !ExtendInstancePartSpace( &m_InstancePart, nNewLength ) )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            // This needs to reflect the new length (normally this
            // is done in ReallocAndCompact
            m_InstancePart.m_pHeader->nLength = nNewLength;

        }

        if ( SUCCEEDED( hr ) )
        {
            memcpy(m_InstancePart.m_DataTable.GetStart(), pBlob, lBlobLen);

    #ifdef _DEBUG
            // During DEBUG HeapValidate our BLOB
            CWin32DefaultArena::ValidateHeap( 0, GetStart() );
    #endif

            // Reset the pointers then restore our actual allocated length
            m_InstancePart.SetData( m_InstancePart.GetStart(), this, m_ClassPart );
            m_InstancePart.m_Heap.SetAllocatedDataLength( *pUsedDataLen );
            m_InstancePart.m_Heap.SetUsedLength( *pUsedDataLen );
        }

        return hr;
    }
    catch(...)
    {
        // Something went South
        return WBEM_E_CRITICAL_ERROR;
    }
}

HRESULT CWbemInstance::CopyTransferBlob(long lBlobType, long lBlobLen,
                                        BYTE* pBlob)
{
    // Lock this BLOB during this operation
    CLock lock(this);

    if(lBlobType == WBEM_BLOB_TYPE_ERROR)
        return (HRESULT)lBlobLen;

    return CopyActualTransferBlob( lBlobLen, pBlob );
}


HRESULT CWbemInstance::CopyTransferArrayBlob(CWbemInstance* pInstTemplate, long lBlobType, long lBlobLen,
                                            BYTE* pBlob, CFlexArray& apObj, long* plNumArrayObj )
{
    if(lBlobType == WBEM_BLOB_TYPE_ERROR)
        return (HRESULT)lBlobLen;

    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pBlob )
    {
        UNALIGNED long*   plVersion = (UNALIGNED long*) pBlob;
        UNALIGNED long*   plNumObjects = (UNALIGNED long*) ( pBlob + sizeof(long) );
        BYTE*   pNextObj = pBlob + (2*sizeof(long));
        DWORD   dwCtr = 0;

        // Check for version mismatches
        if ( *plVersion == TXFRBLOBARRAY_PACKET_VERSION )
        {
            // See if the array is big enough.  If not, realloc it and insert new objects

            if ( apObj.Size() < *plNumObjects )
            {
                IWbemClassObject*   pObj = NULL;

                // Clone new instance objects and stick them in the array
                for ( dwCtr = apObj.Size(); SUCCEEDED( hr ) && dwCtr < *plNumObjects; dwCtr++ )
                {
                    hr = pInstTemplate->Clone( &pObj );
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( apObj.InsertAt( dwCtr, pObj ) != CFlexArray::no_error )
                        {
                            return WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }

            }   // IF reallocing array

            if ( SUCCEEDED( hr ) )
            {
                // Store the number of returned objects
                *plNumArrayObj = *plNumObjects;

                // We have a size and a BLOB to worry about
                UNALIGNED long*   plBlobSize = (UNALIGNED long*) pNextObj;

                CWbemInstance*  pInst = NULL;

                // Now pull out the Instance BLOBs
                for ( dwCtr = 0; SUCCEEDED( hr ) && dwCtr < *plNumObjects; dwCtr++ )
                {
                    pInst = (CWbemInstance*) apObj[dwCtr];

                    // Size is at the front of the BLOB
                    plBlobSize = (UNALIGNED long*) pNextObj;

                    // Point pNextObj at the BLOB after the size
                    pNextObj += sizeof(long);


                    hr = pInst->CopyActualTransferBlob( *plBlobSize, pNextObj );

                    // This will point pNextObj at the length header for the next BLOB
                    pNextObj += *plBlobSize;

                }   // FOR enum BLOBs

            }   // IF initialized array

        }   // IF version match
        else
        {
            hr = WBEM_E_UNEXPECTED;
        }

    }   // IF NULL != pData

    return hr;
}

HRESULT CWbemInstance::DeleteProperty(int nIndex)
{
    if (IsClassPartShared())
    {
        CLock lock(this);
    
        DWORD dwLen = m_DecorationPart.GetLength() +
                      m_ClassPart.GetLength() +
                      m_InstancePart.GetLength();
                      
        BYTE * pMem = m_pBlobControl->Allocate(dwLen);
        
        if (pMem)
        {
            BYTE * pDeleteMe = GetStart();
            BYTE * pDecoration = pMem;
            BYTE * pClassPart = pMem + m_DecorationPart.GetLength();
            BYTE * pInstancePart = pClassPart + m_ClassPart.GetLength();

            memcpy(pDecoration,m_DecorationPart.GetStart(),m_DecorationPart.GetLength());
            memcpy(pClassPart,m_ClassPart.GetStart(),m_ClassPart.GetLength());
            memcpy(pInstancePart,m_InstancePart.GetStart(),m_InstancePart.GetLength());

    	    m_DecorationPart.SetData(pDecoration);
    	    m_ClassPart.SetData(pClassPart,this);
    	    m_InstancePart.SetData(pInstancePart,this,m_ClassPart);

    	   
    	    m_dwInternalStatus &= (~WBEM_OBJ_CLASS_PART_SHARED);
    	    m_dwInternalStatus |= WBEM_OBJ_CLASS_PART_INTERNAL;

    	    if(m_pMergedClassObject)
    	    {
    	        m_pMergedClassObject->Release();
    	        m_pMergedClassObject = NULL;    	        
    	    }

    	    m_pBlobControl->Delete(pDeleteMe);

            m_nTotalLength = dwLen;
    	    
            //if (FAILED(Validate()))
            //    DebugBreak();
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
            
    }
    
    CPropertyInformation* pInfo = m_ClassPart.m_Properties.GetAt(nIndex)->
        GetInformation(&m_ClassPart.m_Heap);
    m_InstancePart.DeleteProperty(pInfo);
    m_ClassPart.DeleteProperty(nIndex);

    return WBEM_S_NO_ERROR;
}

BOOL CWbemInstance::IsInstanceOf(CWbemClass* pClass)
{
    // This now reroutes if our class part is localized
    if ( m_ClassPart.IsLocalized() )
    {
        EReconciliation eTest = m_ClassPart.CompareExactMatch( pClass->m_CombinedPart.m_ClassPart, TRUE );

        if ( e_OutOfMemory == eTest )
        {
            throw CX_MemoryException();
        }

        // We must perform an exhaustive comparison, filtering out localization data
        return ( e_ExactMatch == eTest );
    }
    
    return m_ClassPart.IsIdenticalWith(pClass->m_CombinedPart.m_ClassPart);
}

void CWbemInstance::CompactClass()
{
	// Only Account for the class part if it is internal
	if ( IsClassPartInternal() )
	{
		m_ClassPart.Compact();
	}

    m_InstancePart.Compact();

	// Only Account for the class part if it is internal
	if ( IsClassPartInternal() )
	{
	    MoveBlock(m_InstancePart, EndOf(m_ClassPart));
	}
}

HRESULT CWbemInstance::ConvertToClass(CWbemClass* pClass,
                                        CWbemInstance** ppInst)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Calculate required space
    // ========================

    length_t nRequired = m_DecorationPart.GetLength() +
        pClass->m_CombinedPart.GetLength() +
        m_InstancePart.GetLength();

    LPMEMORY pNewMem = m_pBlobControl->Allocate(nRequired);

    if ( NULL != pNewMem )
    {
        // Copy the decoration and the class parts
        // =======================================

        LPMEMORY pCurrent = pNewMem;
        memcpy(pCurrent, m_DecorationPart.GetStart(), m_DecorationPart.GetLength());
        pCurrent+= m_DecorationPart.GetLength();

        memcpy(pCurrent, pClass->m_CombinedPart.m_ClassPart.GetStart(),
                            pClass->m_CombinedPart.m_ClassPart.GetLength());

        pCurrent+= pClass->m_CombinedPart.m_ClassPart.GetLength();

        // Create a converted instance part
        // ================================

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value (nRequired - (pCurrent - pNewMem))
        // We are not supporting length > 0xFFFFFFFF so cast is ok

        pCurrent = m_InstancePart.ConvertToClass(
                            pClass->m_CombinedPart.m_ClassPart,
                            nRequired - (length_t) (pCurrent - pNewMem),
                            pCurrent);

        // Create an instance from it
        // ==========================

        CWbemInstance* pInst =
            (CWbemInstance*)CWbemObject::CreateFromMemory(pNewMem, nRequired,
                                    TRUE);

        // Set the class name
        // ==================

        if ( NULL != pInst )
        {
            // Use a stack variable, since a reallocation can occur here
            heapptr_t   ptrTemp;

            // Check for allocation errors.
            if ( CCompressedString::CopyToNewHeap(
                        pClass->m_CombinedPart.m_ClassPart.m_pHeader->ptrClassName,
                        &pClass->m_CombinedPart.m_ClassPart.m_Heap,
                        &pInst->m_InstancePart.m_Heap,
                        ptrTemp ) )
            {
                // Now copy the new pointer
                pInst->m_InstancePart.m_pHeader->ptrClassName = ptrTemp;
                *ppInst = pInst;
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CWbemInstance::Reparent(CWbemClass* pClass,
                                CWbemInstance** ppInst)
{
    // First, we need to spawn a new instance
    CWbemInstance*  pNewInst = NULL;
    HRESULT hr = pClass->SpawnInstance( 0L, (IWbemClassObject**) &pNewInst );

    if ( SUCCEEDED( hr ) )
    {

        // DEVNOTE:TODO:PAUL - Comment this out if it's getting in your way
        // i.e. (not working ).  This is what should copy properties.

        // Now walk the nonsystem properties and for each one we find, try to set the
        // value in the new instance

        for(int i = 0; SUCCEEDED( hr ) && i < m_ClassPart.m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = m_ClassPart.m_Properties.GetAt(i);
            CPropertyInformation* pInfo =
                pLookup->GetInformation(&m_ClassPart.m_Heap);

            BSTR strName = m_ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                CreateBSTRCopy();
            CSysFreeMe  sfm(strName);

            // Check for allocation failures
            if ( NULL != strName )
            {
                // Get the value and type
                CVar Var;
                if (FAILED(GetProperty(pInfo, &Var)))
			return WBEM_E_OUT_OF_MEMORY;

                CPropertyInformation*   pNewInstInfo = pNewInst->m_ClassPart.FindPropertyInfo(strName);

                // If types don't match or property not found, we'll ignore the property
                if ( NULL != pNewInstInfo && pInfo->nType == pNewInstInfo->nType )
                {
                    hr = pNewInst->m_InstancePart.SetActualValue(pNewInstInfo, &Var);

                    //
                    // reget-it, since it might have been moved by SetActualValue
                    //
                    pNewInstInfo = pNewInst->m_ClassPart.FindPropertyInfo(strName);

                    if ( SUCCEEDED( hr ) && pNewInstInfo)
                    {

                        // DEVNOTE:TODO:PAUL - Comment this out if it's getting in your way
                        // i.e. (not working ).  This is what should copy local property
                        // qualifiers.

                        // Access that property's qualifier set
                        // ====================================
                        CInstancePropertyQualifierSet IPQS;
                        hr = InitializePropQualifierSet(pInfo, IPQS);

                        if ( SUCCEEDED( hr ) )
                        {
                            CInstancePropertyQualifierSet IPQSNew;
                            hr = pNewInst->InitializePropQualifierSet(pNewInstInfo, IPQSNew);

                            if ( SUCCEEDED( hr ) )
                            {
                                hr = IPQSNew.CopyLocalQualifiers( IPQS );
                            }   // IF Initialized new set

                        }   // IF Initialized THIS set

                    }

                }   // IF property found and Types match


            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }


        }   // FOR enum properties

        // DEVNOTE:TODO:PAUL - Comment this out if it's getting in your way
        // i.e. (not working ).  This is what should copy local instance
        // qualifiers.

        // Now do the instance qualifiers
        if ( SUCCEEDED( hr ) )
        {
            hr = pNewInst->m_InstancePart.m_Qualifiers.CopyLocalQualifiers( m_InstancePart.m_Qualifiers );
        }

    }   // IF Spawn Instance

    // Only save new instance if we succeeded
    if ( SUCCEEDED( hr ) )
    {
        *ppInst = pNewInst;
    }
    else
    {
        pNewInst->Release();
    }

    return hr;
}

// Functions to handle parts
STDMETHODIMP CWbemInstance::SetObjectParts( LPVOID pMem, DWORD dwMemSize, DWORD dwParts )
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;
        DWORD   dwRequiredLength = 0;

        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        if ( NULL != pMem )
        {
            // At least the decoration part must be specified
            if ( dwParts & WBEM_OBJ_DECORATION_PART )
            {

				// Create a new COM Blob control, as the supplied memory must
				// be CoTaskMemAlloced/Freed.

				CCOMBlobControl*	pNewBlobControl = &g_CCOMBlobControl;

				//if ( NULL != pNewBlobControl )
				//{
					// Use the current BLOB Control to delete the underlying BLOB,
					// then delete the BLOB control and replace it with the new one
					// and SetData.
					m_pBlobControl->Delete(GetStart());
					
					//delete m_pBlobControl;
					m_pBlobControl = pNewBlobControl;

	                SetData( (LPBYTE) pMem, dwMemSize, dwParts );

					hr = WBEM_S_NO_ERROR;
				//}
				//else
				//{
				//	hr = WBEM_E_OUT_OF_MEMORY;
				//}

            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }
        }
        else
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Copies specified parts into a user provided buffer
STDMETHODIMP CWbemInstance::GetObjectParts( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed )
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;
        DWORD   dwRequiredLength = 0;

        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        // How big is the decoration part
        if ( dwParts & WBEM_OBJ_DECORATION_PART )
        {
            if ( IsDecorationPartAvailable() )
            {
                dwRequiredLength += m_DecorationPart.GetLength();
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }
        }

        // How big is the class part
        if (    SUCCEEDED( hr )
            &&  dwParts & WBEM_OBJ_CLASS_PART )
        {
            if ( IsClassPartAvailable() )
            {
                dwRequiredLength += m_ClassPart.GetLength();
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }

        }

        // How big is the instance part
        if (    SUCCEEDED( hr )
            &&  dwParts & WBEM_OBJ_INSTANCE_PART )
        {
            if ( IsInstancePartAvailable() )
            {
                dwRequiredLength += m_InstancePart.GetLength();
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }
        }

        // At this point, we at least know we requested valid data.
        if ( SUCCEEDED( hr ) )
        {
            *pdwUsed = dwRequiredLength;

            // Make sure the supplied buffer is big enough
            if ( dwDestBufSize >= dwRequiredLength )
            {
                // Now validate the buffer pointer
                if ( NULL != pDestination )
                {
                    LPBYTE  pbData = (LPBYTE) pDestination;

                    // Now copy the requested parts

                    // Decoration
                    if ( dwParts & WBEM_OBJ_DECORATION_PART )
                    {
                        CopyMemory( pbData, m_DecorationPart.GetStart(), m_DecorationPart.GetLength() );
                        pbData += m_DecorationPart.GetLength();
                    }

                    // Class
                    if ( dwParts & WBEM_OBJ_CLASS_PART )
                    {
                        CopyMemory( pbData, m_ClassPart.GetStart(), m_ClassPart.GetLength() );
                        pbData += m_ClassPart.GetLength();
                    }

                    // Instance (and we're done)
                    if ( dwParts & WBEM_OBJ_INSTANCE_PART )
                    {
                        CopyMemory( pbData, m_InstancePart.GetStart(), m_InstancePart.GetLength() );
                    }

                }
                else
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = WBEM_E_BUFFER_TOO_SMALL;
            }

        }   // IF valid parts requested

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Copies class part into a user provided buffer
STDMETHODIMP CWbemInstance::GetClassPart( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
    // This function doesn't cause any allocations so so need to perform out of memory
    // exception handling.

    try
    {
        HRESULT hr = WBEM_E_INVALID_OPERATION;

        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        if ( IsClassPartAvailable() )
        {
            // How big does the buffer need to be
            *pdwUsed = m_ClassPart.GetLength();

            if ( dwDestBufSize >= m_ClassPart.GetLength() )
            {
                // Check the buffer now, before copying memory
                if ( NULL != pDestination )
                {
                    CopyMemory( pDestination, m_ClassPart.GetStart(), m_ClassPart.GetLength() );
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }

            }   // IF buff big enough
            else
            {
                hr = WBEM_E_BUFFER_TOO_SMALL;
            }

        }   // IF IsClassPartAvailable

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Resets the BLOB with a supplied class part
STDMETHODIMP CWbemInstance::SetClassPart( LPVOID pClassPart, DWORD dwSize )
{

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_E_INVALID_PARAMETER;

        if ( NULL != pClassPart )
        {
            // Resetting our BLOB
            CLock lock(this);

			int nInstPartLength = 0L;

			if ( IsClassPartAvailable() )
			{
				nInstPartLength = m_InstancePart.GetLength();
			}
			else
			{
				nInstPartLength = GetBlockLength() - m_DecorationPart.GetLength();
			}

            int nNewLength = m_DecorationPart.GetLength() + nInstPartLength + dwSize;
            LPMEMORY    pCurrentData, pNewData, pOldData;

            // This is the only point at which we should see an OOM exception, so don't worry
            // about freeing it.

            pNewData = m_pBlobControl->Allocate( ALIGN_FASTOBJ_BLOB(nNewLength) );

            if ( NULL != pNewData )
            {
                pCurrentData = pNewData;

                // Copy the old decoration data

                CopyMemory( pCurrentData, m_DecorationPart.GetStart(), m_DecorationPart.GetLength() );
                pCurrentData += m_DecorationPart.GetLength();

                // Copy in the new class part
                CopyMemory( pCurrentData, pClassPart, dwSize );
                pCurrentData += dwSize;

                // Finish with the Instance Part
				if ( IsClassPartAvailable() )
				{
					CopyMemory( pCurrentData, m_InstancePart.GetStart(), m_InstancePart.GetLength() );
				}
				else
				{
					CopyMemory( pCurrentData, EndOf( m_DecorationPart ), nInstPartLength );
				}
                
                // Save the old data pointer
                pOldData = GetStart();

                // Reset the values.
                SetData( pNewData, nNewLength );

                // Finally dump the old data.
                m_pBlobControl->Delete( pOldData );

                m_nTotalLength = nNewLength;

                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF NULL != pClassPart

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

// Removes the class part from our BLOB, shrinking it
STDMETHODIMP CWbemInstance::StripClassPart( void )
{
    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_E_INVALID_OPERATION;

        if ( IsClassPartInternal() )
        {
            // Resetting our BLOB
            CLock lock(this);

            int nNewLength = m_DecorationPart.GetLength() + m_InstancePart.GetLength();
            LPMEMORY    pNewData, pOldData;

            // No need to clean this up if an exception is thrown
            pNewData = m_pBlobControl->Allocate( ALIGN_FASTOBJ_BLOB(nNewLength) );

            if ( NULL != pNewData )
            {
                pOldData = GetStart();

                // Copy the old decoration data.  This will rebase the pointers
                CopyBlock( m_DecorationPart, pNewData );
                
                // Now copy the InstancePart
                CopyBlock( m_InstancePart, EndOf(m_DecorationPart) );

                // Reset our internal status
                m_dwInternalStatus &= ~( WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_INTERNAL );
                
                // Finally dump the old data.
                m_pBlobControl->Delete( pOldData );

                m_nTotalLength = nNewLength;

                hr = WBEM_S_NO_ERROR;

            }   // IF NULL != pNewData
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // Class Part must be internal

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

// Merges us with the class part in another IWbemClassObject
STDMETHODIMP CWbemInstance::MergeClassPart( IWbemClassObject *pClassPart )
{
    // This function calls StripClassPart() which CAN cause an OOM exception, but that
    // function performs appropriate handling underneath the layers.

    HRESULT                 hr = WBEM_E_INVALID_PARAMETER;
    _IWmiObject*			pClsInternals;

    if ( NULL != pClassPart )
    {
        // Get an object internals interface.  If we can, this is a good
        // indication that the object that was passed to us is one of our
        // own, and we can do some sleazy casting.

        hr = pClassPart->QueryInterface( IID__IWmiObject, (void**) &pClsInternals );

        if ( SUCCEEDED(hr) )
        {
            // This should work.
            CWbemObject*    pWbemObject = NULL;
			
			// Gets the actual underlying WBEMObject
			hr = pClsInternals->_GetCoreInfo( 0L, (void**) &pWbemObject );
			CReleaseMe	rm( (IWbemClassObject*) pWbemObject );

			if ( SUCCEEDED( hr ) )
			{
				// If the object is an Instance, it's probably a CWbemInstance
				if ( pWbemObject->IsObjectInstance() == WBEM_S_NO_ERROR )
				{
					CWbemInstance*  pWbemInstance = (CWbemInstance*) pWbemObject;

					CLock   lock(this);

					// This only makes sense if the class part is internal to the supplied object.
					// We do need to strip our class part from our BLOB, however.
					if ( pWbemInstance->IsClassPartInternal() )
					{
						if ( IsClassPartInternal() )
						{
							hr = StripClassPart();
						}
						else
						{
							hr = WBEM_S_NO_ERROR;
						}

						if (SUCCEEDED(hr))
						{
							// Now reset our class part to point to the data in the other class part
							m_ClassPart.SetData( pWbemInstance->m_ClassPart.GetStart(), pWbemInstance );

							// Instance Part should be reset here if we have one, in case it wasn't properly
							// initialized before.  This could happen, for example, if the object data BLOB
							// was preset without class information in it.

							if ( m_dwInternalStatus & WBEM_OBJ_INSTANCE_PART )
							{
								m_InstancePart.SetData( EndOf( m_DecorationPart ), this, m_ClassPart );
							}

							// Clean up a preexisting object we may have merged with
							if ( NULL != m_pMergedClassObject )
							{
								m_pMergedClassObject->Release();
							}

							// maintain a pointer to the object whose memory we are referencing
							m_pMergedClassObject = pClassPart;
							m_pMergedClassObject->AddRef();

							// set our internal state data.
							m_dwInternalStatus |= WBEM_OBJ_CLASS_PART | WBEM_OBJ_CLASS_PART_SHARED;
						}

					}   // IF other class part is internal
					else
					{
						hr = WBEM_E_INVALID_OPERATION;
					}

				}   // IF IsInstance

			}	// IF Got Object

			pClsInternals->Release();

        }   // IF Got Internals Interface

    }   // IF NULL != pClassPart

    return hr;

}

// CWbemObject override.  Handles case where our class part is shared.
HRESULT CWbemInstance::WriteToStream( IStream* pStrm )
{
    // Protect the BLOB during this operation
    CLock   lock( this, WBEM_FLAG_ALLOW_READ );

    // If our class part that is shared, we need to fake a contiguous
    // block of memory for the Unmarshaler.

    if ( IsClassPartShared() )
    {
        DWORD dwSignature = FAST_WBEM_OBJECT_SIGNATURE;

        // Write the signature
        // ===================

        HRESULT hres = pStrm->Write((void*)&dwSignature, sizeof(DWORD), NULL);
        if(FAILED(hres)) return hres;

        DWORD   dwLength = 0;

        // This will get us the full lengths of these parts
        GetObjectParts( NULL, 0, WBEM_INSTANCE_ALL_PARTS, &dwLength );

        hres = pStrm->Write((void*)&dwLength, sizeof(DWORD), NULL);
        if(FAILED(hres)) return hres;

        // Write each part individually
        // ============================

        // Decoration
        hres = pStrm->Write((void*)m_DecorationPart.GetStart(),
                              m_DecorationPart.GetLength(), NULL);
        if(FAILED(hres)) return hres;

        // Class
        hres = pStrm->Write((void*)m_ClassPart.GetStart(),
                              m_ClassPart.GetLength(), NULL);
        if(FAILED(hres)) return hres;

        // Instance
        hres = pStrm->Write((void*)m_InstancePart.GetStart(),
                              m_InstancePart.GetLength(), NULL);
        if(FAILED(hres)) return hres;
    }
    else
    {
        // Otherwise, call default implementation
        return CWbemObject::WriteToStream( pStrm );
    }

    return S_OK;

}

// CWbemObject override.  Handles case where our class part is shared.
HRESULT CWbemInstance::GetMaxMarshalStreamSize( ULONG* pulSize )
{
    // If our class part that is shared, we need to fake a contiguous
    // block of memory for the Unmarshaler.

    if ( IsClassPartShared() )
    {
        DWORD   dwLength = 0;

        // This will get us the full lengths of these parts
        HRESULT hr = GetObjectParts( NULL, 0, WBEM_INSTANCE_ALL_PARTS, &dwLength );

        // an expected error
        if ( WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            hr = S_OK;
            // Account for the additional DWORDs
            *pulSize = dwLength + sizeof(DWORD) * 2;
        }

        return hr;
    }
    else
    {
        // Otherwise, call default implementation
        return CWbemObject::GetMaxMarshalStreamSize( pulSize );
    }
    return S_OK;
}

HRESULT CWbemInstance::GetDynasty( CVar* pVar )
{
    // We don't do this for Limited Representations
    if ( m_DecorationPart.IsLimited() )
    {
        pVar->SetAsNull();
        return WBEM_NO_ERROR;
    }

    return m_ClassPart.GetDynasty(pVar);
}

HRESULT CWbemInstance::ConvertToMergedInstance( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Check that the class part is not already shared (in which case
    // we're done).

    if ( IsClassPartInternal() )
    {
        // Now, we need to actually separate out the class part from the
        // instance and place it in its own object so the outside world
        // cannot touch the object.

        DWORD   dwClassObjectLength = 0;

        // Get length should fail with a buffer too small error
        hr = GetObjectParts( NULL, 0,
                WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART, &dwClassObjectLength );

        if ( WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            DWORD   dwTempLength;
            LPBYTE  pbData = CBasicBlobControl::sAllocate(dwClassObjectLength);

            if ( NULL != pbData )
            {

                hr = GetObjectParts( pbData, dwClassObjectLength,
                        WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART, &dwTempLength );

                if ( SUCCEEDED( hr ) )
                {
                    // Allocate an object to hold the class data and then
                    // stuff in the binary data.

                    CWbemInstance*  pClassData = NULL;

                    try
                    {
                        // This can throw an exception
                        pClassData = new CWbemInstance;
                    }
                    catch(...)
                    {
                        pClassData = NULL;
                    }

                    if ( NULL != pClassData )
                    {
                        pClassData->SetData( pbData, dwClassObjectLength,
                            WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART |
                            WBEM_OBJ_CLASS_PART_INTERNAL );

                        if ( SUCCEEDED( hr ) )
                        {
                            // Merge the full instance with this object
                            // and we're done

                            hr = MergeClassPart( pClassData );

                        }

                        // There will be one additional addref on the class data,
                        // object, so release it here.  If the object wasn't
                        // successfuly merged, this will free it.
                        pClassData->Release();

                    }   // IF pClassData
                    else
                    {
                        // Cleanup underlying memory
                        CBasicBlobControl::sDelete(pbData);
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }


                }   // IF GetObjectParts
                else
                {
                    // Cleanup underlying memory
                    CBasicBlobControl::sDelete(pbData);
                }

            }   // IF pbData
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }


        }   // IF GetObjectParts

    }   // IF IsClassPartInternal

    return hr;
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
BOOL CWbemInstance::IsLocalized( void )
{
    return ( m_ClassPart.IsLocalized() ||
            m_InstancePart.IsLocalized() );
}

//******************************************************************************
//
//  See fastinst.h for documentation.
//
//******************************************************************************
void CWbemInstance::SetLocalized( BOOL fLocalized )
{
    m_InstancePart.SetLocalized( fLocalized );
}

// Merges us with the class part in another IWbemClassObject
STDMETHODIMP CWbemInstance::ClearWriteOnlyProperties( void )
{

    return WBEM_S_NO_ERROR;

}

//******************************************************************************
//
//  See fastinst.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::FastClone( CWbemInstance* pInstDest )
{
    // Protect the BLOB during this operation
    CLock   lock( this, WBEM_FLAG_ALLOW_READ );

    LPMEMORY pNewData = NULL;

    BYTE* pMem = NULL;
    CompactAll();

    if ( NULL != pInstDest->GetStart() )
    {
        if(pInstDest->GetLength() < GetLength())
        {
            pMem = pInstDest->Reallocate( GetLength() );
        }
        else
        {
            pMem = pInstDest->GetStart();
        }

    }
    else
    {
        pMem = CBasicBlobControl::sAllocate(GetLength());
    }

    // bad
    if(pMem == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    memcpy(pMem, GetStart(), GetLength());

    if ( !IsClassPartShared() )
    {
        pInstDest->SetData(pMem, GetLength());
    }
    else
    {
        // Setup the New Instance.  Decoration and Instance both come from the
        // data block.  We can just merge the new Instance's class part with the
        // same `object we are merged with.

        pInstDest->m_DecorationPart.SetData( pMem );

        // Because pNewInstance will merge with the same class part as us, pass
        // our class part member as the class part for parameter for SetData (it
        // just uses it for informational purposes ).

        // The m_InstancePart.m_Qualifier.m_pSecondarySet pointer will be incorrect after
        // this call ( it will point to the cloning source's secondary set ).  By setting
        // the internal status properly, in the next line, MergeClassPart() will fix
        // everything up properly.
        pInstDest->m_InstancePart.SetData( EndOf( pInstDest->m_DecorationPart ), pInstDest, m_ClassPart );

        // This will "fake out" the status so it fixes up the class part correctly
        pInstDest->m_dwInternalStatus = WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART;

        HRESULT hr = pInstDest->MergeClassPart( m_pMergedClassObject );
        if (FAILED(hr))
        {
            return hr;
        }

        // Copy the status and length variables.
        pInstDest->m_dwInternalStatus = m_dwInternalStatus;
        pInstDest->m_nTotalLength = m_nTotalLength;
    }

    pInstDest->CompactAll();

    return WBEM_S_NO_ERROR; 

}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::CloneEx( long lFlags, _IWmiObject* pDestObject )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Verify it's an instance and Thread Safety
		return FastClone( (CWbemInstance*) pDestObject );
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
HRESULT CWbemInstance::CopyInstanceData( long lFlags, _IWmiObject* pSourceInstance )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		return CopyBlobOf( (CWbemInstance*) pSourceInstance );
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Checks if the current object is a child of the specified class (i.e. is Instance of,
// or is Child of )
STDMETHODIMP CWbemInstance::IsParentClass( long lFlags, _IWmiObject* pClass )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		CLock	lock(this);

		return ( IsInstanceOf( (CWbemClass*) pClass ) ? WBEM_S_NO_ERROR : WBEM_S_FALSE );
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Compares the derived most class information of two class objects.
STDMETHODIMP CWbemInstance::CompareDerivedMostClass( long lFlags, _IWmiObject* pClass )
{
	return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Creates a limited representation class for projection queries
STDMETHODIMP CWbemInstance::GetClassSubset( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass )
{
	return WBEM_E_INVALID_OPERATION;
}

//******************************************************************************
//
//  See wbemint.h for documentation
//
//******************************************************************************
// Creates a limited representation instance for projection queries
// "this" _IWmiObject must be a limited class
STDMETHODIMP CWbemInstance::MakeSubsetInst( _IWmiObject *pInstance, _IWmiObject** pNewInstance )
{
	return WBEM_E_INVALID_OPERATION;
}

// Merges a blob with the current object memory and creates a new object
STDMETHODIMP CWbemInstance::Merge( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj )
{
	return WBEM_E_INVALID_OPERATION;
}

// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
// is specified this will only perform a test
STDMETHODIMP CWbemInstance::ReconcileWith( long lFlags, _IWmiObject* pNewObj )
{
	return WBEM_E_INVALID_OPERATION;
}

// Upgrades class and instance objects
STDMETHODIMP CWbemInstance::Upgrade( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		HRESULT	hr = WBEM_S_NO_ERROR;

		// If the new parent class is NULL, then we need to create a new empty class we will
		// upgrade from (basically we will create a new base class to which the values
		// of the current class will be applied

		if ( NULL != pNewParentClass )
		{
			CWbemClass*	pParentClassObj = NULL;

			hr = WbemObjectFromCOMPtr( pNewParentClass, (CWbemObject**) &pParentClassObj );
			CReleaseMe	rm( (_IWmiObject*) pParentClassObj );

			hr = Reparent( pParentClassObj, (CWbemInstance**) ppNewChild );
		}
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Updates derived class object using the safe/force mode logic
STDMETHODIMP CWbemInstance::Update( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass )
{
	return WBEM_E_INVALID_OPERATION;
}

STDMETHODIMP CWbemInstance::SpawnKeyedInstance( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst )
{
	return WBEM_E_INVALID_OPERATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastobj.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTOBJ.CPP

Abstract:

  This file implements the classes related to generic object representation
  in WbemObjects. Its derived classes for instances (CWbemInstance) and
  classes (CWbemClass) are described in fastcls.h and fastinst.h.

  For complete documentation, see fastobj.h

  Classes implemented:
      CDecorationPart     Information about the origins of the object.
      CWbemObject          Any object --- class or instance.

History:

  3/10/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"

//#include "dbgalloc.h"
#include "wbemutil.h"
#include "fastall.h"
#include <wbemutil.h>

#include <wbemstr.h>
#include "olewrap.h"
#include <arrtempl.h>
#include "wmiarray.h"
#include "genutils.h"
#include "md5wbem.h"
#include "reg.h"

// Define this to enable debugging of object refcounting
//#define DEBUGOBJREFCOUNT

// Default to enabled in DEBUG, disbaled in RELEASE
#ifdef _DEBUG
bool g_bObjectValidation = true;
#else
bool g_bObjectValidation = false;
#endif

CGetHeap CBasicBlobControl::m_Heap;

CCOMBlobControl g_CCOMBlobControl;
CBasicBlobControl g_CBasicBlobControl;

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002

CGetHeap::CGetHeap():m_bNewHeap(FALSE)
    {
        DWORD dwUsePrivateHeapForBlobs = 0;
        HKEY hKey;
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 __TEXT("Software\\Microsoft\\WBEM\\CIMOM"),
                                 NULL,
                                 KEY_READ,
                                 &hKey);

        if (ERROR_SUCCESS == lRet)
        {
            DWORD dwType;
            DWORD dwSize = sizeof(DWORD);
            lRet = RegQueryValueEx(hKey,
                                   __TEXT("EnablePrivateObjectHeap"),
                                   NULL,
                                   &dwType,
                                   (BYTE *)&dwUsePrivateHeapForBlobs,
                                   &dwSize);
            RegCloseKey(hKey);
        }
        
        if (dwUsePrivateHeapForBlobs)
        {
#ifdef INSTRUMENTED_BUILD
#ifdef _X86_        
            //
            // trick here
            //
            ULONG_PTR * RtlpDebugPageHeap = (ULONG_PTR *)0x77fc4498;
            ULONG_PTR * RtlpDhpGlobalFlags = (ULONG_PTR *)0x77fc0a94;
            ULONG_PTR SaveDebug = *RtlpDebugPageHeap;
            ULONG_PTR SaveFlags = *RtlpDhpGlobalFlags;
            *RtlpDebugPageHeap = 1;
            *RtlpDhpGlobalFlags = PAGE_HEAP_ENABLE_PAGE_HEAP  | PAGE_HEAP_COLLECT_STACK_TRACES;
            //
#endif /*_X86_*/
#endif
            m_hHeap = HeapCreate(0,0,0);
#ifdef INSTRUMENTED_BUILD
#ifdef _X86_        
            //
            //
           *RtlpDebugPageHeap = SaveDebug;
           *RtlpDhpGlobalFlags  = SaveFlags;
            //
#endif /*_X86_*/
#endif
            if (m_hHeap)
                m_bNewHeap = TRUE;
        }
        else
        {
            m_hHeap = CWin32DefaultArena::GetArenaHeap();
        }
        if (NULL == m_hHeap)
            m_hHeap = GetProcessHeap();
    };

CGetHeap::~CGetHeap()
    {
        if (m_bNewHeap)
        {
            HeapDestroy(m_hHeap);
        }
    };


#if (defined FASTOBJ_ASSERT_ENABLE)
HRESULT _RetFastObjAssert(TCHAR *msg, HRESULT hres, const char *filename, int line)
{
    TCHAR *buf = new TCHAR[512];
	if (buf == NULL)
	{
		return hres;
	}
    wsprintf(buf, __TEXT("%s\nhres = 0x%X\nFile: %S, Line: %lu\n\nPress Cancel to stop in debugger, OK to continue"), msg, hres, filename, line);
    int mbRet = MessageBox(0, buf, __TEXT("WMI Assert"),  MB_OKCANCEL | MB_ICONSTOP | MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION);
	delete [] buf;
	if (mbRet == IDCANCEL)
	{
		DebugBreak();
	}
	return hres;
}
#endif

#ifdef OBJECT_TRACKING
#pragma message("*** Object Tracking Enabled ***")

#include <oahelp.inl>

static int _Trace(char *pFile, const char *fmt, ...)
{
    char *buffer = new char[2048];
    if (buffer == 0)
        return 1;
    va_list argptr;
    int cnt;
    va_start(argptr, fmt);
    cnt = _vsnprintf(buffer, 2047, fmt, argptr);
    va_end(argptr);

    FILE *f = fopen(pFile, "at");
    fprintf(f, "%s", buffer);
    fclose(f);

    delete [] buffer;
    return cnt;
}

CFlexArray g_TrackingList;
CRITICAL_SECTION g_TrackingCS;
BOOL g_Tracking_bFirstTime = TRUE;

void ObjTracking_Add(CWbemObject *p)
{
    if (g_Tracking_bFirstTime)
    {
        InitializeCriticalSection(&g_TrackingCS);
        g_Tracking_bFirstTime = FALSE;
    }

    EnterCriticalSection(&g_TrackingCS);
    g_TrackingList.Add(p);
    LeaveCriticalSection(&g_TrackingCS);
}


void ObjTracking_Remove(CWbemObject *p)
{
    BOOL bFound = FALSE;
    EnterCriticalSection(&g_TrackingCS);

    for (int i =0; i < g_TrackingList.Size(); i++)
    {
        if (g_TrackingList[i] == p)
        {
            g_TrackingList.RemoveAt(i);
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        DebugBreak();   // Destructed object without construct
    }
    LeaveCriticalSection(&g_TrackingCS);
}


void ObjectTracking_Dump()
{
    if (g_Tracking_bFirstTime)
    {
        InitializeCriticalSection(&g_TrackingCS);
        g_Tracking_bFirstTime = FALSE;
    }

    EnterCriticalSection(&g_TrackingCS);

    _Trace("c:\\temp\\object.log", "---BEGIN OUTSTANDING OBJECT LIST---\n");

    for (int i =0; i < g_TrackingList.Size(); i++)
    {
        IWbemClassObject *pObj =  (IWbemClassObject *) g_TrackingList[i];
        CVARIANT v;
        HRESULT hRes = pObj->Get(L"__RELPATH", 0, &v, 0, 0);
        pObj->AddRef();
        ULONG uRefCount = pObj->Release();
        if (SUCCEEDED(hRes))
        {
            _Trace("c:\\temp\\object.log", "  [0x%X refcount=%u] <%S>\n", pObj, uRefCount, V_BSTR(&v));
        }

    }
    LeaveCriticalSection(&g_TrackingCS);

    _Trace("c:\\temp\\object.log", "Total Objects = %d\n", g_TrackingList.Size());
    _Trace("c:\\temp\\object.log", "---END OUTSTANDING OBJECT LIST---\n");
}



#endif



//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
//  static
BOOL CDecorationPart::MapLimitation(READ_ONLY CWStringArray* pwsNames,
                                    IN OUT CLimitationMapping* pMap)
{
    // Determine which of __SERVER and __NAMESPACE properties are needed
    // =================================================================

    if(pwsNames == NULL || pwsNames->FindStr(L"__PATH", CWStringArray::no_case)
                            != CWStringArray::not_found)
    {
        pMap->SetIncludeServer(TRUE);
        pMap->SetIncludeNamespace(TRUE);
    }
    else
    {
        pMap->SetIncludeServer(
                    pwsNames->FindStr(L"__SERVER", CWStringArray::no_case)
                            != CWStringArray::not_found);

        pMap->SetIncludeNamespace(
                    pwsNames->FindStr(L"__NAMESPACE", CWStringArray::no_case)
                            != CWStringArray::not_found);
    }

    return TRUE;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
LPMEMORY CDecorationPart::CreateLimitedRepresentation(
                                        READ_ONLY CLimitationMapping* pMap,
                                        OUT LPMEMORY pWhere)
{
    LPMEMORY pCurrent = pWhere;

    // Check if any decoration data is required
    // ========================================

    if(!pMap->ShouldIncludeServer() && !pMap->ShouldIncludeNamespace())
    {
        // We want to preserve the genus of the object
        *pCurrent = (*m_pfFlags & OBJECT_FLAG_MASK_GENUS) | OBJECT_FLAG_LIMITED | OBJECT_FLAG_UNDECORATED;
        return pCurrent + 1;
    }

    // Write the flags
    // ===============

    *pCurrent = *m_pfFlags | OBJECT_FLAG_LIMITED;
    pCurrent++;

    if((*m_pfFlags & OBJECT_FLAG_MASK_DECORATION) == OBJECT_FLAG_UNDECORATED)
    {
        // No further data
        // ===============

        return pCurrent;
    }

    // Write the server name if required
    // =================================

    int nLength = m_pcsServer->GetLength();
    memcpy((void*)pCurrent, (void*)m_pcsServer, nLength);
    pCurrent += nLength;

    // Write the namespace name if required
    // ====================================

    nLength = m_pcsNamespace->GetLength();
    memcpy((void*)pCurrent, (void*)m_pcsNamespace, nLength);
    pCurrent += nLength;

    return pCurrent;
}



//*****************************************************************************
//*****************************************************************************
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************

CWbemObject::CWbemObject(CDataTable& refDataTable, CFastHeap& refDataHeap,
                            CDerivationList& refDerivationList)
    : m_nRef(1), m_nCurrentProp(INVALID_PROPERTY_INDEX),
      m_bOwnMemory(TRUE), m_pBlobControl(& g_CBasicBlobControl),
      m_refDataTable(refDataTable), m_refDataHeap(refDataHeap),
      m_refDerivationList(refDerivationList),
      m_dwInternalStatus( 0 ),
      m_pMergedClassObject( NULL )
{
    //if ( NULL == m_pBlobControl )
    //{
    //    throw CX_MemoryException();
    //}

    m_Lock.SetData(&m_LockData);
    ObjectCreated(OBJECT_TYPE_CLSOBJ,(_IWmiObject *)this);

#ifdef OBJECT_TRACKING
    ObjTracking_Add((CWbemObject *) this);
#endif

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
CWbemObject::~CWbemObject()
{
    m_pBlobControl->Delete(GetStart());
    //delete m_pBlobControl;

    // We're done with this pointer
    if ( NULL != m_pMergedClassObject )
    {
        m_pMergedClassObject->Release();
    }

    ObjectDestroyed(OBJECT_TYPE_CLSOBJ,(_IWmiObject *)this);
#ifdef OBJECT_TRACKING
    ObjTracking_Remove(this);
#endif
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	if ( riid ==  IID_IUnknown)
	{
		*ppvObj = (void*) (IUnknown*) (IWbemClassObject*) this;
	}
    else if(riid == IID_IWbemClassObject)
    {
        *ppvObj = (void*)(IWbemClassObject*)this;
    }
    else if(riid == IID_IMarshal)
        *ppvObj = (void*)(IMarshal*)this;
    else if(riid == IID_IWbemPropertySource)
        *ppvObj = (void*)(IWbemPropertySource*)this;
    else if(riid == IID_IErrorInfo)
        *ppvObj = (void*)(IErrorInfo*)this;
    else if(riid == IID_IWbemObjectAccess)
        *ppvObj = (void*)(IWbemObjectAccess*)this;
    else if(riid == IID_IWbemConstructClassObject)
        *ppvObj = (void*)(IWbemConstructClassObject*)this;
    else if (riid == IID__IWmiObjectAccessEx)
        *ppvObj = (void*) (_IWmiObjectAccessEx*)this;
    else if (riid == IID__IWmiObject)
        *ppvObj = (void*) (_IWmiObject*)this;
    else if (riid == IID_IWbemClassObjectEx)
        *ppvObj = (void*) (IWbemClassObjectEx*)this;
    else return E_NOINTERFACE;

    ((IUnknown*)*ppvObj)->AddRef();
    return S_OK;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
ULONG CWbemObject::AddRef()
{
    return InterlockedIncrement((long*)&m_nRef);
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
ULONG CWbemObject::Release()
{
    long lRef = InterlockedDecrement((long*)&m_nRef);
    _ASSERT(lRef >= 0, __TEXT("Reference count on IWbemClassObject went below 0!"))

#ifdef DEBUGOBJREFCOUNT

#pragma message("** Compiling Debug Object Ref Counting **")

    if ( lRef < 0 )
    {
        MessageBox( NULL, "BOOM!!!!!  CWbemObject RefCount went below 0!!!!  Please ensure a debugger is attached and contact a DEV IMMEDIATELY!!!\n\nPlease do this now --- we really mean it!!",
                    "WINMGMT CRITICAL ERROR!!!", MB_OK | MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION );
    }
#endif

    if(lRef == 0)
        delete this;
    return lRef;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
CWbemObject* CWbemObject::CreateFromStream(CMemStream* pStrm)
{
    // Read in and verify the signature
    // ================================

    DWORD dwSignature;
    if(pStrm->ReadDWORD(&dwSignature) != CMemStream::no_error)
    {
        return NULL;
    }
    if(dwSignature != FAST_WBEM_OBJECT_SIGNATURE)
    {
        return NULL;
    }

    // Read in the length of the object
    // ================================

    DWORD dwTotalLength;
    if(pStrm->ReadDWORD(&dwTotalLength) != CMemStream::no_error)
    {
        return NULL;
    }

    // Read in the rest of the block
    // =============================

    // Check for an allocation failure
    BYTE* abyMemory = CBasicBlobControl::sAllocate(dwTotalLength);
    if ( NULL == abyMemory )
    {
        return NULL;
    }

    if(pStrm->ReadBytes(abyMemory, dwTotalLength) != CMemStream::no_error)
    {
        CBasicBlobControl::sDelete(abyMemory);
        return NULL;
    }

    return CreateFromMemory(abyMemory, dwTotalLength, TRUE);
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
CWbemObject* CWbemObject::CreateFromStream(IStream* pStrm)
{
    // Read in and verify the signature
    // ================================

    DWORD dwSignature;
    if(pStrm->Read((void*)&dwSignature, sizeof(DWORD), NULL) != S_OK)
    {
        return NULL;
    }
    if(dwSignature != FAST_WBEM_OBJECT_SIGNATURE)
    {
        return NULL;
    }

    // Read in the length of the object
    // ================================

    DWORD dwTotalLength;
    if(pStrm->Read((void*)&dwTotalLength, sizeof(DWORD), NULL) != S_OK)
    {
        return NULL;
    }

    // Read in the rest of the block
    // =============================

    // Check for allocation failures
    BYTE* abyMemory = CBasicBlobControl::sAllocate(dwTotalLength);
    if ( NULL == abyMemory )
    {
        return NULL;
    }

    if(pStrm->Read((void*)abyMemory, dwTotalLength, NULL) != S_OK)
    {
        CBasicBlobControl::sDelete(abyMemory);
        return NULL;
    }

    return CreateFromMemory(abyMemory, dwTotalLength, TRUE);
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************

CWbemObject* CWbemObject::CreateFromMemory(LPMEMORY pMemory,
                                         int nLength, BOOL bAcquire)
{
    if((*pMemory & OBJECT_FLAG_MASK_GENUS) == OBJECT_FLAG_CLASS)
    {
        // Check for allocation failure

        CWbemClass* pClass = NULL;

        try
        {
            // This can throw an exception
            pClass = new CWbemClass;
        }
        catch(...)
        {
            pClass = NULL;
        }

        if ( NULL == pClass )
        {
            return NULL;
        }

        pClass->SetData(pMemory, nLength);
        pClass->m_bOwnMemory = bAcquire;

		// Check that the object is valid
		if ( FAILED( pClass->ValidateObject( 0L ) ) )
		{
			pClass->Release();
			pClass = NULL;
		}

        return pClass;
    }
    else
    {
        // Check for allocation failure
        CWbemInstance* pInstance = NULL;
        
        try
        {
            // This can throw an exception
            pInstance = new CWbemInstance;
        }
        catch(...)
        {
            pInstance = NULL;
        }

        if ( NULL == pInstance )
        {
            return NULL;
        }

        pInstance->SetData(pMemory, nLength);
        pInstance->m_bOwnMemory = bAcquire;

		// Check that the object is valid
		if ( FAILED( pInstance->ValidateObject( 0L ) ) )
		{
			pInstance->Release();
			pInstance = NULL;
		}

        return pInstance;
    }
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
int CWbemObject::WriteToStream(CMemStream* pStrm)
{
    int nRes;

    CompactAll();

    // Write the signature
    // ===================

    nRes = pStrm->WriteDWORD(FAST_WBEM_OBJECT_SIGNATURE);
    if(nRes != CMemStream::no_error) return nRes;

    // Write length
    // ============

    nRes = pStrm->WriteDWORD(GetBlockLength());
    if(nRes != CMemStream::no_error) return nRes;

    // Write block
    // ===========

    nRes = pStrm->WriteBytes(m_DecorationPart.GetStart(),
        GetBlockLength());
    return nRes;
}

HRESULT CWbemObject::WriteToStream( IStream* pStrm )
{

    // Protect the BLOB during this operation
    CLock   lock( this, WBEM_FLAG_ALLOW_READ );

    DWORD dwSignature = FAST_WBEM_OBJECT_SIGNATURE;

    // Write the signature
    // ===================

    HRESULT hres = pStrm->Write((void*)&dwSignature, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;

    // Write length
    // ============

    DWORD dwLength = GetBlockLength();
    hres = pStrm->Write((void*)&dwLength, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;

    // Write block
    // ===========

    hres = pStrm->Write((void*)m_DecorationPart.GetStart(),
                          GetBlockLength(), NULL);
    if(FAILED(hres)) return hres;

    return S_OK;

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
INTERNAL CCompressedString* CWbemObject::GetClassInternal()
{
    return GetClassPart()->GetClassName();
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
DELETE_ME LPWSTR CWbemObject::GetValueText(long lFlags, READ_ONLY CVar& vValue,
                                            Type_t nType)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    WString wsText;
	if ( CType::GetBasic(nType) == CIM_IUNKNOWN )
	{
		wsText += L"<interface>";
	}
    else if(vValue.GetType() == VT_EMBEDDED_OBJECT)
    {
        // Embedded object
        // ===============

        IWbemClassObject* pEmbedded =
            (IWbemClassObject*)vValue.GetEmbeddedObject();
        // Ensures cleanup during exception handling
        CReleaseMe  rm( pEmbedded );

        BSTR str = NULL;

        hr = pEmbedded->GetObjectText(lFlags | WBEM_FLAG_NO_SEPARATOR, &str);

        // Ensures cleanup during exception handling
        CSysFreeMe  sfm( str );

        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        if(str == NULL)
            return NULL;

        wsText += str;

    }
    else if(vValue.GetType() == VT_EX_CVARVECTOR &&
            vValue.GetVarVector()->GetType() == VT_EMBEDDED_OBJECT)
    {
        // Array of embedded objects
        // =========================

        CVarVector* pvv = vValue.GetVarVector();
        wsText += L"{";
        for(int i = 0; i < pvv->Size(); i++)
        {
            if(i != 0)
                wsText += L", ";

			// Get the value
			CVar	vTemp;
			pvv->FillCVarAt( i, vTemp );

            IWbemClassObject* pEmbedded = (IWbemClassObject*)vTemp.GetEmbeddedObject();

            // Ensures cleanup during exception handling
            CReleaseMe  rm( pEmbedded );

            // Free up the BSTR when we go out of scope
            BSTR str = NULL;

            hr = pEmbedded->GetObjectText(lFlags | WBEM_FLAG_NO_SEPARATOR, &str);
            CSysFreeMe  sfm( str );

            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                throw CX_MemoryException();
            }

            if(str == NULL)
                return NULL;

            wsText += str;
            
        }
        wsText += L"}";
    }
    else
    {
        // Normal value --- CVar can handle
        // ================================

        // Free up the BSTR when we go out of scope
        BSTR str = vValue.GetText(lFlags, CType::GetActualType(nType));
        CSysFreeMe  sfm( str );

        if(str == NULL)
            return NULL;

        // We need to free up the BSTR, then keep the exception going

        wsText += str;

    }

    return wsText.UnbindPtr();

}



//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::Get(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                             CIMTYPE* pctType, long* plFlavor)
{
    try
    {

        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        HRESULT hres;

		// If the value starts with an underscore see if it's a System Property
		// DisplayName, and if so, switch to a property name - otherwise, this
		// will just return the string we passed in
		
		//wszName = CSystemProperties::GetExtPropName( wszName );

        if(pVal != NULL)
        {
            CVar Var;
            hres = GetProperty(wszName, &Var);
            if(FAILED(hres)) return hres;
            VariantInit(pVal);

			// When we fill the variant, perform any appropriate optimizations
			// to cut down on memory allocations
            Var.FillVariant(pVal, TRUE);
        }
        if(pctType != NULL || plFlavor != NULL || pVal == NULL)
        {
            hres = GetPropertyType(wszName, pctType, plFlavor);
            if(FAILED(hres)) return hres;
        }
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetNames(
                    LPCWSTR wszQualifierName,
                    long lFlags, VARIANT* pQualValue, SAFEARRAY** ppArray)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        CClassPart& ClassPart = *GetClassPart();

        // Test parameter correctness
        // ==========================

        if(ppArray == NULL) return WBEM_E_INVALID_PARAMETER;
        *ppArray = NULL;

        long lPrimaryCond = lFlags & WBEM_MASK_PRIMARY_CONDITION;
        long lOriginCond = lFlags & WBEM_MASK_CONDITION_ORIGIN;
		long lClassCondition = lFlags & WBEM_MASK_CLASS_CONDITION;

        BOOL bKeysOnly = lFlags & WBEM_FLAG_KEYS_ONLY;
        BOOL bRefsOnly = lFlags & WBEM_FLAG_REFS_ONLY;

        if(lFlags & ~WBEM_MASK_PRIMARY_CONDITION & ~WBEM_MASK_CONDITION_ORIGIN &
            ~WBEM_FLAG_KEYS_ONLY & ~WBEM_FLAG_REFS_ONLY & ~WBEM_MASK_CLASS_CONDITION)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

		// Cannot request a class conditin and be an instance
		if ( lClassCondition &&	IsInstance() )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

        CVar varQualValue;

        if(lPrimaryCond != WBEM_FLAG_ALWAYS)
        {
            if(wszQualifierName == NULL || wcslen(wszQualifierName) == 0)
                return WBEM_E_INVALID_PARAMETER;

            if(lPrimaryCond == WBEM_FLAG_ONLY_IF_TRUE ||
                lPrimaryCond == WBEM_FLAG_ONLY_IF_FALSE)
            {
                if(pQualValue != NULL) return WBEM_E_INVALID_PARAMETER;
            }
            else if(lPrimaryCond == WBEM_FLAG_ONLY_IF_IDENTICAL)
            {
                if(pQualValue == NULL) return WBEM_E_INVALID_PARAMETER;
                varQualValue.SetVariant(pQualValue, TRUE);
            }
            else return WBEM_E_INVALID_PARAMETER;
        }

        // Changed to AutoDelete so it gets destructed, however, to
        // access the array, we must now make a copy.

        CSafeArray SA(VT_BSTR, CSafeArray::auto_delete,
                        ClassPart.m_Properties.GetNumProperties() +
                        CSystemProperties::GetNumSystemProperties());

        // Add system properties, if required
        // ==================================

        if((lOriginCond == 0 || lOriginCond == WBEM_FLAG_SYSTEM_ONLY) &&
            (lPrimaryCond == WBEM_FLAG_ALWAYS ||
                lPrimaryCond == WBEM_FLAG_ONLY_IF_FALSE) &&
            !bKeysOnly && !bRefsOnly && !lClassCondition
        )
        {
            int nNumProps = CSystemProperties::GetNumSystemProperties();

            for(int i = 1; i <= nNumProps; i++)
            {
                BSTR strName = CSystemProperties::GetNameAsBSTR(i);
                CSysFreeMe  sfm( strName );

                SA.AddBSTR(strName);
            }
        }

        // Enumerate all regular properties, testing condition
        // ===================================================

        for(int i = 0; i < ClassPart.m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = ClassPart.GetPropertyLookup(i);
            if(pLookup == NULL) return WBEM_S_NO_MORE_DATA;

            CPropertyInformation* pInfo = (CPropertyInformation*)
                ClassPart.m_Heap.ResolveHeapPointer(pLookup->ptrInformation);

            // Test condition
            // ==============

            if(lFlags != 0)
            {
                if((lOriginCond == WBEM_FLAG_LOCAL_ONLY) &&
                        CType::IsParents(pInfo->nType))
                    continue;

                if((lOriginCond == WBEM_FLAG_PROPAGATED_ONLY) &&
                        !CType::IsParents(pInfo->nType))
                    continue;

				// This means we're dealing with a class and we're only interested
				// in overridden properties
				if ( lClassCondition == WBEM_FLAG_CLASS_OVERRIDES_ONLY )
				{
					// We ignore if it's local - since no way could it be overridden
					// We ignore if it's not overridden
					if ( !CType::IsParents(pInfo->nType) || !pInfo->IsOverriden( ClassPart.GetDataTable() ) )
					{
						continue;
					}
				}

				// This means we're dealing with a class and we're interested in
				// both local and overridden properties
				if ( lClassCondition == WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES )
				{
					// We ignore if it's not one or the other
					if ( CType::IsParents(pInfo->nType) && !pInfo->IsOverriden( ClassPart.GetDataTable() ) )
						continue;
				}

				// Check for a potential incorrect system property hit here
				if ( GetClassPart()->GetHeap()->ResolveString(pLookup->ptrName)->StartsWithNoCase( L"__" ) )
				{
					if ( lOriginCond & WBEM_FLAG_NONSYSTEM_ONLY || 
						lClassCondition ||
						lOriginCond == WBEM_FLAG_LOCAL_ONLY ||
						lOriginCond == WBEM_FLAG_PROPAGATED_ONLY )
					{
							continue;
					}
				}
				else if ( lOriginCond == WBEM_FLAG_SYSTEM_ONLY )
				{
					// We don't care about the property if this is a system only enumeration
					continue;
				}

                if((lFlags & WBEM_FLAG_KEYS_ONLY) && !pInfo->IsKey())
                    continue;

                if((lFlags & WBEM_FLAG_REFS_ONLY) &&
                        !pInfo->IsRef(&ClassPart.m_Heap))
                    continue;

                // Need to try to find the qualifier
                // =================================

                if(lPrimaryCond != WBEM_FLAG_ALWAYS)
                {
                    CVar varActualQual;
                    HRESULT hres = GetPropQualifier(pInfo,
                        wszQualifierName, &varActualQual);

                    if(lPrimaryCond == WBEM_FLAG_ONLY_IF_TRUE && FAILED(hres))
                        continue;

                    if(lPrimaryCond == WBEM_FLAG_ONLY_IF_FALSE &&
                            SUCCEEDED(hres))
                        continue;

                    if(lPrimaryCond == WBEM_FLAG_ONLY_IF_IDENTICAL &&
                            (FAILED(hres) || !(varActualQual == varQualValue))
                      )
                        continue;
                }
            }

            // Passed the test
            // ===============

            BSTR strName = ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                CreateBSTRCopy();
            // Check for allocation failures
            if ( NULL == strName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

			// Check if it's an extended system prop.  If so, get the real name
			/*
			int	nExtPropIndex = CSystemProperties::FindExtPropName( strName );
			if ( nExtPropIndex > 0L )
			{
				SysFreeString( strName );
				strName = CSystemProperties::GetExtDisplayNameAsBSTR( nExtPropIndex );

				if ( NULL == strName )
				{
					return WBEM_E_OUT_OF_MEMORY;
				}

			}
			*/

            CSysFreeMe  sfm( strName );


            // This should throw an exception if we hit an OOM condition
            SA.AddBSTR(strName);

        }	// FOR enum regular properties

        // Create SAFEARRAY and return
        // ===========================

        SA.Trim();

        // Now we make a copy, since the member array will be autodestructed (this
        // allows us to write exception-handling code
        *ppArray = SA.GetArrayCopy();
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }


}


//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::BeginEnumeration(long lEnumFlags)
{
    // No Allocations take place here, so no need to catch exceptions

    try
    {
        CLock lock(this);

        long lOriginFlags = lEnumFlags & WBEM_MASK_CONDITION_ORIGIN;
		long lClassFlags = lEnumFlags & WBEM_MASK_CLASS_CONDITION;

        BOOL bKeysOnly = lEnumFlags & WBEM_FLAG_KEYS_ONLY;
        BOOL bRefsOnly = lEnumFlags & WBEM_FLAG_REFS_ONLY;

		// We allow CLASS Flags only on classes
		if( lClassFlags && IsInstance() )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

        if( lEnumFlags & ~WBEM_MASK_CONDITION_ORIGIN & ~WBEM_FLAG_KEYS_ONLY &
                ~WBEM_FLAG_REFS_ONLY & ~WBEM_MASK_CLASS_CONDITION )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if((lOriginFlags == 0 || lOriginFlags == WBEM_FLAG_SYSTEM_ONLY) &&
            !bKeysOnly && !bRefsOnly && !lClassFlags )
        {
            m_nCurrentProp = -CSystemProperties::GetNumSystemProperties();
        }
        else
            m_nCurrentProp = 0;

        m_lEnumFlags = lEnumFlags;

		// Always clear this
		m_lExtEnumFlags = 0L;

        return WBEM_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::Next(long lFlags, BSTR* pstrName, VARIANT* pvar,
                              CIMTYPE* pctType, long* plFlavor)
{
    // Check for out of memory

    BSTR strName = NULL;

    try
    {
        CLock lock(this);

        long    nOriginalProp = m_nCurrentProp;

        if(pvar)
            VariantInit(pvar);
        if(pstrName)
            *pstrName = NULL;

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(m_nCurrentProp == INVALID_PROPERTY_INDEX)
            return WBEM_E_UNEXPECTED;

        CClassPart& ClassPart = *GetClassPart();

        // Search for a valid system property
        // ==================================

        while(m_nCurrentProp < 0)
        {
            // Don't use scoping to axe this BSTR, since iut's value may get sent to the
            // outside world.
            strName = CSystemProperties::GetNameAsBSTR(-m_nCurrentProp);

            if ( NULL == strName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            CVar Var;
            HRESULT hres = GetSystemProperty(-(m_nCurrentProp++), &Var);
            if(FAILED(hres))
            {
                COleAuto::_SysFreeString(strName);
                strName = NULL;
                continue;
            }

            CSystemProperties::GetPropertyType(strName, pctType, plFlavor);
            if(pvar)
            {
                Var.FillVariant(pvar, TRUE);
            }
            if(pstrName)
            {
                *pstrName = strName;
            }
            else
            {
                COleAuto::_SysFreeString(strName);
                strName = NULL;
            }

            return hres;
        }

        // Look for the non-system property
        // ================================

        // Loop until you find a match
        // ===========================
        CPropertyLookup* pLookup;
        CPropertyInformation* pInfo;
        while(1)
        {
            pLookup = ClassPart.GetPropertyLookup(m_nCurrentProp++);
            if(pLookup == NULL) return WBEM_S_NO_MORE_DATA;

            pInfo = (CPropertyInformation*)
                ClassPart.m_Heap.ResolveHeapPointer(pLookup->ptrInformation);

            if((m_lEnumFlags & WBEM_FLAG_KEYS_ONLY) && !pInfo->IsKey())
                continue;
            if((m_lEnumFlags & WBEM_FLAG_REFS_ONLY) &&
                    !pInfo->IsRef(&ClassPart.m_Heap))
                continue;

            // Get the flavor and check if it passes our origin conditions
            long lFlavor = 0;
            GetPropertyType( pInfo, NULL, &lFlavor );

            if((m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN)==WBEM_FLAG_LOCAL_ONLY &&
                WBEM_FLAVOR_ORIGIN_PROPAGATED == lFlavor)
                continue;

            if((m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN)==WBEM_FLAG_PROPAGATED_ONLY &&
                WBEM_FLAVOR_ORIGIN_LOCAL == lFlavor)
                continue;

			// Check for a potential incorrect system property hit here
			if ( GetClassPart()->GetHeap()->ResolveString(pLookup->ptrName)->StartsWithNoCase( L"__" ) )
			{
				if ( ( m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN ) == WBEM_FLAG_NONSYSTEM_ONLY ||
					( m_lEnumFlags & WBEM_MASK_CLASS_CONDITION ) ||
					( m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN )==WBEM_FLAG_LOCAL_ONLY ||
					( m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN ) == WBEM_FLAG_PROPAGATED_ONLY )
				{
					// If the extended flag is set, then we really do want this property.
					if ( !( m_lExtEnumFlags & WMIOBJECT_BEGINENUMEX_FLAG_GETEXTPROPS ) )
						continue;
				}
			}
			else if ( ( m_lEnumFlags & WBEM_MASK_CONDITION_ORIGIN ) == WBEM_FLAG_SYSTEM_ONLY )
			{
				// We don't care about the property if this is a system only enumeration
				continue;
			}
			else
			{

				// This means we're dealing with a class and interested in overridden properties
				if ( ( m_lEnumFlags & WBEM_MASK_CLASS_CONDITION ) == WBEM_FLAG_CLASS_OVERRIDES_ONLY )
				{
					// We ignore if it's local - since no way could it be overridden
					// We ignore if it's not overridden
					if ( WBEM_FLAVOR_ORIGIN_LOCAL == lFlavor || !pInfo->IsOverriden( ClassPart.GetDataTable() ) )
						continue;

				}

				// This means we're dealing with a class and interested in local and overridden properties
				if ( ( m_lEnumFlags & WBEM_MASK_CLASS_CONDITION ) == WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES )
				{
					// We ignore if it's not one or the other
					if ( WBEM_FLAVOR_ORIGIN_LOCAL != lFlavor && !pInfo->IsOverriden( ClassPart.GetDataTable() ) )
						continue;
				}

			}

            break;
        }

        // Found our property. Get its value
        // =================================

        // Don't use scoping to axe this BSTR, since iut's value may get sent to the
        // outside world.
        strName = ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
            CreateBSTRCopy();

        // Check for allocation failures
        if ( NULL == strName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CVar Var;
        HRESULT	hr = GetProperty(pInfo, &Var);

		if ( FAILED( hr ) )
		{
			return hr;
		}

        GetPropertyType(strName, pctType, plFlavor);

		// Check if it's an extended system prop.  If so, get the real name
		/*
		int	nExtPropIndex = CSystemProperties::FindExtPropName( strName );

		if ( nExtPropIndex > 0L )
		{
			SysFreeString( strName );
			strName = CSystemProperties::GetExtDisplayNameAsBSTR( nExtPropIndex );

			if ( NULL == strName )
			{
				return WBEM_E_OUT_OF_MEMORY;
			}

			// This is a system property
			if ( NULL != plFlavor )
			{
				*plFlavor = WBEM_FLAVOR_ORIGIN_SYSTEM;
			}

		}
		*/

        if(pvar)
        {
            Var.FillVariant(pvar, TRUE);
        }

        if(pstrName)
        {
            *pstrName = strName;
        }
        else
        {
            // Cleanup the BSTR if we don't need it
            COleAuto::_SysFreeString(strName);
            strName = NULL;
        }

        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        // Something blew.  Just go to the end of the enumeration
        m_nCurrentProp = INVALID_PROPERTY_INDEX;

        // Cleanup the strName if necessary
        if ( NULL != strName )
        {
            COleAuto::_SysFreeString(strName);
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        // Something blew.  Just go to the end of the enumeration
        try
        {
            m_nCurrentProp = INVALID_PROPERTY_INDEX;
        }
        catch(...)
        {
        }

        // Cleanup the strName if necessary
        if ( NULL != strName )
        {
            COleAuto::_SysFreeString(strName);
        }

        return WBEM_E_CRITICAL_ERROR;
    }

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::EndEnumeration()
{
    try
    {
        // No Allocations take place here, so no need to catch exceptions

        CLock lock(this);

        m_nCurrentProp = INVALID_PROPERTY_INDEX;
		m_lExtEnumFlags = 0L;
        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}


//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetSystemProperty(int nIndex, CVar* pVar)
{
    switch(nIndex)
    {
    case CSystemProperties::e_SysProp_Server:
        return GetServer(pVar);
    case CSystemProperties::e_SysProp_Namespace:
        return GetNamespace(pVar);
    case CSystemProperties::e_SysProp_Genus:
        return GetGenus(pVar);
    case CSystemProperties::e_SysProp_Class:
        return GetClassName(pVar);
    case CSystemProperties::e_SysProp_Superclass:
        return GetSuperclassName(pVar);
    case CSystemProperties::e_SysProp_Path:
        return GetPath(pVar);
    case CSystemProperties::e_SysProp_Relpath:
        return GetRelPath(pVar);
    case CSystemProperties::e_SysProp_PropertyCount:
        return GetPropertyCount(pVar);
    case CSystemProperties::e_SysProp_Dynasty:
        return GetDynasty(pVar);
    case CSystemProperties::e_SysProp_Derivation:
        return GetDerivation(pVar);
    }

    return WBEM_E_NOT_FOUND;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetServer(CVar* pVar)
{
    if(m_DecorationPart.IsDecorated())
    {
        // Check for allocation failures
        if ( !m_DecorationPart.m_pcsServer->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetNamespace(CVar* pVar)
{
    if(m_DecorationPart.IsDecorated())
    {
        // Check for allocation failures
        if ( !m_DecorationPart.m_pcsNamespace->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetServerAndNamespace(CVar* pVar)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(m_DecorationPart.IsDecorated())
    {
        // We need to manually throw exceptions if the BSTR allocations fail.
        BSTR strServer = m_DecorationPart.m_pcsServer->CreateBSTRCopy();
        CSysFreeMe  sfmSvr( strServer );

        if ( NULL != strServer )
        {
            BSTR strNamespace = m_DecorationPart.m_pcsNamespace->CreateBSTRCopy();
            CSysFreeMe  sfmNS( strNamespace );

            if ( NULL != strNamespace )
            {
                try
                {
                    // Overridden new will throw an exception intrinsically
                    WCHAR* wszName = new WCHAR[SysStringLen(strServer) +
                                        SysStringLen(strNamespace) + 10];

                    swprintf( wszName, L"\\\\%s\\%s", strServer, strNamespace );

                    // Let the CVar deal with deleting the memory
                    pVar->SetLPWSTR( wszName, TRUE );
                }
                catch( ... )
                {
                    hr =  WBEM_E_OUT_OF_MEMORY;
                }

            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        // No decoration, so just set to NULL
        pVar->SetAsNull();
    }

    return hr;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetPath(CVar* pVar)
{
    if(m_DecorationPart.IsDecorated())
    {
       LPWSTR wszFullPath = GetFullPath();
       if(wszFullPath == NULL)
           return WBEM_E_INVALID_OBJECT;
       pVar->SetBSTR(wszFullPath);
       delete [] wszFullPath;
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetRelPath(CVar* pVar)
{
    LPWSTR wszRelPath = GetRelPath();
    if(wszRelPath == NULL)
    {
        pVar->SetAsNull();
    }
    else
    {
        pVar->SetBSTR(wszRelPath);
        delete [] wszRelPath;
    }
    return WBEM_NO_ERROR;
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
LPWSTR CWbemObject::GetFullPath()
{
    if(!m_DecorationPart.IsDecorated()) return NULL;

    LPWSTR pRelPath = GetRelPath();
    if (!pRelPath)
        return 0;

    WCHAR* wszPath = NULL;

    // We need to manually throw exceptions if the BSTR allocations fail.
    BSTR strServer = m_DecorationPart.m_pcsServer->CreateBSTRCopy();
    CSysFreeMe  sfmSvr( strServer );

    if ( NULL != strServer )
    {
        BSTR strNamespace = m_DecorationPart.m_pcsNamespace->CreateBSTRCopy();
        CSysFreeMe  sfmNS( strNamespace );

        if ( NULL != strNamespace )
        {
            // Overridden new will throw an exception intrinsically
            wszPath = new WCHAR[SysStringLen(strServer) +
                                SysStringLen(strNamespace) + wcslen(pRelPath) + 10];

            if ( NULL != wszPath )
            {
                swprintf(wszPath, L"\\\\%s\\%s:%s", strServer, strNamespace, pRelPath);

                delete [] pRelPath;
            }
            else
            {
                throw CX_MemoryException();
            }

        }
        else
        {
            throw CX_MemoryException();
        }

    }
    else
    {
        throw CX_MemoryException();
    }

    return wszPath;

}

//******************************************************************************
//
//  See fastobj.h for documentation.
//
//******************************************************************************
HRESULT CWbemObject::GetDerivation(CVar* pVar)
{
    return GetClassPart()->GetDerivation(pVar);
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
BOOL CWbemObject::HasRefs()
{
    CClassPart* pClassPart = GetClassPart();

    for(int i = 0; i < pClassPart->m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pClassPart->m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&pClassPart->m_Heap);
        if(CType::GetActualType(pInfo->nType) == CIM_REFERENCE)
            return TRUE;
    }
    return FALSE;
}


//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
BOOL CWbemObject::GetRefs(CWStringArray& awsRefs,
                                CWStringArray* pawsNames)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    // Check for out of memory
    BOOL bFound = FALSE;
    CClassPart* pClassPart = GetClassPart();

    for(int i = 0; i < pClassPart->m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pClassPart->m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&pClassPart->m_Heap);
        if(CType::GetActualType(pInfo->nType) != CIM_REFERENCE)
            continue;

        bFound = TRUE;

        CVar vValue;
        GetProperty(pInfo, &vValue);

        // Special case for when the value is empty
        // ========================================

        if(vValue.GetLPWSTR() == NULL || wcslen(vValue.GetLPWSTR()) == 0)
        {
            // Check if this is a class
            // ========================

            if(IsInstance())
            {
                // Don't mention this property!
                // ============================

                continue;
            }

            // Check if the reference is strongly typed
            // ========================================

            CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
                pInfo->GetQualifierSetData(), &pClassPart->m_Heap, TYPEQUAL);
            CCompressedString* pSyntax =
                pClassPart->m_Heap.ResolveString(pQual->Value.AccessPtrData());

            if(pSyntax->CompareNoCase(L"ref") == 0)
            {
                // Untyped. Value is an empty string
                // =================================

                // Check for OOM
                if ( awsRefs.Add(L"") != CWStringArray::no_error )
                {
                    throw CX_MemoryException();
                }
            }
            else
            {
                // Typed. Extract the class name
                // =============================

                WString wsSyntax = pSyntax->CreateWStringCopy();
                LPCWSTR wszClass = ((LPCWSTR)wsSyntax) + strlen("ref:");

                // Check for OOM
                if ( awsRefs.Add(wszClass) != CWStringArray::no_error )
                {
                    throw CX_MemoryException();
                }

            }
        }
        else
        {
            // Actual value is present
            // =======================

            // Check for OOM
            if ( awsRefs.Add(vValue.GetLPWSTR()) != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
            
        }

        if(pawsNames)
        {
            // Check for OOM
            if ( pawsNames->Add(pClassPart->m_Heap.ResolveString(
                    pLookup->ptrName)->CreateWStringCopy()) != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
            
        }
    }
    return bFound;

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
BOOL CWbemObject::GetClassRefs(CWStringArray& awsRefs,
                                CWStringArray* pawsNames)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    // Check for out of memory
    if(IsInstance())
        return FALSE;

    BOOL bFound = FALSE;
    CClassPart* pClassPart = GetClassPart();

    for(int i = 0; i < pClassPart->m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pClassPart->m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&pClassPart->m_Heap);

        if(CType::GetActualType(pInfo->nType) != CIM_REFERENCE)
            continue;

        CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
            pInfo->GetQualifierSetData(), &pClassPart->m_Heap, TYPEQUAL);

        if(pQual == NULL)
            continue;
        CCompressedString* pSyntax =
            pClassPart->m_Heap.ResolveString(pQual->Value.AccessPtrData());

        bFound = TRUE;

        // Check if the reference is strongly typed
        // ========================================

        if(pSyntax->CompareNoCase(L"ref") == 0)
        {
            // Untyped. Value is an empty string
            // =================================

            // Check for OOM
            if ( awsRefs.Add(L"") != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
            
        }
        else
        {
            // Typed. Extract the class name
            // =============================

            WString wsSyntax = pSyntax->CreateWStringCopy();
            LPCWSTR wszClass = ((LPCWSTR)wsSyntax) + strlen("ref:");

            // Check for OOM
            if ( awsRefs.Add(wszClass) != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
            
        }

        if(pawsNames)
        {
            // Check for OOM
            if ( pawsNames->Add(pClassPart->m_Heap.ResolveString(
                    pLookup->ptrName)->CreateWStringCopy()) != CWStringArray::no_error )
            {
                throw CX_MemoryException();
            }
            
        }
    }
    return bFound;

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(pCompareTo == NULL)
            return WBEM_E_INVALID_PARAMETER;

        HRESULT hres;

        // IMPORTANT: assumes that the other object was created by us as well.
        // ===================================================================

        CWbemObject* pOther = NULL;
		if ( FAILED( WbemObjectFromCOMPtr( pCompareTo, &pOther ) ) )
		{
			return WBEM_E_INVALID_OBJECT;
		}
		
		// Auto Release
		CReleaseMe	rmObj( (IWbemClassObject*) pOther );

        LONG lFlagsLeft = lFlags;
        BOOL bIgnoreQuals = lFlags & WBEM_FLAG_IGNORE_QUALIFIERS;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_QUALIFIERS;

        BOOL bIgnoreSource = lFlags & WBEM_FLAG_IGNORE_OBJECT_SOURCE;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_OBJECT_SOURCE;

        BOOL bIgnoreDefaults = lFlags & WBEM_FLAG_IGNORE_DEFAULT_VALUES;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_DEFAULT_VALUES;

        BOOL bIgnoreDefs = lFlags & WBEM_FLAG_IGNORE_CLASS;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_CLASS;

        BOOL bIgnoreCase = lFlags & WBEM_FLAG_IGNORE_CASE;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_CASE;

        BOOL bIgnoreFlavor = lFlags & WBEM_FLAG_IGNORE_FLAVOR;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_FLAVOR;

        if(lFlagsLeft != 0)
        {
            // Undefined flags were found
            // ==========================
            return WBEM_E_INVALID_PARAMETER;
        }

        // Compare the object's memory blocks just in case they match
        // ==========================================================

        if(GetBlockLength() == pOther->GetBlockLength() &&
            memcmp(GetStart(), pOther->GetStart(), GetBlockLength()) == 0)
        {
            return WBEM_S_SAME;
        }

        // Compare decorations if required.
        // ===============================

        if(!bIgnoreSource && !m_DecorationPart.CompareTo(pOther->m_DecorationPart))
            return WBEM_S_DIFFERENT;

        CClassPart* pThisClass = GetClassPart();
        CClassPart* pOtherClass = pOther->GetClassPart();

        if(!bIgnoreDefs)
        {
            // Compare class name and superclass name
            // ======================================

            if(!pThisClass->CompareDefs(*pOtherClass))
                return WBEM_S_DIFFERENT;
        }

        // Compare qualifier sets if required
        // ==================================

        if(!bIgnoreQuals)
        {
            IWbemQualifierSet   *pThisSet = NULL;
            IWbemQualifierSet   *pOtherSet = NULL;

            GetQualifierSet(&pThisSet);
            CReleaseMe          rm1( pThisSet );

            pOther->GetQualifierSet(&pOtherSet);
            CReleaseMe          rm2( pOtherSet );


            hres =
                ((IExtendedQualifierSet*)pThisSet)->CompareTo(lFlags, pOtherSet);
            if(hres != WBEM_S_SAME)
                return WBEM_S_DIFFERENT;
        }

        // Compare property definitions
        // ============================

        for(int i = 0; i < pThisClass->m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = pThisClass->m_Properties.GetAt(i);
            CPropertyLookup* pOtherLookup = pOtherClass->m_Properties.GetAt(i);

            if(!bIgnoreDefs)
            {
                // Compare names
                // =============

                if(pThisClass->m_Heap.ResolveString(pLookup->ptrName)->
                    CompareNoCase(
                    *pOtherClass->m_Heap.ResolveString(pOtherLookup->ptrName))
                    != 0)
                {
                    return WBEM_S_DIFFERENT;
                }
            }

            // Get property information structures
            // ===================================

            CPropertyInformation* pInfo =
                pLookup->GetInformation(&pThisClass->m_Heap);
            CPropertyInformation* pOtherInfo =
                pOtherLookup->GetInformation(&pOtherClass->m_Heap);

            if(!bIgnoreDefs)
            {

                // Compare types
                // =============

                if(pInfo->nType != pOtherInfo->nType)
                {
                    return WBEM_S_DIFFERENT;
                }
            }

            if( !bIgnoreDefaults || IsInstance() )
            {
                // Protect against NULLs
                if ( NULL == pInfo || NULL == pOtherInfo )
                {
                    return WBEM_E_NOT_FOUND;
                }

                // Compare values
                // ==============

                CVar vThis, vOther;
                hres = GetProperty(pInfo, &vThis);
                if(FAILED(hres)) return hres;
                hres = pOther->GetProperty(pOtherInfo, &vOther);
                if(FAILED(hres)) return hres;

                if(!vThis.CompareTo(vOther, bIgnoreCase))
                {
                    // Check if the values are embedded objects
                    // ========================================

                    if(vThis.GetType() == VT_EMBEDDED_OBJECT &&
                        vOther.GetType() == VT_EMBEDDED_OBJECT)
                    {
                        IWbemClassObject* pThisEmb =
                            (IWbemClassObject*)vThis.GetEmbeddedObject();
                        IWbemClassObject* pOtherEmb =
                            (IWbemClassObject*)vOther.GetEmbeddedObject();

                        // Compare them taking everything into account --- the flags
                        // do not apply!
                        // =========================================================

                        hres = pThisEmb->CompareTo(0, pOtherEmb);
                        if(hres != WBEM_S_SAME)
                            return hres;
                    }
                    else
                    {
                        return WBEM_S_DIFFERENT;
                    }
                }
            }

            // Compare qualifiers if required
            // ==============================

            if( !bIgnoreQuals )
            {
                // Cleanup when we drop out of scope
                BSTR strName = pThisClass->m_Heap.ResolveString(pLookup->ptrName)->
                    CreateBSTRCopy();
                CSysFreeMe  sfm( strName );

                // Check for allocation failures
                if ( NULL == strName )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

				// Don't do this if this appears to be a system property
				if ( !CSystemProperties::IsPossibleSystemPropertyName( strName ) )
				{
					IWbemQualifierSet   *pThisSet = NULL;
					IWbemQualifierSet   *pOtherSet = NULL;

					// Release both when they  fall out of scope

					hres = GetPropertyQualifierSet(strName, &pThisSet);
					CReleaseMe          rm1( pThisSet );
					if(FAILED(hres)) return hres;

					hres = pOther->GetPropertyQualifierSet(strName, &pOtherSet);
					CReleaseMe          rm2( pOtherSet );
					if(FAILED(hres)) return hres;

					hres = ((IExtendedQualifierSet*)pThisSet)->CompareTo(lFlags, pOtherSet);

					if(hres != WBEM_S_SAME)
						return WBEM_S_DIFFERENT;
				}
            }
        }

        return WBEM_S_SAME;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::GetPropertyOrigin(LPCWSTR wszProperty,
                                           BSTR* pstrClassName)
{
    // No allocations in this function so no need to do any exception handling
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszProperty == NULL || pstrClassName == NULL ||
                wcslen(wszProperty) == 0)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // If this is a limited version, return an error since we really can't
        // accurately return property origin data.

        if ( m_DecorationPart.IsLimited() )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        return GetClassPart()->GetPropertyOrigin(wszProperty, pstrClassName);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemObject::InheritsFrom(LPCWSTR wszClassName)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszClassName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if(GetClassPart()->InheritsFrom(wszClassName))
        {
            return WBEM_S_NO_ERROR;
        }
        else return WBEM_S_FALSE;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

STDMETHODIMP CWbemObject::GetPropertyValue(WBEM_PROPERTY_NAME* pName, long lFlags,
                                          WBEM_WSTR* pwszCimType,
                                          VARIANT* pvValue)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(pwszCimType)
            *pwszCimType = NULL;

        // Check that the first element is a property name
        // ===============================================

        if(pName->m_lNumElements <= 0) return WBEM_E_INVALID_PARAMETER;
        if(pName->m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            return WBEM_E_INVALID_PARAMETER;

        // Get that first property
        // =======================

        CVar vCurrent;
        CVar vCimType;
        HRESULT hres = GetProperty(pName->m_aElements[0].Element.m_wszPropertyName,
                                    &vCurrent);
        if(FAILED(hres)) return hres;
        GetPropQualifier(pName->m_aElements[0].Element.m_wszPropertyName,
            TYPEQUAL, &vCimType, NULL);

        // Process the rest of the elements
        // ================================

        long lIndex = 1;
        while(lIndex < pName->m_lNumElements)
        {
            WBEM_NAME_ELEMENT& El = pName->m_aElements[lIndex];
            if(El.m_nType == WBEM_NAME_ELEMENT_TYPE_INDEX)
            {
                if(vCurrent.GetType() != VT_EX_CVARVECTOR)
                    return WBEM_E_NOT_FOUND;

				CVar	vTemp;
				vCurrent.GetVarVector()->FillCVarAt( El.Element.m_lArrayIndex, vTemp );
				vCurrent = vTemp;
            }
            else if(El.m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            {
                if(vCurrent.GetType() != VT_EMBEDDED_OBJECT)
                    return WBEM_E_NOT_FOUND;
                CWbemObject* pObj =
                    (CWbemObject*)(IWbemClassObject*)vCurrent.GetEmbeddedObject();
                vCurrent.Empty();
                hres = pObj->GetProperty(El.Element.m_wszPropertyName, &vCurrent);

                // Clear now to prevent memory leaks
                vCimType.Empty();

                pObj->GetPropQualifier(El.Element.m_wszPropertyName, TYPEQUAL,
                    &vCimType);
                pObj->Release();
                if(FAILED(hres)) return hres;
            }
            lIndex++;
        }

        // Copy the CVar we ended up with into the variant
        // ===============================================

        vCurrent.FillVariant(pvValue, TRUE);
        if(pwszCimType && vCimType.GetType() == VT_BSTR)
            *pwszCimType = WbemStringCopy(vCimType.GetLPWSTR());
        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


STDMETHODIMP CWbemObject::GetPropertyHandle(LPCWSTR wszPropertyName,
                                            CIMTYPE* pct,
                                            long* plHandle)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface
    
    // Allocation Exceptions handled underneath
    return GetClassPart()->GetPropertyHandle(wszPropertyName, pct, plHandle);
}

STDMETHODIMP CWbemObject::GetPropertyInfoByHandle(long lHandle,
                                        BSTR* pstrPropertyName, CIMTYPE* pct)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface
    
    // Allocation Exceptions handled underneath
    return GetClassPart()->GetPropertyInfoByHandle(lHandle, pstrPropertyName,
                                        pct);
}

HRESULT CWbemObject::IsValidPropertyHandle( long lHandle )
{
    // Shouldn' be any allocations here
    return GetClassPart()->IsValidPropertyHandle( lHandle );
}


HRESULT CWbemObject::WritePropertyValue(long lHandle, long lNumBytes,
                                        const BYTE* pData)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface
    
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    BOOL bUseOld = !m_refDataTable.IsDefault(nIndex) &&
                        !m_refDataTable.IsNull(nIndex);
    m_refDataTable.SetNullness(nIndex, FALSE);
    m_refDataTable.SetDefaultness(nIndex, FALSE);

    if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
    {

        // Allocation errors are handled underneath

        // Handle strings.

        int nOffset = (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle));
        LPCWSTR wszData = (LPCWSTR)pData;

        // Verify null-termination
        // =======================

        // The number of bytes must be divisible by 2, >= 2 and
        // the character in the buffer at the end must be a NULL.
        // This will be faster than doing an lstrlen.

        if (    ( lNumBytes < 2 ) ||
                ( lNumBytes % 2 ) ||
                ( wszData[lNumBytes/2 - 1] != 0 ) )
            return WBEM_E_INVALID_PARAMETER;

        // Create a value pointing to the right offset in the data table
        // =============================================================

        CDataTablePtr ValuePtr(&m_refDataTable, nOffset);
        CVar v;
        v.SetLPWSTR((LPWSTR)pData, TRUE);
        v.SetCanDelete(FALSE);

        // Check for possible memory allocation failures
        Type_t  nReturnType;
        HRESULT hr = CUntypedValue::LoadFromCVar(&ValuePtr, v, VT_BSTR, &m_refDataHeap,
                        nReturnType,bUseOld);
        
        if ( FAILED( hr ) )
        {
            return hr;
        }

        if ( CIM_ILLEGAL == nReturnType )
        {
            return WBEM_E_TYPE_MISMATCH;
        }
    }
    else
    {

        if ( lNumBytes != WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Just copy
        // =========

        memcpy((void*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))),
                pData, WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle));
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::ReadPropertyValue(long lHandle, long lNumBytes,
                                        long* plRead, BYTE* pData)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    if(m_refDataTable.IsNull(nIndex))
    {
        *plRead = 0;
        return WBEM_S_FALSE;
    }

    if(m_refDataTable.IsDefault(nIndex))
    {
        long    lRead = 0;
        return GetClassPart()->GetDefaultByHandle( lHandle, lNumBytes, plRead, pData );
    }

    if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
    {
        // Handle strings.

        CCompressedString* pcs = m_refDataHeap.ResolveString(
            *(PHEAPPTRT)(m_refDataTable.m_pData +
                                        (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));

        long lNumChars = pcs->GetStringLength();
        *plRead = (lNumChars + 1) * 2;
        if(*plRead > lNumBytes)
        {
            return WBEM_E_BUFFER_TOO_SMALL;
        }

        if(pcs->IsUnicode())
        {
            memcpy(pData, pcs->GetRawData(), lNumChars * 2);
        }
        else
        {
            WCHAR* pwcDest = (WCHAR*)pData;
            char* pcSource = (char*)pcs->GetRawData();
            long lLeft = lNumChars;
            while(lLeft--)
            {
                *(pwcDest++) = (WCHAR)*(pcSource++);
            }
        }

        ((LPWSTR)pData)[lNumChars] = 0;

        return WBEM_S_NO_ERROR;
    }
    else
    {
        // Just copy
        // =========

        *plRead = WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle);

        // Buffer is too small
        if(*plRead > lNumBytes)
        {
            return WBEM_E_BUFFER_TOO_SMALL;
        }

        memcpy(pData, (void*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))),
                *plRead);
        return WBEM_S_NO_ERROR;
    }
}

HRESULT CWbemObject::ReadDWORD(long lHandle, DWORD* pdw)
{
    // No allocation errors here.  Just direct memory access
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling

    // This is a high-perf interface

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    // Check NULLness and Defaultness
    if(m_refDataTable.IsNull(nIndex))
    {
        *pdw = 0;
        return WBEM_S_FALSE;
    }

    if(m_refDataTable.IsDefault(nIndex))
    {
        long    lRead = 0;
        return GetClassPart()->GetDefaultByHandle( lHandle, sizeof(DWORD), &lRead, (BYTE*) pdw );
    }

    *pdw = *(UNALIGNED DWORD*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::WriteDWORD(long lHandle, DWORD dw)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    // No allocation errors here.  Just direct memory access

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    m_refDataTable.SetNullness(nIndex, FALSE);
    m_refDataTable.SetDefaultness(nIndex, FALSE);

    *(UNALIGNED DWORD*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))) = dw;
    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::ReadQWORD(long lHandle, unsigned __int64* pqw)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    // No allocation errors here.  Just direct memory access

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    if(m_refDataTable.IsNull(nIndex))
    {
        *pqw = 0;
        return WBEM_S_FALSE;
    }

    if(m_refDataTable.IsDefault(nIndex))
    {
        long    lRead = 0;
        return GetClassPart()->GetDefaultByHandle( lHandle, sizeof(unsigned __int64), &lRead, (BYTE*) pqw );
    }

    *pqw = *(UNALIGNED __int64*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::WriteQWORD(long lHandle, unsigned __int64 qw)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    // No allocation errors here.  Just direct memory access

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    m_refDataTable.SetNullness(nIndex, FALSE);
    m_refDataTable.SetDefaultness(nIndex, FALSE);
    *(UNALIGNED __int64*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))) = qw;
    return WBEM_S_NO_ERROR;
}

CWbemObject* CWbemObject::GetEmbeddedObj(long lHandle)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    // Check for NULLNess and a default

    if(m_refDataTable.IsNull(nIndex))
    {
        return NULL;
    }

    CEmbeddedObject* pEmbedding;

    if ( m_refDataTable.IsDefault( nIndex ) )
    {
        GetClassPart()->GetDefaultPtrByHandle( lHandle, (void**) &pEmbedding );
    }
    else
    {

        pEmbedding =
            (CEmbeddedObject*)m_refDataHeap.ResolveHeapPointer(
                *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
    }

    if ( NULL != pEmbedding )
    {
        return pEmbedding->GetEmbedded();
    }
    else
    {
        return NULL;
    }
}

INTERNAL CCompressedString* CWbemObject::GetPropertyString(long lHandle)
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    if(m_refDataTable.IsNull(nIndex))
    {
        return NULL;
    }

    CCompressedString*  pCs;

    // Check for defaultness
    if ( m_refDataTable.IsDefault( nIndex ) )
    {
        GetClassPart()->GetDefaultPtrByHandle( lHandle, (void**) &pCs );
    }
    else
    {
        pCs = m_refDataHeap.ResolveString(
                    *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
    }

    return  pCs;
}

HRESULT CWbemObject::GetArrayPropertyHandle(LPCWSTR wszPropertyName,
                                            CIMTYPE* pct,
                                            long* plHandle)
{
    // Allocation Exceptions handled underneath
    return GetClassPart()->GetPropertyHandleEx(wszPropertyName, pct, plHandle);
}

INTERNAL CUntypedArray* CWbemObject::GetArrayByHandle(long lHandle)
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    if(m_refDataTable.IsNull(nIndex))
    {
        return NULL;
    }

    CUntypedArray* pArr = NULL;
    // Check for defaultness
    if ( m_refDataTable.IsDefault( nIndex ) )
    {
        GetClassPart()->GetDefaultPtrByHandle( lHandle, (void**) &pArr );
    }
    else
    {
        pArr = (CUntypedArray*) m_refDataHeap.ResolveHeapPointer(
                    *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
    }

    return pArr;
}

INTERNAL heapptr_t CWbemObject::GetHeapPtrByHandle(long lHandle)
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    // Check for defaultness
    if ( m_refDataTable.IsDefault( nIndex ) )
    {
        return GetClassPart()->GetHeapPtrByHandle( lHandle );
    }

	// Return the value at the offset
	return *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
}



//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::GetUnmarshalClass(REFIID riid, void* pv,
    DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
    // No memory allocations here, so no need to do exception handling
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        *pClsid = CLSID_WbemClassObjectProxy;
        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::GetMarshalSizeMax(REFIID riid, void* pv,
    DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
    // No memory allocations here, so no need to do exception handling

    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        // Let the object decide how big it is
        return GetMaxMarshalStreamSize( plSize );
    }
    catch(...)
    {
        return E_FAIL;
    }
}

// Default Implementation
HRESULT CWbemObject::GetMaxMarshalStreamSize( ULONG* pulSize )
{
    *pulSize = GetBlockLength() + sizeof(DWORD) * 2;
    return S_OK;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::MarshalInterface(IStream* pStream, REFIID riid,
    void* pv,  DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
    try
    {
        CLock lock(this);

        HRESULT hres = ValidateObject( 0L );

		if ( FAILED( hres ) )
		{
			return E_FAIL;
		}

        CompactAll();

        hres = WriteToStream( pStream );

        return hres;
    }
    catch(...)
    {
        return E_FAIL;
    }
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::UnmarshalInterface(IStream* pStream, REFIID riid,
    void** ppv)
{
    return E_UNEXPECTED;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::ReleaseMarshalData(IStream* pStream)
{
    return E_UNEXPECTED;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}

STDMETHODIMP CWbemObject::GetDescription(BSTR* pstrDescription)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        *pstrDescription = NULL;

        CVar vDesc;
        if(SUCCEEDED(GetProperty(L"Description", &vDesc)))
        {
			// Return "" if vDesc is NULL, otherwise the actual value
			if ( vDesc.IsNull() )
			{
				*pstrDescription = COleAuto::_SysAllocString( L"" );
			}
			else
			{
				*pstrDescription = COleAuto::_SysAllocString( vDesc.GetLPWSTR() );
			}
        }

        return S_OK;
    }
    catch (CX_MemoryException)
    {
        return E_OUTOFMEMORY;
    }
    catch (...)
    {
        return E_FAIL;
    }

}

STDMETHODIMP CWbemObject::GetGUID(GUID* pguid)
{
    try
    {
        *pguid = IID_IWbemServices;
        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}
STDMETHODIMP CWbemObject::GetHelpContext(DWORD* pdwHelpContext)
{
    try
    {
        *pdwHelpContext = 0;
        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}
STDMETHODIMP CWbemObject::GetHelpFile(BSTR* pstrHelpFile)
{
    try
    {
        *pstrHelpFile = 0;
        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}
STDMETHODIMP CWbemObject::GetSource(BSTR* pstrSource)
{
    // Check for out of memory
    try
    {
        *pstrSource = COleAuto::_SysAllocString(L"WinMgmt");
        return S_OK;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


STDMETHODIMP CWbemObject::Lock(long lFlags)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    // Since the flags really don't do anything, we'll require 0L on this call.

    m_Lock.Lock();
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemObject::Unlock(long lFlags)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    // Since the flags really don't do anything, we'll require 0L on this call.

    m_Lock.Unlock();
    return WBEM_S_NO_ERROR;
}

// Iplementations of _IWmiObject functions for getting part data

// Check what the state of the internal data
STDMETHODIMP CWbemObject::QueryPartInfo( DWORD *pdwResult )
{
    try
    {
        *pdwResult = m_dwInternalStatus;
        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// The following code unmerges and merges BLOBs with CRC checking so we can
// verify if any corruptions are occuring outside of our control

#ifdef OBJECT_BLOB_CRC

// Buffer size
#define SIZE_OF_MD5_BUFFER	16

// Sets the object memory to a new BLOB
STDMETHODIMP CWbemObject::SetObjectMemory( LPVOID pMem, DWORD dwMemSize )
{
    // An exception can be thrown by SetData.  If so, the original object should
    // be '86'd (we can't fix it, since we would need to call SetData ourselves
    // to repair it and that may cause another exception

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_E_INVALID_PARAMETER;

        if ( NULL != pMem )
        {
            // Changing the BLOB, so we better be thread safe
            CLock lock(this);

			BYTE	bHash[SIZE_OF_MD5_BUFFER];
			BYTE*	pbTemp = (LPBYTE) pMem;

			// First we need to verify the hash
			MD5::Transform( pbTemp + SIZE_OF_MD5_BUFFER, dwMemSize - SIZE_OF_MD5_BUFFER, bHash );

			if ( memcmp( bHash, pbTemp, SIZE_OF_MD5_BUFFER ) != 0 )
			{
				OutputDebugString( "BLOB hash value check failed!" );
				DebugBreak();
				return WBEM_E_CRITICAL_ERROR;
			}

			pbTemp += SIZE_OF_MD5_BUFFER;
			dwMemSize -= SIZE_OF_MD5_BUFFER			;

			BYTE*	pbData = m_pBlobControl->Allocate(dwMemSize);

			if ( NULL != pbData )
			{
				// Delete prior memory
				m_pBlobControl->Delete(GetStart());

				// Copy the bytes across
	            CopyMemory( pbData, pbTemp, dwMemSize );

	            SetData( pbData, dwMemSize );

				// Cleanup the memory that was passed into us
				CoTaskMemFree( pMem );

		        hr = WBEM_S_NO_ERROR;
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

// Copies our entire BLOB into a user provided buffer
STDMETHODIMP CWbemObject::GetObjectMemory( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
    // Nothing is allocated here, so we should be ok

    HRESULT hr;

    try
    {
        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        // How big a block we need (we will prepend with an MD5 Hash)
		DWORD	dwBlockLen = GetBlockLength();
		DWORD	dwTotalLen = GetBlockLength() + SIZE_OF_MD5_BUFFER;

        *pdwUsed = dwTotalLen;

        // Make sure the size of the block is big enough, or return
        // a failure code.

        if ( dwDestBufSize >= *pdwUsed )
        {
            // Make sure we have a buffer to copy to
            if ( NULL != pDestination )
            {
				// Copy the memory 16 bytes in so we can prepend with an ND5 hash
                CopyMemory( ( (BYTE*) pDestination ) + SIZE_OF_MD5_BUFFER, GetStart(), GetBlockLength() );
				MD5::Transform( GetStart(), GetBlockLength(), (BYTE*) pDestination ); 

                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

#else

// Sets the object memory to a new BLOB
STDMETHODIMP CWbemObject::SetObjectMemory( LPVOID pMem, DWORD dwMemSize )
{
    // An exception can be thrown by SetData.  If so, the original object should
    // be '86'd (we can't fix it, since we would need to call SetData ourselves
    // to repair it and that may cause another exception

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_E_INVALID_PARAMETER;

        if ( NULL != pMem )
        {
            // Changing the BLOB, so we better be thread safe
            CLock lock(this);

			// Create a new COM Blob control, as the supplied memory must
			// be CoTaskMemAlloced/Freed.

			CCOMBlobControl*	pNewBlobControl = & g_CCOMBlobControl;

			//if ( NULL != pNewBlobControl )
			//{
				// Use the current BLOB Control to delete the underlying BLOB,
				// then delete the BLOB control and replace it with the new one
				// and SetData.
				m_pBlobControl->Delete(GetStart());
				
				//delete m_pBlobControl;
				m_pBlobControl = pNewBlobControl;

	            SetData( (LPMEMORY) pMem, dwMemSize );

		        hr = WBEM_S_NO_ERROR;
			//}
			//else
			//{
			//	hr = WBEM_E_OUT_OF_MEMORY;
			//}
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

// Copies our entire BLOB into a user provided buffer
STDMETHODIMP CWbemObject::GetObjectMemory( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
    // Nothing is allocated here, so we should be ok

    HRESULT hr;

    try
    {
        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        // How big a block we need
        *pdwUsed = GetBlockLength();

        // Make sure the size of the block is big enough, or return
        // a failure code.

        if ( dwDestBufSize >= GetBlockLength() )
        {
            // Make sure we have a buffer to copy to
            if ( NULL != pDestination )
            {
                CopyMemory( pDestination, GetStart(), GetBlockLength() );
                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

#endif

// Access to Decorate
STDMETHODIMP CWbemObject::SetDecoration( LPCWSTR pwcsServer, LPCWSTR pwcsNamespace )
{
    // Nothing is allocated here, so we should be ok

    try
    {
        // Changing the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        return Decorate( pwcsServer, pwcsNamespace );
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemObject::RemoveDecoration( void )
{
    // Nothing is allocated here, so we should be ok

    try
    {
        // Changing the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        //It's a void!
        Undecorate();

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

/*
// Shared memory functions
CWbemSharedMem CWbemObject::mstatic_SharedMem;

HRESULT CWbemObject::MoveToSharedMemory()
{
    Lock(0);

    // Find this object's control in shared memory
    // ===========================================

    CVar v;
    HRESULT hres = GetPath(&v);
    if(FAILED(hres))
    {
        Unlock(0);
        return hres;
    }

    CWbemSharedMem& SharedMem = GetSharedMemory();
    SharedMem.Initialize();
    SharedMem.LockMmf();

    SHARED_OBJECT_CONTROL* pControl;
    DWORD dwControlLen;
    int nRes = SharedMem.MapExisting(v.GetLPWSTR(), (void**)&pControl,
                                        &dwControlLen);
    if(nRes == CWbemSharedMem::NotFound)
    {
        // No mapping currently exists
        // ===========================

        dwControlLen = sizeof(SHARED_OBJECT_CONTROL);
        nRes = SharedMem.MapNew(v.GetLPWSTR(), dwControlLen, (void**)&pControl);
        if(nRes != CWbemSharedMem::NoError)
        {
            SharedMem.UnlockMmf();
            Unlock(0);
            return WBEM_E_FAILED;
        }

        pControl->m_LockData.Init();
        pControl->m_hObjectBlob.m_dwBlock = 0;
        pControl->m_hObjectBlob.m_dwOffset = 0;
        pControl->m_lBlobLength = 0;
    }
    else if(nRes != CWbemSharedMem::NoError)
    {
        // Real problem here
        // =================

        SharedMem.UnlockMmf();
        Unlock(0);
        return WBEM_E_FAILED;
    }

    // We have our control. Create the object on it
    // ============================================

    CSharedBlobControl* pBlobControl = new CSharedBlobControl(pControl);

    if ( NULL == pBlobControl )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Extend the memory to the appropriate length
    // ===========================================

    LPVOID pvBlob = SharedMem.GetPointer(pControl->m_hObjectBlob.m_dwBlock,
                        pControl->m_hObjectBlob.m_dwOffset);

    pvBlob = pBlobControl->Reallocate((LPMEMORY)pvBlob, pControl->m_lBlobLength,
                            GetBlockLength());
    if(FAILED(hres) || NULL == pvBlob )
    {
        SharedMem.UnlockMmf();
        Unlock(0);
        return WBEM_E_FAILED;
    }

    // Lock it
    // =======

    CSharedLock Lock;
    Lock.SetData(&pControl->m_LockData);
    Lock.Lock();

    // Switch the locks
    // ================

    m_Lock.SetData(&pControl->m_LockData);

    // Copy the data over
    // ==================

    memcpy(pvBlob, GetStart(), GetBlockLength());

    // Switch the blobs
    // ================

    m_pBlobControl = pBlobControl;
    SetData((LPMEMORY)pvBlob, GetBlockLength());

    // Unlock both locks (internal is not used anymore)
    // ================================================

    Lock.SetData(&m_LockData);
    Lock.Unlock();

    SharedMem.UnlockMmf();
    m_Lock.Unlock();

    return WBEM_S_NO_ERROR;
}

*/

/*

LPMEMORY CSharedBlobControl::Allocate( int nLength )
{
	return NULL;
}

LPMEMORY CSharedBlobControl::Reallocate(LPMEMORY pOld, int nOldLength,
                                   int nNewLength)
{
    if(nNewLength <= nOldLength)
        return pOld;

    CWbemSharedMem& SharedMem = CWbemObject::GetSharedMemory();
    int nRes;

    CSharedLock Lock;
    Lock.SetData(&m_pControl->m_LockData);
    Lock.Lock();

    SHMEM_HANDLE hNewBlob;
    nRes = SharedMem.AllocateBlock(nNewLength,
                        &hNewBlob.m_dwBlock, &hNewBlob.m_dwOffset);

    LPMEMORY pNew = (LPMEMORY)SharedMem.GetPointer(
                        hNewBlob.m_dwBlock,
                        hNewBlob.m_dwOffset);

	if ( NULL == pNew )
	{
	    Lock.Unlock();
        return NULL;
	}

    memcpy(pNew, pOld, nOldLength);

    if(nOldLength > 0)
    {
        SharedMem.FreeBlock(m_pControl->m_hObjectBlob.m_dwBlock,
                        m_pControl->m_hObjectBlob.m_dwOffset);
    }

    m_pControl->m_hObjectBlob = hNewBlob;
    m_pControl->m_lBlobLength = nNewLength;
    Lock.Unlock();
    return pNew;
}

void CSharedBlobControl::Delete(LPMEMORY pOld)
{
    CSharedLock Lock;
    Lock.SetData(&m_pControl->m_LockData);
    Lock.Lock();

    CWbemSharedMem& SharedMem = CWbemObject::GetSharedMemory();

    if(m_pControl->m_hObjectBlob.m_dwBlock ||
        m_pControl->m_hObjectBlob.m_dwOffset)
    {
        SharedMem.FreeBlock(m_pControl->m_hObjectBlob.m_dwBlock,
                        m_pControl->m_hObjectBlob.m_dwOffset);
    }

    m_pControl->m_hObjectBlob.m_dwBlock = 0;
    m_pControl->m_hObjectBlob.m_dwOffset = 0;
    Lock.Unlock();
}

CWbemSharedMem& CWbemObject::GetSharedMemory()
{
    return mstatic_SharedMem;
}

*/

BOOL CWbemObject::AreEqual(CWbemObject* pObj1, CWbemObject* pObj2,
                            long lFlags)
{
    if(pObj1 == NULL)
    {
        if(pObj2 != NULL) return FALSE;
        else return TRUE;
    }
    else if(pObj2 == NULL) return FALSE;
    else
    {
        return (pObj1->CompareTo(lFlags, pObj2) == S_OK);
    }
}

HRESULT CWbemObject::GetPropertyIndex(LPCWSTR wszName, int* pnIndex)
{
    int nSysIndex = CSystemProperties::FindName(wszName);
    if(nSysIndex > 0)
    {
        *pnIndex = -nSysIndex;
        return S_OK;
    }

    CPropertyInformation* pInfo = GetClassPart()->FindPropertyInfo(wszName);
    if(pInfo == NULL)
        return WBEM_E_NOT_FOUND;

    *pnIndex = pInfo->nDataIndex;
    return S_OK;
}

HRESULT CWbemObject::GetPropertyNameFromIndex(int nIndex, BSTR* pstrName)
{
    // Check for out of memory
    try
    {
        if(nIndex < 0)
        {
            *pstrName = CSystemProperties::GetNameAsBSTR(-nIndex);
            return S_OK;
        }

        CClassPart& ClassPart = *GetClassPart();
        CPropertyLookup* pLookup =
            ClassPart.m_Properties.GetAt(nIndex);

        *pstrName = ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                        CreateBSTRCopy();

        // Check for allocation failures
        if ( NULL == *pstrName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return S_OK;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

STDMETHODIMP CWbemObject::SetServerNamespace(LPCWSTR wszServer,
                                            LPCWSTR wszNamespace)
{
    // Memory testing done underneath
    return Decorate(wszServer, wszNamespace);
}

// DEVNOTE:TODO:MEMORY - We should change this header to return an HRESULT
BOOL CWbemObject::ValidateRange(BSTR* pstrName)
{
    HRESULT hr = GetClassPart()->m_Properties.ValidateRange(pstrName,
                                                        &m_refDataTable,
                                                        &m_refDataHeap);

    // Interpret return.  We are successful, if nothing failed and the
    // return is not WBEM_S_FALSE.

    if ( SUCCEEDED( hr ) )
    {
        return WBEM_S_FALSE != hr;
    }

    return FALSE;
}

BOOL CWbemObject::IsSameClass(CWbemObject* pOther)
{
    if(GetClassPart()->GetLength() != pOther->GetClassPart()->GetLength())
        return FALSE;

    return (memcmp(GetClassPart()->GetStart(),
                    pOther->GetClassPart()->GetStart(),
                    GetClassPart()->GetLength()) == 0);
}

HRESULT CWbemObject::ValidatePath(ParsedObjectPath* pPath)
{
    CClassPart* pClassPart = GetClassPart();

    // Make sure singleton-ness holds
    // ==============================

    if((pPath->m_bSingletonObj != FALSE) !=
        (pClassPart->IsSingleton() != FALSE))
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    // Make sure that all the properties mentioned are keys
    // ====================================================

    int i;
    for(i = 0; i < (int)pPath->m_dwNumKeys; i++)
    {
        LPCWSTR wszName = pPath->m_paKeys[i]->m_pName;
        if(wszName)
        {
            CVar vKey;
            CPropertyInformation* pInfo = pClassPart->FindPropertyInfo(wszName);
            if(pInfo == NULL)
                return WBEM_E_INVALID_OBJECT_PATH;
            if(FAILED(pClassPart->GetPropQualifier(pInfo, L"key", &vKey)))
                return WBEM_E_INVALID_OBJECT_PATH;
            if(vKey.GetType() != VT_BOOL || !vKey.GetBool())
                return WBEM_E_INVALID_OBJECT_PATH;
        }
    }

    // Make sure all the keys are listed
    // =================================

    CPropertyLookupTable& Properties = pClassPart->m_Properties;
    CFastHeap& Heap = pClassPart->m_Heap;

    DWORD dwNumKeys = 0;
    for (i = 0; i < Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = Properties.GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(&Heap);

        // Determine if this property is marked with a 'key' Qualifier.
        // ============================================================

        if(pInfo->IsKey())
            dwNumKeys++;
    }

    if(dwNumKeys != pPath->m_dwNumKeys)
        return WBEM_E_INVALID_OBJECT_PATH;

    return WBEM_S_NO_ERROR;
}

/*
#ifdef DEBUG
// Direct to the appropriate call
HRESULT CWbemObject::ValidateObject( CWbemObject* pObj )
{
    if ( g_bObjectValidation )
    {
        return CWbemObject::EnabledValidateObject( pObj );
    }
    else
    {
        return CWbemObject::DisabledValidateObject( pObj );
    }
}
#endif
*/

// This does something
HRESULT CWbemObject::EnabledValidateObject( CWbemObject* pObj )
{
    return pObj->IsValidObj();
}

// This doesn't
HRESULT CWbemObject::DisabledValidateObject( CWbemObject* pObj )
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemObject::CompareClassParts( IWbemClassObject* pObj, long lFlags )
{
    if ( NULL == pObj )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // Checking the BLOB
        CLock lock1(this);
        CLock lock2((CWbemObject*) pObj);

        CClassPart* pThisClassPart = GetClassPart();
        CClassPart* pThatClassPart = ((CWbemObject*) pObj)->GetClassPart();

        if ( NULL == pThisClassPart || NULL == pThatClassPart )
        {
            return WBEM_E_FAILED;
        }

        BOOL    fMatch = FALSE;

        if ( WBEM_FLAG_COMPARE_BINARY == lFlags )
        {
            fMatch = pThisClassPart->IsIdenticalWith( *pThatClassPart );
        }
        else if ( WBEM_FLAG_COMPARE_LOCALIZED == lFlags )
        {
            BOOL    fLocalized = ( WBEM_FLAG_COMPARE_LOCALIZED == lFlags );
            EReconciliation e = pThisClassPart->CompareExactMatch( *pThatClassPart, fLocalized );

            if ( e_OutOfMemory == e )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            fMatch = ( e_ExactMatch == e );
        }

        return ( fMatch ? WBEM_S_SAME : WBEM_S_FALSE );
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// We will throw exceptions in OOM scenarios.

length_t CWbemObject::Unmerge(LPMEMORY* ppStart)
{
    int nLen = EstimateUnmergeSpace();
    length_t    nUnmergedLength = 0L;   // this should be passed in

    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    // Unmerging uses memcpy and is for storing outside, so don't worry about
    // alinging this guy.
    *ppStart = new BYTE[nLen];

    if ( NULL != *ppStart )
    {
        memset(*ppStart, 0, nLen);
        hr = Unmerge(*ppStart, nLen, &nUnmergedLength);

        if ( FAILED( hr ) )
        {
            delete[] *ppStart;
            *ppStart = NULL;

            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                throw CX_MemoryException();
            }
        }
    }
    else
    {
        throw CX_MemoryException();
    }

    return nUnmergedLength;

}

/* New _IWmiObject implementations. */

STDMETHODIMP CWbemObject::GetPropertyHandleEx( LPCWSTR wszPropertyName,
											long lFlags,
                                            CIMTYPE* pct,
                                            long* plHandle )
{
	try
	{
		// Check flags
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Allocation Exceptions handled underneath
		return GetClassPart()->GetPropertyHandleEx(wszPropertyName, pct, plHandle);
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Sets properties using a handle.  If pvData is NULL, it NULLs the property.
// Can set an array to NULL.  To set actual data use the corresponding array
// function.  Objects require a pointer to an _IWmiObject pointer.  Strings
// are pointers to a NULL terminated WCHAR.
STDMETHODIMP CWbemObject::SetPropByHandle( long lHandle, long lFlags, ULONG uDataSize, LPVOID pvData )
{
	try
	{
		// Check flags
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		HRESULT	hr = WBEM_S_NO_ERROR;

		int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

		// If pvData is NULL, then we will NULL out the value

		if ( NULL == pvData )
		{
			// Special case reserved handling
			if ( WBEM_OBJACCESS_HANDLE_ISRESERVED(lHandle) )
			{
				// No reserved can be set to NULL.
				return WBEM_E_ILLEGAL_OPERATION;
			}	// IF Reserved

			// If it's a pointer, make sure it's not an array
			if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
			{
				// Point to the proper heap and datatable
				CFastHeap*	pHeap = &m_refDataHeap;
				CDataTable*	pDataTable = &m_refDataTable;

				// Oops!  Get them from the class part
				if ( m_refDataTable.IsDefault( nIndex ) )
				{
					pHeap = GetClassPart()->GetHeap();
					pDataTable = GetClassPart()->GetDataTable();
				}

				// Now get the heapptr
				heapptr_t ptrData = *(PHEAPPTRT)(pDataTable->m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));

				if ( WBEM_OBJACCESS_HANDLE_ISARRAY(lHandle) )
				{
					CUntypedArray*	pArray = (CUntypedArray*) pHeap->ResolveHeapPointer( ptrData );
					pHeap->Free( ptrData, pArray->GetLengthByActualLength( WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle) ) );
				}
				else if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
				{
					pHeap->FreeString( ptrData );
				}
				else
				{
					CEmbeddedObject* pObj = (CEmbeddedObject*) pHeap->ResolveHeapPointer( ptrData );
					pHeap->Free( ptrData, pObj->GetLength() );
				}

			}	// IF IsPointer

			// Set the NULLness and Defaultness bits

			if ( SUCCEEDED( hr ) )
			{
				m_refDataTable.SetNullness( nIndex, TRUE );
				m_refDataTable.SetDefaultness( nIndex, FALSE );
			}

		}
		else	// We're actually setting some data (or so we hope)
		{
			// Whether or not we will allow the previous pointer to
			// be reused.
			BOOL bUseOld = FALSE;

			// We're actually setting the value here.
			// Ignore arrays and reserved handles
			if ( !WBEM_OBJACCESS_HANDLE_ISRESERVED(lHandle) )
			{
				bUseOld = !m_refDataTable.IsDefault(nIndex) &&
							!m_refDataTable.IsNull(nIndex);

				if ( !WBEM_OBJACCESS_HANDLE_ISARRAY(lHandle) )
				{
					m_refDataTable.SetNullness(nIndex, FALSE);
					m_refDataTable.SetDefaultness(nIndex, FALSE);
				}
			}

			if (WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
			{
				BOOL	fReserved = FALSE;

				// Look for property info only if we need to.
				if ( FASTOBJ_CLASSNAME_PROP_HANDLE == lHandle )
				{
					fReserved = TRUE;
				}
				else if ( FASTOBJ_SUPERCLASSNAME_PROP_HANDLE == lHandle )
				{
					// Don't allow setting the superclass name just yet.
					hr = WBEM_E_INVALID_OPERATION;
				}

				if ( SUCCEEDED( hr ) )
				{
					if ( fReserved || !WBEM_OBJACCESS_HANDLE_ISARRAY(lHandle) )
					{
						CIMTYPE	ctBasic = CIM_OBJECT;

						if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
						{
							LPCWSTR wszData = (LPCWSTR) pvData;

							// The number of bytes must be divisible by 2, >= 2 and
							// the character in the buffer at the end must be a NULL.
							// This will be faster than doing an lstrlen.

							if (    ( uDataSize < 2 ) ||
									( uDataSize % 2 ) ||
									( wszData[uDataSize/2 - 1] != 0 ) )
							{
								return WBEM_E_INVALID_PARAMETER;
							}

							ctBasic = CIM_STRING;
						}

						if ( SUCCEEDED( hr ) )
						{
							CVar var;

							// Fill the CVar properly

							hr = CUntypedValue::FillCVarFromUserBuffer(ctBasic, &var,
																		uDataSize,
																		pvData );


							if ( SUCCEEDED( hr ) )
							{
								// Uses the appropriate method to do this
								if ( FASTOBJ_CLASSNAME_PROP_HANDLE == lHandle )
								{
									hr = GetClassPart()->SetClassName( &var );
								}
								else
								{
									int nOffset = (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle));
									// Create a value pointing to the right offset in the data table
									// =============================================================

									CDataTablePtr ValuePtr(&m_refDataTable, nOffset);
									
									// Check for possible memory allocation failures
									Type_t  nReturnType;

									hr = CUntypedValue::LoadFromCVar( &ValuePtr, var, CType::GetVARTYPE(ctBasic),
																	&m_refDataHeap,	nReturnType, bUseOld );

									if ( CIM_ILLEGAL == nReturnType )
									{
										hr = WBEM_E_TYPE_MISMATCH;
									}
								}


							}	// IF Filled the CVar

						}	// IF we're good to go

					}	// IF not an array
					else
					{
						hr = WBEM_E_INVALID_OPERATION;
					}

				}	// If got CIMTYPE
			}
			else
			{

				if ( uDataSize != WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle) )
				{
					return WBEM_E_INVALID_PARAMETER;
				}

				// Just copy
				// =========

				memcpy((void*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))),
						pvData, WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle));
			}
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Retrieves direct pointer into V1 BLOB.  Does not do so for strings, arrays or embedded objects
STDMETHODIMP CWbemObject::GetPropAddrByHandle( long lHandle, long lFlags, ULONG* puFlags, LPVOID *pAddress )
{
	try
	{
		// Check flags
		if ( lFlags & ~WMIOBJECT_FLAG_ENCODING_V1 )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		HRESULT	hr = WBEM_S_NO_ERROR;

		// No intrinsic lock/unlock here.

		int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
		if( !WBEM_OBJACCESS_HANDLE_ISRESERVED(lHandle) && m_refDataTable.IsNull(nIndex) )
		{
			*pAddress = 0;
			return WBEM_S_FALSE;
		}

		// If it's a pointer, make sure it's not an array
		if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
		{
			// Remember that a reserved flag will have all the mutually
			// exclusive stuff set
			if ( WBEM_OBJACCESS_HANDLE_ISARRAY(lHandle) &&
				!WBEM_OBJACCESS_HANDLE_ISRESERVED(lHandle) )
			{
				hr = WBEM_E_INVALID_OPERATION;
			}
			else
			{
				// If it's a string, we should treat it as such
				if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
				{
					CCompressedString*	pcs;
					
					// Gets the appropriate compressed string pointer
					if ( FASTOBJ_CLASSNAME_PROP_HANDLE == lHandle )
					{
						pcs = GetClassPart()->GetClassName();
					}
					else if ( FASTOBJ_SUPERCLASSNAME_PROP_HANDLE == lHandle )
					{
						pcs = GetClassPart()->GetSuperclassName();
					}
					else
					{
						pcs = GetPropertyString( lHandle );
					}

					// Load up the values now.
					if ( NULL != pcs )
					{
						// If the v1 Encoding flag is set, the user says they know what they're doing
						// so let 'em have the raw pointer
						if ( lFlags & WMIOBJECT_FLAG_ENCODING_V1 )
						{
							*pAddress = pcs;
						}
						else
						{
							*puFlags = *( pcs->GetStart() );
							*pAddress = pcs->GetRawData();
						}
					}
					else
					{
						hr = WBEM_S_FALSE;
					}

				}
				else if ( WBEM_OBJACCESS_HANDLE_ISOBJECT(lHandle) )
				{
					CWbemObject*	pObj = GetEmbeddedObj( lHandle );

					if ( NULL != pObj )
					{
						// Just return the pointer
						*pAddress = (PVOID) pObj;
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}

			}	// Else its not an array

		}	// IF IsPointer
		else
		{
				// Check if it's a default
			if(m_refDataTable.IsDefault(nIndex))
			{
				return GetClassPart()->GetDefaultPtrByHandle( lHandle, pAddress );
			}

			// Just save the memory address
			// =========

			*pAddress = (void*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
		}	// IF we should get the property

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CWbemObject::IsArrayPropertyHandle( long lHandle, CIMTYPE* pctIntrinisic, length_t* pnLength )
{
	try
	{
		HRESULT	hr = WBEM_S_NO_ERROR;

		if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
		{
			if ( WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle) )
			{
				// Get the basic type
				if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
				{
					*pctIntrinisic = CIM_STRING;
				}
				else if ( WBEM_OBJACCESS_HANDLE_ISOBJECT(lHandle) )
				{
					*pctIntrinisic = CIM_OBJECT;
				}
				else
				{
					*pctIntrinisic = CIM_ILLEGAL;
				}
				
				// Retrieve the intrinsic type length (it'll be ignored for
				// the above two anyway).
				*pnLength = WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle);
			}
			else
			{
				hr = WBEM_E_INVALID_OPERATION;

			}

		}
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Retrieves direct pointer into V1 BLOB.  Does not do so for strings, arrays or embedded objects
STDMETHODIMP CWbemObject::GetArrayPropAddrByHandle( long lHandle, long lFlags, ULONG* puNumElements, LPVOID* pAddress )
{
	try
	{
		// Check flags
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// No intrinsic lock/unlock here.

		int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
		if(m_refDataTable.IsNull(nIndex))
		{
			*pAddress = 0;
			return WBEM_S_FALSE;
		}

		CIMTYPE		ct = 0;
		length_t	nLength;
		HRESULT	hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

		// It must be a pointer and non-string/object
		// We may decide to chop this if it's taking too
		// many cycles.

		if( SUCCEEDED( hr ) )
		{
			// No strings, objects or Date_Time
			if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) || 
				WBEM_OBJACCESS_HANDLE_ISOBJECT(lHandle) )
			{
				hr = WBEM_E_INVALID_OPERATION;
			}

		}	// IF IsPointer

		if ( SUCCEEDED( hr ) )
		{
			CUntypedArray*	pArray = GetArrayByHandle( lHandle );

			if ( NULL != pArray )
			{
				// Get the number of elements and a pointer to the first byte
				*puNumElements = pArray->GetNumElements();
				*pAddress = pArray->GetElement( 0, 1 );
			}
			else
			{
				hr = WBEM_S_FALSE;
			}


		}	// IF we should get the property

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Retrieves direct pointer into V1 BLOB.  Since it does double indirection, we handle strings
// and objects here as well.
STDMETHODIMP CWbemObject::GetArrayPropInfoByHandle( long lHandle, long lFlags, BSTR* pstrName,
										CIMTYPE* pct, ULONG* puNumElements )
{
	try
	{
		// Check flags
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// No intrinsic lock/unlock here.

		// Make sure this is an array proprty
		CIMTYPE		ct = 0;
		length_t	nLength;
		HRESULT	hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

		if ( SUCCEEDED( hr ) )
		{
			hr = GetPropertyInfoByHandle( lHandle, pstrName, pct );

			if ( SUCCEEDED(hr) )
			{
				int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
				if(!m_refDataTable.IsNull(nIndex))
				{
					// Grab the array, then point to the required element
					CUntypedArray*	pArray = GetArrayByHandle( lHandle );

					if ( NULL != pArray )
					{
						// Get the number of elements and a pointer to the first byte
						*puNumElements = pArray->GetNumElements();

					}
					else
					{
						hr = WBEM_S_FALSE;
					}
				}
				else
				{
					*puNumElements = 0;
				}

			}	// If we got basic property info


		}	// IF we should get the property

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Retrieves direct pointer into V1 BLOB.  Since it does double indirection, we handle strings
// and objects here as well.
STDMETHODIMP CWbemObject::GetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement,
													ULONG* puFlags,	ULONG* puNumElements, LPVOID *pAddress )
{
	try
	{
		// Check flags
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// No intrinsic lock/unlock here.

		int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
		if(m_refDataTable.IsNull(nIndex))
		{
			*pAddress = 0;
			return WBEM_S_FALSE;
		}

		// Make sure this is an array proprty
		CIMTYPE		ct = 0;
		length_t	nLength;
		HRESULT	hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

		if ( SUCCEEDED( hr ) )
		{
			// Grab the array, then point to the required element
			CUntypedArray*	pArray = GetArrayByHandle( lHandle );

			if ( NULL != pArray )
			{
				// Get the number of elements and a pointer to the first byte
				*puNumElements = pArray->GetNumElements();

				// Check that we're requesting a valid element
				if ( *puNumElements > uElement )
				{

					// Point to the memory - Get the actual Length, since the length in the
					// handle will be wrong
					LPMEMORY pbData = pArray->GetElement( uElement, WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle) );

					// If it's a string or object, we need to further dereference
					if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
					{
						// Make sure we dereference from the proper heap
						CCompressedString* pcs = NULL;

						if ( m_refDataTable.IsDefault( nIndex ) )
						{
							pcs = GetClassPart()->ResolveHeapString( *((PHEAPPTRT) pbData ) );
						}
						else
						{
							pcs = m_refDataHeap.ResolveString( *((PHEAPPTRT) pbData ) );
						}

						// Load up the values now.
						if ( NULL != pcs )
						{
							*puFlags = *( pcs->GetStart() );
							*pAddress = pcs->GetRawData();
						}
						else
						{
							hr = WBEM_S_FALSE;
						}

					}
					else if ( WBEM_OBJACCESS_HANDLE_ISOBJECT(lHandle) )
					{
						CEmbeddedObject* pEmbedding = NULL;

						// Make sure we dereference from the proper heap
						if ( m_refDataTable.IsDefault( nIndex ) )
						{
							GetClassPart()->GetDefaultPtrByHandle( lHandle, (void**) &pEmbedding );
						}
						else
						{

							pEmbedding =
								(CEmbeddedObject*)m_refDataHeap.ResolveHeapPointer(
									*(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
						}

						// Load up the values now.
						if ( NULL != pEmbedding )
						{
							CWbemObject*	pObj = pEmbedding->GetEmbedded();

							if ( NULL != pObj )
							{
								*pAddress = (LPVOID) pObj;
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}
						}
						else
						{
							hr = WBEM_S_FALSE;
						}

					}
					else
					{
						// We're pointing at the element
						*pAddress = pbData;
					}

				}	// IF requesting a valid element
				else
				{
					hr = WBEM_E_NOT_FOUND;
				}
			}
			else
			{
				hr = WBEM_S_FALSE;
			}


		}	// IF we should get the property

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Gets a range of elements from inside an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
// of the current array.
STDMETHODIMP CWbemObject::GetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
								ULONG uNumElements, ULONG uBuffSize, ULONG* pulBuffUsed,
								ULONG* puNumReturned, LPVOID pData )
{
	try
	{
		// Check for invalid flags
		if ( ( lFlags & ~WMIARRAY_FLAG_ALLELEMENTS ) )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// No intrinsic lock/unlock here.

		int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

		// We can't do this if the main data table is NULL or we are defaulted and
		// the parent datatable is also NULL.
		if( m_refDataTable.IsNull(nIndex) ||
			( m_refDataTable.IsNull(nIndex) && GetClassPart()->GetDataTable()->IsNull( nIndex ) ) )
		{
			return WBEM_E_INVALID_OPERATION;
		}

		// Make sure this is an array proprty
		CIMTYPE		ct = 0;
		length_t	nLength;
		HRESULT	hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

		if ( SUCCEEDED( hr ) )
		{
			// Get a direct heap pointer
			heapptr_t	ptrArray = GetHeapPtrByHandle( lHandle );

			// Point to the proper heap
			CFastHeap*	pHeap = ( m_refDataTable.IsDefault( nIndex ) ?
									GetClassPart()->GetHeap() : &m_refDataHeap );

			// A boy and his virtual functions.  This is what makes everything work in case
			// the BLOB gets ripped out from underneath us.  The CHeapPtr class has GetPointer
			// overloaded so we can always fix ourselves up to the underlying BLOB.

			CHeapPtr ArrayPtr(pHeap, ptrArray);

			// If we're told to get all elements, then we need to get them from the
			// starting index to the end
			if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
			{
				CUntypedArray*	pArray = (CUntypedArray*) ArrayPtr.GetPointer();
				uNumElements = pArray->GetNumElements() - uStartIndex;
			}

			// How many will we get?
			*puNumReturned = uNumElements;

			hr = CUntypedArray::GetRange( &ArrayPtr, ct, nLength, pHeap, uStartIndex, uNumElements, uBuffSize,
					pulBuffUsed, pData );

		}	// IF we decided we're really going to do this


		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Sets the data at the specified array element.  BuffSize must be appropriate based on the
// actual element being set.  Object properties require a pointer to an _IWmiObject pointer.
// Strings must be WCHAR null-terminated
STDMETHODIMP CWbemObject::SetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement,
														ULONG uBuffSize, LPVOID pData )
{
	return SetArrayPropRangeByHandle( lHandle, lFlags, uElement, 1, uBuffSize, pData );
}

// Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
// array
STDMETHODIMP CWbemObject::SetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
													ULONG uNumElements, ULONG uBuffSize, LPVOID pData )
{
	try
	{
		// Check flags
		if ( lFlags & ~WMIARRAY_FLAG_ALLELEMENTS )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// No intrinsic lock/unlock here.

		int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

		// This will dictate how we handle the array later
		BOOL	fNullOrDefault = m_refDataTable.IsNull(nIndex) || 
									m_refDataTable.IsDefault(nIndex);

		// Only handle NULL or default if we are setting all elements
		if( fNullOrDefault && ! (lFlags & WMIARRAY_FLAG_ALLELEMENTS) )
		{
			return WBEM_E_INVALID_OPERATION;
		}

		// Make sure this is an array proprty
		CIMTYPE		ct = 0;
		length_t	nLength;
		HRESULT	hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

		if ( SUCCEEDED( hr ) )
		{
			// We always set in only the main data table, and not the one from the
			// class part.

			CFastHeap*	pHeap = &m_refDataHeap;
			CDataTable*	pDataTable = &m_refDataTable;

			// If the array is reallocated, fixup will occur here through
			// the magic of virtual functions.
			CDataTablePtr	DataTablePtr( pDataTable, WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle) );

			// Make sure that if the value is NULL or default, we have an invalid heap ptr at the address
			// or we can cause potential problems by writing to the wrong location.
			if( fNullOrDefault )
			{
				DataTablePtr.AccessPtrData() = INVALID_HEAP_ADDRESS;
			}

			hr = CUntypedArray::SetRange( &DataTablePtr, lFlags, ct, nLength, pHeap, uStartIndex,
										uNumElements, uBuffSize, pData );

			if ( SUCCEEDED(hr) )
			{
				// We always set the array, so we're basically no longer NULL at this
				// point.  If the user sets a zero element range, we are a zero element array
				m_refDataTable.SetNullness( nIndex, FALSE );
				m_refDataTable.SetDefaultness( nIndex, FALSE );
			}

		}	// IF we decided we're really going to do this


		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Removes a single elements from an array.
STDMETHODIMP CWbemObject::RemoveArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement )
{
	return RemoveArrayPropRangeByHandle( lHandle, lFlags, uElement, 1 );
}

// Removes a range of elements from an array.  The range MUST fit within the bounds
// of the current array
STDMETHODIMP CWbemObject::RemoveArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
														ULONG uNumElements )
{
	try
	{
		// Check flags
		if ( lFlags & ~WMIARRAY_FLAG_ALLELEMENTS )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// No intrinsic lock/unlock here.

		int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

		// We can't write to an array that doesn't exist in the main datatable
		if(m_refDataTable.IsNull(nIndex) || m_refDataTable.IsDefault(nIndex))
		{
			return WBEM_E_INVALID_OPERATION;
		}

		// Make sure this is an array proprty
		CIMTYPE		ct = 0;
		length_t	nLength;
		HRESULT	hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

		if ( SUCCEEDED( hr ) )
		{
			// Get a direct heap pointer
			heapptr_t	ptrArray = GetHeapPtrByHandle( lHandle );

			// Point to the proper heap
			CFastHeap*	pHeap = &m_refDataHeap;

			// A boy and his virtual functions.  This is what makes everything work in case
			// the BLOB gets ripped out from underneath us.  The CHeapPtr class has GetPointer
			// overloaded so we can always fix ourselves up to the underlying BLOB.

			CHeapPtr ArrayPtr(pHeap, ptrArray);

			// If we're told to remove all elements, then we need to figure out how
			// many to perform this operation on.
			if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
			{
				CUntypedArray*	pArray = (CUntypedArray*) ArrayPtr.GetPointer();
				uNumElements = pArray->GetNumElements() - uStartIndex;
			}


			hr = CUntypedArray::RemoveRange( &ArrayPtr, ct, nLength, pHeap, uStartIndex, uNumElements );

		}	// IF we decided we're really going to do this


		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Appends a range of elements to an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
// of the current array
STDMETHODIMP CWbemObject::AppendArrayPropRangeByHandle( long lHandle, long lFlags,	ULONG uNumElements,
													   ULONG uBuffSize, LPVOID pData )
{
	try
	{
		// Check flags
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// No intrinsic lock/unlock here.

		int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

		// Make sure this is an array proprty
		CIMTYPE		ct = 0;
		length_t	nLength;
		HRESULT	hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

		if ( SUCCEEDED( hr ) )
		{
			// We always set in only the main data table, and not the one from the
			// class part.

			CFastHeap*	pHeap = &m_refDataHeap;
			CDataTable*	pDataTable = &m_refDataTable;

			// If the array is reallocated, fixup will occur here through
			// the magic of virtual functions.
			CDataTablePtr	DataTablePtr( pDataTable, WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle) );

			// Make sure that if the value is NULL or default, we have an invalid heap ptr at the address
			// or we can cause potential problems by writing to the wrong location.
			if( m_refDataTable.IsDefault( nIndex ) || m_refDataTable.IsNull( nIndex ) )
			{
				DataTablePtr.AccessPtrData() = INVALID_HEAP_ADDRESS;
			}

			hr = CUntypedArray::AppendRange( &DataTablePtr, ct, nLength, pHeap,
											uNumElements, uBuffSize, pData );

			if ( SUCCEEDED(hr) )
			{
				// We always set the array, so we're basically no longer NULL at this
				// point.  If the user appends 0 elements, this is now a 0 element
				// array/
				m_refDataTable.SetNullness( nIndex, FALSE );
				m_refDataTable.SetDefaultness( nIndex, FALSE );
			}

		}	// IF we decided we're really going to do this


		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Removes a range of elements from an array.  The range MUST fit within the bounds
// of the current array
STDMETHODIMP CWbemObject::ReadProp( LPCWSTR pszPropName, long lFlags, ULONG uBuffSize, CIMTYPE *puCimType,
									long* plFlavor, BOOL* pfIsNull, ULONG* puBuffSizeUsed, LPVOID pUserBuff )
{
	try
	{
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		// If the value starts with an underscore see if it's a System Property
		// DisplayName, and if so, switch to a property name - otherwise, this
		// will just return the string we passed in
		
		//pszPropName = CSystemProperties::GetExtPropName( pszPropName );

		// Always get the CIMTYPE, since we'll need this to deal with the
		// fact that this may be an array property
		CIMTYPE	ct;
		HRESULT	hr = GetPropertyType( pszPropName, &ct, plFlavor );

		if ( SUCCEEDED( hr ) )
		{
			// Store the cimtype if it was requested
			if ( NULL != puCimType )
			{
				*puCimType = ct;
			}

			if ( SUCCEEDED( hr ) )
			{
				if ( CType::IsArray( ct ) )
				{
					// We'll still return an array pointer for NULL array properties.

					// We'll need this many bytes to do our dirty work.
					*puBuffSizeUsed = sizeof( _IWmiArray*);

					if ( uBuffSize >= sizeof( _IWmiArray*) && NULL != pUserBuff )
					{
						// Allocate an array object, initialize it and QI for the
						// appropriate object
						CWmiArray*	pArray = new CWmiArray;

						if ( NULL != pArray )
						{
							hr = pArray->InitializePropertyArray( this, pszPropName );

							if ( SUCCEEDED( hr ) )
							{
								// We want to QI into the memory pointed at by pUserBuff
								hr = pArray->QueryInterface( IID__IWmiArray, (LPVOID*) pUserBuff );
							}
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}
					else
					{
						hr = WBEM_E_BUFFER_TOO_SMALL;
					}
				}
				else
				{
					CIMTYPE	ctBasic = CType::GetBasic( ct );
					CVar	var;

					hr = GetProperty( pszPropName, &var );

					if ( SUCCEEDED( hr ) )
					{

						*pfIsNull = var.IsNull();

						if ( !*pfIsNull )
						{
							hr = CUntypedValue::LoadUserBuffFromCVar( ctBasic, &var, uBuffSize, puBuffSizeUsed,
									pUserBuff );
						}

					}	// IF GetProperty

				}	// IF a non-array property.

			}	// IF is NULL

		}	// IF we got basic info

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Assumes caller knows prop type; Supports all CIMTYPES.
// Strings MUST be null-terminated wchar_t arrays.
// Objects are passed in as pointers to _IWmiObject pointers
// Using a NULL buffer will set the property to NULL
// Array properties must conform to array guidelines.  Will
// completely blow away an old array.
STDMETHODIMP CWbemObject::WriteProp( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
									CIMTYPE uCimType, LPVOID pUserBuf )
{
	try
	{
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		CVar	var;
		
		HRESULT	hr = WBEM_S_NO_ERROR;

		// IF this is an array, we will dump it out, and then set the range using
		// the appropriate method.
		if ( CType::IsArray( uCimType ) )
		{
			// First, we'll set as a NULL property.  If it already exists, this will dump the
			// property.
			var.SetAsNull();

			// Now just set the property
			hr = SetPropValue( pszPropName, &var, uCimType );

			// If the User Buffer is NULL, then we just did our job
			if ( SUCCEEDED( hr ) && NULL != pUserBuf )
			{
				long	lHandle = 0L;

				// Get the handle, then set the array
				hr = GetPropertyHandleEx( pszPropName, lFlags, NULL, &lHandle );

				if ( SUCCEEDED( hr ) )
				{
					hr = SetArrayPropRangeByHandle( lHandle, WMIARRAY_FLAG_ALLELEMENTS, 0L, uNumElements,
													uBufSize, pUserBuf );
				}

			}	// IF NULLed out array

		}
		else
		{
			hr = CUntypedValue::FillCVarFromUserBuffer( uCimType, &var, uBufSize, pUserBuf );

			if ( SUCCEEDED( hr ) )
			{
				// Now just set the property
				hr = SetPropValue( pszPropName, &var, uCimType );
			}
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings are copied in-place and null-terminated.
// Arrays come out as a pointer to IWmiArray
STDMETHODIMP CWbemObject::GetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, CIMTYPE *puCimType,
									ULONG *puQualFlavor, ULONG* puBuffSizeUsed,	LPVOID pDestBuf )
{
	try
	{
		CIMTYPE	ct = 0;

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		//	First, get the type, if it's an array, we need to gin up an _IWmiArray pointer.
		//	We don't want the Var this time, since that may get hung up in an array
		HRESULT hr = GetQualifier( pszQualName, NULL, (long*) puQualFlavor, &ct );

		if ( SUCCEEDED( hr ) )
		{
			// Save the CIMTYPE as appropriate
			if ( NULL != puCimType )
			{
				*puCimType = ct;
			}

			if ( CType::IsArray( ct ) )
			{
				// We'll need this many bytes to do our dirty work.
				*puBuffSizeUsed = sizeof( _IWmiArray*);

				if ( uBufSize >= sizeof( _IWmiArray*) && NULL != pDestBuf )
				{
					// Allocate an array object, initialize it and QI for the
					// appropriate object
					CWmiArray*	pArray = new CWmiArray;

					if ( NULL != pArray )
					{
						hr = pArray->InitializeQualifierArray( this, NULL, pszQualName, ct );

						if ( SUCCEEDED( hr ) )
						{
							// We want to QI into the memory pointed at by pUserBuff
							hr = pArray->QueryInterface( IID__IWmiArray, (LPVOID*) pDestBuf );
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
				else
				{
					hr = WBEM_E_BUFFER_TOO_SMALL;
				}

			}
			else
			{
				// Now get the value
				CVar	var;

				hr = GetQualifier( pszQualName, &var, NULL );

				if ( SUCCEEDED( hr ) )
				{
					hr = CUntypedValue::LoadUserBuffFromCVar( CType::GetBasic(ct), &var, uBufSize,
							puBuffSizeUsed,	pDestBuf );
				}

			}	// IF Not an Array

		}	// IF got qualifier data


		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings MUST be WCHAR
// Arrays are set using _IWmiArray interface from Get
STDMETHODIMP CWbemObject::SetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, ULONG uNumElements,
										CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf )
{
	try
	{
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Check that the CIMTYPE is proper (if so, then a conversion may occur (e.g. CIM_UINT32 becomes CIM_SINT32))
		VARTYPE	vt = CType::GetVARTYPE( uCimType );

		if ( !CBasicQualifierSet::IsValidQualifierType( vt ) )
		{
			return WBEM_E_TYPE_MISMATCH;
		}

		uCimType = (Type_t) CType::VARTYPEToType( vt );

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		CVar	var;
		HRESULT	hr = WBEM_S_NO_ERROR;

		// Special handling for arrays
		if ( CType::IsArray( uCimType ) )
		{
			// Reroute to the array code
			hr = SetQualifierArrayRange( NULL, pszQualName, FALSE, WMIARRAY_FLAG_ALLELEMENTS, uQualFlavor,
				uCimType, 0L, uNumElements, uBufSize, pUserBuf );
		}
		else
		{
			hr = CUntypedValue::FillCVarFromUserBuffer( uCimType, &var, uBufSize, pUserBuf );

			if ( SUCCEEDED( hr ) )
			{
				// Now just set the property
				hr = SetQualifier( pszQualName, &var, (long) uQualFlavor );
			}
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings are copied in-place and null-terminated.
// Arrays come out as a pointer to IWmiArray
STDMETHODIMP CWbemObject::GetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
										CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
										LPVOID pDestBuf )
{
	try
	{
		CIMTYPE	ct = 0;

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		// Don't believe we need to deal with NULL types here.

		//	First, get the type, if it's an array, we need to gin up an _IWmiArray pointer.
		//	We don't want the Var this time, since that may get hung up in an array
		HRESULT hr = GetPropQualifier( pszPropName, pszQualName, NULL, (long*) puQualFlavor, &ct );

		if ( SUCCEEDED( hr ) )
		{
			// Get the cimtype from the array
			if ( NULL != puCimType )
			{
				*puCimType = ct;
			}

			if ( CType::IsArray( ct ) )
			{
				// We'll need this many bytes to do our dirty work.
				*puBuffSizeUsed = sizeof( _IWmiArray*);

				if ( uBufSize >= sizeof( _IWmiArray*) && NULL != pDestBuf )
				{
					// Allocate an array object, initialize it and QI for the
					// appropriate object
					CWmiArray*	pArray = new CWmiArray;

					if ( NULL != pArray )
					{
						hr = pArray->InitializeQualifierArray( this, pszPropName, pszQualName, ct );

						if ( SUCCEEDED( hr ) )
						{
							// We want to QI into the memory pointed at by pUserBuff
							hr = pArray->QueryInterface( IID__IWmiArray, (LPVOID*) pDestBuf );
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
				else
				{
					hr = WBEM_E_BUFFER_TOO_SMALL;
				}

			}
			else
			{
				// Now get the value
				CVar	var;

				hr = GetPropQualifier( pszPropName, pszQualName, &var, NULL );

				if ( SUCCEEDED( hr ) )
				{
					hr = CUntypedValue::LoadUserBuffFromCVar( CType::GetBasic(ct), &var, uBufSize,
							puBuffSizeUsed,	pDestBuf );
				}

			}	// IF Not an Array

		}	// IF got qualifier data


		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings MUST be WCHAR
// Arrays are set using _IWmiArray interface from Get
STDMETHODIMP CWbemObject::SetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
										ULONG uNumElements, CIMTYPE uCimType, ULONG uQualFlavor,
										LPVOID pUserBuf )
{
	try
	{
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Check that the CIMTYPE is proper (if so, then a conversion may occur (e.g. CIM_UINT32 becomes CIM_SINT32))
		VARTYPE	vt = CType::GetVARTYPE( uCimType );

		if ( !CBasicQualifierSet::IsValidQualifierType( vt ) )
		{
			return WBEM_E_TYPE_MISMATCH;
		}

		uCimType = (Type_t) CType::VARTYPEToType( vt );

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		CVar	var;
		HRESULT	hr = WBEM_S_NO_ERROR;

		// Special handling for arrays
		if ( CType::IsArray( uCimType ) )
		{
			// Reroute to the array code
			hr = SetQualifierArrayRange( pszPropName, pszQualName, FALSE, WMIARRAY_FLAG_ALLELEMENTS, uQualFlavor,
				uCimType, 0L, uNumElements, uBufSize, pUserBuf );
		}
		else
		{
			hr = CUntypedValue::FillCVarFromUserBuffer( uCimType, &var, uBufSize, pUserBuf );

			if ( SUCCEEDED( hr ) )
			{
				// Now just set the property qualifier
				hr = SetPropQualifier( pszPropName, pszQualName, (long) uQualFlavor, &var );
			}
		}

		return hr;

	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings are copied in-place and null-terminated.
// Arrays come out as a pointer to IWmiArray
STDMETHODIMP CWbemObject::GetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
										CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
										LPVOID pDestBuf )
{
	try
	{
		CIMTYPE	ct = 0;

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		// Don't believe we need to deal with NULL types here.

		//	First, get the type, if it's an array, we need to gin up an _IWmiArray pointer.
		//	We don't want the Var this time, since that may get hung up in an array
		HRESULT hr = GetMethodQualifier( pszMethodName, pszQualName, NULL, (long*) puQualFlavor, &ct );

		if ( SUCCEEDED( hr ) )
		{
			// Save the CIMTYPE as appropriate
			if ( NULL != puCimType )
			{
				*puCimType = ct;
			}

			if ( CType::IsArray( ct ) )
			{
				// We'll need this many bytes to do our dirty work.
				*puBuffSizeUsed = sizeof( _IWmiArray*);

				if ( uBufSize >= sizeof( _IWmiArray*) && NULL != pDestBuf )
				{
					// Allocate an array object, initialize it and QI for the
					// appropriate object
					CWmiArray*	pArray = new CWmiArray;

					if ( NULL != pArray )
					{
						hr = pArray->InitializeQualifierArray( this, pszMethodName, pszQualName, ct );

						if ( SUCCEEDED( hr ) )
						{
							// We want to QI into the memory pointed at by pUserBuff
							hr = pArray->QueryInterface( IID__IWmiArray, (LPVOID*) pDestBuf );
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
				else
				{
					hr = WBEM_E_BUFFER_TOO_SMALL;
				}

			}
			else
			{
				// Now get the value
				CVar	var;

				hr = GetMethodQualifier( pszMethodName, pszQualName, &var, NULL );

				if ( SUCCEEDED( hr ) )
				{
					hr = CUntypedValue::LoadUserBuffFromCVar( CType::GetBasic(ct), &var, uBufSize,
							puBuffSizeUsed,	pDestBuf );
				}

			}	// IF Not an Array

		}	// IF got qualifier data


		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings MUST be WCHAR
// Arrays are set using _IWmiArray interface from Get
STDMETHODIMP CWbemObject::SetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
										ULONG uNumElements, CIMTYPE uCimType, ULONG uQualFlavor,
										LPVOID pUserBuf )
{
	try
	{
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Check that the CIMTYPE is proper (if so, then a conversion may occur (e.g. CIM_UINT32 becomes CIM_SINT32))
		VARTYPE	vt = CType::GetVARTYPE( uCimType );

		if ( !CBasicQualifierSet::IsValidQualifierType( vt ) )
		{
			return WBEM_E_TYPE_MISMATCH;
		}

		uCimType = (Type_t) CType::VARTYPEToType( vt );

		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		CVar	var;
		HRESULT	hr = WBEM_S_NO_ERROR;

		// Special handling for arrays
		if ( CType::IsArray( uCimType ) )
		{
			// Reroute to the array code
			hr = SetQualifierArrayRange( pszMethodName, pszQualName, TRUE, WMIARRAY_FLAG_ALLELEMENTS, uQualFlavor,
				uCimType, 0L, uNumElements, uBufSize, pUserBuf );
		}
		else
		{
			hr = CUntypedValue::FillCVarFromUserBuffer( uCimType, &var, uBufSize, pUserBuf );

			if ( SUCCEEDED( hr ) )
			{
				// Now just set the property qualifier
				hr = SetMethodQualifier( pszMethodName, pszQualName, (long) uQualFlavor, &var );
			}
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Returns flags indicating singleton, dynamic, association, etc.
STDMETHODIMP CWbemObject::QueryObjectFlags( long lFlags, unsigned __int64 qObjectInfoMask,
										  unsigned __int64* pqObjectInfo)
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Lock the BLOB
		CLock	lock( this );

		// Clear the destination data
		*pqObjectInfo = 0;

		CClassPart*	pClassPart = GetClassPart();

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION )
		{
			if ( pClassPart->IsAssociation() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_DYNAMIC )
		{
			if ( pClassPart->IsDynamic() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_DYNAMIC;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_SINGLETON )
		{
			if ( pClassPart->IsSingleton() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_SINGLETON;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_AMENDMENT )
		{
			if ( pClassPart->IsAmendment() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_AMENDMENT;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_LOCALIZED )
		{
			if ( IsLocalized() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_LOCALIZED;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_KEYED )
		{
			if ( IsKeyed() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_KEYED;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_ABSTRACT )
		{
			if ( pClassPart->IsAbstract() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_HIPERF )
		{
			if ( pClassPart->IsHiPerf() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_AUTOCOOK )
		{
			if ( pClassPart->IsAutocook() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_DECORATED )
		{
			if ( m_DecorationPart.IsDecorated() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_DECORATED;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_LIMITED )
		{
			if ( IsLimited() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_LIMITED;
			}
		}

		if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_CLIENTONLY )
		{
			if ( IsClientOnly() )
			{
				*pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_CLIENTONLY;
			}
		}

		return WBEM_S_NO_ERROR;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Helper for accessing Boolean qualifiers
BOOL CWbemObject::CheckBooleanPropQual( LPCWSTR pwszPropName, LPCWSTR pwszQualName )
{
	BOOL	fReturn = FALSE;
	CVar	var;

	HRESULT	hr = GetPropQualifier( pwszPropName, pwszQualName, &var, NULL );

	if ( SUCCEEDED( hr ) )
	{
		fReturn = ( var.GetType() == VT_BOOL	&&
					var.GetBool() );
	}

	return fReturn;
}

// Returns flags indicating key, index, etc.
STDMETHODIMP CWbemObject::QueryPropertyFlags( long lFlags, LPCWSTR pszPropertyName,
								unsigned __int64 qPropertyInfoMask, unsigned __int64 *pqPropertyInfo )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Lock the BLOB
		CLock	lock( this );

		*pqPropertyInfo = 0;

		if ( qPropertyInfoMask & WMIOBJECT_GETPROPERTY_LOFLAG_KEY )
		{
			if ( CheckBooleanPropQual( pszPropertyName, L"key" ) )
			{
				*pqPropertyInfo |= WMIOBJECT_GETPROPERTY_LOFLAG_KEY;
			}
		}

		if ( qPropertyInfoMask & WMIOBJECT_GETPROPERTY_LOFLAG_INDEX )
		{
			if ( CheckBooleanPropQual( pszPropertyName, L"index" ) )
			{
				*pqPropertyInfo |= WMIOBJECT_GETPROPERTY_LOFLAG_INDEX;
			}
		}

		if ( qPropertyInfoMask & WMIOBJECT_GETPROPERTY_LOFLAG_DYNAMIC )
		{
			if ( CheckBooleanPropQual( pszPropertyName, L"dynamic" ) )
			{
				*pqPropertyInfo |= WMIOBJECT_GETPROPERTY_LOFLAG_DYNAMIC;
			}
		}

		return WBEM_S_NO_ERROR;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT CWbemObject::FindMethod( LPCWSTR wszMethod )
{
	return WBEM_E_INVALID_OPERATION;
}

// Sets an array value in a qualifier, but allows for doing so - in place.
HRESULT CWbemObject::SetQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod, long lFlags,
									ULONG uFlavor, CIMTYPE ct, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
									LPVOID pData )
{
	try
	{
		HRESULT	hr = WBEM_S_NO_ERROR;

		CLock	lock( this );

		CTypedValue	value;
		CFastHeap*	pHeap = NULL;
		long		lCurrentFlavor;
		heapptr_t	ptrTemp = INVALID_HEAP_ADDRESS;
		BOOL		fPrimaryError = FALSE;

		if ( NULL != pwszPrimaryName )
		{
			if ( fIsMethod )
			{
				// Check the method first:
				hr = FindMethod( pwszPrimaryName );

				if ( SUCCEEDED( hr ) )
				{
					// This is a method qualifier
					hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
				}
				else
				{
					fPrimaryError = TRUE;
				}
			}
			else
			{
				// Check the property first:
				hr = GetPropertyType( pwszPrimaryName, NULL, NULL );

				if ( SUCCEEDED( hr ) )
				{
					// This is a property qualifier
					hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
				}
				else
				{
					fPrimaryError = TRUE;
				}
			}
		}
		else
		{
			// Object level qualifier
			hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );

		}

		// We only let not found qualifiers through
		if ( !fPrimaryError )
		{
			// IF this failed, because the qualifier does not exist, then we will
			// assume we will be able to add it, and will set the Value to be like an
			// empty value
			if ( FAILED( hr ) && WBEM_E_NOT_FOUND == hr )
			{
				// If it does not exist, then we only let this through if we are setting
				// all elements

				if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS && 0 == uStartIndex  )
				{
					CTypedValue	temp( ct, (LPMEMORY) &ptrTemp );
					temp.CopyTo( &value );

					hr = WBEM_S_NO_ERROR;
				}
				else
				{
					hr = WBEM_E_ILLEGAL_OPERATION;
				}
			}
			else
			{
				// If the qualifier is not local, then we should again NULL out the
				// value, since we will be setting the qualifier locally

				if ( !CQualifierFlavor::IsLocal( (BYTE) lCurrentFlavor ) )
				{
					CTypedValue	temp( ct, (LPMEMORY) &ptrTemp );
					temp.CopyTo( &value );
				}
			}

		}

		if ( SUCCEEDED( hr ) )
		{
			// Fake up an address for the value to change.  The heap will always be the
			// current refDataHeap.  Then we can go ahead and let they Untyped array function
			// take care of setting the range.  Once that is done, we will do a final set on
			// the qualifier value.

			CStaticPtr ValuePtr( value.GetRawData() );

			CIMTYPE	ctBasic = CType::GetBasic(ct);

			hr = CUntypedArray::SetRange( &ValuePtr, lFlags, ctBasic, CType::GetLength( ctBasic ), &m_refDataHeap, uStartIndex, uNumElements, uBuffSize, pData );

			if ( SUCCEEDED( hr ) )
			{
				if ( ARRAYFLAVOR_USEEXISTING == uFlavor )
				{
					// Use the existing flavor
					uFlavor = lCurrentFlavor;
				}

				if ( NULL != pwszPrimaryName )
				{
					if ( fIsMethod )
					{
						// This is a method qualifier
						hr = SetMethodQualifier( pwszPrimaryName, pwszQualName, uFlavor, &value );
					}
					else
					{
						// This is a property qualifier
						hr = SetPropQualifier( pwszPrimaryName, pwszQualName, uFlavor, &value );
					}
				}
				else
				{
					// Object level qualifier
					hr = SetQualifier( pwszQualName, uFlavor, &value );
				}

			}

		}	// If okay to try and set a qualifier

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Sets an array value in a qualifier, but allows for doing so - in place.
HRESULT CWbemObject::AppendQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, CIMTYPE ct, ULONG uNumElements, ULONG uBuffSize, LPVOID pData )
{
	try
	{
		HRESULT	hr = WBEM_S_NO_ERROR;

		CLock	lock( this );


		CTypedValue	value;
		CFastHeap*	pHeap = NULL;
		long		lCurrentFlavor;
		heapptr_t	ptrTemp = INVALID_HEAP_ADDRESS;
		BOOL		fPrimaryError = FALSE;

		if ( NULL != pwszPrimaryName )
		{
			if ( fIsMethod )
			{
				// Check the method first:
				hr = FindMethod( pwszPrimaryName );

				if ( SUCCEEDED( hr ) )
				{
					// This is a method qualifier
					hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
				}
				else
				{
					fPrimaryError = TRUE;
				}
			}
			else
			{
				// Check the property first:
				hr = GetPropertyType( pwszPrimaryName, NULL, NULL );

				if ( SUCCEEDED( hr ) )
				{
					// This is a property qualifier
					hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
				}
				else
				{
					fPrimaryError = TRUE;
				}
			}
		}
		else
		{
			// Object level qualifier
			hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );

		}

		// We only let not found qualifiers through
		if ( !fPrimaryError )
		{
			// IF this failed, because the qualifier does not exist, then we will
			// assume we will be able to add it, and will set the Value to be like an
			// empty value
			if ( FAILED( hr ) && WBEM_E_NOT_FOUND == hr )
			{
				CTypedValue	temp( ct, (LPMEMORY) &ptrTemp );
				temp.CopyTo( &value );

				hr = WBEM_S_NO_ERROR;
			}
			else if ( SUCCEEDED( hr ) )
			{
				// If the qualifier is not local, then this is an invalid operation

				if ( !CQualifierFlavor::IsLocal( (BYTE) lCurrentFlavor ) )
				{
					hr = WBEM_E_PROPAGATED_QUALIFIER;
				}
			}
		}

		if ( SUCCEEDED( hr ) )
		{
			// Fake up an address for the value to change.  The heap will always be the
			// current refDataHeap.  Then we can go ahead and let they Untyped array function
			// take care of setting the range.  Once that is done, we will do a final set on
			// the qualifier value.

			CStaticPtr ValuePtr( value.GetRawData() );

			CIMTYPE	ctBasic = CType::GetBasic(ct);

			hr = CUntypedArray::AppendRange( &ValuePtr, ctBasic, CType::GetLength( ctBasic ), &m_refDataHeap,
											uNumElements, uBuffSize, pData );

			if ( SUCCEEDED( hr ) )
			{
				if ( NULL != pwszPrimaryName )
				{
					if ( fIsMethod )
					{
						// This is a method qualifier
						hr = SetMethodQualifier( pwszPrimaryName, pwszQualName, lCurrentFlavor, &value );
					}
					else
					{
						// This is a property qualifier
						hr = SetPropQualifier( pwszPrimaryName, pwszQualName, lCurrentFlavor, &value );
					}
				}
				else
				{
					// Object level qualifier
					hr = SetQualifier( pwszQualName, lCurrentFlavor, &value );
				}

			}
		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Appends to an existing array value in a qualifier, but allows for doing so - in place.
HRESULT CWbemObject::RemoveQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, ULONG uStartIndex, ULONG uNumElements )
{
	try
	{
		HRESULT	hr = WBEM_S_NO_ERROR;

		CLock	lock( this );

		CTypedValue	value;
		CFastHeap*	pHeap = NULL;
		long		lCurrentFlavor;
		heapptr_t	ptrTemp = INVALID_HEAP_ADDRESS;
		BOOL		fPrimaryError = FALSE;

		if ( NULL != pwszPrimaryName )
		{
			if ( fIsMethod )
			{
				// Check the method first:
				hr = FindMethod( pwszPrimaryName );

				if ( SUCCEEDED( hr ) )
				{
					// This is a method qualifier
					hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
				}
				else
				{
					fPrimaryError = TRUE;
				}
			}
			else
			{
				// Check the property first:
				hr = GetPropertyType( pwszPrimaryName, NULL, NULL );

				if ( SUCCEEDED( hr ) )
				{
					// This is a property qualifier
					hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
				}
				else
				{
					fPrimaryError = TRUE;
				}
			}
		}
		else
		{
			// Object level qualifier
			hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
		}

		// We won't allow modification of the array if the qualifier is not local
		if ( !fPrimaryError )
		{
			if ( SUCCEEDED( hr ) && !CQualifierFlavor::IsLocal( (BYTE) lCurrentFlavor ) )
			{
				hr = WBEM_E_PROPAGATED_QUALIFIER;
			}
		}

		if ( SUCCEEDED( hr ) )
		{
			// Fake up an address for the value to change.  The heap will always be the
			// current refDataHeap.  Then we can go ahead and let they Untyped array function
			// take care of setting the range.  Once that is done, we will do a final set on
			// the qualifier value.

			CHeapPtr HeapPtr( &m_refDataHeap, value.AccessPtrData() );

			// If we're told to remove all elements, then we need to figure out how
			// many to perform this operation on.
			if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
			{
				CUntypedArray*	pArray = (CUntypedArray*) HeapPtr.GetPointer();
				uNumElements = pArray->GetNumElements() - uStartIndex;
			}

			CIMTYPE	ctBasic = CType::GetBasic( value.GetType() );

			// This is all done in-place, so the array wopn't move
			hr = CUntypedArray::RemoveRange( &HeapPtr, ctBasic, CType::GetLength(ctBasic), &m_refDataHeap,
											uStartIndex, uNumElements );

		}

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Gets array info for a qualifier
HRESULT CWbemObject::GetQualifierArrayInfo( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, CIMTYPE* pct, ULONG* puNumElements )
{
	try
	{
		HRESULT	hr = WBEM_S_NO_ERROR;

		CTypedValue	value;
		CFastHeap*	pHeap = NULL;
		long		lCurrentFlavor;
		heapptr_t	ptrTemp = INVALID_HEAP_ADDRESS;

		if ( NULL != pwszPrimaryName )
		{
			if ( fIsMethod )
			{
				// This is a method qualifier
				hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
			}
			else
			{
				// This is a property qualifier
				hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
			}

		}
		else
		{
			// Object level qualifier
			hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
		}

		if ( SUCCEEDED( hr ) )
		{
			CUntypedArray*	pArray = (CUntypedArray*) pHeap->ResolveHeapPointer( value.AccessPtrData() );

			if ( NULL != pct )
			{
				*pct = value.GetType();

				if ( NULL != puNumElements )
				{
					*puNumElements = pArray->GetNumElements();
				}

			}

		}	// IF got qualifier array

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Gets array data for a qualifier
HRESULT CWbemObject::GetQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
									long lFlags, ULONG uStartIndex,	ULONG uNumElements, ULONG uBuffSize,
									ULONG* puNumReturned, ULONG* pulBuffUsed, LPVOID pData )
{
	try
	{
		HRESULT	hr = WBEM_S_NO_ERROR;

		CTypedValue	value;
		CFastHeap*	pHeap = NULL;
		long		lCurrentFlavor;
		heapptr_t	ptrTemp = INVALID_HEAP_ADDRESS;

		if ( NULL != pwszPrimaryName )
		{
			if ( fIsMethod )
			{
				// This is a method qualifier
				hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
			}
			else
			{
				// This is a property qualifier
				hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
			}

		}
		else
		{
			// Object level qualifier
			hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
		}

		if ( SUCCEEDED( hr ) )
		{
			// A boy and his virtual functions.  This is what makes everything work in case
			// the BLOB gets ripped out from underneath us.  The CHeapPtr class has GetPointer
			// overloaded so we can always fix ourselves up to the underlying BLOB.

			CHeapPtr ArrayPtr(pHeap, value.AccessPtrData());

			// If we're told to get all elements, then we need to get them from the
			// starting index to the end
			if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
			{
				CUntypedArray*	pArray = (CUntypedArray*) ArrayPtr.GetPointer();
				uNumElements = pArray->GetNumElements() - uStartIndex;
			}

			// How many will we get?
			*puNumReturned = uNumElements;

			CIMTYPE	ctBasic = CType::GetBasic( value.GetType() );

			hr = CUntypedArray::GetRange( &ArrayPtr, ctBasic, CType::GetLength( ctBasic ), pHeap,
					uStartIndex, uNumElements, uBuffSize, pulBuffUsed, pData );

		}	// IF got qualifier array

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Sets flags, including internal ones normally inaccessible.
STDMETHODIMP CWbemObject::SetObjectFlags( long lFlags,
							unsigned __int64 qObjectInfoOnFlags,
							unsigned __int64 qObjectInfoOffFlags )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		if ( qObjectInfoOnFlags & WMIOBJECT_SETOBJECT_LOFLAG_LIMITED )
		{
			m_DecorationPart.SetLimited();
		}

		if ( qObjectInfoOnFlags & WMIOBJECT_SETOBJECT_LOFLAG_CLIENTONLY )
		{
			m_DecorationPart.SetClientOnly();
		}

		if ( qObjectInfoOnFlags & WMIOBJECT_SETOBJECT_LOFLAG_LOCALIZED )
		{
			SetLocalized( TRUE );
		}

		return WBEM_S_NO_ERROR;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

	// Merges in amended qualifiers from the amended class object into the
	// current object.  If lFlags is WMIOBJECT_MERGEAMENDED_FLAG_PARENTLOCALIZED,
	// this means that the parent object was localized, but not the current,
	// so we need to prevent certain qualifiers from "moving over."
STDMETHODIMP CWbemObject::MergeAmended( long lFlags, _IWmiObject* pAmendedClass )
{
	try
	{
		// Only take in supported flags
		if ( lFlags &~WMIOBJECT_MERGEAMENDED_FLAG_PARENTLOCALIZED )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		CLock	lock( this );

		// This needs to be fixed up to NOT use the qualifier set APIs to speed things up
		IWbemQualifierSet*	pLocalizedQs = NULL;
		IWbemQualifierSet*	pThisQs = NULL;
		bool	bChg = false;
		bool	fParentLocalized = lFlags & WMIOBJECT_MERGEAMENDED_FLAG_PARENTLOCALIZED;
		BOOL	fInstance = IsInstance();

		// At this point, we have the localized copy, and are
		// ready to combine qualifiers.  Start with class qualifiers.
		// ============================================================

		if (FAILED(pAmendedClass->GetQualifierSet(&pLocalizedQs)))
		{
			return WBEM_S_NO_ERROR;
		}
		CReleaseMe	rmlqs( pLocalizedQs );

		if (FAILED(GetQualifierSet(&pThisQs)))
		{
			return WBEM_S_NO_ERROR;
		}
		CReleaseMe	rmtqs( pThisQs );

		HRESULT	hr = LocalizeQualifiers(fInstance, fParentLocalized, pThisQs, pLocalizedQs, bChg);

		pLocalizedQs->EndEnumeration();
		if (FAILED(hr))
		{
			return hr;
		}

		hr = LocalizeProperties(fInstance, fParentLocalized, this, pAmendedClass, bChg);

		// Methods.
		// Putting a method cancels enumeration, so we have to enumerate first.

		IWbemClassObject *pLIn = NULL, *pLOut = NULL;
		IWbemClassObject *pOIn = NULL, *pOOut = NULL;
		int iPos = 0;

		hr = pAmendedClass->BeginMethodEnumeration(0);

		if ( SUCCEEDED( hr ) )
		{
			BSTR	bstrMethodName = NULL;

			while( pAmendedClass->NextMethod( 0, &bstrMethodName, 0, 0 ) == S_OK )
			{
				// Auto cleanup
				CSysFreeMe	sfm( bstrMethodName );

				pLIn = NULL;
				pOIn = NULL;
				pLOut = NULL;
				pOOut = NULL;
				pAmendedClass->GetMethod(bstrMethodName, 0, &pLIn, &pLOut);

				hr = GetMethod(bstrMethodName, 0, &pOIn, &pOOut);

				CReleaseMe rm0(pLIn);
				CReleaseMe rm1(pOIn);
				CReleaseMe rm2(pLOut);
				CReleaseMe rm3(pOOut);

				// METHOD IN PARAMETERS
				if (pLIn)
					if (pOIn)
						hr = LocalizeProperties(fInstance, fParentLocalized, pOIn, pLIn, bChg);

				if (pLOut)
					if (pOOut)
						hr = LocalizeProperties(fInstance, fParentLocalized, pOOut, pLOut, bChg);

				// METHOD QUALIFIERS

				hr = GetMethodQualifierSet(bstrMethodName, &pThisQs);
				if (FAILED(hr))
				{
					continue;
				}
				CReleaseMe	rmThisQs( pThisQs );

				hr = pAmendedClass->GetMethodQualifierSet(bstrMethodName, &pLocalizedQs);
				if (FAILED(hr))
				{
					continue;
				}
				CReleaseMe	rmLocalizedQs( pLocalizedQs );

				hr = LocalizeQualifiers(fInstance, fParentLocalized, pThisQs, pLocalizedQs, bChg);

				PutMethod(bstrMethodName, 0, pOIn, pOOut);

			}	// WHILE Enum Methods
			

			pAmendedClass->EndMethodEnumeration();

		}	// IF BeginMethodEnumeration
		else
		{
			// Mask this error
			hr = WBEM_S_NO_ERROR;
		}

		// If we changed, we should be localized
		if (bChg)
			SetLocalized(true);

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Helper function to localize qualifiers
HRESULT CWbemObject::LocalizeQualifiers(BOOL bInstance, bool bParentLocalized,
										IWbemQualifierSet *pBase, IWbemQualifierSet *pLocalized,
										bool &bChg)
{
	try
	{
		HRESULT hr = WBEM_S_NO_ERROR;

		pLocalized->BeginEnumeration(0);

		BSTR strName = NULL;
		VARIANT vVal;
		VariantInit(&vVal);

		long lFlavor;
		while(pLocalized->Next(0, &strName, &vVal, &lFlavor) == S_OK)
		{
			// Ignore if this is an instance.

			if (bInstance && !(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE))
			{
				VariantClear(&vVal);
				SysFreeString(strName);
				continue;
			}

			if (!_wcsicmp(strName, L"amendment") ||
				!_wcsicmp(strName, L"key") ||
				!_wcsicmp(strName, L"singleton") ||
				!_wcsicmp(strName, L"dynamic") ||
				!_wcsicmp(strName, L"indexed") ||
				!_wcsicmp(strName, L"cimtype") ||
				!_wcsicmp(strName, L"static") ||
				!_wcsicmp(strName, L"implemented") ||
				!_wcsicmp(strName, L"abstract"))
			{
				VariantClear(&vVal);
				SysFreeString(strName);
				continue;
			}

			// If this is not a propagated qualifier,
			// ignore it.  (Bug #45799)
			// =====================================

			if (bParentLocalized &&
				!(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS))
			{
				VariantClear(&vVal);
				SysFreeString(strName);
				continue;
			}

			// Now, we need to test for this in the other
			// class.
			// The only localized qualifiers that do not override the
			// default are where only parent qualifiers exist, but the
			// child has overriden its own parent.
			// =======================================================

			VARIANT vBasicVal;
			VariantInit(&vBasicVal);
			long lBasicFlavor;

			if (pBase->Get(strName, 0, &vBasicVal, &lBasicFlavor) != WBEM_E_NOT_FOUND)
			{
				if (bParentLocalized &&                             // If there is no localized copy of this class
					(lBasicFlavor & WBEM_FLAVOR_OVERRIDABLE) &&     // .. and this is an overridable qualifier
					 (lBasicFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS) && // and this is propogated
					 (lBasicFlavor & WBEM_FLAVOR_ORIGIN_LOCAL))     // .. and this was actualy overridden
				{
					VariantClear(&vVal);                            // .. DON'T DO IT.
					VariantClear(&vBasicVal);
					SysFreeString(strName);
					continue;
				}

				if (bParentLocalized &&
					!(lBasicFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS))
				{
					VariantClear(&vVal);
					VariantClear(&vBasicVal);
					SysFreeString(strName);
					continue;
				}
			}

			pBase->Put(strName, &vVal, (lFlavor&~WBEM_FLAVOR_ORIGIN_PROPAGATED) | WBEM_FLAVOR_AMENDED);
			bChg = true;

			VariantClear(&vVal);
			VariantClear(&vBasicVal);
			SysFreeString(strName);

		}
		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Helper function to localize properties
HRESULT CWbemObject::LocalizeProperties(BOOL bInstance, bool bParentLocalized, IWbemClassObject *pOriginal,
                                        IWbemClassObject *pLocalized, bool &bChg)
{
	try
	{
		HRESULT hr = WBEM_S_NO_ERROR;

		pLocalized->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);

		BSTR strPropName;
		LONG lLong;
		CIMTYPE ct;
		VARIANT vNewVal;

		while(pLocalized->Next(0, &strPropName, &vNewVal, &ct, &lLong) == S_OK)
		{
			IWbemQualifierSet *pLocalizedQs = NULL, *pThisQs = NULL;
			VARIANT vBasicVal;
			VariantInit(&vBasicVal);

			if (FAILED(pLocalized->GetPropertyQualifierSet(strPropName,&pLocalizedQs)))
			{
				SysFreeString(strPropName);
				VariantClear(&vNewVal);
				continue;
			}
			CReleaseMe rm1(pLocalizedQs);

			if (FAILED(pOriginal->GetPropertyQualifierSet(strPropName, &pThisQs)))
			{
				SysFreeString(strPropName);
				VariantClear(&vNewVal);
				continue;
			}
			CReleaseMe rm2(pThisQs);

			hr = LocalizeQualifiers(bInstance, bParentLocalized, pThisQs, pLocalizedQs, bChg);
			if (FAILED(hr))
			{
				SysFreeString(strPropName);
				VariantClear(&vNewVal);
				continue;
			}

			SysFreeString(strPropName);
			VariantClear(&vNewVal);

		}

		pLocalized->EndEnumeration();

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Retrieves the derivation of an object as an array of LPCWSTR's, each one
// terminated by a NULL.  Leftmost class is at the top of the chain
STDMETHODIMP CWbemObject::GetDerivation( long lFlags, ULONG uBufferSize, ULONG* puNumAntecedents,
										ULONG* puBuffSizeUsed, LPWSTR pwstrUserBuffer )
{
	try
	{
		if ( lFlags != 0L )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		CLock	lock( this );

		CVar	varDerivation;

		HRESULT	hr = GetClassPart()->GetDerivation( &varDerivation );

		if ( SUCCEEDED( hr ) )
		{
			if ( varDerivation.GetType() == VT_EX_CVARVECTOR && varDerivation.GetVarVector()->Size() > 0 )
			{
				CVarVector*	pvv = varDerivation.GetVarVector();

				// How many there are
				*puNumAntecedents = pvv->Size();
				*puBuffSizeUsed = 0;

				LPWSTR	pwstrTemp = pwstrUserBuffer;
				for ( long x = ( *puNumAntecedents - 1 ); x > 0; x-- )
				{
					// Point at the class name and store ts lenth
					LPCWSTR	pwszAntecedent = pvv->GetAt( x ).GetLPWSTR();
					ULONG	uLen = wcslen( pwszAntecedent ) + 1;

					// Add to the required size
					*puBuffSizeUsed +=	uLen;

					// If we have a plcae to copy into and haven't exceeded its
					// size, copy the string, and jump to the next location
					if ( NULL != pwstrTemp && *puBuffSizeUsed <= uBufferSize )
					{
						wcscpy( pwstrTemp, pwszAntecedent );
						pwstrTemp += uLen;
					}

				}	// FOR enum the hierarchy	

				// Set an error as apropriate
				if ( NULL == pwstrTemp || *puBuffSizeUsed > uBufferSize )
				{
					hr = WBEM_E_BUFFER_TOO_SMALL;
				}

			}
			else
			{
				*puNumAntecedents = 0;
				*puBuffSizeUsed = 0;
			}

		}	// IF we got the derivation

		return hr;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Returns CWbemObject - allows for quick discovery of the real CWbemObject
// in case we've been wrapped.
STDMETHODIMP CWbemObject::_GetCoreInfo( long lFlags, void** ppvData )
{
	// AddRef us and return
	AddRef();
	*ppvData = (void*) this;

	return WBEM_S_NO_ERROR;
}

// Helper function to see if we know about a classname or not
classindex_t CWbemObject::GetClassIndex( LPCWSTR pwszClassName )
{
	return GetClassPart()->GetClassIndex( pwszClassName );
}

// Helper function to get a CWbemObject from IWbemClassObject;
HRESULT CWbemObject::WbemObjectFromCOMPtr( IUnknown* pUnk, CWbemObject** ppObj )
{
	// NULL is okay
	if ( NULL == pUnk )
	{
		*ppObj = NULL;
		return WBEM_S_NO_ERROR;
	}

	_IWmiObject*	pWmiObject = NULL;

	HRESULT	hr = pUnk->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );
	CReleaseMe	rm(pWmiObject);

	if ( SUCCEEDED( hr ) )
	{
		// Okay pull out the object
		hr = pWmiObject->_GetCoreInfo( 0L, (void**) ppObj );	
	}
	else
	{
		// This will only happen if the object ain't one of ours
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}


// Returns a BLOB of memory containing minimal data (local)
STDMETHODIMP CWbemObject::Unmerge( long lFlags, ULONG uBuffSize, ULONG* puBuffSizeUsed, LPVOID pData )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		int nLen = EstimateUnmergeSpace();
		length_t    nUnmergedLength = 0L;   // this should be passed in

		HRESULT hr = WBEM_E_OUT_OF_MEMORY;

		if ( NULL != puBuffSizeUsed )
		{
			*puBuffSizeUsed = nLen;
		}

		if ( uBuffSize >= nLen && NULL != pData )
		{
			// The buffer is big enough, so let the games begin.
			memset(pData, 0, nLen);
			hr = Unmerge( (LPBYTE) pData, nLen, &nUnmergedLength );

			if ( SUCCEEDED( hr ) && NULL != puBuffSizeUsed )
			{
				// This is the actual number of bytes used
				*puBuffSizeUsed = nUnmergedLength;
			}
		}
		else
		{
			hr = WBEM_E_BUFFER_TOO_SMALL;
		}

		return hr;

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	catch( ... )
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Returns the name of the class where the keys were defined
STDMETHODIMP CWbemObject::GetKeyOrigin( long lFlags, DWORD dwNumChars, DWORD* pdwNumUsed, LPWSTR pwszClassName )
{
	try
	{
		if ( 0L != lFlags )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		CLock	lock( this );

		WString	wstr;

		HRESULT	hr = GetClassPart()->GetKeyOrigin( wstr );

		if ( SUCCEEDED( hr ) )
		{
			*pdwNumUsed = wstr.Length() + 1;

			if ( dwNumChars >= *pdwNumUsed && NULL != pwszClassName )
			{
				wcscpy( pwszClassName, wstr );
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
		}

		return hr;

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	catch( ... )
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Returns the key string of the class
STDMETHODIMP CWbemObject::GetKeyString( long lFlags, BSTR* ppwszKeyString )
{
	try
	{
		if ( 0L != lFlags || NULL == ppwszKeyString )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		CLock	lock( this );

		HRESULT	hr = WBEM_S_NO_ERROR;

		if ( IsInstance() )
		{
			WString	wstr;

			CWbemInstance*	pInst = (CWbemInstance*) this;

			LPWSTR	pwszStr = pInst->GetKeyStr();
	        CVectorDeleteMe<WCHAR> vdm(pwszStr);

			if ( NULL != pwszStr )
			{
				*ppwszKeyString = SysAllocString( pwszStr );

				if ( NULL != *ppwszKeyString )
				{
					wcscpy( *ppwszKeyString, pwszStr );
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}
			else
			{
				hr = WBEM_E_INVALID_OPERATION;
			}

		}
		else
		{
			return WBEM_E_INVALID_OPERATION;
		}

		return hr;

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	catch( ... )
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Returns the key string of the class
STDMETHODIMP CWbemObject::GetNormalizedPath( long lFlags, BSTR* ppwszPath )
{
        try
        {
                if ( 0L != lFlags || NULL == ppwszPath )
                {
                        return WBEM_E_INVALID_PARAMETER;
                }

                *ppwszPath = NULL;

                LPWSTR wszRelpath = GetRelPath( TRUE );

                if ( wszRelpath == NULL )
                {
                    return WBEM_E_INVALID_OBJECT;
                }

                *ppwszPath = SysAllocString( wszRelpath );

                delete wszRelpath;

                return *ppwszPath != NULL?WBEM_S_NO_ERROR:WBEM_E_OUT_OF_MEMORY;
        }
        catch( CX_MemoryException )
        {
                return WBEM_E_OUT_OF_MEMORY;
        }

        catch( ... )
        {
                return WBEM_E_CRITICAL_ERROR;
        }
}

/*
HRESULT CWbemObject::InitSystemTimeProps( void )
{
    // cvadai: This fouls MOFCOMP by making it think a default
    //          value has changed, and therefore all subclasses
    //          must be forcibly updated.

	//SYSTEMTIME	st;
	//FILETIME	ft;

	//GetSystemTime( &st );
	//SystemTimeToFileTime( &st, &ft );

	//ULARGE_INTEGER		uli;

	//CopyMemory( &uli, &ft, sizeof(uli) );

	// Setting all the values
	// HRESULT	hr = WriteProp( L"__TC", 0L, sizeof(uli), 0, CIM_UINT64, &uli.QuadPart );

    HRESULT	hr = WriteProp( L"__TC", 0L, 0L, 0L, CIM_UINT64, NULL);

	if ( SUCCEEDED( hr ) )
	{
		hr = WriteProp( L"__TE", 0L, 0L, 0L, CIM_UINT64, NULL );
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = WriteProp( L"__TM", 0L, 0L, 0L, CIM_UINT64, NULL );
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = WriteProp( L"__SD", 0L, 0L, 0L, CIM_UINT8 | CIM_FLAG_ARRAY, NULL );
	}

	return hr;

}
*/

// Allows special filtering when enumerating properties outside the
// bounds of those allowed via BeginEnumeration().
STDMETHODIMP CWbemObject::BeginEnumerationEx( long lFlags, long lExtFlags )
{
	try
	{
		CLock	lock(this);

		if ( lExtFlags & ~WMIOBJECT_BEGINENUMEX_FLAG_GETEXTPROPS )
			return WBEM_E_INVALID_PARAMETER;

		HRESULT	hr = BeginEnumeration( lFlags );

		if ( SUCCEEDED( hr ) )
		{
			m_lExtEnumFlags = lExtFlags;
		}

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

// Returns a VARTYPE from a CIMTYPE
STDMETHODIMP CWbemObject::CIMTYPEToVARTYPE( CIMTYPE ct, VARTYPE* pvt )
{
	try
	{
		*pvt = CType::GetVARTYPE( ct );
		return WBEM_S_NO_ERROR;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

/* IWbemClassObjectEx implementations */
STDMETHODIMP CWbemObject::PutEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CWbemObject::DeleteEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CWbemObject::GetEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals, CIMTYPE* pCimType, long* plFlavor )
{
	return WBEM_E_NOT_AVAILABLE;
}

BOOL	g_fCheckedValidateFlag = FALSE;
BOOL	g_fDefaultValidate = FALSE;

// Validates an object blob
STDMETHODIMP CWbemObject::ValidateObject( long lFlags )
{

	// If we've never checked for the global validation flag, do so now.
	if ( !g_fCheckedValidateFlag )
	{
		Registry	reg( HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_WINMGMT );
		DWORD	dwValidate = 0;

		reg.GetDWORDStr( __TEXT("EnableObjectValidation"), &dwValidate );
		g_fDefaultValidate = dwValidate;
		g_fCheckedValidateFlag = TRUE;
	}

	if ( lFlags & WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE || g_fDefaultValidate )
	{
		return IsValidObj();
	}

	return WBEM_S_NO_ERROR;
}

// Returns the parent class name from a BLOB
STDMETHODIMP CWbemObject::GetParentClassFromBlob( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass )
{
	return WBEM_E_NOT_AVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastobj.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTOBJ.H

Abstract:

  This file defines the classes related to generic object representation
  in WbemObjects. Its derived classes for instances (CWbemInstance) and
  classes (CWbemClass) are described in fastcls.h and fastinst.h.

  Classes defined:
      CDecorationPart     Information about the origins of the object.
      CWbemObject          Any object --- class or instance.

History:

  3/10/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_WBEMOBJECT__H_
#define __FAST_WBEMOBJECT__H_

#include <assert.h>
#include <stddef.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "corepol.h"

#include "fastqual.h"
#include "fastprop.h"
#include "fastsys.h"
#include "strm.h"
#include "shmlock.h"
#include "shmem.h"
#include <genlex.h>
#include <objpath.h>

//!!! Enable verbose assertions if we are a checked build!
#ifdef DBG
#define FASTOBJ_ASSERT_ENABLE
#endif


#if (defined FASTOBJ_ASSERT_ENABLE)

HRESULT _RetFastObjAssert(TCHAR *msg, HRESULT hres, const char *filename, int line);
#define RET_FASTOBJ_ASSERT(hres, msg)  return _RetFastObjAssert(msg, hres, __FILE__, __LINE__)
#define FASTOBJ_ASSERT( hres, msg) _RetFastObjAssert(msg, hres, __FILE__, __LINE__)

#else

#define RET_FASTOBJ_ASSERT(msg, hres)  return hres
#define FASTOBJ_ASSERT(msg, hres)

#endif

//#pragma pack(push, 1)

#define INVALID_PROPERTY_INDEX 0x7FFFFFFF
#define WBEM_FLAG_NO_SEPARATOR 0x80000000

#define FAST_WBEM_OBJECT_SIGNATURE 0x12345678

// This is a workaround for faststr clients like ESS who
// may need to directly access raw bytes of object data.
// In those cases, if the blob is not properly aligned,
// on Alphas and possibly Win64 machines, wcslen, wcscpy
// and SysAllocString have a tendency to crash if the
// bytes are in *just* the right location at the end of
// a page boundary.  By *silently* padding our BLOBs with
// 4 extra bytes, we ensure that there will always be
// space at the end of the BLOB to prevent the aformentioned
// functions from inexplicably crashing.
#define ALIGN_FASTOBJ_BLOB(a)   a + 4

//*****************************************************************************
//*****************************************************************************
//
//  struct CDecorationPart
//
//  This class represents overall information about an object, including its
//  genus (class or instance) and origin (server and namespace).
//
//  The layout of the memory block (it is the first part of every object!) is:
//
//      BYTE fFlags     A combination of flags from the flag enumeration
//                      (below), it specifies whether the object is a class or
//                      an instance, as well as whether it is "decorated", i.e.
//                      contains the origin information. All objects that came
//                      from WINMGMT are decorated. Objects created by the client
//                      (via SpawnInstance, for example) are not.
//          If the flags specify that the object is not decorated, this is the
//          end of the structure. Otherwise, the following information follows:
//
//      CCompressedString csServer      The name of the server as a compressed
//                                      string (see faststr.h)
//      CCompressedString csNamespace   the full name of the namespace as a
//                                      compressed string (see faststr.h)
//
//*****************************************************************************
//
//  SetData
//
//  Initialization function.
//
//  PARAMETERS:
//
//      LPMEMORY pData      Points to the memory block of the part.
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   the memory block of the part.
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t:   the length of the memory block of the part.
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object of the new location of its memory block.
//
//  PARAMETERS:
//
//      LPMEMORY pData      The new location of the memory block.
//
//*****************************************************************************
//
//  IsDecorated
//
//  Checks if the object is decorated (as determined by the flag)
//
//  RETURN VALUES:
//
//      BOOL:   TRUE iff the origin information is present
//
//*****************************************************************************
//
//  IsInstance
//
//  Checks if the object is a class or an instance.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE iff the object is an instance.
//
//*****************************************************************************
//
//  static GetMinLength
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes required for an empty decoration part.
//
//*****************************************************************************
//
//  static ComuteNecessarySpace
//
//  Computes the number of bytes required for a decoration part with the given
//  server name and namespace name.
//
//  Parameters;
//
//      LPCWSTR wszServer       The name of the server to store.
//      LPCWSTR wszNamespace    The name of the namespace to store.
//
//  Returns;
//
//      length_t:   the number of bytes required
//
//*****************************************************************************
//
//  CreateEmpty
//
//  Creates an empty (undecorated) decoration part on a given block of memory
//
//  PARAMETERS:
//
//      BYTE byFlags            The value of the flags field to set.
//      LPMEMORY pWhere         The memory block to create in.
//
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the decoration part.
//
//*****************************************************************************
//
//  Create
//
//  Creates a complete (decorated) decoration part on a given block of memory.
//
//  PARAMETERS:
//
//      BYTE byFlags            The value of the flags field to set.
//      LPCWSTR wszServer       The name of the server to set.
//      LPCWSTR wszNamespace    The name of the namespace to set.
//      LPMEMORY pWhere         The memory block to create in.
//
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the decoration part.
//
//*****************************************************************************
//
//  CompareTo
//
//  Compares this decoration part to another decoration part.
//
//  PARAMETERS:
//
//      IN READONLY CDecorationPart& Other  The part to compare to.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE only if the flags are the same and the server and
//              namespace are the same to within the case.
//
//*****************************************************************************
enum
{
    OBJECT_FLAG_CLASS = WBEM_GENUS_CLASS,
    OBJECT_FLAG_INSTANCE = WBEM_GENUS_INSTANCE,
    OBJECT_FLAG_MASK_GENUS = 3,

    OBJECT_FLAG_UNDECORATED = 0,
    OBJECT_FLAG_DECORATED = 4,
    OBJECT_FLAG_MASK_DECORATION = 4,

    OBJECT_FLAG_COMPLETE = 0,
    OBJECT_FLAG_LIMITED = 0x10,
    OBJECT_FLAG_MASK_LIMITATION = 0x10,

    OBJECT_FLAG_CLIENT_ONLY = 0x20,
    OBJECT_FLAG_MASK_CLIENT_ONLY = 0x20,

    OBJECT_FLAG_KEYS_REMOVED = 0x40,
    OBJECT_FLAG_KEYS_PRESENT = 0,
    OBJECT_FLAG_MASK_KEY_PRESENCE = 0x40,
};

class COREPROX_POLARITY CDecorationPart
{
public:
    BYTE* m_pfFlags;
    CCompressedString* m_pcsServer;
    CCompressedString* m_pcsNamespace;

    CDecorationPart() : m_pfFlags(NULL) {}
     void SetData(LPMEMORY pData)
    {
        m_pfFlags = pData;
        if(IsDecorated())
        {
            m_pcsServer = (CCompressedString*)(pData + sizeof(BYTE));
            m_pcsNamespace = (CCompressedString*)
                (LPMEMORY(m_pcsServer) + m_pcsServer->GetLength());
        }
        else
        {
            m_pcsServer = m_pcsNamespace = NULL;
        }
    }
     BOOL IsDecorated()
        {return (*m_pfFlags & OBJECT_FLAG_DECORATED);}
     LPMEMORY GetStart() {return m_pfFlags;}
     length_t GetLength()
    {
        if(IsDecorated())
            return sizeof(BYTE) + m_pcsServer->GetLength() +
                                    m_pcsNamespace->GetLength();
        else
            return sizeof(BYTE);
    }
     void Rebase(LPMEMORY pNewMemory)
    {
        m_pfFlags = pNewMemory;
        if(IsDecorated())
        {
            m_pcsServer = (CCompressedString*)(pNewMemory + sizeof(BYTE));
            m_pcsNamespace = (CCompressedString*)
                (LPMEMORY(m_pcsServer) + m_pcsServer->GetLength());
        }
    }
    BOOL IsInstance()
    {return (*m_pfFlags & OBJECT_FLAG_MASK_GENUS) == OBJECT_FLAG_INSTANCE;}

    BOOL IsLimited()
    {return (*m_pfFlags & OBJECT_FLAG_MASK_LIMITATION) == OBJECT_FLAG_LIMITED;}
    BOOL IsClientOnly()
    {return (*m_pfFlags & OBJECT_FLAG_MASK_CLIENT_ONLY) == OBJECT_FLAG_CLIENT_ONLY;}
    BOOL AreKeysRemoved()
    {return (*m_pfFlags & OBJECT_FLAG_MASK_KEY_PRESENCE) == OBJECT_FLAG_KEYS_REMOVED;}
     void SetClientOnly()
    {
        *m_pfFlags &= ~OBJECT_FLAG_MASK_CLIENT_ONLY;
        *m_pfFlags |= OBJECT_FLAG_CLIENT_ONLY;
    }

     void SetLimited()
    {
        *m_pfFlags &= ~OBJECT_FLAG_MASK_LIMITATION;
        *m_pfFlags |= OBJECT_FLAG_LIMITED;
    }

public:
    static  length_t GetMinLength() {return sizeof(BYTE);}
    static  length_t ComputeNecessarySpace(LPCWSTR wszServer,
        LPCWSTR wszNamespace)
    {
        return sizeof(BYTE) +
            CCompressedString::ComputeNecessarySpace(wszServer) +
            CCompressedString::ComputeNecessarySpace(wszNamespace);
    }

     LPMEMORY CreateEmpty(BYTE byFlags, LPMEMORY pWhere)
    {
        m_pfFlags = pWhere;

        *m_pfFlags = (byFlags & ~OBJECT_FLAG_DECORATED);

        m_pcsServer = m_pcsNamespace = NULL;
        return pWhere + sizeof(BYTE);
    }

     void Create(BYTE fFlags, LPCWSTR wszServer, LPCWSTR wszNamespace,
        LPMEMORY pWhere)
    {
        m_pfFlags = pWhere;
        *m_pfFlags = fFlags | OBJECT_FLAG_DECORATED;

        m_pcsServer = (CCompressedString*)(pWhere + sizeof(BYTE));
        m_pcsServer->SetFromUnicode(wszServer);
        m_pcsNamespace = (CCompressedString*)
            (LPMEMORY(m_pcsServer) + m_pcsServer->GetLength());
        m_pcsNamespace->SetFromUnicode(wszNamespace);
    }
     BOOL CompareTo(CDecorationPart& Other)
    {
        if((m_pcsServer == NULL) != (Other.m_pcsServer == NULL))
            return FALSE;
        if(m_pcsServer && m_pcsServer->CompareNoCase(*Other.m_pcsServer))
            return FALSE;
        if((m_pcsNamespace == NULL) != (Other.m_pcsNamespace == NULL))
            return FALSE;
        if(m_pcsNamespace && m_pcsNamespace->CompareNoCase(*Other.m_pcsNamespace))
            return FALSE;
        return TRUE;
    }

    static BOOL MapLimitation(IN CWStringArray* pwsNames,
                       IN OUT CLimitationMapping* pMap);
    LPMEMORY CreateLimitedRepresentation(READ_ONLY CLimitationMapping* pMap,
                                         OUT LPMEMORY pWhere);
    static void MarkKeyRemoval(OUT LPMEMORY pWhere)
    {
        *pWhere &= ~OBJECT_FLAG_MASK_KEY_PRESENCE;
        *pWhere |= OBJECT_FLAG_KEYS_REMOVED;
    }
};

// Need to use Interlocked functions here
//#pragma pack(push, 4)


#define BLOB_SIZE_MAX	0x7FFFFFFF

class CBlobControl
{
public:
    virtual ~CBlobControl(){}
    virtual LPMEMORY Allocate(int nLength) = 0;
    virtual LPMEMORY Reallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength) = 0;
    virtual void Delete(LPMEMORY pOld) = 0;
};

class CGetHeap
{
private:
    HANDLE m_hHeap;
    BOOL   m_bNewHeap;
public:
    CGetHeap();
    ~CGetHeap();

    operator HANDLE(){ return m_hHeap; };
};

//
//  if you plan hooking the Allocation function in arena.cpp
//  beware that there few places where the heap is used 
//  throught the regular heap functions,
//  like WStringArray and _BtrMemAlloc
//

class CBasicBlobControl : public CBlobControl
{
public:

    static CGetHeap m_Heap;

    virtual LPMEMORY Allocate(int nLength)
	{
	    return sAllocate(nLength);
	}

    virtual LPMEMORY Reallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength)
    {
        return sReallocate(pOld,nOldLength,nNewLength);
    }
    virtual void Delete(LPMEMORY pOld)
    {
        return sDelete(pOld);
    }

    static LPMEMORY sAllocate(int nLength)
	{
		if ( ((DWORD) nLength) > BLOB_SIZE_MAX )
		{
			return NULL;
		}

		return (LPMEMORY)HeapAlloc(m_Heap,0,ALIGN_FASTOBJ_BLOB(nLength));
	}
    static LPMEMORY sReallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength)
    {
	    if ( ((DWORD) nNewLength)  > BLOB_SIZE_MAX )
	    {
	     return NULL;
   	    }

        LPMEMORY pNew = (LPMEMORY)HeapReAlloc( m_Heap, HEAP_ZERO_MEMORY, pOld, ALIGN_FASTOBJ_BLOB(nNewLength) );

        return pNew;
    }
    static void sDelete(LPMEMORY pOld)
    {
        HeapFree(m_Heap,0,pOld);
    }
    
};

extern CBasicBlobControl g_CBasicBlobControl;

class CCOMBlobControl : public CBlobControl
{
public:
    virtual LPMEMORY Allocate(int nLength)
	{
		if ( ((DWORD) nLength)  > BLOB_SIZE_MAX )
		{
			return NULL;
		}

		return (LPMEMORY) CoTaskMemAlloc(ALIGN_FASTOBJ_BLOB(nLength));
	}

    virtual LPMEMORY Reallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength)
    {

		if ( ((DWORD) nNewLength)  > BLOB_SIZE_MAX )
		{
			return NULL;
		}

        // CoTaskMemRealloc will copy and free memory as needed
        return (LPMEMORY) CoTaskMemRealloc( pOld, ALIGN_FASTOBJ_BLOB(nNewLength) );
    }
    virtual void Delete(LPMEMORY pOld)
    {
        CoTaskMemFree( pOld );
    }
};

extern CCOMBlobControl g_CCOMBlobControl;

struct COREPROX_POLARITY SHMEM_HANDLE
{
    DWORD m_dwBlock;
    DWORD m_dwOffset;
};

struct COREPROX_POLARITY SHARED_OBJECT_CONTROL
{
    SHARED_LOCK_DATA m_LockData;
    long m_lBlobLength;
    SHMEM_HANDLE m_hObjectBlob;
};
/*
class COREPROX_POLARITY CSharedBlobControl : public CBlobControl
{
protected:
    SHARED_OBJECT_CONTROL* m_pControl;
public:
    CSharedBlobControl(LPVOID pLocation) :
        m_pControl((SHARED_OBJECT_CONTROL*)pLocation)
    {}
    virtual LPMEMORY Allocate(int nLength);
    virtual LPMEMORY Reallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength);
    virtual void Delete(LPMEMORY pOld);
};
*/

class COREPROX_POLARITY CDerivationList : public CCompressedStringList
{
public:
    static  LPMEMORY Merge(CCompressedStringList& cslParent,
                                 CCompressedStringList& cslChild,
                                 LPMEMORY pDest)
    {
        LPMEMORY pCurrent = pDest + GetHeaderLength();
        pCurrent = cslChild.CopyData(pCurrent);
        pCurrent = cslParent.CopyData(pCurrent);

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  We do not support length
        // > 0xFFFFFFFF so cast is ok.

        *(UNALIGNED length_t*)pDest = (length_t) ( pCurrent - pDest );

        return pCurrent;
    }

     LPMEMORY Unmerge(LPMEMORY pDest)
    {
        CCompressedString* pcsFirst = GetFirst();
        LPMEMORY pCurrent = pDest + GetHeaderLength();
        if(pcsFirst != NULL)
        {
            int nLength = pcsFirst->GetLength() + GetSeparatorLength();
            memcpy(pCurrent, (LPMEMORY)pcsFirst, nLength);
            pCurrent += nLength;
        }

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  We do not support length
        // > 0xFFFFFFFF so cast is ok.

        *(UNALIGNED length_t*)pDest = (length_t) ( pCurrent - pDest );
        return pCurrent;
    }

    LPMEMORY CreateLimitedRepresentation(CLimitationMapping* pMap,
                                                LPMEMORY pWhere);
};

// Forward class definitions
class CWmiArray;

//*****************************************************************************
//*****************************************************************************
//
//  class CWbemObject
//
//  This is the base class for both Wbem instances (represented by CWbemInstance
//  in fastinst.h) and Wbem classes (represented by CWbemClass in fastcls.h).
//
//  It handles all the functionality that is common between the two and defines
//  virtual functions to be used by internal code that does not wish to
//  distinguish between classes and instances.
//
//  This class does not have a well-defined memory block, since classes and
//  instances have completely different formats. But every memory block of an
//  object starts with a decoration part (as represented by CDecorationPart
//  above.
//
//  CWbemObject also effects memory allocation for classes and instances. There
//  is a provision for a CWbemObject on a memory block it does not own (and
//  should ne deallocate), but it is not used.
//
//*****************************************************************************
//**************************** protected interface ****************************
//
//  Reallocate
//
//  Called by derived classes when they need to extend the size of the memory
//  block, this function allocates a new block of memory and deletes the old
//  one.
//
//  PARAMETERS:
//
//      length_t nNewLength     The number of bytes to allocate.
//
//  RETURN VALUES:
//
//      LPMEMORY:   pointer to the memory block
//
//*****************************************************************************
//
//  GetStart
//
//  Returns the pointer to the memory block of the object.
//
//  RETURN VALUES:
//
//      LPMEMORY
//
//*****************************************************************************
//
//  PURE GetBlockLength
//
//  Defined by derived classes to return the length of their memory block.
//
//  RETURN VALUES:
//
//      length_t:   the length
//
//*****************************************************************************
//
//  PURE GetClassPart
//
//  Defined by derived classes to return the pointer to the CClassPart object
//  describing the class of the object. See CWbemClass and CWbemInstance for
//  details on how that information is stored.
//
//  RETURN VALUES:
//
//      CClassPart*: pointer to the class part describing this class.
//
//*****************************************************************************
//
//  PURE GetProperty
//
//  Defined by derived classes to get the value of the property referenced
//  by a given CPropertyInformation structure (see fastprop.h). CWbemObject
//  can obtain this structure from the CClassPart it can get from GetClassPart,
//  so these two methods combined give CWbemObject own methods full access to
//  object properties, without knowing where they are stored.
//
//  PARAMETERS:
//
//      IN CPropertyInformation* pInfo  The information structure for the
//                                      desired property.
//      OUT CVar* pVar                  Destination for the value. Must NOT
//                                      already contain a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      (No errors can really occur at this stage, since the property has
//      already been "found").
//
//*****************************************************************************
//****************************** Persistence interface ************************
//
//  WriteToStream
//
//  Writes a serialized representation of the object into a CMemStream (see
//  strm.h). Since our objects are always represented serially, this is nothing
//  more than a couple of memcpys.
//
//  The format of an object in the stream consists of a signature, the length
//  of the block, and the block itself.
//
//  PARAMETERS:
//
//      CMemStream* pStream      The stream to write to.
//
//  RETURN VALUES:
//
//      int:    Any of CMemStream return codes (see strm.h),
//              CMemStream::no_error for success.
//
//*****************************************************************************
//
//  static CreateFromStream
//
//  Reads an object representation from a stream (see WriteStream for format)
//  and creates a CWbemObject corresponding to it.
//
//  Parameters I:
//
//      CMemStream* pStream     The stream to read from.
//
//  Parameters II:
//
//      IStream* pStream        The stream to read from
//
//  RETURN VALUES:
//
//      CWbemObject*:    representing the object, or NULL on error.
//
//*****************************************************************************
//
//  PURE EstimateUnmergeSpace
//
//  When objects are stored into the database, only those parts of them that
//  are different from the parent object (parent class for classes, class for
//  instances) are stored. This function is defined by derived classes to
//  calculate the amount of space needed for such an unmerged representation
//  of the object.
//
//  RETURN VALUES:
//
//      length_t:       the number of bytes required. May be an overestimate.
//
//*****************************************************************************
//
//  PURE Unmerge
//
//  When objects are stored into the database, only those parts of them that
//  are different from the parent object (parent class for classes, class for
//  instances) are stored. This function is defined by derived classes to
//  create such an unmerged representation of the object on a given memory
//  block.
//
//  PARAMETERS:
//
//      LPMEMORY pBlock                 The memory block. Assumed to be large
//                                      enough to contain all the data.
//      int nAllocatedSpace             The size of the block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   points to the firsy byte after the object
//
//*****************************************************************************
//
//  Unmerge
//
//  A helper function for internal clients. Combines the functionality of
//  EstimateUnmergeSpace and Unmerge to allocate enough memory, create an
//  unmerge, and return the pointer to the caller.
//
//  PARAMETERS:
//
//      OUT LPMEMORY* pBlock        Destination for the newely allocated block.
//                                  The caller is responsible for deleting it
//                                  (delete *pBlock).
//  RETURN VALUES:
//
//      length_t:   the allocated length of the returned block.
//
//*****************************************************************************
//************************* internal public interface *************************
//
//  PURE GetProperty
//
//  Implemented by derived classes to return the value of a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the property to access.
//      OUT CVar* pVar          Destination for the value. Must not already
//                              contain a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the proeprty to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      CPropertyInformation*   pInfo - Identifies property to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  PURE SetPropValue
//
//  Implemented by derived classes to set the value of the property. In the
//  case of a class, the property will be added if not already present.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property to set.
//      IN CVar *pVal           The value to store in the property.
//      IN CIMTYPE ctType       specifies the actual type of the property.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property in the instance.
//      WBEM_E_TYPE_MISMATCH     The value does not match the property type
//
//*****************************************************************************
//
//  PURE SetPropQualifier
//
//  Implemented by derived classes to set the value of a given qualifier on
//  a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      IN long lFlavor         The flavor for the qualifier (see fastqual.h)
//      IN CVar *pVal           The value of the qualifier
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property.
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  PURE GetPropQualifier
//
//  Retrieves the value of a given qualifier on a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      OUT CVar* pVar          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property or no such qualifier.
//
//*****************************************************************************
//
//  PURE GetQualifier
//
//  Retrieves a qualifier from the object itself, that is,either an instance or
//  a class qualifier.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve.
//      OUT CVar* pVal          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//      IN BOOL fLocalOnly      Only retrieve local qualifiers
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such qualifier.
//
//*****************************************************************************
//
//  PURE GetNumProperties
//
//  Retrieves the number of properties in the object
//
//  RETURN VALUES:
//
//      int:
//
//*****************************************************************************
//
//  PURE GetPropName
//
//  Retrieves the name of the property at a given index. This index has no
//  meaning except inthe context of this enumeration. It is NOT the v-table
//  index of the property.
//
//  PARAMETERS:
//
//      IN int nIndex        The index of the property to retrieve. Assumed to
//                           be within range (see GetNumProperties).
//      OUT CVar* pVar       Destination for the name. Must not already contain
//                           a value.
//
//*****************************************************************************
//
//  GetSystemProperty
//
//  Retrieves a system property by its index (see fastsys.h).
//
//  PARAMETERS:
//
//      int nIndex          The index of the system property (see fastsys.h)
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         Invalid index or this system property is not
//                              defined in this object.
//      WBEM_E_UNDECORATED_OBJECT    This object has no origin information (see
//                                  CDecorationPart) and therefore does not
//                                  have decoration-related properties.
//
//*****************************************************************************
//
//  GetSystemPropertyByName
//
//  Retrieves a system property by its name (e.g. "__CLASS"). See fastsys.h
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName  The name of the property to access.
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         Invalid name or this system property is not
//                              defined in this object.
//      WBEM_E_UNDECORATED_OBJECT    This object has no origin information (see
//                                  CDecorationPart) and therefore does not
//                                  have decoration-related properties.
//
//*****************************************************************************
//
//  PURE IsKeyed
//
//  Defined by derived classes to verify if this object has keys.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if the object either has 'key' properties or is singleton.
//
//*****************************************************************************
//
//  PURE GetRelPath
//
//  Defined by derived classes to determine the relative path of the object.
//
//  RETURN VALUES:
//
//      LPWSTR: the newnely allocated string containing the path or NULL on
//              errors. The caller must delete this string.
//
//*****************************************************************************
//
//  GetFullPath
//
//  Returns the complete path to the object, assuming the object is decorated,
//  or NULL on errors.
//
//  RETURN VALUES:
//
//      LPWSTR: the complete path or NULL. The caller must delete this string.
//
//*****************************************************************************
//
//  PURE Decorate
//
//  Defined by derived classes to set the origin information for the object.
//
//  PARAMETERS:
//
//      LPCWSTR wszServer       the name of the server to set.
//      LPCWSTR wszNamespace    the name of the namespace to set.
//
//*****************************************************************************
//
//  PURE Undecorate
//
//  Defined by derived classes to remove the origin informaiton from the object
//
//*****************************************************************************
//
//  HasRefs
//
//  Checks if the object has properties which are references.
//
//  Returns;
//
//      BOOL: TRUE if it does.
//
//*****************************************************************************
//
//  GetRefs
//
//  Returns the list of names and values for the properties that are references
//  to other objects.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aRefList     Destination for the values of the
//                                      properties which are references.
//                                      Assumed to be empty.
//      OUT CWStringArray *pPropNames   If not NULL, destination for the
//                                      names of the properties which are
//                                      references in the same order as in
//                                      aRefList
//
//*****************************************************************************
//
//  GetClassRefs
//
//  Returns the list of names and values for the properties that are references
//  to other classes.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aRefList     Destination for the values of the
//                                      properties which are references.
//                                      Assumed to be empty.
//      OUT CWStringArray *pPropNames   If not NULL, destination for the
//                                      names of the properties which are
//                                      references in the same order as in
//                                      aRefList
//
//*****************************************************************************
//
//  PURE GetIndexedProps
//
//  Returns the array of the names of all the proeprties that are indexed.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  PURE GetKeyProps
//
//  Returns the array of the names of all the proeprties that are keys.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyOrigin
//
//  Returns the name of the class of origin of the keys.
//
//  PARAMETERS:
//
//      OUT CWString& wsClass       Destination for the name.
//
//*****************************************************************************
//
//  IsInstance
//
//  Checks the genus of the object to see if it is a class or an instance.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if it is an instance
//
//*****************************************************************************
//
//  IsLimited
//
//  Checks if this object is complete or limited, i.e. the result of a
//  projection --- some properties and/or qualifiers are missing. There are
//  many restrictions placed on the use of such objects in the system.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if the object is limited.
//
//*****************************************************************************
//
//  PURE CompactAll
//
//  Implememnted by derived classes to compact their memory block removing any
//  holes between components. This does not include heap compaction and thus
//  is relatively fast.
//
//*****************************************************************************
//
//  GetServer
//
//  Retrieves the name of the server from the decoration part of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_S_UNDECORATED_OBJECT    If decoration information is not set.
//
//*****************************************************************************
//
//  GetNamespace
//
//  Retrieves the name of the namespace from the decoration part of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_S_UNDECORATED_OBJECT    If decoration information is not set.
//
//*****************************************************************************
//
//  GetRelPath
//
//  Retrieves the relative path of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_S_INVALID_OBJECT    If some of the key proeprties do not have
//                              values or the class is not keyed.
//
//*****************************************************************************
//
//  GetPath
//
//  Retrieves the full path of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_S_INVALID_OBJECT        If some of the key proeprties do not have
//                                  values or the class is not keyed.
//      WBEM_S_UNDECORATED_OBJECT    If decoration information is not set.
//
//*****************************************************************************
//
//  PURE GetGenus
//
//  Retrieves the genus of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  PURE GetClassName
//
//  Retrieves the class name of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  PURE GetDynasty
//
//  Retrieves the dynasty of the object, i.e. the name of the top-level class
//  its class is derived from.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  PURE GetSuperclassName
//
//  Retrieves the parent class name of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class is a top-levle class.
//
//*****************************************************************************
//
//  PURE GetPropertyCount
//
//  Retrieves the number of proerpties in the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  EstimateLimitedRepresentationLength
//
//  Estimates the amount of space that a limited representation of an object
//  will take. A limited representation is one with certain properties and/or
//  qualifiers removed from the object.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//  RETURN VALUES:
//
//      length_t:   an (over-)estimate for the amount of space required
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Creates a limited representation of the object on a given block of memory
//  as described in EstimateLimitedRepresentationLength above.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      IN nAllocatedSize           The size of the memory block allocated for
//                                  the operation --- pDest.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not any localization bits have been set.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL    TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the appropriate spot.
//
//  PARAMETERS:
//
//      BOOL    TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************
//****************************** IWbemClassObject interface ********************
//
//  This interface is documented in the help file.
//
//*****************************************************************************
//****************************** IMarshal interface ***************************
//
//  CWbemObject implements standard COM IMarshal interface. The idea is to keep
//  CWbemObjects local and never marshal individual calls for properties and
//  such. So, whenever a pointer to CWbemObject needs to be marshalled across
//  process boundaries (when an object is being sent to the client or when the
//  client calls something like PutInstance), we want to simply send all the
//  object data to the destination so that any subsequent access to the object
//  by the callee would be local.
//
//  To accomplish this in COM, we implement our own IMarshal which does the
//  following (THIS IS NOT A HACK --- THIS IS THE PROPER COM WAY OF
//  ACCOMPLISHING WHAT WE WANT, AS DOCUMENTED IN BROCKSCHMIDT).
//
//*****************************************************************************
//
//  GetUnmarshalClass
//
//  Returns CLSID_WbemClassObjectProxy. This class ID points to the DLL containg
//  this very code.
//
//*****************************************************************************
//
//  MarshalInterface
//
//  By COM rules, this function is supposed to write enough information to a
//  stream to allow the proxy to connect back to the original object. Since we
//  don't want the proxy to connect and want it to be able to field all
//  questions by itself, we simply write the serialized representation of the
//  object into the stream.
//
//*****************************************************************************
//
//  UnmarshalInterface
//
//  This method is never called on an actual CWbemObject, since the object
//  ontainable at our UnmarshalClass is actually a CFastProxy (see fastprox.h
//  under marshalers\fastprox).
//
//*****************************************************************************
//
//  ReleaseMarsalData
//
//  This method is never called on an actual CWbemObject, since the object
//  ontainable at our UnmarshalClass is actually a CFastProxy (see fastprox.h
//  under marshalers\fastprox).
//
//*****************************************************************************
//
//  DisconnectObject
//
//  This method is never called on an actual CWbemObject, since the object
//  ontainable at our UnmarshalClass is actually a CFastProxy (see fastprox.h
//  under marshalers\fastprox).
//
//*****************************************************************************
//************************** IWbemPropertySource *******************************
//
//  GetPropertyValue
//
//  Retrieves a property value given the complex property name --- this can
//  include embeddeed object references and array references.
//
//  Parameters:
//
//      IN WBEM_PROPERTY_NAME* pName     The structure containing the name of the
//                                      property to retrieve. See providl.idl
//                                      for more information.
//      IN long lFlags                  Reserved.
//      OUT LPWSTR* pwszCimType         Destination for the CIM type of the
//                                      property, i.e. "sint32" or
//                                      "ref:MyClass". If NULL, not supplied.
//                                      If not NULL, the caller must call
//                                      CoTaskFree.
//      OUT VARIANT* pvValue            Destination for the value. Must not
//                                      contain releasable information on entry.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     No such property
//
//*****************************************************************************

#define ARRAYFLAVOR_USEEXISTING	0xFFFFFFFF

// Forward declarations
class	CUmiPropertyArray;
class	CUmiProperty;

class COREPROX_POLARITY CWbemObject : public _IWmiObject, public IMarshal,
                   public IWbemPropertySource, public IErrorInfo,
                   public IWbemConstructClassObject,
                   //, public IUmiPropList,
				   public IWbemClassObjectEx
{
/*
private:
    static CWbemSharedMem mstatic_SharedMem;
*/    

public:
    int m_nRef;
protected:
    BOOL m_bOwnMemory;
    int m_nCurrentProp;
    long m_lEnumFlags;
	long m_lExtEnumFlags;

    // _IWmiObject Data

    //WBEM_OBJINTERNALPARTS_INFO
    DWORD m_dwInternalStatus;

    // Maintains a pointer to a WbemClassObject we are merged with.  This means we
    // are sharing pointers into the other class object's BLOB.
    IWbemClassObject*   m_pMergedClassObject;


    CDecorationPart m_DecorationPart;

    SHARED_LOCK_DATA m_LockData;
    CSharedLock m_Lock;
    CBlobControl* m_pBlobControl;

    CDataTable& m_refDataTable;
    CFastHeap& m_refDataHeap;
    CDerivationList& m_refDerivationList;

protected:
    CWbemObject(CDataTable& refDataTable, CFastHeap& refDataHeap,
                CDerivationList& refDerivationList);

    LPMEMORY Reallocate(length_t nNewLength)
    {
        return m_pBlobControl->Reallocate(GetStart(), GetBlockLength(),
                        nNewLength);
    }


    virtual HRESULT GetProperty(CPropertyInformation* pInfo,
        CVar* pVar) = 0;

    virtual CClassPart* GetClassPart() = 0;

    // Rerouting targets for object validation
    static HRESULT EnabledValidateObject( CWbemObject* pObj );
    static HRESULT DisabledValidateObject( CWbemObject* pObj );

	HRESULT LocalizeQualifiers(BOOL bInstance, bool bParentLocalized,
							IWbemQualifierSet *pBase, IWbemQualifierSet *pLocalized,
							bool &bChg);

	HRESULT LocalizeProperties(BOOL bInstance, bool bParentLocalized, IWbemClassObject *pOriginal,
								IWbemClassObject *pLocalized, bool &bChg);

public:
/*
    HRESULT MoveToSharedMemory();
*/    

    LPMEMORY GetStart() {return m_DecorationPart.GetStart();}
    virtual DWORD GetBlockLength() = 0;

    // These three functions return NULL in OOM and error
    // conditions
    static CWbemObject* CreateFromStream(CMemStream* pStrm);
    static CWbemObject* CreateFromStream(IStream* pStrm);
    static CWbemObject* CreateFromMemory(LPMEMORY pMemory, int nLength,
        BOOL bAcquire);

    int WriteToStream(CMemStream* pStrm);
    virtual HRESULT WriteToStream( IStream* pStrm );
    virtual HRESULT GetMaxMarshalStreamSize( ULONG* pulSize );

    virtual length_t EstimateUnmergeSpace() = 0;
    virtual HRESULT Unmerge(LPMEMORY pStart, int nAllocatedLength, length_t* pnUnmergedLength) = 0;

    // We will throw exceptions in OOM scenarios.

    length_t Unmerge(LPMEMORY* ppStart);

    virtual ~CWbemObject();
public:
    // Quick 'get' and 'set' functions.
    // ===============================
    virtual HRESULT GetProperty(LPCWSTR wszName, CVar* pVal) = 0;
    virtual HRESULT GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                    long* plFlavor = NULL) = 0;
    virtual HRESULT GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                    long* plFlavor = NULL) = 0;

    virtual HRESULT SetPropValue(LPCWSTR wszProp, CVar *pVal,
        CIMTYPE ctType) = 0;
    virtual HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CVar *pVal) = 0;
    virtual HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal) = 0;

    virtual HRESULT GetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL) = 0;
    virtual HRESULT GetPropQualifier(CPropertyInformation* pInfo,
        LPCWSTR wszQualifier, CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL) = 0;

    virtual HRESULT GetPropQualifier(LPCWSTR wszName, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet) = 0;
    virtual HRESULT GetPropQualifier(CPropertyInformation* pInfo,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet) = 0;

    virtual HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL) = 0;
    virtual HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet) = 0;
    virtual HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal) = 0;
    virtual HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal) = 0;
	virtual HRESULT FindMethod( LPCWSTR wszMethod );

    virtual HRESULT GetQualifier(LPCWSTR wszName, CVar* pVal,
        long* plFlavor = NULL, CIMTYPE* pct = NULL ) = 0;
    virtual HRESULT GetQualifier(LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet) = 0;
    virtual HRESULT SetQualifier(LPCWSTR wszName, long lFlavor, CTypedValue* pTypedVal ) = 0;
    virtual HRESULT SetQualifier(LPCWSTR wszName, CVar* pVal,
        long lFlavor = 0) = 0;

    virtual BOOL IsLocalized( void ) = 0;
    virtual void SetLocalized( BOOL fLocalized ) = 0;

    virtual int GetNumProperties() = 0;
    virtual HRESULT GetPropName(int nIndex, CVar* pVal) = 0;

    HRESULT GetSystemProperty(int nIndex, CVar* pVar);
    HRESULT GetSystemPropertyByName(LPCWSTR wszName, CVar* pVar)
    {
        int nIndex = CSystemProperties::FindName(wszName);
        if(nIndex < 0) return WBEM_E_NOT_FOUND;
        return GetSystemProperty(nIndex, pVar);
    }
    HRESULT GetDerivation(CVar* pVar);

    virtual BOOL IsKeyed() = 0;
    virtual LPWSTR GetRelPath( BOOL bNormalized=FALSE ) = 0;

    LPWSTR GetFullPath();

    virtual HRESULT Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace) = 0;
    virtual void Undecorate() = 0;

    BOOL GetRefs(
        OUT CWStringArray& aRefList,
        OUT CWStringArray *pPropNames = 0
        );
    BOOL GetClassRefs(
        OUT CWStringArray& aRefList,
        OUT CWStringArray *pPropNames = 0
        );

    BOOL HasRefs();

    virtual  BOOL GetIndexedProps(CWStringArray& awsNames) = 0;
    virtual  BOOL GetKeyProps(CWStringArray& awsNames) = 0;
    virtual  HRESULT GetKeyOrigin(WString& wsClass) = 0;

    length_t EstimateLimitedRepresentationSpace(
        IN long lFlags,
        IN CWStringArray* pwsNames)
    {
        return (length_t)GetBlockLength();
    }

    HRESULT GetServer(CVar* pVar);
    HRESULT GetNamespace(CVar* pVar);
    HRESULT GetServerAndNamespace( CVar* pVar );
    HRESULT GetPath(CVar* pVar);
    HRESULT GetRelPath(CVar* pVar);

    int GetNumParents()
    {
        return m_refDerivationList.GetNumStrings();
    }

    INTERNAL CCompressedString* GetParentAtIndex(int nIndex)
    {
        return m_refDerivationList.GetAtFromLast(nIndex);
    }
    INTERNAL CCompressedString* GetClassInternal();
    INTERNAL CCompressedString* GetPropertyString(long lHandle);
    HRESULT GetArrayPropertyHandle(LPCWSTR wszPropertyName,
                                            CIMTYPE* pct,
                                            long* plHandle);
    INTERNAL CUntypedArray* GetArrayByHandle(long lHandle);
	INTERNAL heapptr_t GetHeapPtrByHandle(long lHandle);

    CWbemObject* GetEmbeddedObj(long lHandle);

    virtual HRESULT GetGenus(CVar* pVar) = 0;
    virtual HRESULT GetClassName(CVar* pVar) = 0;
    virtual HRESULT GetDynasty(CVar* pVar) = 0;
    virtual HRESULT GetSuperclassName(CVar* pVar) = 0;
    virtual HRESULT GetPropertyCount(CVar* pVar) = 0;

    BOOL IsInstance()
    {
       return m_DecorationPart.IsInstance();
    }

    BOOL IsLimited()
    {
       return m_DecorationPart.IsLimited();
    }

    BOOL IsClientOnly()
    {
       return m_DecorationPart.IsClientOnly();
    }

    void SetClientOnly()
    {
       m_DecorationPart.SetClientOnly();
    }

	BOOL CheckBooleanPropQual( LPCWSTR pwszPropName, LPCWSTR pwszQualName );

    virtual void CompactAll()  = 0;
    virtual HRESULT CopyBlobOf(CWbemObject* pSource) = 0;
/*
    // Static debugging helpers
#ifdef DEBUG
    static HRESULT ValidateObject( CWbemObject* pObj );
#else
    static HRESULT ValidateObject( CWbemObject* pObj ) { return WBEM_S_NO_ERROR; }
#endif
*/
    static void EnableValidateObject( BOOL fEnable );

    virtual HRESULT IsValidObj( void ) = 0;

// DEVNOTE:TODO:MEMORY - We should change this header to return an HRESULT
    BOOL ValidateRange(BSTR* pstrName);

    virtual void SetData(LPMEMORY pData, int nTotalLength) = 0;

    static DELETE_ME LPWSTR GetValueText(long lFlags, READ_ONLY CVar& vValue,
                                            Type_t nType = 0);
    HRESULT ValidatePath(ParsedObjectPath* pPath);

	// Qualifier Array Support Functions
    HRESULT SetQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod, long lFlags,
									ULONG uflavor, CIMTYPE ct, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
									LPVOID pData );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

	HRESULT AppendQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, CIMTYPE ct, ULONG uNumElements, ULONG uBuffSize, LPVOID pData );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

	HRESULT RemoveQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, ULONG uStartIndex, ULONG uNumElements );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

	HRESULT GetQualifierArrayInfo( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, CIMTYPE* pct, ULONG* puNumElements );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

    HRESULT GetQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
									long lFlags, ULONG uStartIndex,	ULONG uNumElements, ULONG uBuffSize,
									ULONG* puNumReturned, ULONG* pulBuffUsed, LPVOID pData );
    // Gets a range of elements from inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
	// of the current array.

	// Helper function to get the actual index of a class
	classindex_t GetClassIndex( LPCWSTR pwszClassName );

	// Helper function to get a CWbemObject from IWbemClassObject;
	static HRESULT WbemObjectFromCOMPtr( IUnknown* pUnk, CWbemObject** ppObj );

	// UMI Helper functions
	HRESULT GetIntoArray( CUmiPropertyArray* pArray, LPCWSTR pszName, ULONG uFlags );
	HRESULT PutUmiProperty( CUmiProperty* pProp, LPCWSTR pszName, ULONG uFlags );

	// System Time proeprty helper functions
	//HRESULT InitSystemTimeProps( void );

public:

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    /* IWbemClassObject methods */
    STDMETHOD(GetQualifierSet)(IWbemQualifierSet** pQualifierSet) = 0;
    STDMETHOD(Get)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
        long* plFlavor);

    STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType) = 0;
    STDMETHOD(Delete)(LPCWSTR wszName) = 0;
    STDMETHOD(GetNames)(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                        SAFEARRAY** pNames);
    STDMETHOD(BeginEnumeration)(long lEnumFlags);

    STDMETHOD(Next)(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                    long* plFlavor);

    STDMETHOD(EndEnumeration)();

    STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty,
                                       IWbemQualifierSet** pQualifierSet) = 0;
    STDMETHOD(Clone)(IWbemClassObject** pCopy) = 0;
    STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax) = 0;

    STDMETHOD(CompareTo)(long lFlags, IWbemClassObject* pCompareTo);
    STDMETHOD(GetPropertyOrigin)(LPCWSTR wszProperty, BSTR* pstrClassName);
    STDMETHOD(InheritsFrom)(LPCWSTR wszClassName);

    /* IWbemPropertySource methods */

    STDMETHOD(GetPropertyValue)(WBEM_PROPERTY_NAME* pName, long lFlags,
        WBEM_WSTR* pwszCimType, VARIANT* pvValue);

    // IMarshal methods

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv,
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

    // IErrorInfo methods

    STDMETHOD(GetDescription)(BSTR* pstrDescription);
    STDMETHOD(GetGUID)(GUID* pguid);
    STDMETHOD(GetHelpContext)(DWORD* pdwHelpContext);
    STDMETHOD(GetHelpFile)(BSTR* pstrHelpFile);
    STDMETHOD(GetSource)(BSTR* pstrSource);

    // IWbemConstructClassObject methods
    // =================================

    STDMETHOD(SetInheritanceChain)(long lNumAntecedents,
        LPWSTR* awszAntecedents) = 0;
    STDMETHOD(SetPropertyOrigin)(LPCWSTR wszPropertyName, long lOriginIndex) = 0;
    STDMETHOD(SetMethodOrigin)(LPCWSTR wszMethodName, long lOriginIndex) = 0;
    STDMETHOD(SetServerNamespace)(LPCWSTR wszServer, LPCWSTR wszNamespace);

    // IWbemObjectAccess

    STDMETHOD(GetPropertyHandle)(LPCWSTR wszPropertyName, CIMTYPE* pct,
        long *plHandle);

    STDMETHOD(WritePropertyValue)(long lHandle, long lNumBytes,
                const byte *pData);
    STDMETHOD(ReadPropertyValue)(long lHandle, long lBufferSize,
        long *plNumBytes, byte *pData);

    STDMETHOD(ReadDWORD)(long lHandle, DWORD *pdw);
    STDMETHOD(WriteDWORD)(long lHandle, DWORD dw);
    STDMETHOD(ReadQWORD)(long lHandle, unsigned __int64 *pqw);
    STDMETHOD(WriteQWORD)(long lHandle, unsigned __int64 qw);

    STDMETHOD(GetPropertyInfoByHandle)(long lHandle, BSTR* pstrName,
             CIMTYPE* pct);

    STDMETHOD(Lock)(long lFlags);
    STDMETHOD(Unlock)(long lFlags);

    HRESULT IsValidPropertyHandle( long lHandle );

/*
    static CWbemSharedMem& GetSharedMemory();
*/    
    static BOOL AreEqual(CWbemObject* pObj1, CWbemObject* pObj2,
                            long lFlags = 0);

    HRESULT GetPropertyNameFromIndex(int nIndex, BSTR* pstrName);
    HRESULT GetPropertyIndex(LPCWSTR wszName, int* pnIndex);

    BOOL IsSameClass(CWbemObject* pOther);
	HRESULT IsArrayPropertyHandle( long lHandle, CIMTYPE* pctIntrinisic, length_t* pnLength );

	// _IWmiObjectAccessEx methods
    // =================================
    STDMETHOD(GetPropertyHandleEx)( LPCWSTR pszPropName, long lFlags, CIMTYPE* puCimType, long* plHandle );
	// Returns property handle for ALL types

    STDMETHOD(SetPropByHandle)( long lHandle, long lFlags, ULONG uDataSize, LPVOID pvData );
	// Sets properties using a handle.  If pvData is NULL, it NULLs the property.
	// Can set an array to NULL.  To set actual data use the corresponding array
	// function.  Objects must be pointers to _IWmiObject pointers.

    STDMETHOD(GetPropAddrByHandle)( long lHandle, long lFlags, ULONG* puFlags, LPVOID *pAddress );
    // Returns a pointer to a memory address containing the requested data
	// Caller should not write into the memory address.  The memory address is
	// not guaranteed to be valid if the object is modified.
	// For String properties, puFlags will contain info on the string
	// For object properties, LPVOID will get back an _IWmiObject pointer
	// that must be released by the caller.  Does not return arrays.

    STDMETHOD(GetArrayPropInfoByHandle)( long lHandle, long lFlags, BSTR* pstrName,
										CIMTYPE* pct, ULONG* puNumElements );
    // Returns a pointer directly to a memory address containing contiguous
	// elements.  Limited to non-string/obj types

    STDMETHOD(GetArrayPropAddrByHandle)( long lHandle, long lFlags, ULONG* puNumElements, LPVOID *pAddress );
    // Returns a pointer directly to a memory address containing contiguous
	// elements.  Limited to non-string/obj types

    STDMETHOD(GetArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement, ULONG* puFlags,
				ULONG* puNumElements, LPVOID *pAddress );
    // Returns a pointer to a memory address containing the requested data
	// Caller should not write into the memory address.  The memory address is
	// not guaranteed to be valid if the object is modified.
	// For String properties, puFlags will contain info on the string
	// For object properties, LPVOID will get back an _IWmiObject pointer
	// that must be released by the caller.

    STDMETHOD(SetArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement, ULONG uBuffSize,
				LPVOID pData );
    // Sets the data at the specified array element.  BuffSize must be appropriate based on the
	// actual element being set.  Object properties require an _IWmiObject pointer.  Strings must
	// be WCHAR null-terminated

    STDMETHOD(RemoveArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement );
    // Removes the data at the specified array element.

    STDMETHOD(GetArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex,
				ULONG uNumElements, ULONG uBuffSize, ULONG* puNumReturned, ULONG* pulBuffUsed,
				LPVOID pData );
    // Gets a range of elements from inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
	// of the current array.

    STDMETHOD(SetArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex,
				ULONG uNumElements, ULONG uBuffSize, LPVOID pData );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

    STDMETHOD(RemoveArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex, ULONG uNumElements );
    // Removes a range of elements from an array.  The range MUST fit within the bounds
	// of the current array

    STDMETHOD(AppendArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uNumElements,
				ULONG uBuffSize, LPVOID pData );
    // Appends elements to the end of an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.


    STDMETHOD(ReadProp)( LPCWSTR pszPropName, long lFlags, ULONG uBuffSize, CIMTYPE *puCimType,
							long* plFlavor, BOOL* pfIsNull, ULONG* puBuffSizeUsed, LPVOID pUserBuf );
    // Assumes caller knows prop type; Objects returned as _IWmiObject pointers.  Strings
	// returned as WCHAR Null terminated strings, copied in place.  Arrays returned as _IWmiArray
	// pointer.  Array pointer used to access actual array values.

    STDMETHOD(WriteProp)( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
							CIMTYPE uCimType, LPVOID pUserBuf );
    // Assumes caller knows prop type; Supports all CIMTYPES.
	// Strings MUST be null-terminated wchar_t arrays.
	// Objects are passed in as pointers to _IWmiObject pointers
	// Using a NULL buffer will set the property to NULL
	// Array properties must conform to array guidelines.  Will
	// completely blow away an old array.

    STDMETHOD(GetObjQual)( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, CIMTYPE *puCimType,
							ULONG *puQualFlavor, ULONG* puBuffSizeUsed,	LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    STDMETHOD(SetObjQual)( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, ULONG uNumElements,
							CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

    STDMETHOD(GetPropQual)( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
							LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    STDMETHOD(SetPropQual)( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

    STDMETHOD(GetMethodQual)( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
							LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    STDMETHOD(SetMethodQual)( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

	//
	//	_IWmiObject functions
	STDMETHOD(CopyInstanceData)( long lFlags, _IWmiObject* pSourceInstance ) = 0;
	// Copies instance data from source instance into current instance
	// Class Data must be exactly the same

    STDMETHOD(QueryObjectFlags)( long lFlags, unsigned __int64 qObjectInfoMask,
				unsigned __int64 *pqObjectInfo );
	// Returns flags indicating singleton, dynamic, association, etc.

    STDMETHOD(SetObjectFlags)( long lFlags, unsigned __int64 qObjectInfoOnFlags,
								unsigned __int64 qObjectInfoOffFlags );
	// Sets flags, including internal ones normally inaccessible.

    STDMETHOD(QueryPropertyFlags)( long lFlags, LPCWSTR pszPropertyName, unsigned __int64 qPropertyInfoMask,
				unsigned __int64 *pqPropertyInfo );
	// Returns flags indicating key, index, etc.

	STDMETHOD(CloneEx)( long lFlags, _IWmiObject* pDestObject ) = 0;
    // Clones the current object into the supplied one.  Reuses memory as
	// needed

    STDMETHOD(IsParentClass)( long lFlags, _IWmiObject* pClass ) = 0;
	// Checks if the current object is a child of the specified class (i.e. is Instance of,
	// or is Child of )

    STDMETHOD(CompareDerivedMostClass)( long lFlags, _IWmiObject* pClass ) = 0;
	// Compares the derived most class information of two class objects.

    STDMETHOD(MergeAmended)( long lFlags, _IWmiObject* pAmendedClass );
	// Merges in amended qualifiers from the amended class object into the
	// current object.  If lFlags is WMIOBJECT_MERGEAMENDED_FLAG_PAENTLOCALIZED,
	// this means that the parent object was localized, but not the current,
	// so we need to prevent certain qualifiers from "moving over."

	STDMETHOD(GetDerivation)( long lFlags, ULONG uBufferSize, ULONG* puNumAntecedents,
							ULONG* puBuffSizeUsed, LPWSTR pwstrUserBuffer );
	// Retrieves the derivation of an object as an array of LPCWSTR's, each one
	// terminated by a NULL.  Leftmost class is at the top of the chain

	STDMETHOD(_GetCoreInfo)( long lFlags, void** ppvData );
	//Returns CWbemObject

    STDMETHOD(QueryPartInfo)( DWORD *pdwResult );

    STDMETHOD(SetObjectMemory)( LPVOID pMem, DWORD dwMemSize );
    STDMETHOD(GetObjectMemory)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed );
    STDMETHOD(SetObjectParts)( LPVOID pMem, DWORD dwMemSize, DWORD dwParts ) = 0;
    STDMETHOD(GetObjectParts)( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed ) = 0;

    STDMETHOD(StripClassPart)() = 0;
    STDMETHOD(IsObjectInstance)()
    { return ( IsInstance() ? WBEM_S_NO_ERROR : WBEM_S_FALSE ); }

    STDMETHOD(GetClassPart)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed ) = 0;
    STDMETHOD(SetClassPart)( LPVOID pClassPart, DWORD dwSize ) = 0;
    STDMETHOD(MergeClassPart)( IWbemClassObject *pClassPart ) = 0;

    STDMETHOD(SetDecoration)( LPCWSTR pwcsServer, LPCWSTR pwcsNamespace );
    STDMETHOD(RemoveDecoration)( void );

    STDMETHOD(CompareClassParts)( IWbemClassObject* pObj, long lFlags );

    STDMETHOD(ClearWriteOnlyProperties)( void ) = 0;

    STDMETHOD(GetClassSubset)( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass ) = 0;
	// Creates a limited representation class for projection queries

    STDMETHOD(MakeSubsetInst)( _IWmiObject *pInstance, _IWmiObject** pNewInstance ) = 0;
	// Creates a limited representation instance for projection queries
	// "this" _IWmiObject must be a limited class

	STDMETHOD(Unmerge)( long lFlags, ULONG uBuffSize, ULONG* puBuffSizeUsed, LPVOID pData );
	// Returns a BLOB of memory containing minimal data (local)

	STDMETHOD(Merge)( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj ) = 0;
	// Merges a blob with the current object memory and creates a new object

	STDMETHOD(ReconcileWith)( long lFlags, _IWmiObject* pNewObj ) = 0;
	// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
	// is specified this will only perform a test

	STDMETHOD(GetKeyOrigin)( long lFlags, DWORD dwNumChars, DWORD* pdwNumUsed, LPWSTR pwzClassName );
	// Returns the name of the class where the keys were defined

	STDMETHOD(GetKeyString)( long lFlags, BSTR* ppwzKeyString );
	// Returns the key string that defines the instance

	STDMETHOD(GetNormalizedPath)( long lFlags, BSTR* ppwzKeyString );
	// Returns the normalized path of an instance

	STDMETHOD(Upgrade)( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild ) = 0;
	// Upgrades class and instance objects

	STDMETHOD(Update)( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass ) = 0;
	// Updates derived class object using the safe/force mode logic

	STDMETHOD(BeginEnumerationEx)( long lFlags, long lExtFlags );
	// Allows special filtering when enumerating properties outside the
	// bounds of those allowed via BeginEnumeration().
	
	STDMETHOD(CIMTYPEToVARTYPE)( CIMTYPE ct, VARTYPE* pvt );
	// Returns a VARTYPE from a CIMTYPE

	STDMETHOD(SpawnKeyedInstance)( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst ) = 0;
	// Spawns an instance of a class and fills out the key properties using the supplied
	// path.

	STDMETHOD(ValidateObject)( long lFlags );
	// Validates an object blob

	STDMETHOD(GetParentClassFromBlob)( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass );
	// Returns the parent class name from a BLOB

/*
	// IUmiPropList Methods
    STDMETHOD(Put)( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp );
	STDMETHOD(Get)( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp );
	STDMETHOD(GetAt)( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
	STDMETHOD(GetAs)( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp );
	STDMETHOD(FreeMemory)( ULONG uReserved, LPVOID pMem );
	STDMETHOD(Delete)( LPCWSTR pszName, ULONG uFlags );
    STDMETHOD(GetProps)( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps );
	STDMETHOD(PutProps)( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps );
	STDMETHOD(PutFrom)( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
*/	

	/* IWbemClassObjectEx Methods */
	STDMETHOD(PutEx)( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
	STDMETHOD(DeleteEx)( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
	STDMETHOD(GetEx)( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals, CIMTYPE* pCimType, long* plFlavor );

protected:

    class CLock
    {
    protected:
        CWbemObject* m_p;
    public:
        CLock(CWbemObject* p, long lFlags = 0) : m_p(p) { if ( NULL != p ) p->Lock(lFlags);}
        ~CLock() { if ( NULL != m_p ) m_p->Unlock(0);}
    };

    friend CQualifierSet;
	friend CWmiArray;

};

#define WBEM_INSTANCE_ALL_PARTS     WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART | WBEM_OBJ_INSTANCE_PART

//#pragma pack(pop)
//#pragma pack(pop)

#ifdef OBJECT_TRACKING
#pragma message("** Object Tracking **")
void COREPROX_POLARITY ObjectTracking_Dump();
void COREPROX_POLARITY ObjTracking_Add(CWbemObject *p);
void COREPROX_POLARITY ObjTracking_Remove(CWbemObject *p);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprbg.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FASTPRBG.CPP

Abstract:

  CFastPropertyBag Definition.

  Implements an array of property data for minimal storage.

History:

  24-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "fastprbg.h"
#include <corex.h>
#include "strutils.h"

// This class assumes that the incoming data is properly validated
//***************************************************************************
//
//  CFastPropertyBagItem::~CFastPropertyBagItem
//
//***************************************************************************
// ok
CFastPropertyBagItem::CFastPropertyBagItem( LPCWSTR pszName, CIMTYPE ctData, ULONG uDataLength, ULONG uNumElements,
									LPVOID pvData )
:	m_wsPropertyName( pszName ),
	m_ctData( ctData ),
	m_uDataLength( uDataLength ),
	m_uNumElements( uNumElements ),
	m_pvData( NULL ),
	m_lRefCount( 1L )	// Then we always know to release it!
{

	// If the data is non-NULL we need to store it.

	if ( NULL != pvData )
	{
		// IF it's pointer type data then we will allocate storage,
		// unless the length happens to fit in our buffer
		if ( CType::IsPointerType( ctData ) )
		{

			if ( uDataLength >= MAXIMUM_FIXED_DATA_LENGTH )
			{
				m_pvData = (void*) new BYTE[uDataLength];

				if ( NULL == m_pvData )
				{
					m_wsPropertyName.Empty();
					throw CX_MemoryException();
				}
			}
			else
			{
				m_pvData = (void*) m_bRawData;
			}

		}
		else
		{
			m_pvData = (void*) m_bRawData;
		}

		// Copy data into the proper location
		CopyMemory( m_pvData, pvData, uDataLength );

		// We should Addref the incoming objects
		if ( CType::GetBasic( m_ctData ) == CIM_OBJECT )
		{
			ULONG	uNumObj = 1;

			if ( CType::IsArray( m_ctData ) )
			{
				uNumObj = m_uNumElements;
			}

			for ( ULONG uCtr = 0; uCtr < uNumObj; uCtr++ )
			{
				(*(IUnknown**) m_pvData )->AddRef();
			}

		}	// IF embedded objects

	}	// IF NULL != pvData

}
    
//***************************************************************************
//
//  CFastPropertyBagItem::~CFastPropertyBagItem
//
//***************************************************************************
// ok
CFastPropertyBagItem::~CFastPropertyBagItem()
{
	// Cleanup
	if ( NULL != m_pvData )
	{
		// We should Release objects we are holding onto
		if ( CType::GetBasic( m_ctData ) == CIM_OBJECT )
		{
			ULONG	uNumObj = 1;

			if ( CType::IsArray( m_ctData ) )
			{
				uNumObj = m_uNumElements;
			}

			for ( ULONG uCtr = 0; uCtr < uNumObj; uCtr++ )
			{
				(*(IUnknown**) m_pvData )->Release();
			}

		}	// IF embedded objects

		// Check if it's pointing to our raw buffer before we
		// free it
		if ( m_pvData != (void*) m_bRawData )
		{
			delete m_pvData;
		}
	}
}

ULONG CFastPropertyBagItem::AddRef()
{
    return InterlockedIncrement((long*)&m_lRefCount);
}

ULONG CFastPropertyBagItem::Release()
{
    long lRef = InterlockedDecrement((long*)&m_lRefCount);
    _ASSERT(lRef >= 0, __TEXT("Reference count on CFastPropertyBagItem went below 0!"))

    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CFastPropertyBag::~CFastPropertyBag
//
//***************************************************************************
// ok
CFastPropertyBag::CFastPropertyBag( void )
:	m_aProperties()
{
}
    
//***************************************************************************
//
//  CFastPropertyBag::~CFastPropertyBag
//
//***************************************************************************
// ok
CFastPropertyBag::~CFastPropertyBag()
{
}

//***************************************************************************
//
//  CFastPropertyBag::FindProperty
//	Locates a property bag item
//
//***************************************************************************
CFastPropertyBagItem*	CFastPropertyBag::FindProperty( LPCWSTR pszName )
{
	CFastPropertyBagItem*	pItem = NULL;

	for ( int x = 0; x < m_aProperties.GetSize(); x++ )
	{
		pItem = m_aProperties.GetAt(x);

		if ( pItem->IsPropertyName( pszName ) )
		{
			return pItem;
		}

	}

	return NULL;
}

//***************************************************************************
//
//  CFastPropertyBag::FindProperty
//	Locates a property bag item
//
//***************************************************************************
int	CFastPropertyBag::FindPropertyIndex( LPCWSTR pszName )
{
	CFastPropertyBagItem*	pItem = NULL;

	for ( int x = 0; x < m_aProperties.GetSize(); x++ )
	{
		pItem = m_aProperties.GetAt(x);

		if ( pItem->IsPropertyName( pszName ) )
		{
			return x;
		}

	}

	return -1;
}

//***************************************************************************
//
//  CFastPropertyBag::Add
//	Adds a property and value to the bag
//
//***************************************************************************
HRESULT CFastPropertyBag::Add( LPCWSTR pszName, CIMTYPE ctData, ULONG uDataLength, ULONG uNumElements, LPVOID pvData )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Verify the data size
		if ( CType::IsArray( ctData ) )
		{
			hr = CUntypedArray::CheckRangeSize( CType::GetBasic( ctData ), uDataLength, uNumElements, uDataLength, pvData );
		}
		else
		{
			CVar	var;
			hr = CUntypedValue::FillCVarFromUserBuffer( ctData, &var, uDataLength, pvData );
		}

		if ( SUCCEEDED( hr ) )
		{
			// Make sure we release it if we allocate it
			CFastPropertyBagItem* pItem = new CFastPropertyBagItem( pszName, ctData, uDataLength,
																	uNumElements, pvData );
			CTemplateReleaseMe<CFastPropertyBagItem>	rm( pItem );

			if ( NULL != pItem )
			{
				if ( m_aProperties.Add( pItem ) < 0 )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}

		}	// IF buffer was valid

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

//***************************************************************************
//
//  CFastPropertyBag::Get
//	Returns values for a property.  Note that embedded objects
//	are NOT AddRef'd.  Caller should not atempt to free returned memory.
//
//***************************************************************************
HRESULT CFastPropertyBag::Get( int nIndex, LPCWSTR* ppszName, CIMTYPE* pctData, ULONG* puDataLength, ULONG* puNumElements, LPVOID* ppvData )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Make sure it doesn't already exist

	if ( nIndex >= 0 && nIndex < m_aProperties.GetSize() )
	{
		CFastPropertyBagItem*	pItem = m_aProperties.GetAt( nIndex );

		if ( NULL != pItem )
		{
			pItem->GetData( ppszName, pctData, puDataLength, puNumElements, ppvData );
		}
		else
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;
}

//***************************************************************************
//
//  CFastPropertyBag::Get
//	Returns values for a property.  Note that embedded objects
//	are NOT AddRef'd
//
//***************************************************************************
HRESULT CFastPropertyBag::Get( LPCWSTR pszName, CIMTYPE* pctData, ULONG* puDataLength, ULONG* puNumElements, LPVOID* ppvData )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Make sure it doesn't already exist
	CFastPropertyBagItem*	pItem = FindProperty( pszName );

	if ( NULL != pItem )
	{
		pItem->GetData( pctData, puDataLength, puNumElements, ppvData );
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;
}

//***************************************************************************
//
//  CFastPropertyBag::Remove
//	Removes a property from the bag
//
//***************************************************************************
HRESULT CFastPropertyBag::Remove( LPCWSTR pszName )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Make sure it doesn't already exist
	int	nIndex = FindPropertyIndex( pszName );

	if ( nIndex >= 0 )
	{
		m_aProperties.RemoveAt( nIndex );
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;
}

//***************************************************************************
//
//  CFastPropertyBag::RemoveAll
//	Removes all properties from the bag
//
//***************************************************************************
HRESULT CFastPropertyBag::RemoveAll( void )
{
	m_aProperties.RemoveAll();
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CFastPropertyBag::Copy
//	Copies all properties from a source bag
//
//***************************************************************************
HRESULT	CFastPropertyBag::Copy( const CFastPropertyBag& source )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Basically we just AddRef the new properties
	for ( int x = 0; SUCCEEDED( hr ) && x < source.m_aProperties.GetSize(); x++ )
	{
		CFastPropertyBagItem* pItem = (CFastPropertyBagItem*) source.m_aProperties.GetAt( x );

		if ( m_aProperties.Add( pItem ) != CFlexArray::no_error )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprop.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROP.CPP

Abstract:

  This file implements the classes related to property representation 
  in WbemObjects

  Classes defined: 
      CPropertyInformation    Property type, location and qualifiers
      CPropertyLookup         Property name and information pointers.
      CPropertyLookupTable    Binary search table.
      CDataTable              Property data table
      CDataTableContainer     Anything that has a data table inside of it.

History:

    3/10/97     a-levn  Fully documented
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
//#include "dbgalloc.h"
#include "wbemutil.h"
#include "fastall.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <CWbemTime.h>
#include <arrtempl.h>
 

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CPropertyInformation::WritePropagatedHeader(CFastHeap* pOldHeap,
                CPropertyInformation* pDest, CFastHeap* pNewHeap)
{
    pDest->nType = CType::MakeParents(nType);
    pDest->nDataOffset = nDataOffset;
    pDest->nDataIndex = nDataIndex;
    pDest->nOrigin = nOrigin;
}
//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CPropertyInformation::IsRef(CFastHeap* pHeap)
{
    return (CType::GetActualType(nType) == CIM_REFERENCE);
}
    
HRESULT CPropertyInformation::ValidateRange(CFastHeap* pHeap, CDataTable* pData,
                                            CFastHeap* pDataHeap)
{
    if(pData->IsNull(nDataIndex))
        return WBEM_S_NO_ERROR;

    if(pData->IsDefault(nDataIndex))
        return WBEM_S_NO_ERROR;

    if(CType::GetBasic(nType) == CIM_OBJECT)
    {
        // Get the cimtype qualifier
        // =========================

        CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
            GetQualifierSetData(), pHeap, L"cimtype");
        if(pQual == NULL)
            return WBEM_S_NO_ERROR; // impossible
        
        CVar vCimType;

        // Check for allocation failure
        if ( !pQual->Value.StoreToCVar(vCimType, pHeap) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(vCimType.GetType() != VT_BSTR)
            return WBEM_S_NO_ERROR; // impossible

        LPCWSTR wszCimType = vCimType.GetLPWSTR();
        if(!wbem_wcsicmp(wszCimType, L"object"))
            return WBEM_S_NO_ERROR; // no restrictions

        LPCWSTR wszClassName = wszCimType + 7; // "object:"

        CUntypedValue* pValue = pData->GetOffset(nDataOffset);
        
        if(CType::IsArray(nType))
        {
            HRESULT hr = WBEM_S_NO_ERROR;
            CUntypedArray* pArrValue = (CUntypedArray*)
                pDataHeap->ResolveHeapPointer(*(PHEAPPTRT)pValue);
    
            for(int i = 0; i < pArrValue->GetNumElements(); i++)
            {
                heapptr_t ptrElement = 
                    *(PHEAPPTRT)(pArrValue->GetElement(i, sizeof(heapptr_t)));
                
                CEmbeddedObject* pEmbObj = (CEmbeddedObject*)
                    pDataHeap->ResolveHeapPointer(ptrElement);

                // Check for errors and WBEM_S_FALSE
                hr = ValidateObjectRange(pEmbObj, wszClassName);
                
                if ( WBEM_S_NO_ERROR != hr )
                {
                    return hr;
                }

            }

            return hr;
        }
        else
        {
            CEmbeddedObject* pEmbObj = (CEmbeddedObject*)
                    pDataHeap->ResolveHeapPointer(*(PHEAPPTRT)pValue);
            return ValidateObjectRange(pEmbObj, wszClassName);
        }
    }
        
    if(CType::GetBasic(nType) != CIM_REFERENCE &&
        CType::GetBasic(nType) != CIM_DATETIME)
    {
        return WBEM_S_NO_ERROR;
    }

    CUntypedValue* pValue = pData->GetOffset(nDataOffset);
    
    if(CType::IsArray(nType))
    {
        HRESULT hr = WBEM_S_NO_ERROR;
        CUntypedArray* pArrValue = (CUntypedArray*)
            pDataHeap->ResolveHeapPointer(*(PHEAPPTRT)pValue);

        for(int i = 0; i < pArrValue->GetNumElements(); i++)
        {
            heapptr_t ptrElement = 
                *(PHEAPPTRT)(pArrValue->GetElement(i, sizeof(heapptr_t)));
            CCompressedString* pcsValue = pDataHeap->ResolveString(ptrElement);

            // Check for errors and WBEM_S_FALSE
            hr = ValidateStringRange(pcsValue);
            if ( WBEM_S_NO_ERROR != hr )
            {
                return hr;
            }
        }

        return hr;
    }
    else
    {
        CCompressedString* pcsValue = 
            pDataHeap->ResolveString(*(PHEAPPTRT)pValue);
        return ValidateStringRange(pcsValue);
    }
}
        
HRESULT CPropertyInformation::ValidateObjectRange(CEmbeddedObject* pEmbObj,
                                                LPCWSTR wszClassName)
{
    CWbemObject* pObj = pEmbObj->GetEmbedded();
    if(pObj == NULL)
        return TRUE;

    HRESULT hr = pObj->InheritsFrom((LPWSTR)wszClassName);
    pObj->Release();
    return hr;
}

HRESULT CPropertyInformation::ValidateStringRange(CCompressedString* pcsValue)
{
    if(CType::GetBasic(nType) == CIM_REFERENCE)
    {
        // Free the string when we fall out of scope
        BSTR strPath = pcsValue->CreateBSTRCopy();
        CSysFreeMe  sfm( strPath );

        // Check for allocation failures
        if ( NULL == strPath )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CObjectPathParser Parser;
        ParsedObjectPath* pOutput = NULL;
        BOOL bRet = 
            (Parser.Parse(strPath, &pOutput) == CObjectPathParser::NoError &&
                pOutput->IsObject());
        delete pOutput;

        return ( bRet ? WBEM_S_NO_ERROR : WBEM_S_FALSE );
    }
    else if(CType::GetBasic(nType) == CIM_DATETIME)
    {
        return ValidateDateTime(pcsValue);
    }
    else return WBEM_S_NO_ERROR;
}

HRESULT CPropertyInformation::ValidateDateTime(CCompressedString* pcsValue)
{
    if(pcsValue->IsUnicode())
        return WBEM_S_FALSE;

    // Pre-test
    // ========

    LPCSTR sz = (LPCSTR)pcsValue->GetRawData();
    if(strlen(sz) != 25)
        return WBEM_S_FALSE;

    if(sz[14] != '.' && sz[14] != '*')
        return WBEM_S_FALSE;

    if(sz[21] != ':' && sz[21] != '-' && sz[21] != '+' && sz[21] != '*')
        return WBEM_S_FALSE;

    for(int i = 0; i < 25; i++)
    {
        if(i == 21 || i == 14)
            continue;
        if(sz[i] != '*' && !isdigit(sz[i]))
            return WBEM_S_FALSE;
    }

    // Passed pre-test. Check if any stars were specified
    // ==================================================

    if(strchr(sz, '*'))
    {
        // No further checking
        return WBEM_S_NO_ERROR;
    }

    if(sz[21] == ':')
    {
        // Interval -- no checking
        return WBEM_S_NO_ERROR;
    }

    // Cleanup the BSTR when we fall out of scope
    BSTR str = pcsValue->CreateBSTRCopy();
    CSysFreeMe  sfm( str );

    // Check for allocation failures
    if ( NULL == str )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemTime Time;
    BOOL bRes = Time.SetDMTF(str);
    return ( bRes ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
}

//******************************************************************************
//******************************************************************************
//******************************************************************************

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CPropertyLookup::IsIncludedUnderLimitation(IN CWStringArray* pwsNames,
                                             IN CFastHeap* pCurrentHeap)
{
    // DEVNOTE:MEMORY:RETVAL - This function should really return an HRESULT

    if(pwsNames == NULL)
    {
        return TRUE;
    }

    // Only properties in the array must be included
    // =============================================

    // From here we will throw an exception.  It will be up to the outside
    // to deal with it.
    BSTR strName = pCurrentHeap->ResolveString(ptrName)->CreateBSTRCopy();
    CSysFreeMe  sfm( strName );

    if ( NULL == strName )
    {
        throw CX_MemoryException();
    }

    int nRes = pwsNames->FindStr(strName, CWStringArray::no_case);

    if(nRes != CWStringArray::not_found)
    {
        return TRUE;
    }

    return FALSE;
}
        
//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
HRESULT CPropertyLookupTable::InsertProperty(LPCWSTR wszName, Type_t nType, int& nReturnIndex)
{
    // Determine where the new property will go in the data table
    // ==========================================================

    CFastHeap* pHeap = m_pContainer->GetHeap();

    int nNewOffset = 0;
    int nNewIndex = 0;
    int nNewType = nType;

    for(int i = 0; i < *m_pnProps; i++)
    {
        CPropertyInformation* pInfo = (CPropertyInformation*)
            pHeap->ResolveHeapPointer(GetAt(i)->ptrInformation);

        int nAfterOffset = pInfo->nDataOffset + CType::GetLength(pInfo->nType);
        if(nAfterOffset > nNewOffset)
        {
            nNewOffset = nAfterOffset;
        }

        if(pInfo->nDataIndex + 1 > nNewIndex)
        {
            nNewIndex = pInfo->nDataIndex + 1;
        }
    }

    // Get more space in the data table
    // ================================

    int nValueLen = CType::GetLength(nType);

    // WARNING: next line may result in rebase call on ourselves!!!
    if (!m_pContainer->GetDataTable()->ExtendTo( (propindex_t) nNewIndex, nNewOffset + nValueLen))
    	return WBEM_E_OUT_OF_MEMORY;

    // Create property information structure (no qualifiers)
    // =====================================================

    // Check for allocation failure.
    heapptr_t ptrInformation;
    if ( !pHeap->Allocate(CPropertyInformation::GetMinLength(), ptrInformation) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if (wcslen(wszName) > 2 && wszName[0] == L'_')
    {
        nNewType |= CIMTYPE_EX_PARENTS;
    }

    ((CPropertyInformation*)pHeap->ResolveHeapPointer(ptrInformation))->
        SetBasic(nNewType, (propindex_t) nNewIndex, nNewOffset, 
        m_pContainer->GetCurrentOrigin());

    // NULL the data out in the data table
    // ===================================

    memset((void*)(m_pContainer->GetDataTable()->GetOffset(nNewOffset)),
        0xFF, nValueLen);
    m_pContainer->GetDataTable()->SetNullness(nNewIndex, TRUE);

    // Create the lookup node
    // ======================

    CPropertyLookup Lookup;

    // Check for allocation failure.
    if ( !pHeap->CreateNoCaseStringHeapPtr(wszName, Lookup.ptrName) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    Lookup.ptrInformation = ptrInformation;

    return InsertProperty(Lookup, nReturnIndex);
}


//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
HRESULT CPropertyLookupTable::InsertProperty(const CPropertyLookup& Lookup, int& nReturnIndex)
{
    // Get more space from the container
    // =================================

    if ( !m_pContainer->ExtendPropertyTableSpace(GetStart(), GetLength(), 
            GetLength() + sizeof(CPropertyLookup)) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Search for the place to insert
    // ==============================

    CFastHeap* pHeap = m_pContainer->GetHeap();
    CCompressedString* pcsNewName = pHeap->ResolveString(Lookup.ptrName);

    int nIndex = 0;
    while(nIndex < *m_pnProps)
    {
        CCompressedString* pcsPropName = pHeap->ResolveString(
            GetAt(nIndex)->ptrName);

        int nCompare = pcsNewName->CompareNoCase(*pcsPropName);
        if(nCompare == 0)
        {
            // Found the property with the same name
            // =====================================

            // Delete old value
            // ================

            CPropertyInformation* pOldInfo = (CPropertyInformation*)
                pHeap->ResolveHeapPointer(GetAt(nIndex)->ptrInformation);
            
            pOldInfo->Delete(pHeap);
            pHeap->Free(GetAt(nIndex)->ptrInformation, pOldInfo->GetLength());

            // Copy new value
            // ==============

            GetAt(nIndex)->ptrInformation = Lookup.ptrInformation;

            // Delete new property name from the heap --- already there
            // ========================================================

            pHeap->FreeString(Lookup.ptrName);
            
            nReturnIndex = nIndex;
            return WBEM_NO_ERROR;
        }
        else if(nCompare > 0)
        {
            // Still not there
            // ===============

            nIndex++;
        }
        else // nCompare < 0
        {
            // Found insertion point. Move everything else to the right
            // ========================================================

            memmove((void*)GetAt(nIndex+1), (void*)GetAt(nIndex),
                sizeof(CPropertyLookup)*(*m_pnProps-nIndex));

            (*m_pnProps)++;

            // Copy our node here
            // ==================

            memcpy((void*)GetAt(nIndex), (void*)&Lookup,
                sizeof(CPropertyLookup));

            nReturnIndex = nIndex;
            return WBEM_NO_ERROR;
        }
    }

    // If here, we finished the list without finding a place.
    // Add it at the end
    // ======================================================

    memcpy((void*)GetAt(*m_pnProps), (void*)&Lookup, 
            sizeof(CPropertyLookup));

    (*m_pnProps)++;

    nReturnIndex = (*m_pnProps - 1);
    return WBEM_NO_ERROR;

}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CPropertyLookupTable::DeleteProperty(CPropertyLookup* pLookup, int nFlags)
{
    CFastHeap* pHeap = m_pContainer->GetHeap();
    CDataTable* pDataTable = m_pContainer->GetDataTable();
    CPropertyInformation* pInfo = pLookup->GetInformation(pHeap);

    if(nFlags == e_UpdateDataTable)
    {
        // Shift all the properties in the data table
        // ==========================================

        CFastHeap* pHeap = m_pContainer->GetHeap();
        CPropertyInformation* pInfoToDelete = (CPropertyInformation*)
            pHeap->ResolveHeapPointer(pLookup->ptrInformation);
        int nDataSize = CType::GetLength(pInfoToDelete->nType);

        for(int i = 0; i < *m_pnProps; i++)
        {
            CPropertyInformation* pPropInfo = (CPropertyInformation*)
                pHeap->ResolveHeapPointer(GetAt(i)->ptrInformation);
            if(pPropInfo->nDataOffset > pInfoToDelete->nDataOffset)
            {
                pPropInfo->nDataOffset -= nDataSize;
            }
            if(pPropInfo->nDataIndex > pInfoToDelete->nDataIndex)
            {
                pPropInfo->nDataIndex--;
            }
        }

        // Inform the data table that it is now shorter
        // ============================================

        // WARNING: this may rebase us!
        pDataTable->RemoveProperty(
            pInfoToDelete->nDataIndex, pInfoToDelete->nDataOffset, nDataSize);
    }

    // Delete all information associated with this property from the heap
    // ==================================================================

    pLookup->Delete(pHeap);

    // Collapse this location in the data table
    // ========================================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value.  We do not support length
    // > 0xFFFFFFFF, so cast is ok.

    int nSizeOfTail = *m_pnProps - (int) (pLookup+1 - GetAt(0));

    memcpy(pLookup, pLookup + 1, sizeof(CPropertyLookup)*nSizeOfTail);
    m_pContainer->ReducePropertyTableSpace(GetStart(), 
        GetLength(), sizeof(CPropertyLookup));

    // Adjust our length
    // =================

    (*m_pnProps)--;
}


//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CPropertyLookupTable::Merge(
                  CPropertyLookupTable* pParentTable, CFastHeap* pParentHeap,
                  CPropertyLookupTable* pChildTable, CFastHeap* pChildHeap,
                  LPMEMORY pDest, CFastHeap* pNewHeap, BOOL bCheckValidity)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================


    // Prepare the destination
    // =======================

    CPropertyLookup* pCurrentEnd = (CPropertyLookup*)(pDest + sizeof(int));

    int nParentIndex = 0, nChildIndex = 0;
    while(nParentIndex < pParentTable->GetNumProperties() &&
          nChildIndex < pChildTable->GetNumProperties())
    {
        // Compare property names
        // ======================

        CPropertyLookup* pParentLookup = pParentTable->GetAt(nParentIndex);
        CPropertyLookup* pChildLookup = pChildTable->GetAt(nChildIndex);

        int nCompare = pParentHeap->ResolveString(pParentLookup->ptrName)->
            CompareNoCase(*pChildHeap->ResolveString(pChildLookup->ptrName));

        if(nCompare < 0)
        {
            // Take parent's property
            // ======================

            // Check for memory allocation failures
            if ( !pParentLookup->WritePropagatedVersion(pCurrentEnd,
                    pParentHeap, pNewHeap) )
            {
                return NULL;
            }

            nParentIndex++;
        }
        else if(nCompare > 0)
        {
            // Take child's property
            // =====================

            memcpy(pCurrentEnd, pChildLookup, sizeof(CPropertyLookup));
            CStaticPtr CurrentEnd((LPMEMORY)pCurrentEnd);

            // Check for memory allocation failures
            if ( !CPropertyLookup::TranslateToNewHeap(&CurrentEnd, pChildHeap, 
                                                      pNewHeap) )
            {
                return NULL;
            }

            nChildIndex++;
        }
        else
        {
            // Merge them together
            // ===================

            // Check for memory allocation failures
            if ( !CCompressedString::CopyToNewHeap(
                    pParentLookup->ptrName, pParentHeap, pNewHeap,
                    pCurrentEnd->ptrName) )
            {
                return NULL;
            }

            // Compute the space that merged property information will take
            // up on the heap
            // ============================================================

            CPropertyInformation* pParentInfo = 
                pParentLookup->GetInformation(pParentHeap);
            CPropertyInformation* pChildInfo = 
                pChildLookup->GetInformation(pChildHeap);

            if(bCheckValidity)
            {
                if(CType::GetActualType(pParentInfo->nType) != 
                    CType::GetActualType(pChildInfo->nType))
                    return NULL;

                if(pParentInfo->nDataOffset != pChildInfo->nDataOffset ||
                    pParentInfo->nDataIndex != pChildInfo->nDataIndex)
                {
                    return NULL;
                }
            }
                           
            int nMergedQualifiersLen = CBasicQualifierSet::ComputeMergeSpace(
                pParentInfo->GetQualifierSetData(), pParentHeap,
                pChildInfo->GetQualifierSetData(), pChildHeap);

            // Allocate it on the heap and set up information header
            // =====================================================

            // Check for memory allocation failures
            if ( !pNewHeap->Allocate(
                    CPropertyInformation::GetHeaderLength() + 
                    nMergedQualifiersLen, pCurrentEnd->ptrInformation) )
            {
                return NULL;
            }

            CPropertyInformation* pMergeInfo = (CPropertyInformation*)
                pNewHeap->ResolveHeapPointer(pCurrentEnd->ptrInformation);

            // This call does no allocations so don't worry about leaks.
            pParentInfo->WritePropagatedHeader(pParentHeap, 
                                      pMergeInfo, pNewHeap);

            if ( CBasicQualifierSet::Merge(
                    pParentInfo->GetQualifierSetData(), pParentHeap,
                    pChildInfo->GetQualifierSetData(), pChildHeap,
                    pMergeInfo->GetQualifierSetData(), pNewHeap, 
                    bCheckValidity
                    ) == NULL )
            {
                return NULL;
            }

            nParentIndex++;
            nChildIndex++;
        }
        /* end of comparing two properties by name */

        pCurrentEnd++;
    }
    
    while(nParentIndex < pParentTable->GetNumProperties())
    {
        // Take parent's property
        // ======================

        CPropertyLookup* pParentLookup = pParentTable->GetAt(nParentIndex);


        // Check for memory allocation failures
        if ( !pParentLookup->WritePropagatedVersion(pCurrentEnd,
                        pParentHeap, pNewHeap ) )
        {
            return NULL;
        }

        nParentIndex++;
        pCurrentEnd++;
    }

    while(nChildIndex < pChildTable->GetNumProperties())
    {    
        // Take child's property
        // =====================

        CPropertyLookup* pChildLookup = pChildTable->GetAt(nChildIndex);
        memcpy(pCurrentEnd, pChildLookup, sizeof(CPropertyLookup));
        CStaticPtr CurrentEnd((LPMEMORY)pCurrentEnd);

        // Check for memory allocation failures
        if ( !CPropertyLookup::TranslateToNewHeap(&CurrentEnd, pChildHeap, 
                                                pNewHeap) )
        {
            return NULL;
        }

        nChildIndex++;
        pCurrentEnd++;
    }

    // Set the length
    // ==============

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value. We do not support length
    // > 0xFFFFFFFF, so cast is ok.

    *(UNALIGNED int*)pDest = (int) ( pCurrentEnd - (CPropertyLookup*)(pDest + sizeof(int)) );

    return (LPMEMORY)pCurrentEnd;
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CPropertyLookupTable::Unmerge(CDataTable* pDataTable, 
                                       CFastHeap* pCurrentHeap,
                                       LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    CPropertyLookup* pCurrentNew = (CPropertyLookup*)(pDest + sizeof(int));

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);
        CPropertyInformation* pInfo = pCurrent->GetInformation(pCurrentHeap);

        // Check if it is local
        // ====================

        if(!pInfo->IsOverriden(pDataTable))
        {
            continue;
        }

        // Add it to the unmerge
        // =====================

        // Check for allocation errors
        if ( !CCompressedString::CopyToNewHeap(
                pCurrent->ptrName, pCurrentHeap, pNewHeap,
                pCurrentNew->ptrName) )
        {
            return NULL;
        }
        
        // Check for allocation errors
        if ( !pInfo->ProduceUnmergedVersion(
                pCurrentHeap, pNewHeap,
                pCurrentNew->ptrInformation) )
        {
            return NULL;
        }

        pCurrentNew++;
    }

    // Set the length
    // ==============

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value. We do not support length
    // > 0xFFFFFFFF, so cast is ok.

    *(UNALIGNED int*)pDest = (int) ( pCurrentNew - (CPropertyLookup*)(pDest + sizeof(int)) );

    return (LPMEMORY)pCurrentNew;
}


//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CPropertyLookupTable::WritePropagatedVersion(
       CFastHeap* pCurrentHeap, 
       LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    *(UNALIGNED int*)pDest = GetNumProperties();
    CPropertyLookup* pCurrentNew = (CPropertyLookup*)(pDest + sizeof(int));

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);
        CPropertyInformation* pInfo = pCurrent->GetInformation(pCurrentHeap);

        // Check for allocation failures
        if ( !pCurrent->WritePropagatedVersion(pCurrentNew,
                pCurrentHeap, pNewHeap) )
        {
            return NULL;
        }

        pCurrentNew++;
    }

    return (LPMEMORY)pCurrentNew;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CPropertyLookupTable::MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        OUT CLimitationMapping* pMap)
{
    // This function will cleanup properly if an exception is thrown.  The caller is responsible for
    // catching the exception.

    CFastHeap* pCurrentHeap = GetHeap();

    int nCurrentIndex = 0;
    offset_t nCurrentOffset = 0;

    pMap->Build(GetNumProperties());
    pMap->SetFlags(lFlags);

    BOOL bIncludeKeys = TRUE;
    BOOL bIncludeAll = FALSE;
    if(pwsNames == NULL)
    {
        bIncludeAll = TRUE;
    }
    else if(pwsNames->FindStr(L"__RELPATH", CWStringArray::no_case) ==
                                                CWStringArray::not_found)
    {
        if(pwsNames->FindStr(L"__PATH", CWStringArray::no_case) ==
                                                CWStringArray::not_found)
        {
            bIncludeKeys = FALSE;
        }
    }

    pMap->SetAddChildKeys(bIncludeKeys);

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);

        // Check if this property is excluded
        // ==================================

        if(bIncludeAll ||
           pCurrent->IsIncludedUnderLimitation(pwsNames, pCurrentHeap) ||
           (bIncludeKeys && pCurrent->GetInformation(pCurrentHeap)->IsKey()))
        {
            // Include it. Determine the index and offset for it.
            // ==================================================

            CPropertyInformation* pOldInfo = 
                    pCurrent->GetInformation(pCurrentHeap);

            CPropertyInformation NewInfo;
            NewInfo.nType = pOldInfo->nType;
            NewInfo.nDataIndex = (propindex_t) nCurrentIndex;
            NewInfo.nDataOffset = nCurrentOffset;

            nCurrentOffset += CType::GetLength(pOldInfo->nType);
            nCurrentIndex++;
            
            // Add it to the map
            // =================

            pMap->Map(pOldInfo, &NewInfo, TRUE); // common for all
        }
    }

    pMap->SetVtableLength(nCurrentOffset, TRUE); // common

    return TRUE;
}

LPMEMORY CPropertyLookupTable::CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN CFastHeap* pNewHeap,
        OUT LPMEMORY pDest,
        BOOL& bRemovedKeys)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    bRemovedKeys = FALSE;

    CPropertyLookup* pFirstLookup = (CPropertyLookup*)(pDest + sizeof(int));
    CPropertyLookup* pCurrentNew = pFirstLookup;
    CFastHeap* pCurrentHeap = GetHeap();

    int nCurrentIndex = pMap->GetNumMappings();
    offset_t nCurrentOffset = pMap->GetVtableLength();
    BOOL bIncludeKeys = pMap->ShouldAddChildKeys();

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);
        CPropertyInformation* pInfo = pCurrent->GetInformation(pCurrentHeap);

        // Check if this property is excluded
        // ==================================

        CPropertyInformation* pNewInfoHeader = pMap->GetMapped(pInfo);
        CPropertyInformation NewInfo;

        if(pNewInfoHeader == NULL && bIncludeKeys && pInfo->IsKey())
        {
            // We need to add all our keys --- __RELPATH was requested
            // =======================================================

            NewInfo.nType = pInfo->nType;
            NewInfo.nDataIndex = (propindex_t) nCurrentIndex;
            NewInfo.nDataOffset = nCurrentOffset;
            pNewInfoHeader = &NewInfo;

            pMap->Map(pInfo, &NewInfo, FALSE); // specific to this class

            nCurrentOffset += CType::GetLength(pInfo->nType);
            nCurrentIndex++;
        }
            
        if(pNewInfoHeader != NULL)
        {
            // Copy the name
            // =============

            // Check for allocation failures
            if ( !CCompressedString::CopyToNewHeap(
                    pCurrent->ptrName, pCurrentHeap, pNewHeap,
                    pCurrentNew->ptrName) )
            {
                return NULL;
            }

            // Check if the qualifiers are needed.
            // ===================================

            CPropertyInformation* pNewInfo;
            if(pMap->GetFlags() & WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS)
            {
                // Just copy the property header with empty qualifiers
                // ===================================================

                int nLength = CPropertyInformation::GetMinLength();
                
                // Check for allocation failures
                if ( !pNewHeap->Allocate(nLength, pCurrentNew->ptrInformation) )
                {
                    return NULL;
                }

                pNewInfo =  pCurrentNew->GetInformation(pNewHeap);
                pNewInfo->SetBasic(pInfo->nType, 
                    pNewInfoHeader->nDataIndex, pNewInfoHeader->nDataOffset,
                    pInfo->nOrigin);
            }
            else
            {
                // Make a complete copy
                // ====================

                // Check for allocation failures
                if ( !CPropertyInformation::CopyToNewHeap(
                            pCurrent->ptrInformation, pCurrentHeap, pNewHeap,
                            pCurrentNew->ptrInformation) )
                {
                    return NULL;
                }

                pNewInfo = pCurrentNew->GetInformation(pNewHeap);
                pNewInfo->nDataIndex = pNewInfoHeader->nDataIndex;
                pNewInfo->nDataOffset = pNewInfoHeader->nDataOffset;
            }
                
            pCurrentNew++;
        }
        else
        {
            if(pInfo->IsKey())
            {
                // Key not included!
                bRemovedKeys = TRUE;
            }
        }
    }

    pMap->SetVtableLength(nCurrentOffset, FALSE); // this class only

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value. We do not support length
    // > 0xFFFFFFFF, so cast is ok.

    *(UNALIGNED int*)pDest = (int) ( pCurrentNew - pFirstLookup );

    return (LPMEMORY)pCurrentNew;
}


HRESULT CPropertyLookupTable::ValidateRange(BSTR* pstrName, CDataTable* pData,
                                            CFastHeap* pDataHeap)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFastHeap* pHeap = GetHeap();

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);
        CPropertyInformation* pInfo = pCurrent->GetInformation(pHeap);

        // Check for a failure (such as out of memory)
        hr = pInfo->ValidateRange(pHeap, pData, pDataHeap);

        if ( FAILED( hr ) )
        {
            return hr;
        }

        // If we had an invalid property store it's name
        if ( WBEM_S_FALSE == hr )
        {
            if(pstrName)
            {
                *pstrName = 
                    pHeap->ResolveString(pCurrent->ptrName)->CreateBSTRCopy();

                // Check for allocation failures
                if ( NULL == *pstrName )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

            }
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}
            
    
//***************************************************************************
//***************************************************************************
//***************************************************************************
//***************************************************************************

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CDataTable::ExtendTo(propindex_t nMaxIndex, offset_t nOffsetBound)
{
    // Check if the nullness table needs expantion
    // ===========================================

    int nTableLenDiff = CNullnessTable::GetNecessaryBytes(nMaxIndex+1) -
        GetNullnessLength();
    if(nTableLenDiff > 0)
    {
        if (!m_pContainer->ExtendDataTableSpace(GetStart(), 
            GetLength(), GetLength() + nTableLenDiff))
            return FALSE;

        // Move the actual data
        // ====================
        memmove(m_pData + nTableLenDiff, m_pData, GetDataLength());
        m_pData += nTableLenDiff;
    }

    m_nProps = nMaxIndex+1;
    m_nLength += nTableLenDiff;

    // Expand the data
    // ===============

    if (!m_pContainer->ExtendDataTableSpace(GetStart(), 
        GetLength(), GetNullnessLength() + nOffsetBound))
        return FALSE;

    m_nLength = GetNullnessLength() + nOffsetBound;

    return TRUE;
}


//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CDataTable::RemoveProperty(propindex_t nIndex, offset_t nOffset, 
                                length_t nLength)
{
    // Remove that index from the bit table (collapsing it)
    // ====================================================

    m_pNullness->RemoveBitBlock(nIndex, GetNullnessLength());
    m_nProps--;
    int nTableLenDiff = 
        GetNullnessLength() - CNullnessTable::GetNecessaryBytes(m_nProps);
    if(nTableLenDiff > 0)
    {
        // Move the data back by one
        // =========================

        memcpy(m_pData-nTableLenDiff, m_pData, GetDataLength());
        m_pData -= nTableLenDiff;
        m_nLength -= nTableLenDiff;
    }

    // Collapse the area of memory occupied by the property
    // ====================================================

    memcpy(GetOffset(nOffset), GetOffset(nOffset+nLength),
        GetDataLength() - nLength - nOffset);

    // Give space back to container
    // ============================

    m_pContainer->ReduceDataTableSpace(GetStart(), GetLength(), 
        nLength + nTableLenDiff);

    m_nLength -= nLength;
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CDataTable::Merge( 
        CDataTable* pParentData, CFastHeap* pParentHeap,
        CDataTable* pChildData, CFastHeap* pChildHeap,
        CPropertyLookupTable* pProperties, LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    // First of all, copy child's data table to the destination.
    // =========================================================

    memcpy(pDest, pChildData->GetStart(), pChildData->GetLength());

    // (Note, that no heap translation has been performed)

    // Set up a new CDataTable on this copy
    // ====================================

    CDataTable NewData;
    NewData.SetData(pDest, pProperties->GetNumProperties(), 
        pChildData->m_nLength, NULL);

    // Iterate over all the child's properties (the property table is using
    // the NEW heap!!!
    // ====================================================================

    for(int i = 0; i < pProperties->GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pProperties->GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(pNewHeap);
        
        // Check if this property is marked as DEFAULT
        // ===========================================

        if(NewData.IsDefault(pInfo->nDataIndex))
        {
            // Copy it from the parent
            // =======================

            if(pParentData->IsNull(pInfo->nDataIndex))
            {
                NewData.SetNullness(pInfo->nDataIndex, TRUE);
            }
            else
            {
                CStaticPtr Source(
                    (LPMEMORY)(pParentData->GetOffset(pInfo->nDataOffset)));
                CStaticPtr Dest((LPMEMORY)(NewData.GetOffset(pInfo->nDataOffset)));

                // Check for memory allocation failures
                if ( !CUntypedValue::CopyTo(
                        &Source, CType::GetActualType(pInfo->nType),
                        &Dest,
                        pParentHeap, pNewHeap) )
                {
                    return NULL;
                }
            }
        }
        else
        {
            // Translate it from the child
            // ===========================

            if(!NewData.IsNull(pInfo->nDataIndex))
            {                
                CStaticPtr Source(
                    (LPMEMORY)(NewData.GetOffset(pInfo->nDataOffset)));

                // Check for memory allocation failures
                if ( !CUntypedValue::TranslateToNewHeap(
                        &Source, 
                        CType::GetActualType(pInfo->nType),
                        pChildHeap, pNewHeap) )
                {
                    return NULL;
                }

            }   // IF !IsNull()

        }   // if-else IsDefault()

    }   // FOR EnumProperties

    return EndOf(NewData);
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CDataTable::Unmerge(CPropertyLookupTable* pLookupTable,
        CFastHeap* pCurrentHeap, LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    // Start by copying the whole thing
    // ================================

    memcpy(pDest, GetStart(), GetLength());

    // Now copy to the heap overriden values (if pointers)
    // ===================================================

    for(int i = 0; i < pLookupTable->GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pLookupTable->GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(pCurrentHeap);
        
        // Check if this property is marked as DEFAULT
        // ===========================================

        if(!IsDefault(pInfo->nDataIndex))
        {
            // Real value. Translate to the new heap
            // =====================================

            if(!IsNull(pInfo->nDataIndex))
            {
                CStaticPtr Source(pDest + GetNullnessLength() + 
                                    pInfo->nDataOffset);

                // Check for allocation errors
                if ( !CUntypedValue::TranslateToNewHeap(
                        &Source,
                        CType::GetActualType(pInfo->nType),
                        pCurrentHeap, pNewHeap) )
                {
                    return NULL;
                }   // IF !TranslateToNewHeap

            }   // IF !IsNull

        }   // IF !IsDefault

    }   // FOR enumproperties

    return pDest + GetLength();
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CDataTable::WritePropagatedVersion(CPropertyLookupTable* pLookupTable,
        CFastHeap* pCurrentHeap, LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    // Copy the whole thing
    // ====================

    memcpy(pDest, GetStart(), GetLength());

    CNullnessTable* pDestBitTable = (CNullnessTable*)pDest;

    // Copy individual values
    // ======================

    for(int i = 0; i < pLookupTable->GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pLookupTable->GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(pCurrentHeap);
        
        // Translate to the new heap
        // =========================

        if(!IsNull(pInfo->nDataIndex))
        {
            CStaticPtr Source(pDest + GetNullnessLength() + pInfo->nDataOffset);

            // Check for allocation failures
            if ( !CUntypedValue::TranslateToNewHeap(
                    &Source,
                    CType::GetActualType(pInfo->nType),
                    pCurrentHeap, pNewHeap) )
            {
                return NULL;
            }
        }
        
        // Mark as having default value
        // ============================

        pDestBitTable->SetBit(pInfo->nDataIndex, e_DefaultBit, TRUE);
    }

    return pDest + GetLength();
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CDataTable::TranslateToNewHeap(CPropertyLookupTable* pLookupTable,
        BOOL bIsClass,
        CFastHeap* pCurrentHeap, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    BOOL    fReturn = TRUE;

    // Copy individual values
    // ======================

    for(int i = 0; i < pLookupTable->GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pLookupTable->GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(
            pLookupTable->GetHeap());
        
        // Make sure this instance sets it to something!
        // =============================================

        if(IsDefault(pInfo->nDataIndex) && !bIsClass) continue;

        // Translate to the new heap
        // =========================

        if(!IsNull(pInfo->nDataIndex))
        {
            CStaticPtr Source(m_pData + pInfo->nDataOffset);

            // Check for allocation failure.
            fReturn = CUntypedValue::TranslateToNewHeap(
                    &Source,
                    CType::GetActualType(pInfo->nType),
                    pCurrentHeap, pNewHeap);

            if ( !fReturn ) 
            {
                break;
            }
        }
    }

    return fReturn;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
//        CPropertyLookupTable* pOldTable, CPropertyLookupTable* pNewTable, 
LPMEMORY CDataTable::CreateLimitedRepresentation(
        CLimitationMapping* pMap, BOOL bIsClass,
        CFastHeap* pOldHeap,  CFastHeap* pNewHeap, 
        LPMEMORY pDest)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    // Figure out the size of the nullness table
    // =========================================

    CNullnessTable* pDestBitTable = (CNullnessTable*)pDest;
    int nNullnessLength = 
        CNullnessTable::GetNecessaryBytes(pMap->GetNumMappings());
    LPMEMORY pData = pDest + nNullnessLength;

    // Enumerate all property mappings
    // ===============================

    pMap->Reset();
    CPropertyInformation NewInfo;
    CPropertyInformation OldInfo;
    while(pMap->NextMapping(&OldInfo, &NewInfo))
    {
        // Copy the nullness data for the property
        // =======================================

        pDestBitTable->SetBit(NewInfo.nDataIndex, e_NullnessBit,
            IsNull(OldInfo.nDataIndex));
        pDestBitTable->SetBit(NewInfo.nDataIndex, e_DefaultBit,
            IsDefault(OldInfo.nDataIndex));

        // Copy the real data for the property
        // ===================================

        if(!IsNull(OldInfo.nDataIndex) && 
            (bIsClass || !IsDefault(OldInfo.nDataIndex)))
        {
            CStaticPtr OldSource((LPMEMORY)GetOffset(OldInfo.nDataOffset));
            CStaticPtr NewSource(pData + NewInfo.nDataOffset);

            // Check for allocation failures
            if ( !CUntypedValue::CopyTo(&OldSource, OldInfo.nType, &NewSource, 
                    pOldHeap, pNewHeap) )
            {
                return NULL;
            }
        }
    }

    return pData + pMap->GetVtableLength();
}

LPMEMORY CDataTable::WriteSmallerVersion(int nNumProps, length_t nDataLen, 
                                            LPMEMORY pMem)
{
    // Calculate the length of the nullness portion
    // ============================================

    length_t nNullnessLength = CNullnessTable::GetNecessaryBytes(nNumProps);
    
    // Copy nullness
    // =============

    LPMEMORY pCurrent = pMem;
    memcpy(pCurrent, (LPMEMORY)m_pNullness, nNullnessLength);
    pCurrent += nNullnessLength;

    // Copy data
    // =========

    memcpy(pCurrent, m_pData, nDataLen - nNullnessLength);
    
    return pCurrent + nDataLen - nNullnessLength;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
CLimitationMapping::CLimitationMapping()
    : m_nCurrent(0), m_apOldList(NULL), m_nNumCommon(0), 
#ifdef DEBUG_CLASS_MAPPINGS
        m_pClassObj( NULL ),
#endif
        m_nCommonVtableLength(0)
{
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************

CLimitationMapping::~CLimitationMapping()
{
    for(int i = 0; i < m_aMappings.Size(); i++)
    {
        delete (COnePropertyMapping*)m_aMappings[i];
    }

    delete [] m_apOldList;

#ifdef DEBUG_CLASS_MAPPINGS
    if ( NULL != m_pClassObj )
    {
        m_pClassObj->Release();
    }
#endif
}


//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CLimitationMapping::Build(int nPropIndexBound)
{
    if(m_apOldList)
        delete [] (LPMEMORY)m_apOldList;
    m_apOldList = new CPropertyInformation*[nPropIndexBound];

    if ( NULL == m_apOldList )
    {
        throw CX_MemoryException();
    }

    memset((void*)m_apOldList, 0,
            nPropIndexBound * sizeof(CPropertyInformation*));

    m_nPropIndexBound = nPropIndexBound;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CLimitationMapping::Map(
        COPY CPropertyInformation* pOldInfo,
        COPY CPropertyInformation* pNewInfo,
        BOOL bCommon)
{
    // Add it to property location map
    // ===============================

    COnePropertyMapping* pOne = new COnePropertyMapping;

    if ( NULL == pOne )
    {
        throw CX_MemoryException();
    }

    CopyInfo(pOne->m_OldInfo, *pOldInfo);
    CopyInfo(pOne->m_NewInfo, *pNewInfo);

    // Check for OOM
    if ( m_aMappings.Add((LPVOID)pOne) != CFlexArray::no_error )
    {
        throw CX_MemoryException();
    }

    if(bCommon)
        m_nNumCommon = m_aMappings.Size();

    // Add it to the inclusion list
    // ============================

    if(bCommon && m_apOldList)
        m_apOldList[pOldInfo->nDataIndex] = &pOne->m_NewInfo;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CLimitationMapping::NextMapping(OUT CPropertyInformation* pOldInfo,
                                     OUT CPropertyInformation* pNewInfo)
{
    if(m_nCurrent == m_aMappings.Size()) return FALSE;
    COnePropertyMapping* pOne =
        (COnePropertyMapping*)m_aMappings[m_nCurrent++];
    CopyInfo(*pOldInfo, pOne->m_OldInfo);
    CopyInfo(*pNewInfo, pOne->m_NewInfo);
    return TRUE;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
propindex_t CLimitationMapping::GetMapped(
                        IN propindex_t nIndex)
{
    // Look up the data index in the inclusion table
    // =============================================

    if(m_apOldList == NULL)
    {
        // That means everything is included
        // =================================

        return nIndex;
    }

    if(nIndex >= m_nPropIndexBound)
    {
        // out of range of included properties
        // ===================================

        return -1;
    }

    return m_apOldList[nIndex]->nDataIndex;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
INTERNAL CPropertyInformation* CLimitationMapping::GetMapped(
                        IN CPropertyInformation* pOldInfo)
{
    // Look up the data index in the inclusion table
    // =============================================

    if(m_apOldList == NULL)
    {
        // That means everything is included
        // =================================

        return pOldInfo;
    }

    int nIndex = pOldInfo->nDataIndex;
    if(nIndex >= m_nPropIndexBound)
    {
        // out of range of included properties
        // ===================================

        return NULL;
    }

    return m_apOldList[nIndex];
}
//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CLimitationMapping::RemoveSpecific()
{
    // Remove all property mappings after m_nNumCommon
    // ===============================================

    while(m_nNumCommon < m_aMappings.Size())
    {
        delete (COnePropertyMapping*)m_aMappings[m_nNumCommon];
        m_aMappings.RemoveAt(m_nNumCommon);
    }

    m_nVtableLength = m_nCommonVtableLength;
}
BOOL CPropertyInformation::IsOverriden(CDataTable* pDataTable)
{
    return !CType::IsParents(nType) ||               // defined locally
           !pDataTable->IsDefault(nDataIndex) ||        // new default value
           CBasicQualifierSet::HasLocalQualifiers(   // new qualifiers
                GetQualifierSetData());
}

#ifdef DEBUG_CLASS_MAPPINGS
void CLimitationMapping::SetClassObject( CWbemClass* pClassObj )
{
    if ( NULL != pClassObj )
    {
        pClassObj->AddRef();
    }

    if ( NULL != m_pClassObj )
    {
        m_pClassObj->Release();
    }

    m_pClassObj = pClassObj;
}

HRESULT CLimitationMapping::ValidateInstance( CWbemInstance* pInst )
{
    if ( NULL == m_pClassObj )
    {
        return WBEM_E_FAILED;
    }

    if ( !pInst->IsInstanceOf( m_pClassObj ) )
    {
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprbg.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FASTPRBG.H

Abstract:

  CFastPropertyBag Definition.

  Implements an array of property data for minimal storage.

History:

  24-Feb-2000	sanjes    Created.

--*/

#ifndef _FASTPRBG_H_
#define _FASTPRBG_H_

#include "corepol.h"
#include <arena.h>
#include "fastval.h"
#include "arrtempl.h"

// Storage class for property names and their associated data
class CFastPropertyBagItem
{
private:
	WString	m_wsPropertyName;
	BYTE	m_bRawData[MAXIMUM_FIXED_DATA_LENGTH];
	CIMTYPE	m_ctData;
	ULONG	m_uDataLength;
	ULONG	m_uNumElements;
	LPVOID	m_pvData;
	long	m_lRefCount;

public:

	CFastPropertyBagItem( LPCWSTR pszName, CIMTYPE ctData, ULONG uDataLength, ULONG uNumElements, LPVOID pvData );
	~CFastPropertyBagItem();

	// AddRef/Release methods
	ULONG	AddRef( void );
	ULONG	Release( void );

	BOOL IsPropertyName( LPCWSTR pszName )
	{	return m_wsPropertyName.EqualNoCase( pszName );	}

	void GetData( CIMTYPE* pct, ULONG* puDataLength, ULONG* puNumElements, LPVOID*ppvData )
	{ *pct = m_ctData;	*puDataLength = m_uDataLength;	*puNumElements = m_uNumElements; *ppvData = m_pvData; }
	void GetData( LPCWSTR* ppwszName, CIMTYPE* pct, ULONG* puDataLength, ULONG* puNumElements, LPVOID*ppvData )
	{ *ppwszName = m_wsPropertyName; *pct = m_ctData;	*puDataLength = m_uDataLength;
		*puNumElements = m_uNumElements; *ppvData = m_pvData; }
};

// Workaround for import/export issues
class COREPROX_POLARITY CPropertyBagItemArray : public CRefedPointerArray<CFastPropertyBagItem>
{
public:
	CPropertyBagItemArray() {};
	~CPropertyBagItemArray() {};
};

//***************************************************************************
//
//  class CFastPropertyBag
//
//  Implementation of our comless property bag
//
//***************************************************************************

class COREPROX_POLARITY CFastPropertyBag
{
protected:

	CPropertyBagItemArray	m_aProperties;

	// Locates an item
	CFastPropertyBagItem*	FindProperty( LPCWSTR pszName );
	// Locates an item
	int	FindPropertyIndex( LPCWSTR pszName );

public:

    CFastPropertyBag();
	virtual ~CFastPropertyBag(); 

	HRESULT Add( LPCWSTR pszName, CIMTYPE ctData, ULONG uDataLength, ULONG uNumElements, LPVOID pvData );
	HRESULT Get( LPCWSTR pszName, CIMTYPE* pctData, ULONG* puDataLength, ULONG* puNumElements, LPVOID* pvData );
	HRESULT Get( int nIndex, LPCWSTR* ppszName, CIMTYPE* pctData, ULONG* puDataLength, ULONG* puNumElements,
				LPVOID* pvData );
	HRESULT Remove( LPCWSTR pszName );
	HRESULT RemoveAll( void );

	HRESULT	Copy( const CFastPropertyBag& source );

	// How many are there?
	int Size( void ) { return m_aProperties.GetSize(); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprox.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROX.H

Abstract:

    Object Marshaling

History:

--*/

#ifndef __FAST_WRAPPER__H_
#define __FAST_WRAPPER__H_
#pragma warning (disable : 4786)

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include <clsfac.h>
#include <wbemutil.h>
#include <fastall.h>

class CFastProxy : public IMarshal
{
protected:
    long m_lRef;

public:

    CFastProxy(CLifeControl* pControl) : m_lRef(0){}

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);
};

class CClassObjectFactory : public CBaseClassFactory
{
public:

    CClassObjectFactory( CLifeControl* pControl = NULL ) 
    : CBaseClassFactory( pControl ) {} 

    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        if(pOuter)
            return CLASS_E_NOAGGREGATION;
    
        CWbemClass* pNewObj = new CWbemClass;
        
        if ( FAILED( pNewObj->InitEmpty(0) ) )
        {
            return E_FAIL;
        }

        return pNewObj->QueryInterface(riid, ppv);
    }

    HRESULT LockServer( BOOL fLock )
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};        

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastqual.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTQUAL.CPP

Abstract:

  This file implements the classes related to qualifier processing in WbeWbemjects
  See fastqual.h for full documentation and fastqual.inc for  function
  implementations.

  Classes implemented:
      CQualifierFlavor                Encapsulates qualifier flavor infor
      CQualifier                      Represents a qualifier
      CBasicQualifierSet              Represents read-only functionality.
      CQualiferSetContainer           What qualifier set container supports.
      CQualifierSet                   Full-blown qualifier set (template)
      CQualifierSetListContainer      What qualifier set list container supports.
      CQualifierSetList               List of qualifier sets.
      CInstanceQualifierSet           Instance qualifier set.
      CClassQualifierSet              Class qualifier set.
      CClassPQSContainer              Class property qualifier set container
      CClassPropertyQualifierSet      Class property qualifier set
      CInstancePQSContainer           Instance proeprty qualifier set container
      CInstancePropertyQualifierSet   Instance property qualifier set

History:

    2/20/97     a-levn  Fully documented
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
//#include "dbgalloc.h"
#include "wbemutil.h"
#include "fastall.h"
#include "olewrap.h"
#include <arrtempl.h>

#include <assert.h>

WString CQualifierFlavor::GetText()
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    WString wsText;
    if(m_byFlavor == 0)
        return wsText;

    wsText = L":";
    BOOL bFirst = TRUE;

    if(!IsOverridable())
    {
        wsText += L" DisableOverride";
        bFirst = FALSE;
    }

    if(DoesPropagateToInstances())
    {
        wsText += L" ToInstance";
        bFirst = FALSE;
    }

    if(DoesPropagateToDerivedClass())
    {
        wsText += L" ToSubClass";
        bFirst = FALSE;
    }

    if ( IsAmended() )
    {
        wsText += L" Amended";
        bFirst = FALSE;
    }

    return wsText;

}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
length_t CBasicQualifierSet::ComputeNecessarySpaceForPropagation(
        LPMEMORY pStart, BYTE byPropagationFlag)
{
    // Start enumeration of qualifiers
    // ===============================

    CQualifier* pEnd = (CQualifier*)(pStart + GetLengthFromData(pStart));
    CQualifier* pQualifier = GetFirstQualifierFromData(pStart);
    length_t nNewLength = GetMinLength();

    while(pQualifier < pEnd)
    {
        // Check if this qualifier propagates as required
        // ==============================================

        if(pQualifier->fFlavor & byPropagationFlag)
        {
            nNewLength += pQualifier->GetLength();
        }
        pQualifier = (CQualifier*)pQualifier->Next();
    }

    return nNewLength;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
LPMEMORY CBasicQualifierSet::WritePropagatedVersion(CPtrSource* pThis,
        BYTE byPropagationFlag, CPtrSource* pDest,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap)
{
    // Start enumeration of qualifiers
    // ===============================

    CShiftedPtr SourcePtr(pThis, GetMinLength());
    CShiftedPtr EndPtr(pThis, GetLengthFromData(pThis->GetPointer()));
    CShiftedPtr DestPtr(pDest, GetMinLength());

    length_t nNewLength = GetMinLength();

    while(SourcePtr.GetPointer() < EndPtr.GetPointer())
    {
        // Check if this qualifier propagates as required
        // ==============================================

        CQualifier* pSourceQualifier = CQualifier::GetPointer(&SourcePtr);
        if(pSourceQualifier->fFlavor & byPropagationFlag)
        {
            // Copy it to the new localtion (and new heap)
            // ===========================================

            // Check for allocation failures
            if ( !pSourceQualifier->CopyTo(&DestPtr, pOldHeap, pNewHeap) )
            {
                return NULL;
            }

            CQualifier* pDestQualifier = CQualifier::GetPointer(&DestPtr);
            pDestQualifier->fFlavor.SetLocal(FALSE);
            DestPtr += pDestQualifier->GetLength();
        }

        SourcePtr += CQualifier::GetPointer(&SourcePtr)->GetLength();
    }

    // Set length
    // ==========

    *(UNALIGNED length_t*)(pDest->GetPointer()) =
        DestPtr.GetPointer() - pDest->GetPointer();

    return DestPtr.GetPointer();
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
length_t CBasicQualifierSet::ComputeMergeSpace(
                               READ_ONLY LPMEMORY pParentSetData,
                               READ_ONLY CFastHeap* pParentHeap,
                               READ_ONLY LPMEMORY pChildSetData,
                               READ_ONLY CFastHeap* pChildHeap,
                               BOOL bCheckValidity)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    CBasicQualifierSet ParentSet;
    ParentSet.SetData(pParentSetData, pParentHeap);

    CBasicQualifierSet ChildSet;
    ChildSet.SetData(pChildSetData, pChildHeap);

    // Start with the child set, which will go in its entirety
    // =======================================================

    length_t nTotalLength = ChildSet.GetLength();

    // Examine parent's qualifiers
    // ===========================

    CQualifier* pCurrentQual = ParentSet.GetFirstQualifier();
    CQualifier* pParentEnd = (CQualifier*)ParentSet.Skip();

    while(pCurrentQual < pParentEnd)
    {
        // Check if it propagates to child classes
        // =======================================

        if(pCurrentQual->fFlavor.DoesPropagateToDerivedClass())
        {
            // Check that it is not overriden
            // ==============================

            CQualifier* pChildQual = ChildSet.GetQualifierLocally(
                pParentHeap->ResolveString(pCurrentQual->ptrName));

            if(pChildQual == NULL)
            {
                // Propagating non-overriden qualifier. Count it.
                // ==============================================

                nTotalLength += pCurrentQual->GetLength();
            }
            else  if(bCheckValidity)
            {
                // Check if the parent actually allows overrides
                // =============================================

                if(!pCurrentQual->fFlavor.IsOverridable())
                    return 0xFFFFFFFF;
            }
        }

        pCurrentQual = (CQualifier*)pCurrentQual->Next();
    }

    return nTotalLength;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************

LPMEMORY CBasicQualifierSet::Merge(
                               READ_ONLY LPMEMORY pParentSetData,
                               READ_ONLY CFastHeap* pParentHeap,
                               READ_ONLY LPMEMORY pChildSetData,
                               READ_ONLY CFastHeap* pChildHeap,
                               LPMEMORY pDest,  CFastHeap* pNewHeap,
                               BOOL bCheckValidity)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    CBasicQualifierSet ParentSet;
    ParentSet.SetData(pParentSetData, pParentHeap);

    CBasicQualifierSet ChildSet;
    ChildSet.SetData(pChildSetData, pChildHeap);

    // First of all, copy child set, since they all go
    // ===============================================

    memcpy(pDest, ChildSet.GetStart(), ChildSet.GetLength());
    CQualifier* pCurrentNew = (CQualifier*)(pDest + ChildSet.GetLength());

    // Translate it to the new heap
    // ============================

    SetDataLength(pDest, LPMEMORY(pCurrentNew)-pDest);

    CStaticPtr DestPtr(pDest);

    // Check for memory allocation failures
    if ( !TranslateToNewHeap(&DestPtr, pChildHeap, pNewHeap) )
    {
        return NULL;
    }

    // Copy parent's qualifiers conditionaly
    // =====================================

    CQualifier* pCurrentQual = ParentSet.GetFirstQualifier();
    CQualifier* pParentEnd = (CQualifier*)ParentSet.Skip();

    while(pCurrentQual < pParentEnd)
    {
        // Check if it propagates to child classes
        // =======================================

        if(pCurrentQual->fFlavor.DoesPropagateToDerivedClass())
        {
            // Check that it is not overriden
            // ==============================

            CQualifier* pChildQual = ChildSet.GetQualifierLocally(
                pParentHeap->ResolveString(pCurrentQual->ptrName));

            if(pChildQual == NULL)
            {
                // Propagating non-overriden qualifier. Copy it.
                // =============================================

                CStaticPtr CurrentNewPtr((LPMEMORY)pCurrentNew);

                // Check for memory allocation failures
                if ( !pCurrentQual->CopyTo(&CurrentNewPtr, pParentHeap, pNewHeap) )
                {
                    return NULL;
                }

                pCurrentNew->fFlavor.SetLocal(FALSE);
                pCurrentNew = (CQualifier*)pCurrentNew->Next();
            }
            else  if(bCheckValidity)
            {
                // Check if the parent actually allows overrides
                // =============================================

                if(!pCurrentQual->fFlavor.IsOverridable())
                    return NULL;
            }
        }

        pCurrentQual = (CQualifier*)pCurrentQual->Next();
    }

    // Set the length appropriately
    // ============================

    SetDataLength(pDest, (LPMEMORY)pCurrentNew - pDest);
    return (LPMEMORY)pCurrentNew;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
length_t CBasicQualifierSet::ComputeUnmergedSpace(
                          READ_ONLY LPMEMORY pMergedData)
{
    CQualifier* pCurrentMerged = GetFirstQualifierFromData(pMergedData);
    CQualifier* pMergedEnd =
        (CQualifier*)(pMergedData + GetLengthFromData(pMergedData));

    length_t nTotalLength = GetMinLength();

    while(pCurrentMerged < pMergedEnd)
    {
        // Check if it is local or not
        // ===========================

        if(pCurrentMerged->fFlavor.IsLocal())
        {
            // Count it
            // ========

            nTotalLength += pCurrentMerged->GetLength();
        }
        pCurrentMerged = (CQualifier*)pCurrentMerged->Next();
    }

    return nTotalLength;
}


//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************

LPMEMORY CBasicQualifierSet::Unmerge(
                          READ_ONLY LPMEMORY pMergedData,
                          READ_ONLY CFastHeap* pMergedHeap,
                          NEW_OBJECT LPMEMORY pDest,
                          MODIFY CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    CQualifier* pCurrentMerged = GetFirstQualifierFromData(pMergedData);
    CQualifier* pMergedEnd =
        (CQualifier*)(pMergedData + GetLengthFromData(pMergedData));

    CQualifier* pCurrentNew = GetFirstQualifierFromData(pDest);
    while(pCurrentMerged < pMergedEnd)
    {
        // Check if it is local or not
        // ===========================

        if(pCurrentMerged->fFlavor.IsLocal())
        {
            // Copy yo destination
            // ===================

            CStaticPtr CurrentNewPtr((LPMEMORY)pCurrentNew);

            // Check for allocation failure
            if ( !pCurrentMerged->CopyTo(&CurrentNewPtr, pMergedHeap, pNewHeap) )
            {
                return NULL;
            }

            pCurrentNew = (CQualifier*)pCurrentNew->Next();
        }
        pCurrentMerged = (CQualifier*)pCurrentMerged->Next();
    }

    // Set the length
    // ==============

    SetDataLength(pDest, LPMEMORY(pCurrentNew) - pDest);
    return (LPMEMORY)pCurrentNew;
}


//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************

HRESULT CBasicQualifierSet::EnumPrimaryQualifiers(BYTE eFlags, BYTE fFlavorMask,
                                   CFixedBSTRArray& astrMatching,
                                   CFixedBSTRArray& astrNotMatching
                                   )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Divide  qualifiers into those matching and not macching the
    // criteria
    // ================================================================

    try
    {
        astrMatching.Create(GetNumUpperBound());
        astrNotMatching.Create(GetNumUpperBound());

        int nMatchingIndex = 0, nNotMatchingIndex = 0;

        CQualifier* pEnd = (CQualifier*)Skip();

        CQualifier* pCurrent = (CQualifier*)m_pOthers;
        while(pCurrent < pEnd)
        {
            // Check that this qualifier is valid
            // ==================================

            if(pCurrent->ptrName == INVALID_HEAP_ADDRESS) continue;

            // Resolve the name
            // ================

            CCompressedString* pName = GetHeap()->
                                        ResolveString(pCurrent->ptrName);

            // Check if it matches the propagation mask and the flags
            // ======================================================

            if((pCurrent->fFlavor & fFlavorMask) == fFlavorMask &&
                (eFlags != WBEM_FLAG_LOCAL_ONLY || pCurrent->fFlavor.IsLocal()) &&
                (eFlags != WBEM_FLAG_PROPAGATED_ONLY || !pCurrent->fFlavor.IsLocal())
            )
            {
                astrMatching[nMatchingIndex++] = pName->CreateBSTRCopy();

                // Check for allocation failures
                if ( NULL == astrMatching[nMatchingIndex-1] )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
            }
            else
            {
                astrNotMatching[nNotMatchingIndex++] = pName->CreateBSTRCopy();

                // Check for allocation failures
                if ( NULL == astrNotMatching[nNotMatchingIndex-1] )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }

            }

            // Go to the next qualifier
            // ========================

            pCurrent = (CQualifier*)pCurrent->Next();
        }

        if ( SUCCEEDED( hr ) )
        {
            astrMatching.SetLength(nMatchingIndex);
            astrMatching.SortInPlace();
            astrNotMatching.SetLength(nNotMatchingIndex);
            astrNotMatching.SortInPlace();
        }
        else
        {
            // Cleanup if failed
            astrMatching.Free();
            astrNotMatching.Free();
        }

        return hr;
    }
    catch( CX_MemoryException )
    {
        // Cleanup if failed
        astrMatching.Free();
        astrNotMatching.Free();

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        // Cleanup if failed
        astrMatching.Free();
        astrNotMatching.Free();

        return WBEM_E_FAILED;
    }

}


HRESULT CBasicQualifierSet::IsValidQualifierSet( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //  Enumerate the qualifiers, and check that names and ptr data
    //  Are inside the heap
    // ================================================================

    LPMEMORY    pHeapStart = m_pHeap->GetHeapData();
    LPMEMORY    pHeapEnd = m_pHeap->GetStart() + m_pHeap->GetLength();

    CQualifier* pEnd = (CQualifier*)Skip();
    CQualifier* pCurrent = (CQualifier*)m_pOthers;
    while(pCurrent < pEnd)
    {
        // Check that this qualifier is valid
        // ==================================

        if(pCurrent->ptrName == INVALID_HEAP_ADDRESS)
        {
            pCurrent = (CQualifier*)pCurrent->Next();
            continue;
        }

        // Resolve the name
        // ================

        LPMEMORY pName = ( CFastHeap::IsFakeAddress( pCurrent->ptrName ) ?
                        NULL : m_pHeap->ResolveHeapPointer(pCurrent->ptrName) );
        
        if ( ( NULL == pName ) ||  ( pName >= pHeapStart && pName < pHeapEnd  ) )
        {

            if ( CType::IsPointerType( pCurrent->Value.GetType() ) )
            {
                LPMEMORY    pData = m_pHeap->ResolveHeapPointer(  pCurrent->Value.AccessPtrData() );

                if ( pData >= pHeapStart && pData < pHeapEnd  )
                {
                    // We could, if an embedded object, validate the object,
                    // or if an array of ptr values, validate those as well

                    if ( pCurrent->Value.GetType().IsArray() )
                    {
                        HRESULT hres = ((CUntypedArray*) pData)->IsArrayValid( pCurrent->Value.GetType(), m_pHeap );

                        if ( FAILED( hres ) )
                        {
                            return hres;
                        }
                    }

                }
                else
                {
                    OutputDebugString(__TEXT("Winmgmt: Bad Qualifier value pointer!"));
                    FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad Qualifier value pointer!") );
                    return WBEM_E_FAILED;
                }

            }

        }
        else
        {
            OutputDebugString(__TEXT("Winmgmt: Bad qualifier name pointer!"));
            FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad qualifier name pointer!") );
            return WBEM_E_FAILED;
        }

        // Go to the next qualifier
        // ========================

        pCurrent = (CQualifier*)pCurrent->Next();
    }

    return hr;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CBasicQualifierSet::GetText(READ_ONLY LPMEMORY pData,
                                 READ_ONLY CFastHeap* pHeap,
                                 long lFlags,
                                 NEW_OBJECT OUT WString& wsText)
{
	try
	{
		// DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
		// if an exception is thrown

		BOOL bFirst = TRUE;

		// Loop through the qualifiers
		// ===========================

		CQualifier* pCurrent = GetFirstQualifierFromData(pData);
		CQualifier* pEnd = (CQualifier*)(pData + GetLengthFromData(pData));

		while(pCurrent < pEnd)
		{
			// Make sure it is ours, not inherited
			// ===================================

			BSTR strName = NULL;

			try
			{
				if(pCurrent->fFlavor.IsLocal())
				{
					// We will throw an exception in case of OOM
					strName = pHeap->ResolveString(pCurrent->ptrName)->
											CreateBSTRCopy();

					if ( NULL == strName )
					{
						throw CX_MemoryException();
					}

					// If this is an in,out value, replace "in" or "out" with
					// "in,out"
					if( ( lFlags & WBEM_FLAG_IS_INOUT )
						&& ( wbem_wcsicmp( strName, L"in" ) == 0
						||   wbem_wcsicmp( strName, L"out" ) == 0 ) )
					{
						// Cleanup the existing value and NULL it out in case another exception is
						// thrown
						COleAuto::_SysFreeString( strName );
						strName = NULL;
						strName = COleAuto::_SysAllocString( L"in,out" );
					}


					// Make sure it is not 'syntax'
					// Ignore ID if required
					// =====================

					if((lFlags & WBEM_FLAG_IGNORE_IDS) && !wbem_wcsicmp(strName, L"id"))
					{
						// Nothing to do
					}

					// ===========================

					else if(wbem_wcsicmp(strName, TYPEQUAL))
					{
						// Write the separator, if required
						// ================================

						if(!bFirst)
						{
							wsText += L", ";
						}
						else
						{
							wsText += L"[";
							bFirst = FALSE;
						}


						// Write the name
						// ==============

						wsText += strName;

						// Write the value
						// ===============

						if(pCurrent->Value.GetType().GetActualType() == VT_BOOL &&
							pCurrent->Value.GetBool())
						{
							// boolean and true -- no value required
						}
						else
						{
							// We need to make sure we cleanup the BSTR here.
							// CSysFreeMe will even work during an exception
							BSTR strVal = NULL;

							CVar var;

							pCurrent->Value.StoreToCVar(var, pHeap);
							if(pCurrent->Value.GetType().IsArray())
							{
								wsText += L"{";

								strVal = var.GetVarVector()->GetText(0);
								CSysFreeMe sfmVal(strVal);

								// Check for a NULL return
								if ( NULL == strVal )
								{
									COleAuto::_SysFreeString( strName );
									return WBEM_E_INVALID_QUALIFIER;
								}

								wsText += strVal;
								wsText += L"}";
							}
							else
							{
								wsText += L"(";

								strVal = var.GetText(0);
								CSysFreeMe sfmVal(strVal);

								// Check for a NULL return
								if ( NULL == strVal )
								{
									COleAuto::_SysFreeString( strName );
									return WBEM_E_INVALID_QUALIFIER;
								}

								wsText += strVal;
								wsText += L")";
							}

						}

						if((lFlags & WBEM_FLAG_NO_FLAVORS) == 0)
						{
							// Write the flavor
							// ================

							if(wbem_wcsicmp(strName, L"key"))
							{
								wsText += pCurrent->fFlavor.GetText();
							}
						}

					}

					// Cleanup strName
					COleAuto::_SysFreeString( strName );
					strName = NULL;

				}
			}
			catch (...)
			{
				// Cleanup strName if necessary, then rethrow the exception.
				if ( NULL != strName )
				{
					COleAuto::_SysFreeString( strName );
				}

				throw;
			}

			pCurrent = (CQualifier*)pCurrent->Next();
		}

		if(!bFirst)
			wsText += L"]";

		return WBEM_S_NO_ERROR;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CBasicQualifierSet::Compare( CBasicQualifierSet& qsThat, BYTE eFlags, LPCWSTR* ppFilters, DWORD dwNumFilters )
{
    BOOL            fReturn = TRUE;

    CFixedBSTRArray astrNamesThis,
                    astrNamesThisFailed,
                    astrNamesThat,
                    astrNamesThatFailed;

    // We will throw exceptions in OOM scenarios

    // Get the names of the qualifiers in each set.

    HRESULT hr = EnumPrimaryQualifiers( eFlags, 0, astrNamesThis, astrNamesThisFailed );
    
    if ( FAILED( hr ) )
    {

        // If we got out of memory, throw an exception
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    hr = qsThat.EnumPrimaryQualifiers( eFlags, 0, astrNamesThat, astrNamesThatFailed );

    if ( FAILED( hr ) )
    {
        // Cleanup
        astrNamesThis.Free();
        astrNamesThisFailed.Free();

        // If we got out of memory, throw an exception
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    // Filter the arrays if we need to
    if ( NULL != ppFilters )
    {
        // Filter out all appropriate values

        // The array should free any "found" elements
        for ( int x = 0; x < dwNumFilters; x++ )
        {
            astrNamesThis.Filter( ppFilters[x], TRUE );
            astrNamesThat.Filter( ppFilters[x], TRUE );
        }

    }

    // Each must have the same number of names
    if ( astrNamesThis.GetLength() == astrNamesThat.GetLength() )
    {
        
        // Enum the qualifiers, checking that names and values
        // match

        for (   int i = 0;
                fReturn && i < astrNamesThis.GetLength();
                i++ )
        {

            // Qualifiers MUST be in the same order, so check that the two names
            // are equal
            if ( wbem_wcsicmp( astrNamesThis[i], astrNamesThat[i] ) == 0 )
            {

                CQualifier* pQualifierThis = GetQualifierLocally( astrNamesThis[i] );
                CQualifier* pQualifierThat = qsThat.GetQualifierLocally( astrNamesThat[i] );

                // Must have qualifier pointers, and flavors MUST match.
                if (    NULL != pQualifierThis
                    &&  NULL != pQualifierThat
                    &&  pQualifierThis->fFlavor == pQualifierThat->fFlavor )
                {
                    CVar    varThis,
                            varThat;

                    // We will throw exceptions in OOM scenarios

                    // Check for allocation failures
                    if ( !pQualifierThis->Value.StoreToCVar( varThis, GetHeap() ) )
                    {
                        throw CX_MemoryException();
                    }

                    // Check for allocation failures
                    if ( fReturn && !pQualifierThat->Value.StoreToCVar( varThat, qsThat.GetHeap() ) )
                    {
                        throw CX_MemoryException();
                    }

                    // Types must match
                    if ( fReturn && pQualifierThis->Value.GetType() == pQualifierThat->Value.GetType() )
                    {
                        // Compare the CVars
                        fReturn = ( varThis == varThat );
                    }
                    else
                    {
                        fReturn = FALSE;
                    }
                }   // IF got qualifiers, flavors and IsLocal match
                else
                {
                    fReturn = FALSE;
                }

            }   // IF names equal
            else
            {
                // Names NOT in exact order
                fReturn = FALSE;
            }

        }   // FOR iterate qualifier names

    }   // bstr Array lengths different
    else
    {
        // We don't have the same number of qualifiers
        fReturn = FALSE;
    }

    // Clear arrays.
    astrNamesThis.Free();
    astrNamesThisFailed.Free();
    astrNamesThat.Free();
    astrNamesThatFailed.Free();

    return fReturn;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CBasicQualifierSet::CompareLocalizedSet( CBasicQualifierSet& qsThat )
{
    BOOL            fReturn = TRUE;
    
    CWStringArray   wstrFilters;

    CFixedBSTRArray astrNamesThis,
                    astrNamesThisFailed;

    try
    {
        // Get the names of all the qualifiers in each set.
        HRESULT hr = EnumPrimaryQualifiers( 0, 0, astrNamesThis, astrNamesThisFailed );
        
        if ( FAILED( hr ) )
        {
            // If we failed because of out of memory, throw an exception.  Otherwise, just
            // return FALSE

            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                throw CX_MemoryException();
            }

            return FALSE;
        }

        // Now we need to create an array of filters.  To do this, first add the "amendment" and
        // "locale" qualifiers

        // Now walk through all of our qualifiers.  For each one we find that meets one of our criteria,
        // that it is "amendment", "locale", or marked with the IsAmended flavor we should add it to
        // the filters array

        for (   int i = 0;
                fReturn && i < astrNamesThis.GetLength();
                i++ )
        {
            BOOL    fLocalized = FALSE;
            BOOL    fAdd = FALSE;

            CQualifier* pQualifierThis = GetQualifierLocally( astrNamesThis[i] );

            // If we couldn't get a qualifier that was named in our list, we've got
            // serious problems
            if ( NULL != pQualifierThis )
            {
                // Amendment and locale qualifiers are ALWAYS local
                if ( wbem_wcsicmp( astrNamesThis[i], L"amendment" ) == 0 )
                {
                    fLocalized = TRUE;
                }
                else if ( wbem_wcsicmp( astrNamesThis[i], L"locale" ) == 0 )
                {
                    fLocalized = TRUE;
                }
                else
                {
                    // If it's amended, it's a localization value.
                    fLocalized = CQualifierFlavor::IsAmended( pQualifierThis->GetFlavor() );
                }

                // If it is localized, see if it's in the other qualifier set.  If so, then
                // we will check that type and flavor values make sense.  If so, we will
                // ignore the qualifier.  If it's not in the other set, we should filter it

                if ( fLocalized )
                {
                    
                    CQualifier* pQualifierThat = qsThat.GetQualifierLocally( astrNamesThis[i] );

                    if ( NULL != pQualifierThat )
                    {
                        // Types must match
                        fReturn = ( pQualifierThis->Value.GetType() == pQualifierThat->Value.GetType() );

                        if ( fReturn )
                        {
                            // Check the flavors after masking out the amended flavor bit
                            BYTE bThisFlavor = pQualifierThis->GetFlavor() & ~WBEM_FLAVOR_MASK_AMENDED;
                            BYTE bThatFlavor = pQualifierThat->GetFlavor() & ~WBEM_FLAVOR_MASK_AMENDED;

                            // We also want to mask out the origin bit, since during localization
                            // a qualifier from a base class may get tagged onto a derived class.

                            bThisFlavor &= ~WBEM_FLAVOR_MASK_ORIGIN;
                            bThatFlavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

                            // If the two match, we will assume that this qualifier should
                            // be filtered out.
                            fAdd = fReturn = ( bThisFlavor == bThatFlavor );
                        }

                    }
                    else
                    {
                        // It's in 'this' one but not 'that' one.  Filter it.
                        fAdd = TRUE;
                    }

                }   // If it's a localized qualifier

            }   // IF got this qualifier
            else
            {
                // Hmmm...we didn't find the qualifier even though it was
                // in our list.
                fReturn = FALSE;
            }

            // If we should add it, do it now
            if ( fAdd && fReturn )
            {
                if ( wstrFilters.Add( astrNamesThis[i] ) != CWStringArray::no_error )
                {
                    throw CX_MemoryException();
                }
            }   // If we should add to the filter list

        }   // For enumerate names

        // Empty out our lists.
        astrNamesThis.Free();
        astrNamesThisFailed.Free();

        // Now that we have an appropriate filter list, do a regular comparison
        if ( fReturn )
        {
            fReturn = Compare( qsThat, 0L, wstrFilters.GetArrayPtr(), wstrFilters.Size() );
        }

        return fReturn;

    }
    catch(...)
    {
        // Clear arrays and re-throw
        astrNamesThis.Free();
        astrNamesThisFailed.Free();
        throw;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CBasicQualifierSet::CanBeReconciledWith( CBasicQualifierSet& qsThat )
{
    BOOL            fReturn = TRUE;

    CFixedBSTRArray astrNamesThat,
                    astrNamesThatFailed;
    // We will throw exceptions in OOM scenarios

    // Get the names of the qualifiers in each set.

    HRESULT hr = qsThat.EnumPrimaryQualifiers( WBEM_FLAG_LOCAL_ONLY, 0, astrNamesThat, astrNamesThatFailed );
    
    if ( FAILED( hr ) )
    {

        // Throw an exception if OOM
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    // Names in the new set are checked against the old set.
    // Enum the qualifiers, checking that names and values
    // match.

    for (   int i = 0;
            fReturn && i < astrNamesThat.GetLength();
            i++ )
    {

        CQualifier* pQualifierThis = GetQualifierLocally( astrNamesThat[i] );
        CQualifier* pQualifierThat = qsThat.GetQualifierLocally( astrNamesThat[i] );

        // Make sure we got a value from the new set
        if ( NULL != pQualifierThat )
        {
            // We handle things differently depending on whether or
            // not the qualifier exists in the previous version
            if ( NULL != pQualifierThis )
            {

                // Note here that for important qualifiers, we will
                // already have made sure that those values matched up
                // (most are hardcoded anyways).  Reconciliation
                // mostly applies to unimportant qualifiers.

                // If flavors are equal, we're fine.  If not, check for
                // propagation flags.

                if ( pQualifierThat->fFlavor != pQualifierThis->fFlavor )
                {
                
                    if ( CQualifierFlavor::DoesPropagateToInstances(
                            pQualifierThat->fFlavor )
                        || CQualifierFlavor::DoesPropagateToDerivedClass(
                            pQualifierThat->fFlavor ) )
                    {

                        // If it's propagated, then if it is not overrideable
                        // check that the previous value was also not
                        // overrideable.

                        if ( !CQualifierFlavor::IsOverridable(
                                    pQualifierThat->fFlavor ) )
                        {

                            // If the previous value was overrideable,
                            // changing this class could affect existing
                            // instances/derived classes so this will
                            // fail

                            if ( !CQualifierFlavor::IsOverridable(
                                    pQualifierThis->fFlavor ) )
                            {
                                // if it was not overrideable, then the previous
                                // propagation flags MUST match or we will
                                // fail the operation, since we may now be propagating
                                // to an entity to which we were not previously
                                // doing so.

                                fReturn = ( (   CQualifierFlavor::DoesPropagateToInstances(
                                                    pQualifierThis->fFlavor ) ==
                                                CQualifierFlavor::DoesPropagateToInstances(
                                                    pQualifierThat->fFlavor )   )   &&
                                            (   CQualifierFlavor::DoesPropagateToDerivedClass(
                                                    pQualifierThis->fFlavor ) ==
                                                CQualifierFlavor::DoesPropagateToDerivedClass(
                                                    pQualifierThat->fFlavor )   )   );
                            }
                            else
                            {

                                fReturn = FALSE;
                            }

                        }   // IF not overrideable

                    }   // IF propagated

                }   // IF flavors did not match

            }   // IF got that qualifier
            else
            {
                // If we are here, the qualifier is a new one.

                // If the qualifier propagates to instances/
                // derived classes, then we need to check if
                // the qualifier is overrideable.  If not, then
                // we will fail, because existing classes/instances
                // may have unknowingly already overridden this
                // qualifier.

                if ( CQualifierFlavor::DoesPropagateToInstances(
                        pQualifierThat->fFlavor )
                    || CQualifierFlavor::DoesPropagateToDerivedClass(
                        pQualifierThat->fFlavor ) )
                {
                    fReturn = CQualifierFlavor::IsOverridable(
                            pQualifierThat->fFlavor );
                }   // IF qualifier propagated

            }   // ELSE no qualifier in this

        }   // IF NULL != pQualifierThat
        else
        {
            // WHOOPS!  Got a name but no qualifier...something is wrong
            fReturn = FALSE;
        }

    }   // FOR enum qualifiers

    // Clear arrays.
    astrNamesThat.Free();
    astrNamesThatFailed.Free();

    return fReturn;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
CQualifierSet::CQualifierSet(int nPropagationFlag, int nStartRef) :
  m_nCurrentIndex(-1), m_nPropagationFlag(nPropagationFlag),
      m_nRef(nStartRef)
{
    ObjectCreated(OBJECT_TYPE_QUALIFIER,this);
}
CQualifierSet::~CQualifierSet()
{
    m_astrCurrentNames.Free();
    ObjectDestroyed(OBJECT_TYPE_QUALIFIER,this);
}

// Like doing a set, but only performs validaton
HRESULT CQualifierSet::ValidateSet(COPY LPCWSTR wszName, 
                     BYTE fFlavor,
                     COPY CTypedValue* pNewValue,
                     BOOL bCheckPermissions,
					 BOOL fValidateName )
{

    // Try to find it first
    // ====================

    HRESULT hr = WBEM_S_NO_ERROR;
    int nKnownIndex;
    CQualifier* pOldQual = GetQualifierLocally(wszName, nKnownIndex);

    // Special case "key"
    // ==================

    if(!wbem_wcsicmp(wszName, L"key"))
    {
        if  ( bCheckPermissions )
        {
            hr = m_pContainer->CanContainKey();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Key properties cannnot be dynamic
        if ( NULL != GetQualifier( L"dynamic" ) )
        {
            return WBEM_E_INVALID_QUALIFIER;
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
/*
        if ( fFlavor != ENFORCED_KEY_FLAVOR )
        {
            return WBEM_E_INVALID_FLAVOR;
        }
*/
        fFlavor = ENFORCED_KEY_FLAVOR;
    }

    // Special case "singleton"
    // ========================

    if(!wbem_wcsicmp(wszName, L"singleton"))
    {
        if( bCheckPermissions )
        {
            hr = m_pContainer->CanContainSingleton();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
/*
        if ( fFlavor != ENFORCED_SINGLETON_FLAVOR )
        {
            return WBEM_E_INVALID_FLAVOR;
        }
*/
        fFlavor = ENFORCED_SINGLETON_FLAVOR;
    }

    // Special case "dynamic"
    // ========================

    if(!wbem_wcsicmp(wszName, L"dynamic"))
    {
        // Check that the container will allow this
        if ( bCheckPermissions )
        {
            hr = m_pContainer->CanContainDynamic();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Dynamic properties cannnot be keys
        if ( NULL != GetQualifier( L"key" ) )
        {
            return WBEM_E_INVALID_QUALIFIER;
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        fFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
    }

    // Special case "indexed"
    // ======================

    if(!wbem_wcsicmp(wszName, L"indexed"))
    {
        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
        fFlavor = ENFORCED_INDEXED_FLAVOR;
/*
        if ( fFlavor != ENFORCED_INDEXED_FLAVOR )
        {
            return WBEM_E_INVALID_FLAVOR;
        }
*/

    }

    // Special case "abstract"
    // ======================

    if(!wbem_wcsicmp(wszName, L"abstract"))
    {
        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        if( bCheckPermissions )
        {
            hr = m_pContainer->CanContainAbstract( pNewValue->GetBool() );

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

    }

    // Special case "cimtype"
    // ======================

    if(!wbem_wcsicmp(wszName, L"cimtype"))
    {
        if(bCheckPermissions)
        {
            if(pNewValue->GetType().GetActualType() != CIM_STRING)
                return WBEM_E_INVALID_QUALIFIER;

            // Cleanup the BSTR when we fall out of scope
            BSTR str = GetHeap()->ResolveString(pNewValue->AccessPtrData())->
                            CreateBSTRCopy();
            CSysFreeMe  sfm( str );

            // Check for allocation failures
            if ( NULL == str )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            BOOL bValid = m_pContainer->CanHaveCimtype(str);
            if(!bValid)
                return WBEM_E_INVALID_QUALIFIER;
        }
        // Flavor values are enforced here.
        fFlavor = ENFORCED_CIMTYPE_FLAVOR;
/*
        if ( fFlavor != ENFORCED_CIMTYPE_FLAVOR )
        {
            return WBEM_E_INVALID_FLAVOR;
        }
*/

    }

    // See if we were successful
    // =========================

    if(pOldQual != NULL)
    {
        // Verify if this property is local or overridable
        // ===============================================

        if(bCheckPermissions &&
            !pOldQual->fFlavor.IsLocal() &&
            !pOldQual->fFlavor.IsOverridable())
        {
            return WBEM_E_OVERRIDE_NOT_ALLOWED;
        }

    }
    else
    {
        // This qualifier was not found.
        // =============================

        // If required, check that our class does not prevent us from
        // overriding this qualifier
        // ==========================================================

        if(bCheckPermissions && !IsComplete())
        {
            if(nKnownIndex >= 0)
            {
                pOldQual = m_pSecondarySet->GetKnownQualifierLocally(nKnownIndex);
            }
            else
            {
                pOldQual = m_pSecondarySet->GetRegularQualifierLocally(wszName);
            }

            // Can't set if qualifier exists in secondary, propagates to us,
            // and marked as non-overridable
            // =============================================================

            if(pOldQual &&
                (pOldQual->fFlavor.GetPropagation() & m_nPropagationFlag) &&
                !pOldQual->fFlavor.IsOverridable())
            {
                return WBEM_E_OVERRIDE_NOT_ALLOWED;
            }
        }

        // Check the name for validity
        // ===========================

        if( fValidateName && !IsValidElementName(wszName))
            return WBEM_E_INVALID_PARAMETER;

    }

    return WBEM_NO_ERROR;

}


HRESULT CQualifierSet::
SetQualifierValue(LPCWSTR wszName,
        BYTE fFlavor,
        COPY CTypedValue* pNewValue,
        BOOL bCheckPermissions,
        BOOL fValidateName /* = TRUE */)
{
    // IMPORTANT: Assumes that pNewValue is permanent!!!
    // =================================================

    // Try to find it first
    // ====================

    HRESULT hr = WBEM_S_NO_ERROR;
    int nKnownIndex;
    CQualifier* pOldQual = GetQualifierLocally(wszName, nKnownIndex);

    // Special case "key"
    // ==================

    if(!wbem_wcsicmp(wszName, L"key"))
    {
        if  ( bCheckPermissions )
        {
            hr = m_pContainer->CanContainKey();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Key properties cannnot be dynamic
        if ( NULL != GetQualifier( L"dynamic" ) )
        {
            return WBEM_E_INVALID_QUALIFIER;
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
/*
        if ( fFlavor != ENFORCED_KEY_FLAVOR )
        {
            return WBEM_E_INVALID_FLAVOR;
        }
*/
        fFlavor = ENFORCED_KEY_FLAVOR;
    }

    // Special case "singleton"
    // ========================

    if(!wbem_wcsicmp(wszName, L"singleton"))
    {
        if( bCheckPermissions )
        {
            hr = m_pContainer->CanContainSingleton();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
/*
        if ( fFlavor != ENFORCED_SINGLETON_FLAVOR )
        {
            return WBEM_E_INVALID_FLAVOR;
        }
*/
        fFlavor = ENFORCED_SINGLETON_FLAVOR;
    }

    // Special case "dynamic"
    // ========================

    if(!wbem_wcsicmp(wszName, L"dynamic"))
    {
        // Check that the container will allow this
        if ( bCheckPermissions )
        {
            hr = m_pContainer->CanContainDynamic();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Dynamic properties cannnot be keys
        if ( NULL != GetQualifier( L"key" ) )
        {
            return WBEM_E_INVALID_QUALIFIER;
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        fFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
    }

    // Special case "indexed"
    // ======================

    if(!wbem_wcsicmp(wszName, L"indexed"))
    {
        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
        fFlavor = ENFORCED_INDEXED_FLAVOR;
/*
        if ( fFlavor != ENFORCED_INDEXED_FLAVOR )
        {
            return WBEM_E_INVALID_FLAVOR;
        }
*/

    }

    // Special case "abstract"
    // ======================

    if(!wbem_wcsicmp(wszName, L"abstract"))
    {
        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        if( bCheckPermissions )
        {
            hr = m_pContainer->CanContainAbstract( pNewValue->GetBool() );

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

    }

    // Special case "cimtype"
    // ======================

    if(!wbem_wcsicmp(wszName, L"cimtype"))
    {
        if(bCheckPermissions)
        {
            if(pNewValue->GetType().GetActualType() != CIM_STRING)
                return WBEM_E_INVALID_QUALIFIER;

            // Cleanup the BSTR when we fall out of scope
            BSTR str = GetHeap()->ResolveString(pNewValue->AccessPtrData())->
                            CreateBSTRCopy();
            CSysFreeMe  sfm( str );

            // Check for allocation failures
            if ( NULL == str )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            BOOL bValid = m_pContainer->CanHaveCimtype(str);
            if(!bValid)
                return WBEM_E_INVALID_QUALIFIER;
        }
        // Flavor values are enforced here.
        fFlavor = ENFORCED_CIMTYPE_FLAVOR;
/*
        if ( fFlavor != ENFORCED_CIMTYPE_FLAVOR )
        {
            return WBEM_E_INVALID_FLAVOR;
        }
*/

    }

    // See if we were successful
    // =========================

    if(pOldQual != NULL)
    {
        // Verify if this property is local or overridable
        // ===============================================

        if(bCheckPermissions &&
            !pOldQual->fFlavor.IsLocal() &&
            !pOldQual->fFlavor.IsOverridable())
        {
            return WBEM_E_OVERRIDE_NOT_ALLOWED;
        }

        // See if there is enoung room for the new one
        // ===========================================

        int nNewLen = pNewValue->GetLength();
        int nOldLen = pOldQual->Value.GetLength();

        if(nNewLen > nOldLen)
        {
            int nShift = nNewLen - nOldLen;

            // Request more room from the container.
            // (will copy us there if required)
            // ================================

            int nOldQualOffset = LPMEMORY(pOldQual) - GetStart();
            if (!m_pContainer->ExtendQualifierSetSpace(this,GetLength() + nShift))
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

	        // Delete old value here, since from now on it will work
	        pOldQual->Value.Delete(GetHeap());
            
            pOldQual = (CQualifier*)(GetStart() + nOldQualOffset);

            // Insert necessary space at the end of the old value
            // ==================================================

            InsertSpace(GetStart(), GetLength(), pOldQual->Next(), nShift);
            IncrementLength(nShift);

        }
        else if(nNewLen < nOldLen)
        {
       		// Delete old value here, since from now on it will work
	        pOldQual->Value.Delete(GetHeap());
	        
            // Move the tail back by the difference
            // ====================================

            LPMEMORY pTail = LPMEMORY(pOldQual->Next());
            int nShift = nOldLen - nNewLen;

            memcpy((void*)(pTail-nShift), (void*)pTail,
                m_nLength-(pTail-GetStart())
            );

            // Give space back to the container
            // ================================

            m_pContainer->ReduceQualifierSetSpace(this, nShift);

            IncrementLength(-nShift);
        }
        else // nNewLen == nOldLen
        {
       		// Delete old value here, since from now on it will work
	        pOldQual->Value.Delete(GetHeap());        
        };
        // Now that we either had or made enough space, copy the value
        // ===========================================================

        pOldQual->fFlavor = fFlavor;

        // No Heap allocations here.
        pNewValue->CopyTo(&pOldQual->Value);
    }
    else
    {
        // This qualifier was not found.
        // =============================

        // If required, check that our class does not prevent us from
        // overriding this qualifier
        // ==========================================================

        if(bCheckPermissions && !IsComplete())
        {
            if(nKnownIndex >= 0)
            {
                pOldQual = m_pSecondarySet->GetKnownQualifierLocally(nKnownIndex);
            }
            else
            {
                pOldQual = m_pSecondarySet->GetRegularQualifierLocally(wszName);
            }

            // Can't set if qualifier exists in secondary, propagates to us,
            // and marked as non-overridable
            // =============================================================

            if(pOldQual &&
                (pOldQual->fFlavor.GetPropagation() & m_nPropagationFlag) &&
                !pOldQual->fFlavor.IsOverridable())
            {
                return WBEM_E_OVERRIDE_NOT_ALLOWED;
            }
        }

        // Check the name for validity
        // ===========================

        if( fValidateName && !IsValidElementName(wszName))
            return WBEM_E_INVALID_PARAMETER;

        // Can add (at the end of the list)
        // ================================

        // Allocate the name on the heap, if not well-known
        // ================================================

        heapptr_t ptrName;
        if(nKnownIndex < 0)
        {

            // Check for memory allocation errors.
            if ( !GetHeap()->AllocateString(wszName, ptrName) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            // GetHeap()->ResolveString(ptrName)->MakeLowercase();

            // NOTE: above could have moved us!!!!
            // ===================================

            if(!SelfRebase())
                return WBEM_E_INVALID_PROPERTY;
        }
        else
        {
            ptrName = CFastHeap::MakeFakeFromIndex(nKnownIndex);
        }


        // Request more room from the container
        // ====================================

        int nShift = CQualifier::GetHeaderLength() + pNewValue->GetLength();

        if (!m_pContainer->ExtendQualifierSetSpace(this, GetLength() + nShift))
        	return WBEM_E_OUT_OF_MEMORY;

        // Place the new qualifier at the end of the list
        // ==============================================

        CQualifier* pNewQual = (CQualifier*)Skip();
        pNewQual->ptrName = ptrName;
        pNewQual->fFlavor = fFlavor;

        // No Heap allocations here.
        pNewValue->CopyTo(&pNewQual->Value);

        // Change list length accordingly
        // ==============================

        IncrementLength(nShift);
    }

    return WBEM_NO_ERROR;
}


//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::
DeleteQualifier(READ_ONLY LPCWSTR wszName, BOOL bCheckPermissions)
{
    // Try to find it first
    // ====================

    int nKnownIndex;
    CQualifier* pOldQual = GetQualifierLocally(wszName, nKnownIndex);

    // See if we were successful
    // =========================

    if(pOldQual != NULL)
    {
        // Make sure that it is not a cached parent's value
        // ================================================

        if(bCheckPermissions && !pOldQual->fFlavor.IsLocal())
        {
            return WBEM_E_PROPAGATED_QUALIFIER;
        }

        // Free its name, if not well-known
        // ================================

        if(nKnownIndex < 0)
        {
            GetHeap()->FreeString(pOldQual->ptrName);
        }

        // Delete the value (if it is a string, for instance)
        // ==================================================

        pOldQual->Delete(GetHeap());

        // Move the tail back by the qualifier size
        // ========================================

        LPMEMORY pTail = LPMEMORY(pOldQual->Next());
        int nShift = pOldQual->GetLength();

        memcpy((void*)(pTail-nShift), (void*)pTail,
            m_nLength-(pTail-GetStart())
        );

        // Give space back to the container
        // ================================

        m_pContainer->ReduceQualifierSetSpace(this, nShift);

        IncrementLength(-nShift);

        return WBEM_NO_ERROR;
    }
    else
    {
        // Wasn't there to begin with
        // ==========================

        return WBEM_E_NOT_FOUND;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

STDMETHODIMP CQualifierSet::
Get(LPCWSTR Name, LONG lFlags, VARIANT *pVal, long* plFlavor)
{
    try
    {
        CWbemObject::CLock  lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        if(Name == NULL || wcslen(Name) == 0) return WBEM_E_INVALID_PARAMETER;
        if(lFlags != 0) return WBEM_E_INVALID_PARAMETER;

        if(!SelfRebase()) return WBEM_E_INVALID_PROPERTY;

        BOOL bIsLocal;
        CQualifier* pQualifier = GetQualifier(Name, bIsLocal);
        if(pQualifier == NULL) return WBEM_E_NOT_FOUND;

        // Set the flavor
        // ==============

        if(plFlavor)
        {
            *plFlavor = pQualifier->fFlavor;
            if(!bIsLocal)
            {
                CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, FALSE);
            }
        }

        // Set the value
        // =============

        CVar Var;

        // Check for allocation failures
        if ( !pQualifier->Value.StoreToCVar(Var,
                (bIsLocal)?GetHeap():m_pSecondarySet->GetHeap()) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(pVal)
        {
            VariantInit(pVal);
            Var.FillVariant(pVal, TRUE);
        }
        return WBEM_NO_ERROR;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

HRESULT STDMETHODCALLTYPE CQualifierSet::
Put(LPCWSTR Name, VARIANT *pVal, long lFlavor)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        if(Name == NULL || pVal == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Verify flavor validity
        // ======================

        if(lFlavor & ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE &
            ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS &
            ~WBEM_FLAVOR_NOT_OVERRIDABLE &
            ~WBEM_FLAVOR_AMENDED)
        {
            // Note: no origin flavor other than local is allowed
            // ==================================================

            return WBEM_E_INVALID_PARAMETER;
        }

        // Verifty that the type is one of allowed ones
        // ============================================

        if(!IsValidQualifierType(V_VT(pVal)))
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Verify that the name is not a system one
        // ========================================

        if(Name[0] == L'_')
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Other operations could have moved us. Rebase from container
        // ===========================================================

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Make sure flavor is valid
        // =========================

        if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Construct typed value from the VARIANT
        // ======================================

        CVar Var;
        Var.SetVariant(pVal, TRUE);

        if(Var.IsDataNull())
            return WBEM_E_INVALID_PARAMETER;

        CTypedValue TypedValue;
        CStaticPtr ValuePtr((LPMEMORY)&TypedValue);

        // Check returns from the following calls
        HRESULT hres = CTypedValue::LoadFromCVar(&ValuePtr, Var, GetHeap());

        if ( SUCCEEDED( hres ) )
        {
            if( SelfRebase() )
            {
                // Set it in the primary qualifier set (checking permissions)
                // ==========================================================

                hres = SetQualifierValue(Name, (BYTE)lFlavor, &TypedValue, TRUE);
                EndEnumeration();
            }
            else
            {
                hres = WBEM_E_INVALID_PROPERTY;
            }

        }

        return hres;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::Delete(LPCWSTR Name)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        if(Name == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Deletion of CIMTYPE qualifier is not allowed.
        // =============================================

        if(!wbem_wcsicmp(Name, TYPEQUAL))
            return WBEM_E_INVALID_PARAMETER;

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Delete it from the primary qualifier set (checking permissions)
        // ===============================================================

        HRESULT hres = DeleteQualifier(Name, TRUE);
        EndEnumeration();

        if(hres == WBEM_E_PROPAGATED_QUALIFIER)
        {
            // This means that this qualifier is inherited. Deleting it is a noop
            // ==================================================================

            return WBEM_E_PROPAGATED_QUALIFIER;
        }

        if(!IsComplete())
        {
            // The qualifier may be hiding in the secondary set.
            // =================================================

            CQualifier* pQualifier = m_pSecondarySet->GetQualifierLocally(Name);
            if(pQualifier &&
                (pQualifier->fFlavor.GetPropagation() & m_nPropagationFlag))
            {
                if(hres == WBEM_E_NOT_FOUND)
                    return WBEM_E_PROPAGATED_QUALIFIER;
                else
                    return WBEM_S_RESET_TO_DEFAULT;
            }
        }

        if(hres == WBEM_S_NO_ERROR && IsComplete() && m_pSecondarySet != NULL)
        {
            // If this qualifier exists in our parent and propagates to us, we
            // need to insert the parent's version into our set now
            // ===============================================================

            CQualifier* pParentQualifier =
                m_pSecondarySet->GetQualifierLocally(Name);
            if(pParentQualifier &&
                (pParentQualifier->fFlavor.GetPropagation() & m_nPropagationFlag))
            {
                CQualifierFlavor fParentFlavor = pParentQualifier->fFlavor;
                fParentFlavor.SetLocal(FALSE);

                CTypedValue Value;

                // No Heap allocations here.
                pParentQualifier->Value.CopyTo(&Value);

                CStaticPtr ValuePtr((LPMEMORY)&Value);

                // Check for allocation failures
                if ( !CTypedValue::TranslateToNewHeap(&ValuePtr,
                                                m_pSecondarySet->GetHeap(),
                                                GetHeap()) )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

				// NOTE: TranslateToNewHeap may have invalidated our pointers, so we need to rebase.
				SelfRebase();

                SetQualifierValue(Name, fParentFlavor, &Value, FALSE);
                return WBEM_S_RESET_TO_DEFAULT;
            }
        }

        return hres;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::
GetNames(long lFlags, LPSAFEARRAY *pNames)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        if(pNames == NULL)
            return WBEM_E_INVALID_PARAMETER;
        *pNames = NULL;

        if(lFlags != 0 && lFlags != WBEM_FLAG_LOCAL_ONLY &&
                lFlags != WBEM_FLAG_PROPAGATED_ONLY )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Get a regular array of them
        // ===========================

        CFixedBSTRArray astrNames;
        EnumQualifiers((BYTE)lFlags, 0, // no propagation restrictions
            astrNames);

        CSafeArray saNames(VT_BSTR, CSafeArray::no_delete,
            astrNames.GetLength());
        for(int i = 0; i < astrNames.GetLength(); i++)
        {
            saNames.AddBSTR(astrNames[i]);
        }

        astrNames.Free();
        *pNames = saNames.GetArray();

        return WBEM_S_NO_ERROR;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::
EnumQualifiers(BYTE eFlags, BYTE fFlavorMask, CFixedBSTRArray& astrNames)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        // Divide local qualifiers into those matching and not macching the
        // criteria
        // ================================================================

        CFixedBSTRArray astrPrimaryMatching, astrPrimaryNotMatching;

        HRESULT hr = EnumPrimaryQualifiers(eFlags, fFlavorMask,
                    astrPrimaryMatching, astrPrimaryNotMatching);

        if ( FAILED(hr) )
        {
            return hr;
        }

        // Get our parent's qualifiers, if required
        // ========================================

        CFixedBSTRArray astrParentMatching, astrParentNotMatching;

        if(!IsComplete() && eFlags != WBEM_FLAG_LOCAL_ONLY)
        {

            hr = m_pSecondarySet->EnumPrimaryQualifiers(
                    0,                      // need both local and propagated ---
                                            // our own flags do not apply, since all
                                            // parent's qualifiers are "propagated"
                                            // from our perspective

                    fFlavorMask |
                    m_nPropagationFlag,    // we need our parent's qualifiers which
                                            // satisfy both: a) it propagates to us and
                                            // b) it propagates as required by our mask
                    astrParentMatching,
                    astrParentNotMatching
                );

            // Check for allocation failures
            if ( FAILED(hr) )
            {
                astrPrimaryMatching.Free();
                astrPrimaryNotMatching.Free();
                return hr;
            }
        }

        astrParentNotMatching.Free();

        // Now, we need to produce the following merge: all the elements in the
        // astrLocalMatching, plus all the elements in astrParentMatching which are
        // not in astrLocalNotMatching. The reason for this is that even if our
        // parent thinks that a qualifier propagates as requested, we may have
        // overriden it and changed the propagation rules.
        // ======================================================================

        astrNames.ThreeWayMergeOrdered(astrPrimaryMatching, astrParentMatching,
                            astrPrimaryNotMatching);

        astrPrimaryMatching.Free();
        astrPrimaryNotMatching.Free();
        astrParentMatching.Free();

        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }


}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CQualifierSet::Compare( CQualifierSet& qualifierset, CFixedBSTRArray* pExcludeNames /* = NULL */,
                                BOOL fCheckOrder /* = TRUE */ )
{
    BOOL            fReturn = TRUE;

    CFixedBSTRArray astrNamesThis,
                    astrNamesThat;

    // We will throw exceptions in OOM scenarios

    HRESULT hr = EnumQualifiers( 0, 0, astrNamesThis );
    
    // Get the names of the qualifiers in each set.
    if ( FAILED( hr ) )
    {
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    hr = qualifierset.EnumQualifiers( 0, 0, astrNamesThat );

    if ( FAILED( hr ) )
    {
        astrNamesThis.Free();

        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    // Each must have the same number of names
    if ( astrNamesThis.GetLength() == astrNamesThat.GetLength() )
    {
        
        // Enum the qualifiers, checking that names and values
        // match

        for (   int i = 0;
                fReturn && i < astrNamesThis.GetLength();
                i++ )
        {
            BOOL    fContinue = TRUE;
            BOOL    fFatal = FALSE;

            // If we got an exclude names array, check to see if the matching qualifier
            // is one we will ignore for this comparison.

            if ( NULL != pExcludeNames )
            {
                //
                for ( int nCtr = 0; fContinue && nCtr < pExcludeNames->GetLength();
                        nCtr++ )
                {
                    // In this case, we only continue if our name does not match any
                    // of the values in the array.  This is not a fatal error.
                    fContinue = ( wbem_wcsicmp( astrNamesThis[i],
                                    pExcludeNames->GetAt(nCtr) ) != 0 );
                }
            }
            else
            {
                if ( fCheckOrder )
                {
                    // In this case we continue only when the two names match
                    // This is a fatal error if it happens.
                    fContinue = ( wbem_wcsicmp( astrNamesThis[i], astrNamesThat[i] ) == 0 );
                    fFatal = !fContinue;
                }
            }

            // Only continue if we are supposed to.
            if ( fContinue )
            {
                BOOL    bIsLocalThis,
                        bIsLocalThat;

                CQualifier* pQualifierThis = GetQualifier( astrNamesThis[i], bIsLocalThis );

                // If order is not important, we just need to verify that the qualifier in
                // this set is also in that set
                CQualifier* pQualifierThat = qualifierset.GetQualifier(
                                ( fCheckOrder ? astrNamesThat[i] : astrNamesThis[i] ),
                                bIsLocalThat );

                // Must have qualifier pointers, flavors and IsLocal must match
                if (    NULL != pQualifierThis
                    &&  NULL != pQualifierThat
                    &&  bIsLocalThis == bIsLocalThat
                    &&  pQualifierThis->fFlavor == pQualifierThat->fFlavor )
                {
                    CVar    varThis,
                            varThat;

                    // Get CVar's from each qualifer

                    // We will throw exceptions in OOM scenarios

                    // Check for allocation failures
                    if ( !pQualifierThis->Value.StoreToCVar( varThis,
                            (bIsLocalThis)?GetHeap():m_pSecondarySet->GetHeap()) )
                    {
                        throw CX_MemoryException();
                    }

                    // Check for allocation failures
                    if ( !pQualifierThat->Value.StoreToCVar( varThat,
                            (bIsLocalThat)?qualifierset.GetHeap():
                            qualifierset.m_pSecondarySet->GetHeap()) )
                    {
                        throw CX_MemoryException();
                    }

                    // Types must match
                    if ( pQualifierThis->Value.GetType() == pQualifierThat->Value.GetType() )
                    {
                        // Compare the CVars
                        fReturn = ( varThis == varThat );
                    }
                    else
                    {
                        fReturn = FALSE;
                    }
                }   // IF got qualifiers, flavors and IsLocal match
                else
                {
                    fReturn = FALSE;
                }

            }   // IF names equal
            else if ( fFatal )
            {
                // fContinue of FALSE is ok if fFatal is not TRUE
                fReturn = FALSE;
            }

        }   // FOR iterate qualifier names

    }   // bstr Array lengths different
    else
    {
        fReturn = FALSE;
    }

    astrNamesThis.Free();
    astrNamesThat.Free();

    return fReturn;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::Update( CBasicQualifierSet& childSet, long lFlags,
                              CFixedBSTRArray* paExcludeNames )
{
    try
    {
        HRESULT         hr = WBEM_S_NO_ERROR;
        CFixedBSTRArray aMatching, aNotMatching;
        CVarVector      vectorConflicts( VT_BSTR );
        BOOL            fAddConflicts = FALSE;

        // Checks for allocation failures
        hr = childSet.EnumPrimaryQualifiers( WBEM_FLAG_LOCAL_ONLY, 0, aMatching, aNotMatching);

        for ( int x = 0; SUCCEEDED( hr ) && x < aMatching.GetLength(); x++ )
        {
            BOOL    fIgnore = FALSE;
            CQualifier* pQualifier = childSet.GetQualifierLocally( aMatching[x] );

            // If we got an Exclude Names qualifier, see if
            // we should ignore this qualifier
            if ( NULL != paExcludeNames )
            {
                for ( int i = 0; !fIgnore && i < paExcludeNames->GetLength(); i++ )
                {
                    // See if we should ignore this qualifier
                    fIgnore = ( wbem_wcsicmp( aMatching[x], paExcludeNames->GetAt(i) ) == 0 );
                }
            }

            // Only continue if we have a qualifier and are not supposed
            // to ignore it.
            if ( !fIgnore && NULL != pQualifier )
            {

                CVar    vTemp;
                CTypedValue Value;
                CStaticPtr ValuePtr((LPMEMORY)&Value);


                // Check for an out of memory condition
                if ( !pQualifier->Value.StoreToCVar( vTemp, childSet.GetHeap() ) )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if ( SUCCEEDED( hr ) )
                {
                    // This will return errors as appropriate
                    hr = CTypedValue::LoadFromCVar(&ValuePtr, vTemp, GetHeap());
                }
                
                if( SUCCEEDED( hr ) )
                {
                    // The last call may have moved us --- rebase
                    // ==========================================

                    SelfRebase();

                    // We won't do any name validation if we are working with an Update Conflict
                    // qualifier.

                    BOOL    fValidateName = ( wbem_wcsicmp( aMatching[x], UPDATE_QUALIFIER_CONFLICT ) != 0 );

                    hr = SetQualifierValue( aMatching[x], pQualifier->fFlavor, &Value, TRUE, fValidateName );

                    // If we failed to set the value and we're in Force mode, then
                    // ignore the error

                    if (    FAILED( hr )
                        &&  WBEM_FLAG_UPDATE_FORCE_MODE == ( lFlags & WBEM_MASK_UPDATE_MODE ) )
                    {

                        // We will store all conflicts in an array, then add them
                        // all en masse at the end
                        hr = StoreQualifierConflicts( aMatching[x], vTemp, pQualifier->fFlavor,
                                vectorConflicts );
                        fAddConflicts = TRUE;

                    }   // IF Force Mode

                }   // IF LoadFromCVar

            }   // IF Qualifier and not ignored

        }   // FOR enum qualifiers

        // If we've succeded and encountered any conflicts, we need to account for
        // these now.

        if ( SUCCEEDED( hr ) && fAddConflicts )
        {
            hr = AddQualifierConflicts( vectorConflicts );
        }

        // Clear out the arrays
        aMatching.Free();
        aNotMatching.Free();

        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::CopyLocalQualifiers( CQualifierSet& qsSource )
{
    CFixedBSTRArray astrNamesThisProp,
                    astrNamesThisPropFailed;


    try
    {
        HRESULT hr = qsSource.EnumPrimaryQualifiers( WBEM_FLAG_LOCAL_ONLY, 0, astrNamesThisProp, astrNamesThisPropFailed );

        if ( SUCCEEDED ( hr ) )
        {
            for ( int i = 0; SUCCEEDED( hr ) && i < astrNamesThisProp.GetLength(); i++ )
            {
                // We know the qualifier is local
                CQualifier* pQualifier = qsSource.GetQualifierLocally( astrNamesThisProp[i] );

                if ( NULL != pQualifier )
                {
                    CVar    varQual;

                    if ( pQualifier->Value.StoreToCVar( varQual, qsSource.GetHeap() ) )
                    {
                        VARIANT v;

                        // DEVNOTE:TODO:SANJ - See if there's an easier way to do this
                        // Initialize the variant
                        VariantInit( &v );
                        varQual.FillVariant( &v, TRUE );

                        if ( SUCCEEDED( hr ) )
                        {
                            // Okay, put in the new value
                            hr = Put( astrNamesThisProp[i], &v, pQualifier->fFlavor );
                        }

                        // We Initialized above so call clear
                        VariantClear( &v );
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WBEM_E_UNEXPECTED;
                }

            }   // FOR emumlocals

        }   // IF EnumedPrimaryQualifiers

        // Clear arrays.
        astrNamesThisProp.Free();
        astrNamesThisPropFailed.Free();

        return hr;

    }
    catch( CX_MemoryException )
    {
        astrNamesThisProp.Free();
        astrNamesThisPropFailed.Free();

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::AddQualifierConflicts( CVarVector& vectorConflicts )
{
    try
    {
        HRESULT     hr = WBEM_S_NO_ERROR;
        CVarVector  varArray( VT_BSTR );

        // If the qualifier already exists, we need to append our
        // new values to the existing array.
        CQualifier* pOldQualifier = GetQualifierLocally( UPDATE_QUALIFIER_CONFLICT );

        if ( NULL != pOldQualifier )
        {
            CVar    varOldQualValue;

            // If we got a value for the old qualifier, make sure it is
            // an array, if not, well, it should never have gotten here
            // so we're gonna bail.

            if ( pOldQualifier->Value.StoreToCVar( varOldQualValue, GetHeap() ) )
            {
                if ( varOldQualValue.GetType() == VT_EX_CVARVECTOR )
                {
                    // Copy the array
                    varArray = *(varOldQualValue.GetVarVector());
                }
                else
                {
                    hr = WBEM_E_INVALID_QUALIFIER;
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF NULL != pOldQualifier

        // Final check that things are in order
        if ( SUCCEEDED( hr ) )
        {

            // Enum the conflicts array and add these to any preexisting
            // values, then set the final value.

            for ( int x = 0; SUCCEEDED( hr ) && x < vectorConflicts.Size(); x++ )
            {
                if ( CVarVector::no_error != varArray.Add( vectorConflicts.GetAt(x) ) )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }   // FOR enum elements in the array

            // Now we need to set the value.
            CVar    varQualConflictVal;

            // This is a stack variable, so the destination CVar should copy it.
            varQualConflictVal.SetVarVector( &varArray, FALSE );

            CTypedValue qualConflictValue;
            CStaticPtr qualConflictValuePtr((LPMEMORY)&qualConflictValue);

            // This function will return errors directly
            hr = CTypedValue::LoadFromCVar(&qualConflictValuePtr, varQualConflictVal, GetHeap());
            
            if( SUCCEEDED( hr ) )
            {
                // On this call, don't worry about override protection and don't validate
                // the name, since this qualifier is an internally provided system qualifier
                hr = SetQualifierValue( UPDATE_QUALIFIER_CONFLICT, 0, &qualConflictValue,
                        FALSE, FALSE );
            }
        }   // If new qualifier conflict Value ok

        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::StoreQualifierConflicts( LPCWSTR pwcsName, CVar& value,
                            CQualifierFlavor& flavor, CVarVector& vectorConflicts )
{
    // Check for out of memory
    try
    {
        // Pretend everything's ok
        HRESULT hr = WBEM_S_NO_ERROR;

        CVar    varOldValAsText;

        // Start with name and parentheses
        WString wsOldText( pwcsName );
        wsOldText += L"(";

        // Get the variant in Text form.  Free the BSTR when we drop out of scope
        BSTR    bstrOldText = value.GetText(0);
        if(bstrOldText == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe  sfm( bstrOldText );

        wsOldText += bstrOldText;

        // Add any flavor values
        wsOldText += flavor.GetText();

        // Finish with an RPAREN
        wsOldText += L")";

        // The call to SetBSTR() with the bAcquire value of TRUE will free the
        // BSTR returned by SysAllocString.
        varOldValAsText.SetBSTR( COleAuto::_SysAllocString( wsOldText ), TRUE );

        // Only reason I can see this failing is we're out of memory
        if ( CVarVector::no_error != vectorConflicts.Add( varOldValAsText ) )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::
BeginEnumeration(LONG lFlags)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        if(lFlags != 0 && lFlags != WBEM_FLAG_LOCAL_ONLY &&
            lFlags != WBEM_FLAG_PROPAGATED_ONLY )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Get all the matching qualifier names into that array
        // ====================================================

        // Check for possible allocation failures
        HRESULT hr = EnumQualifiers((BYTE)lFlags, 0, m_astrCurrentNames);

        // Reset index data
        // ================

        if ( SUCCEEDED(hr) )
        {
            m_nCurrentIndex = 0;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::
Next(LONG lFlags, BSTR *pstrName, VARIANT *pVal, long* plFlavor)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(m_nCurrentIndex == -1)
            return WBEM_E_UNEXPECTED;

        if(m_nCurrentIndex == m_astrCurrentNames.GetLength())
            return WBEM_S_NO_MORE_DATA;

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Get the next name
        // =================

        if(pstrName)
            *pstrName = COleAuto::_SysAllocString(m_astrCurrentNames[m_nCurrentIndex]);

        // Get the qualifier data
        // ======================

        return Get(m_astrCurrentNames[m_nCurrentIndex++], 0, pVal, plFlavor);
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::
EndEnumeration()
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        m_nCurrentIndex = -1;
        m_astrCurrentNames.Free();

        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
STDMETHODIMP CQualifierSet::
CompareTo(long lFlags, IWbemQualifierSet* pOther)
{
    try
    {
        HRESULT hres;

        // Get name arrays --- the only reason is to count them, really
        // ============================================================

        SAFEARRAY *psaThisQuals, *psaOtherQuals;
        GetNames(0, &psaThisQuals);
        pOther->GetNames(0, &psaOtherQuals);

        long lThisNum, lOtherNum;
        SafeArrayGetUBound(psaThisQuals, 1, &lThisNum);
        SafeArrayGetUBound(psaOtherQuals, 1, &lOtherNum);
        SafeArrayDestroy(psaOtherQuals);
        if(lThisNum != lOtherNum)
        {
            SafeArrayDestroy(psaThisQuals);
            return WBEM_S_DIFFERENT;
        }

        // The count is the same. Go through them one by one and compare
        // =============================================================

        for(long i = 0; i <= lThisNum; i++)
        {
            BSTR strName = NULL;

            SafeArrayGetElement(psaThisQuals, &i, &strName);
            // Free this BSTR whenever we drop out of scope
            CSysFreeMe  sfm( strName );

            VARIANT vThis, vOther;
            long lThisFlavor, lOtherFlavor;
            hres = Get(strName, 0, &vThis, &lThisFlavor);
            if(FAILED(hres))
            {
                SafeArrayDestroy(psaThisQuals);
                return hres;
            }

            CVar varThis;
            varThis.SetVariant(&vThis);
            VariantClear(&vThis);

            hres = pOther->Get(strName, 0, &vOther, &lOtherFlavor);
            if(FAILED(hres))
            {
                SafeArrayDestroy(psaThisQuals);
                if(hres == WBEM_E_NOT_FOUND) return WBEM_S_DIFFERENT;
                else return hres;
            }

            CVar varOther;
            varOther.SetVariant(&vOther);
            VariantClear(&vOther);

            if((lFlags & WBEM_FLAG_IGNORE_FLAVOR) == 0)
            {
                if(lThisFlavor != lOtherFlavor)
                {
                    SafeArrayDestroy(psaThisQuals);
                    return WBEM_S_DIFFERENT;
                }
            }

            if(!varThis.CompareTo(varOther, lFlags & WBEM_FLAG_IGNORE_CASE))
            {
                SafeArrayDestroy(psaThisQuals);
                return WBEM_S_DIFFERENT;
            }
        }

        SafeArrayDestroy(psaThisQuals);
        return WBEM_S_SAME;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

CClassPQSContainer::~CClassPQSContainer()
{
    delete m_pSecondarySet;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
CFastHeap* CClassPQSContainer::GetHeap()
{
    return &m_pClassPart->m_Heap;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
IUnknown* CClassPQSContainer::GetWbemObjectUnknown()
{
    return m_pClassPart->GetWbemObjectUnknown();
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CClassPQSContainer::CanContainKey()
{
    if(!m_pClassPart->CanContainKeyedProps()) return WBEM_E_CANNOT_BE_KEY;

    CPropertyInformation* pInfo = GetPropertyInfo();
    if(pInfo == NULL) return WBEM_E_CANNOT_BE_KEY;

    if ( !CType::CanBeKey(pInfo->nType) )
    {
        return WBEM_E_CANNOT_BE_KEY;
    }

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CClassPQSContainer::CanContainSingleton()
{
    return WBEM_E_INVALID_QUALIFIER;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CClassPQSContainer::CanContainAbstract( BOOL fValue )
{
    return WBEM_E_INVALID_QUALIFIER;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CClassPQSContainer::CanContainDynamic( void )
{
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
BOOL CClassPQSContainer::CanHaveCimtype(LPCWSTR wszCimtype)
{
    CPropertyInformation* pInfo = GetPropertyInfo();
    if(pInfo == NULL) return FALSE;

    CType Type = CType::GetBasic(pInfo->nType);
    if(Type == CIM_OBJECT)
    {
        if(!wbem_wcsicmp(wszCimtype, L"object") ||
            !wbem_wcsnicmp(wszCimtype, L"object:", 7))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    if(Type == CIM_REFERENCE)
    {
        if(!wbem_wcsicmp(wszCimtype, L"ref"))
            return TRUE;
        else if (!wbem_wcsnicmp(wszCimtype, L"ref:", 4))
        {
            //We need to check that the class following this is valid..
            if ((wcslen(wszCimtype)> 4) && IsValidElementName2(wszCimtype+4, TRUE))
                return TRUE;
            else
                return FALSE;
        }
        else
        {
            return FALSE;
        }
    }

    return (wbem_wcsicmp(wszCimtype, CType::GetSyntax(Type)) == 0);
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CClassPQSContainer::SetSecondarySetData()
{
    CClassPart* pParentPart = m_pClassPart->m_pParent;
    if(m_nParentSetOffset == 0)
    {
        // Find the name of our property
        // =============================

        CPropertyLookup* pLookup =
            m_pClassPart->m_Properties.FindPropertyByPtr(m_ptrPropName);
        if(pLookup == NULL) return;

        CCompressedString* pcsName = m_pClassPart->m_Heap.ResolveString(
                                        pLookup->ptrName);

        // Find it in the parent
        // =====================

        pLookup = pParentPart->m_Properties.FindPropertyByName(pcsName);

        if(pLookup == NULL) return;

        CPropertyInformation* pInfo = (CPropertyInformation*)
            pParentPart->m_Heap.ResolveHeapPointer(pLookup->ptrInformation);

        m_nParentSetOffset =
            pInfo->GetQualifierSetData() - pParentPart->GetStart();
    }

    if(m_pSecondarySet == NULL)
    {
        m_pSecondarySet = new CBasicQualifierSet;

        if ( NULL == m_pSecondarySet )
        {
            throw CX_MemoryException();
        }
    }

    m_pSecondarySet->SetData(
        pParentPart->GetStart() + m_nParentSetOffset,
        pParentPart->GetHeap());
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
LPMEMORY CClassPQSContainer::GetQualifierSetStart()
{
    SetSecondarySetData();
    CPropertyInformation* pInfo = GetPropertyInfo();
    if(pInfo == NULL) return NULL;
    return pInfo->GetQualifierSetData();
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
CPropertyInformation* CClassPQSContainer::GetPropertyInfo()
{
    // Find the property all over again
    // ================================

    CPropertyLookup* pLookup =
        m_pClassPart->m_Properties.FindPropertyByPtr(m_ptrPropName);
    if(pLookup == NULL) return NULL;

    return (CPropertyInformation*)
        m_pClassPart->m_Heap.ResolveHeapPointer(pLookup->ptrInformation);
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
BOOL CClassPQSContainer::ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nNewLength)
{
    // Find the property all over again
    // ================================

    CPropertyLookup* pLookup =
        m_pClassPart->m_Properties.FindPropertyByPtr(m_ptrPropName);

    // DEVNOTE:TODO:SANJ - Is this right?  We didn't find the value so we really
    // can't extend anything.
    if(pLookup == NULL) return TRUE;

    // Extend CPropertyInformation's space on the heap
    // ===============================================

    // Check for Allocation failure
    heapptr_t ptrNewInfo;
    if ( !m_pClassPart->m_Heap.Reallocate(
        pLookup->ptrInformation,
        CPropertyInformation::GetHeaderLength() + pSet->GetLength(),
        CPropertyInformation::GetHeaderLength() + nNewLength,
        ptrNewInfo) )
    {
        return FALSE;
    }

    // Find the property again --- reallocation may have moved us
    // ==========================================================

    pLookup = m_pClassPart->m_Properties.FindPropertyByPtr(m_ptrPropName);

    // RAJESHR - Fix for prefix bug 144428
    if(pLookup == NULL) return TRUE;

    if(ptrNewInfo != pLookup->ptrInformation)
    {
        // Reset the pointer in the lookup table
        // =====================================

        pLookup->ptrInformation = ptrNewInfo;

        // Compute the new qualifier set data pointer
        // ==========================================

        LPMEMORY pNewMemory =
            m_pClassPart->m_Heap.ResolveHeapPointer(ptrNewInfo) +
            CPropertyInformation::GetHeaderLength();

        pSet->Rebase(pNewMemory);
    }

    // DEVNOTE:TODO:SANJ - Fixup memory checks so return is GOOD
    return TRUE;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CClassPQSContainer::ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement)
{
}

//*****************************************************************************
//*****************************************************************************

length_t mstatic_EmptySet = sizeof(length_t);

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CInstancePQSContainer::SetSecondarySetData()
{
    m_SecondarySet.SetData(
        m_pClassPart->GetStart() + m_nClassSetOffset,
        m_pClassPart->GetHeap());
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CInstancePQSContainer::RebaseSecondarySet()
{
    m_SecondarySet.Rebase(m_pClassPart->GetStart() + m_nClassSetOffset);
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CQualifierSetList::InsertQualifierSet(int nIndex)
{
    if (!EnsureReal())
    	return WBEM_E_OUT_OF_MEMORY;

    // Request extra space from container
    // ==================================

    int nExtraSpace = CBasicQualifierSet::GetMinLength();
    if ( !m_pContainer->ExtendQualifierSetListSpace(
			GetStart(), GetLength(), GetLength() + nExtraSpace) )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

    // Find the insertion point
    // ========================

	HRESULT	hr = WBEM_S_NO_ERROR;
    LPMEMORY pQualSet = GetQualifierSetData(nIndex);

    // Shift everything by the length of an empty qualifier set
    // ========================================================

	if ( NULL != pQualSet )
	{
		memmove(pQualSet + nExtraSpace, pQualSet,
			m_nTotalLength - (pQualSet-GetStart()));

		// Create empty qualifier set in the space
		// =======================================

		CBasicQualifierSet::SetDataToNone(pQualSet);

		// Adjust cached length
		// ====================

		m_nTotalLength += nExtraSpace;
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CQualifierSetList::DeleteQualifierSet(int nIndex)
{
    if(*m_pStart == QSL_FLAG_NO_SETS)
    {
        // No qualifier sets
        // =================
        return;
    }

    // Find the set
    // ============

    LPMEMORY pQualSet = GetQualifierSetData(nIndex);

    // Get its length
    // ==============

    int nLength = CBasicQualifierSet::GetLengthFromData(pQualSet);

    // Delete all its data from the heap
    // =================================

    CBasicQualifierSet::Delete(pQualSet, GetHeap());

    // Shift everything to our right to the left
    // =========================================

    memcpy(pQualSet + nLength, pQualSet,
        m_nTotalLength - nLength - (pQualSet - GetStart()));

    // Return the space to the container
    // =================================

    m_pContainer->ReduceQualifierSetListSpace(GetStart(), GetLength(),
        nLength);

    // Adjust our cached length
    // ========================

    m_nTotalLength -= nLength;
}


//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
BOOL CQualifierSetList::ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
                                                length_t nNewLength)
{
    // WARNING: Trusing the caller here to specify a valid address!!!

    int nSetStartOffset = pSet->GetStart() - GetStart();

    // Request extra space from container
    // ==================================

    int nExtraSpace = nNewLength - pSet->GetLength();
    if (!m_pContainer->ExtendQualifierSetListSpace(
        GetStart(), GetLength(), GetLength() + nExtraSpace))
    {
        return FALSE;
    }

    LPMEMORY pSetStart = GetStart() + nSetStartOffset;
    pSet->Rebase(pSetStart);

    // Shift the tail to the right by required amount
    // ==============================================

    memmove(pSetStart + nNewLength, pSetStart + pSet->GetLength(),
        GetLength() - (nSetStartOffset + pSet->GetLength()));

    // Adjust our cached length
    // ========================

    m_nTotalLength += nExtraSpace;

    return TRUE;

}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CQualifierSetList::ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
                                                offset_t nReduceBy)
{
    // WARNING: Trusing the caller here to specify a valid address!!!

    LPMEMORY pSetEnd = EndOf(*pSet);

    // Shift the tail to the left by required amount
    // =============================================

    memcpy(pSetEnd-nReduceBy, pSetEnd, GetLength() - (pSetEnd - GetStart()));

    // Return the space to the container
    // =================================

    m_pContainer->ReduceQualifierSetListSpace(
        GetStart(), GetLength(), nReduceBy);

    // Adjust our cached length
    // ========================

    m_nTotalLength -= nReduceBy;
}

LPMEMORY CQualifierSetList::CreateLimitedRepresentation(
        IN class CLimitationMapping* pMap, IN CFastHeap* pCurrentHeap,
        MODIFIED CFastHeap* pNewHeap, OUT LPMEMORY pWhere)
{
    // Allocate space for the flags
    // ============================

    BYTE* pfFlags = pWhere;
    *pfFlags = QSL_FLAG_NO_SETS;

    LPMEMORY pCurrentNew = pWhere+1;

    if(*m_pStart == QSL_FLAG_NO_SETS)
    {
        // No qualifier sets to start with
        // ===============================
        return pCurrentNew;
    }

    // Go through all our properties and look them up in the map
    // =========================================================

    int nNewIndex = 0;
    CPropertyInformation OldInfo, NewInfo;

    // IMPORTANT: THIS ASSUMES THAT THE MAPPINGS ARE ORDERED BY THE PROPERTY
    // INDEX OF THE NEW INFO!!!
    // =====================================================================
    pMap->Reset();
    while(pMap->NextMapping(&OldInfo, &NewInfo))
    {
        BOOL bCopy = FALSE;
        LPMEMORY pThisSetData = NULL;
        if(*pfFlags == QSL_FLAG_PRESENT)
        {
            // We are not empty --- just copy the set
            // ======================================

            bCopy = TRUE;
        }
        else
        {
            // Check if this set is actually empty
            // ===================================

            pThisSetData = GetQualifierSetData(OldInfo.nDataIndex);
            if(!CBasicQualifierSet::IsEmpty(pThisSetData))
            {
                // Need to create a list of empties for all previous
                // =================================================

                for(int i = 0; i < nNewIndex; i++)
                {
                    pCurrentNew = CBasicQualifierSet::CreateEmpty(pCurrentNew);
                }
                *pfFlags = QSL_FLAG_PRESENT;
                bCopy = TRUE;
            }
        }

        // Copy the qualifier set if required
        // ==================================

        if(bCopy)
        {
            if(pThisSetData == NULL)
                pThisSetData = GetQualifierSetData(OldInfo.nDataIndex);

            int nLength = CBasicQualifierSet::GetLengthFromData(pThisSetData);
            memcpy(pCurrentNew, pThisSetData, nLength);

            CStaticPtr CurrentNewPtr(pCurrentNew);

            // Check for allocation failures
            if ( !CBasicQualifierSet::TranslateToNewHeap(&CurrentNewPtr,
                    pCurrentHeap, pNewHeap) )
            {
                return NULL;
            }

            pCurrentNew += nLength;
        }

        nNewIndex++;
    }

    return pCurrentNew;
}

LPMEMORY CQualifierSetList::WriteSmallerVersion(int nNumSets, LPMEMORY pMem)
{
    if(IsEmpty())
    {
        *pMem = QSL_FLAG_NO_SETS;
        return pMem+1;
    }

    // Find the end of the last included qualifier set
    // ===============================================

    LPMEMORY pLastSet = GetQualifierSetData(nNumSets-1);
    length_t nLastLen = CBasicQualifierSet::GetLengthFromData(pLastSet);
    length_t nTotalLen = (pLastSet - GetStart()) + nLastLen;

    memcpy(pMem, GetStart(), nTotalLen);
    return pMem + nTotalLen;
}


LPMEMORY CInstancePQSContainer::GetQualifierSetStart()
    {
        RebaseSecondarySet();
        LPMEMORY pStart = m_pList->GetQualifierSetData(m_nPropIndex);
        if(pStart == NULL)
        {
            return (LPMEMORY)&mstatic_EmptySet;
        }
        else return pStart;
    }

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 BOOL CBasicQualifierSet::IsValidQualifierType(VARTYPE vt)
{
    switch(vt)
    {
    case VT_I4:
    case VT_BSTR:
    case VT_R8:
    case VT_BOOL:
    case VT_I4 | VT_ARRAY:
    case VT_BSTR | VT_ARRAY:
    case VT_R8 | VT_ARRAY:
    case VT_BOOL | VT_ARRAY:
        return TRUE;
    }

    return FALSE;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

 void CBasicQualifierSet::Delete(LPMEMORY pData, CFastHeap* pHeap)
{
    CQualifier* pCurrent = GetFirstQualifierFromData(pData);
    CQualifier* pEnd = (CQualifier*)(pData + GetLengthFromData(pData));

    while(pCurrent < pEnd)
    {
        pCurrent->Delete(pHeap);
        pCurrent = (CQualifier*)pCurrent->Next();
    }
}
//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CBasicQualifierSet::TranslateToNewHeap(CPtrSource* pThis,
                                                   CFastHeap* pOldHeap,
                                                   CFastHeap* pNewHeap)
{
    BOOL    fReturn = TRUE;

    int nCurrentOffset = GetMinLength();
    int nEndOffset = GetLengthFromData(pThis->GetPointer());

    while(nCurrentOffset < nEndOffset)
    {
        CShiftedPtr CurrentPtr(pThis, nCurrentOffset);

        // Check for allocation failures
        fReturn = CQualifier::TranslateToNewHeap(&CurrentPtr, pOldHeap, pNewHeap);

        if ( !fReturn )
        {
            break;
        }

        nCurrentOffset += CQualifier::GetPointer(&CurrentPtr)->GetLength();
    }

    return fReturn;
}


//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

 INTERNAL CQualifier* CBasicQualifierSet::GetRegularQualifierLocally(
                                     LPMEMORY pData,
                                     CFastHeap* pHeap,
                                     LPCWSTR wszName)
{
    CQualifier* pCurrent = GetFirstQualifierFromData(pData);
    CQualifier* pEnd = (CQualifier*)(pData + GetLengthFromData(pData));

    while(pCurrent < pEnd)
    {
        if(pHeap->ResolveString(pCurrent->ptrName)->CompareNoCase(wszName) == 0)
        {
            return pCurrent;
        }
        else
        {
            pCurrent = (CQualifier*)pCurrent->Next();
        }
    }
    return NULL;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 INTERNAL CQualifier* CBasicQualifierSet::GetKnownQualifierLocally(
                        LPMEMORY pStart,
                        int nStringIndex)
{
    CQualifier* pCurrent = GetFirstQualifierFromData(pStart);
    CQualifier* pEnd = (CQualifier*)(pStart + GetLengthFromData(pStart));

    while(pCurrent < pEnd)
    {
        if(nStringIndex == CFastHeap::GetIndexFromFake(pCurrent->ptrName))
        {
            return pCurrent;
        }
        else
        {
            pCurrent = (CQualifier*)pCurrent->Next();
        }
    }
    return NULL;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 INTERNAL CQualifier* CBasicQualifierSet::GetQualifierLocally(
                                               LPMEMORY pStart,
                                               CFastHeap* pHeap,
                                               LPCWSTR wszName,
                                               int& nKnownIndex)
{
    // IMPORTANT: MUST COMPUTE nKnownIndex NO MATTER WHAT!!!!
    // ======================================================

    nKnownIndex = CKnownStringTable::GetKnownStringIndex(wszName);
    if(nKnownIndex >= 0)
    {
        // It is a well-known property.
        // ============================

        return GetKnownQualifierLocally(pStart, nKnownIndex);
    }
    else
    {
        // It is not a known string
        // ========================

        return GetRegularQualifierLocally(pStart, pHeap, wszName);
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

 INTERNAL CQualifier* CBasicQualifierSet::GetQualifierLocally(
                                     LPMEMORY pData,
                                     CFastHeap* pHeap,
                                     CCompressedString* pcsName)
{
    CQualifier* pCurrent = GetFirstQualifierFromData(pData);
    CQualifier* pEnd = (CQualifier*)(pData + GetLengthFromData(pData));

    while(pCurrent < pEnd)
    {
        if(pHeap->ResolveString(pCurrent->ptrName)->CompareNoCase(*pcsName)
            == 0)
        {
            return pCurrent;
        }
        else
        {
            pCurrent = (CQualifier*)pCurrent->Next();
        }
    }
    return NULL;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 INTERNAL CQualifier*
CQualifierSet::GetQualifier(
                                                 READ_ONLY LPCWSTR wszName,
                                                 OUT BOOL& bLocal)
{
    // Search the primary set first
    // ============================

    int nKnownIndex;
    CQualifier* pQualifier = GetQualifierLocally(wszName, nKnownIndex);

    if(pQualifier == NULL)
    {
        // Search the secondary set now
        // ============================

        if(!IsComplete())
        {
            if(nKnownIndex >= 0)
            {
                pQualifier = m_pSecondarySet->GetKnownQualifierLocally(
                    nKnownIndex);
            }
            else
            {
                pQualifier = m_pSecondarySet->GetRegularQualifierLocally(
                    wszName);
            }
        }

        // make sure that it propagates to us
        // ==================================

        if(pQualifier == NULL ||
            (pQualifier->GetFlavor() & m_nPropagationFlag) == 0)
            return NULL;

        // Found it in the secondary list
        // ==============================

        bLocal = FALSE;
    }
    else
    {
        // Found it in the primary list,
        // =============================

        bLocal = TRUE;
    }

    return pQualifier;
}

//  Helper function to retrieve a qualifier from local or secondary set as necessary

HRESULT INTERNAL CQualifierSet::GetQualifier( LPCWSTR pwszName, CVar* pVar, long* plFlavor, CIMTYPE* pct )
{

    BOOL bIsLocal;
    CQualifier* pQualifier = GetQualifier(pwszName, bIsLocal);
    if(pQualifier == NULL) return WBEM_E_NOT_FOUND;

    // Set the flavor
    // ==============

    if(plFlavor)
    {
        *plFlavor = pQualifier->fFlavor;
        if(!bIsLocal)
        {
            CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, FALSE);
        }
    }

	// Retrieve the type if requested
	if ( NULL != pct )
	{
		*pct = pQualifier->Value.GetType();
	}

    // Set the value
    // =============

    if ( NULL != pVar )
    {
        // Check for allocation failures
        if ( !pQualifier->Value.StoreToCVar(*pVar,
                (bIsLocal)?GetHeap():m_pSecondarySet->GetHeap()) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_S_NO_ERROR;
}

//  Helper function to retrieve a qualifier from local or secondary set as necessary

HRESULT INTERNAL CQualifierSet::GetQualifier( LPCWSTR pwszName, long* plFlavor, CTypedValue* pTypedValue,
											 CFastHeap** ppHeap, BOOL fValidateSet )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

    BOOL bIsLocal;
    CQualifier* pQualifier = GetQualifier(pwszName, bIsLocal);
    if(pQualifier == NULL) return WBEM_E_NOT_FOUND;

	// Make sure a set will actually work - Ostensibly we are calling this API because we need
	// direct access to a qualifier's underlying data before actually setting (possibly because
	// the qualifier is an array).
	if ( fValidateSet )
	{
		hr = ValidateSet( pwszName, pQualifier->fFlavor, pTypedValue, TRUE, TRUE );
	}

	if ( SUCCEEDED( hr ) )
	{
		if(plFlavor)
		{
			*plFlavor = pQualifier->fFlavor;
			if(!bIsLocal)
			{
				CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, FALSE);
			}
		}

		// Copy out the qualifier data
		// ==============

		pQualifier->Value.CopyTo( pTypedValue );

		// Return the proper heap
		*ppHeap = (bIsLocal)?GetHeap():m_pSecondarySet->GetHeap();
	}

    return hr;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 LPMEMORY CQualifierSetList::CreateListOfEmpties(LPMEMORY pStart,
                                                       int nNumProps)
{
    *pStart = QSL_FLAG_NO_SETS;
    return pStart+1;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CQualifierSetList::EnsureReal()
{
    if(*m_pStart == QSL_FLAG_PRESENT) return TRUE;
    *m_pStart = QSL_FLAG_PRESENT;

    if (!m_pContainer->ExtendQualifierSetListSpace(m_pStart, GetHeaderLength(),
        ComputeRealSpace(m_nNumSets)))
        return FALSE;

    LPMEMORY pCurrent = m_pStart + GetHeaderLength();
    for(int i = 0; i < m_nNumSets; i++)
    {
        pCurrent = CBasicQualifierSet::CreateEmpty(pCurrent);
    }

    m_nTotalLength = (pCurrent - m_pStart);
    return TRUE;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CQualifierSetList::TranslateToNewHeap(CFastHeap* pCurrentHeap,
                                                  CFastHeap* pNewHeap)
{
    //NO Sets so we're done
    if(*m_pStart == QSL_FLAG_NO_SETS) return TRUE;

    BOOL    fReturn = TRUE;

    LPMEMORY pCurrent = m_pStart + GetHeaderLength();
    for(int i = 0; i < m_nNumSets; i++)
    {
        CStaticPtr QSPtr(pCurrent);

        // Check for allocation failures
        fReturn = CBasicQualifierSet::TranslateToNewHeap(&QSPtr, pCurrentHeap, pNewHeap);

        if ( !fReturn )
        {
            break;
        }

        pCurrent += CBasicQualifierSet::GetLengthFromData(pCurrent);
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprop.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROP.H

Abstract:

  This file defines the classes related to property representation 
  in WbemObjects

  Classes defined: 
      CPropertyInformation    Property type, location and qualifiers
      CPropertyLookup         Property name and information pointers.
      CPropertyLookupTable    Binary search table.
      CDataTable              Property data table
      CDataTableContainer     Anything that has a data table inside of it.

History:

    3/10/97     a-levn  Fully documented
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_PROPERTY__H_
#define __FAST_PROPERTY__H_

// DEVNOTE:TODO - Take this OUT for final release.  It's just here to help us debug stuff
#define DEBUG_CLASS_MAPPINGS

#include "fastheap.h"
#include "fastval.h"
#include "fastqual.h"

//#pragma pack(push, 1)

//*****************************************************************************
//*****************************************************************************
//
//  class CPropertyInformation
//
//  This object represents all the information which comes with the definition
//  of a property, excluding its name and value. The name is stored in
//  CPropertyLookup (below). The value is stored separately in the CDataTable.
//
//  This is one of those classes where the 'this' pointer is pointing directly
//  to the data. The format of the data is:
//
//      Type_t nType            The type of the property (see fastval.h for 
//                              CType). One of the high bits is used to convey
//                              whether this property came from the parent.
//      propindex_t nDataIndex  The index of this property in the v-table for
//                              the class.
//      offset_t nDataOffset    The offset of the data for this property from
//                              the start of the v-table. Since the number of
//                              bytes a property takes up in a v-table is 
//                              defined by its type (strings and such are
//                              stored on the heap) this value does not change.
//
//      Qualifier Set. The data for the property qualifier set follows 
//                              immediately after the other tree fields. See
//                              fastqual.h for qualifier set data layout.
//
//*****************************************************************************
//
//  GetHeaderLength
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes in the structure before the qualifier
//                  set data.
//
//*****************************************************************************
//
//  GetMinLength
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes required for this structure assuming
//                  that the qualifier set is empty.
//
//*****************************************************************************
//
//  SetBasic
//
//  Sets the values of the header parameters and initializes the qualifier set
//  to an empty one. See the class header for parameter descriptions.
//
//  PARAMETERS:
//
//      Type_t _nType                   The type of the property
//      propindex_t _nDataIndex         The index in the v-table.
//      offset_t _nDataOffset           The offset in the v-table.
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   the start of the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t;   the total length of this structure
//
//*****************************************************************************
//
//  GetType
//
//  RETURN VALUES:
//
//      Type_t:     the type of the property
//
//*****************************************************************************
//
//  GetQualifierSetData
//
//  RETURN VALUES:
//
//      LPMEMORY:   the pointer to the qualifier set data (immediately after
//                  the header elements, see class header for details).
//
//*****************************************************************************
//
//  Delete
//
//  Removes any data associated with this structure from the associated heap. 
//  Basically, forwards the call to its qualifier set
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap to remove data from.
//
//*****************************************************************************
//
//  MarkAsParents
//
//  Sets the bit in the nType field which designates this property is one that
//  came from our parent class.
//
//*****************************************************************************
//
//  ComputeNecessarySpaceForPropagation
//
//  Computes how much space this structure will take when propagated to a child
//  class. The difference stems from the fact that not all 
//  qualifiers propagate (see fastqual.h for discussion of propagation). 
//
//  RETURN VALUES:
//
//      length_t: the number of bytes required to represent the propagated 
//                  structure.
//
//*****************************************************************************
//
//  WritePropagatedHeader
//
//  Fills in the header values for the corresponding structure in a child
//  object: an instance or a derived class. Basically, the values are the same
//  except for the fact that the "parent's" bit is set in the type field to
//  indicate that the property came from the parent
//
//  PARAMETERS:
//
//      CPropertyInformation* pDest     The destination structure.
//
//*****************************************************************************
//
//  static WritePropagatedVersion
//
//  Writes a complete propagated version of itself, including the header 
//  adjusted for propagation (see WritePropagatedHeader) and the propagated
//  qualifiers.
//
//  Since 'this' pointer of this class points directly to its memory block and
//  copying a qualifier set may require memory allocations which may in turn
//  move the memory block thus invalidating the 'this' pointer, pointer sources
//  are used instead (see CPtrSource in fastsprt.h).
//
//  PARAMETERS:
//
//      CPtrSource* pThis           The source for the 'this' pointer. 
//      CPtrSource* pDest           The source for the destination pointer.
//      CFastHeap* pOldHeap         The heap where we keep our extra data.
//      CFastHeap* pNewHeap         The heap where the propagated vesion should
//                                  keep its extra data.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  Moves any data this object has on the heap to a different heap.  The data
//  is NOT freed from the old heap. 
//
//  Since 'this' pointer of this class points directly to its memory block and
//  copying a qualifier set may require memory allocations which may in turn
//  move the memory block thus invalidating the 'this' pointer, pointer sources
//  are used instead (see CPtrSource in fastsprt.h).
//
//  PARAMETERS:
//
//      CPtrSource* pThis           The source for the 'this' pointer. 
//      CFastHeap* pOldHeap         The heap where we keep our extra data.
//      CFastHeap* pNewHeap         The heap where we should keep our extra data
//      
//*****************************************************************************
//
//  static CopyToNewHeap
//
//  As this object almost always lives in a heap itself, this function copies
//  it to a different heap. The operation consists of physically transfering 
//  the bits and then translating internal objects (like qualifiers) to the
//  new heap as well.
//
//  NOTE: the data is not freed form the old heap.
//
//  PARAMETERS:
//
//      heapptr_t ptrInfo           The heap pointer to ourselves on the
//                                  original heap.
//      CFastHeap* pOldHeap         The original heap.
//      CFastHeap* pNewHeap         The heap to copy to.
//
//  RETURN VALUES:
//
//      heapptr_t:  the pointer to our copy on the new heap.
//
//*****************************************************************************
//
//  IsKey
//
//  This function determines if this property is a key by looking for the 'key'
//  qualifier in the qualifier set.
//
//  RETURN VALUES:
//
//      TRUE if the qualfier is there and has the value of TRUE.
//
//*****************************************************************************
//
//  IsIndexed
//
//  Determines if thius property is indexed by looking for the 'index' 
//  qualifier in the qualifier set. 
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap we are based in.
//
//  RETURN VALUES:
//
//      TRUE if the qualifier is there and has the value of TRUE.
//
//*****************************************************************************
//
//  CanBeNull
//
//  A property may not take on a value of NULL if it is marked with a not_null
//  qualifier. This function checks if this qualifier is present.
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap we are based in.
//
//  RETURN VALUES:
//
//      TRUE if the qualifier is NOT there or has the value of FALSE.
//
//*****************************************************************************
//
//  IsRef
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap we are based in.
//
//  RETURN VALUES:
//
//      TRUE iff this property is a reference, i.e. it has a 'syntax' qualifier
//          with a value of "ref" or "ref:<class name>".
//
//*****************************************************************************
//
//  IsOverriden
//
//  Checks if this (parents) property is overriden in this class. A property is
//  considered overriden if its default value has been changed or qualifiers
//  have been added or overriden.
//
//  PARAMETERS:
//
//      CDataTable* pData       The defaults table of this class (see below).
//
//  RETURN VALUES:
//
//      TRUE iff overriden.
//
//*****************************************************************************

// Special case property handles.  These should never happen because our actual maximum offset value
// is 8k (1024 QWORD properties), and we're using a whole 16-bit value for the offest
#define	FASTOBJ_CLASSNAME_PROP_HANDLE		0xFFFFFFFE
#define	FASTOBJ_SUPERCLASSNAME_PROP_HANDLE	0xFFFFFFFD

// Helper macros for IWbemObjetAccess

// Index will be a value from 0 to 1023
#define WBEM_OBJACCESS_HANDLE_GETINDEX(handle) (handle >> 16) & 0x3FF

// Maximum offset in the data table is ( 1024 * 8 ) - 1, whih is 0x18FF
#define WBEM_OBJACCESS_HANDLE_GETOFFSET(handle) handle & 0x1FFF

// 3 unused bits on DataTable offset are used for further type info
#define WBEM_OBJACCESS_ARRAYBIT		0x2000
#define WBEM_OBJACCESS_OBJECTBIT	0x4000
#define WBEM_OBJACCESS_STRINGBIT	0x8000

// Identifies the above bits
#define WBEM_OBJACCESS_HANDLE_ISARRAY(handle)	(BOOL) ( handle & WBEM_OBJACCESS_ARRAYBIT )
#define WBEM_OBJACCESS_HANDLE_ISOBJECT(handle)	(BOOL) ( handle & WBEM_OBJACCESS_OBJECTBIT )
#define WBEM_OBJACCESS_HANDLE_ISSTRING(handle)	(BOOL) ( handle & WBEM_OBJACCESS_STRINGBIT )

// If ARRAY String and Object are set, this is a reserved handle, since these are
// all exclusive of each other
#define WBEM_OBJACCESS_HANDLE_ISRESERVED(handle)	(BOOL)	( WBEM_OBJACCESS_HANDLE_ISOBJECT(handle) &&\
															WBEM_OBJACCESS_HANDLE_ISSTRING(handle) &&\
															WBEM_OBJACCESS_HANDLE_ISARRAY(handle) )
													
// This does a proper masking of the actual length (no more than 8 bytes)
#define WBEM_OBJACCESS_HANDLE_GETLENGTH(handle) (int) ( ( handle >> 26 ) & 0xF )

// Hi bit is used for IsPointer or not
#define WBEM_OBJACCESS_HANDLE_ISPOINTER(handle) handle & 0x80000000


// The data in this structure is unaligned
#pragma pack(push, 1)
class CPropertyInformation
{
public:
    Type_t nType;
    propindex_t nDataIndex;
    offset_t nDataOffset;
    classindex_t nOrigin;
    // followed by the qualifier set.

public:
    static length_t GetHeaderLength() 
    {
        return sizeof(Type_t) + sizeof(propindex_t) + sizeof(offset_t) +
                sizeof(heapptr_t);
    }

    static length_t GetMinLength() 
    {
        return GetHeaderLength() + CBasicQualifierSet::GetMinLength();
    }

    static CPropertyInformation* GetPointer(CPtrSource* pSource)
        {return (CPropertyInformation*)pSource->GetPointer();}
    void SetBasic(Type_t _nType, propindex_t _nDataIndex,
                            offset_t _nDataOffset, classindex_t _nOrigin)
    {
        nType = _nType;
        nDataIndex = _nDataIndex;
        nDataOffset = _nDataOffset;
        nOrigin = _nOrigin;
        CClassPropertyQualifierSet::SetDataToNone(GetQualifierSetData());
    }

    LPMEMORY GetStart() {return LPMEMORY(this);}
    Type_t GetType() {return nType;}
    LPMEMORY GetQualifierSetData() 
        {return LPMEMORY(this) + GetHeaderLength();}
    length_t GetLength() 
    {
        return GetHeaderLength() + 
            CClassPropertyQualifierSet::GetLengthFromData(
                                            GetQualifierSetData());
    }
    void Delete(CFastHeap* pHeap) 
        {CBasicQualifierSet::Delete(GetQualifierSetData(), pHeap);}

    void MarkAsParents()
        {nType = CType::MakeParents(nType);}

public:
    length_t ComputeNecessarySpaceForPropagation()
    {
        return GetHeaderLength() + 
            CClassPropertyQualifierSet::ComputeNecessarySpaceForPropagation(
                                GetQualifierSetData(), 
                                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);
    }
    void WritePropagatedHeader(CFastHeap* pOldHeap,
                    CPropertyInformation* pDest, CFastHeap* pNewHeap);

    static BOOL WritePropagatedVersion(CPtrSource* pThis,
                                        CPtrSource* pDest,
                                        CFastHeap* pOldHeap, 
                                        CFastHeap* pNewHeap)
    {
		// No allocations performed by this call
        GetPointer(pThis)->WritePropagatedHeader(pOldHeap,
                                                GetPointer(pDest), pNewHeap);
        CShiftedPtr QSPtrThis(pThis, GetHeaderLength());
        CShiftedPtr QSPtrDest(pDest, GetHeaderLength());

		// Check for possible allocation errors
        return ( CClassPropertyQualifierSet::WritePropagatedVersion(
	                    &QSPtrThis, WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, 
		                &QSPtrDest, pOldHeap, pNewHeap) != NULL );
    }

    BOOL ProduceUnmergedVersion(CFastHeap* pCurrentHeap,
                                CFastHeap* pNewHeap, UNALIGNED heapptr_t& ptrResult)
    {
        int nUnmergedSpace = CBasicQualifierSet::ComputeUnmergedSpace(
            GetQualifierSetData());

		// Check for allocation errors
        heapptr_t ptrNew;
		BOOL fReturn = pNewHeap->Allocate(GetHeaderLength()+nUnmergedSpace, ptrNew);

		if ( fReturn )
		{
			CPropertyInformation* pNewInfo = 
				(CPropertyInformation*) pNewHeap->ResolveHeapPointer(ptrNew);

			memcpy(pNewInfo, this, GetHeaderLength());

			// Check for allocation errors
			if ( CBasicQualifierSet::Unmerge(
					GetQualifierSetData(), 
					pCurrentHeap,
					pNewInfo->GetQualifierSetData(), 
					pNewHeap) != NULL )
			{
				ptrResult = ptrNew;
			}
			else
			{
				fReturn = FALSE;
			}

		}	// IF fReturn

		return fReturn;
    }

    static BOOL TranslateToNewHeap(CPtrSource* pThis,
                                      CFastHeap* pOldHeap, CFastHeap* pNewHeap)
    {
        CShiftedPtr QSPtr(pThis, GetHeaderLength());
        return CClassPropertyQualifierSet::TranslateToNewHeap(
				&QSPtr, pOldHeap, pNewHeap);
    }

    static BOOL CopyToNewHeap(heapptr_t ptrInfo, 
        CFastHeap* pOldHeap, CFastHeap* pNewHeap, UNALIGNED heapptr_t& ptrResult)
    {
        CPropertyInformation* pInfo = (CPropertyInformation*)
            pOldHeap->ResolveHeapPointer(ptrInfo);
        length_t nLen = pInfo->GetLength();

		// Check for allocation failure
        heapptr_t ptrNewInfo;
		BOOL fReturn = pNewHeap->Allocate(nLen, ptrNewInfo);

		if ( fReturn )
		{
			memcpy(
				pNewHeap->ResolveHeapPointer(ptrNewInfo),
				pOldHeap->ResolveHeapPointer(ptrInfo),
				nLen);

			CStaticPtr DestPtr(pNewHeap->ResolveHeapPointer(ptrNewInfo));

			// Check for allocation failure
			fReturn = TranslateToNewHeap(&DestPtr, pOldHeap, pNewHeap);
			if ( fReturn )
			{
				ptrResult = ptrNewInfo;
			}
		}
        
        return fReturn;
    }

	// Helper function to build a handle
	long GetHandle( void )
	{
		// 16-bits for offset
		long lHandle = nDataOffset;

		// 5-bits for length
		// Always set this for the basic type, so that with arrays,
		// we don't need to look up CIMTYPE to know what the size is
		lHandle |= (CType::GetLength(CType::GetBasic(nType))) << 26;

		// 10-bits for index
		lHandle |= (nDataIndex << 16);

		// 1-bit for IsPointer
		if(CType::IsPointerType(nType))
			lHandle |= 0x80000000;

		// For now, just experiment with this here
		Type_t	typeActual = CType::GetActualType(nType);
		Type_t	typeBasic = CType::GetBasic(nType);

		if ( CType::IsArray( typeActual ) )
		{
			lHandle |= WBEM_OBJACCESS_ARRAYBIT;
		}

		if ( CType::IsStringType( typeBasic ) )
		{
			lHandle |= WBEM_OBJACCESS_STRINGBIT;
		}
		else if ( CIM_OBJECT == typeBasic )
		{
			lHandle |= WBEM_OBJACCESS_OBJECTBIT;
		}

		return lHandle;
	}

public:
    BOOL IsKey() 
    {
        return CBasicQualifierSet::GetKnownQualifierLocally(
            GetQualifierSetData(), 
            CKnownStringTable::GetIndexOfKey()) != NULL;
    }

    BOOL IsIndexed(CFastHeap* pHeap) 
    {
        return CBasicQualifierSet::GetRegularQualifierLocally(
            GetQualifierSetData(), pHeap, L"indexed") != NULL;
    }

    BOOL CanBeNull(CFastHeap* pHeap)
    {
        if(IsKey()) return FALSE;
        if(IsIndexed(pHeap)) return FALSE;
        return CBasicQualifierSet::GetRegularQualifierLocally(
            GetQualifierSetData(), pHeap, L"not_null") == NULL;
    }


    BOOL IsRef(CFastHeap* pHeap);
    BOOL IsOverriden(class CDataTable* pDataTable);

    HRESULT ValidateRange(CFastHeap* pHeap, CDataTable* pData, 
                            CFastHeap* pDataHeap);
    HRESULT ValidateStringRange(CCompressedString* pcsValue);
    HRESULT ValidateDateTime(CCompressedString* pcsValue);
    HRESULT ValidateObjectRange(CEmbeddedObject* pEmbObj, LPCWSTR wszClassName);
};
#pragma pack(pop)

//*****************************************************************************
//*****************************************************************************
//
//  class CPropertyLookup
//
//  This simple structure is an element of the property lookup table 
//  (CPropertyLookupTable) described below. It contains the heap pointer to the
//  name of the property (ptrName to CCompressedString (see faststr.h)) and 
//  the heap pointer to the information of the property (ptrInformation to 
//  CPropertyInformation (see above)).
//
//*****************************************************************************
//
//  Delete
//
//  Removes all the information from the heap, namely the name and the
//  information structure (both of which can delete themselves).
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap where the data resides.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  Moves all the data (the name and the information( to a different heap and
//  changes the structure members to the new heap pointer values.
//
//  Since 'this' pointer of this class points directly to its memory block and
//  copying a qualifier set may require memory allocations which may in turn
//  move the memory block thus invalidating the 'this' pointer, pointer sources
//  are used instead (see CPtrSource in fastsprt.h).
//
//  PARAMETERS:
//
//      CPtrSource* pThis           The source for the 'this' pointer. 
//      CFastHeap* pOldHeap         The heap where we keep our extra data.
//      CFastHeap* pNewHeap         The heap where we should keep our extra data
//      
//*****************************************************************************
//
//  IsIncludedUnderLimitation
//
//  This function determines if this property should be included in an object
//  limited by a "select" criteria.
//
//  PARAMETERS:
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      IN CFastHeap* pCurrentHeap  The heap where our data resides.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if the property is included
//
//*****************************************************************************

// The data in this structure is unaligned
#pragma pack(push, 1)
struct CPropertyLookup
{
    /* fixed-sized structure for binary search for properties */
    heapptr_t ptrName; // CompressedString
    heapptr_t ptrInformation; // PropertyInformation_t

    static CPropertyLookup* GetPointer(CPtrSource* pSource) 
        {return (CPropertyLookup*)pSource->GetPointer();}
public:
    void Delete(CFastHeap* pHeap)
    {
        pHeap->FreeString(ptrName);
        CPropertyInformation* pInfo = (CPropertyInformation*)
            pHeap->ResolveHeapPointer(ptrInformation);
        pInfo->Delete(pHeap);
        pHeap->Free(ptrInformation, pInfo->GetLength());
    }

    static BOOL TranslateToNewHeap(CPtrSource* pThis,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap)
    {
		BOOL	fReturn = TRUE;

		// Check for allocation failure
        heapptr_t ptrTemp;
		if ( !CCompressedString::CopyToNewHeap(
				GetPointer(pThis)->ptrName, pOldHeap, pNewHeap, ptrTemp) )
		{
			return FALSE;
		}

        GetPointer(pThis)->ptrName = ptrTemp;

		// Check for allocation failure
        if ( !CPropertyInformation::CopyToNewHeap(
				GetPointer(pThis)->ptrInformation, pOldHeap, pNewHeap, ptrTemp) )
		{
			return FALSE;
		}

        GetPointer(pThis)->ptrInformation = ptrTemp;

		return TRUE;
    }

    BOOL WritePropagatedVersion(CPropertyLookup* pDest,
                                        CFastHeap* pOldHeap, 
                                        CFastHeap* pNewHeap)
    {
		// Check for allocation failures
        if ( !CCompressedString::CopyToNewHeap(
				ptrName, pOldHeap, pNewHeap, pDest->ptrName) )
		{
			return FALSE;
		}

        length_t nInfoLen = GetInformation(pOldHeap)->
                                ComputeNecessarySpaceForPropagation();

		// Check for allocation failures
		if ( !pNewHeap->Allocate(nInfoLen, pDest->ptrInformation ) )
		{
			return FALSE;
		}

        CHeapPtr OldInfo(pOldHeap, ptrInformation);
        CHeapPtr NewInfo(pNewHeap, pDest->ptrInformation);

        return CPropertyInformation::WritePropagatedVersion(
				&OldInfo, &NewInfo, pOldHeap, pNewHeap);
    }
        
    CPropertyInformation* GetInformation(CFastHeap* pHeap)
    {
        return (CPropertyInformation*)pHeap->ResolveHeapPointer(ptrInformation);
    }

    BOOL IsIncludedUnderLimitation(
        IN CWStringArray* pwsNames,
        IN CFastHeap* pCurrentHeap);
};  
#pragma pack(pop)

class CLimitationMapping;

//*****************************************************************************
//*****************************************************************************
//
//  class CPropertyTableContainer
//
//  See CPropertyLookupTable class first. 
//
//  This class defines the capabilities required by CPropertyLookupTable of
//  the objects that contain its memory block within thewir own.
//
//*****************************************************************************
//
//  GetHeap
//
//  RETURN VALUES:
//
//      CFastHeap*:     the current heap.
//
//*****************************************************************************
//
//  ExtendPropertyTableSpace
//
//  Called when the property table needs more memory. If no more memory is 
//  avaiable at the end of the current block, the container must reallocate 
//  and move the table, calling Rebase with the new location.
//
//  PARAMETERS:
//
//      LPMEMORY pOld           Current memory block
//      length_t nOldLength     The current length of the block.
//      length_t nNewLength     The new length of the block.
//
//*****************************************************************************
//
//  ReduceProipertyTableSpace
//
//  Called when the property table returns memory to the system. The container
//  may NOT move the table's memory block in response to this call.
//
//  PARAMETERS:
//
//      LPMEMORY pOld           Current memory block
//      length_t nOldLength     The current length of the block.
//      length_t nDecrement     How much memory to return.
//
//*****************************************************************************
//  
//  GetDataTable
//
//  RETURN VALUES:
//
//      CDataTable*: the data table for this object (defaults for a class, 
//                      actual values for an instance).
//
//*****************************************************************************

class COREPROX_POLARITY CPropertyTableContainer
{
public:
    virtual CFastHeap* GetHeap() = 0;
    virtual BOOL ExtendPropertyTableSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nNewLength) = 0;
    virtual void ReducePropertyTableSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nDecrement) = 0;
    virtual class CDataTable* GetDataTable() = 0;
    virtual classindex_t GetCurrentOrigin() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CPropertyLookupTable
//
//  This is the table mapping property names to their information. Its memory
//  block has the following format: 
//      int nProps:     the number of properties in the table
//      followed by that many CPropertyLookup structures.
//  Since CPropertyLookup structures have fixed length, this class allows 
//  direct access to any property. The structures are sorted alphabetically
//  in a case-insensitive manner, so properties can be looked up using a binary
//  search.
//
//*****************************************************************************
//
//  SetData
//
//  Initializer.
//
//  PARAMETERS:
//
//      LPMEMORY pStart                         The memory block.
//      CPropertyTableContainer* pContainer     Container (see class def).
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   the pointer to the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t:   the length of the memory block
//
//*****************************************************************************
//
//  Skip
//
//  RETURN VALUES:
//
//      LPMEMORY:   the pointer to the first byte after the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Advises the object that its memory block has moved.
//
//  PARAMETERS:
//
//      LPMEMORY pNew       The new location of the memory block
//
//*****************************************************************************
//
//  GetNumProperties
//
//  RETURN VALUES:
//
//      int:    the number of properties in the table.
//
//*****************************************************************************
//
//  GetAt
//
//  Returns the pointer to the CPropertyLookup structure at a given position.
//  Range validation is not performed.
//
//  Parameters;
//
//      int nIndex      The index of THE STRUCTURE IN THE TABLE. This is NOT
//                      the v-table index of the property.
//  RETURN VALUES:
//
//      CPropertyLookup*    at the given position
//
//*****************************************************************************
//
//  FindProperty
//
//  Main method. Finds the property's CPropertyLookup structure given the name
//  of the property. Performs a binary search.
//
//  Parameters;
//
//      LPCWSTR wszName     The name of the property to find
//
//  RETURN VALUES:
//
//      CPropertyLookup*:   NULL if not found
//
//*****************************************************************************
//
//  FindPropertyByPtr
//
//  Finds the property's CPropertyLookup structure given the heap pointer to
//  the property's name. While binary search is not possible in this case,
//  pointer comparison is so much faster that string comparison that this 
//  method is much more efficient that FindProperty.
//
//  PARAMETERS:
//
//      heapptr_t ptrName       Heap pointer to the name of the property.
//
//  RETURN VALUES:
//
//      CPropertyLookup*:   NULL if not found
//
//*****************************************************************************
//
//  InsertProperty
//
//  Inserts a new property into the lookup table as well as into the 
//  corrseponding data table. First of all, it traverses the lookup table to
//  find the smallest free location in the v-table for this class. Based on
//  that, it creates the property information (CPropertyInformation) structure.
//  Finally, it inserts the appropriate CPropertyLookup structure into the
//  alphabetically appropriate place in the list
//
//  PARAMETERS:
//
//      LPCWSTR wszName     The name of the property
//      Type_t nType        The type of the property (see CType in fastval.h)
//
//  RETURN VALUES:
//
//      int:    the index of the new property in this table (NOT THE INDEX
//                  IN THE V_TABLE!)
//
//*****************************************************************************
//
//  DeleteProperty
//
//  Removes a property from the lookup table as well as from the data table.
//  First of all, it determines how much space the property took in the v-table
//  and collapses that location. This involves updating the indeces and the 
//  offsets of all the properties that came after it. Finally, it removes the
//  CPropertyLookup structure from the lookup table.
//
//  PARAMETERS:
//
//      CPropertyLookup* pLookup        The property to remove
//      int nFlags                      Must be e_UpdateDataTable.
//
//*****************************************************************************
//
//  static GetMinLength
//
//  Returns the minimum space required to hold a property lookup table (for 0
//  properties).
//
//  RETURN VALUES:
//
//      length_t: number of bytes.
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty lookup tahle (for 0 properties) on a given memory block.
//
//  PARAMETERS:
//
//      LPMEMORY pMemory        Where to create
//
//  RETURN VALUES:
//
//      LPMEMORY: the first byte after the table.
//
//*****************************************************************************
//
//  static Merge
//
//  Invoked when a derived-most portion of a class is merged with the parent
//  to create the combined class definition. Only the overriden properties are
//  stored in the database for the derived class, and even then only the info
//  that has actually changed is stored. 
//
//  PARAMETERS:
//
//      CPropertyLookupTable* pParentTable  The parent lookup table.
//      CFastHeap* pParentHeap              The heap where the parent keeps
//                                          extra data.
//      CPropertyLookupTable* pChildTable   The child lookup table.
//      CFastHeap* pChildHeap               The heap where the child keeps
//                                          extra data.
//      LPMEMORY pDest                      Destination memory block. Assumed
//                                          to be large enough to contain the
//                                          merged lookup table.
//      CFastHeap* pNewHeap                 Destinatio heap.ASSUMED TO BE LARGE
//                                          ENOUGH THAT NO ALLOCATION WILL 
//                                          CAUSE IOT TO RELOCATE!
//      BOOL bCheckValidity                 If TRUE, child qualifier overrides
//                                          are checked for not violating 
//                                          parents override restrictions.
//                                          (see fastqual.h)
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the merge.
//
//*****************************************************************************
//
//  Unmerge
//
//  Called when a derived class is about to be written into the database. This
//  function extracts the information in the child which is different from the
//  parent, i.e. only those properties that are overriden (see IsOverriden in
//  CProeprtyInformation). The result can later be Merge'd with the parent
//  class to recreate the complete definition.
//
//  PARAMETERS:
//
//      CDataTable* pDataTable      The data table wher the property data is
//                                  stored. It is used to check if a property
//                                  has been overriden.
//      CFastHeap* pCurrentHeap     The heap where we keep extra data.
//      LPMEMORY pDest              Destination memoty block. Assumed  to be 
//                                  large enough to hold the result. 
//      CFastHeap* pNewHeap         Destination heap. ASSUMED TO BE LARGE 
//                                  ENOUGH THAT NO ALLOCATION WILL CAUSE IT
//                                  TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the unmerge.
//
//*****************************************************************************
//
//  WritePropagatedVersion
//
//  Invoked when a new derived class is created. Writes a propagated version
//  of all the properties to the destination memory block: all marked as
//  parent's and with only propagating qualifiers included.
//
//  PARAMETERS:
//
//      CFastHeap* pCurrentHeap     The heap where we keep the data.
//      LPMEMORY pDest              Destination memory block. Assumed  to be 
//                                  large enough to hold the result. 
//      CFastHeap* pNewHeap         Destination heap. ASSUMED TO BE LARGE 
//                                  ENOUGH THAT NO ALLOCATION WILL CAUSE IT
//                                  TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the propagated version
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Creates a limited representation of this table on a given block of 
//  memory as described in EstimateLimitedRepresentationLength in fastobj.h.
//  Basically, it removes all the excluded properties and optionally removes
//  the qualifiers.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to 
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      IN CFastHeap* pNewHeap      The heap to use for all out-of-table data.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//      OUT CPropertyMapping* pMap  If not NULL, property mappings are placed
//                                  into this object. See CPropertyMapping for 
//                                  details.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************

class COREPROX_POLARITY CPropertyLookupTable
{
protected:
    PUNALIGNEDINT m_pnProps; // beginning of the structure
    CPropertyTableContainer* m_pContainer;
public:
    void SetData(LPMEMORY pStart, CPropertyTableContainer* pContainer)
    {
        m_pnProps = (PUNALIGNEDINT)pStart;
        m_pContainer = pContainer;
    }

    LPMEMORY GetStart() {return LPMEMORY(m_pnProps);}
    int GetLength() 
        {return sizeof(int) + sizeof(CPropertyLookup)* *m_pnProps;}
    LPMEMORY Skip() {return GetStart() + GetLength();}
    void Rebase(LPMEMORY pNewMemory) {m_pnProps = (PUNALIGNEDINT)pNewMemory;}

public:
    int GetNumProperties() {return *m_pnProps;}
    CPropertyLookup* GetAt(int nIndex) 
    {
		// DEVNOTE:WIN64:SANJ - 
		//
		// Original code:
		// return (CPropertyLookup*)
		//            (GetStart() + sizeof(int) + sizeof(CPropertyLookup)* nIndex);
		//
		// This is NOT portable to WIN64 if nIndex is ever negative, in which case
		// since the sizeof() operands are unsigned, nIndex is treated as unsigned
		// which is a large 32-bit value, which when added unsigned to GetStart()
		// which in Win64 is a 64-bit pointer, generates a very large 64-bit value.
		//
		// This compiles with no problems, so to fix it, I cast the entire 32-bit
		// portion of this statement as an int, so the compiler knows that the
		// final value is signed.
		//

        return (CPropertyLookup*)
            ( GetStart() + (int) ( sizeof(int) + sizeof(CPropertyLookup) * nIndex ) );
    }

    CFastHeap* GetHeap() {return m_pContainer->GetHeap();}
    CPropertyLookup* FindProperty(LPCWSTR wszName)
    {
        CFastHeap* pHeap = m_pContainer->GetHeap();

		// Only continue if the number of properties is >= 1.

		if ( *m_pnProps >= 1 )
		{
			CPropertyLookup* pLeft = GetAt(0);
			CPropertyLookup* pRight = GetAt(*m_pnProps-1);

			while(pLeft <= pRight)
			{
				CPropertyLookup* pNew = pLeft + (pRight-pLeft)/2;
				int nCompare = pHeap->ResolveString(pNew->ptrName)->
									CompareNoCase(wszName);
            
				if(nCompare == 0)
				{
					return pNew;
				}
				else if(nCompare > 0)
				{
					pRight = pNew-1;
				}
				else 
				{
					pLeft = pNew+1;
				}
			}

		}	// IF *m_pnProps >= 1

        return NULL;
    }
    CPropertyLookup* FindPropertyByName(CCompressedString* pcsName)
    {
        CFastHeap* pHeap = m_pContainer->GetHeap();
        CPropertyLookup* pLeft = GetAt(0);
        CPropertyLookup* pRight = GetAt(*m_pnProps-1);
        while(pLeft <= pRight)
        {
            CPropertyLookup* pNew = pLeft + (pRight-pLeft)/2;
            int nCompare = pHeap->ResolveString(pNew->ptrName)->
                                CompareNoCase(*pcsName);
            
            if(nCompare == 0)
            {
                return pNew;
            }
            else if(nCompare > 0)
            {
                pRight = pNew-1;
            }
            else 
            {
                pLeft = pNew+1;
            }
        }

        return NULL;
    }
    
    CPropertyLookup* FindPropertyByPtr(heapptr_t ptrName)
    {
        for(int i = 0; i < *m_pnProps; i++)
        {
            if(GetAt(i)->ptrName == ptrName) 
                return GetAt(i);
        }
        return NULL;
    }

    CPropertyLookup* FindPropertyByOffset(offset_t nOffset)
    {
        CFastHeap* pHeap = GetHeap();
        for(int i = 0; i < *m_pnProps; i++)
        {
            if(GetAt(i)->GetInformation(pHeap)->nDataOffset == nOffset) 
                return GetAt(i);
        }
        return NULL;
    }

    enum {e_DontTouchDataTable, e_UpdateDataTable};

    HRESULT InsertProperty(LPCWSTR wszName, Type_t nType, int& nReturnIndex);
    HRESULT InsertProperty(const CPropertyLookup& Lookup, int& nReturnIndex);
    void DeleteProperty(CPropertyLookup* pLookup, int nFlags);
public:
    static length_t GetMinLength() {return sizeof(int);}
    static LPMEMORY CreateEmpty(LPMEMORY pStart)
    {
        *(PUNALIGNEDINT)pStart = 0;
        return pStart + sizeof(int);
    }
public:
   static LPMEMORY Merge(CPropertyLookupTable* pParentTable, 
       CFastHeap* pParentHeap, 
       CPropertyLookupTable* pChildTable,  CFastHeap* pChildHeap, 
       LPMEMORY pDest, CFastHeap* pNewHeap, BOOL bCheckValidity = FALSE);

   LPMEMORY Unmerge(CDataTable* pDataTable, CFastHeap* pCurrentHeap,
       LPMEMORY pDest, CFastHeap* pNewHeap);

   LPMEMORY WritePropagatedVersion(CFastHeap* pCurrentHeap,
       LPMEMORY pDest, CFastHeap* pNewHeap);

   BOOL MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        IN OUT CLimitationMapping* pMap);

   LPMEMORY CreateLimitedRepresentation(
        IN OUT CLimitationMapping* pMap,
        IN CFastHeap* pNewHeap,
        OUT LPMEMORY pDest,
        BOOL& bRemovedKeys);

    HRESULT ValidateRange(BSTR* pstrName, CDataTable* pData, CFastHeap* pDataHeap);
};

//*****************************************************************************
//*****************************************************************************

// forward definitions
#ifdef DEBUG_CLASS_MAPPINGS
class CWbemClass;
class CWbemInstance;
#endif

class COREPROX_POLARITY CLimitationMapping
{
protected:
    struct COnePropertyMapping
    {
        CPropertyInformation m_OldInfo;
        CPropertyInformation m_NewInfo;
    };
    CFlexArray m_aMappings; // COnePropertyMapping*
    int m_nNumCommon;
    int m_nCurrent;

    offset_t m_nVtableLength;
    offset_t m_nCommonVtableLength;

    long m_lFlags;
    BOOL m_bIncludeServer;
    BOOL m_bIncludeNamespace;
    BOOL m_bIncludeDerivation;

    CPropertyInformation** m_apOldList;
    int m_nPropIndexBound;
    BOOL m_bAddChildKeys;

#ifdef DEBUG_CLASS_MAPPINGS
	CWbemClass*	m_pClassObj;
#endif

protected:
    void CopyInfo(OUT CPropertyInformation& Dest,
                         IN const CPropertyInformation& Source)
    {
        memcpy((LPVOID)&Dest, (LPVOID)&Source, 
            CPropertyInformation::GetHeaderLength());
    }
public:
    CLimitationMapping();
    ~CLimitationMapping();

    void Build(int nPropIndexBound);

    void Map(COPY CPropertyInformation* pOldInfo, 
            COPY CPropertyInformation* pNewInfo,
            BOOL bCommon);

    void Reset() { m_nCurrent = 0; }
    BOOL NextMapping(OUT CPropertyInformation* pOldInfo,
                     OUT CPropertyInformation* pNewInfo);

    int GetNumMappings() {return m_aMappings.Size();}
    void RemoveSpecific();

    void SetVtableLength(offset_t nLen, BOOL bCommon) 
    {
        m_nVtableLength = nLen;
        if(bCommon) m_nCommonVtableLength = nLen;
    }
    offset_t GetVtableLength() {return m_nVtableLength;}

    void SetFlags(long lFlags) {m_lFlags = lFlags;}
    long GetFlags() {return m_lFlags;}

    void SetIncludeServer(BOOL bInclude) {m_bIncludeServer = bInclude;}
    BOOL ShouldIncludeServer() {return m_bIncludeServer;}

    void SetIncludeNamespace(BOOL bInclude) 
        {m_bIncludeNamespace = bInclude;}
    BOOL ShouldIncludeNamespace() {return m_bIncludeNamespace;}

    void SetIncludeDerivation(BOOL bInclude) 
        {m_bIncludeDerivation = bInclude;}
    BOOL ShouldIncludeDerivation() {return m_bIncludeDerivation;}

    void SetAddChildKeys(BOOL bAdd) 
        {m_bAddChildKeys = bAdd;}
    BOOL ShouldAddChildKeys() {return m_bAddChildKeys;}

    BOOL ArePropertiesLimited() {return m_apOldList != NULL;}
    propindex_t GetMapped(propindex_t nPropIndex);
    INTERNAL CPropertyInformation* GetMapped(
                        READ_ONLY CPropertyInformation* pOldInfo);

#ifdef DEBUG_CLASS_MAPPINGS
	void SetClassObject( CWbemClass* pClassObj );
	HRESULT ValidateInstance( CWbemInstance* pInst );
#endif

};

//***************************************************************************
//***************************************************************************
//
//  class CDataTableContainer
//
//  See CDataTable class below first.
//
//  This class encapsulates the functionality required by CDataTable class of
//  any objectwhose memory block contains that of the data table.
//
//***************************************************************************
//
//  GetHeap
//
//  RETURN VALUES:
//
//      CFastHeap*  the heap currently in use.
//
//***************************************************************************
//
//  ExtendDataTableSpace
//
//  Called by the data table when it required more memory for its memory 
//  block. If the container must relocate the memory block in order to grow
//  it, it must inform the data table of the new location by calling Rebase
//
//  PARAMETERS:
//
//      LPMEMORY pOld       The current location of the memory block
//      length_t nLength    The curent length of the memory block
//      length_t nNewLength the desired length of the memory block
//
//***************************************************************************
//
//  ReduceDataTableSpace
//
//  Called by the data table when it wants to return some of its memory to 
//  the container. The container may NOT relocate the memory block in response
//  to this call.
//
//  PARAMETERS:
//
//      LPMEMORY pOld       The current location of the memory block
//      length_t nLength    The curent length of the memory block
//      length_t nDecrement How many bytes to return.
//
//***************************************************************************
class COREPROX_POLARITY CDataTableContainer
{
public:
    virtual CFastHeap* GetHeap() = 0;
    virtual BOOL ExtendDataTableSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nNewLength) = 0;
    virtual void ReduceDataTableSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nDecrement) = 0;
    //virtual void SetDataLength(length_t nDataLength) = 0;
};

enum
{
    e_NullnessBit = 0,
    e_DefaultBit = 1,

    NUM_PER_PROPERTY_BITS
};

typedef CBitBlockTable<NUM_PER_PROPERTY_BITS> CNullnessTable;

//*****************************************************************************
//*****************************************************************************
//
//  class CDataTable
//
//  This class represents the table containing the values of the properties.
//  It appears both in class definitions, where it represents default values,
//  and in instances, where it represents the actual data, The main part of the
//  data table is arranged as a v-table: all instance of a given class have 
//  exactly the same layout. That is, if property MyProp of class MyClass is
//  at offset 23 in one instance of MyClass, it will be at offset23 in every
//  other instance of MyClass. This is achieved by storing variable-length data
//  on the Heap. The offsets for any given property are found in 
//  CPropertyInformation structures.
//
//  In addition to property values, CDataTable contains several additional bits
//  of information for each property. Currently therre are two such bits;
//  1) Whether or not the property has the value of NULL. If TRUE, the actual
//      data at the property's offset is ignored.
//  2) Whether or not the property value is inherited from a parent. For
//      instance, if an instance does not define the value of a property, that
//      it inherits the default. But if the default value changes after the 
//      instance is created, the change propagates to the instance. This is
//      accomplished using this bit: if it is TRUE, the parent's value is
//      copied over the child's every time this object is created (Merged).
//   
//  These bits are stored in a bit table in the order of property indeces. The
//  index for a given property is found in the nDataIndex field of its 
//  CPropertyInformation structure.
//
//  The layout of the memory block is as follows:
//      1) 2*<number of properties> bits rounded up to the next byte.
//      2) The v-table itself. 
//  The total length of the structure is found in the CClassPart's headet's
//  nDataLength field.
//
//*****************************************************************************
//
//  SetData
//
//  Initialization
//
//  PARAMETERS:
//
//      LPMEMORY pData                      The memory block for the table
//      int nProps                          The number of properties.
//      int nLength                         The total length of the structure
//      CDataTableContainer* m_pContainer   The container (see class).
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   start of the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  returns:
//
//      length_t:   the length of the memory block
//
//*****************************************************************************
//
//  GetNullnessLength
//
//  RETURN VALUES:
//
//      length_t:   the length of the bit-table part of the memory block.
//
//*****************************************************************************
//
//  GetDataLength
//
//  RETURN VALUES:
//
//      length_t:   the length of the v-table part of the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object that its memory block has moved. Updates internal data.
//
//  PARAMETERS:
//
//      LPMEMORY pNewMem        The new location of the memory block
//
//*****************************************************************************
//
//  IsDefault
//
//  Checks if a property at a given index has the inherited value, or its own.
//  
//  PARAMETERS:
//
//      int nIndex          The index of the property(see CPropertyInformation)
//
//  RETURN VALUES:
//
//      BOOL
//
//*****************************************************************************
//
//  SetDefaultness
//
//  Sets the bit responsible for saying whether a given property has the 
//  inherited value, or its own.
//
//  PARAMETERS:
//
//      int nIndex          The index of the property(see CPropertyInformation)
//      BOOL bDefault       The new value of the bit
//
//*****************************************************************************
//
//  IsNull
//
//  Checks if a property at a given index is NULL.
//  
//  PARAMETERS:
//
//      int nIndex          The index of the property(see CPropertyInformation)
//
//  RETURN VALUES:
//
//      BOOL
//
//*****************************************************************************
//
//  SetNullness
//
//  Sets the bit responsible for saying whether a given property is NULL. 
//
//  PARAMETERS:
//
//      int nIndex          The index of the property(see CPropertyInformation)
//      BOOL bNull          The new value of the bit
//
//*****************************************************************************
//
//  GetOffset
//
//  Access the data at a given offset in the v-table as an UntypedValue (see
//  fastval.h for details). No range checking is performed.
//
//  PARAMETERS:
//
//      offset_t nOffset    The offset of the property.
//
//  RETURN VALUES:
//
//      CUntypedValue*  pointing to the data at the given offset.
//
//*****************************************************************************
//
//  SetAllToDefault
//
//  Marks all properties as having the default values
//
//*****************************************************************************
//
//  CopyNullness
//
//  Copies the nullness attributes of all properties from another CDataTable
//  
//  PARAMETERS:
//
//      CDataTable* pSourceTable        The table whose attributes to copy.
//
//*****************************************************************************
//
//  ExtendTo
//
//  Extends the data table to accomodate a given number of properties and and
//  a given area of the v-table. Request more space from the container, if
//  required, then grows the nullness table if required and shifts the v-table
//  if required.
//
//  PARAMETERS:
//
//      propindex_t nMaxIndex       the largest allowed property index.
//      offse_t nOffsetBound        The size of the v-table.
//
//*****************************************************************************
//
//  RemoveProperty
//
//  Removes a property from the data table. This involves cllapsing its bits in
//  the nullness table as well as its area in the v-table. Adjustments still
//  need to be made to the property definitions (see CPropertyLookupTable::
//  DeleteProperty).
//
//  PARAMETERS:
//
//      propindex_t nIndex      The index of the property to remove.
//      offset_t nOffset        The offset of the property to remove.
//      lenght_t nLength        The length of the v-table area occupied by the
//                              property.
//
//*****************************************************************************
//
//  static GetMinLength
//
//  Returns the amount of space required by a data table on 0 properties.
//
//  RETURN VALUES:
//
//      0
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty data table on a block of memory. Since there is no info
//  in such a table, does nothing
//
//  PARAMETERS:
//
//      LPMEMORY pStart         The memory block to create the table on
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the amount of space required for a data table with a given number
//  of properties and the size of the v-table (the sum of data sizes for all 
//  properties).
//
//  PARAMETERS:
//
//      int nNumProps           The number of propeties (determines nullness
//                              table size).
//      int nDataSize           The size of the v-table.
//
//  RETURN VALUES:
//
//      length_t:       the number of bytes required for such a table
//
//*****************************************************************************
//
//  Merge
//
//  Merges two data tables, one from parent, one from child. This occurs when
//  an instance or a derived class is being read from the database and merged
//  with its (parent) class. Since some properties may not be defined in the
//  child object (left default), and their values will need to be read from the
//  parent object.
//
//  PARAMETERS:
//
//      CDataTable* pParentData             The parent's data table object
//      CFastHeap* pParentHeap              The parent's heap where string data
//                                          and such is kept.
//      CDataTable* pChildData              The child's data table object
//      CFastHeap* pChildHeap               The child's heap.
//      CPropertyLookupTable* pProperties   The property lookup table for this
//                                          class. It is needed to find
//                                          individual properties.
//      LPMEMORY pDest                      Destination memory block. Assumed
//                                          to be large enough to contain all
//                                          the merge.
//      CFastHeap* pNewHeap                 Destination heap. ASSUMED TO BE
//                                          LARGE ENOUGH THAT NO ALLOCATION 
//                                          WILL CAUSE IT TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY: pointer to the first byte after the merge.
//
//*****************************************************************************
//
//  Unmerge
//
//  Called when it is time to store an instance or a class into the database.
//  Since inherited information (the one that didn't change in this object
//  as compared to its parent) isn't stored in the database, it needs to be
//  removed or unmerged.
//
//  PARAMETERS:
//
//      CPropertyLookupTable* pLookupTable  The property lookup table for this
//                                          class.
//      CFastHeap* pCurrentHeap             The heap where we keep extra data.
//      LPMEMORY pDest                      Destination memory block. Assumed
//                                          to be large enough to contain all
//                                          the unmerge.
//      CFastHeap* pNewHeap                 Destination heap. ASSUMED TO BE
//                                          LARGE ENOUGH THAT NO ALLOCATION 
//                                          WILL CAUSE IT TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY: pointer to the first byte after the unmerge.
//
//*****************************************************************************
//
//  WritePropagatedVersion
//
//  Called when a new instance or a derived class is created. It produces the
//  data table for the child. Copies all the values from the parent's table and
//  marks them all as "default" in the nullness table.
//
//  PARAMETERS:
//
//      CPropertyLookupTable* pLookupTable  The property lookup table for this
//                                          class.
//      CFastHeap* pCurrentHeap             The heap where we keep extra data.
//      LPMEMORY pDest                      Destination memory block. Assumed
//                                          to be large enough to contain all
//                                          the propagated data.
//      CFastHeap* pNewHeap                 Destination heap. ASSUMED TO BE
//                                          LARGE ENOUGH THAT NO ALLOCATION 
//                                          WILL CAUSE IT TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY: pointer to the first byte after the propagated data.
//
//*****************************************************************************
//     
//  TranslateToNewHeap
//
//  Moves all the data we have on the heap to a different heap. Property lookup
//  table is needed here to interpret the proeprties. This function does NOT
//  freee the data from the current heap.
//
//  PARAMETERS:
//
//      CPropertyLookupTable* pLookupTable  The property lookup table for this
//                                          class.
//      BOOL bIsClass                       Whether this is a class defaults 
//                                          table or an instance data table. 
//                                          If it is a class, the data for
//                                          properties which inherit their
//                                          parent's default values is not
//                                          present. 
//      CFastHeap* pCurrentHeap             The heap where we currently keep 
//                                          extra data.
//      CFastHeap* pNewHeap                 The heap where the extra data
//                                          should go.
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Copies the data for the properties which are included under the limitation.
//  It uses the old property lookup table and the new one to guide it.
//
//  PARAMETERS:
//
//      CPropertyMapping* pMap      The property mapping to effect, see 
//                                  CPropertyMapping for details.
//      IN BOOL bIsClass            TRUE if this is the defaults table for the
//                                  class, FALSE if data table for an instance
//      IN CFastHeap* pOldHeap      The heap where our extra data is stored.
//      IN CFastHeap* pNewHeap      The heap where the extra data should go to.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************

class COREPROX_POLARITY CDataTable
{
protected:
    CNullnessTable* m_pNullness;
    LPMEMORY m_pData;
    int m_nLength;
    int m_nProps;
    CDataTableContainer* m_pContainer;

    friend class CWbemObject;
    friend class CWbemClass;
    friend class CWbemInstance;
	friend class CClassPart;

public:
    void SetData(LPMEMORY pData, int nProps, int nLength,
        CDataTableContainer* pContainer)
    {
        m_pNullness = (CNullnessTable*)pData;
        m_pData = pData + CNullnessTable::GetNecessaryBytes(nProps);
        m_nLength = nLength;
        m_nProps = nProps;
        m_pContainer = pContainer;
    }

    LPMEMORY GetStart() {return LPMEMORY(m_pNullness);}
    length_t GetLength() {return m_nLength;}

    length_t GetNullnessLength()
		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned 32-bit value.  We do not support length
		// > 0xFFFFFFFF so cast is ok.
        {return (length_t) ( m_pData - LPMEMORY(m_pNullness) );}

    length_t GetDataLength() 
        {return m_nLength-GetNullnessLength();}

    void Rebase(LPMEMORY pNewMemory)
    {
        int nTableLen = GetNullnessLength();
        m_pNullness = (CNullnessTable*)pNewMemory;
        m_pData = pNewMemory + nTableLen;
    }

public:
    BOOL IsDefault(int nProp) 
        {return m_pNullness->GetBit(nProp, e_DefaultBit);}
    void SetDefaultness(int nProp, BOOL bDefault)
        {m_pNullness->SetBit(nProp, e_DefaultBit, bDefault);}
    BOOL IsNull(int nProp)
        {return m_pNullness->GetBit(nProp, e_NullnessBit);}
    void SetNullness(int nProp, BOOL bNull)
        {m_pNullness->SetBit(nProp, e_NullnessBit, bNull);}

    CUntypedValue* GetOffset(offset_t nOffset) 
        {return (CUntypedValue*)(m_pData + nOffset);}

    void SetAllToDefault()
    {
        for(int i = 0; i < m_nProps; i++)
            SetDefaultness(i, TRUE);
    }
    void CopyNullness(CDataTable* pParent)
    {
        for(int i = 0; i < m_nProps; i++)
            SetNullness(i, pParent->IsNull(i));
    }


public:
    BOOL ExtendTo(propindex_t nMaxIndex, offset_t nOffsetBound);
    void RemoveProperty(propindex_t nIndex, offset_t nOffset, length_t nLength);
public:
    static length_t GetMinLength() {return 0;}
    static LPMEMORY CreateEmpty(LPMEMORY pStart) {return pStart;}
    static length_t ComputeNecessarySpace(int nNumProps, int nDataLen)
    {
        return CNullnessTable::GetNecessaryBytes(nNumProps) + nDataLen;
    }

    static LPMEMORY Merge( 
        CDataTable* pParentData, CFastHeap* pParentHeap,
        CDataTable* pChildData, CFastHeap* pChildHeap,
        CPropertyLookupTable* pProperties, LPMEMORY pDest, CFastHeap* pNewHeap);

    LPMEMORY Unmerge(CPropertyLookupTable* pLookupTable,
        CFastHeap* pCurrentHeap, LPMEMORY pDest, CFastHeap* pNewHeap);

    LPMEMORY WritePropagatedVersion(CPropertyLookupTable* pLookupTable,
        CFastHeap* pCurrentHeap, LPMEMORY pDest, CFastHeap* pNewHeap);

/*
        CPropertyLookupTable* pOldTable,
        CPropertyLookupTable* pNewTable, 
*/
    LPMEMORY CreateLimitedRepresentation(
        CLimitationMapping* pMap,
        BOOL bIsClass,
        CFastHeap* pOldHeap, 
        CFastHeap* pNewHeap, LPMEMORY pDest);

    BOOL TranslateToNewHeap(CPropertyLookupTable* pLookupTable, BOOL bIsClass,
        CFastHeap* pCurrentHeap, CFastHeap* pNewHeap);
    
    LPMEMORY WriteSmallerVersion(int nNumProps, length_t nDataLen, 
                                            LPMEMORY pMem);

};

class CDataTablePtr : public CPtrSource
{
protected:
    CDataTable* m_pTable;
    offset_t m_nOffset;
public:
    CDataTablePtr(CDataTable* pTable, offset_t nOffset) 
        : m_pTable(pTable), m_nOffset(nOffset) {}
    LPMEMORY GetPointer() 
        {return (LPMEMORY)m_pTable->GetOffset(m_nOffset);}
};

//***************************************************************************

//#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprox.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROX.CPP

Abstract:

    Object Marshaling

History:

--*/

#include "precomp.h"
#include "fastprox.h"

ULONG CFastProxy::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_lRef);
}

ULONG CFastProxy::Release()
{
    long lNewRef = InterlockedDecrement(&m_lRef);
    if(lNewRef == 0)
    {
        delete this;
    }
    return lNewRef;
}

STDMETHODIMP CFastProxy::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
    {
        AddRef();
        *ppv = (void*)(IUnknown*)(IMarshal*)this;
        return S_OK;
    }
    if(riid == IID_IMarshal)
    {
        AddRef();
        *ppv = (void*)(IMarshal*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

STDMETHODIMP CFastProxy::GetUnmarshalClass(REFIID riid, void* pv, 
          DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::GetMarshalSizeMax(REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::MarshalInterface(IStream* pStream, REFIID riid, 
    void* pv, DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::UnmarshalInterface(IStream* pStream, REFIID riid, 
                                            void** ppv)
{
    CWbemObject* pObj = CWbemObject::CreateFromStream(pStream);
    if(pObj == NULL)
        return E_FAIL;

    HRESULT hres = pObj->QueryInterface(riid, ppv);
    pObj->Release();
    return hres;
}

STDMETHODIMP CFastProxy::ReleaseMarshalData(IStream* pStream)
{
    return S_OK;
}

STDMETHODIMP CFastProxy::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastqual.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTQUAL.H

Abstract:

  This file defines the classes related to qualifier processing in WbeWbemjects
  See fastqual.h for full documentation and fastqual.inc for  function
  implementations.

  Classes implemented: 
      CQualifierFlavor                Encapsulates qualifier flavor infor
      CQualifier                      Represents a qualifier
      CBasicQualifierSet              Represents read-only functionality.
      CQualiferSetContainer           What qualifier set container supports.
      CQualifierSet                   Full-blown qualifier set (template)
      CQualifierSetListContainer      What qualifier set list container supports.
      CQualifierSetList               List of qualifier sets.
      CInstanceQualifierSet           Instance qualifier set.
      CClassQualifierSet              Class qualifier set.
      CClassPQSContainer              Class property qualifier set container
      CClassPropertyQualifierSet      Class property qualifier set
      CInstancePQSContainer           Instance proeprty qualifier set container
      CInstancePropertyQualifierSet   Instance property qualifier set

History:

    2/20/97     a-levn  Fully documented
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_QUALIFIER__H_
#define __FAST_QUALIFIER__H_

#include <wbemidl.h>
#include "wstring.h"
#include "fastval.h"

//#pragma pack(push, 1)

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierFlavor
//
//  This class corresponds to qualifier flavor. It contains one byte which is
//  where the flavor is stored. Because of its simple data storage, most of its
//  member functions have static counterparts which take a BYTE or a BYTE& as 
//  the first parameter. Here, we document only the non-static members where
//  appropriate.
//
//  The flavor consists of four parts:
//
//  1) Origin. Where this qualifier came from. Can be any of these values:
//      WBEM_FLAVOR_ORIGIN_LOCAL:        defined here
//      WBEM_FLAVOR_ORIGIN_PROPAGATED:   inherited from elsewhere
//      WBEM_FLAVOR_ORIGIN_SYSTEM:       unused
//
//  2) Propagation rules. Where this qualifier propagates to. Can be 
//      WBEM_FLAVOR_DONT_PROPAGATE or any combination of these values:
//      WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE
//      WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
//
//  3) Permissions. What the heirs of this qualifier can do with it. Can be
//      one of these:
//      WBEM_FLAVOR_OVERRIDABLE:     heirs may change the value any way the want
//      WBEM_FLAVOR_NOT_OVERRIDABLE: heirs may not change the value.
//
//	4) Amendments: Support for localization in which localized qualifiers
//		are merged in from a localization namespace.
//		WBEM_FLAVOR_AMENDED
//
//  The parts are |'ed together.
//
//*****************************************************************************
//
//  Clear
//
//  Sets the flavor to 0.
//
//*****************************************************************************
//
//  GetPropagation
//
//  Retrieves propagation-related section of the flavor.
//
//  Returns:
//
//      BYTE
//
//*****************************************************************************
//
//  SetPropagation
//
//  Sets the propation-related section of the flavor. The other sections remain
//  untouched.
//
//  Parameters:
//
//      BYTE byPropagation  The propagation section to set. Other sections of
//                          byPropagation are ignored.
//
//*****************************************************************************
//
//  DoesPropagateToInstances
//
//  Returns:
//
//      BOOL    TRUE iff "propagate to instances" flag is set.
//
//*****************************************************************************
//
//  DoesPropagateToDerivedClass
//
//  Returns:
//
//      BOOL    TRUE iff "propagate to dervied class" flag is set.
//
//*****************************************************************************
//
//  GetPermissions
//
//  Returns:
//
//      BYTE:   the permissions section of the flavor (overrides, etc).
//
//*****************************************************************************
//
//  SetPermissions
//
//  Sets the permissions section of the flavor. The other sections remain 
//  untouched.
//
//  Parameters:
//
//      BYTE byPermissions  The permissions to set. The other sections of
//                          byPermissions are ignored.
//
//*****************************************************************************
//
//  IsOverridable
//
//  Returns:
//
//      BOOL:   TRUE iff the qualifier may be overriden by those who inherit it
//
//*****************************************************************************
//
//  SetOverridable
//
//  Sets whether those who inherit this qualifier may override it.
//
//  Parameters:
//
//      BOOL bIs    If TRUE set to overridable, if not set to not overridable.
//
//*****************************************************************************
//
//  GetOrigin
//
//  Returns:
//
//      BYTE: the origin section of the flavor
//
//*****************************************************************************
//
//  SetOrigin
//
//  Sets the origin section of the flavor.
//
//  Parameters:
//
//      BYTE byOrigin   The origin to set. The other sections of byOrigin are
//                      ignored.
//
//*****************************************************************************
//
//  IsLocal
//
//  Returns:
//
//      BOOL:   TRUE iff the origin of this qualifier is local.
//
//*****************************************************************************
//
//  SetLocal
//
//  Sets whether or not the origin of this qualifier is local.
//
//  Parameters:
//
//      BOOL bIs    If TRUE, the origin is set to local. 
//                  If FALSE, to propagated.
//
//*****************************************************************************
//
//  IsAmended
//
//  Returns:
//
//      BOOL:   TRUE if the qualifier is amended
//
//*****************************************************************************
//
//  SetAmended
//
//  Sets whether or not the qualifier is amended
//
//  Parameters:
//
//      BOOL bIs    If TRUE, amended
//                  If FALSE, not amended.
//
//*****************************************************************************


// The data in this structure is unaligned
#pragma pack(push, 1)

class CQualifierFlavor
{
protected:
    BYTE m_byFlavor;
public:
     CQualifierFlavor(BYTE byFlavor) : m_byFlavor(byFlavor) {}
     operator BYTE() {return m_byFlavor;}

	 bool operator ==( const CQualifierFlavor& flavor )
		{ return m_byFlavor == flavor.m_byFlavor; }

     static void Clear(BYTE& byFlavor) {byFlavor = 0;}
     void Clear() {Clear(m_byFlavor);}

     static BYTE GetPropagation(BYTE byFlavor) 
        {return byFlavor & WBEM_FLAVOR_MASK_PROPAGATION;}
     BYTE GetPropagation() {return GetPropagation(m_byFlavor);}

     static void SetPropagation(BYTE& byFlavor, BYTE byPropagation)
    {
        byFlavor &= ~WBEM_FLAVOR_MASK_PROPAGATION;
        byFlavor |= byPropagation;
    }
     void SetPropagation(BYTE byPropagation)
        {SetPropagation(m_byFlavor, byPropagation);}

     static BOOL DoesPropagateToInstances(BYTE byFlavor)
    {
        return (GetPropagation(byFlavor) & 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
    }
     BOOL DoesPropagateToInstances()
        {return DoesPropagateToInstances(m_byFlavor);}

     static BOOL DoesPropagateToDerivedClass(BYTE byFlavor)
    {
        return (GetPropagation(byFlavor) & 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);
    }
     BOOL DoesPropagateToDerivedClass()
        {return DoesPropagateToDerivedClass(m_byFlavor);}
    
     static BYTE GetPermissions(BYTE byFlavor) 
        {return byFlavor & WBEM_FLAVOR_MASK_PERMISSIONS;}
     BYTE GetPermissions() {return GetPermissions(m_byFlavor);}

     static void SetPermissions(BYTE& byFlavor, BYTE byPermissions)
    {
        byFlavor &= ~WBEM_FLAVOR_MASK_PERMISSIONS;
        byFlavor |= byPermissions;
    }
     void SetPermissions(BYTE byPermissions)
        {SetPermissions(m_byFlavor, byPermissions);}

     static BOOL IsOverridable(BYTE byFlavor)
    {
        return GetPermissions(byFlavor) == WBEM_FLAVOR_OVERRIDABLE;
    }
     BOOL IsOverridable() {return IsOverridable(m_byFlavor);}

     static void SetOverridable(BYTE& byFlavor, BOOL bIs)
    {
        SetPermissions(byFlavor, bIs?WBEM_FLAVOR_OVERRIDABLE:
                                     WBEM_FLAVOR_NOT_OVERRIDABLE);
    }
     void SetOverridable(BOOL bIs)
        {SetOverridable(m_byFlavor, bIs);}

     static BYTE GetOrigin(BYTE byFlavor) 
        {return byFlavor & WBEM_FLAVOR_MASK_ORIGIN;}
     BYTE GetOrigin() {return GetOrigin(m_byFlavor);}

     static void SetOrigin(BYTE& byFlavor, BYTE byOrigin)
    {
        byFlavor &= ~WBEM_FLAVOR_MASK_ORIGIN;
        byFlavor |= byOrigin;
    }
     void SetOrigin(BYTE byOrigin)
        {SetOrigin(m_byFlavor, byOrigin);}

     static BOOL IsLocal(BYTE byFlavor)
        {return GetOrigin(byFlavor) == WBEM_FLAVOR_ORIGIN_LOCAL;}
     BOOL IsLocal() {return IsLocal(m_byFlavor);}

     static void SetLocal(BYTE& byFlavor, BOOL bIs)
    {
        SetOrigin(byFlavor, bIs?WBEM_FLAVOR_ORIGIN_LOCAL:
                                WBEM_FLAVOR_ORIGIN_PROPAGATED);
    }
     void SetLocal(BOOL bIs) {SetLocal(m_byFlavor, bIs);}

     static BOOL IsAmended(BYTE byFlavor)
        {return byFlavor & WBEM_FLAVOR_MASK_AMENDED;}
     BOOL IsAmended() {return IsAmended(m_byFlavor);}

     static void SetAmended(BYTE& byFlavor, BOOL bIs)
    {
		 byFlavor &= ~WBEM_FLAVOR_MASK_AMENDED;
		 byFlavor |= (bIs ? WBEM_FLAVOR_AMENDED:
							WBEM_FLAVOR_NOT_AMENDED);
    }
     void SetAmended(BOOL bIs) {SetAmended(m_byFlavor, bIs);}

    WString GetText();
};
#pragma pack(pop)

// 'key' qualifier is special cased and must always have this flavor.
#define ENFORCED_KEY_FLAVOR (WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |      \
                            WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |  \
                            WBEM_FLAVOR_NOT_OVERRIDABLE)
#define ENFORCED_INDEXED_FLAVOR		ENFORCED_KEY_FLAVOR
#define ENFORCED_SINGLETON_FLAVOR	ENFORCED_KEY_FLAVOR
#define ENFORCED_CIMTYPE_FLAVOR		(WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
									WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifier
//
//  Represents a single qualifier, including its name and value. A qualifier
//  is represented in memory by a sequence of:
//
//      heapptr_t ptrName   Contains the heap pointer to the name of the
//                          qualifier. The location of the heap is assumed to
//                          be known to the container. As with all heap 
//                          pointers, this one may be fake if the qualifier\
//                          name is well-known (see fastheap.h and faststr.h)
//      CQualifierFlavor fFlavor
//                          As described above, contains the qualifier flavor.
//      CTypedValue Value   Contains the value of the qualfier, including the
//                          type. As described in fastval.h, the value stores
//                          all variable-length data on the heap. The heap
//                          used here is the same as used for ptrName.
//
//  The 'this' pointer of CQualifier points directly at the structure.
//
//*****************************************************************************
//
//  GetLength
//
//  Returns the total length of the structure (which varies depending on the 
//  type of the value).
//
//  Returns:
//
//      length_t:       the length in bytes.
//
//*****************************************************************************
//
//  Next
//
//  Returns:
//
//      LPMEMORY:   the pointer to the first byte following thie qualifier in
//                  memory.
//
//*****************************************************************************
//
//  static GetHeaderLength
//
//  The number of bytes (constant) consumed by the header of this structure
//  (the part before the value starts).
//
//*****************************************************************************
//
//  GetFlavor
//
//  Returns:
//
//      BYTE:   the flavor.
//
//*****************************************************************************
//
//  Delete
//
//  Frees any data this qualifier may have on the fast heap. Does not touch the
//  qualifier memory block itself.
//
//  Parameters:
//
//      CFastHeap* pHeap    The heap where this qualifier keeps its data.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  Moves all the data that this qualifier has on the heap to a new heap and
//  updates all internal heap pointers accordingly. 
//
//  When heap allocations are performed, the heap may grow. Such growth may 
//  require reallocation of the object memory block. But the 'this' pointer of
//  CQualifier points inside the object's memory block, and so 'this' pointer
//  would be invalidated. Thus, this function had to be made static, with the
//  'this' pointer provided in a source (see CPtrSource in fastsprt.h).
//
//  Parameters:
//
//      CPtrSource* pThis       Where to get our 'this' pointer.
//      CFastHeap* pOldHeap     The heap where our data currently is.
//      CFastHeap* pNewHeap     The heap where our data must go.
//
//*****************************************************************************
//
//  CopyTo
//
//  Copies the memory block to a new location, in the process translating the
//  data to a new heap. See TranslateToNewHeap for more details. Luckily, we
//  can get away without sourcing our 'this' pointer because we copy data
//  first and tehn translate at the destination.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of our destination pointer.
//      CFastHeap* pOldHeap     The heap where our data currently is.
//      CFastHeap* pNewHeap     The heap where our data must go.
//
//*****************************************************************************

// The data in this structure is unaligned
#pragma pack(push, 1)
struct CQualifier
{
    heapptr_t ptrName;
    CQualifierFlavor fFlavor;
    CTypedValue Value;

    static  CQualifier* GetPointer(CPtrSource* pSource)
        {return (CQualifier*)pSource->GetPointer();}
public:
     static int GetHeaderLength() 
        {return sizeof(heapptr_t) + sizeof(CQualifierFlavor);}
     int GetLength() {return GetHeaderLength() + Value.GetLength();}
     LPMEMORY Next() {return Value.Skip();}
public:
    BYTE GetFlavor() {return fFlavor;}

public:
     void Delete(CFastHeap* pHeap) 
        {Value.Delete(pHeap); pHeap->FreeString(ptrName); }
     static BOOL TranslateToNewHeap(CPtrSource* pThis,
                                    CFastHeap* pOldHeap, CFastHeap* pNewHeap)
    {
		 // Check for allocation errors
        heapptr_t ptrNewName;
		if ( !CCompressedString::CopyToNewHeap(
				CQualifier::GetPointer(pThis)->ptrName, pOldHeap, pNewHeap, ptrNewName) )
		{
			return FALSE;
		}

        GetPointer(pThis)->ptrName = ptrNewName;
        CShiftedPtr PtrValue(pThis, GetHeaderLength());

		 // Check for allocation errors
        return CTypedValue::TranslateToNewHeap(&PtrValue, pOldHeap, pNewHeap);
    }
    BOOL CopyTo(CPtrSource* pDest, CFastHeap* pOldHeap, 
                                          CFastHeap* pNewHeap)
    {
        memcpy(pDest->GetPointer(), this, GetLength());
        return CQualifier::TranslateToNewHeap(pDest, pOldHeap, pNewHeap);
    }
};
#pragma pack(pop)

//*****************************************************************************
//*****************************************************************************
//
//  class CBasicQualifierSet
//
//  CBasicQualifierSet encapsulates all the qualifier set functionality that
//  can be implemented without any knowledge of our container. This includes
//  all the read-only functionality and the static methods.
//
//  The layout of a qualifier set in memory is very simple: first comes a 
//  length_t variable containing the total length of the set (including itself)
//  Then come qualifiers, as described in CQualifier above, one after another.
//  It is important to realize that the first item in teh set is the *length*,
//  not the number of qualifiers.
//
//  CBasicQualifierSet has no notion of a parent's qualifier set, so all the
//  qualifiers are retrieved locally.
//
//*****************************************************************************
//************************** static methods ***********************************
//  
//  static SetDataLength
//
//  Sets the length of the set in the set's memory block.
//
//  Properties:
//
//      LPMEMORY pStart     Where the set's memory block starts.
//      length_t nLength    The length to set.
//
//*****************************************************************************
//
//  static GetMinLength
//
//  Returns:
//
//      length_t:   the length of an empty qualifier set.
//
//*****************************************************************************
//
//  static GetLengthFromData
//
//  Returns the length of a qualifier set based on its memory block.
//
//  Parameters:
//
//      LPMEMORY pStart     Where the set's memory block starts.
//
//  Returns:
//
//      length_t:   
//
//*****************************************************************************
//
//  static IsEmpty
//
//  Determines if a given qualifier set is empty based on its memory block.
//
//  Parameters:
//
//      LPMEMORY pStart     Where the set's memory block starts.
//
//  Returns:
//
//      BOOL:   TRUE idd the set is empty.
//
//*****************************************************************************
//
//  static GetFirstQualifierFromData
//
//  Retrieves the pointer to the first qualifier in the set (after that, one
//  can use that CQualifier::Next function to iterate over them).
//
//  Parameters:
//
//      LPMEMORY pStart     Where the set's memory block starts.
//
//  Returns:
//
//      CQualifier*
//
//*****************************************************************************
//
//  static GetRegularQualifierLocally
//
//  Tries to find a qualifier with a given name, where the caller guarantees 
//  that the name is not a well-known string (see faststr,h). 
//
//  Parameters:
//
//      LPMEMORY pData      Points to the set's memory block.
//      CFastHeap* pHeap    Where the extra data (including qualifier names)
//                          is kept.
//      LPCWSTR wszName     The name of the qualifier to find.
//
//  Returns:
//
//      CQualifier* pointing to the qualifier found (not a copy) or NULL if
//          not found.
//
//*****************************************************************************
//
//  static GetKnownQualifierLocally
//
//  Tries to find a qualifier with a given name, where the caller guarantees 
//  that the name is a well-known string (see faststr.h) and provides the 
//  index of that string.
//
//  Parameters:
//
//      LPMEMORY pData      Points to the set's memory block.
//      int nStringIndex    The index of the qualifier's name in the well-known
//                          string table.
//
//  Returns:
//
//      CQualifier* pointing to the qualifier found (not a copy) or NULL if
//          not found.
//
//*****************************************************************************
//
//  static GetQualifierLocally
//
//  Tries to find a qualifier with a given name.
//
//  Parameters:
//
//      LPMEMORY pData      Points to the set's memory block.
//      CFastHeap* pHeap    Where the extra data (including qualifier names)
//                          is kept.
//  Parameters I:
//      LPCWSTR wszName     The name of the qualifier to find.
//      int& nKnownIndex    (Optional). If provided, the function will place
//                          the well-known index of the name here, or 
//                          -1 if not found.
//  Parameters II:
//      CCompressedString* pcsName  The name of the qualifier as a compressed
//                          string. Such a name cannot be well-known (see
//                          string storage on the heap in fastheap.h).
//  Returns:
//
//      CQualifier* pointing to the qualifier found (not a copy) or NULL if
//          not found.
//
//*****************************************************************************
//
//  static IsValidQualifierType
//
//  Not every VARIANT type can server as the type of a qualifier. This function
//  verifies if a given VARIANT type is valid for a qualifier.
//
//  Parameters:
//
//      VARTYPE vt      The type to check.
//
//  Returns:
//
//      BOOL    TRUE iff valid.
//
//*****************************************************************************
//
//  static SetDataToNone
//
//  Empties the qualifier set in a given memory block.
//
//  Parameters:
//
//      LPMEMORY pBlock     The memory block of the qualifier set.
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty qualifier set on a given memory block and returns the
//  pointer to the first byte after it.
//
//  Parameters:
//
//      LPMEMORY pBlock     The memory block of the qualifier set.
//
//  Returns:
//
//      LPMEMORY
//
//*****************************************************************************
//
//  static Delete
//
//  Frees any data that this qualifier set may have on the heap (names, values)
//
//  Parameters:
//
//      LPMEMORY pBlock     The memory block of the qualifier set.
//      CFastHeap* pHeap    The heap where this qualifier set keep extra data.
//
//*****************************************************************************
//
//  static ComputeNecessarySpaceForPropagation
//
//  As described in CQualifierFlavor, only some qualifiers propagate and only
//  to some destinations. This function computes the amount of space that
//  a propagated copy of this set will take.
//
//  Parameters:
//
//      LPMEMORY pBlock         The memory block of the qualifier set.
//      BYTE byPropagationFlag  Identifies the target of the propagation. If
//                              we are propagating to a derived class, it will
//                              be WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS.
//                              If we are propagating to an instance, it will
//                              be WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCES.
//  Returns:
//
//      length_t:   the number of bytes necessary for the propagated set.
//
//*****************************************************************************
//
//  static WritePropagatedVersion
//
//  Creates a propagated version of a qualifier set based on the propagation
//  flag (as described in ComputeNecessarySpaceForPropagation). The memory is 
//  assumed to be already allocated and large enough.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to the memory block
//                              of the set to propagate. Since the C value of
//                              this pointer may change while we are writing,
//                              due to object reallocation, we must use source
//                              (see fastsprt.h).
//      BYTE byPropagationFlag  The flag describing who we are propagating to
//                              (as descrined in 
//                              ComputeNecessarySpaceForPropagation)
//      CPtrSource* pDest       The source fot the pointer to the destination
//                              memory block.
//      CFastHeap* pOldHeap     The heap where the original qualifier set keeps
//                              extra data.
//      CFastHeap* pNewHeap     The heap where the new qualifier set should 
//                              place extra data.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  Moves whatever data this qualifier set keeps on the heap to a new heap.
//  The data is NOT deleted from the old heap.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to the memory block
//                              of the qualifier set to translate.
//      CFastHeap* pOldHeap     The heap where the qualifier set keeps its data
//                              currently.
//      CFastHeap* pNewHeap     The heap to which the data should be moved.
//
//*****************************************************************************
//
//  static ComputeMergeSpace
//
//  Computes the amount of space required to merge to qualifier sets. The 
//  sets being merged are the "parent" set and the "child" set. For instance,
//  this could be the qualifier set for a property of a class and the qualfier
//  set for that property in a derived class of that class. The merge then 
//  takes all the propagated qualifiers from the parent and the qualifiers
//  in the child and merges them, giving priority the the child.
//
//  NOTE: this function is only applied for classes and their children, not
//  instances. Instances do not merge their qualifier sets with the classes ---
//  they keep them separate and perform to separate lookups.
//
//  Parameters:
//
//      LPMEMORY pParentSet     The memory block of the parent set.
//      CFastHeap* pParentHeap  The heap where the parent set keeps its data.
//      LPMEMORY pChildSet      The memory block of the child set.
//      CFastHeap* pChildHeap   The heap where the child set keeps its data.
//      BOOL bCheckValidity     If TRUE, the function will check that the child
//                              does not violate permissions in overriding
//                              parent's qualifiers. Normally, this is not
//                              necessary, as the check is performed when the
//                              qualifier is added.
//  Returns:
//
//      length_t:   the number of bytes that the merged set will take. This
//                  number is precise, not an estimate.
//
//*****************************************************************************
//
//  static Merge
//
//  Merges a parent's and a child's qualifier sets. See ComputeMergeSpace above
//  for details on this operation. It is assumed that there is:
//
//  1) Enough space at the destination to contain the qualifier set.
//  2) MOST IMPORTANTLY, enough space on the destination heap to contain all
//      the qualifier set data, so that no reallocations will occur.
//  
//  Parameters:
//
//      LPMEMORY pParentSet     The memory block of the parent set.
//      CFastHeap* pParentHeap  The heap where the parent set keeps its data.
//      LPMEMORY pChildSet      The memory block of the child set.
//      CFastHeap* pChildHeap   The heap where the child set keeps its data.
//      LPMEMORY pDestSet       The memory block of the destination set.
//      CFastHeap* pDestHeap    The heap where the destination set should
//                              keep its data.
//      BOOL bCheckValidity     If TRUE, the function will check that the child
//                              does not violate permissions in overriding
//                              parent's qualifiers. Normally, this is not
//                              necessary, as the check is performed when the
//                              qualifier is added.
//
//*****************************************************************************
//
//  static ComputeUnmergeSpace
//
//  As described above, qualifier sets for classes and their parents are merged
//  together. Then, when it is time to change the (modified) version of the
//  child class back, it needs to be unmerged, i.e., we need to obtain just the
//  qualifiers that are new or overriden in the child.
//
//  ComputeUnmergeSpace calculates how much space is needed to represent the
//  result of such an unmerge
//
//  Parameters:
//
//      LPMEMORY pMergedSet     The memory block of the merged qualifier set.
//
//  Returns:
//
//      length_t: the number of bytes required to store the unmerge.
//
//*****************************************************************************
//
//  static Unmerge
//
//  Unmerges the child's part form the merged set, as described in 
//  ComputeUnmergeSpace. This function assumes that there is:
//
//  1) Enough space at the destination to contain the qualifier set.
//  2) MOST IMPORTANTLY, enough space on the destination heap to contain all
//      the qualifier set data, so that no reallocations will occur.
//
//  Parameters:
//
//      LPMEMORY pMergedData        The memory block of the merged set
//      CFastHeap* pMergedHeap      The heap where the merge keeps its data.
//      LPMEMORY pDestData          The destination memory block.
//      CFastHeap* pDestHeap        The heap where the data should be placed.
//
//*****************************************************************************
//
//  static HasLocalQualifiers
//
//  Checks if a qualifier set has any local or overriden qualifiers, i.e., if
//  there is anything new in it as compared to the parent.
//
//  Parameters:
//
//      LPMEMORY pMergedData        The memory block of the merged set.
//
//  Returns:
//
//      BOOL        TRUE iff it has local or overriden qualifiers.
//
//*****************************************************************************
//
//  GetText
//
//  Produces the MOF representation of a given qualifier set.
//
//  Parameters:
//
//      LPMEMORY pData          The memory block of the qualifier set.
//      CFastHeap* pHeap        The heap where it keeps its data.
//      long lFlags             The flags. 
//      WString& wsText         The destination for the textual representation.
//
//*****************************************************************************
//***************************** Dynamic methods *******************************
//
//  Non-static methods of CBasicQualifierSet rely (of course) on the data
//  members. The members are:
//
//  length_t m_nLength          The length of the block.
//  CQualifier* m_pOthers       Points to the firsyt qualifier in the list.
//  CFastHeap* m_pHeap          The heap where the extra data is kept.
//
//  Many of the non-static methods simply call static methods providing the
//  information taken from the member variables. We do not document them, as
//  they are analagous to the static ones. Here is the list of such methods:
//
//  GetStart, GetLength, GetFirstQualifier, Skip, GetHeap, GetText
//  GetRegularQualifierLocally, GetKnownQualifierLocaly, GetQualifierLocally
//  
//*****************************************************************************
//
//  SetData
//
//  Sets up the internal members given the location of the memory block
//
//  Parameters:
//
//      LPMEMORY pStart     The start of the memory block of the set.
//      CFastHeap* pHeap    The heap where this set keeps its data.
//
//*****************************************************************************
//
//  IncrementLength
//
//  Increments the stored length of the qualifier set block both in the member
//  variable and in the block itself.
//
//  Parameters:
//
//      lenght_t nIncrement in bytes
//
//*****************************************************************************
//
//  Rebase
//
//  Updates internal variables when the memory block has moved.
//
//  Parameters:
//
//      LPMEMORY pNewMemory     The new location of the memory block.
//
//*****************************************************************************
//
//  GetNumUpperBound
//
//  A quick way to get an upper boun don the number of qualifiers in the set
//  without traversing it.
//
//  Returns:
//
//      int:    >= the numbed of qualifiers.
//
//*****************************************************************************
//
//  EnumPrimaryQualifiers.
//
//  Given enumeration flags and a flavor mask (below), creates to arrays of
//  qualifier names: those that match the criteria and those that do not.
//
//  Parameters:
//
//      BYTE eFlags                         The flags for enumeration. Can be:
//                                          WBEM_FLAG_LOCAL_ONLY:
//                                              only the qualifiers defined or
//                                              overriden in this set.
//                                          WBEM_FLAG_PROPAGATED_ONLY:
//                                              only the qualifiers inherited
//                                              from the parent (and not
//                                              overriden).
//                                          Any other value:
//                                              no restriction.
//      BYTE fFlavorMask                    Any bit that is set in fFlavorMask
//                                          must be set in the flavor of a 
//                                          qualifier, or it does not match.
//      CFixedBSTRArray& astrMatching       Destination for the names of the
//                                          matching qualifiers. Must not be
//                                          initialized (Create'ed)
//      CFixedBSTRArray& astrNotMatching    Destination for the names of the
//                                          nonmatching qualifiers. Must not be
//                                          initialized (Create'ed)
//
//*****************************************************************************
//
//  CanBeReconciledWith.
//
//  Compares this qualifier set to another one.  Checking whether differences
//	can be reconciled or not.
//
//  Parameters:
//		CBasicQualifierSet& qsThat			Qualifier set to reconcile with.
//
//*****************************************************************************
//
//  Compare.
//
//  Compares this qualifier set to another one, filtering out names if specified.
//
//  Parameters:
//		CBasicQualifierSet& qsThat			Qualifier set to compare to.
//      BYTE eFlags                         The flags for enumeration. Can be:
//                                          WBEM_FLAG_LOCAL_ONLY:
//                                              only the qualifiers defined or
//                                              overriden in this set.
//                                          WBEM_FLAG_PROPAGATED_ONLY:
//                                              only the qualifiers inherited
//                                              from the parent (and not
//                                              overriden).
//                                          Any other value:
//                                              no restriction.
//		LPCWSTR* ppFilters					Names of properties to filter out of
//											comparison.  For example, __UPDATE_CONFLICT
//											qualifiers are informational only and should
//											not cause matching operations to fail.
//		DWORD dwNumFilters					Number of filters in array
//
//*****************************************************************************
//
//  CompareLocalizedSet.
//
//  Compares this qualifier set to another one.  It uses the Compare() function
//	above, but precreates a filter list of all amended qualifiers as well as
//	"amendmendt" and "locale" i.e. all localization qualifiers.
//
//  Parameters:
//		CBasicQualifierSet& qsThat			Qualifier set to compare to.
//
//*****************************************************************************

class COREPROX_POLARITY CBasicQualifierSet
{
    //*************** Static part **************************
protected:
     static void SetDataLength(LPMEMORY pStart, length_t nLength)
        {*(PLENGTHT)pStart = nLength;}
public:
     static length_t GetMinLength() {return sizeof(length_t);}
     static length_t GetLengthFromData(LPMEMORY pData)
        {return *(PLENGTHT)pData;}
     static BOOL IsEmpty(LPMEMORY pData) 
        {return GetLengthFromData(pData) == GetMinLength();}
     static CQualifier* GetFirstQualifierFromData(LPMEMORY pData)
        {return (CQualifier*)(pData + GetMinLength());}
public:
    static  INTERNAL CQualifier* GetRegularQualifierLocally(
                    LPMEMORY pData, CFastHeap* pHeap, LPCWSTR wszName);
    static  INTERNAL CQualifier* GetKnownQualifierLocally(
                        LPMEMORY pStart, int nStringIndex);
    static  INTERNAL CQualifier* GetQualifierLocally(
                    LPMEMORY pStart, CFastHeap* pHeap, LPCWSTR wszName,
                    int& nKnownIndex);
    static  INTERNAL CQualifier* GetQualifierLocally(
                    LPMEMORY pStart, CFastHeap* pHeap,  LPCWSTR wszName)
    {
        int nKnownIndex;
        return GetQualifierLocally(pStart, pHeap, wszName, nKnownIndex);
    }
    static  INTERNAL CQualifier* GetQualifierLocally(LPMEMORY pStart, 
        CFastHeap* pHeap, CCompressedString* pcsName);

    static  BOOL IsValidQualifierType(VARTYPE vt);
        
public:
    
     static void SetDataToNone(LPMEMORY pData)
        {*(PLENGTHT)pData = sizeof(length_t);}
     static LPMEMORY CreateEmpty(LPMEMORY pStart)
        {SetDataToNone(pStart); return pStart + sizeof(length_t);}

     static void Delete(LPMEMORY pData, CFastHeap* pHeap);

    static length_t ComputeNecessarySpaceForPropagation(
        LPMEMORY pStart, BYTE byPropagationFlag);

    static LPMEMORY WritePropagatedVersion(CPtrSource* pThis,
        BYTE byPropagationFlag, CPtrSource* pDest,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap);

    static BOOL TranslateToNewHeap(CPtrSource* pThis, 
        CFastHeap* pOldHeap, CFastHeap* pNewHeap);

    static length_t ComputeMergeSpace(
                               READ_ONLY LPMEMORY pParentSetData,
                               READ_ONLY CFastHeap* pParentHeap,
                               READ_ONLY LPMEMORY pChildSetData,
                               READ_ONLY CFastHeap* pChildHeap,
                               BOOL bCheckValidity = FALSE);
    static LPMEMORY Merge(
                          READ_ONLY LPMEMORY pParentSetData,
                          READ_ONLY CFastHeap* pParentHeap,
                          READ_ONLY LPMEMORY pChildSetData,
                          READ_ONLY CFastHeap* pChildHeap,
                          NEW_OBJECT LPMEMORY pDest, 
                          MODIFY CFastHeap* pNewHeap,
                          BOOL bCheckValidity = FALSE);

    static length_t ComputeUnmergedSpace(
                          READ_ONLY LPMEMORY pMergedData);

    static  BOOL HasLocalQualifiers(
                          READ_ONLY LPMEMORY pMergedData)
    {
        return ComputeUnmergedSpace(pMergedData) != GetMinLength();
    }
                        
    static LPMEMORY Unmerge(
                          READ_ONLY LPMEMORY pMergedData,
                          READ_ONLY CFastHeap* pMergedHeap,
                          NEW_OBJECT LPMEMORY pDest,
                          MODIFY CFastHeap* pNewHeap);

    static HRESULT GetText(READ_ONLY LPMEMORY pData, READ_ONLY CFastHeap* pHeap,
        long lFlags, NEW_OBJECT OUT WString& wsText);

    //************************** Dynamic part ************************
protected:
    length_t m_nLength;
    CQualifier* m_pOthers;

    CFastHeap* m_pHeap;

public:
    CBasicQualifierSet(){}
    ~CBasicQualifierSet(){}

     void SetData(LPMEMORY pStart, CFastHeap* pHeap)
    {
        m_nLength = *(PLENGTHT)pStart;
        m_pOthers = (CQualifier*)(pStart + sizeof(length_t));
        m_pHeap = pHeap;
    }

     LPMEMORY GetStart() {return LPMEMORY(m_pOthers) - sizeof(length_t);}
     length_t GetLength() {return m_nLength;}
     BOOL IsEmpty() {return m_nLength == sizeof(length_t);}
     CQualifier* GetFirstQualifier() {return m_pOthers;}
     LPMEMORY Skip() {return GetStart() + m_nLength;}
     void IncrementLength(length_t nIncrement)
    {
        m_nLength += nIncrement;
        *(PLENGTHT)GetStart() = m_nLength;
    }

     void Rebase(LPMEMORY pNewMemory)
    {
        m_pOthers = (CQualifier*)(pNewMemory + sizeof(length_t));
    }

    CFastHeap* GetHeap() {return m_pHeap;}
public:
     int GetNumUpperBound()
        {return m_nLength / CQualifier::GetHeaderLength();}

     INTERNAL CQualifier* GetRegularQualifierLocally(LPCWSTR wszName)
    {
        return GetRegularQualifierLocally(GetStart(), m_pHeap, wszName);
    }
     INTERNAL CQualifier* GetKnownQualifierLocally(int nStringIndex)
        {return GetKnownQualifierLocally(GetStart(), nStringIndex); }

     INTERNAL CQualifier* GetQualifierLocally(LPCWSTR wszName,
                                                  int& nKnownIndex)
    {
        return GetQualifierLocally(GetStart(), m_pHeap, wszName, nKnownIndex);
    }

     INTERNAL CQualifier* GetQualifierLocally(LPCWSTR wszName)
        {int nKnownIndex; return GetQualifierLocally(wszName, nKnownIndex);}

     INTERNAL CQualifier* GetQualifierLocally(CCompressedString* pcsName)
        {return GetQualifierLocally(GetStart(), GetHeap(), pcsName);}


    HRESULT EnumPrimaryQualifiers(BYTE eFlags, BYTE fFlavorMask, 
        CFixedBSTRArray& aMatching, CFixedBSTRArray& aNotMatching);

     HRESULT GetText(long lFlags, NEW_OBJECT OUT WString& wsText)
        { return GetText(GetStart(), GetHeap(), lFlags, wsText);}

	 BOOL Compare( CBasicQualifierSet& qsThat, BYTE eFlags,
			LPCWSTR* ppFilters = NULL, DWORD dwNumFilters = 0 );

	BOOL CompareLocalizedSet( CBasicQualifierSet& qsThat );

	 BOOL CanBeReconciledWith( CBasicQualifierSet& qsThat );

	 HRESULT IsValidQualifierSet( void );

};

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierSetContainer
//
//  Defines the functionality that a class containing a qualifier set must
//  implement. These classes are CClassPart, CInstancePart, and specialized
//  containers CClassPQSContainer and CInstancePQSContainer defined below.
//
//*****************************************************************************
//
//  PURE GetHeap
//
//  Returns:
//
//      CFastHeap*: the heap that the qualifier set should use.
//
//*****************************************************************************
//
//  GetWbemObjectUnknown
//
//  Returns:
//
//      IUnknown*:   pointer to the IUnknown of the CWbemObject containing the 
//              qualifier set. We need it since qualifier sets are themselves
//              COM objects, but they need to ensure that the containing 
//              CWbemObject survives as long as they do, and so they must
//              propagate their AddRef's and Release's to the CWbemObject.
//
//*****************************************************************************
//
//  GetQualifierSetStart
//
//  Returns:
//
//      LPMEMORY;   The pointer to the memory block of the qualifier set.
//                  Note that the value of this pointer may change even as the
//                  qualifier set remains active due to object reallocations.
//
//*****************************************************************************
//
//  CanContainKey
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain a 'key' 
//              qualifier. Only class property qualifier sets are allowed to
//              do so, and then only those of approved key types.
//
//*****************************************************************************
//
//  CanContainSingleton
//
//  Whether it is legal for this qualifier set to contain a 'singleton' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain a 'singelton' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from keyed classes.
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************
//
//  ExtendQualifierSetSpace
//
//  Qualifier set calls this method to request that its memory block be
//  extended. The container must comply and either make room at the end of the
//  qualifier set's curent block, or reallocate the set to another location.
//  In the latter case, the container must copy the set's data and call Rebase
//  on the set before returning from this call.
//
//  Parameters:
//
//      CBasicQualifierSet* pSet    Identifies the qualifier set making the
//                                  request.
//      length_t nNewLength         The required length of the memory block.
//
//  Returns:
//
//      void: there is no out-of-memory handling.
//
//*****************************************************************************
//
//  ReduceQualifierSetSpace
//
//  Qualifier set calls this method to inform the container that it no longer
//  needs as much room as it currently has. The container may NOT move the
//  set's memory block in response to this call. 
//
//  Parameters:
//
//      CBasicQualifierSet* pSet    Identifies the qualifier set making the
//                                  request.
//      length_t nDecrement         How much memory is being returned.
//
//*****************************************************************************

class COREPROX_POLARITY CQualifierSetContainer
{
public:
    virtual CFastHeap* GetHeap() = 0;
    virtual IUnknown* GetWbemObjectUnknown() = 0;
    virtual LPMEMORY GetQualifierSetStart() = 0;
    virtual BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet, 
        length_t nNewLength) = 0;
    virtual void ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement) = 0;
    virtual HRESULT CanContainKey() = 0;
    virtual HRESULT CanContainSingleton() = 0;
    virtual HRESULT CanContainAbstract( BOOL fValue ) = 0;
    virtual HRESULT CanContainDynamic() = 0;
    virtual BOOL CanHaveCimtype(LPCWSTR wszCimtype) = 0;
};

class IExtendedQualifierSet : public IWbemQualifierSet
{
public:
    STDMETHOD(CompareTo)(long lFlags, IWbemQualifierSet* pOther) = 0;
};

// qualifier used to indicate conflicts during updates
// Prefixed by double underscore so it can't be added by
// "just anyone"
#define UPDATE_QUALIFIER_CONFLICT L"__UPDATE_QUALIFIER_CONFLICT"

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierSet
//
//  The real full-blown qualifier set. The most important distinctions from
//  CBasicQualifierSet is that it is cognisant of:
//  1) Its container, which allows it to request more space and thus enables
//      it to perform qualifier addition and deletion related operations.
//  2) Its parent set. For classes, it is the corresponding qualifier set of
//      its parent class. For instance, that of its class. This allows this
//      object to properly obtain propagated qualifiers. See below for
//      class/instance distinctions in handling.
//
//  Qualifier propagation happens in two contexts: from parent class to child
//  class and from class to instance. The mechanisms used in these cases are
//  quite different. In the case of a class, the qualifier sets of the parent
//  and the child are merged (see CBasicQualifierSet::Merge) to produce the
//  qualifier set actually used in the child. For instances, however, they are
//  not merged, thus cutting down the loading and saving time of instances
//  quite significantly (instance data is loaded from disk into memory without
//  any modifications whasoever).
//
//  However, both instance and class qualifier sets need to have a pointer to 
//  their "parent"'s qualifier set in order to function properly. Instances 
//  need this pointer to perform every operation --- even qualifier lookup 
//  needs to happen in both the child and the parent sets. 
//
//  Classes need this pointer only during delete operations: if a qualifier is
//  deleted from the child class, it is possible that the parent's qualifier 
//  which was overriden by the deletee needs to be brought in, since it is now
//  unmasked.
//  
//  Note, that the parent qualifier set has two nice features: it has no 
//  relevant parent itself, and it cannot change. Thus, CBasicQualifierSet is
//  perfectly sufficient to represent it.
//
//  In order to describe the relation between this set and the parent set
//  CQualifierSet uses a template parameter m_nPropagationFlag, which will be
//  WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS for child class-parent class 
//  relations and WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE for instance-class
//  relations. 
//
//  The extra difficulty in qualifier sets is that they must exist as stand-
//  alone COM objects. For that and other reasons, they cannot be successfully
//  rebased by their containing CWbemObject every time the object itself is
//  reallocated (this is the case for property qualifier sets). Thus, 
//  qualifier sets always rebase themselves to the new memory block available
//  from their container every time they service a COM call.
//
//*****************************************************************************
//
//  SetData
//
//  Sets up internal members given the initial information about the location
//  of the qualifier set.
//
//  Parameters:
//
//      LPMEMORY pStart                     The qualifier set's memory block.
//      CQualifierSetContainer* pContainer  The container pointer.
//      CBasicQualifierSet* pSecondarySet   The parent qualifier set.
//
//*****************************************************************************
//
//  SelfRebase
//
//  Gets its (new) memory block location from its container and rebases itself
//  to this new block. Done at the beginning of every COM interface call.
//
//*****************************************************************************
//
//  IsComplete
//
//  Returns:
//
//      BOOL:   TRUE iff this qualifier set is "complete" without its parent
//              set. As described in the header, this is true for class sets
//              but not for instance sets.
//
//*****************************************************************************
//
//  GetQualifier
//
//  The ultimate qualifier reader. It will look for the qualifier in the 
//  primary set and, if that is not complete, in the parent set as well 
//  (subject to propagation rules).
//
//  Parameters:
//
//      LPCWSTR wszName     The name of the qualifier to get.
//      BOOL& bLocal        (Optional) If provided, it is set to TRUE if the
//                          qualifier is local ((re)defined in the primary set)
//  Returns:
//
//      CQualifier*:    the pointer to the qualifier or NULL if not found. This
//                      pointer is of course TEMPORARY subject to object 
//                      relocation.
//
//*****************************************************************************
//
//  SetQualifierValue
//
//  Adds a qualifier to the set or changes the value of the qualifier that
//  already exists. The parent set is checked (if appropriate) for permissions.
//  
//  Parameters:
//
//      LPCWSTR wszName         The name of the qualifier to set.
//      BYTE fFlavor            The flavor to assign. Does not check the flavor
//                              for legality.
//      CTypedValue* pValue     The new value of the qualifier. If this value
//                              contains extra data (string, array), it must
//                              be on the heap of this qualifier set.
//      BOOL bCheckPermissions  If TRUE and the qualifier exists in the parent
//                              set, the parent's flavor is checked for
//                              override protection.
//		BOOL fValidateName		If TRUE, we will make sure the name is valid, if
//								FALSE, we don't.  The main reasone we do this
//								is because we may need to add system qualifiers
//								that we don't want a user to have access to.
//  Returns:
//
//      WBEM_NO_ERROR                On Success
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  DeleteQualifier
//
//  Deletes a qualifier from the set. 
//
//  Parameters:
//
//      LPCWSTR wszName         The name of the qualifier to delete.
//      BOOL bCheckPermissions  If TRUE, checks if the qualifier is actually
//                              a parent's qualifier propagated to us. (In this
//                              case it cannot be deleted).
//  Returns:
//
//      WBEM_NO_ERROR                The qualifier was deleted.
//      WBEM_S_NOT_FOUND             The qualifier was not there. This is a 
//                                  success value
//      WBEM_E_PROPAGATED_QUALIFIER  It is our parent's qualifier and therefore
//                                  cannot be deleted.
//      WBEM_S_NOT_FOUND             Qualifier not found
//
//*****************************************************************************
//
//  EnumQualifiers
//
//  This function is used for qualifier enumeration. It creates a list of names
//  of all the qualifiers (local or propagated) matching certain criteria. Both
//  the criteria identified by eFlags and that identified by fFlavorMask must
//  be satisfied for a qualifier to be included.
//
//  Paramaters:
//
//      [in] BYTE eFlags                Can be 0 (no restriction) or 
//                                      WBEM_FLAG_LOCAL_ONLY or 
//                                      WBEM_FLAG_PROPAGATED_ONLY
//      [in] BYTE fFlavorMask           Can be 0 (no restriction) or any 
//                                      combination of:
//                                      WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,
//                                      WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
//                                      in which case those flavor bits must be
//                                      prtesent in the qualifier's flavor.
//      [out] CFixedBSTRArray& aNames   Destination for the array (see
//                                      faststr.h for definitions).
//
//*****************************************************************************
//
//  operator ==()
//
//  This function is used check if two qualifier sets are equal.  To be
//	equal, there must be an equivalent number of parameters, the names
//	must be the same (and in the same order), and the values must be the
//	same
//
//  Parameters:
//
//      [in] CQualifierSet& qualifierset	Qualifier set to compare to.
//
//*****************************************************************************
//
//  Compare
//
//  This function is used check if two qualifier sets are equal as indicated
//	by the == function, however in this case, a caller can specify an array
//	of names which can be safely ignored during the comparison.
//
//  Parameters:
//
//      [in] CQualifierSet& qualifierset	Qualifier set to compare to.
//		[in] CFixedBSTRArray* paExcludeNames Array of names we can exclude
//												during the comparison.	
//		[in] BOOL fCheckOrder - Check the order of the data in the qualifier
//								set.
//
//*****************************************************************************
//
//  Update
//
//  This function is used when we are updating a class, and need to update
//	qualifier sets of derived classes and their properties, methods, etc.
//	In force mode, it will handle conflicts via the AddQualifierConflict
//	function.
//
//  Parameters:
//      [in] CBasicQualifierSet& childSet	original qualifier set.
//		[in] long lFlags - Flags for update (must indicate SAFE or FORCE mode)
//		[in] CFixedBSTRArray* paExcludeNames Array of names we can exclude
//												during the update.	
//
//*****************************************************************************
//
//  StoreQualifierConflict
//
//  This function is used when during an update, we encounter a conflict.  Since
//	a set may contain multiple conflicts, we will store them in a single array
//	then add them en masse.
//
//  Parameters:
//		[in] LPCWSTR pwcsName - Name of the qualifier with which we had a conflict.
//		[in] CVar& value - Value for the qualifier with which we had a conflict.
//		[in] CQualifierFlavor& flavor - falue for the qualifier with which we had
//										a conflict.
//		[in,out] CVerVector& vectorConflicts - Array of qualifier conflicts.
//
//*****************************************************************************
//
//  AddQualifierConflicts
//
//  This function is used when during an update, we encounter a conflict.  In
//	this case, we will add an "__UPDATE_QUALIFIER_CONFLICT" qualifier and store
//	the name, value and flavors for which we encountered the conflict.  Note that
//	we will preserve any preexisting values as necessary.
//
//  Parameters:
//		[in] CVarVector& vectorConflicts - Array of conflict descriptions.
//
//*****************************************************************************
//
//  CopyLocalQualifiers
//
//  This function is used when we want to copy local qualifiers from one set
//	to another.  This assumes we will be able to gro heaps, do fixups and
//	all that other lovely stuff.
//
//  Parameters:
//		[in] CQualifierSet&	qsSourceSet - Source Qualifier Set
//
//*****************************************************************************
//
//  GetQualifier
//
//  Reads local and propagated qualifiers and retrieves values to boot.
//
//  Parameters:
//
//      LPCWSTR wszName     The name of the qualifier to get.
//      long*	plFlavor	(optional) returns the flavor
//		CVar*	pVal		(optional) returns the value
//  Returns:
//
//      WBEM_S_NO_ERROR if success.
//
//*****************************************************************************
//**************************** IUnknown interface *****************************
//
//  CQualifierSet has its own reference count, but since it is a part of an
//  WbemObject, it needs to ensure that the containing object hangs around for
//  at least as long as the qualifier set does. Thus, in addition to keeping
//  its own reference count, the qualifier set forwards AddRef and Release 
//  calls to the containing object.
//
//*****************************************************************************
//************************ IWbemQualifierSet interface *************************
//
//  Documented in help file 
//
//*****************************************************************************
#pragma warning(disable: 4275)

class COREPROX_POLARITY CQualifierSet : public CBasicQualifierSet, 
					  public IExtendedQualifierSet
{
protected:
    int m_nPropagationFlag; // a template parameter, really

    long m_nRef;
    IUnknown* m_pControl;

    CQualifierSetContainer* m_pContainer;
    CBasicQualifierSet* m_pSecondarySet;

    CFixedBSTRArray m_astrCurrentNames;
    int m_nCurrentIndex;

	// Handling for qualifier conflicts during update operations
	HRESULT AddQualifierConflicts( CVarVector& vectorConflicts );
	HRESULT StoreQualifierConflicts( LPCWSTR pwcsName, CVar& value,
				CQualifierFlavor& flavor, CVarVector& vectorConflicts );

public:
    CQualifierSet(int nPropagationFlag, int nStartRef = 0);
    virtual ~CQualifierSet();

     void SetData(LPMEMORY pStart, 
        CQualifierSetContainer* pContainer, 
        CBasicQualifierSet* pSecondarySet = NULL)
    {
        CBasicQualifierSet::SetData(pStart, pContainer->GetHeap());

        m_pContainer = pContainer;
        m_pSecondarySet = pSecondarySet;
        m_pControl = pContainer->GetWbemObjectUnknown();
    }

     BOOL SelfRebase()
    {
        LPMEMORY pStart = m_pContainer->GetQualifierSetStart();
        if(pStart == NULL) return FALSE;
        Rebase(pStart);
        return TRUE;
    }

     BOOL IsComplete() 
    {
        return (m_nPropagationFlag == 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);
    }
                                                         
     CQualifier* GetQualifier(READ_ONLY LPCWSTR wszName, 
                                    OUT BOOL& bLocal);
     CQualifier* GetQualifier(READ_ONLY LPCWSTR wszName)
    {
        BOOL bLocal; 
        return GetQualifier(wszName, bLocal);
    }

    HRESULT SetQualifierValue(COPY LPCWSTR wszName, 
                                     BYTE fFlavor,
                                     COPY CTypedValue* pNewValue,
                                     BOOL bCheckPermissions,
									 BOOL fValidateName = TRUE);

    HRESULT ValidateSet(COPY LPCWSTR wszName, 
                                     BYTE fFlavor,
                                     COPY CTypedValue* pNewValue,
                                     BOOL bCheckPermissions,
									 BOOL fValidateName = TRUE);

    HRESULT DeleteQualifier(READ_ONLY LPCWSTR wszName,
                                   BOOL bCheckPermissions);

    HRESULT EnumQualifiers(BYTE eFlags, BYTE fFlavorMask, 
        CFixedBSTRArray& aNames);

	BOOL operator ==( CQualifierSet& qualifierset )	{ return Compare( qualifierset ); }
	BOOL Compare( CQualifierSet& qualifierset, CFixedBSTRArray* paExcludeNames = NULL, BOOL fCheckOrder = TRUE );

	// Updates 'this' qualifier set from the memory block of the supplied
	// basic qualifer set.

	HRESULT Update( CBasicQualifierSet& childSet, long lFlags, CFixedBSTRArray* paExcludeNames = NULL );

	HRESULT CopyLocalQualifiers( CQualifierSet& qsSource );

	// Helper function to retrieve qualifiers from the set.
	HRESULT GetQualifier( LPCWSTR pwszName, CVar* pVar, long* plFlavor, CIMTYPE* pct = NULL );

	// Helper function to retrieve qualifiers from the set as typed values
	HRESULT GetQualifier( LPCWSTR pwszName, long* plFlavor, CTypedValue* pTypedValue, CFastHeap** ppHeap,
						BOOL fValidateSet );

public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj)
    {
        if(riid == IID_IWbemQualifierSet || riid == IID_IUnknown)
        {
            AddRef();
            *ppvObj = (void*)(IWbemQualifierSet*)this;
            return S_OK;
        }
        else return E_NOINTERFACE;
    }
    STDMETHOD_(ULONG, AddRef)(){ InterlockedIncrement( &m_nRef ); return m_pControl->AddRef();}
    STDMETHOD_(ULONG, Release)()
    {
		long lRef = InterlockedDecrement( &m_nRef );
        m_pControl->Release();
        if( lRef == 0)
        {
            delete this;
            return 0;
        }
        else return lRef;
    }

    /* IWbemQualifierSet methods */

    HRESULT STDMETHODCALLTYPE Get( 
        LPCWSTR Name,
        LONG lFlags,
        VARIANT *pVal,
        LONG *plFlavor);
    
    HRESULT STDMETHODCALLTYPE Put( 
        LPCWSTR Name,
        VARIANT *pVal,
        LONG lFlavor);
    
    HRESULT STDMETHODCALLTYPE Delete( 
        LPCWSTR Name);
    
    HRESULT STDMETHODCALLTYPE GetNames( 
        LONG lFlavor,
        LPSAFEARRAY *pNames);
    
    HRESULT STDMETHODCALLTYPE BeginEnumeration(LONG lFlags);
    
    HRESULT STDMETHODCALLTYPE Next( 
        LONG lFlags,
        BSTR *pName,
        VARIANT *pVal,
        LONG *plFlavor);

    HRESULT STDMETHODCALLTYPE EndEnumeration();

	// extra
    STDMETHOD(CompareTo)(long lFlags, IWbemQualifierSet* pOther);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierSetListContainer
//
//  This pure abstract class defines the functionality required of objects 
//  whose memory block contains that of a qualifier set list (see 
//  CQualifierSetList below).
//
//*****************************************************************************
//
//  GetHeap
//
//  Returns the pointer to the CFastHeap on which the qualifiers should store
//  their variable-sized data (like strings).
//
//  Returns:
//
//      CFastHeap*
//
//*****************************************************************************
//
//  ExtendQualifierSetListspace
//
//  Requests that the size of the memory block alloted for the list be
//  increased. If the container cannot accomplish that without moving the 
//  memory block, it must call Rebase on the List.
//
//  Parameters:
//
//      LPMEMORY pOld           Pointer to the current memory block.
//      length_t nOldLength     Current length of the block.
//      length_t nNewLength     Required length of the block.
//
//  No out-of-memory conditions are supported.
//
//*****************************************************************************
//
//  ReduceQualifierSetListSpace
//
//  Requests that the size of the memory block alloted for this list be reduced
//  The container may NOT move the object's memory block during this operation.
//
//  Parameters:
//
//      LPMEMORY pOld           Current memory block start address
//      length_t nOldLength     Current length of the block
//      length_t nDecrement     How much space to return to the container.
//
//*****************************************************************************
//  
//  GetQualifierSetListStart
//
//  Self-rebasing function. Since the location of the memory block of the list 
//  can change between calls, the list will want to ask the container to point
//  to the current location of the block in the beginning of certain calls.
//
//  Returns:
//
//      LPMEMORY    Current location of the memory block.
//
//*****************************************************************************
//
//  GetWbemObjectUnknown
//
//  Since (as described in IUnknown implementation help above) qualifier sets
//  need to link their reference counts with those of the containing WbemObject,
//  this function is used by the list to obtain the location of the WbemObject's
//  reference count.
//
//  Returns:
//
//      IUnknown*    location of the main object's ref count.
//
//*****************************************************************************

class COREPROX_POLARITY CQualifierSetListContainer
{
public:
    virtual CFastHeap* GetHeap() = 0;
    virtual BOOL ExtendQualifierSetListSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nNewLength) = 0;
    virtual void ReduceQualifierSetListSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nDecrement) = 0;
    virtual LPMEMORY GetQualifierSetListStart() = 0;
    virtual IUnknown* GetWbemObjectUnknown() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierSetList
//
//  This class represents a list of a fixed number of qualifier set. It is
//  used by WBEM instances (CWbemInstance) to represent instance property
//  qualifier sets. The storage model is optimized for the case where no 
//  instance property qualifiers are present (which is most of the time). 
//
//  The layout of the memory block for the list is as follows.
//  It starts with one BYTE which can be either QSL_FLAG_NO_SETS, in which case
//  that's the end of it, or QSL_FLAG_PRESENT, in which case it is followed by
//  the predefined number of qualifier sets, one after another. 
//
//*****************************************************************************
//
//  SetData
//
//  Informs the list of its position and other information. Initialization.
//
//  Parameters:
//
//      LPMEMORY pStart                         The start of the memory block
//      int nNumSets                            The number of sets.
//      CQualifierSetListContainer* pContainer  The container.
//
//*****************************************************************************
//
//  GetStart
//
//  Returns:
//
//      LPMEMORY    The starting address of the memory block.
//
//*****************************************************************************
//
//  static GetHeaderLength
//
//  The number of bytes before the actual qualifier set data starts (currently
//  1).
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      int;    the length of the complete structure.
//
//*****************************************************************************
//
//  static GetLength
//
//  Parameters:
//
//      LPMEMORY pStart     The start of the memory block
//      int nNumSets        The number of sets in the list
//
//  Returns:
//
//      int;    the length of the complete structure.
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the list that its memory block has moved. The object updates
//  internal members pointing to the data.
//
//  Parameters:
//
//      LPMEMORY pStart     The memory block.
//
//*****************************************************************************
//
//  Rebase
//
//  Same as the other Rebase, but gets the pointer to the new memory block
//  from our container. Used for self-rebasing at the beginning of operations.
//
//*****************************************************************************
//
//  GetQualifierSetData
//
//  Returns the address of the data for the qualifier set at a given index.
//
//  Parameters:
//
//      int nIndex      The index of the set to access
//
//  Returns:
//
//      LPMEMORY:   the pointer to the data.
//
//*****************************************************************************
//
//  InsertQualifierSet
//
//  Insers an empty qualifier set into a given location. If the list is not 
//  populated at the moment (is of style QSL_FLAG_NO_SETS) it is converted
//  to a real one (stype QSL_FLAG_PRESENT). 
//
//  This call request extra memory from the container, which may move the
//  list's memory block.
//
//  Parameters:
//
//      int nIndex      The index of the position to insert into.
//
//*****************************************************************************
//
//  DeleteQualifierSet
//
//  Deletes a qualifier set at a given position from the list
// 
//  Parameters:
//
//      int nIndex      The index of the qualifier set to delete
//
//*****************************************************************************
//
//  ExtendQualifierSetSpace
//
//  Extends the amount of space alloted for a given qualifier set by moving
//  the later qualifier sets forward.
//
//  This call request extra memory from the container, which may move the
//  list's memory block.
//
//  Parameters:
//
//      CBasicQualifierSet* pSet        The qualiier set to extend
//      length_t nNewLength             The length required by the set.
//
//*****************************************************************************
//
//  ReduceQualifierSetSpace
//
//  Reduces the amount of space alloted for a given qualifier by moving the
//  later qualifier sets backward.
//
//  Parameters:
//
//      CbaseicQualifierSet* pSet       The qualfiier set to reduce
//      length_t nDecrement             By how much (in bytes).
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the number of bytes needed for a qualifier set list with a given
//  number of (empty) sets. Actually, this number is the size of the header, 
//  i.e. 1 byte, since that's how much a completely empty list takes.
//
//  Parameters:
//
//      int nNumSets        The number of qualifier sets. Ignored.
//
//  Returns:
//
//      length_t
//
//*****************************************************************************
//
//  static ComputeRealSpace
//
//  Computes the number of bytes required for a qualifier set list with a given
//  numbed of empty qualifier sets, but with the QSL_FLAG_PRESENT style, i.e.
//  with all the qualifier sets actually written as opposed to a single byte
//  saying that ther aren't any (see ComputeNecessarySpace).
//
//  Parameters:
//
//      int nNumSets        The number of qualifier sets.
//
//  Returns:  
//
//      length_t
//
//*****************************************************************************
//
//  static CreateListOfEmpties
//
//  Creates a qualifier set list on a given piece of memory coresponding to 
//  a given number of empty qualifier sets. It is created in the 
//  QSL_FLAG_NO_SETS style, and thus consists of a single bytes saying "none".
//
//  The block must contain enough space to accomodate the list, see
//  ComputeNecessarySpace.
//
//  Parameters:
//
//      LPMEMORY pMemory        Where to create.
//      int nNumSets            The number of sets to create. Ignored.
//
//  Returns:
//
//      LPMEMORY: points to the next byte after the list's representation.
//
//*****************************************************************************
//
//  EnsureReal
//
//  Ensures that the list is in the QSL_FLAG_PRESENT style. If it is not, the
//  list is converted. Such an operation will request extra memory from the 
//  container and can thus move the memory block of the list.
//
//*****************************************************************************
//
//  TranslateToNewHeap
//
//  Moves any data that the list keeps on the heap to a different heap. This
//  class simply propagates the call to all its member qualifier sets, it any.
//
//  Note: this function does not free the data from the original heap.
//
//  Parameters:
//
//      CFastHeap* pOldHeap     Where the heap data is currently stored
//      CFastHeap* pNewHeap     Where the data should be moved to.  
//
//*****************************************************************************


#define QSL_FLAG_NO_SETS 1
#define QSL_FLAG_PRESENT 2
class COREPROX_POLARITY CQualifierSetList// : public CQualifierSetContainer
{
private:
    int m_nNumSets;
    int m_nTotalLength;
    LPMEMORY m_pStart;
    CQualifierSetListContainer* m_pContainer;
    
public:
     void SetData(LPMEMORY pStart, int nNumSets, 
        CQualifierSetListContainer* pContainer)
    {
        m_nNumSets = nNumSets;
        m_pContainer = pContainer;
        m_pStart = pStart;

        m_nTotalLength = GetLength(pStart, nNumSets);
    }
     LPMEMORY GetStart() {return m_pStart;}
     static GetHeaderLength() {return sizeof(BYTE);}
     BOOL IsEmpty() {return *m_pStart == QSL_FLAG_NO_SETS;}
     static GetLength(LPMEMORY pStart, int nNumSets)
    {
        if(*pStart == QSL_FLAG_NO_SETS) return GetHeaderLength();
        LPMEMORY pCurrent = pStart + GetHeaderLength();
        for(int i = 0; i < nNumSets; i++)
        {
            pCurrent += CBasicQualifierSet::GetLengthFromData(pCurrent);
        }

		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned 32-bit value.  We do not support length
		// > 0xFFFFFFFF so cast is ok.

        return (length_t) ( pCurrent - pStart );
    }
     int GetLength() {return m_nTotalLength;}

     void Rebase(LPMEMORY pNewMemory) { m_pStart = pNewMemory;}
     void Rebase() {Rebase(m_pContainer->GetQualifierSetListStart());}

public:
     static LPMEMORY GetQualifierSetData(LPMEMORY pStart, int nIndex)
    {
        if(*pStart == QSL_FLAG_NO_SETS) return NULL;
        LPMEMORY pCurrent = pStart + GetHeaderLength();
        for(int i = 0; i < nIndex; i++)
        {
            pCurrent += CBasicQualifierSet::GetLengthFromData(pCurrent);
        }
        return pCurrent;
    }
     LPMEMORY GetQualifierSetData(int nIndex)
    {
        return GetQualifierSetData(m_pStart, nIndex);
    }

    HRESULT InsertQualifierSet(int nIndex);
    void DeleteQualifierSet(int nIndex);

public:
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,length_t nNewLength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet, length_t nReduceBy);

     CFastHeap* GetHeap() {return m_pContainer->GetHeap();}
    IUnknown* GetWbemObjectUnknown() 
        {return m_pContainer->GetWbemObjectUnknown();}
public:

    static  length_t ComputeNecessarySpace(int nNumSets)
    {
        return GetHeaderLength();
    }
    static  length_t ComputeRealSpace(int nNumSets)
    {
        return nNumSets * CBasicQualifierSet::GetMinLength() + 
            GetHeaderLength();
    }
    static  LPMEMORY CreateListOfEmpties(LPMEMORY pStart,int nNumProps);
     BOOL EnsureReal();
     BOOL TranslateToNewHeap(CFastHeap* pCurrentHeap, 
                                   CFastHeap* pNewHeap);
    
    LPMEMORY CreateLimitedRepresentation(
        IN class CLimitationMapping* pMap, IN CFastHeap* pCurrentHeap, 
        MODIFIED CFastHeap* pNewHeap, OUT LPMEMORY pWhere);
    
    LPMEMORY WriteSmallerVersion(int nNumSets, LPMEMORY pMem);
};

//*****************************************************************************
//
//  class CInstancePropertyQualifierSetList
//
//  This is the class that represents the list of qualifier sets for the 
//  properties of an instance. See CQualifierSetList (above) for the actual
//  descriptions.
//
//*****************************************************************************
typedef CQualifierSetList CInstancePropertyQualifierSetList;

//*****************************************************************************
//
//  class CInstanceQualifierSet
//
//  The qualifier set for the whole instance. It uses the CQualifierSet class
//  template with the propagation parameter (determining which of the parent's
//  qualifiers propagate to us) of WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE.
//
//*****************************************************************************

class COREPROX_POLARITY CInstanceQualifierSet : public CQualifierSet
{
public:
    CInstanceQualifierSet(int nStartRef = 0)
        : CQualifierSet(WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE, nStartRef)
    {}
};

//*****************************************************************************
//
//  class CClassQualifierSet
//
//  The qualifier set for the whole class. It uses the CQualifierSet class
//  template with the propagation parameter (determining which of the parent's
//  qualifiers propagate to us) of WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS.
//
//*****************************************************************************
class COREPROX_POLARITY CClassQualifierSet : public CQualifierSet
{
public:
    CClassQualifierSet(int nStartRef = 0)
        : CQualifierSet(WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, nStartRef)
    {}
};

//*****************************************************************************
//*****************************************************************************
//
//  class CClassPQSContainer
//
//  Before reading this, it is advisable to read the help for the
//  CClassPropertyQualifierSet class below.
//
//  This class represents the container for a qualifier set of a class 
//  property. Its purpose in life is managing the qualifier set's requests for
//  more memory. The problem is twofold:
//
//  1) As described in CClassPropertyQualifierSet class, several other objects
//  are connected to the qualifier sets and have to be moved with it.
//  2) Since qualifier sets may have a rather long life (they are COM objects 
//  in their own right), other operations on the class can intervene between
//  operations on such a set. But those other operations may, for instance, 
//  insert new properties, etc, causing this set's data to move to a completely
//  different location. Thus, this container needs to be able to "find" the
//  qualifier set's data all over again for every operation.
//
//*****************************************************************************
//
//  Create
//
//  Initializing function, giving this object enough information to always be
//  able to find the set's data.
//
//  Parameters:
//
//      CClassPart* pClassPart      The class part containing the property
//                                  definition (see fastcls.h)
//      heapptr_t ptrPropName       The heap pointer to the name of the
//                                  property (on the heap of pClassPart).
//
//*****************************************************************************
//
//  GetQualifierSetStart
//
//  Finds the data of our qualifier set. Does it by looking up the property
//  in the class part by its name and getting its qualifier set from the 
//  CPropertyInformation structure.
//
//  Returns:
//
//      LPMEMORY:   the memory block. very temporary, of coutse.
//
//*****************************************************************************
//
//  SetSecondarySetData
//
//  Finds the parent qualifier set data and informs our qualifier set of it
//  Does it by looking up our property in the parent's class part (obtained
//  from our class part.
//
//*****************************************************************************
//
//  ExtendQualifierSetSpace
//
//  Processes a request from its qualifier set for more space. Requests more
//  space from the heap that contains us and rebases the qualifier set if
//  reallocation occurs. In this case it moves the entire CPropertyInforamtion
//  structure with it and updates the heap pointer to it in the corresponding
//  CPropertyLookup structure (see fastprop.h) for more info on that.
//
//  Parameters:
//
//      CBasicQualifierSet* pSet        Our qualifier set
//      length_t nNewLength             the required length.
//
//*****************************************************************************
//
//  ReduceQualifierSetSpace
//
//  Processes a request to reduce the amount of space alloted to the set.
//  Currently a noop.
//  
//  Parameters:
//
//      CBasicQualifierSet* pSet        Our qualifier set
//      length_t nDecrement             How many bytes to return.
//
//*****************************************************************************
//
//  CanContainKey
//
//  As required from all qualifier set containers, this function determines if
//  it is legal for this property to contain a 'key' qualifier. The criteria
//  are described in the help file, but property type as well as whether or not
//  the parent class has a key are taken into account here.
//
//  Returns:
//
//      S_OK if key can be legally specified, error otherwise.
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************

class CClassPart;
class CClassPQSContainer : public CQualifierSetContainer
{
protected:
    CClassPart* m_pClassPart;
    heapptr_t m_ptrPropName;
    offset_t m_nParentSetOffset;

    CBasicQualifierSet* m_pSecondarySet;
    friend class CClassPropertyQualifierSet;
public:
    CClassPQSContainer() : m_pClassPart(NULL), m_pSecondarySet(NULL){}

     void Create(CClassPart* pClassPart, heapptr_t ptrPropName)
    {
        m_pClassPart = pClassPart; m_ptrPropName = ptrPropName;
        m_nParentSetOffset = 0;
        m_pSecondarySet = NULL;
    }

    class CPropertyInformation* GetPropertyInfo();
    LPMEMORY GetQualifierSetStart();
    void SetSecondarySetData();

public:   
    ~CClassPQSContainer();
    CFastHeap* GetHeap();
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,length_t nNewlength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet, length_t nReduceBy);
    IUnknown* GetWbemObjectUnknown();
    HRESULT CanContainKey();
    HRESULT CanContainSingleton();
	HRESULT CanContainAbstract( BOOL fValue );
	HRESULT CanContainDynamic();
    BOOL CanHaveCimtype(LPCWSTR wsz);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CClassPropertyQualifierSet
//
//  This class represents the qualifier set for a property. It uses
//  CQualifierSet for most of its functionality, but has a few extra quirks.
//  The problem is that it lives on the heap, as part of the 
//  CPropertyInformation structure for a property. This makes relocation rather
//  complicated: when this qualifier set grows and the container needs to move
//  it to a different location in the heap, rather than just moving the
//  qualifier set it has to move the complete CPropertyInformation object (see
//  fastprop.h for description) as well as update the pointer to it from the
//  CPropertyLookup structure (see same).
//
//  These responsibilities really fall on the qualifier set container object.
//  Hence, this qualifier set uses a very specific implementation, 
//  CClassPropertyPQSContainer to do the job. CClassPropertyQualfieirSet
//  creates the container as its own member and gives it enough information to
//  perform all the reallocations.
//
//*****************************************************************************
//
//  SetData
//
//  Initializes the qualifier set with all the data it needs to survive.
//
//  Parameters:
//
//      LPMEMORY pStart             The location of the memory block for this
//                                  qualifier set (the format of the block is
//                                  described in CBasicQualifierSet).
//      CClassPart* pClassPart      The class part which contains the property
//                                  for which this is a qualifier set (see
//                                  fastcls.h for that).
//      heapptr_t ptrPropName       The heap pointer (on the same heap as the
//                                  set itself) to the name of the property
//                                  we are the qualifier set for.
//      CBasicQualifierSet* pSet    The parent's qualifier set.
//
//*****************************************************************************

class CClassPropertyQualifierSet : public CClassQualifierSet
{
protected:
    CClassPQSContainer m_Container;
public:
     void SetData(LPMEMORY pStart, CClassPart* pClassPart, 
        heapptr_t ptrPropName, CBasicQualifierSet* pSecondarySet = NULL)
    {
        m_Container.Create(pClassPart, ptrPropName);
        m_Container.SetSecondarySetData();
        CClassQualifierSet::SetData(
            pStart, (CQualifierSetContainer*)&m_Container, 
            m_Container.m_pSecondarySet);
    }
};

//*****************************************************************************
//*****************************************************************************
//
//  class CInstancePQSContainer
//
//  This class functions as the qualifier set container for the instance 
//  property qualifier sets. See CInstancePropertyQualifierSet class before
//  reading this help.
//
//  The primary purpose of this class is to contain enough information to 
//  always be able to find the qualifier set data.
//
//*****************************************************************************
//
//  Create
//
//  Initialization function.
//
//  Parameters:
//
//      CInstancePropertyQualifierSetList* pList    The list we are part of.
//      int nPropIndex              The index of our property in the v-table
//      CClassPart* pClassPart      The class part of this instance (fastcls.h)
//      offset_t nClassSetOffset    The offset of the class property qualifier
//                                  set from the class part.
//
//*****************************************************************************
//
//  SetSecondarySetData
//
//  Finds and initializes the parent qualifier set.
//
//*****************************************************************************
//
//  RebaseSecondarySet
//
//  Finds the data of the secondary qualifier set and informs it of the (new)
//  location of its data.
//
//*****************************************************************************
//
//  GetQualifierSetStart
//
//  Finds the qualifier set data and returns the pointer to it.
//  
//  Returns:
//
//      LPMEMORY:   the data of our qualifier set (temporary of course)
//
//*****************************************************************************
//
//  CanContainKey
//
//  The 'key' qualifier cannot be specified on instance, so this function 
//  always
//
//  Returns:
//
//      WBEM_E_INVALID_QUALIFIER
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************
//
//    
                 
class COREPROX_POLARITY CInstancePQSContainer : public CQualifierSetContainer
{

protected:
    CInstancePropertyQualifierSetList* m_pList;
    int m_nPropIndex;

    CClassPart* m_pClassPart;
    offset_t m_nClassSetOffset;

    CBasicQualifierSet m_SecondarySet;
    friend class CInstancePropertyQualifierSet;
public:
    CInstancePQSContainer() : m_pClassPart(NULL), m_pList(NULL){}

     void Create(CInstancePropertyQualifierSetList* pList, 
                       int nPropIndex,
                       CClassPart* pClassPart,
                       offset_t nClassSetOffset)
    {
        m_pList = pList; m_nPropIndex = nPropIndex;
        m_pClassPart = pClassPart;
        m_nClassSetOffset = nClassSetOffset;
        SetSecondarySetData();
    }

    void SetSecondarySetData();
    void RebaseSecondarySet();
   
    LPMEMORY GetQualifierSetStart();
    
     CFastHeap* GetHeap() {return m_pList->GetHeap();}
     HRESULT CanContainKey() {return WBEM_E_INVALID_QUALIFIER;}
     HRESULT CanContainSingleton() {return WBEM_E_INVALID_QUALIFIER;}
     HRESULT CanContainAbstract( BOOL fValue ) { return WBEM_E_INVALID_QUALIFIER;}
     HRESULT CanContainDynamic() { return WBEM_S_NO_ERROR;}
     BOOL CanHaveCimtype(LPCWSTR) {return FALSE;}
     BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nNewLength)
    {
        if (!m_pList->EnsureReal())
        	return FALSE;
        pSet->Rebase(m_pList->GetQualifierSetData(m_nPropIndex));
        if (!m_pList->ExtendQualifierSetSpace(pSet, nNewLength))
        {
        	return FALSE;
        }
        RebaseSecondarySet();
		
		return TRUE;
    }
     void ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement)
    {
        m_pList->ReduceQualifierSetSpace(pSet, nDecrement);
        RebaseSecondarySet();
    }

    IUnknown* GetWbemObjectUnknown() {return m_pList->GetWbemObjectUnknown();}
};

//*****************************************************************************
//*****************************************************************************
//
//  class CInstancepropertyQualifierSet
//
//  This flavor of CQualifierSet represents a qualifier set of a property of
//  an instance. It uses CQualifierSet for most functionality, but has an
//  additional problem with re-allocation. Since instance property qualifier
//  sets are stored as members of a CQualifierSetList, if one of them needs to
//  grow, the whole list needs to grow, and the whole list may need to relocate
//  and the heap pointer to the list will have to be updated. In addition, 
//  since this qualifier set is an actual COM object, it may live for a long
//  time, and its memory block can be completely moved between operations.
//
//  Hence, a special QualifierSetContainer, CInstancePQSContainer (above) is
//  used. CInstancePropertyQualifierSet stores its container object in itself.
//
//*****************************************************************************
//
//  SetData
//
//  Initializing function supplying enough data for this object to be able
//  to find its data no matter how the instance changes.
//
//  Parameters:
//
//      CInstancePropertyQualifierSetList* pList    The list of which we are
//                                                  a part of.
//      int nPropIndex              The index of our property in the v-table.
//      CClassPart* pClassPart      The class part of the instance (fastcls.h)
//      offset_t nClassSetOffset    The offset of the corresponding class
//                                  property qualifier set off the class part.
//                                  Since the class part of an instance never
//                                  changes, this value is constant.
//
//*****************************************************************************
class CInstancePropertyQualifierSet : public CInstanceQualifierSet
{
protected:
    CInstancePQSContainer m_Container;
public:
     void SetData(CInstancePropertyQualifierSetList* pList, 
        int nPropIndex, CClassPart* pClassPart, offset_t nClassSetOffset)
    {
        m_Container.Create(pList, nPropIndex, pClassPart, nClassSetOffset);
        CInstanceQualifierSet::SetData(m_Container.GetQualifierSetStart(), 
            &m_Container, &m_Container.m_SecondarySet);
    }
};

//#pragma pack(pop, 1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastqual.inc ===
//=============================================================================
//
//                              FASTQUAL.INC
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  This file implements inline functions for the classes related to 
//  qualifier processing in WbemObjects. 
//
//  See fastqual.h for full documentation
//  and fastqual.cpp for non-inline implementations.
//
//  Classes implemented: 
//      CQualifierFlavor                Encapsulates qualifier flavor infor
//      CQualifier                      Represents a qualifier
//      CBasicQualifierSet              Represents read-only functionality.
//      CQualiferSetContainer           What qualifier set container supports.
//      CQualifierSet                   Full-blown qualifier set (template)
//      CQualifierSetListContainer      What qualifier set list container supports.
//      CQualifierSetList               List of qualifier sets.
//      CInstanceQualifierSet           Instance qualifier set.
//      CClassQualifierSet              Class qualifier set.
//      CClassPQSContainer              Class property qualifier set container
//      CClassPropertyQualifierSet      Class property qualifier set
//      CInstancePQSContainer           Instance proeprty qualifier set container
//      CInstancePropertyQualifierSet   Instance property qualifier set
//      
//  History:
//
//      2/20/97     a-levn  Fully documented
//
//=============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastsprt.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSPRT.CPP

Abstract:

  This file implements supporting classes for Wbem Class/Instance objects.
  See faststr.h for documentation.

  Classes implemented: 
      CBitBlockTable:     a two-dimentional array of bits.

History:

  2/20/97     a-levn  Fully documented

--*/

#include "precomp.h"
//#include <dbgalloc.h>

#include "fastsprt.h"

//*****************************************************************************
//
//  InsertSpace
//
//  Inserts space into a block of memory by moving the tail of the block back
//  by the required amount. It assumes that there is enough room at the end
//  of the block for the insertion.
//
//  Parameters:
//
//      [in] LPMEMORY pMemory           The starting point of the block
//      [in] int nLength                The original length of the block
//      [in] LPMEMORY pInsertionPoint   Points to the insertion point (between
//                                      pMemory and pMemory + nLength
//      [in] int nBytesToInsert         The number of bytes to insert
//
//*****************************************************************************
  
 void InsertSpace(LPMEMORY pMemory, int nLength, 
                        LPMEMORY pInsertionPoint, int nBytesToInsert)
{
    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value (nLength - (pInsertionPoint - pMemory)).
    // We do not support length > 0xFFFFFFFF, so cast is ok.

    memmove((void*)(pInsertionPoint + nBytesToInsert),
           (void*)pInsertionPoint, 
           nLength - (int) ( (pInsertionPoint - pMemory) ) );
}

/*
static DWORD CBitTable::m_pMasks[32] = 
{
    0x80000000,
    0x40000000,
    0x20000000,
    0x10000000,

    0x08000000,
    0x04000000,
    0x02000000,
    0x01000000,

    0x00800000,
    0x00400000,
    0x00200000,
    0x00100000,

    0x00080000,
    0x00040000,
    0x00020000,
    0x00010000,

    0x00008000,
    0x00004000,
    0x00002000,
    0x00001000,

    0x00000800,
    0x00000400,
    0x00000200,
    0x00000100,

    0x00000080,
    0x00000040,
    0x00000020,
    0x00000010,

    0x00000008,
    0x00000004,
    0x00000002,
    0x00000001
};

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastumi.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTUMI.CPP

Abstract:

  This file implements the classes related to generic object representation
  in WbemObjects. It contains UMI implementations for CWbemObject.

  Classes implemented:
      CWbemObject          Any object --- class or instance.

History:

  3/8/00 sanjes -    Created

--*/

#include "precomp.h"

//#include "dbgalloc.h"
#include "wbemutil.h"
#include "fastall.h"
#include <wbemutil.h>

#include <wbemstr.h>
#include "olewrap.h"
#include <arrtempl.h>
#include "wmiarray.h"
#include "umiprop.h"

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp )
{
	return PutProps( &pszName, 1, uFlags, pProp );
}

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		// We'll need somewhere to store our results
		CUmiPropertyArray	umiPropertyArray;

		hr = GetIntoArray( &umiPropertyArray, pszName, uFlags );
		if ( SUCCEEDED( hr ) )
		{
			// Now export the data
			hr = umiPropertyArray.Export( pProp );
		}

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );
		CIMTYPE	ct;

		hr = GetPropertyType( pszName, &ct, NULL );

		if ( SUCCEEDED( hr ) )
		{

			if ( !CType::IsArray(ct) )
			{
				BOOL fIsNull;
				ULONG	dwBuffSizeUsed;
				
				// ReadRaw
				hr = ReadProp( pszName, 0L, uBufferLength, NULL, NULL, &fIsNull, &dwBuffSizeUsed, pExistingMem );

				if ( SUCCEEDED( hr ) && fIsNull )
				{
					// NULL means WBEM_S_FALSE
					hr = WBEM_S_FALSE;
				}
			}
			else
			{
				hr = WBEM_E_INVALID_OPERATION;
			}
		}

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		// We'll need somewhere to store our results
		CUmiPropertyArray	umiPropertyArray;

		hr = GetIntoArray( &umiPropertyArray, pszName, uFlags );

		if ( SUCCEEDED( hr ) )
		{
			// Now attempt to coerce the property value
			CUmiProperty* pUmiProp = NULL;

			hr = umiPropertyArray.GetAt( 0, &pUmiProp );

			if ( SUCCEEDED( hr ) )
			{
				hr = pUmiProp->Coerce( uCoercionType );

				if ( SUCCEEDED( hr ) )
				{
					// Now export the data
					hr = umiPropertyArray.Export( pProp );
				}

			}	// IF GetAt

		}	// IF Get into array

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::FreeMemory( ULONG uReserved, LPVOID pMem )
{
	if ( 0L != uReserved || NULL == pMem )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		CUmiPropertyArray	umiPropertyArray;

		hr = umiPropertyArray.Delete( (UMI_PROPERTY_VALUES*) pMem );
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::Delete( LPCWSTR pszName, ULONG uFlags )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		hr = Delete( pszName );

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		// We'll need somewhere to store our results
		CUmiPropertyArray	umiPropertyArray;

		for ( ULONG uCtr = 0; SUCCEEDED( hr ) && uCtr < uNameCount; uCtr++ )
		{
			hr = GetIntoArray( &umiPropertyArray, pszNames[uCtr], uFlags );
		}

		// Lastly, if we got all properties, now we can export the data
		if ( SUCCEEDED( hr ) )
		{
			// Now export the data
			hr = umiPropertyArray.Export( pProps );
		}

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );

		// Ensure this will work
		if ( uNameCount != pProps->uCount )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// We'll need to be able to interpret the properties
		CUmiPropertyArray	umiPropertyArray;

		// This will setup the array, but won't dump any memory when we destruct
		hr = umiPropertyArray.Set( pProps, TRUE, FALSE );

		if ( SUCCEEDED( hr ) )
		{
			for ( ULONG	uPropCtr = 0; uPropCtr < uNameCount; uPropCtr++ )
			{
				CUmiProperty*	pProperty = NULL;

				hr = umiPropertyArray.GetAt( uPropCtr, &pProperty );

				if ( SUCCEEDED( hr ) )
				{
					if ( pProperty->GetOperationType() == UMI_OPERATION_UPDATE )
					{
						hr = PutUmiProperty( pProperty, pszNames[uPropCtr], uFlags );
					}
					else
					{
						hr = WBEM_E_INVALID_OPERATION;
					}
				}	// IF we got at the property

			}	// FOR enum properties

		}	// IF Set

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// See UMI.IDL for Documentation
STDMETHODIMP CWbemObject::PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Protect the BLOB during this operation
		CLock   lock( this, WBEM_FLAG_ALLOW_READ );
		CIMTYPE	ct;

		hr = GetPropertyType( pszName, &ct, NULL );

		if ( SUCCEEDED( hr ) )
		{

			if ( !CType::IsArray(ct) )
			{
				// WriteRaw
				hr = WriteProp( pszName, 0L, uBufferLength, 0L, ct, pExistingMem );
			}
			else
			{
				hr = WBEM_E_INVALID_OPERATION;
			}
		}

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// See UMI.IDL for Documentation
HRESULT CWbemObject::GetIntoArray( CUmiPropertyArray* pArray, LPCWSTR pszName, ULONG uFlags )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// First get the type
		CIMTYPE	ct;
		hr = GetPropertyType( pszName, &ct, NULL );

		if( SUCCEEDED( hr ) )
		{
			if ( CType::IsArray( ct ) )
			{
				BOOL	fIsNull;
				ULONG	uBuffSizeUsed = 0L,
						uBuffSize = 0L;
				_IWmiArray*	pWmiArray = NULL;

				hr = ReadProp( pszName, 0L, sizeof(_IWmiArray*), &ct, NULL, &fIsNull, &uBuffSizeUsed, (void**) &pWmiArray );
				CReleaseMe	rm(pWmiArray);

				if ( SUCCEEDED( hr ) )
				{
					ULONG	uNumElements;
					hr = pWmiArray->GetAt( 0L, 0, WMIARRAY_FLAG_ALLELEMENTS, 0, &uNumElements, &uBuffSize, NULL );

					// Not this error and something's wrong

					if ( WBEM_E_BUFFER_TOO_SMALL == hr )
					{
						LPMEMORY	pbData = new BYTE[uBuffSize];
						CVectorDeleteMe<BYTE>	dm(pbData);

						if ( NULL != pbData )
						{
							// Get the data for real
							hr = pWmiArray->GetAt( 0L, 0, WMIARRAY_FLAG_ALLELEMENTS, uBuffSize, &uNumElements, &uBuffSizeUsed, NULL );

							if ( SUCCEEDED( hr ) )
							{
								LPWSTR*		pbStringArray = NULL;
								LPMEMORY	pbRealData = pbData;

								// Convert to an array of LPWSTRs if necessary
								if ( CType::IsStringType( ct ) )
								{
									pbStringArray = new LPWSTR[uNumElements];

									if ( NULL != pbStringArray )
									{
										LPWSTR pwszTemp = (LPWSTR) pbData;

										for ( ULONG uCtr =0; uCtr < uNumElements; uCtr++ )
										{
											pbStringArray[uCtr] = pwszTemp;
											pwszTemp += ( wcslen( pwszTemp ) + 1 );
										}

										pbRealData = (LPMEMORY) pbStringArray;
									}
									else
									{
										hr = WBEM_E_OUT_OF_MEMORY;
									}
								}
								
								// Ensures cleanup
								CVectorDeleteMe<LPWSTR> dmsa(pbStringArray);

								if ( SUCCEEDED( hr ) )
								{
									// Add the array  We don't want to acquire, since we will be exporting
									// this at the end
									UMI_TYPE umiType = CUmiValue::CIMTYPEToUmiType( CType::GetBasic( ct ) );
									hr = pArray->Add( umiType | UMI_TYPE_ARRAY_FLAG, UMI_OPERATION_NONE, pszName,
														uNumElements, pbRealData, FALSE );
								}

							}	// IF we got the array

						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}

					}	// IF GetAt

				}	// IF ReadProp

			}
			else
			{
				// Get the value as a singleton
				CVar	var;

				hr = GetProperty( pszName, &var );

				// Add it into the array
				if ( SUCCEEDED( hr ) )
				{
					hr = pArray->Add( pszName, ct, &var );
				}
			}

		}	// IF GetPropertyType

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// Helper function for Put
HRESULT CWbemObject::PutUmiProperty( CUmiProperty* pProperty, LPCWSTR pszName, ULONG uFlags )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Must be singleton and a non-Octet string
	if ( !pProperty->IsArray() && pProperty->GetType() != UMI_TYPE_OCTETSTRING )
	{
		ULONG		uNumValues;
		ULONG		uBuffSize;
		LPBYTE		pbData;

		hr = pProperty->CoerceToCIMTYPE( &uNumValues, &uBuffSize, NULL, &pbData );
		// For cleanup
		CVectorDeleteMe<BYTE> dm(pbData);

		// Write out the property

		if ( SUCCEEDED( hr ) )
		{

			CIMTYPE	ct = CUmiValue::UmiTypeToCIMTYPE( pProperty->GetPropertyType() );

			hr = WriteProp( pProperty->GetPropertyName(),
							0L,
							uBuffSize,
							uNumValues,
							ct,
							pbData );

		}	// IF okay to write

	}
	else
	{
		ULONG		uNumValues;
		ULONG		uBuffSize;
		LPBYTE		pbData;

		hr = pProperty->CoerceToCIMTYPE( &uNumValues, &uBuffSize, NULL, &pbData );
		// For cleanup
		CVectorDeleteMe<BYTE> dm(pbData);

		// Write out the property

		if ( SUCCEEDED( hr ) )
		{

			CIMTYPE	ct = CUmiValue::UmiTypeToCIMTYPE( pProperty->GetPropertyType() ) | CIM_FLAG_ARRAY;

			hr = WriteProp( pProperty->GetPropertyName(),
							0L,
							uBuffSize,
							uNumValues,
							ct,
							pbData );

		}	// IF okay to write

	}	// ELSE it's an array

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastsprt.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPRT.H

Abstract:

  This file defines supporting classes for WBEM Class/Instance objects.

  Classes defined: 
      CBitBlockTable:     a two-dimentional array of bits.
      CPtrSource          moving pointer representation base class
          CStaticPtr      static pointer representation
          CShiftedPtr     pointer arithmetic representation.

History:

  2/20/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

//***********************!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//*************** IMPORTANT *********************************
//
//  1) Memory reallocation (ExtendMemoryBlock) routines may NOT
//      return a forward-overlapping region (say old+1).
//
//**************** IMPORTANT ********************************

#ifndef __FAST_SUPPORT__H_
#define __FAST_SUPPORT__H_

#include "parmdefs.h"
#include "strutils.h"

// pack is necessary since our structures correspond to not necessarily 
// alligned disk data.
#pragma pack(push, 1)

// offset into the object's local heap
typedef DWORD heapptr_t;
// length of a structure
typedef DWORD length_t;
// index of a property in the class v-table
typedef WORD propindex_t;
// offset of the property's data from the v-table start
typedef DWORD offset_t;
// index of the originating class in the derivation chain
typedef DWORD classindex_t;
// identifier length type
typedef length_t idlength_t;
// property type
typedef DWORD Type_t;

typedef UNALIGNED heapptr_t*	PHEAPPTRT;
typedef UNALIGNED length_t*		PLENGTHT;
typedef UNALIGNED propindex_t*	PPROPINDEXT;
typedef UNALIGNED offset_t*		POFFSETT;
typedef UNALIGNED classindex_t*	PCLASSINDEXT;
typedef UNALIGNED idlength_t*	PIDLENGTHT;

typedef UNALIGNED int*			PUNALIGNEDINT;

// arbitrary memory block
typedef BYTE* LPMEMORY;

#define MOST_SIGNIFICANT_BIT_IN_DWORD 0x80000000

typedef __int64 WBEM_INT64;
typedef unsigned __int64 WBEM_UINT64;

// the function like memcpy, but safe for forward copying. memmove will do.
#define MEMRCPY memmove

typedef enum {
    e_Reconcilable, e_ExactMatch, e_DiffClassName, e_DiffParentName, e_DiffNumProperties,
        e_DiffPropertyName, e_DiffPropertyType, e_DiffPropertyLocation,
        e_DiffKeyAssignment, e_DiffIndexAssignment, e_DiffClassQualifier,
		e_DiffPropertyQualifier, e_DiffPropertyValue, e_DiffMethodNames,
		e_DiffMethodFlags, e_DiffMethodOrigin, e_DiffMethodInSignature,
		e_DiffMethodOutSignature, e_DiffMethodQualifier, e_DiffNumMethods,
		e_WbemFailed, e_OutOfMemory} EReconciliation;

//*****************************************************************************
//*****************************************************************************
//
//  TMovable
//
//  This name appears several times in the templates below. Classes that can be
//  used in these templates must represent a block of memory (and most 
//  everything inside a CWbemObject is a blcok of memory). They must implement 
//  all the methods described below. This could be made into a base class with
//  all these functions being pure virtual members, but that would increase 
//  function call overhead and this is critical code; thus the templates are
//  used instead.
//
//*****************************************************************************
//
//  GetStart
//
//  Returns:
//
//      LPMEMORY: the address of the beginning of the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      length_t: the length of the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  This function is called when the memory block of the object in question is
//  moved to a different location. Since some objects cache pointers into their
//  memory blocks, this function is necessary and must update whatever cache 
//  the object has to the new location.
//
//  Parameters:
//
//      [in] LPMEMORY pNewMemory:   points to the starting address of the new
//                                  memory location for the object. The length
//                                  is not needed as the object knows it.
//  
//*****************************************************************************


//*****************************************************************************
//
//  EndOf
//
//  This function template returns the pointer to the first byte following the
//  memory block of a given object (represented by a TMovable, see above).
//
//  Parameters:
//
//      [in, readonly] TMovable& Block  the object whose block is considered.
//                                      The class must be a valid TMovable
//                                      (see above)
//  Returns:
//
//      LPMEMORY:   the pointer to the first byte after the object.
//
//*****************************************************************************
template<class TMovable>
 LPMEMORY EndOf(READ_ONLY TMovable& Block)
{
    return Block.GetStart() + Block.GetLength();
}

//*****************************************************************************
//
//  MoveBlock
//
//  This function template moves an object representing a memory block to a new
//  location. The function uses memmove to copy object's memory block and then
//  advises the object of its new location. 
//
//  Parameters:
//
//      [in] TMovable& Block    The object whose memory block is being moved. 
//                              The class must be a valid TMovable (see above)
//                              It will be advised of its new location.
//                             
//      [in] LPMEMORY pMemory   Points to the beginning of the new memory blcok
//                              It is assumed to be large enough for the object
//
//*****************************************************************************

template<class TMovable>
 void MoveBlock(TMovable& Block, LPMEMORY pNewMemory)
{
    if(pNewMemory != Block.GetStart())
    {
        memmove((void*)pNewMemory, (void*)Block.GetStart(), Block.GetLength());
        Block.Rebase(pNewMemory);
    }
}

//*****************************************************************************
//
//  CopyBlock
//
//  This function is exactly the same as MoveBlock (above), except that it
//  assumes that the new memory is guaranteed not to forward-overlap with the
//  old one, and so uses the more efficient memcpy function to copy the data.
//
//  Parameters:
//
//      [in] TMovable& Block    The object whose memory block is being moved. 
//                              The class must be a valid TMovable (see above)
//                              It will be advised of its new location.
//                             
//      [in] LPMEMORY pMemory   Points to the beginning of the new memory blcok
//                              It is assumed to be large enough for the object
//
//*****************************************************************************
template<class TMovable>
 void CopyBlock(TMovable& Block, LPMEMORY pNewMemory)
{
    if(pNewMemory != Block.GetStart())
    {
        memcpy((void*)pNewMemory, (void*)Block.GetStart(), Block.GetLength());
        Block.Rebase(pNewMemory);
    }
}


//*****************************************************************************
//
//  InsertSpaceAfter
//
//  This function template assumes that the SmallBlock is an object whose 
//  memory block resides inside the BigObject's one (like a qualifier set
//  inside a class part). It then inserts some space into the BigBlock right
//  after the SmallBlock (usually to allow the SmallBlock to expand).
//
//  InsertSpace function (above) does the work.
//
//  Parmeters:
//
//      [in] TMovable& BigBlock     The containing object
//      [in] TMovable& SmallBlock   The contained object
//      [in] int nBytesToInsert     The number of bytes of space to insert.
//
//*****************************************************************************

template<class TMovable1, class TMovable2>
 void InsertSpaceAfter(TMovable1& BigBlock, TMovable2& SmallBlock,
                        int nBytesToInsert)
{
    LPMEMORY pInsertionPoint = EndOf(SmallBlock);
    memmove((void*)(pInsertionPoint + nBytesToInsert),
           (void*)pInsertionPoint, 
           Block.GetLength() - (pInsertionPoint - Block.GetStart()));
}


//*****************************************************************************
//*****************************************************************************
//
//  class CBitBlockTable
//
//  This class template represents a table of an arbitrary number of bit 
//  strings of fixed length. The length of each bit string is t_nNumValues, the
//  template parameter. The number of strings may change, but this class never
//  re-allocates memory, leaving that job to its owner. 
//
//  Like many CWbemObject-related classes, it is a pseudo-class: its 'this'
//  pointer points to the beginning of the data. Thus, *(BYTE*)this, would get
//  us the first eight bits of the table. Instances of this class are never 
//  constructed. Instead, a pointer to CBitBlockTable is created and set to 
//  point to the actual table (found as part of some other memory block).
//
//*************************** public interface ********************************
//
//  static GenNecessaryBytes
//
//  Computes the number of integral bytes necessary to hold a given bit table.
//  Only the number of blocks (strings) is given as a parameter. Recall that
//  the length of each string is a template parameter.
//
//  Parameters:
//
//      int nBitBlocks      the numbed of blocks in the proposed table
//
//  Returns:
//
//      int:    the number of bytes necessary to contain the table.
//
//*****************************************************************************
//
//  GetBit
//
//  Retrieves a given bit from a given string. No bounds checking is performed.
//
//  Parameters:
//
//      int nBitBlock       The index of the string (block) in the table
//      int nValueIndex     The index of the bit in the string.
//
//  Returns:
//
//      BOOL    the value of the bit (1/0).
//
//*****************************************************************************
//
//  SetBit
//
//  Sets a given bit in a given block to a given value. No bounds checking is
//  performed.
//
//  Parameters:
//
//      int nBitBlock       The index of the string (block) in the table
//      int nValueIndex     The index of the bit in the block.
//      BOOL bValue         The value to set.
//
//*****************************************************************************
//
//  RemoveBitBlock
//
//  Removes one of the bit blocks from the table by copying the tail of the 
//  table (after the aforementioned block) forward. No bounds checking is
//  performed and no memory is freed.
//
//  Parameters:
//
//      int nBitBlock       The index of the block to remove.
//      int nTableByteLen   The number of bytes in the table (bytes,not blocks)
//
//*****************************************************************************
template<int t_nNumValues>
class CBitBlockTable
{
protected:
//    static DWORD m_pMasks[32];

     static BOOL GetBitFromDWORD(DWORD dw, int nBit)
    {
        return (dw >> nBit) & 1;
        // return (dw & m_pMasks[nBit]);
    }

     static void SetBitInDWORD( UNALIGNED DWORD& dw, int nBit)
    {
        dw |= ((DWORD)1 << nBit);
        //dw |= m_pMasks[nBit];
    }

     static void ResetBitInDWORD( UNALIGNED DWORD& dw, int nBit)
    {
        dw &= ~((DWORD)1 << nBit);
        //dw &= ~m_pMasks[nBit];
    }

     static void SetBitInDWORD( UNALIGNED DWORD& dw, int nBit, BOOL bValue)
    {
        bValue?SetBitInDWORD(dw, nBit):ResetBitInDWORD(dw, nBit);
    }

    static BOOL GetBit(LPMEMORY pMemory, int nBit)
    {
        return GetBitFromDWORD(
                ((UNALIGNED DWORD*)pMemory)[nBit/32],
                nBit % 32);
    }
    
    static void SetBit(LPMEMORY pMemory, int nBit, BOOL bValue)
    {
        SetBitInDWORD(((UNALIGNED DWORD*)pMemory)[nBit/32], nBit%32, bValue);
    }

public:
    static int GetNecessaryBytes(int nBitBlocks)
    {
        int nTotalBits = nBitBlocks * t_nNumValues;
        return (nTotalBits%8) ? nTotalBits/8 + 1 : nTotalBits/8;
    }
public:

    BOOL GetBit(int nBitBlock, int nValueIndex)
    {
        return GetBit(LPMEMORY(this), nBitBlock*t_nNumValues + nValueIndex);
    }

    void SetBit(int nBitBlock, int nValueIndex, BOOL bValue)
    {
        SetBit(LPMEMORY(this), nBitBlock*t_nNumValues + nValueIndex, bValue);
    }

    void RemoveBitBlock(int nBitBlock, int nTableByteLen)
    {
        for(int i = nBitBlock*t_nNumValues; i < nTableByteLen*8 - t_nNumValues; i++)
        {
            SetBit(LPMEMORY(this), i, GetBit(LPMEMORY(this), i+t_nNumValues));
        }
    }

};

//*****************************************************************************
//*****************************************************************************
//
//  class CPtrSource
//
//  This class has a very sad reason for existence. Imagine that, inside a 
//  certain function, you store a pointer to an internal memory location inside
//  an object's block. Then you call some member function of that object, 
//  causing the object's block to request more space. Doing so may completely
//  reallocate the object, invalidating your pointer. 
//
//  The solution is CPtrSource, a kind of pointer moniker --- it has the
//  knowledge to find your pointer even if the memory block moves. 
//
//*****************************************************************************
//
//  GetPointer() = 0
//
//  Must be implemented by derived classes to return the actual value of the
//  pointer at the moment.
//
//  Returns:
//
//      LPMEMORY:       the pointer
//
//*****************************************************************************
//
//  AccessPtrData
//
//  A helper function, for those occasions when the pointer points to a heap
//  offset. Returns a reference to that offset (heapptr_t&).
//
//  Returns:
//
//      heapptr_t& pointed to by this pointer.
//
//*****************************************************************************

class CPtrSource
{
public:
    virtual LPMEMORY GetPointer() = 0;
    UNALIGNED heapptr_t& AccessPtrData() {return *(UNALIGNED heapptr_t*)GetPointer();}
};

//*****************************************************************************
//
//  class CStaticPtr : public CPtrSource
//
//  A flavor of CPtrSource (above) for those occasions when your pointer is
//  guaranteed not to move, but a function expects a CPtrSource. Contains the
//  actual value of the pointer and always returns it.
//
//*****************************************************************************
//
//  Constructor.
//
//  Parameters:
//
//      LPMEMORY p      The pointer to store and return. Assumed to last at
//                      least as long as the object itself.
//
//*****************************************************************************

class CStaticPtr : public CPtrSource
{
protected:
    LPMEMORY m_p;
public:
    CStaticPtr(LPMEMORY p) : m_p(p) {}
    LPMEMORY GetPointer() {return m_p;}
};

//*****************************************************************************
//
//  class CShiftedPtr : public CPtrSource
//
//  A flavor of CPtrSource for those occasions when you receive a CPtrSource
//  from somebody and need to give somebody a pointer which has the same logic
//  as the one given to you, but plus some constant. 
//
//  When asked for the current pointer value, this class will evaluate its base
//  and add the offset.
//
//*****************************************************************************
//
//  Constructor
//
//  Parameters:
//
//      CPtrSource* pBase       The base. Assumed to last at least as long as
//                              this object.
//      int nOffset             The offset.
//
//*****************************************************************************

class CShiftedPtr : public CPtrSource
{
protected:
    CPtrSource* m_pBase;
    int m_nOffset;
public:
    CShiftedPtr(CPtrSource* pBase, int nOffset) 
        : m_pBase(pBase), m_nOffset(nOffset) {}
    LPMEMORY GetPointer() {return m_pBase->GetPointer() + m_nOffset;}
    void operator+=(int nShift) {m_nOffset += nShift;}
};

 void InsertSpace(LPMEMORY pMemory, int nLength, 
                        LPMEMORY pInsertionPoint, int nBytesToInsert);

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\faststr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSTR.CPP

Abstract:

  This file implements the classes related to string processing in WbemObjects.

  See faststr.h for documentation.

  Classes implemented: 
      CCompressedString   Represents an ascii or unicode string.
      CKnownStringTable   The table of strings hard-coded into WINMGMT for
                          compression.
      CFixedBSTRArray     An array of BSTRs capable of sophisticated merges.

History:

  2/20/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
//#include <dbgalloc.h>

#include "faststr.h"
#include "fastheap.h"
#include "olewrap.h"
#include "corex.h"

//*****************************************************************************
//
//  See faststr.h for documentation
//
//*****************************************************************************
BOOL CCompressedString::CopyToNewHeap(
                    heapptr_t ptrOldString, CFastHeap* pOldHeap, CFastHeap* pNewHeap,
                    UNALIGNED heapptr_t& ptrResult )
{
    if(CFastHeap::IsFakeAddress(ptrOldString))
    {
        ptrResult = ptrOldString;
        return TRUE;
    }

    CCompressedString* pString = (CCompressedString*)
        pOldHeap->ResolveHeapPointer(ptrOldString);

    int nLen = pString->GetLength();

    // Check that allocation succeeds
    BOOL fReturn = pNewHeap->Allocate(nLen, ptrResult);
    // can no longer use pString --- the heap might have moved
    
    if ( fReturn )
    {
        memcpy(pNewHeap->ResolveHeapPointer(ptrResult),
            pOldHeap->ResolveHeapPointer(ptrOldString),
            nLen);
    }

    return fReturn;
}
 
//*****************************************************************************
//
//  See faststr.h for documentation
//
//*****************************************************************************
LPMEMORY CCompressedString::CreateEmpty(LPMEMORY pWhere)
{
    pWhere[0] = STRING_FLAG_ASCII;
    pWhere[1] = 0;
    return pWhere + 2;
}

//*****************************************************************************
//************************ Known String Table *********************************
//*****************************************************************************

LPSTR mstatic_aszStrings[] = {
    ASCII_STRING_PREFIX "", // nothing for index 0
    ASCII_STRING_PREFIX "key", 
    ASCII_STRING_PREFIX "",
    ASCII_STRING_PREFIX "read", 
    ASCII_STRING_PREFIX "write",
    ASCII_STRING_PREFIX "volatile",
    ASCII_STRING_PREFIX "provider",
    ASCII_STRING_PREFIX "dynamic",
    ASCII_STRING_PREFIX "cimwin32",
    ASCII_STRING_PREFIX "DWORD",
    ASCII_STRING_PREFIX "CIMTYPE"
};
int mstatic_nNumStrings = 0;

int CKnownStringTable::GetKnownStringIndex(READ_ONLY LPCWSTR wszString)
    {
        if(mstatic_nNumStrings == 0) Initialize();
        for(int i = 1; i < mstatic_nNumStrings; i++)
        {
            if(CCompressedString::CompareUnicodeToAsciiNoCase(
                wszString,
                mstatic_aszStrings[i] + 1) == 0)
            {
                return i;
            }
        }
        return STRING_INDEX_UNKNOWN;
    }

INTERNAL CCompressedString& CKnownStringTable::GetKnownString(IN int nIndex)
    {
        if(mstatic_nNumStrings == 0) Initialize();
        return *(CCompressedString*)mstatic_aszStrings[nIndex];
    }

void CKnownStringTable::Initialize()
{
    mstatic_nNumStrings =  sizeof(mstatic_aszStrings) / sizeof(LPSTR);
/*
    for(int i = 1; i < mstatic_nNumStrings; i++)
    {
        // Set the first byte to STRING_FLAG_ASCII.
        // ========================================
        mstatic_aszStrings[i][0] = STRING_FLAG_ASCII;
    }
*/
}

//*****************************************************************************
//************************ Reserved Word Table *********************************
//*****************************************************************************

// IMPORTANT!!!!

// When adding new entries to the following list, ENSURE that they are correctly alphabetized
// or the binary searches will not work!

LPCWSTR CReservedWordTable::s_apwszReservedWords[] = {
    L"AMENDED",
    L"CLASS",
    L"DISABLEOVERRIDE",
    L"ENABLEOVERRIDE",
    L"INSTANCE",
    L"NOTTOINSTANCE",
    L"NOTTOSUBCLASS",
    L"OF",
    L"PRAGMA",
    L"QUALIFIER",
    L"RESTRICTED",
    L"TOINSTANCE",
    L"TOSUBCLASS",
};

// IMPORTANT!!!!

// When adding new entries to the following lists, ENSURE that they are correctly alphabetized
// or the binary searches will not work!  Also, be sure to add the new character to BOTH upper
// and lower case lists

LPCWSTR CReservedWordTable::s_pszStartingCharsUCase = L"ACDEINOPQRT";
LPCWSTR CReservedWordTable::s_pszStartingCharsLCase = L"acdeinopqrt";

BOOL CReservedWordTable::IsReservedWord( LPCWSTR pwcsName )
{
    BOOL    fFound = FALSE;

    if ( NULL != pwcsName && NULL != *pwcsName )
    {
        LPCWSTR pwszStartingChars = NULL;

        // See if we're even a character to worry about
        if ( *pwcsName >= 'A' && *pwcsName <= 'Z' )
        {
            pwszStartingChars = CReservedWordTable::s_pszStartingCharsUCase;
        }
        else if ( *pwcsName >= 'a' && *pwcsName <= 'z' )
        {
            pwszStartingChars = CReservedWordTable::s_pszStartingCharsLCase;
        }

        // Well at least it's a possibility, so binary search the list
        if ( NULL != pwszStartingChars )
        {
            int nLeft = 0,
                nRight = lstrlenW( pwszStartingChars )  - 1;

            BOOL    fFoundChar = FALSE;

            // Binary search the characters
            while(  !fFoundChar && nLeft < nRight )
            {
                
                int nNew = ( nLeft + nRight ) / 2;

                fFoundChar = ( pwszStartingChars[nNew] == *pwcsName );

                if ( !fFoundChar )
                {
                
                    // Check for > or <
                    if( pwszStartingChars[nNew] > *pwcsName )
                    {
                        nRight = nNew;
                    }
                    else 
                    {
                        nLeft = nNew + 1;
                    }

                }   // IF fFoundChar

            }   // While looking for character

            if ( !fFoundChar )
            {
                fFoundChar = ( pwszStartingChars[nLeft] == *pwcsName );
            }

            // Only search the list if we found a char
            if ( fFoundChar )
            {
                // Reset these
                nLeft = 0;
                nRight = ( sizeof(CReservedWordTable::s_apwszReservedWords) / sizeof(LPCWSTR) ) - 1;

                // Now Binary search the actual strings

                // Binary search the characters
                while(  !fFound && nLeft < nRight )
                {
                    int nNew = ( nLeft + nRight ) / 2;
                    int nCompare = wbem_wcsicmp(
                            CReservedWordTable::s_apwszReservedWords[nNew], pwcsName );

                    if ( 0 == nCompare )
                    {
                        fFound = TRUE;
                    }
                    else if ( nCompare > 0 )
                    {
                        nRight = nNew;
                    }
                    else 
                    {
                        nLeft = nNew + 1;
                    }

                }   // While looking string

                // Check last slot
                if ( !fFound )
                {
                    fFound = !wbem_wcsicmp(
                            CReservedWordTable::s_apwszReservedWords[nLeft], pwcsName );
                }

            }   // IF found character

        }   // IF we had a potential character set match

    }   // IF we got passed a reasonable string

    return fFound;
}

//*****************************************************************************
//************************ String Array    ************************************
//*****************************************************************************

void CFixedBSTRArray::Free()
{
    for(int i = 0; i < m_nSize; i++)
    {
        COleAuto::_SysFreeString(m_astrStrings[i]);
    }

    delete [] m_astrStrings;
    m_astrStrings = NULL;
    m_nSize = 0;
}

void CFixedBSTRArray::Create( int nSize )
{
    Free();
    
    m_astrStrings = new BSTR[nSize];

    // Check for allocation failure and throw an exception
    if ( NULL == m_astrStrings )
    {
        throw CX_MemoryException();
    }

    ZeroMemory( m_astrStrings, nSize * sizeof(BSTR) );
    
    m_nSize = nSize;
}

void CFixedBSTRArray::SortInPlace()
{
    int nIndex = 0;
    while(nIndex < GetLength()-1)
    {
        if(wbem_wcsicmp(GetAt(nIndex), GetAt(nIndex+1)) > 0)
        {
            BSTR strTemp = GetAt(nIndex);
            GetAt(nIndex) = GetAt(nIndex+1);
            GetAt(nIndex+1) = strTemp;

            if(nIndex > 0) nIndex--;
        }
        else nIndex++;
    }
}
/*
void CFixedBSTRArray::MergeOrdered(
                                   CFixedBSTRArray& a1, 
                                   CFixedBSTRArray& a2)
{
    // Create ourselves with the size which is the sum of theirs
    // =========================================================

    Create(a1.GetLength() + a2.GetLength());

    // Merge
    // =====

    int i1 = 0, i2 = 0, i = 0;

    while(i1 < a1.GetLength() && i2 < a2.GetLength())
    {
        CCompressedString* pcs1 = a1[i1];
        CCompressedString* pcs2 = a2[i2];

        int nCompare = pcs1->Compare(*pcs2);
        if(nCompare < 0)
        {
            GetAt(i++) = pcs1;
            i1++;
        }
        else if(nCompare > 0)
        {
            GetAt(i++) = pcs2;
            i2++;
        }
        else
        {
            GetAt(i++) = pcs1;
            i1++;
            i2++;
        }
    }

    // Copy whatever remains in whatever array
    // =======================================

    while(i1 < a1.GetLength())
    {
        GetAt(i++) = a1[i1++];
    }

    while(i2 < a2.GetLength())
    {
        GetAt(i++) = a2[i2++];
    }

    m_nSize = i;
}
*/

void CFixedBSTRArray::ThreeWayMergeOrdered(
                              CFixedBSTRArray& astrInclude1, 
                              CFixedBSTRArray& astrInclude2,
                              CFixedBSTRArray& astrExclude)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    try
    {
        // Create ourselves with the size which is the sum of theirs
        // =========================================================

        Create(astrInclude1.GetLength() + astrInclude2.GetLength());

        // Merge
        // =====

        int nIndexInc1 = 0, nIndexInc2 = 0, nIndexExc = 0, nIndexNew = 0;

        BSTR strInc;

        BOOL bEndInc1 = (nIndexInc1 == astrInclude1.GetLength());
        BOOL bEndInc2 = (nIndexInc2 == astrInclude2.GetLength());
        BOOL bEndExc = (nIndexExc == astrExclude.GetLength());

        while(!bEndInc1 || !bEndInc2)
        {
            // Find the smaller of the includes
            // ================================

            int nCompare;
            if(bEndInc1)
            {
                strInc = astrInclude2[nIndexInc2];
                nCompare = 1;
            }
            else if(bEndInc2)
            {
                strInc = astrInclude1[nIndexInc1];
                nCompare = -1;
            }
            else
            {
                nCompare = wbem_wcsicmp(astrInclude1[nIndexInc1],
                                  astrInclude2[nIndexInc2]);
                if(nCompare >= 0)
                {
                    strInc = astrInclude2[nIndexInc2];
                }
                else
                {
                    strInc = astrInclude1[nIndexInc1];
                }
            }

            // Check the exclude
            // =================

            while(!bEndExc && wbem_wcsicmp(astrExclude[nIndexExc], strInc) < 0)
            {
                nIndexExc++;
                bEndExc = (nIndexExc >= astrExclude.GetLength());
            }

            if(bEndExc || wbem_wcsicmp(astrExclude[nIndexExc], strInc) > 0)
            {
                // strInc is not excluded
                // ======================

                GetAt(nIndexNew++) = COleAuto::_SysAllocString(strInc);
            }
            else
            {
                // strInc is excluded
                // ==================
            
                nIndexExc++;
                bEndExc = (nIndexExc == astrExclude.GetLength());
            }

            if(nCompare <= 0)
            {
                nIndexInc1++;
                bEndInc1 = (nIndexInc1 == astrInclude1.GetLength());
            }

            if(nCompare >= 0)
            {
                nIndexInc2++;
                bEndInc2 = (nIndexInc2 == astrInclude2.GetLength());
            }
        }

        m_nSize = nIndexNew;
    }
    catch (CX_MemoryException)
    {
        // Cleanup and propagate the exception
        Free();
        throw;
    }
    catch (...)
    {
        // Cleanup and propagate the exception
        Free();
        throw;
    }

}

void CFixedBSTRArray::Filter( LPCWSTR pwcsStr, BOOL fFree /* = FALSE */ )
{

    // Make sure we have an array first
    if ( NULL != m_astrStrings )
    {
        // Walk the array, looking for exact matches to the filter.
        // If we find them we need to shrink the array
        for ( int x = 0; x < m_nSize; x++ )
        {
            if ( wbem_wcsicmp( pwcsStr, m_astrStrings[x] ) == 0 )
            {
                // Free the BSTR if appropriate
                if ( fFree )
                {
                    COleAuto::_SysFreeString( m_astrStrings[x] );
                }

                // Zero the pointer and copy memory from x+1 to the end of the array
                // in one block
                m_astrStrings[x]= NULL;
                CopyMemory( &m_astrStrings[x], &m_astrStrings[x+1],
                            ( m_nSize - x - 1 ) * sizeof(BSTR) );

                // Decrement size and x by 1
                m_nSize--;
                x--;

            }   // IF wbem_wcsicmp

        }   // FOR enum array elements

    }   // IF NULL != m_astrStrings

}

int CCompressedString::GetLength() const
{
    return sizeof(BYTE)+ 
        (GetStringLength()+1) * ((IsUnicode())?2:1);
}

int CCompressedString::GetStringLength() const
{
    return (IsUnicode()) ? 
        fast_wcslen(LPWSTR(GetRawData())) 
        : strlen(LPSTR(GetRawData()));
}

//*****************************************************************************
//
//  CCompressedString::ConvertToUnicode
//
//  Writes a UNICODE equivalent of self into a pre-allocated buffer
//
//  PARAMETERS:
//
//      [in, modified] LPWSTR wszDest   The buffer. Assumed to be large enough,
//
//*****************************************************************************
 
void CCompressedString::ConvertToUnicode(LPWSTR wszDest) const
{
    if(IsUnicode())
    {
        fast_wcscpy(wszDest, (LPWSTR)GetRawData());
    }
    else
    {
        WCHAR* pwc = wszDest;
        unsigned char* pc = (unsigned char*)LPSTR(GetRawData());
        while(*pc)
        {
            *(pwc++) = (WCHAR)(*(pc++));
        }
        *pwc = 0;
    }
}


WString CCompressedString::CreateWStringCopy() const
{
    if(IsUnicode())
    {
        int nLen = fast_wcslen(LPWSTR(GetRawData())) + 1;

        // This will throw an exception if this fails
        LPWSTR wszText = new WCHAR[nLen];

        if ( NULL == wszText )
        {
            throw CX_MemoryException();
        }

        // Copy using the helper
        fast_wcsncpy( wszText, LPWSTR(GetRawData()), nLen - 1 );

        return WString(wszText, TRUE);
    }
    else
    {
        int nLen = strlen(LPSTR(GetRawData())) + 1;

        // This will throw an exception if this fails
        LPWSTR wszText = new WCHAR[nLen];

        if ( NULL == wszText )
        {
            throw CX_MemoryException();
        }

        ConvertToUnicode(wszText);
        return WString(wszText, TRUE);
    }
}

SYSFREE_ME BSTR CCompressedString::CreateBSTRCopy() const
{
    // We already have LOTS of code that handles NULL returns from
    // here, so catch the exception and return a NULL.

    try
    {
        if(IsUnicode())
        {
            int nLen = fast_wcslen(LPWSTR(GetRawData()));

            BSTR strRet = COleAuto::_SysAllocStringLen(NULL, nLen);

            // Check that the SysAlloc succeeded
            if ( NULL != strRet )
            {
                fast_wcsncpy( strRet, LPWSTR(GetRawData()), nLen );
            }

            return strRet;
        }
        else
        {
            int nLen = strlen(LPSTR(GetRawData()));
            BSTR strRet = COleAuto::_SysAllocStringLen(NULL, nLen);

            // Check that the SysAlloc succeeded
            if ( NULL != strRet )
            {
                ConvertToUnicode(strRet);
            }

            return strRet;
        }
    }
    catch (CX_MemoryException)
    {
        return NULL;
    }
    catch (...)
    {
        return NULL;
    }
}

int CCompressedString::ComputeNecessarySpace(
                                           READ_ONLY LPCSTR szString)
{
    return sizeof(BYTE) + strlen(szString) + 1;
}

int CCompressedString::ComputeNecessarySpace(
                                           READ_ONLY LPCWSTR wszString)
{
    if(IsAsciiable(wszString))
    {
        return sizeof(BYTE) + fast_wcslen(wszString) + 1;
    }
    else
    {
        return sizeof(BYTE) + (fast_wcslen(wszString) + 1) * 2;
    }
}

//*****************************************************************************
//
//  static CCompressedString::IsAsciiable
//
//  Determines if a given UNICODE string is actually ASCII (or, to be more
//  precise, if all characters are between 0 and 255).
//
//  PARAMETERS:
//
//      [in, readonly] LPCWSTR wszString    the string to examine
//
//  RETURNS:
//
//      BOOL    TRUE iff asciiable.
//
//*****************************************************************************

BOOL CCompressedString::IsAsciiable(LPCWSTR wszString)
{
    WCHAR *pwc = (WCHAR*)wszString;
    while(*pwc)
    {
        if(UpperByte(*pwc) != 0) return FALSE;
        pwc++;
    }
    return TRUE;
}

void CCompressedString::SetFromUnicode(COPY LPCWSTR wszString)
{
    if(IsAsciiable(wszString))
    {
        m_fFlags = STRING_FLAG_ASCII;
        const WCHAR* pwc = wszString;
        char* pc = LPSTR(GetRawData());
        while(*pwc)
        {
            *(pc++) = LowerByte(*(pwc++));
        }
        *pc = 0; 
    }
    else
    {
        m_fFlags = STRING_FLAG_UNICODE;
        fast_wcscpy(LPWSTR(GetRawData()), wszString);
    }
}

void CCompressedString::SetFromAscii(COPY LPCSTR szString)
{
    m_fFlags = STRING_FLAG_ASCII;
    strcpy(LPSTR(GetRawData()), szString);
}

int CCompressedString::Compare(
              READ_ONLY const CCompressedString& csOther) const
{
    return (csOther.IsUnicode())?
        Compare(LPWSTR(csOther.GetRawData())):
        Compare(LPSTR(csOther.GetRawData()));
}

int CCompressedString::Compare(READ_ONLY LPCWSTR wszOther) const
{
    return (IsUnicode())?
        wcscmp((LPCWSTR)GetRawData(), wszOther):
        - CompareUnicodeToAscii(wszOther, (LPCSTR)GetRawData());
}

int CCompressedString::Compare(READ_ONLY LPCSTR szOther) const
{
    return (IsUnicode())?
        CompareUnicodeToAscii((LPCWSTR)GetRawData(), szOther):
        strcmp((LPCSTR)GetRawData(), szOther);
}

int CCompressedString::CompareUnicodeToAscii( UNALIGNED const wchar_t* wszFirst,
                                                    LPCSTR szSecond)
{
    UNALIGNED const WCHAR* pwc = wszFirst;
    const unsigned char* pc = (const unsigned char*)szSecond;
    while(*pc)
    {        
        if(*pwc != (WCHAR)*pc)
        {
            return (int)*pwc - (int)*pc;
        }
        pc++; pwc++;
    }
    return (*pwc)?1:0;
}

int CCompressedString::CompareNoCase(
                            READ_ONLY const CCompressedString& csOther) const
{
    return (csOther.IsUnicode())?
        CompareNoCase((LPCWSTR)csOther.GetRawData()):
        CompareNoCase((LPCSTR)csOther.GetRawData());
}

int CCompressedString::CompareNoCase(READ_ONLY LPCSTR szOther) const
{
    return (IsUnicode())?
        CompareUnicodeToAsciiNoCase((LPCWSTR)GetRawData(), szOther):
        wbem_ncsicmp((LPCSTR)GetRawData(), szOther);
}

int CCompressedString::CompareNoCase(READ_ONLY LPCWSTR wszOther) const
{
    return (IsUnicode())?
        wbem_unaligned_wcsicmp((LPCWSTR)GetRawData(), wszOther):
        - CompareUnicodeToAsciiNoCase(wszOther, (LPCSTR)GetRawData());
}

int CCompressedString::CheapCompare(
                             READ_ONLY const CCompressedString& csOther) const
{
    if(IsUnicode())
    {
        if(csOther.IsUnicode())
            return wbem_unaligned_wcsicmp((LPCWSTR)GetRawData(), 
                                (LPCWSTR)csOther.GetRawData());
        else
            return CompareUnicodeToAscii((LPCWSTR)GetRawData(), 
                                          (LPCSTR)csOther.GetRawData());
    }
    else
    {
        if(csOther.IsUnicode())
            return -CompareUnicodeToAscii((LPCWSTR)csOther.GetRawData(), 
                                           (LPCSTR)GetRawData());
        else
            return wbem_ncsicmp((LPCSTR)GetRawData(), 
                                (LPCSTR)csOther.GetRawData());
    }
}

int CCompressedString::CompareUnicodeToAsciiNoCase( UNALIGNED const wchar_t* wszFirst,
                                                    LPCSTR szSecond,
                                                    int nMax)
{
    UNALIGNED const WCHAR* pwc = wszFirst;
    const unsigned char* pc = (const unsigned char*)szSecond;
    while(nMax-- && (*pc || *pwc))
    {        
        int diff = wbem_towlower(*pwc) - wbem_towlower(*pc);
        if(diff) return diff;
        pc++; pwc++;
    }
    return 0;
}

BOOL CCompressedString::StartsWithNoCase(READ_ONLY LPCWSTR wszOther) const
{
    if(IsUnicode())
    {
        return wbem_unaligned_wcsnicmp((LPWSTR)GetRawData(), wszOther, 
									fast_wcslen(wszOther)) == 0;
    }
    else
    {
        return CompareUnicodeToAsciiNoCase(wszOther, (LPSTR)GetRawData(), 
                fast_wcslen(wszOther)) == 0;
    }
}


BOOL CCompressedString::StoreToCVar(CVar& Var) const
{
    BSTR    str = CreateBSTRCopy();

    // Check that the allocation does not fail.
    if ( NULL != str )
    {
        return Var.SetBSTR( str, TRUE); // acquire
    }

    return FALSE;

/* THIS WOULD BE MUCH MORE EFCICIENT!!!!!
    if(IsUnicode())
    {
        Var.SetLPWSTR((LPWSTR)GetRawData(), TRUE); // don't copy
    }
    else
    {
        Var.SetLPSTR((LPSTR)GetRawData(), TRUE); // don't copy
    }

    Var.SetCanDelete(FALSE);
*/
}

void CCompressedString::MakeLowercase()
{
    if(IsUnicode())
    {
        WCHAR* pwc = (LPWSTR)GetRawData();
        while(*pwc)
        {
            *pwc = wbem_towlower(*pwc);
            pwc++;
        }
    }
    else
    {
        char* pc = (LPSTR)GetRawData();
        while(*pc)
        {
            *pc = (char)wbem_towlower(*pc);
            pc++;
        }
    }
}

// The following functions are designed to work even under circumstances
// in which the source and destination strings are not aligned on even
// byte boundaries (which is something that could easily happen with the
// fastobj code).  For now, I'm passing all wchar operations here, although
// we may find that for performance we may need to be abit more selective
// about when we call these functions and when we don't
        
int CCompressedString::fast_wcslen( LPCWSTR wszString )
{
    BYTE*   pbData = (BYTE*) wszString;

    // Walk the string looking for two 0 bytes next to each other.
    for( int i =0; !(!*(pbData) && !*(pbData+1) ); pbData+=2, i++ );

    return i;
}

WCHAR* CCompressedString::fast_wcscpy( WCHAR* wszDest, LPCWSTR wszSource )
{
    int nLen = fast_wcslen( wszSource );

    // Account for the NULL terminator when copying
    CopyMemory( (BYTE*) wszDest, (BYTE*) wszSource, (nLen+1) * 2 );

    return wszDest;
}

WCHAR* CCompressedString::fast_wcsncpy( WCHAR* wszDest, LPCWSTR wszSource, int nNumChars )
{
    // Account for the NULL terminator when copying
    CopyMemory( (BYTE*) wszDest, (BYTE*) wszSource, (nNumChars+1) * 2 );

    return wszDest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastsys.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSYS.H

Abstract:

  This file defines the classes related to system properties.

  Classes defined: 
      CSystemProperties   System property information class.

History:

  2/21/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_SYSPROP__H_
#define __FAST_SYSPROP__H_

#include "parmdefs.h"
#include <wbemidl.h>
#include "wbemstr.h"

//#pragma pack(push, 1)

// This is the maximum number of user-defined properties
#define MAXNUM_USERDEFINED_PROPERTIES	1024

//*****************************************************************************
//*****************************************************************************
//
//  class CSystemProperties
//
//  This class contains the information about the names and types of all 
//  system properties. All its data members and methods are static.
//
//*****************************************************************************
//
//  static GetNumSystemProperties
//
//  Returns:
//
//      int: the number of systsm properties currently defined
//
//*****************************************************************************
//
//  static GetNumDecorationIndependentProperties
//
//  Returns:
//
//      int: the number of system properties that do not depend on the object's
//          decoration. For instance, __SERVER is NOT such a property.
//
//*****************************************************************************
//
//  static GetNameAsBSTR
//
//  Retrives a system property name as a newely allocated BSTR.
//
//  Parameters:
//
//      int nIndex      The index of the system property, taken from the 
//                      e_SysProp... list.
//  Returns:
//
//      BSTR: containing the property name. This BSTR MUST be freed 
//              (SysFreeString) by the caller.
//
//*****************************************************************************
//
//  static GetPropertyType
//
//  Returns complete type information for a system property.
//
//  Parameters:
//
//      [in] LPCWSTR wszName        The name of the system property.
//      [out] long* plType          Destination for the type of the property,
//                                  e.g. VT_BSTR. May be NULL if not required.
//      [out] long* plFlavor        Destination for the flavor of the property.
//                                  At this time, all system properties are of
//                                  the WBEM_FLAVOR_ORIGIN_SYSTEM flavor.
//                                  May be NULL if not required.
//  Returns:
//
//      HRESULT:    
//          WBEM_S_NO_ERROR        on success
//          WBEM_E_NOT_FOUND       no such system property.
//                  
//*****************************************************************************
//
//  static FindName
//
//  Returns the index of a system property based on its name
//  
//  Parameters:
//
//      [in] LPCWSTR wszName        The name of the system property.
//      
//  Returns:
//
//      HRESULT:    
//          WBEM_S_NO_ERROR        on success
//          WBEM_E_NOT_FOUND       no such system property.
//                  
//*****************************************************************************

class COREPROX_POLARITY CSystemProperties
{

public:
    enum 
    {
        e_SysProp_Genus = 1,
        e_SysProp_Class,
        e_SysProp_Superclass,
        e_SysProp_Dynasty,
        e_SysProp_Relpath,
        e_SysProp_PropertyCount,
        e_SysProp_Derivation,

        e_SysProp_Server,
        e_SysProp_Namespace,
        e_SysProp_Path

    };

    static int GetNumSystemProperties();
    //static int GetNumExtProperties();
    static int MaxNumProperties();
    static inline int GetNumDecorationIndependentProperties() 
    {
        return 7;
    }

    static SYSFREE_ME BSTR GetNameAsBSTR(int nIndex);

    static int FindName(READ_ONLY LPCWSTR wszName);
/*
    static int FindExtPropName(READ_ONLY LPCWSTR wszName);
    static int FindExtDisplayName(READ_ONLY LPCWSTR wszName);
	static BOOL IsExtProperty(READ_ONLY LPCWSTR wszName);
	static LPCWSTR GetExtDisplayFromExtPropName(READ_ONLY LPCWSTR wszName);
	static LPCWSTR GetExtPropNameFromExtDisplay(READ_ONLY LPCWSTR wszName);
    static LPCWSTR GetExtDisplayName( int nIndex );
    static LPCWSTR GetExtPropName( int nIndex );
	static LPCWSTR GetExtPropName(READ_ONLY LPCWSTR wszName);
    static BSTR GetExtDisplayNameAsBSTR( int nIndex );

	static BOOL IsExtTimeProp( READ_ONLY LPCWSTR wszName );
*/
    static HRESULT GetPropertyType(READ_ONLY LPCWSTR wszName, 
        OUT CIMTYPE* pctType, OUT long* plFlags)
    {
        int nIndex = FindName(wszName);
        if(nIndex >= 0)
        {
            if(plFlags) 
            {
                *plFlags = WBEM_FLAVOR_ORIGIN_SYSTEM;
            }
            if(pctType)
            {
                if(nIndex == e_SysProp_Genus || 
                    nIndex == e_SysProp_PropertyCount)
                {
                    *pctType = CIM_SINT32;
                }
                else if(nIndex == e_SysProp_Derivation)
                {
                    *pctType = CIM_STRING | CIM_FLAG_ARRAY;
                }
                else
                {
                    *pctType = CIM_STRING;
                }
            }
            return WBEM_S_NO_ERROR;
        }
        else return WBEM_E_NOT_FOUND;
    }

	static BOOL IsPossibleSystemPropertyName(READ_ONLY LPCWSTR wszName);
    static BOOL IsIllegalDerivedClass(READ_ONLY LPCWSTR wszName);
};

//#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastsys.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSYS.CPP

Abstract:

  This file implements the classes related to system properties.
  See fastsys.h for all documentation.

  Classes implemented: 
      CSystemProperties   System property information class.

History:

  2/21/97     a-levn  Fully documented

--*/

#include "precomp.h"
//#include <dbgalloc.h>

#include "fastsys.h"
#include "strutils.h"
#include "olewrap.h"
#include "arena.h"

//******************************************************************************
//
//  See fastsys.h for documentation
//
//******************************************************************************
LPWSTR m_awszPropNames[] =
{
    /*0*/ L"", // nothing at index 0
    /*1*/ L"__GENUS",
    /*2*/ L"__CLASS",
    /*3*/ L"__SUPERCLASS",
    /*4*/ L"__DYNASTY",
    /*5*/ L"__RELPATH",
    /*6*/ L"__PROPERTY_COUNT",
    /*7*/ L"__DERIVATION",

    /*8*/ L"__SERVER",
    /*9*/ L"__NAMESPACE",
    /*10*/L"__PATH",
};


//LPWSTR m_awszExtPropNames[] =
//{
//    /*0*/ L"", // nothing at index 0
//    /*1*/ L"__TC",
//    /*2*/ L"__TM",
//    /*3*/ L"__TE",
//    /*4*/ L"__SD"
//};

//LPWSTR m_awszExtDisplayNames[] =
//{
//    /*0*/ L"", // nothing at index 0
//    /*1*/ L"__TCREATED",
//    /*2*/ L"__TMODIFIED",
//    /*3*/ L"__TEXPIRATION",
//    /*4*/ L"__SECURITY_DESCRIPTOR"
//};

// System classes that aren't allowed to reproduce.

LPWSTR m_awszDerivableSystemClasses[] =
{
	L"__Namespace",
	L"__Win32Provider",
	L"__ExtendedStatus",
	L"__EventConsumer",
	L"__ExtrinsicEvent"
};


//******************************************************************************
//
//  See fastsys.h for documentation
//
//******************************************************************************
int CSystemProperties::GetNumSystemProperties() 
{
    return sizeof(m_awszPropNames) / sizeof(LPWSTR) - 1;
}

SYSFREE_ME BSTR CSystemProperties::GetNameAsBSTR(int nIndex)
{
        return COleAuto::_SysAllocString(m_awszPropNames[nIndex]);
}

int CSystemProperties::FindName(READ_ONLY LPCWSTR wszName)
{
        int nNumProps = GetNumSystemProperties();
        for(int i = 1; i <= nNumProps; i++)
        {
            if(!wbem_wcsicmp(wszName, m_awszPropNames[i])) return i;
        }

        return -1;
}
/*
int CSystemProperties::GetNumExtProperties() 
{
    return sizeof(m_awszExtPropNames) / sizeof(LPWSTR) - 1;
}

int CSystemProperties::FindExtPropName(READ_ONLY LPCWSTR wszName)
{
    int nNumProps = GetNumExtProperties();
    for(int i = 1; i <= nNumProps; i++)
    {
        if(!wbem_wcsicmp(wszName, m_awszExtPropNames[i])) return i;
    }

    return -1;
}

int CSystemProperties::FindExtDisplayName(READ_ONLY LPCWSTR wszName)
{
    int nNumProps = GetNumExtProperties();
    for(int i = 1; i <= nNumProps; i++)
    {
        if(!wbem_wcsicmp(wszName, m_awszExtDisplayNames[i])) return i;
    }

    return -1;
}

LPCWSTR CSystemProperties::GetExtPropName(READ_ONLY LPCWSTR wszName)
{
	if ( L'_' == wszName[0] )
	{
		int nExtProp = FindExtDisplayName( wszName );

		if ( nExtProp > 0 )
		{
			return m_awszExtPropNames[nExtProp];
		}
	}

	// Just return the name passed into us
	return wszName;

}

LPCWSTR CSystemProperties::GetExtDisplayFromExtPropName(READ_ONLY LPCWSTR wszName)
{
	int nExtProp = FindExtPropName( wszName );

	if ( nExtProp > 0 )
	{
		return m_awszExtDisplayNames[nExtProp];
	}
	else
	{
		return NULL;
	}
}

LPCWSTR CSystemProperties::GetExtPropNameFromExtDisplay(READ_ONLY LPCWSTR wszName)
{
	int nExtProp = FindExtDisplayName( wszName );

	if ( nExtProp > 0 )
	{
		return m_awszExtPropNames[nExtProp];
	}
	else
	{
		return NULL;
	}
}

LPCWSTR CSystemProperties::GetExtDisplayName( int nIndex )
{
	return m_awszExtDisplayNames[nIndex];
}

LPCWSTR CSystemProperties::GetExtPropName( int nIndex )
{
	return m_awszExtPropNames[nIndex];
}

BSTR CSystemProperties::GetExtDisplayNameAsBSTR( int nIndex )
{
	return COleAuto::_SysAllocString(m_awszExtDisplayNames[nIndex]);
}
*/

int CSystemProperties::MaxNumProperties() 
{
    return MAXNUM_USERDEFINED_PROPERTIES; // + GetNumExtProperties();
}

/*
BOOL CSystemProperties::IsExtProperty(READ_ONLY LPCWSTR wszName)
{
	BOOL	fReturn = FALSE;

	// Check if it's even remotely possible it's a system property
	// (must start with a '_'.
	if ( L'_' == wszName[0] )
	{
		fReturn = ( ( FindExtPropName( wszName ) > 0 ) || ( FindExtDisplayName( wszName ) > 0 ) );
	}

	return fReturn;
}
*/

BOOL CSystemProperties::IsPossibleSystemPropertyName(READ_ONLY LPCWSTR wszName)
{
	return ((*wszName == L'_')); 
}
/*
BOOL CSystemProperties::IsExtTimeProp( READ_ONLY LPCWSTR wszName )
{
	BOOL	fReturn = FALSE;

	// If it's an extended system property, get the name, and from there
	// the index.  If it's in the first 3, then it's one of the time
	// properties.

	if ( IsExtProperty( wszName ) )
	{
		LPCWSTR pwszExtName = GetExtPropName( wszName );

		int	nIndex = FindExtPropName( pwszExtName );

		fReturn = ( nIndex >= 1 && nIndex <= 3 );
	}

	return fReturn;
}
*/

BOOL CSystemProperties::IsIllegalDerivedClass(READ_ONLY LPCWSTR wszName)
{
    BOOL bRet = FALSE;
    BOOL bFound = FALSE;
    DWORD dwNumSysClasses = sizeof(m_awszDerivableSystemClasses) / sizeof(LPWSTR)-1;

    // If this isn't a system class, skip it.

    if (wszName[0] != L'_')
        bRet = FALSE;
    else
    {
        bRet = TRUE;
        for (int i = 0; i <= dwNumSysClasses; i++)
        {
            if (!wbem_wcsicmp(wszName, m_awszDerivableSystemClasses[i]))
            {
                bFound = TRUE;
                bRet = FALSE;
                break;
            }
        }
    }
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\faststr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSTR.H

Abstract:

  This file defines the classes related to string processing in WbemObjects.

  Classes defined: 
      CCompressedString   Represents an ascii or unicode string.
      CKnownStringTable   The table of strings hard-coded into WINMGMT for
                          compression.
      CFixedBSTRArray     An array of BSTRs capable of sophisticated merges.

History:

  2/20/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_STRINGS__H_
#define __FAST_STRINGS__H_

#include "corepol.h"
#include "fastsprt.h"
#include <stdio.h>
#include "arena.h"
#include "var.h"
#include "wstring.h"

// see fastsprt.h for explanation
#pragma pack(push, 1)

typedef enum 
{
    /*
        These flags preceed every string on the "heap". Uniqueness is not used
        at this time --- all string are unique
    */
    STRING_FLAG_ASCII = 0,
    STRING_FLAG_UNICODE = 0x1,
} FStringFlags;

#define ASCII_STRING_PREFIX "\000"

class CFastHeap;

//*****************************************************************************
//*****************************************************************************
//
//  class CCompressedString
//
//  The purpose of this class is to compress UNICODE strings which are actually
//  ASCII (and therefore consist of 1/2 zeros). This is done by representing
//  every string by a flag byte followed by either a UNICODE string (if the 
//  flag byte is STRING_FLAG_UNICODE) or an ASCII string (if the flag byte is
//  STRING_FLAG_ASCII).
//
//  As with many other CWbemObject-related classes, its this pointer points to
//  the actual data. Thus the actual characters start immediately after 
//  m_fFlags.
//
//  Here's how one might create such an object:
//
//      WCHAR wszText[] = L"My String";
//      LPMEMORY pBuffer = new BYTE[
//            CCompressedString::ComputeNecessarySpace(wszText)];
//      CCompressedString* pString = (CCompressedString*)pBuffer;
//      pString->SetFromUnicode(wszText);
//
//************************ TMovable interface *********************************
//
//  GetStart
//
//  RETURNS:
//
//      LPMEMORY pointing to the beginning of the memory block (the flags).
//
//*****************************************************************************
//
//  GetLength
//
//  RETURNS:
//
//      int containing the number of bytes in the representation (not the 
//          string length).
//
//************************* Public interface **********************************
//
//  GetStringLength
//
//  RETURNS:
//
//      int the number of characters in the string (whether UNICODE or ASCII).
//
//*****************************************************************************
//
//  CreateBSTRCopy
//
//  RETURNS:
//
//      BSTR containing the string. This BSTR is newely allocated using 
//          SysAllocString and must be SysFreeString'ed by the caller.
//
//*****************************************************************************
//
//  CreateWStringCopy
//
//  RETURNS:
//
//      WString (see wstring.h) containg the string. The object itself is
//          returned, so no freeing is required.
//
//*****************************************************************************
//
//  Compare
//
//  Compares this string to another. It has three calling methods:
//
//  Parameters I:
//
//      [in, readonly] const CCompressedString& Other
//
//  Parameters II:
//
//      [in, readonly] LPSTR szOther
//
//  Parameters III:
//
//      [in, readonly] LPWSTR wszOther
//
//  RETURNS:
//
//      0  of the strings are the same.
//      <0 if this lexicographically preceeds the other
//      >0 if this lexicographically follows the other
//
//*****************************************************************************
//
//  CompareNoCase
//
//  Exactly the same as Compare (above), except that comparison is performed
//  case-insensitively.
//
//*****************************************************************************
//
//  StartsWithNoCase
//
//  Verifies if the given string is a prefix of ours (in a case-inseinsitive
//  way).
//
//  PARAMETERS:
//
//      [in, readonly]
//          LPCWSTR wszOther    the string whose prefixness ww want to check.
//
//  RETURNS:
//
//      BOOL        TRUE iff it is a prefix
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the amount of space that will be required to store a given string.
//  This amount depends on whether the string can be compressed into ASCII.
//
//  See SetFromAscii and SetFromUnicode on what to do next.
//
//  Parameters I:
//
//      [in, readonly] LPCWSTR wszString
//
//  Parameters II:
//
//      [in, readonly] LPCSTR szString
//
//  RETURNS:
//
//      int:    the nuumber of bytes required.
//
//*****************************************************************************
//
//  SetFromUnicode
//
//  Stores a UNICODE string into itself. It is assumed that the buffer 'this'
//  is pointing to is large enough to hold the string.
//
//  PARAMETERS:
//
//      [in, readonly] LPCWSTR wszString
//
//*****************************************************************************
//
//  SetFromAscii
//
//  Stores a ASCII string into itself. It is assumed that the buffer 'this'
//  is pointing to is large enough to hold the string.
//
//  PARAMETERS:
//
//      [in, readonly] LPCSTR szString
//
//*****************************************************************************
//
//  MakeLowercase
//
//  Performs an in-place conversion to lower case.
//
//*****************************************************************************
//
//  StoreToCVar
//
//  Transfers its contents into a CVar (var.h). The CVar will have the type of
//  VT_BSTR and will contain a fresh BSTR copy of the string. More efficient
//  mechanism is possible, but requires a change in CVar logic which is not
//  feasible at this time.
//
//  PARAMETERS:
//
//      [in, created] CVar& Var     Destination. Assumed to be empty.
//
//*****************************************************************************
//
//  static CopyToNewHeap
//
//  Given a heap offset a CCompressedString on one heap, makes a copy of the 
//  string on another heap and returns the new offset.
//
//  PARAMETERS:
//
//      [in] heapptr_t ptrOldString     The offset of the string on the old
//                                      heap.
//      [in, readonly] 
//          CFastHeap* pOldHeap         The heap to read from.
//      [in, modified]
//          CFastHeap* pNewHeap         The heap to write to.
//
//  RETURNS:
//
//      heapptr_t   the offset on the pNewHeap where the copy of the string is.
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty string on a given block of memory.
//
//  PARAMETERS:
//
//     LPMEMORY pWhere          Destination block.
// 
//  RETURN VALUES:
//
//      LPMEMORY:   points to the first character after the data written.
//
//*****************************************************************************
//
//  static fast_wcslen
//
//  Performs a wcslen operation but it shouldn't throw an exception
//	or cause an AV on systems that are expecting aligned buffers.
//
//  PARAMETERS:
//
//     WCHAR*	pwszString - String to get length of
// 
//  RETURN VALUES:
//
//     Length of the string without a terminating NULL.
//
//*****************************************************************************
//
//  static fast_wcscpy
//
//  Copies WCHAR string from source buffer to destination buffer.  We have to
//	do this in a way which will not cause faults or exceptions for non-aligned
//	buffers
//
//  PARAMETERS:
//
//		WCHAR*	pwszDestination - Destination buffer.
//		LPCWSTR	pwszSource - Source buffer,
// 
//  RETURN VALUES:
//
//     Pointer to the destination buffer.
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty string on a given block of memory.
//
//  PARAMETERS:
//
//     LPMEMORY pWhere          Destination block.
// 
//  RETURN VALUES:
//
//      LPMEMORY:   points to the first character after the data written.
//
//*****************************************************************************

class COREPROX_POLARITY CCompressedString
{
private:
    BYTE m_fFlags;
    // followed by either a unicode or an ASCII string
    BYTE m_cFirstByte; // just a place holder
public:
    INTERNAL LPMEMORY GetStart() {return LPMEMORY(this);}
    int GetLength() const;

protected:
public:
    int GetStringLength() const;

    SYSFREE_ME BSTR CreateBSTRCopy() const;
    NEW_OBJECT WString CreateWStringCopy() const;

    int Compare(READ_ONLY const CCompressedString& csOther) const;
    int Compare(READ_ONLY LPCWSTR wszOther) const;
    int Compare(READ_ONLY LPCSTR szOther) const;

    int CompareNoCase(READ_ONLY const CCompressedString& csOther) const;
    int CompareNoCase(READ_ONLY LPCWSTR wszOther) const;
    int CompareNoCase(READ_ONLY LPCSTR szOther) const;

    int CheapCompare(READ_ONLY const CCompressedString& csOther) const;

    BOOL StartsWithNoCase(READ_ONLY LPCWSTR wszOther) const;
public:
    static int ComputeNecessarySpace(READ_ONLY LPCWSTR wszString);
    static int ComputeNecessarySpace(READ_ONLY LPCSTR szString);

    void SetFromUnicode(COPY LPCWSTR wszString);
    void SetFromAscii(COPY LPCSTR szString);
    void MakeLowercase();

    BOOL IsUnicode() const {return (m_fFlags == STRING_FLAG_UNICODE);}
    INTERNAL LPMEMORY GetRawData() const 
        {return (LPMEMORY)&m_cFirstByte;}
public:
    BOOL StoreToCVar(NEW_OBJECT CVar& Var) const;

	// Trap whether or not anyone calls this
    BOOL TranslateToNewHeap(CFastHeap* pOldHeap, CFastHeap* pNewHeap){ return FALSE; }

    static BOOL CopyToNewHeap(heapptr_t ptrOldString,
        READ_ONLY CFastHeap* pOldHeap, MODIFIED CFastHeap* pNewHeap,
		UNALIGNED heapptr_t& ptrResult);
    static LPMEMORY CreateEmpty(LPMEMORY pWhere);

    void ConvertToUnicode(LPWSTR wszDest) const;

	static int fast_wcslen( LPCWSTR wszString );
	static WCHAR* fast_wcscpy( WCHAR* wszDest, LPCWSTR wszSource );
	static WCHAR* fast_wcsncpy( WCHAR* wszDest, LPCWSTR wszSource, int nNumChars );

protected:
    static char LowerByte(WCHAR w) {return w & 0xFF;}
    static char UpperByte(WCHAR w) {return w >> 8;}
    static BOOL IsAsciiable(READ_ONLY LPCWSTR wszString);

    static int CompareUnicodeToAscii( UNALIGNED const wchar_t* wszFirst, 
                                            READ_ONLY LPCSTR szSecond);

    static int CompareUnicodeToAsciiNoCase( UNALIGNED const wchar_t* wszFirst, 
                                                  READ_ONLY LPCSTR szSecond,
                                                    int nMax = 0x7000000);

    friend class CKnownStringTable;
    friend class CFixedBSTRArray;
};




//*****************************************************************************
//*****************************************************************************
//
//  class CKnownStringTable
//
//  This class represents a table of strings hard-coded into WINMGMT. Certain 
//  strings that appear very often are represented in objects simply as indeces
//  into this table, thus saving valuable space.
//
//  All the data and memeber functions in this class are static.
//
//*****************************************************************************
//
//  static Initialize
//
//  While the strings are specified as an array of LPSTR in the source code,
//  they are actually stored as CCompressedString's so as to be able to return 
//  their CCompressedString representations very fast. Initialize performs the
//  conversion (USING INSIDER KNOWLEDGE OF CCompressedString CLASS!)
//
//*****************************************************************************
//
//  static GetKnownStringIndex
//
//  Searches for a (UNICODE) string and returns its index in the table if found.
//  
//  PARAMETERS:
//
//      [in, readonly] LPCWSTR wszString    The string to look for.
//  
//  RETURNS:
//
//      int     If found, it is the index of the string (1 or larger).
//              If not found, it is STRING_INDEX_UNKNOWN (< 0)
//
//*****************************************************************************
//
//  GetIndexOfKey
//
//  Returns the index of "key" in the table.
//
//*****************************************************************************
//
//  GetKnownString
//
//  Returns the string at a given index.
//
//  PARAMETERS:
//
//      [in] int nIndex     The index of the string to retrieve (1 or larger)
//
//  RETURNS:
//
//      CCompressedString*  The pointer to the string. This pointer is internal
//                          and must NOT be deleted or modified by the called.
//
//*****************************************************************************


#define STRING_INDEX_UNKNOWN -1


class COREPROX_POLARITY CKnownStringTable
{

public:
    static void Initialize();
    static int GetKnownStringIndex(READ_ONLY LPCWSTR wszString);

    static int GetIndexOfKey() 
        {return /**!!!!!**/ 1;}
    static INTERNAL CCompressedString& GetKnownString(IN int nIndex);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CReservedWordTable
//
//  This class represents a table of strings hard-coded into WINMGMT. These
//	strings are reserved words which for various reasons we need to verify
//	before allowing users to set.
//
//  All the data and memeber functions in this class are static.
//
//*****************************************************************************
//
//  static Initialize
//
//  Sets up member data
//
//*****************************************************************************
//
//  static IsReservedWord
//
//  Searches for a (UNICODE) string in our list and returns whether or not
//	we found it.
//  
//  RETURNS:
//
//      bool	If found TRUE.
//
//*****************************************************************************


#define STRING_INDEX_UNKNOWN -1


class COREPROX_POLARITY CReservedWordTable
{
private:
	static LPCWSTR	s_apwszReservedWords[];
	static LPCWSTR	s_pszStartingCharsUCase;
	static LPCWSTR	s_pszStartingCharsLCase;

public:
    static BOOL IsReservedWord(READ_ONLY LPCWSTR wszString);

};

//*****************************************************************************
//*****************************************************************************
//
//  class CFixedBSTRArray
//
//  This class represents a fixed-sized array of BSTRs. Its purpose in life
//  is to implement a sophisticated merge function on itself.
//
//*****************************************************************************
//
//  Create
//
//  Creates an array of a given size. The size cannot be changed during the 
//  array's lifetime. 
//
//  PARAMETERS:
//
//      int nSize
//
//*****************************************************************************
//
//  Free
//
//  Destroys the array, deallocating all the BSTRs.
//
//*****************************************************************************
//
//  GetLength
//
//  RETURNS:
//
//      int:    the number of elements in the array
//
//*****************************************************************************
//
//  GetAt
//
//  Retrieves the BSTR at ta given index.
//
//  PARAMETERS:
//
//      int nIndex
//
//  RETURNS:
//
//      BSTR at the desired index. This is NOT a copy, so the caller must NOT
//          deallocate it.
//
//*****************************************************************************
//
//  SortInPlace
//
//  Sorts the array lexicographically in a case-insensitive manner. Bubble-sort
//  is used at this time.
//
//*****************************************************************************
//
//  Filter
//
//  Filters the supplied string from the local BSTR array.  Frees located
//	elements as necessary.
//
//  PARAMETERS:
//
//      wchar_t*	pwcsStr - String to filter out
//		BOOL		fFree - Free string if found (FALSE)
//
//*****************************************************************************
//
//  ThreeWayMergeOrdered
//
//  The reason for this class's existence. Takes three already ordered arrays
//  of BSTRs (acsInculde1, acsInclude2 and acsExclude) and produces (inside
//  itself) an array of all BSTRs A such that:
//
//      ((A appears in ascInclude1) OR (A appears in ascInclude2)) 
//      AND
//      NOT (A appears in acsExclude)
//
//  and does it reasonable fast.
//
//  PARAMETERS:
//
//      CFixedBSTRArray& acsInclude1    Include these strings unless found in
//                                      acsExclude.
//      CFixedBSTRArray& acsInclude2    Include these strings unless found in
//                                      acsExclude.
//      CFixedBSTRArray& acsExclude     Exclude these strings.
//
//*****************************************************************************

class COREPROX_POLARITY CFixedBSTRArray
{
protected:
    int m_nSize;
    BSTR* m_astrStrings;
public:
    CFixedBSTRArray() : m_nSize(0), m_astrStrings(NULL){}
    ~CFixedBSTRArray() {delete [] m_astrStrings;}

    void Free();
    void Create(int nSize);

    int GetLength() {return m_nSize;}
    BSTR& GetAt(int nIndex) {return m_astrStrings[nIndex];}
    BSTR& operator[](int nIndex) {return GetAt(nIndex);}

    void SetLength(int nLength) {m_nSize = nLength;}

public:
    void SortInPlace();
    /*
    void MergeOrdered(CFixedBSTRArray& a1, 
                      CFixedBSTRArray& a2);
    */
    void ThreeWayMergeOrdered(CFixedBSTRArray& acsInclude1, 
                      CFixedBSTRArray& acsInclude2,
                      CFixedBSTRArray& acsExclude);

	void Filter( LPCWSTR pwcsStr, BOOL fFree = FALSE );

};

//*****************************************************************************
//*****************************************************************************
//
//  class CCompressedStringList
//
//*****************************************************************************

class COREPROX_POLARITY CCompressedStringList
{
protected:
    PLENGTHT m_pnLength;
    int m_nNumStrings;

    static length_t GetSeparatorLength() {return sizeof(idlength_t);}
public:
    void SetData(LPMEMORY pData)
    {
        m_pnLength = (PLENGTHT)pData;
        m_nNumStrings = -1;
    }
    void Rebase(LPMEMORY pData)
    {
        m_pnLength = (PLENGTHT)pData;
    }
    LPMEMORY GetStart() {return (LPMEMORY)m_pnLength;}
    length_t GetLength() {return *m_pnLength;}
    static length_t GetHeaderLength() {return sizeof(length_t);}

public:
    BOOL IsEmpty()
    {
        return (GetLength() == GetHeaderLength());
    }

    void Reset()
    {
        *m_pnLength = GetHeaderLength();
        m_nNumStrings = 0;
    }

    CCompressedString* GetFirst()
    {
        if(IsEmpty())
            return NULL;
        else
            return (CCompressedString*)(GetStart() + GetHeaderLength());
    }

    CCompressedString* GetNext(CCompressedString* pThis)
    {
        LPMEMORY pNext = EndOf(*pThis) + GetSeparatorLength();
        if(pNext - GetStart() >= (int)GetLength()) 
            return NULL;
        else
            return (CCompressedString*)pNext;
    }

    
    CCompressedString* GetPrevious(CCompressedString* pThis)
    {
        if((LPMEMORY)pThis == GetStart() + GetHeaderLength()) return NULL;
        PIDLENGTHT pnPrevLen =  
            (PIDLENGTHT)(pThis->GetStart() - GetSeparatorLength());
        return (CCompressedString*)((LPMEMORY)pnPrevLen - *pnPrevLen);
    }
        
    CCompressedString* GetLast()
    {
        return GetPrevious((CCompressedString*)EndOf(*this));
    }
        
    CCompressedString* GetAtFromLast(int nIndex)
    {
        int i = 0;
        CCompressedString* pCurrent = GetLast();
        while(i < nIndex && pCurrent)
        {
            pCurrent = GetPrevious(pCurrent);
            i++;
        }
        return pCurrent;
    }

    int GetNumStrings()
    {
        if(m_nNumStrings == -1)
        {
            CCompressedString* pCurrent = GetFirst();
            for(int i = 0; pCurrent != NULL; i++)
                pCurrent = GetNext(pCurrent);
            
            m_nNumStrings = i;
        }
        return m_nNumStrings;
    }

    int Find(LPCWSTR wszString)
    {
        CCompressedString* pCurrent = GetFirst();
        for(int i = 0; pCurrent != NULL; i++)
        {
            if(pCurrent->CompareNoCase(wszString) == 0)
                return i;
            pCurrent = GetNext(pCurrent);
        }
        return -1;
    }
            
    void AddString(LPCWSTR wszString)
    {
        LPMEMORY pEnd = EndOf(*this);
        CCompressedString* pcs = (CCompressedString*)pEnd;
        pcs->SetFromUnicode(wszString);
        *(PLENGTHT)EndOf(*pcs) = pcs->GetLength();
        
		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned longs.  We do not support length
		// > 0xFFFFFFFF so cast is ok.

        *m_pnLength = (length_t) ( EndOf(*pcs) + sizeof(length_t) - GetStart() );
        if(m_nNumStrings != -1)
            m_nNumStrings++;
    }
        

public:
    static LPMEMORY CreateEmpty(LPMEMORY pDest)
    {
        *(PLENGTHT)pDest = sizeof(length_t);
        return pDest + sizeof(length_t);
    }

    static length_t EstimateExtraSpace(CCompressedString* pcsExtra)
    {
        if(pcsExtra == NULL) 
            return 0;
        else
            return pcsExtra->GetLength() + GetSeparatorLength();
    }

    static length_t EstimateExtraSpace(LPCWSTR wszExtra)
    {
        return CCompressedString::ComputeNecessarySpace(wszExtra) + 
                    GetSeparatorLength();
    }

    length_t ComputeNecessarySpace(CCompressedString* pcsExtra)
    {
        return GetLength() + EstimateExtraSpace(pcsExtra);
    }

    LPMEMORY CopyData(LPMEMORY pDest)
    {
        int nDataLength = GetLength() - GetHeaderLength();
        memcpy(pDest, GetStart() + GetHeaderLength(), nDataLength);
        return pDest + nDataLength;
    }
        
        
    LPMEMORY CreateWithExtra(LPMEMORY pDest, CCompressedString* pcsExtra)
    {
        LPMEMORY pCurrent = pDest + GetHeaderLength();
        if(pcsExtra)
        {
            memcpy(pCurrent, (LPMEMORY)pcsExtra, pcsExtra->GetLength());
            pCurrent += pcsExtra->GetLength();
            *(PIDLENGTHT)pCurrent = pcsExtra->GetLength();
            pCurrent += sizeof(idlength_t);
        }

        pCurrent = CopyData(pCurrent);

		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned longs.  We do not support length
		// > 0xFFFFFFFF so cast is ok.

        *(PLENGTHT)pDest = (length_t) ( pCurrent - pDest );
        return pCurrent;
    }

};


#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastval.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTVAL.CPP

Abstract:

  This file implements the classes related to value representation.
  Note: inline function implementations are cointained in fastval.inc.
  See fastval.h for all documentation.

  Classes implemented:
      CType               Representing property type
      CUntypedValue       A value with otherwise known type.
      CTypedValue         A value with stored type.
      CUntypedArray       Array of values of otherwise known type.

History:

  2/21/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.


--*/

#include "precomp.h"
//#include "dbgalloc.h"
#include "wbemutil.h"
#include <wbemidl.h>
#include "corex.h"
#include "faster.h"
#include "fastval.h"
#include "datetimeparser.h"
#include <genutils.h>
#include "arrtempl.h"
#include <fastall.h>
#include <wbemint.h>


//******************************************************************************
//
//  See fastval.h for documentation
//
//******************************************************************************
length_t m_staticLengths[128] =
{
    /* 0*/ 0, 0, 2, 4, 4, 8, 0, 0, 4, 0,
    /*10*/ 0, 2, 0, 4, 0, 0, 1, 1, 2, 4,
    /*20*/ 8, 8, 0, 0, 0, 0, 0, 0, 0, 0,
    /*30*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*40*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*50*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*60*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*70*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*80*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*90*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*100*/0, 4, 4, 2, 0, 0, 0, 0, 0, 0,
    /*110*/0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*120*/0, 0, 0, 0, 0, 0, 0, 0
};

length_t CType::GetLength(Type_t nType)
{
    if(GetBasic(nType) > 127) return 0;

    if(IsArray(nType)) return sizeof(heapptr_t);
    else return m_staticLengths[GetBasic(nType)];
}

BOOL CType::IsPointerType(Type_t nType)
{
    Type_t nBasic = GetBasic(nType);
    return (nBasic == CIM_STRING || nBasic == CIM_DATETIME ||
        nBasic == CIM_REFERENCE || nBasic == CIM_OBJECT ||
        IsArray(nType));
}

BOOL CType::IsNonArrayPointerType(Type_t nType)
{
    Type_t nBasic = GetBasic(nType);
    return ( !IsArray(nType) && 
		( nBasic == CIM_STRING || nBasic == CIM_DATETIME ||
        nBasic == CIM_REFERENCE || nBasic == CIM_OBJECT ) );
}

BOOL CType::IsStringType(Type_t nType)
{
    Type_t nBasic = GetBasic(nType);
    return (nBasic == CIM_STRING || nBasic == CIM_DATETIME ||
        nBasic == CIM_REFERENCE );
}

BOOL CType::DoesCIMTYPEMatchVARTYPE(CIMTYPE ct, VARTYPE vt)
{
    // EXCEPTIONS: UINT32 matches STRING, LPWSTR matches string and datetime

    BOOL bCimArray = ((ct & CIM_FLAG_ARRAY) != 0);
    BOOL bVtArray = ((vt & VT_ARRAY) != 0);
	CIMTYPE ctBasic = CType::GetBasic(ct);

    if(bCimArray != bVtArray)
        return FALSE;

    if( ( ct & ~CIM_FLAG_ARRAY ) == CIM_UINT32 &&
        ( vt & ~VT_ARRAY ) == VT_BSTR)
    {
        return TRUE;
    }

    if ( CType::IsStringType( ct ) &&
        (vt & ~VT_ARRAY) == VT_LPWSTR)
    {
        return TRUE;
    }

	// We use strings for 64-bit values as well
    if ( ( ctBasic == CIM_SINT64 || ctBasic == CIM_UINT64 ) &&
        (vt & ~VT_ARRAY) == VT_LPWSTR)
    {
        return TRUE;
    }

    return (vt == GetVARTYPE(ct));
}

BOOL inline CType::IsMemCopyAble(VARTYPE vtFrom, CIMTYPE ctTo)
{
    if (vtFrom == VT_BSTR)
    {
        if (ctTo == CIM_UINT64 ||
            ctTo == CIM_SINT64 || 
            ctTo == CIM_DATETIME)
        {
            return FALSE;
        }
    }
    else if (vtFrom == VT_I2) 
    {
        if (ctTo == CIM_SINT8)
        {
            return FALSE;
        }
    }
    else if (vtFrom == VT_I4) 
    {
        if (ctTo == CIM_UINT16)
        {
            return FALSE;
        }
    }
    
    return TRUE;
}


 void CUntypedValue::Delete(CType Type, CFastHeap* pHeap)
{
    if(Type.GetActualType() == CIM_STRING ||
        Type.GetActualType() == CIM_REFERENCE ||
        Type.GetActualType() == CIM_DATETIME)
    {
        pHeap->FreeString(AccessPtrData());
        AccessPtrData() = INVALID_HEAP_ADDRESS;
    }
    else if(Type.GetActualType() == CIM_OBJECT)
    {
        CEmbeddedObject* pObj = (CEmbeddedObject*)
            pHeap->ResolveHeapPointer(AccessPtrData());
        int nLen = pObj->GetLength();
        pHeap->Free(AccessPtrData(), nLen);
    }
    else if(Type.IsArray())
    {
        CUntypedArray* pArray = (CUntypedArray*)
            pHeap->ResolveHeapPointer(AccessPtrData());
        int nArrayLen = pArray->GetLengthByType(Type.GetBasic());
        pArray->Delete(Type.GetBasic(), pHeap);
        pHeap->Free(AccessPtrData(), nArrayLen);
    }
}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************

//******************************************************************************
 // IF YOU SPECIFY fOptimize of TRUE ---
 //
 //	PLEASE ENSURE THAT YOU KNOW WHAT YOU ARE DOING!!!!   IT MAKES ASSUMPTIONS THAT YOU WILL
 //	PERFORM CLEANUP OPERATIONS THAT ARE NORMALLY DONE AUTOMAGICALLY!
//****