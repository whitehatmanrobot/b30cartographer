 = (0x0400+19),
                                                                                                                                                                                                                                                                                                                  RB_GETBKCOLOR = (0x0400+20),
                                                                                                                                                                                                                                                                                                                                  RB_SETTEXTCOLOR = (0x0400+21),
                                                                                                                                                                                                                                                                                                                                                    RB_GETTEXTCOLOR = (0x0400+22),
                                                                                                                                                                                                                                                                                                                                                                      RB_SIZETORECT = (0x0400+23),
                                                                                                                                                                                                                                                                                                                                                                                      RB_BEGINDRAG = (0x0400+24),
                                                                                                                                                                                                                                                                                                                                                                                                     RB_ENDDRAG = (0x0400+25),
                                                                                                                                                                                                                                                                                                                                                                                                                  RB_DRAGMOVE = (0x0400+26),
                                                                                                                                                                                                                                                                                                                                                                                                                                RB_GETBARHEIGHT = (0x0400+27),
                                                                                                                                                                                                                                                                                                                                                                                                                                                  RB_GETBANDINFOW = (0x0400+28),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    RB_GETBANDINFOA = (0x0400+29),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      RB_MINIMIZEBAND = (0x0400+30),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        RB_MAXIMIZEBAND = (0x0400+31),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          RB_GETBANDBORDERS = (0x0400+34),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              RB_SHOWBAND = (0x0400+35),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            RB_SETPALETTE = (0x0400+37),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            RB_GETPALETTE = (0x0400+38),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            RB_MOVEBAND = (0x0400+39),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          RB_SETCOLORSCHEME = win.CCM_SETCOLORSCHEME,
        RB_GETCOLORSCHEME = win.CCM_GETCOLORSCHEME,
        RB_GETDROPTARGET = win.CCM_GETDROPTARGET,
        RB_SETUNICODEFORMAT = win.CCM_SETUNICODEFORMAT,
        RB_GETUNICODEFORMAT = win.CCM_GETUNICODEFORMAT,
        RBN_HEIGHTCHANGE = ((0-831)-0),
                           RBN_GETOBJECT = ((0-831)-1),
                                           RBN_LAYOUTCHANGED = ((0-831)-2),
                                                               RBN_AUTOSIZE = ((0-831)-3),
                                                                              RBN_BEGINDRAG = ((0-831)-4),
                                                                                              RBN_ENDDRAG = ((0-831)-5),
                                                                                                            RBN_DELETINGBAND = ((0-831)-6),
                                                                                                                               RBN_DELETEDBAND = ((0-831)-7),
                                                                                                                                                 RBN_CHILDSIZE = ((0-831)-8),
                                                                                                                                                                 RBHT_NOWHERE = 0x0001,
        RBHT_CAPTION = 0x0002,
        RBHT_CLIENT = 0x0003,
        RBHT_GRABBER = 0x0004,
        RPC_S_OK = 0,
        RPC_S_INVALID_ARG = 87,
        RPC_S_OUT_OF_MEMORY = 14,
        RPC_S_OUT_OF_THREADS = 164,
        RPC_S_INVALID_LEVEL = 87,
        RPC_S_BUFFER_TOO_SMALL = 122,
        RPC_S_INVALID_SECURITY_DESC = 1338,
        RPC_S_ACCESS_DENIED = 5,
        RPC_S_SERVER_OUT_OF_MEMORY = 1130,
        RPC_X_NO_MEMORY = 14,
        RPC_X_INVALID_BOUND = 1734,
        RPC_X_INVALID_TAG = 1733,
        RPC_X_ENUM_VALUE_TOO_LARGE = 1781,
        RPC_X_SS_CONTEXT_MISMATCH = 6,
        RPC_X_INVALID_BUFFER = 1784;







        public const int SIMULATED_FONTTYPE = unchecked((int)0x8000),
        SCREEN_FONTTYPE = 0x2000,
        ST_CONNECTED = 0x0001,
        ST_ADVISE = 0x0002,
        ST_ISLOCAL = 0x0004,
        ST_BLOCKED = 0x0008,
        ST_CLIENT = 0x0010,
        ST_TERMINATED = 0x0020,
        ST_INLIST = 0x0040,
        ST_BLOCKNEXT = 0x0080,
        ST_ISSELF = 0x0100,
        stc1 = 0x0440,
        stc2 = 0x0441,
        stc3 = 0x0442,
        stc4 = 0x0443,
        stc5 = 0x0444,
        stc6 = 0x0445,
        stc7 = 0x0446,
        stc8 = 0x0447,
        stc9 = 0x0448,
        stc10 = 0x0449,
        stc11 = 0x044a,
        stc12 = 0x044b,
        stc13 = 0x044c,
        stc14 = 0x044d,
        stc15 = 0x044e,
        stc16 = 0x044f,
        stc17 = 0x0450,
        stc18 = 0x0451,
        stc19 = 0x0452,
        stc20 = 0x0453,
        stc21 = 0x0454,
        stc22 = 0x0455,
        stc23 = 0x0456,
        stc24 = 0x0457,
        stc25 = 0x0458,
        stc26 = 0x0459,
        stc27 = 0x045a,
        stc28 = 0x045b,
        stc29 = 0x045c,
        stc30 = 0x045d,
        stc31 = 0x045e,
        stc32 = 0x045f,
        scr1 = 0x0490,
        scr2 = 0x0491,
        scr3 = 0x0492,
        scr4 = 0x0493,
        scr5 = 0x0494,
        scr6 = 0x0495,
        scr7 = 0x0496,
        scr8 = 0x0497,
        STYLE_DESCRIPTION_SIZE = 32,
        SCS_CAP_COMPSTR = 0x00000001,
        SCS_CAP_MAKEREAD = 0x00000002,
        SELECT_CAP_CONVERSION = 0x00000001,
        SELECT_CAP_SENTENCE = 0x00000002,
        SCS_SETSTR = (0x0001|0x0008),
                     SCS_CHANGEATTR = (0x0002|0x0010),
                                      SCS_CHANGECLAUSE = (0x0004|0x0020),
                                                         SOFTKEYBOARD_TYPE_T1 = 0x0001,
        SOFTKEYBOARD_TYPE_C1 = 0x0002,
        SND_SYNC = 0x0000,
        SND_ASYNC = 0x0001,
        SND_NODEFAULT = 0x0002,
        SND_MEMORY = 0x0004,
        SND_LOOP = 0x0008,
        SND_NOSTOP = 0x0010,
        SND_NOWAIT = 0x00002000,
        SND_ALIAS = 0x00010000,
        SND_ALIAS_ID = 0x00110000,
        SND_FILENAME = 0x00020000,
        SND_RESOURCE = 0x00040004,
        SND_PURGE = 0x0040,
        SND_APPLICATION = 0x0080,
        SND_ALIAS_START = 0,
        SEEK_SET = 0,
        SEEK_CUR = 1,
        SEEK_END = 2,
        SELECTDIB = 41,
        SC_SCREENSAVE = 0xF140,
        SO_CONNDATA = 0x7000,
        SO_CONNOPT = 0x7001,
        SO_DISCDATA = 0x7002,
        SO_DISCOPT = 0x7003,
        SO_CONNDATALEN = 0x7004,
        SO_CONNOPTLEN = 0x7005,
        SO_DISCDATALEN = 0x7006,
        SO_DISCOPTLEN = 0x7007,
        SO_OPENTYPE = 0x7008,
        SO_SYNCHRONOUS_ALERT = 0x10,
        SO_SYNCHRONOUS_NONALERT = 0x20,
        SO_MAXDG = 0x7009,
        SO_MAXPATHDG = 0x700A,
        SO_UPDATE_ACCEPT_CONTEXT = 0x700B,
        SO_CONNECT_TIME = 0x700C,
        SESSION_ESTABLISHED = 0x03,
        SESSION_ABORTED = 0x06,
        STGM_DIRECT = 0x00000000,
        STGM_TRANSACTED = 0x00010000,
        STGM_SIMPLE = 0x08000000,
        STGM_READ = 0x00000000,
        STGM_WRITE = 0x00000001,
        STGM_READWRITE = 0x00000002,
        STGM_SHARE_DENY_NONE = 0x00000040,
        STGM_SHARE_DENY_READ = 0x00000030,
        STGM_SHARE_DENY_WRITE = 0x00000020,
        STGM_SHARE_EXCLUSIVE = 0x00000010,
        STGM_PRIORITY = 0x00040000,
        STGM_DELETEONRELEASE = 0x04000000,
        STGM_NOSCRATCH = 0x00100000,
        STGM_CREATE = 0x00001000,
        STGM_CONVERT = 0x00020000,
        STGM_FAILIFTHERE = 0x00000000,
        STGM_NOSNAPSHOT = 0x00200000,
        STGTY_REPEAT = 0x00000100,
        STG_TOEND = unchecked((int)0xFFFFFFFF),
        STG_LAYOUT_SEQUENTIAL = 0x00000000,
        STG_LAYOUT_INTERLEAVED = 0x00000001,
        STDOLE_MAJORVERNUM = 0x1,
        STDOLE_MINORVERNUM = 0x0,
        STDOLE_LCID = 0x0000,
        STDOLE2_MAJORVERNUM = 0x2,
        STDOLE2_MINORVERNUM = 0x0,
        STDOLE2_LCID = 0x0000,
        SEC_WINNT_AUTH_IDENTITY_ANSI = 0x1,
        SEC_WINNT_AUTH_IDENTITY_UNICODE = 0x2,
        SE_ERR_FNF = 2,
        SE_ERR_PNF = 3,
        SE_ERR_ACCESSDENIED = 5,
        SE_ERR_OOM = 8,
        SE_ERR_DLLNOTFOUND = 32,
        SE_ERR_SHARE = 26,
        SE_ERR_ASSOCINCOMPLETE = 27,
        SE_ERR_DDETIMEOUT = 28,
        SE_ERR_DDEFAIL = 29,
        SE_ERR_DDEBUSY = 30,
        SE_ERR_NOASSOC = 31,
        SEE_MASK_CLASSNAME = 0x00000001,
        SEE_MASK_CLASSKEY = 0x00000003,
        SEE_MASK_IDLIST = 0x00000004,
        SEE_MASK_INVOKEIDLIST = 0x0000000c,
        SEE_MASK_ICON = 0x00000010,
        SEE_MASK_HOTKEY = 0x00000020,
        SEE_MASK_NOCLOSEPROCESS = 0x00000040,
        SEE_MASK_CONNECTNETDRV = 0x00000080,
        SEE_MASK_FLAG_DDEWAIT = 0x00000100,
        SEE_MASK_DOENVSUBST = 0x00000200,
        SEE_MASK_FLAG_NO_UI = 0x00000400,
        SEE_MASK_UNICODE = 0x00004000,
        SEE_MASK_NO_CONSOLE = 0x00008000,
        SEE_MASK_ASYNCOK = 0x00100000;
        public const long SHGFI_ICON = 0x000000100L,
        SHGFI_DISPLAYNAME = 0x000000200L,
        SHGFI_TYPENAME = 0x000000400L,
        SHGFI_ATTRIBUTES = 0x000000800L,
        SHGFI_ICONLOCATION = 0x000001000L,
        SHGFI_EXETYPE = 0x000002000L,
        SHGFI_SYSICONINDEX = 0x000004000L,
        SHGFI_LINKOVERLAY = 0x000008000L,
        SHGFI_SELECTED = 0x000010000L,
        SHGFI_LARGEICON = 0x000000000L,
        SHGFI_SMALLICON = 0x000000001L,
        SHGFI_OPENICON = 0x000000002L,
        SHGFI_SHELLICONSIZE = 0x000000004L,
        SHGFI_PIDL = 0x000000008L,
        SHGFI_USEFILEATTRIBUTES = 0x000000010L,
        SHGNLI_PIDL = 0x000000001L,
        SHGNLI_PREFIXNAME = 0x000000002L,
        SHGNLI_NOUNIQUE = 0x000000004L;
        public const int SECURITY_CONTEXT_TRACKING = 0x00040000,
        SECURITY_EFFECTIVE_ONLY = 0x00080000,
        SECURITY_SQOS_PRESENT = 0x00100000,
        SECURITY_VALID_SQOS_FLAGS = 0x001F0000,
        SP_SERIALCOMM = (0x00000001),
        SP_PARITY = (0x0001),
        SP_BAUD = (0x0002),
        SP_DATABITS = (0x0004),
        SP_STOPBITS = (0x0008),
        SP_HANDSHAKING = (0x0010),
        SP_PARITY_CHECK = (0x0020),
        SP_RLSD = (0x0040),
        STOPBITS_10 = (0x0001),
        STOPBITS_15 = (0x0002),
        STOPBITS_20 = (0x0004),
        SPACEPARITY = 4,
        SETXOFF = 1,
        SETXON = 2,
        SETRTS = 3,
        SETDTR = 5,
        SETBREAK = 8,
        S_QUEUEEMPTY = 0,
        S_THRESHOLD = 1,
        S_ALLTHRESHOLD = 2,
        S_NORMAL = 0,
        S_LEGATO = 1,
        S_STACCATO = 2,
        S_PERIOD512 = 0,
        S_PERIOD1024 = 1,
        S_PERIOD2048 = 2,
        S_PERIODVOICE = 3,
        S_WHITE512 = 4,
        S_WHITE1024 = 5,
        S_WHITE2048 = 6,
        S_WHITEVOICE = 7,
        S_SERDVNA = (-1),
                    S_SEROFM = (-2),
                               S_SERMACT = (-3),
                                           S_SERQFUL = (-4),
                                                       S_SERBDNT = (-5),
                                                                   S_SERDLN = (-6),
                                                                              S_SERDCC = (-7),
                                                                                         S_SERDTP = (-8),
                                                                                                    S_SERDVL = (-9),
                                                                                                               S_SERDMD = (-10),
                                                                                                                          S_SERDSH = (-11),
                                                                                                                                     S_SERDPT = (-12),
                                                                                                                                                S_SERDFQ = (-13),
                                                                                                                                                           S_SERDDR = (-14),
                                                                                                                                                                      S_SERDSR = (-15),
                                                                                                                                                                                 S_SERDST = (-16),
                                                                                                                                                                                            SCS_32BIT_BINARY = 0,
        SCS_DOS_BINARY = 1,
        SCS_WOW_BINARY = 2,
        SCS_PIF_BINARY = 3,
        SCS_POSIX_BINARY = 4,
        SCS_OS216_BINARY = 5,
        SEM_FAILCRITICALERRORS = 0x0001,
        SEM_NOGPFAULTERRORBOX = 0x0002,
        SEM_NOALIGNMENTFAULTEXCEPT = 0x0004,
        SEM_NOOPENFILEERRORBOX = unchecked((int)0x8000),
        SET_TAPE_MEDIA_INFORMATION = 0,
        SET_TAPE_DRIVE_INFORMATION = 1,
        STREAM_NORMAL_ATTRIBUTE = 0x00000000,
        STREAM_MODIFIED_WHEN_READ = 0x00000001,
        STREAM_CONTAINS_SECURITY = 0x00000002,
        STREAM_CONTAINS_PROPERTIES = 0x00000004,
        STARTF_USESHOWWINDOW = 0x00000001,
        STARTF_USESIZE = 0x00000002,
        STARTF_USEPOSITION = 0x00000004,
        STARTF_USECOUNTCHARS = 0x00000008,
        STARTF_USEFILLATTRIBUTE = 0x00000010,
        STARTF_RUNFULLSCREEN = 0x00000020,
        STARTF_FORCEONFEEDBACK = 0x00000040,
        STARTF_FORCEOFFFEEDBACK = 0x00000080,
        STARTF_USESTDHANDLES = 0x00000100,
        STARTF_USEHOTKEY = 0x00000200,
        SHUTDOWN_NORETRY = 0x00000001,
        SHIFT_PRESSED = 0x0010,
        SCROLLLOCK_ON = 0x0040,
        SIMPLEBLOB = 0x1,
        SEVERITY_SUCCESS = 0,
        SEVERITY_ERROR = 1,
        STG_E_INVALIDFUNCTION = unchecked((int)0x80030001),
        STG_E_FILENOTFOUND = unchecked((int)0x80030002),
        STG_E_PATHNOTFOUND = unchecked((int)0x80030003),
        STG_E_TOOMANYOPENFILES = unchecked((int)0x80030004),
        STG_E_ACCESSDENIED = unchecked((int)0x80030005),
        STG_E_INVALIDHANDLE = unchecked((int)0x80030006),
        STG_E_INSUFFICIENTMEMORY = unchecked((int)0x80030008),
        STG_E_INVALIDPOINTER = unchecked((int)0x80030009),
        STG_E_NOMOREFILES = unchecked((int)0x80030012),
        STG_E_DISKISWRITEPROTECTED = unchecked((int)0x80030013),
        STG_E_SEEKERROR = unchecked((int)0x80030019),
        STG_E_WRITEFAULT = unchecked((int)0x8003001D),
        STG_E_READFAULT = unchecked((int)0x8003001E),
        STG_E_SHAREVIOLATION = unchecked((int)0x80030020),
        STG_E_LOCKVIOLATION = unchecked((int)0x80030021),
        STG_E_FILEALREADYEXISTS = unchecked((int)0x80030050),
        STG_E_INVALIDPARAMETER = unchecked((int)0x80030057),
        STG_E_MEDIUMFULL = unchecked((int)0x80030070),
        STG_E_PROPSETMISMATCHED = unchecked((int)0x800300F0),
        STG_E_ABNORMALAPIEXIT = unchecked((int)0x800300FA),
        STG_E_INVALIDHEADER = unchecked((int)0x800300FB),
        STG_E_INVALIDNAME = unchecked((int)0x800300FC),
        STG_E_UNKNOWN = unchecked((int)0x800300FD),
        STG_E_UNIMPLEMENTEDFUNCTION = unchecked((int)0x800300FE),
        STG_E_INVALIDFLAG = unchecked((int)0x800300FF),
        STG_E_INUSE = unchecked((int)0x80030100),
        STG_E_NOTCURRENT = unchecked((int)0x80030101),
        STG_E_REVERTED = unchecked((int)0x80030102),
        STG_E_CANTSAVE = unchecked((int)0x80030103),
        STG_E_OLDFORMAT = unchecked((int)0x80030104),
        STG_E_OLDDLL = unchecked((int)0x80030105),
        STG_E_SHAREREQUIRED = unchecked((int)0x80030106),
        STG_E_NOTFILEBASEDSTORAGE = unchecked((int)0x80030107),
        STG_E_EXTANTMARSHALLINGS = unchecked((int)0x80030108),
        STG_E_DOCFILECORRUPT = unchecked((int)0x80030109),
        STG_E_BADBASEADDRESS = unchecked((int)0x80030110),
        STG_E_INCOMPLETE = unchecked((int)0x80030201),
        STG_E_TERMINATED = unchecked((int)0x80030202),
        STG_S_CONVERTED = 0x00030200,
        STG_S_BLOCK = 0x00030201,
        STG_S_RETRYNOW = 0x00030202,
        STG_S_MONITORING = 0x00030203,
        SIMPLEREGION = 2,
        STRETCH_ANDSCANS = 1,
        STRETCH_ORSCANS = 2,
        STRETCH_DELETESCANS = 3,
        STRETCH_HALFTONE = 4,
        SETCOLORTABLE = 4,
        SETABORTPROC = 9,
        STARTDOC = 10,
        SETCOPYCOUNT = 17,
        SELECTPAPERSOURCE = 18,
        SETLINECAP = 21,
        SETLINEJOIN = 22,
        SETMITERLIMIT = 23,
        SETDIBSCALING = 32,
        SETKERNTRACK = 770,
        SETALLJUSTVALUES = 771,
        SETCHARSET = 772,
        STRETCHBLT = 2048,
        SAVE_CTM = 4101,
        SET_ARC_DIRECTION = 4102,
        SET_BACKGROUND_COLOR = 4103,
        SET_POLY_MODE = 4104,
        SET_SCREEN_ANGLE = 4105,
        SET_SPREAD = 4106,
        SET_CLIP_BOX = 4108,
        SET_BOUNDS = 4109,
        SET_MIRROR_MODE = 4110,
        SP_NOTREPORTED = 0x4000,
        SP_ERROR = (-1),
                   SP_APPABORT = (-2),
                                 SP_USERABORT = (-3),
                                                SP_OUTOFDISK = (-4),
                                                               SP_OUTOFMEMORY = (-5),
                                                                                SYMBOL_CHARSET = 2,
        SHIFTJIS_CHARSET = 128,
        SYSTEM_FONT = 13,
        SYSTEM_FIXED_FONT = 16,
        STOCK_LAST = 17;
        // STOCK_LAST = 16;
        public const int SIZEPALETTE = 104,
        SCALINGFACTORX = 114,
        SCALINGFACTORY = 115,
        SYSPAL_ERROR = 0,
        SYSPAL_STATIC = 1,
        SYSPAL_NOSTATIC = 2,
        SORT_STRINGSORT = 0x00001000,
        SUBLANG_NEUTRAL = 0x00,
        SUBLANG_DEFAULT = 0x01,
        SUBLANG_SYS_DEFAULT = 0x02,
        SUBLANG_ARABIC_SAUDI_ARABIA = 0x01,
        SUBLANG_ARABIC_IRAQ = 0x02,
        SUBLANG_ARABIC_EGYPT = 0x03,
        SUBLANG_ARABIC_LIBYA = 0x04,
        SUBLANG_ARABIC_ALGERIA = 0x05,
        SUBLANG_ARABIC_MOROCCO = 0x06,
        SUBLANG_ARABIC_TUNISIA = 0x07,
        SUBLANG_ARABIC_OMAN = 0x08,
        SUBLANG_ARABIC_YEMEN = 0x09,
        SUBLANG_ARABIC_SYRIA = 0x0a,
        SUBLANG_ARABIC_JORDAN = 0x0b,
        SUBLANG_ARABIC_LEBANON = 0x0c,
        SUBLANG_ARABIC_KUWAIT = 0x0d,
        SUBLANG_ARABIC_UAE = 0x0e,
        SUBLANG_ARABIC_BAHRAIN = 0x0f,
        SUBLANG_ARABIC_QATAR = 0x10,
        SUBLANG_CHINESE_TRADITIONAL = 0x01,
        SUBLANG_CHINESE_SIMPLIFIED = 0x02,
        SUBLANG_CHINESE_HONGKONG = 0x03,
        SUBLANG_CHINESE_SINGAPORE = 0x04,
        SUBLANG_DUTCH = 0x01,
        SUBLANG_DUTCH_BELGIAN = 0x02,
        SUBLANG_ENGLISH_US = 0x01,
        SUBLANG_ENGLISH_UK = 0x02,
        SUBLANG_ENGLISH_AUS = 0x03,
        SUBLANG_ENGLISH_CAN = 0x04,
        SUBLANG_ENGLISH_NZ = 0x05,
        SUBLANG_ENGLISH_EIRE = 0x06,
        SUBLANG_ENGLISH_SOUTH_AFRICA = 0x07,
        SUBLANG_ENGLISH_JAMAICA = 0x08,
        SUBLANG_ENGLISH_CARIBBEAN = 0x09,
        SUBLANG_ENGLISH_BELIZE = 0x0a,
        SUBLANG_ENGLISH_TRINIDAD = 0x0b,
        SUBLANG_FRENCH = 0x01,
        SUBLANG_FRENCH_BELGIAN = 0x02,
        SUBLANG_FRENCH_CANADIAN = 0x03,
        SUBLANG_FRENCH_SWISS = 0x04,
        SUBLANG_FRENCH_LUXEMBOURG = 0x05,
        SUBLANG_GERMAN = 0x01,
        SUBLANG_GERMAN_SWISS = 0x02,
        SUBLANG_GERMAN_AUSTRIAN = 0x03,
        SUBLANG_GERMAN_LUXEMBOURG = 0x04,
        SUBLANG_GERMAN_LIECHTENSTEIN = 0x05,
        SUBLANG_ITALIAN = 0x01,
        SUBLANG_ITALIAN_SWISS = 0x02,
        SUBLANG_KOREAN = 0x01,
        SUBLANG_KOREAN_JOHAB = 0x02,
        SUBLANG_NORWEGIAN_BOKMAL = 0x01,
        SUBLANG_NORWEGIAN_NYNORSK = 0x02,
        SUBLANG_PORTUGUESE = 0x02,
        SUBLANG_PORTUGUESE_BRAZILIAN = 0x01,
        SUBLANG_SERBIAN_LATIN = 0x02,
        SUBLANG_SERBIAN_CYRILLIC = 0x03,
        SUBLANG_SPANISH = 0x01,
        SUBLANG_SPANISH_MEXICAN = 0x02,
        SUBLANG_SPANISH_MODERN = 0x03,
        SUBLANG_SPANISH_GUATEMALA = 0x04,
        SUBLANG_SPANISH_COSTA_RICA = 0x05,
        SUBLANG_SPANISH_PANAMA = 0x06,
        SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 0x07,
        SUBLANG_SPANISH_VENEZUELA = 0x08,
        SUBLANG_SPANISH_COLOMBIA = 0x09,
        SUBLANG_SPANISH_PERU = 0x0a,
        SUBLANG_SPANISH_ARGENTINA = 0x0b,
        SUBLANG_SPANISH_ECUADOR = 0x0c,
        SUBLANG_SPANISH_CHILE = 0x0d,
        SUBLANG_SPANISH_URUGUAY = 0x0e,
        SUBLANG_SPANISH_PARAGUAY = 0x0f,
        SUBLANG_SPANISH_BOLIVIA = 0x10,
        SUBLANG_SPANISH_EL_SALVADOR = 0x11,
        SUBLANG_SPANISH_HONDURAS = 0x12,
        SUBLANG_SPANISH_NICARAGUA = 0x13,
        SUBLANG_SPANISH_PUERTO_RICO = 0x14,
        SUBLANG_SWEDISH = 0x01,
        SUBLANG_SWEDISH_FINLAND = 0x02,
        SORT_DEFAULT = 0x0,
        SORT_JAPANESE_XJIS = 0x0,
        SORT_JAPANESE_UNICODE = 0x1,
        SORT_CHINESE_BIG5 = 0x0,
        SORT_CHINESE_PRCP = 0x0,
        SORT_CHINESE_UNICODE = 0x1,
        SORT_CHINESE_PRC = 0x2,
        SORT_KOREAN_KSC = 0x0,
        SORT_KOREAN_UNICODE = 0x1,
        SORT_GERMAN_PHONE_BOOK = 0x1,
        STATUS_WAIT_0 = (0x00000000),
                        STATUS_ABANDONED_WAIT_0 = (0x00000080),
                                                  STATUS_USER_APC = (0x000000C0),
                                                                    STATUS_TIMEOUT = (0x00000102),
                                                                                     STATUS_PENDING = (0x00000103),
                                                                                                      STATUS_SEGMENT_NOTIFICATION = (0x40000005),
                                                                                                                                    STATUS_GUARD_PAGE_VIOLATION = (unchecked((int)0x80000001)),
                                                                                                                                                                  STATUS_DATATYPE_MISALIGNMENT = (unchecked((int)0x80000002)),
                                                                                                                                                                                                 STATUS_BREAKPOINT = (unchecked((int)0x80000003)),
                                                                                                                                                                                                                     STATUS_SINGLE_STEP = (unchecked((int)0x80000004)),
                                                                                                                                                                                                                                          STATUS_ACCESS_VIOLATION = (unchecked((int)0xC0000005)),
                                                                                                                                                                                                                                                                    STATUS_IN_PAGE_ERROR = (unchecked((int)0xC0000006)),
                                                                                                                                                                                                                                                                                           STATUS_INVALID_HANDLE = (unchecked((int)0xC0000008)),
                                                                                                                                                                                                                                                                                                                   STATUS_NO_MEMORY = (unchecked((int)0xC0000017)),
                                                                                                                                                                                                                                                                                                                                      STATUS_ILLEGAL_INSTRUCTION = (unchecked((int)0xC000001D)),
                                                                                                                                                                                                                                                                                                                                                                   STATUS_NONCONTINUABLE_EXCEPTION = (unchecked((int)0xC0000025)),
                                                                                                                                                                                                                                                                                                                                                                                                     STATUS_INVALID_DISPOSITION = (unchecked((int)0xC0000026)),
                                                                                                                                                                                                                                                                                                                                                                                                                                  STATUS_ARRAY_BOUNDS_EXCEEDED = (unchecked((int)0xC000008C)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 STATUS_FLOAT_DENORMAL_OPERAND = (unchecked((int)0xC000008D)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 STATUS_FLOAT_DIVIDE_BY_ZERO = (unchecked((int)0xC000008E)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               STATUS_FLOAT_INEXACT_RESULT = (unchecked((int)0xC000008F)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             STATUS_FLOAT_INVALID_OPERATION = (unchecked((int)0xC0000090)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              STATUS_FLOAT_OVERFLOW = (unchecked((int)0xC0000091)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      STATUS_FLOAT_STACK_CHECK = (unchecked((int)0xC0000092)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 STATUS_FLOAT_UNDERFLOW = (unchecked((int)0xC0000093)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          STATUS_INTEGER_DIVIDE_BY_ZERO = (unchecked((int)0xC0000094)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          STATUS_INTEGER_OVERFLOW = (unchecked((int)0xC0000095)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    STATUS_PRIVILEGED_INSTRUCTION = (unchecked((int)0xC0000096)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    STATUS_STACK_OVERFLOW = (unchecked((int)0xC00000FD)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            STATUS_CONTROL_C_EXIT = (unchecked((int)0xC000013A)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    SIZE_OF_80387_REGISTERS = 80,
        SEMAPHORE_MODIFY_STATE = 0x0002,
        SECTION_QUERY = 0x0001,
        SECTION_MAP_WRITE = 0x0002,
        SECTION_MAP_READ = 0x0004,
        SECTION_MAP_EXECUTE = 0x0008,
        SECTION_EXTEND_SIZE = 0x0010,
        SEC_FILE = unchecked((int)0x800000),
        SEC_IMAGE = 0x1000000,
        SEC_RESERVE = 0x4000000,
        SEC_COMMIT = unchecked((int)0x8000000),
        SEC_NOCACHE = 0x10000000,
        SYNCHRONIZE = (0x00100000),
        STANDARD_RIGHTS_REQUIRED = (0x000F0000),
        STANDARD_RIGHTS_READ = ((0x00020000)),
        STANDARD_RIGHTS_WRITE = ((0x00020000)),
        STANDARD_RIGHTS_EXECUTE = ((0x00020000)),
        STANDARD_RIGHTS_ALL = (0x001F0000),
        SPECIFIC_RIGHTS_ALL = (0x0000FFFF),
        SID_REVISION = (1),
        SID_MAX_SUB_AUTHORITIES = (15),
        SID_RECOMMENDED_SUB_AUTHORITIES = (1),
        SECURITY_NULL_RID = (0x00000000),
        SECURITY_WORLD_RID = (0x00000000),
        SECURITY_LOCAL_RID = (0X00000000),
        SECURITY_CREATOR_OWNER_RID = (0x00000000),
        SECURITY_CREATOR_GROUP_RID = (0x00000001),
        SECURITY_CREATOR_OWNER_SERVER_RID = (0x00000002),
        SECURITY_CREATOR_GROUP_SERVER_RID = (0x00000003),
        SECURITY_DIALUP_RID = (0x00000001),
        SECURITY_NETWORK_RID = (0x00000002),
        SECURITY_BATCH_RID = (0x00000003),
        SECURITY_INTERACTIVE_RID = (0x00000004),
        SECURITY_SERVICE_RID = (0x00000006),
        SECURITY_ANONYMOUS_LOGON_RID = (0x00000007),
        SECURITY_PROXY_RID = (0x00000008),
        SECURITY_SERVER_LOGON_RID = (0x00000009),
        SECURITY_LOGON_IDS_RID = (0x00000005),
        SECURITY_LOGON_IDS_RID_COUNT = (3),
        SECURITY_LOCAL_SYSTEM_RID = (0x00000012),
        SECURITY_NT_NON_UNIQUE = (0x00000015),
        SECURITY_BUILTIN_DOMAIN_RID = (0x00000020),
        SE_GROUP_MANDATORY = (0x00000001),
        SE_GROUP_ENABLED_BY_DEFAULT = (0x00000002),
        SE_GROUP_ENABLED = (0x00000004),
        SE_GROUP_OWNER = (0x00000008),
        SE_GROUP_LOGON_ID = (unchecked((int)0xC0000000)),
        SYSTEM_AUDIT_ACE_TYPE = (0x2),
        SYSTEM_ALARM_ACE_TYPE = (0x3),
        SUCCESSFUL_ACCESS_ACE_FLAG = (0x40),
        SECURITY_DESCRIPTOR_REVISION = (1),
        SECURITY_DESCRIPTOR_REVISION1 = (1),
        SECURITY_DESCRIPTOR_MIN_LENGTH = (20),
        SE_OWNER_DEFAULTED = (0x0001),
        SE_GROUP_DEFAULTED = (0x0002),
        SE_DACL_PRESENT = (0x0004),
        SE_DACL_DEFAULTED = (0x0008),
        SE_SACL_PRESENT = (0x0010),
        SE_SACL_DEFAULTED = (0x0020),
        SE_SELF_RELATIVE = (unchecked((int)0x8000)),
        SE_PRIVILEGE_ENABLED_BY_DEFAULT = (0x00000001),
        SE_PRIVILEGE_ENABLED = (0x00000002),
        SE_PRIVILEGE_USED_FOR_ACCESS = (unchecked((int)0x80000000));
        public const bool SECURITY_DYNAMIC_TRACKING = (true),
                                                      SECURITY_STATIC_TRACKING = (false);
        public const int SACL_SECURITY_INFORMATION = (0X00000008),
                                                     SIZEOF_RFPO_DATA = 16,
        SERVICE_KERNEL_DRIVER = 0x00000001,
        SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
        SERVICE_ADAPTER = 0x00000004,
        SERVICE_RECOGNIZER_DRIVER = 0x00000008,
        SERVICE_WIN32_OWN_PROCESS = 0x00000010,
        SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
        SERVICE_INTERACTIVE_PROCESS = 0x00000100,
        SERVICE_BOOT_START = 0x00000000,
        SERVICE_SYSTEM_START = 0x00000001,
        SERVICE_AUTO_START = 0x00000002,
        SERVICE_DEMAND_START = 0x00000003,
        SERVICE_DISABLED = 0x00000004,
        SERVICE_ERROR_IGNORE = 0x00000000,
        SERVICE_ERROR_NORMAL = 0x00000001,
        SERVICE_ERROR_SEVERE = 0x00000002,
        SERVICE_ERROR_CRITICAL = 0x00000003,
        SERVER_ACCESS_ADMINISTER = 0x00000001,
        SERVER_ACCESS_ENUMERATE = 0x00000002;
        public const char SC_GROUP_IDENTIFIERW = '+',
        SC_GROUP_IDENTIFIERA = '+';
        public const int SERVICE_NO_CHANGE = unchecked((int)0xFfffffff),
        SERVICE_ACTIVE = 0x00000001,
        SERVICE_INACTIVE = 0x00000002,
        SERVICE_CONTROL_STOP = 0x00000001,
        SERVICE_CONTROL_PAUSE = 0x00000002,
        SERVICE_CONTROL_CONTINUE = 0x00000003,
        SERVICE_CONTROL_INTERROGATE = 0x00000004,
        SERVICE_CONTROL_SHUTDOWN = 0x00000005,
        SERVICE_STOPPED = 0x00000001,
        SERVICE_START_PENDING = 0x00000002,
        SERVICE_STOP_PENDING = 0x00000003,
        SERVICE_RUNNING = 0x00000004,
        SERVICE_CONTINUE_PENDING = 0x00000005,
        SERVICE_PAUSE_PENDING = 0x00000006,
        SERVICE_PAUSED = 0x00000007,
        SERVICE_ACCEPT_STOP = 0x00000001,
        SERVICE_ACCEPT_PAUSE_CONTINUE = 0x00000002,
        SERVICE_ACCEPT_SHUTDOWN = 0x00000004,
        SC_MANAGER_CONNECT = 0x0001,
        SC_MANAGER_CREATE_SERVICE = 0x0002,
        SC_MANAGER_ENUMERATE_SERVICE = 0x0004,
        SC_MANAGER_LOCK = 0x0008,
        SC_MANAGER_QUERY_LOCK_STATUS = 0x0010,
        SC_MANAGER_MODIFY_BOOT_CONFIG = 0x0020,
        SERVICE_QUERY_CONFIG = 0x0001,
        SERVICE_CHANGE_CONFIG = 0x0002,
        SERVICE_QUERY_STATUS = 0x0004,
        SERVICE_ENUMERATE_DEPENDENTS = 0x0008,
        SERVICE_START = 0x0010,
        SERVICE_STOP = 0x0020,
        SERVICE_PAUSE_CONTINUE = 0x0040,
        SERVICE_INTERROGATE = 0x0080,
        SERVICE_USER_DEFINED_CONTROL = 0x0100,
        SB_HORZ = 0,
        SB_VERT = 1,
        SB_CTL = 2,
        SB_BOTH = 3,
        SB_LINEUP = 0,
        SB_LINELEFT = 0,
        SB_LINEDOWN = 1,
        SB_LINERIGHT = 1,
        SB_PAGEUP = 2,
        SB_PAGELEFT = 2,
        SB_PAGEDOWN = 3,
        SB_PAGERIGHT = 3,
        SB_THUMBPOSITION = 4,
        SB_THUMBTRACK = 5,
        SB_TOP = 6,
        SB_LEFT = 6,
        SB_BOTTOM = 7,
        SB_RIGHT = 7,
        SB_ENDSCROLL = 8,
        SW_HIDE = 0,
        SW_SHOWNORMAL = 1,
        SW_NORMAL = 1,
        SW_SHOWMINIMIZED = 2,
        SW_SHOWMAXIMIZED = 3,
        SW_MAXIMIZE = 3,
        SW_SHOWNOACTIVATE = 4,
        SW_SHOW = 5,
        SW_MINIMIZE = 6,
        SW_SHOWMINNOACTIVE = 7,
        SW_SHOWNA = 8,
        SW_RESTORE = 9,
        SW_SHOWDEFAULT = 10,
        SW_MAX = 10,
        SHOW_OPENWINDOW = 1,
        SHOW_ICONWINDOW = 2,
        SHOW_FULLSCREEN = 3,
        SHOW_OPENNOACTIVATE = 4,
        SW_PARENTCLOSING = 1,
        SW_OTHERZOOM = 2,
        SW_PARENTOPENING = 3,
        SW_OTHERUNZOOM = 4,
        ST_BEGINSWP = 0,
        ST_ENDSWP = 1,
        SMTO_NORMAL = 0x0000,
        SMTO_BLOCK = 0x0001,
        SMTO_ABORTIFHUNG = 0x0002,
        SIZE_RESTORED = 0,
        SIZE_MINIMIZED = 1,
        SIZE_MAXIMIZED = 2,
        SIZE_MAXSHOW = 3,
        SIZE_MAXHIDE = 4,
        SIZENORMAL = 0,
        SIZEICONIC = 1,
        SIZEFULLSCREEN = 2,
        SIZEZOOMSHOW = 3,
        SIZEZOOMHIDE = 4,
        SWP_NOSIZE = 0x0001,
        SWP_NOMOVE = 0x0002,
        SWP_NOZORDER = 0x0004,
        SWP_NOREDRAW = 0x0008,
        SWP_NOACTIVATE = 0x0010,
        SWP_FRAMECHANGED = 0x0020,
        SWP_SHOWWINDOW = 0x0040,
        SWP_HIDEWINDOW = 0x0080,
        SWP_NOCOPYBITS = 0x0100,
        SWP_NOOWNERZORDER = 0x0200,
        SWP_NOSENDCHANGING = 0x0400,
        SWP_DRAWFRAME = 0x0020,
        SWP_NOREPOSITION = 0x0200,
        SWP_DEFERERASE = 0x2000,
        SWP_ASYNCWINDOWPOS = 0x4000,
        SM_CXSCREEN = 0,
        SM_CYSCREEN = 1,
        SM_CXVSCROLL = 2,
        SM_CYHSCROLL = 3,
        SM_CYCAPTION = 4,
        SM_CXBORDER = 5,
        SM_CYBORDER = 6,
        SM_CXDLGFRAME = 7,
        SM_CYDLGFRAME = 8,
        SM_CYVTHUMB = 9,
        SM_CXHTHUMB = 10,
        SM_CXICON = 11,
        SM_CYICON = 12,
        SM_CXCURSOR = 13,
        SM_CYCURSOR = 14,
        SM_CYMENU = 15,
        SM_CXFULLSCREEN = 16,
        SM_CYFULLSCREEN = 17,
        SM_CYKANJIWINDOW = 18,
        SM_MOUSEPRESENT = 19,
        SM_CYVSCROLL = 20,
        SM_CXHSCROLL = 21,
        SM_DEBUG = 22,
        SM_SWAPBUTTON = 23,
        SM_RESERVED1 = 24,
        SM_RESERVED2 = 25,
        SM_RESERVED3 = 26,
        SM_RESERVED4 = 27,
        SM_CXMIN = 28,
        SM_CYMIN = 29,
        SM_CXSIZE = 30,
        SM_CYSIZE = 31,
        SM_CXFRAME = 32,
        SM_CYFRAME = 33,
        SM_CXMINTRACK = 34,
        SM_CYMINTRACK = 35,
        SM_CXDOUBLECLK = 36,
        SM_CYDOUBLECLK = 37,
        SM_CXICONSPACING = 38,
        SM_CYICONSPACING = 39,
        SM_MENUDROPALIGNMENT = 40,
        SM_PENWINDOWS = 41,
        SM_DBCSENABLED = 42,
        SM_CMOUSEBUTTONS = 43,
        SM_CXFIXEDFRAME = 7,
        SM_CYFIXEDFRAME = 8,
        SM_CXSIZEFRAME = 32,
        SM_CYSIZEFRAME = 33,
        SM_SECURE = 44,
        SM_CXEDGE = 45,
        SM_CYEDGE = 46,
        SM_CXMINSPACING = 47,
        SM_CYMINSPACING = 48,
        SM_CXSMICON = 49,
        SM_CYSMICON = 50,
        SM_CYSMCAPTION = 51,
        SM_CXSMSIZE = 52,
        SM_CYSMSIZE = 53,
        SM_CXMENUSIZE = 54,
        SM_CYMENUSIZE = 55,
        SM_ARRANGE = 56,
        SM_CXMINIMIZED = 57,
        SM_CYMINIMIZED = 58,
        SM_CXMAXTRACK = 59,
        SM_CYMAXTRACK = 60,
        SM_CXMAXIMIZED = 61,
        SM_CYMAXIMIZED = 62,
        SM_NETWORK = 63,
        SM_CLEANBOOT = 67,
        SM_CXDRAG = 68,
        SM_CYDRAG = 69,
        SM_SHOWSOUNDS = 70,
        SM_CXMENUCHECK = 71,
        SM_CYMENUCHECK = 72,
        SM_SLOWMACHINE = 73,
        SM_MIDEASTENABLED = 74,
        SM_MOUSEWHEELPRESENT = 75,
        SM_XVIRTUALSCREEN = 76,
        SM_YVIRTUALSCREEN = 77,
        SM_CXVIRTUALSCREEN = 78,
        SM_CYVIRTUALSCREEN = 79,
        SM_CMONITORS = 80,
        SM_SAMEDISPLAYFORMAT = 81,
        SM_CMETRICS = 83;
        public const int SW_SCROLLCHILDREN = 0x0001,
        SW_INVALIDATE = 0x0002,
        SW_ERASE = 0x0004,
        SC_SIZE = 0xF000,
        SC_MOVE = 0xF010,
        SC_MINIMIZE = 0xF020,
        SC_MAXIMIZE = 0xF030,
        SC_NEXTWINDOW = 0xF040,
        SC_PREVWINDOW = 0xF050,
        SC_CLOSE = 0xF060,
        SC_VSCROLL = 0xF070,
        SC_HSCROLL = 0xF080,
        SC_MOUSEMENU = 0xF090,
        SC_KEYMENU = 0xF100,
        SC_ARRANGE = 0xF110,
        SC_RESTORE = 0xF120,
        SC_TASKLIST = 0xF130,
        SC_HOTKEY = 0xF150,
        SC_DEFAULT = 0xF160,
        SC_MONITORPOWER = 0xF170,
        SC_CONTEXTHELP = 0xF180,
        SC_SEPARATOR = 0xF00F,
        SC_ICON = 0xF020,
        SC_ZOOM = 0xF030,
        SS_LEFT = 0x00000000,
        SS_CENTER = 0x00000001,
        SS_RIGHT = 0x00000002,
        SS_ICON = 0x00000003,
        SS_BLACKRECT = 0x00000004,
        SS_GRAYRECT = 0x00000005,
        SS_WHITERECT = 0x00000006,
        SS_BLACKFRAME = 0x00000007,
        SS_GRAYFRAME = 0x00000008,
        SS_WHITEFRAME = 0x00000009,
        SS_USERITEM = 0x0000000A,
        SS_SIMPLE = 0x0000000B,
        SS_LEFTNOWORDWRAP = 0x0000000C,
        SS_OWNERDRAW = 0x0000000D,
        SS_BITMAP = 0x0000000E,
        SS_ENHMETAFILE = 0x0000000F,
        SS_ETCHEDHORZ = 0x00000010,
        SS_ETCHEDVERT = 0x00000011,
        SS_ETCHEDFRAME = 0x00000012,
        SS_TYPEMASK = 0x0000001F,
        SS_NOPREFIX = 0x00000080,
        SS_NOTIFY = 0x00000100,
        SS_CENTERIMAGE = 0x00000200,
        SS_RIGHTJUST = 0x00000400,
        SS_REALSIZEIMAGE = 0x00000800,
        SS_SUNKEN = 0x00001000,
        SS_ENDELLIPSIS = 0x00004000,
        SS_PATHELLIPSIS = 0x00008000,
        SS_WORDELLIPSIS = 0x0000C000,
        SS_ELLIPSISMASK = 0x0000C000,
        STM_SETICON = 0x0170,
        STM_GETICON = 0x0171,
        STM_SETIMAGE = 0x0172,
        STM_GETIMAGE = 0x0173,
        STN_CLICKED = 0,
        STN_DBLCLK = 1,
        STN_ENABLE = 2,
        STN_DISABLE = 3,
        STM_MSGMAX = 0x0174,
        SBS_HORZ = 0x0000,
        SBS_VERT = 0x0001,
        SBS_TOPALIGN = 0x0002,
        SBS_LEFTALIGN = 0x0002,
        SBS_BOTTOMALIGN = 0x0004,
        SBS_RIGHTALIGN = 0x0004,
        SBS_SIZEBOXTOPLEFTALIGN = 0x0002,
        SBS_SIZEBOXBOTTOMRIGHTALIGN = 0x0004,
        SBS_SIZEBOX = 0x0008,
        SBS_SIZEGRIP = 0x0010,
        SBM_SETPOS = 0x00E0,
        SBM_GETPOS = 0x00E1,
        SBM_SETRANGE = 0x00E2,
        SBM_SETRANGEREDRAW = 0x00E6,
        SBM_GETRANGE = 0x00E3,
        SBM_ENABLE_ARROWS = 0x00E4,
        SBM_SETSCROLLINFO = 0x00E9,
        SBM_GETSCROLLINFO = 0x00EA,
        SIF_RANGE = 0x0001,
        SIF_PAGE = 0x0002,
        SIF_POS = 0x0004,
        SIF_DISABLENOSCROLL = 0x0008,
        SIF_TRACKPOS = 0x0010,
        SIF_ALL = (0x0001|0x0002|0x0004|0x0010),
                  SPI_GETBEEP = 1,
        SPI_SETBEEP = 2,
        SPI_GETMOUSE = 3,
        SPI_SETMOUSE = 4,
        SPI_GETBORDER = 5,
        SPI_SETBORDER = 6,
        SPI_GETKEYBOARDSPEED = 10,
        SPI_SETKEYBOARDSPEED = 11,
        SPI_LANGDRIVER = 12,
        SPI_ICONHORIZONTALSPACING = 13,
        SPI_GETSCREENSAVETIMEOUT = 14,
        SPI_SETSCREENSAVETIMEOUT = 15,
        SPI_GETSCREENSAVEACTIVE = 16,
        SPI_SETSCREENSAVEACTIVE = 17,
        SPI_GETGRIDGRANULARITY = 18,
        SPI_SETGRIDGRANULARITY = 19,
        SPI_SETDESKWALLPAPER = 20,
        SPI_SETDESKPATTERN = 21,
        SPI_GETKEYBOARDDELAY = 22,
        SPI_SETKEYBOARDDELAY = 23,
        SPI_ICONVERTICALSPACING = 24,
        SPI_GETICONTITLEWRAP = 25,
        SPI_SETICONTITLEWRAP = 26,
        SPI_GETMENUDROPALIGNMENT = 27,
        SPI_SETMENUDROPALIGNMENT = 28,
        SPI_SETDOUBLECLKWIDTH = 29,
        SPI_SETDOUBLECLKHEIGHT = 30,
        SPI_GETICONTITLELOGFONT = 31,
        SPI_SETDOUBLECLICKTIME = 32,
        SPI_SETMOUSEBUTTONSWAP = 33,
        SPI_SETICONTITLELOGFONT = 34,
        SPI_GETFASTTASKSWITCH = 35,
        SPI_SETFASTTASKSWITCH = 36,
        SPI_SETDRAGFULLWINDOWS = 37,
        SPI_GETDRAGFULLWINDOWS = 38,
        SPI_GETNONCLIENTMETRICS = 41,
        SPI_SETNONCLIENTMETRICS = 42,
        SPI_GETMINIMIZEDMETRICS = 43,
        SPI_SETMINIMIZEDMETRICS = 44,
        SPI_GETICONMETRICS = 45,
        SPI_SETICONMETRICS = 46,
        SPI_SETWORKAREA = 47,
        SPI_GETWORKAREA = 48,
        SPI_SETPENWINDOWS = 49,
        SPI_GETHIGHCONTRAST = 66,
        SPI_SETHIGHCONTRAST = 67,
        SPI_GETKEYBOARDPREF = 68,
        SPI_SETKEYBOARDPREF = 69,
        SPI_GETSCREENREADER = 70,
        SPI_SETSCREENREADER = 71,
        SPI_GETANIMATION = 72,
        SPI_SETANIMATION = 73,
        SPI_GETFONTSMOOTHING = 74,
        SPI_SETFONTSMOOTHING = 75,
        SPI_SETDRAGWIDTH = 76,
        SPI_SETDRAGHEIGHT = 77,
        SPI_SETHANDHELD = 78,
        SPI_GETLOWPOWERTIMEOUT = 79,
        SPI_GETPOWEROFFTIMEOUT = 80,
        SPI_SETLOWPOWERTIMEOUT = 81,
        SPI_SETPOWEROFFTIMEOUT = 82,
        SPI_GETLOWPOWERACTIVE = 83,
        SPI_GETPOWEROFFACTIVE = 84,
        SPI_SETLOWPOWERACTIVE = 85,
        SPI_SETPOWEROFFACTIVE = 86,
        SPI_SETCURSORS = 87,
        SPI_SETICONS = 88,
        SPI_GETDEFAULTINPUTLANG = 89,
        SPI_SETDEFAULTINPUTLANG = 90,
        SPI_SETLANGTOGGLE = 91,
        SPI_GETWINDOWSEXTENSION = 92,
        SPI_SETMOUSETRAILS = 93,
        SPI_GETMOUSETRAILS = 94,
        SPI_SCREENSAVERRUNNING = 97,
        SPI_GETFILTERKEYS = 50,
        SPI_SETFILTERKEYS = 51,
        SPI_GETTOGGLEKEYS = 52,
        SPI_SETTOGGLEKEYS = 53,
        SPI_GETMOUSEKEYS = 54,
        SPI_SETMOUSEKEYS = 55,
        SPI_GETSHOWSOUNDS = 56,
        SPI_SETSHOWSOUNDS = 57,
        SPI_GETSTICKYKEYS = 58,
        SPI_SETSTICKYKEYS = 59,
        SPI_GETACCESSTIMEOUT = 60,
        SPI_SETACCESSTIMEOUT = 61,
        SPI_GETSERIALKEYS = 62,
        SPI_SETSERIALKEYS = 63,
        SPI_GETSOUNDSENTRY = 64,
        SPI_SETSOUNDSENTRY = 65,
        SPI_GETSNAPTODEFBUTTON = 95,
        SPI_SETSNAPTODEFBUTTON = 96,
        SPI_GETMOUSEHOVERWIDTH = 98,
        SPI_SETMOUSEHOVERWIDTH = 99,
        SPI_GETMOUSEHOVERHEIGHT = 100,
        SPI_SETMOUSEHOVERHEIGHT = 101,
        SPI_GETMOUSEHOVERTIME = 102,
        SPI_SETMOUSEHOVERTIME = 103,
        SPI_GETWHEELSCROLLLINES = 104,
        SPI_SETWHEELSCROLLLINES = 105,
        SPI_GETKEYBOARDCUES = 0x100A,
        SPI_GETMENUUNDERLINES = SPI_GETKEYBOARDCUES,
        SPIF_UPDATEINIFILE = 0x0001,
        SPIF_SENDWININICHANGE = 0x0002,
        SPIF_SENDCHANGE = 0x0002,
        SERKF_SERIALKEYSON = 0x00000001,
        SERKF_AVAILABLE = 0x00000002,
        SERKF_INDICATOR = 0x00000004,
        SKF_STICKYKEYSON = 0x00000001,
        SKF_AVAILABLE = 0x00000002,
        SKF_HOTKEYACTIVE = 0x00000004,
        SKF_CONFIRMHOTKEY = 0x00000008,
        SKF_HOTKEYSOUND = 0x00000010,
        SKF_INDICATOR = 0x00000020,
        SKF_AUDIBLEFEEDBACK = 0x00000040,
        SKF_TRISTATE = 0x00000080,
        SKF_TWOKEYSOFF = 0x00000100,
        SSGF_NONE = 0,
        SSGF_DISPLAY = 3,
        SSTF_NONE = 0,
        SSTF_CHARS = 1,
        SSTF_BORDER = 2,
        SSTF_DISPLAY = 3,
        SSWF_NONE = 0,
        SSWF_TITLE = 1,
        SSWF_WINDOW = 2,
        SSWF_DISPLAY = 3,
        SSWF_CUSTOM = 4,
        SSF_SOUNDSENTRYON = 0x00000001,
        SSF_AVAILABLE = 0x00000002,
        SSF_INDICATOR = 0x00000004,
        SLE_ERROR = 0x00000001,
        SLE_MINORERROR = 0x00000002,
        SLE_WARNING = 0x00000003,
        STD_CUT = 0,
        STD_COPY = 1,
        STD_PASTE = 2,
        STD_UNDO = 3,
        STD_REDOW = 4,
        STD_DELETE = 5,
        STD_FILENEW = 6,
        STD_FILEOPEN = 7,
        STD_FILESAVE = 8,
        STD_PRINTPRE = 9,
        STD_PROPERTIES = 10,
        STD_HELP = 11,
        STD_FIND = 12,
        STD_REPLACE = 13,
        STD_PRINT = 14,
        SBARS_SIZEGRIP = 0x0100,
        SB_SETTEXTA = (0x0400+1),
                      SB_SETTEXTW = (0x0400+11),
                                    SB_GETTEXTA = (0x0400+2),
                                                  SB_GETTEXTW = (0x0400+13),
                                                                SB_GETTEXTLENGTHA = (0x0400+3),
                                                                                    SB_GETTEXTLENGTHW = (0x0400+12),
                                                                                                        SB_SETPARTS = (0x0400+4),
                                                                                                                      SB_GETPARTS = (0x0400+6),
                                                                                                                                    SB_GETBORDERS = (0x0400+7),
                                                                                                                                                    SB_SETMINHEIGHT = (0x0400+8),
                                                                                                                                                                      SB_SIMPLE = (0x0400+9),
                                                                                                                                                                                  SB_GETRECT = (0x0400+10),
                                                                                                                                                                                               SB_ISSIMPLE = (0x0400+14),
                                                                                                                                                                                                             SB_SETICON = (0x0400+15),
                                                                                                                                                                                                                          SB_SETTIPTEXTA = (0x0400+16),
                                                                                                                                                                                                                                           SB_SETTIPTEXTW = (0x0400+17),
                                                                                                                                                                                                                                                            SB_GETTIPTEXTA = (0x0400+18),
                                                                                                                                                                                                                                                                             SB_GETTIPTEXTW = (0x0400+19),
                                                                                                                                                                                                                                                                                              SB_GETICON = (0x0400+20),
                                                                                                                                                                                                                                                                                                           SB_SETBKCOLOR = win.CCM_SETBKCOLOR,
        SB_SETUNICODEFORMAT = win.CCM_SETUNICODEFORMAT,
        SB_GETUNICODEFORMAT = win.CCM_GETUNICODEFORMAT,
        SBT_OWNERDRAW = 0x1000,
        SBT_NOBORDERS = 0x0100,
        SBT_POPOUT = 0x0200,
        SBT_RTLREADING = 0x0400,
        SBT_TOOLTIPS = 0x0800;
        public const char SC_GROUP_IDENTIFIER = '+';
        public const int SYSRGN = 4;
        public const int STILL_ACTIVE = (0x00000103),
                                        SEMAPHORE_ALL_ACCESS = ((0x000F0000)|(0x00100000)|0x3),
                                                               SRCCOPY = 0x00CC0020,
        SRCPAINT = 0x00EE0086,
        SRCAND = 0x008800C6,
        SRCINVERT = 0x00660046,
        SRCERASE = 0x00440328,
        STD_INPUT_HANDLE = -10,
        STD_OUTPUT_HANDLE = -11,
        STD_ERROR_HANDLE = -12,
        SBN_FIRST = (0-880),
                    SBN_LAST = (0-899),
                               SBN_SIMPLEMODECHANGE = (SBN_FIRST - 0);

        public const int S_OK =      0x00000000;
        public const int S_FALSE =   0x00000001;

        public static bool Succeeded(int hr) {
            return(hr >= 0);
        }

        public static bool Failed(int hr) {
            return(hr < 0);
        }


        public const bool TRUE = true;
        public const int TIMEOUT_ASYNC = unchecked((int)0xFFFFFFFF),
        TIME_MS = 0x0001,
        TIME_SAMPLES = 0x0002,
        TIME_BYTES = 0x0004,
        TIME_SMPTE = 0x0008,
        TIME_MIDI = 0x0010,
        TIME_TICKS = 0x0020,
        TIMERR_BASE = 96,
        TIMERR_NOERROR = (0),
                         TIMERR_NOCANDO = (96+1),
                                          TIMERR_STRUCT = (96+33),
                                                          TIME_ONESHOT = 0x0000,
        TIME_PERIODIC = 0x0001,
        TIME_CALLBACK_FUNCTION = 0x0000,
        TIME_CALLBACK_EVENT_SET = 0x0010,
        TIME_CALLBACK_EVENT_PULSE = 0x0020,
        TCP_BSDURGENT = 0x7000,
        TF_DISCONNECT = 0x01,
        TF_REUSE_SOCKET = 0x02,
        TF_WRITE_BEHIND = 0x04,
        TRANSPORT_TYPE_CN = 0x1,
        TRANSPORT_TYPE_DG = 0x2,
        TRANSPORT_TYPE_LPC = 0x4,
        TRANSPORT_TYPE_WMSG = unchecked((int)0x8);
        public const int TRUNCATE_EXISTING = 5,
        THREAD_PRIORITY_NORMAL = 0,
        TWOSTOPBITS = 2,
        TC_NORMAL = 0,
        TC_HARDERR = 1,
        TC_GP_TRAP = 2,
        TC_SIGNAL = 3;
        // TRUE = 1;
        public const int TYPE_E_BUFFERTOOSMALL = unchecked((int)0x80028016),
        TYPE_E_INVDATAREAD = unchecked((int)0x80028018),
        TYPE_E_UNSUPFORMAT = unchecked((int)0x80028019),
        TYPE_E_REGISTRYACCESS = unchecked((int)0x8002801C),
        TYPE_E_LIBNOTREGISTERED = unchecked((int)0x8002801D),
        TYPE_E_UNDEFINEDTYPE = unchecked((int)0x80028027),
        TYPE_E_QUALIFIEDNAMEDISALLOWED = unchecked((int)0x80028028),
        TYPE_E_INVALIDSTATE = unchecked((int)0x80028029),
        TYPE_E_WRONGTYPEKIND = unchecked((int)0x8002802A),
        TYPE_E_ELEMENTNOTFOUND = unchecked((int)0x8002802B),
        TYPE_E_AMBIGUOUSNAME = unchecked((int)0x8002802C),
        TYPE_E_NAMECONFLICT = unchecked((int)0x8002802D),
        TYPE_E_UNKNOWNLCID = unchecked((int)0x8002802E),
        TYPE_E_DLLFUNCTIONNOTFOUND = unchecked((int)0x8002802F),
        TYPE_E_BADMODULEKIND = unchecked((int)0x800288BD),
        TYPE_E_SIZETOOBIG = unchecked((int)0x800288C5),
        TYPE_E_DUPLICATEID = unchecked((int)0x800288C6),
        TYPE_E_INVALIDID = unchecked((int)0x800288CF),
        TYPE_E_TYPEMISMATCH = unchecked((int)0x80028CA0),
        TYPE_E_OUTOFBOUNDS = unchecked((int)0x80028CA1),
        TYPE_E_IOERROR = unchecked((int)0x80028CA2),
        TYPE_E_CANTCREATETMPFILE = unchecked((int)0x80028CA3),
        TYPE_E_CANTLOADLIBRARY = unchecked((int)0x80029C4A),
        TYPE_E_INCONSISTENTPROPFUNCS = unchecked((int)0x80029C83),
        TYPE_E_CIRCULARTYPE = unchecked((int)0x80029C84),
        TRUST_E_PROVIDER_UNKNOWN = unchecked((int)0x800B0001),
        TRUST_E_ACTION_UNKNOWN = unchecked((int)0x800B0002),
        TRUST_E_SUBJECT_FORM_UNKNOWN = unchecked((int)0x800B0003),
        TRUST_E_SUBJECT_NOT_TRUSTED = unchecked((int)0x800B0004),
        TRUST_E_NOSIGNATURE = unchecked((int)0x800B0100),
        TA_NOUPDATECP = 0,
        TA_UPDATECP = 1,
        TA_LEFT = 0,
        TA_RIGHT = 2,
        TA_CENTER = 6,
        TA_TOP = 0,
        TA_BOTTOM = 8,
        TA_BASELINE = 24,
        TA_RTLREADING = 256,
        TA_MASK = (24+6+1+256);
        // TA_MASK = (24+6+1);
        public const int TRANSFORM_CTM = 4107,
        TCI_SRCCHARSET = 1,
        TCI_SRCCODEPAGE = 2,
        TCI_SRCFONTSIG = 3,
        TMPF_FIXED_PITCH = 0x01,
        TMPF_VECTOR = 0x02,
        TMPF_DEVICE = 0x08,
        TMPF_TRUETYPE = 0x04,
        TURKISH_CHARSET = 162,
        THAI_CHARSET = 222,
        TRUETYPE_FONTTYPE = 0x004,
        TRANSPARENT = 1,
        TECHNOLOGY = 2,
        TEXTCAPS = 34,
        TC_OP_CHARACTER = 0x00000001,
        TC_OP_STROKE = 0x00000002,
        TC_CP_STROKE = 0x00000004,
        TC_CR_90 = 0x00000008,
        TC_CR_ANY = 0x00000010,
        TC_SF_X_YINDEP = 0x00000020,
        TC_SA_DOUBLE = 0x00000040,
        TC_SA_INTEGER = 0x00000080,
        TC_SA_CONTIN = 0x00000100,
        TC_EA_DOUBLE = 0x00000200,
        TC_IA_ABLE = 0x00000400,
        TC_UA_ABLE = 0x00000800,
        TC_SO_ABLE = 0x00001000,
        TC_RA_ABLE = 0x00002000,
        TC_VA_ABLE = 0x00004000,
        TC_RESERVED = 0x00008000,
        TC_SCROLLBLT = 0x00010000,
        TT_POLYGON_TYPE = 24,
        TT_PRIM_LINE = 1,
        TT_PRIM_QSPLINE = 2,
        TT_AVAILABLE = 0x0001,
        TT_ENABLED = 0x0002,
        TIME_NOMINUTESORSECONDS = 0x00000001,
        TIME_NOSECONDS = 0x00000002,
        TIME_NOTIMEMARKER = 0x00000004,
        TIME_FORCE24HOURFORMAT = 0x00000008,
        THREAD_TERMINATE = (0x0001),
                           THREAD_SUSPEND_RESUME = (0x0002),
                                                   THREAD_GET_CONTEXT = (0x0008),
                                                                        THREAD_SET_CONTEXT = (0x0010),
                                                                                             THREAD_SET_INFORMATION = (0x0020),
                                                                                                                      THREAD_QUERY_INFORMATION = (0x0040),
                                                                                                                                                 THREAD_SET_THREAD_TOKEN = (0x0080),
                                                                                                                                                                           THREAD_IMPERSONATE = (0x0100),
                                                                                                                                                                                                THREAD_DIRECT_IMPERSONATION = (0x0200),
                                                                                                                                                                                                                              TLS_MINIMUM_AVAILABLE = 64,
        THREAD_BASE_PRIORITY_LOWRT = 15,
        THREAD_BASE_PRIORITY_MAX = 2,
        THREAD_BASE_PRIORITY_MIN = -2,
        THREAD_BASE_PRIORITY_IDLE = -15,
        TIME_ZONE_ID_UNKNOWN = 0,
        TIME_ZONE_ID_STANDARD = 1,
        TIME_ZONE_ID_DAYLIGHT = 2,
        TOKEN_ASSIGN_PRIMARY = (0x0001),
                               TOKEN_DUPLICATE = (0x0002),
                                                 TOKEN_IMPERSONATE = (0x0004),
                                                                     TOKEN_QUERY = (0x0008),
                                                                                   TOKEN_QUERY_SOURCE = (0x0010),
                                                                                                        TOKEN_ADJUST_PRIVILEGES = (0x0020),
                                                                                                                                  TOKEN_ADJUST_GROUPS = (0x0040),
                                                                                                                                                        TOKEN_ADJUST_DEFAULT = (0x0080),
                                                                                                                                                                               TOKEN_EXECUTE = (((0x00020000))),
                                                                                                                                                                                               TOKEN_SOURCE_LENGTH = 8,
        TAPE_ERASE_SHORT = 0,
        TAPE_ERASE_LONG = 1,
        TAPE_LOAD = 0,
        TAPE_UNLOAD = 1,
        TAPE_TENSION = 2,
        TAPE_LOCK = 3,
        TAPE_UNLOCK = 4,
        TAPE_FORMAT = 5,
        TAPE_SETMARKS = 0,
        TAPE_FILEMARKS = 1,
        TAPE_SHORT_FILEMARKS = 2,
        TAPE_LONG_FILEMARKS = 3,
        TAPE_ABSOLUTE_POSITION = 0,
        TAPE_LOGICAL_POSITION = 1,
        TAPE_PSEUDO_LOGICAL_POSITION = 2,
        TAPE_REWIND = 0,
        TAPE_ABSOLUTE_BLOCK = 1,
        TAPE_LOGICAL_BLOCK = 2,
        TAPE_PSEUDO_LOGICAL_BLOCK = 3,
        TAPE_SPACE_END_OF_DATA = 4,
        TAPE_SPACE_RELATIVE_BLOCKS = 5,
        TAPE_SPACE_FILEMARKS = 6,
        TAPE_SPACE_SEQUENTIAL_FMKS = 7,
        TAPE_SPACE_SETMARKS = 8,
        TAPE_SPACE_SEQUENTIAL_SMKS = 9,
        TAPE_DRIVE_FIXED = 0x00000001,
        TAPE_DRIVE_SELECT = 0x00000002,
        TAPE_DRIVE_INITIATOR = 0x00000004,
        TAPE_DRIVE_ERASE_SHORT = 0x00000010,
        TAPE_DRIVE_ERASE_LONG = 0x00000020,
        TAPE_DRIVE_ERASE_BOP_ONLY = 0x00000040,
        TAPE_DRIVE_ERASE_IMMEDIATE = 0x00000080,
        TAPE_DRIVE_TAPE_CAPACITY = 0x00000100,
        TAPE_DRIVE_TAPE_REMAINING = 0x00000200,
        TAPE_DRIVE_FIXED_BLOCK = 0x00000400,
        TAPE_DRIVE_VARIABLE_BLOCK = 0x00000800,
        TAPE_DRIVE_WRITE_PROTECT = 0x00001000,
        TAPE_DRIVE_EOT_WZ_SIZE = 0x00002000,
        TAPE_DRIVE_ECC = 0x00010000,
        TAPE_DRIVE_COMPRESSION = 0x00020000,
        TAPE_DRIVE_PADDING = 0x00040000,
        TAPE_DRIVE_REPORT_SMKS = 0x00080000,
        TAPE_DRIVE_GET_ABSOLUTE_BLK = 0x00100000,
        TAPE_DRIVE_GET_LOGICAL_BLK = 0x00200000,
        TAPE_DRIVE_SET_EOT_WZ_SIZE = 0x00400000,
        TAPE_DRIVE_EJECT_MEDIA = 0x01000000,
        TAPE_DRIVE_RESERVED_BIT = unchecked((int)0x80000000),
        TAPE_DRIVE_LOAD_UNLOAD = unchecked((int)0x80000001),
        TAPE_DRIVE_TENSION = unchecked((int)0x80000002),
        TAPE_DRIVE_LOCK_UNLOCK = unchecked((int)0x80000004),
        TAPE_DRIVE_REWIND_IMMEDIATE = unchecked((int)0x80000008),
        TAPE_DRIVE_SET_BLOCK_SIZE = unchecked((int)0x80000010),
        TAPE_DRIVE_LOAD_UNLD_IMMED = unchecked((int)0x80000020),
        TAPE_DRIVE_TENSION_IMMED = unchecked((int)0x80000040),
        TAPE_DRIVE_LOCK_UNLK_IMMED = unchecked((int)0x80000080),
        TAPE_DRIVE_SET_ECC = unchecked((int)0x80000100),
        TAPE_DRIVE_SET_COMPRESSION = unchecked((int)0x80000200),
        TAPE_DRIVE_SET_PADDING = unchecked((int)0x80000400),
        TAPE_DRIVE_SET_REPORT_SMKS = unchecked((int)0x80000800),
        TAPE_DRIVE_ABSOLUTE_BLK = unchecked((int)0x80001000),
        TAPE_DRIVE_ABS_BLK_IMMED = unchecked((int)0x80002000),
        TAPE_DRIVE_LOGICAL_BLK = unchecked((int)0x80004000),
        TAPE_DRIVE_LOG_BLK_IMMED = unchecked((int)0x80008000),
        TAPE_DRIVE_END_OF_DATA = unchecked((int)0x80010000),
        TAPE_DRIVE_RELATIVE_BLKS = unchecked((int)0x80020000),
        TAPE_DRIVE_FILEMARKS = unchecked((int)0x80040000),
        TAPE_DRIVE_SEQUENTIAL_FMKS = unchecked((int)0x80080000),
        TAPE_DRIVE_SETMARKS = unchecked((int)0x80100000),
        TAPE_DRIVE_SEQUENTIAL_SMKS = unchecked((int)0x80200000),
        TAPE_DRIVE_REVERSE_POSITION = unchecked((int)0x80400000),
        TAPE_DRIVE_SPACE_IMMEDIATE = unchecked((int)0x80800000),
        TAPE_DRIVE_WRITE_SETMARKS = unchecked((int)0x81000000),
        TAPE_DRIVE_WRITE_FILEMARKS = unchecked((int)0x82000000),
        TAPE_DRIVE_WRITE_SHORT_FMKS = unchecked((int)0x84000000),
        TAPE_DRIVE_WRITE_LONG_FMKS = unchecked((int)0x88000000),
        TAPE_DRIVE_WRITE_MARK_IMMED = unchecked((int)0x90000000),
        TAPE_DRIVE_FORMAT = unchecked((int)0xA0000000),
        TAPE_DRIVE_FORMAT_IMMEDIATE = unchecked((int)0xC0000000),
        TAPE_DRIVE_HIGH_FEATURES = unchecked((int)0x80000000),
        TAPE_FIXED_PARTITIONS = 0,
        TAPE_SELECT_PARTITIONS = 1,
        TAPE_INITIATOR_PARTITIONS = 2,
        TME_HOVER = 0x00000001,
        TME_LEAVE = 0x00000002,
        TME_QUERY = 0x40000000,
        TME_CANCEL = unchecked((int)0x80000000),
        TPM_LEFTBUTTON = 0x0000,
        TPM_RIGHTBUTTON = 0x0002,
        TPM_LEFTALIGN = 0x0000,
        TPM_CENTERALIGN = 0x0004,
        TPM_RIGHTALIGN = 0x0008,
        TPM_TOPALIGN = 0x0000,
        TPM_VCENTERALIGN = 0x0010,
        TPM_BOTTOMALIGN = 0x0020,
        TPM_HORIZONTAL = 0x0000,
        TPM_VERTICAL = 0x0040,
        TPM_NONOTIFY = 0x0080,
        TPM_RETURNCMD = 0x0100,
        TKF_TOGGLEKEYSON = 0x00000001,
        TKF_AVAILABLE = 0x00000002,
        TKF_HOTKEYACTIVE = 0x00000004,
        TKF_CONFIRMHOTKEY = 0x00000008,
        TKF_HOTKEYSOUND = 0x00000010,
        TKF_INDICATOR = 0x00000020,
        TV_FIRST = 0x1100,
        TVN_FIRST = (0-400),
                    TVN_LAST = (0-499),
                               TTN_FIRST = (0-520),
                                           TTN_LAST = (0-549),
                                                      TCN_FIRST = (0-550),
                                                                  TCN_LAST = (0-580),
                                                                             TBN_FIRST = (0-700),
                                                                                         TBN_LAST = (0-720),
                                                                                                    TBSTATE_CHECKED = 0x01,
        TBSTATE_PRESSED = 0x02,
        TBSTATE_ENABLED = 0x04,
        TBSTATE_HIDDEN = 0x08,
        TBSTATE_INDETERMINATE = 0x10,
        TBSTATE_WRAP = 0x20,
        TBSTATE_ELLIPSES = 0x40,
        TBSTATE_MARKED = unchecked((int)0x80),
        TBSTYLE_BUTTON = 0x00,
        TBSTYLE_SEP = 0x01,
        TBSTYLE_CHECK = 0x02,
        TBSTYLE_GROUP = 0x04,
        TBSTYLE_CHECKGROUP = (0x04|0x02),
                             TBSTYLE_DROPDOWN = 0x08,
        TBSTYLE_AUTOSIZE = 0x10,
        TBSTYLE_NOPREFIX = 0x20,
        TBSTYLE_TOOLTIPS = 0x0100,
        TBSTYLE_WRAPABLE = 0x0200,
        TBSTYLE_ALTDRAG = 0x0400,
        TBSTYLE_FLAT = 0x0800,
        TBSTYLE_LIST = 0x1000,
        TBSTYLE_CUSTOMERASE = 0x2000,
        TBSTYLE_REGISTERDROP = 0x4000,
        TBSTYLE_TRANSPARENT = unchecked((int)0x8000),
        TBSTYLE_EX_DRAWDDARROWS = 0x00000001,
        TB_ENABLEBUTTON = (0x0400+1),
                          TB_CHECKBUTTON = (0x0400+2),
                                           TB_PRESSBUTTON = (0x0400+3),
                                                            TB_HIDEBUTTON = (0x0400+4),
                                                                            TB_INDETERMINATE = (0x0400+5),
                                                                                               TB_MARKBUTTON = (0x0400+6),
                                                                                                               TB_ISBUTTONENABLED = (0x0400+9),
                                                                                                                                    TB_ISBUTTONCHECKED = (0x0400+10),
                                                                                                                                                         TB_ISBUTTONPRESSED = (0x0400+11),
                                                                                                                                                                              TB_ISBUTTONHIDDEN = (0x0400+12),
                                                                                                                                                                                                  TB_ISBUTTONINDETERMINATE = (0x0400+13),
                                                                                                                                                                                                                             TB_ISBUTTONHIGHLIGHTED = (0x0400+14),
                                                                                                                                                                                                                                                      TB_SETSTATE = (0x0400+17),
                                                                                                                                                                                                                                                                    TB_GETSTATE = (0x0400+18),
                                                                                                                                                                                                                                                                                  TB_ADDBITMAP = (0x0400+19),
                                                                                                                                                                                                                                                                                                 TB_ADDBUTTONSA = (0x0400+20),
                                                                                                                                                                                                                                                                                                                  TB_ADDBUTTONSW = (0x0400+68),
                                                                                                                                                                                                                                                                                                                                   TB_INSERTBUTTONA = (0x0400+21),
                                                                                                                                                                                                                                                                                                                                                      TB_INSERTBUTTONW = (0x0400+67),
                                                                                                                                                                                                                                                                                                                                                                         TB_DELETEBUTTON = (0x0400+22),
                                                                                                                                                                                                                                                                                                                                                                                           TB_GETBUTTON = (0x0400+23),
                                                                                                                                                                                                                                                                                                                                                                                                          TB_BUTTONCOUNT = (0x0400+24),
                                                                                                                                                                                                                                                                                                                                                                                                                           TB_COMMANDTOINDEX = (0x0400+25),
                                                                                                                                                                                                                                                                                                                                                                                                                                               TB_SAVERESTOREA = (0x0400+26),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 TB_SAVERESTOREW = (0x0400+76),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TB_CUSTOMIZE = (0x0400+27),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  TB_ADDSTRINGA = (0x0400+28),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  TB_ADDSTRINGW = (0x0400+77),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  TB_GETITEMRECT = (0x0400+29),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TB_BUTTONSTRUCTSIZE = (0x0400+30),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TB_SETBUTTONSIZE = (0x0400+31),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TB_SETBITMAPSIZE = (0x0400+32),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TB_AUTOSIZE = (0x0400+33),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             TB_GETTOOLTIPS = (0x0400+35),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              TB_SETTOOLTIPS = (0x0400+36),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TB_SETPARENT = (0x0400+37),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              TB_SETROWS = (0x0400+39),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TB_GETROWS = (0x0400+40),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TB_GETBITMAPFLAGS = (0x0400+41),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TB_SETCMDID = (0x0400+42),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TB_CHANGEBITMAP = (0x0400+43),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TB_GETBITMAP = (0x0400+44),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TB_GETBUTTONTEXTA = (0x0400+45),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TB_GETBUTTONTEXTW = (0x0400+75),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TB_REPLACEBITMAP = (0x0400+46),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TB_SETINDENT = (0x0400+47),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     TB_SETIMAGELIST = (0x0400+48),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       TB_GETIMAGELIST = (0x0400+49),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TB_LOADIMAGES = (0x0400+50),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TB_GETRECT = (0x0400+51),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TB_SETHOTIMAGELIST = (0x0400+52),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TB_GETHOTIMAGELIST = (0x0400+53),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TB_SETDISABLEDIMAGELIST = (0x0400+54),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TB_GETDISABLEDIMAGELIST = (0x0400+55),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    TB_SETSTYLE = (0x0400+56),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  TB_GETSTYLE = (0x0400+57),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TB_GETBUTTONSIZE = (0x0400+58),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TB_SETBUTTONWIDTH = (0x0400+59),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       TB_SETMAXTEXTROWS = (0x0400+60),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TB_GETTEXTROWS = (0x0400+61),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TB_GETOBJECT = (0x0400+62),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TB_GETBUTTONINFOW = (0x0400+63),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TB_SETBUTTONINFOW = (0x0400+64),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TB_GETBUTTONINFOA = (0x0400+65),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       TB_SETBUTTONINFOA = (0x0400+66),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TB_HITTEST = (0x0400+69),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TB_GETHOTITEM = (0x0400+71),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TB_SETHOTITEM = (0x0400+72),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TB_SETANCHORHIGHLIGHT = (0x0400+73),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TB_GETANCHORHIGHLIGHT = (0x0400+74),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TB_MAPACCELERATORA = (0x0400+78),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             TB_GETINSERTMARK = (0x0400+79),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TB_SETINSERTMARK = (0x0400+80),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TB_INSERTMARKHITTEST = (0x0400+81),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TB_MOVEBUTTON = (0x0400+82),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TB_GETMAXSIZE = (0x0400+83),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TB_SETEXTENDEDSTYLE = (0x0400+84),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TB_GETEXTENDEDSTYLE = (0x0400+85),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TB_GETPADDING = (0x0400+86),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TB_SETPADDING = (0x0400+87),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TB_SETINSERTMARKCOLOR = (0x0400+88),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              TB_GETINSERTMARKCOLOR = (0x0400+89),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TB_MAPACCELERATORW = (0x0400+90),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TB_SETCOLORSCHEME = win.CCM_SETCOLORSCHEME,
        TB_GETCOLORSCHEME = win.CCM_GETCOLORSCHEME,
        TB_SETUNICODEFORMAT = win.CCM_SETUNICODEFORMAT,
        TB_GETUNICODEFORMAT = win.CCM_GETUNICODEFORMAT,
        TBIMHT_AFTER = 0x00000001,
        TBIMHT_BACKGROUND = 0x00000002,
        TBIF_IMAGE = 0x00000001,
        TBIF_TEXT = 0x00000002,
        TBIF_STATE = 0x00000004,
        TBIF_STYLE = 0x00000008,
        TBIF_LPARAM = 0x00000010,
        TBIF_COMMAND = 0x00000020,
        TBIF_SIZE = 0x00000040,
        TBBF_LARGE = 0x0001,
        TBN_GETBUTTONINFOA = ((0-700)-0),
                             TBN_GETBUTTONINFOW = ((0-700)-20),
                                                  TBN_BEGINDRAG = ((0-700)-1),
                                                                  TBN_ENDDRAG = ((0-700)-2),
                                                                                TBN_BEGINADJUST = ((0-700)-3),
                                                                                                  TBN_ENDADJUST = ((0-700)-4),
                                                                                                                  TBN_RESET = ((0-700)-5),
                                                                                                                              TBN_QUERYINSERT = ((0-700)-6),
                                                                                                                                                TBN_QUERYDELETE = ((0-700)-7),
                                                                                                                                                                  TBN_TOOLBARCHANGE = ((0-700)-8),
                                                                                                                                                                                      TBN_CUSTHELP = ((0-700)-9),
                                                                                                                                                                                                     TBN_DROPDOWN = ((0-700)-10),
                                                                                                                                                                                                                    TBN_CLOSEUP = ((0-700)-11),
                                                                                                                                                                                                                                  TBN_GETOBJECT = ((0-700)-12),
                                                                                                                                                                                                                                                  TBN_HOTITEMCHANGE = ((0-700)-13),
                                                                                                                                                                                                                                                                      TBN_DRAGOUT = ((0-700)-14),
                                                                                                                                                                                                                                                                                    TBN_DELETINGBUTTON = ((0-700)-15),
                                                                                                                                                                                                                                                                                                         TBN_GETDISPINFOA = ((0-700)-16),
                                                                                                                                                                                                                                                                                                                            TBN_GETDISPINFOW = ((0-700)-17),
                                                                                                                                                                                                                                                                                                                                               TBN_GETINFOTIPA = ((0-700)-18),
                                                                                                                                                                                                                                                                                                                                                                 TBN_GETINFOTIPW = ((0-700)-19),
                                                                                                                                                                                                                                                                                                                                                                                   TTS_ALWAYSTIP = 0x01,
        TTS_NOPREFIX = 0x02,
        TTF_IDISHWND = 0x0001,
        TTF_CENTERTIP = 0x0002,
        TTF_RTLREADING = 0x0004,
        TTF_SUBCLASS = 0x0010,
        TTF_TRACK = 0x0020,
        TTF_ABSOLUTE = 0x0080,
        TTF_TRANSPARENT = 0x0100,
        TTF_DI_SETITEM = unchecked((int)0x8000),
        TTDT_AUTOMATIC = 0,
        TTDT_RESHOW = 1,
        TTDT_AUTOPOP = 2,
        TTDT_INITIAL = 3,
        TTM_ACTIVATE = (0x0400+1),
        TTM_ADJUSTRECT = (0x400 + 31),
        TTM_SETDELAYTIME = (0x0400+3),
        TTM_ADDTOOLA = (0x0400+4),
        TTM_ADDTOOLW = (0x0400+50),
        TTM_DELTOOLA = (0x0400+5),
        TTM_DELTOOLW = (0x0400+51),
        TTM_NEWTOOLRECTA = (0x0400+6),
        TTM_NEWTOOLRECTW = (0x0400+52),
        TTM_RELAYEVENT = (0x0400+7),
        TTM_GETTOOLINFOA = (0x0400+8),
        TTM_GETTOOLINFOW = (0x0400+53),
        TTM_SETTOOLINFOA = (0x0400+9),
        TTM_SETTOOLINFOW = (0x0400+54),
        TTM_HITTESTA = (0x0400+10),
        TTM_HITTESTW = (0x0400+55),
        TTM_GETTEXTA = (0x0400+11),
        TTM_GETTEXTW = (0x0400+56),
        TTM_UPDATE = (0x0400+29),
        TTM_UPDATETIPTEXTA = (0x0400+12),
        TTM_UPDATETIPTEXTW = (0x0400+57),
        TTM_GETTOOLCOUNT = (0x0400+13),
        TTM_ENUMTOOLSA = (0x0400+14),
        TTM_ENUMTOOLSW = (0x0400+58),
        TTM_GETCURRENTTOOLA = (0x0400+15),
        TTM_GETCURRENTTOOLW = (0x0400+59),
        TTM_WINDOWFROMPOINT = (0x0400+16),
        TTM_TRACKACTIVATE = (0x0400+17),
        TTM_TRACKPOSITION = (0x0400+18),
        TTM_SETTIPBKCOLOR = (0x0400+19),
        TTM_SETTIPTEXTCOLOR = (0x0400+20),
        TTM_GETDELAYTIME = (0x0400+21),
        TTM_GETTIPBKCOLOR = (0x0400+22),
        TTM_GETTIPTEXTCOLOR = (0x0400+23),
        TTM_SETMAXTIPWIDTH = (0x0400+24),
        TTM_GETMAXTIPWIDTH = (0x0400+25),
        TTM_SETMARGIN = (0x0400+26),
        TTM_GETMARGIN = (0x0400+27),
        TTM_POP = (0x0400+28),
        TTN_GETDISPINFOA = ((0-520)-0),
        TTN_GETDISPINFOW = ((0-520)-10),
        TTN_SHOW = ((0-520)-1),
        TTN_POP = ((0-520)-2),
        TTN_NEEDTEXTA = ((0-520)-0),
        TTN_NEEDTEXTW = ((0-520)-10),
        TBS_AUTOTICKS = 0x0001,
        TBS_VERT = 0x0002,
        TBS_HORZ = 0x0000,
        TBS_TOP = 0x0004,
        TBS_BOTTOM = 0x0000,
        TBS_LEFT = 0x0004,
        TBS_RIGHT = 0x0000,
        TBS_BOTH = 0x0008,
        TBS_NOTICKS = 0x0010,
        TBS_ENABLESELRANGE = 0x0020,
        TBS_FIXEDLENGTH = 0x0040,
        TBS_NOTHUMB = 0x0080,
        TBS_TOOLTIPS = 0x0100,
        TBM_GETPOS = (0x0400),
                     TBM_GETRANGEMIN = (0x0400+1),
                                       TBM_GETRANGEMAX = (0x0400+2),
                                                         TBM_GETTIC = (0x0400+3),
                                                                      TBM_SETTIC = (0x0400+4),
                                                                                   TBM_SETPOS = (0x0400+5),
                                                                                                TBM_SETRANGE = (0x0400+6),
                                                                                                               TBM_SETRANGEMIN = (0x0400+7),
                                                                                                                                 TBM_SETRANGEMAX = (0x0400+8),
                                                                                                                                                   TBM_CLEARTICS = (0x0400+9),
                                                                                                                                                                   TBM_SETSEL = (0x0400+10),
                                                                                                                                                                                TBM_SETSELSTART = (0x0400+11),
                                                                                                                                                                                                  TBM_SETSELEND = (0x0400+12),
                                                                                                                                                                                                                  TBM_GETPTICS = (0x0400+14),
                                                                                                                                                                                                                                 TBM_GETTICPOS = (0x0400+15),
                                                                                                                                                                                                                                                 TBM_GETNUMTICS = (0x0400+16),
                                                                                                                                                                                                                                                                  TBM_GETSELSTART = (0x0400+17),
                                                                                                                                                                                                                                                                                    TBM_GETSELEND = (0x0400+18),
                                                                                                                                                                                                                                                                                                    TBM_CLEARSEL = (0x0400+19),
                                                                                                                                                                                                                                                                                                                   TBM_SETTICFREQ = (0x0400+20),
                                                                                                                                                                                                                                                                                                                                    TBM_SETPAGESIZE = (0x0400+21),
                                                                                                                                                                                                                                                                                                                                                      TBM_GETPAGESIZE = (0x0400+22),
                                                                                                                                                                                                                                                                                                                                                                        TBM_SETLINESIZE = (0x0400+23),
                                                                                                                                                                                                                                                                                                                                                                                          TBM_GETLINESIZE = (0x0400+24),
                                                                                                                                                                                                                                                                                                                                                                                                            TBM_GETTHUMBRECT = (0x0400+25),
                                                                                                                                                                                                                                                                                                                                                                                                                               TBM_GETCHANNELRECT = (0x0400+26),
                                                                                                                                                                                                                                                                                                                                                                                                                                                    TBM_SETTHUMBLENGTH = (0x0400+27),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TBM_GETTHUMBLENGTH = (0x0400+28),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              TBM_SETTOOLTIPS = (0x0400+29),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TBM_GETTOOLTIPS = (0x0400+30),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  TBM_SETTIPSIDE = (0x0400+31),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TBTS_TOP = 0,
        TBTS_LEFT = 1,
        TBTS_BOTTOM = 2,
        TBTS_RIGHT = 3,
        TBM_SETBUDDY = (0x0400+32),
                       TBM_GETBUDDY = (0x0400+33),
                                      TB_LINEUP = 0,
        TB_LINEDOWN = 1,
        TB_PAGEUP = 2,
        TB_PAGEDOWN = 3,
        TB_THUMBPOSITION = 4,
        TB_THUMBTRACK = 5,
        TB_TOP = 6,
        TB_BOTTOM = 7,
        TB_ENDTRACK = 8,
        TBCD_TICS = 0x0001,
        TBCD_THUMB = 0x0002,
        TBCD_CHANNEL = 0x0003,
        TBCDRF_NOEDGES = 0x00010000,
        TBCDRF_HILITEHOTTRACK = 0x00020000,
        TBCDRF_NOOFFSET = 0x00040000,
        TBCDRF_NOMARK = 0x00080000,
        TBCDRF_NOETCHEDEFFECT = 0x00100000,
        TVS_HASBUTTONS = 0x0001,
        TVS_HASLINES = 0x0002,
        TVS_LINESATROOT = 0x0004,
        TVS_EDITLABELS = 0x0008,
        TVS_DISABLEDRAGDROP = 0x0010,
        TVS_SHOWSELALWAYS = 0x0020,
        TVS_RTLREADING = 0x0040,
        TVS_NOTOOLTIPS = 0x0080,
        TVS_CHECKBOXES = 0x0100,
        TVS_TRACKSELECT = 0x0200,
        TVS_SHAREDIMAGELISTS = 0x0000,
        TVS_PRIVATEIMAGELISTS = 0x0400,
        TVS_FULLROWSELECT = 0x1000,
        TVIF_TEXT = 0x0001,
        TVIF_IMAGE = 0x0002,
        TVIF_PARAM = 0x0004,
        TVIF_STATE = 0x0008,
        TVIF_HANDLE = 0x0010,
        TVIF_SELECTEDIMAGE = 0x0020,
        TVIF_CHILDREN = 0x0040,
        TVIS_SELECTED = 0x0002,
        TVIS_CUT = 0x0004,
        TVIS_DROPHILITED = 0x0008,
        TVIS_BOLD = 0x0010,
        TVIS_EXPANDED = 0x0020,
        TVIS_EXPANDEDONCE = 0x0040,
        TVIS_EXPANDPARTIAL = 0x0080,
        TVIS_OVERLAYMASK = 0x0F00,
        TVIS_STATEIMAGEMASK = 0xF000,
        TVIS_USERMASK = 0xF000,
        TVI_ROOT = (unchecked((int)0xFFFF0000)),
                   TVI_FIRST = (unchecked((int)0xFFFF0001)),
                               TVI_LAST = (unchecked((int)0xFFFF0002)),
                                          TVI_SORT = (unchecked((int)0xFFFF0003)),
                                                     TVM_INSERTITEMA = (0x1100+0),
                                                                       TVM_INSERTITEMW = (0x1100+50),
                                                                                         TVM_DELETEITEM = (0x1100+1),
                                                                                                          TVM_EXPAND = (0x1100+2),
                                                                                                                       TVE_COLLAPSE = 0x0001,
        TVE_EXPAND = 0x0002,
        TVE_TOGGLE = 0x0003,
        TVE_EXPANDPARTIAL = 0x4000,
        TVE_COLLAPSERESET = unchecked((int)0x8000),
        TVM_GETITEMRECT = (0x1100+4),
                          TVM_GETCOUNT = (0x1100+5),
                                         TVM_GETINDENT = (0x1100+6),
                                                         TVM_SETINDENT = (0x1100+7),
                                                                         TVM_GETIMAGELIST = (0x1100+8),
                                                                                            TVSIL_NORMAL = 0,
        TVSIL_STATE = 2,
        TVM_SETIMAGELIST = (0x1100+9),
                           TVM_GETNEXTITEM = (0x1100+10),
                                             TVGN_ROOT = 0x0000,
        TVGN_NEXT = 0x0001,
        TVGN_PREVIOUS = 0x0002,
        TVGN_PARENT = 0x0003,
        TVGN_CHILD = 0x0004,
        TVGN_FIRSTVISIBLE = 0x0005,
        TVGN_NEXTVISIBLE = 0x0006,
        TVGN_PREVIOUSVISIBLE = 0x0007,
        TVGN_DROPHILITE = 0x0008,
        TVGN_CARET = 0x0009,
        TVM_SELECTITEM = (0x1100+11),
                         TVM_GETITEMA = (0x1100+12),
                                        TVM_GETITEMW = (0x1100+62),
                                                       TVM_SETITEMA = (0x1100+13),
                                                                      TVM_SETITEMW = (0x1100+63),
                                                                                     TVM_EDITLABELA = (0x1100+14),
                                                                                                      TVM_EDITLABELW = (0x1100+65),
                                                                                                                       TVM_GETEDITCONTROL = (0x1100+15),
                                                                                                                                            TVM_GETVISIBLECOUNT = (0x1100+16),
                                                                                                                                                                  TVM_HITTEST = (0x1100+17),
                                                                                                                                                                                TVHT_NOWHERE = 0x0001,
        TVHT_ONITEMICON = 0x0002,
        TVHT_ONITEMLABEL = 0x0004,
        TVHT_ONITEMINDENT = 0x0008,
        TVHT_ONITEMBUTTON = 0x0010,
        TVHT_ONITEMRIGHT = 0x0020,
        TVHT_ONITEMSTATEICON = 0x0040,
        TVHT_ABOVE = 0x0100,
        TVHT_BELOW = 0x0200,
        TVHT_TORIGHT = 0x0400,
        TVHT_TOLEFT = 0x0800,
        TVM_CREATEDRAGIMAGE = (0x1100+18),
                              TVM_SORTCHILDREN = (0x1100+19),
                                                 TVM_ENSUREVISIBLE = (0x1100+20),
                                                                     TVM_SORTCHILDRENCB = (0x1100+21),
                                                                                          TVM_ENDEDITLABELNOW = (0x1100+22),
                                                                                                                TVM_GETISEARCHSTRINGA = (0x1100+23),
                                                                                                                                        TVM_GETISEARCHSTRINGW = (0x1100+64),
                                                                                                                                                                TVM_SETTOOLTIPS = (0x1100+24),
                                                                                                                                                                                  TVM_GETTOOLTIPS = (0x1100+25),
                                                                                                                                                                                                    TVM_SETITEMHEIGHT = (0x1100+27),
                                                                                                                                                                                                                        TVM_GETITEMHEIGHT = (0x1100+28),
                                                                                                                                                                                                                                            TVN_SELCHANGINGA = ((0-400)-1),
                                                                                                                                                                                                                                                               TVN_SELCHANGINGW = ((0-400)-50),
                                                                                                                                                                                                                                                                                  TVN_SELCHANGEDA = ((0-400)-2),
                                                                                                                                                                                                                                                                                                    TVN_SELCHANGEDW = ((0-400)-51),
                                                                                                                                                                                                                                                                                                                      TVC_UNKNOWN = 0x0000,
        TVC_BYMOUSE = 0x0001,
        TVC_BYKEYBOARD = 0x0002,
        TVN_GETDISPINFOA = ((0-400)-3),
                           TVN_GETDISPINFOW = ((0-400)-52),
                                              TVN_SETDISPINFOA = ((0-400)-4),
                                                                 TVN_SETDISPINFOW = ((0-400)-53),
                                                                                    TVIF_DI_SETITEM = 0x1000,
        TVN_ITEMEXPANDINGA = ((0-400)-5),
                             TVN_ITEMEXPANDINGW = ((0-400)-54),
                                                  TVN_ITEMEXPANDEDA = ((0-400)-6),
                                                                      TVN_ITEMEXPANDEDW = ((0-400)-55),
                                                                                          TVN_BEGINDRAGA = ((0-400)-7),
                                                                                                           TVN_BEGINDRAGW = ((0-400)-56),
                                                                                                                            TVN_BEGINRDRAGA = ((0-400)-8),
                                                                                                                                              TVN_BEGINRDRAGW = ((0-400)-57),
                                                                                                                                                                TVN_DELETEITEMA = ((0-400)-9),
                                                                                                                                                                                  TVN_DELETEITEMW = ((0-400)-58),
                                                                                                                                                                                                    TVN_BEGINLABELEDITA = ((0-400)-10),
                                                                                                                                                                                                                          TVN_BEGINLABELEDITW = ((0-400)-59),
                                                                                                                                                                                                                                                TVN_ENDLABELEDITA = ((0-400)-11),
                                                                                                                                                                                                                                                                    TVN_ENDLABELEDITW = ((0-400)-60),
                                                                                                                                                                                                                                                                                        TVN_KEYDOWN = ((0-400)-12),
                                                                                                                                                                                                                                                                                                      TCS_SCROLLOPPOSITE = 0x0001,
        TCS_BOTTOM = 0x0002,
        TCS_RIGHT = 0x0002,
        TCS_MULTISELECT = 0x0004,
        TCS_FLATBUTTONS = 0x0008,
        TCS_FORCEICONLEFT = 0x0010,
        TCS_FORCELABELLEFT = 0x0020,
        TCS_HOTTRACK = 0x0040,
        TCS_VERTICAL = 0x0080,
        TCS_TABS = 0x0000,
        TCS_BUTTONS = 0x0100,
        TCS_SINGLELINE = 0x0000,
        TCS_MULTILINE = 0x0200,
        TCS_RIGHTJUSTIFY = 0x0000,
        TCS_FIXEDWIDTH = 0x0400,
        TCS_RAGGEDRIGHT = 0x0800,
        TCS_FOCUSONBUTTONDOWN = 0x1000,
        TCS_OWNERDRAWFIXED = 0x2000,
        TCS_TOOLTIPS = 0x4000,
        TCS_FOCUSNEVER = unchecked((int)0x8000),
        TCM_FIRST = 0x1300,
        TCM_GETIMAGELIST = (0x1300+2),
                           TCM_SETIMAGELIST = (0x1300+3),
                                              TCM_GETITEMCOUNT = (0x1300+4),
                                                                 TCIF_TEXT = 0x0001,
        TCIF_IMAGE = 0x0002,
        TCIF_RTLREADING = 0x0004,
        TCIF_PARAM = 0x0008,
        TCIF_STATE = 0x0010,
        TCIS_BUTTONPRESSED = 0x0001,
        TCM_GETITEMA = (0x1300+5),
                       TCM_GETITEMW = (0x1300+60),
                                      TCM_SETITEMA = (0x1300+6),
                                                     TCM_SETITEMW = (0x1300+61),
                                                                    TCM_INSERTITEMA = (0x1300+7),
                                                                                      TCM_INSERTITEMW = (0x1300+62),
                                                                                                        TCM_DELETEITEM = (0x1300+8),
                                                                                                                         TCM_DELETEALLITEMS = (0x1300+9),
                                                                                                                                              TCM_GETITEMRECT = (0x1300+10),
                                                                                                                                                                TCM_GETCURSEL = (0x1300+11),
                                                                                                                                                                                TCM_SETCURSEL = (0x1300+12),
                                                                                                                                                                                                TCHT_NOWHERE = 0x0001,
        TCHT_ONITEMICON = 0x0002,
        TCHT_ONITEMLABEL = 0x0004,
        TCHT_ONITEM = (0x0002|0x0004),
                      TCM_HITTEST = (0x1300+13),
                                    TCM_SETITEMEXTRA = (0x1300+14),
                                                       TCM_ADJUSTRECT = (0x1300+40),
                                                                        TCM_SETITEMSIZE = (0x1300+41),
                                                                                          TCM_REMOVEIMAGE = (0x1300+42),
                                                                                                            TCM_SETPADDING = (0x1300+43),
                                                                                                                             TCM_GETROWCOUNT = (0x1300+44),
                                                                                                                                               TCM_GETTOOLTIPS = (0x1300+45),
                                                                                                                                                                 TCM_SETTOOLTIPS = (0x1300+46),
                                                                                                                                                                                   TCM_GETCURFOCUS = (0x1300+47),
                                                                                                                                                                                                     TCM_SETCURFOCUS = (0x1300+48),
                                                                                                                                                                                                                       TCM_SETMINTABWIDTH = (0x1300+49),
                                                                                                                                                                                                                                            TCM_DESELECTALL = (0x1300+50),
                                                                                                                                                                                                                                                              TCN_KEYDOWN = ((0-550)-0),
                                                                                                                                                                                                                                                                            TCN_SELCHANGE = ((0-550)-1),
                                                                                                                                                                                                                                                                                            TCN_SELCHANGING = ((0-550)-2),
                                                                                                                                                                                                                                                                                                              THREAD_PRIORITY_LOWEST = -2,
        THREAD_PRIORITY_BELOW_NORMAL = (-2+1),
                                       THREAD_PRIORITY_HIGHEST = 2,
        THREAD_PRIORITY_ABOVE_NORMAL = (2-1),
                                       THREAD_PRIORITY_ERROR_RETURN = (0x7fffffff),
                                                                      THREAD_PRIORITY_TIME_CRITICAL = 15,
        THREAD_PRIORITY_IDLE = -15,
        TVHT_ONITEM = (0x0002|0x0004|0x0040),
                      TBDDRET_DEFAULT = 0,
        TBDDRET_NODEFAULT = 1,
        TBDDRET_TREATPRESSED = 2,
        TBNF_IMAGE = 0x00000001,
        TBNF_TEXT = 0x00000002,
        TBNF_DI_SETITEM = 0x10000000;

        public const int TYMED_HGLOBAL      = 1;
        public const int TYMED_FILE         = 2;
        public const int TYMED_ISTREAM      = 4;
        public const int TYMED_ISTORAGE     = 8;
        public const int TYMED_GDI          = 16;
        public const int TYMED_MFPICT       = 32;
        public const int TYMED_ENHMF        = 64;
        public const int TYMED_NULL         = 0;

        public const int UI_CAP_2700 = 0x00000001,
        UI_CAP_ROT90 = 0x00000002,
        UI_CAP_ROTANY = 0x00000004,
        UIS_SET = 1,
        UIS_CLEAR = 2,
        UIS_INITIALIZE = 3,
        UISF_HIDEFOCUS = 0x1,
        UISF_HIDEACCEL = 0x2,
        UNIQUE_NAME = 0x00,
        UPDFCACHE_NODATACACHE = (0x1),
                                UPDFCACHE_ONSAVECACHE = (0x2),
                                                        UPDFCACHE_ONSTOPCACHE = (0x4),
                                                                                UPDFCACHE_NORMALCACHE = (unchecked((int)0x8)),
                                                                                                        UPDFCACHE_IFBLANK = (0x10),
                                                                                                                            UPDFCACHE_ONLYIFBLANK = (unchecked((int)0x80000000)),
                                                                                                                                                    UPDFCACHE_IFBLANKORONSAVECACHE = ((0x10)|(0x2)),
                                                                                                                                                                                     UPDFCACHE_ALL = (~(unchecked((int)0x80000000))),
                                                                                                                                                                                                     UPDFCACHE_ALLBUTNODATACACHE = ((~(unchecked((int)0x80000000)))&~(0x1)),
                                                                                                                                                                                                                                   USERCLASSTYPE_FULL = 1,
        USERCLASSTYPE_SHORT = 2,
        USERCLASSTYPE_APPNAME = 3,
        USER_MARSHAL_FC_BYTE = 1,
        USER_MARSHAL_FC_CHAR = 2,
        USER_MARSHAL_FC_SMALL = 3,
        USER_MARSHAL_FC_USMALL = 4,
        USER_MARSHAL_FC_WCHAR = 5,
        USER_MARSHAL_FC_SHORT = 6,
        USER_MARSHAL_FC_USHORT = 7,
        USER_MARSHAL_FC_LONG = 8,
        USER_MARSHAL_FC_ULONG = 9,
        USER_MARSHAL_FC_FLOAT = 10,
        USER_MARSHAL_FC_HYPER = 11,
        USER_MARSHAL_FC_DOUBLE = 12,
        UNLOAD_DLL_DEBUG_EVENT = 7,
        UNIVERSAL_NAME_INFO_LEVEL = 0x00000001,
        UOI_FLAGS = 1,
        UOI_NAME = 2,
        UOI_TYPE = 3,
        UOI_USER_SID = 4,
        UDN_FIRST = (0-721),
                    UDN_LAST = (0-740),
                               UD_MAXVAL = 0x7fff,
        UD_MINVAL = (-0x7fff),
                    UDS_WRAP = 0x0001,
        UDS_SETBUDDYINT = 0x0002,
        UDS_ALIGNRIGHT = 0x0004,
        UDS_ALIGNLEFT = 0x0008,
        UDS_AUTOBUDDY = 0x0010,
        UDS_ARROWKEYS = 0x0020,
        UDS_HORZ = 0x0040,
        UDS_NOTHOUSANDS = 0x0080,
        UDS_HOTTRACK = 0x0100,
        UDM_SETRANGE = (0x0400+101),
                       UDM_GETRANGE = (0x0400+102),
                                      UDM_SETPOS = (0x0400+103),
                                                   UDM_GETPOS = (0x0400+104),
                                                                UDM_SETBUDDY = (0x0400+105),
                                                                               UDM_GETBUDDY = (0x0400+106),
                                                                                              UDM_SETACCEL = (0x0400+107),
                                                                                                             UDM_GETACCEL = (0x0400+108),
                                                                                                                            UDM_SETBASE = (0x0400+109),
                                                                                                                                          UDM_GETBASE = (0x0400+110),
                                                                                                                                                        UDM_SETRANGE32 = (0x0400+111),
                                                                                                                                                                         UDM_GETRANGE32 = (0x0400+112),
                                                                                                                                                                                          /* NT5 begin */
                                                                                                                                                                                          ULW_COLORKEY            =0x00000001,
        ULW_ALPHA               =0x00000002,
        ULW_OPAQUE              =0x00000004,
        /* NT5 end */
        UDN_DELTAPOS = ((0-721)-1);










        public const int VARIANT_NOVALUEPROP = 0x1,
        VARIANT_ALPHABOOL = 0x2,
        VARIANT_NOUSEROVERRIDE = 0x4,
        VAR_TIMEVALUEONLY = (0x00000001),
                            VAR_DATEVALUEONLY = (0x00000002),
                                                VAR_VALIDDATE = 0x0004,
        VAR_CALENDAR_HIJRI = 0x0008,
        VARIANT_CALENDAR_HIJRI = 0x0008,
        VER_PLATFORM_WIN32s = 0,
        VER_PLATFORM_WIN32_WINDOWS = 1,
        VER_PLATFORM_WIN32_NT = 2,
        VIEW_E_FIRST = unchecked((int)0x80040140),
        VIEW_E_LAST = unchecked((int)0x8004014F),
        VIEW_S_FIRST = 0x00040140,
        VIEW_S_LAST = 0x0004014F,
        VIEW_E_DRAW = unchecked((int)0x80040140),
        VIEW_S_ALREADY_FROZEN = 0x00040140,
        VTA_BASELINE = 24,
        VTA_LEFT = 8,
        VTA_RIGHT = 0,
        VTA_CENTER = 6,
        VTA_BOTTOM = 2,
        VTA_TOP = 0,
        VARIABLE_PITCH = 2,
        VIETNAMESE_CHARSET = 163,
        VERTSIZE = 6,
        VERTRES = 10,
        VREFRESH = 116,
        VALID_INHERIT_FLAGS = (0xF),
                              VK_LBUTTON = 0x01,
        VK_RBUTTON = 0x02,
        VK_CANCEL = 0x03,
        VK_MBUTTON = 0x04,
        VK_BACK = 0x08,
        VK_TAB = 0x09,
        VK_CLEAR = 0x0C,
        VK_RETURN = 0x0D,
        VK_SHIFT = 0x10,
        VK_CONTROL = 0x11,
        VK_MENU = 0x12,
        VK_PAUSE = 0x13,
        VK_CAPITAL = 0x14,
        VK_ESCAPE = 0x1B,
        VK_SPACE = 0x20,
        VK_PRIOR = 0x21,
        VK_NEXT = 0x22,
        VK_END = 0x23,
        VK_HOME = 0x24,
        VK_LEFT = 0x25,
        VK_UP = 0x26,
        VK_RIGHT = 0x27,
        VK_DOWN = 0x28,
        VK_SELECT = 0x29,
        VK_PRINT = 0x2A,
        VK_EXECUTE = 0x2B,
        VK_SNAPSHOT = 0x2C,
        VK_INSERT = 0x2D,
        VK_DELETE = 0x2E,
        VK_HELP = 0x2F,
        VK_LWIN = 0x5B,
        VK_RWIN = 0x5C,
        VK_APPS = 0x5D,
        VK_NUMPAD0 = 0x60,
        VK_NUMPAD1 = 0x61,
        VK_NUMPAD2 = 0x62,
        VK_NUMPAD3 = 0x63,
        VK_NUMPAD4 = 0x64,
        VK_NUMPAD5 = 0x65,
        VK_NUMPAD6 = 0x66,
        VK_NUMPAD7 = 0x67,
        VK_NUMPAD8 = 0x68,
        VK_NUMPAD9 = 0x69,
        VK_MULTIPLY = 0x6A,
        VK_ADD = 0x6B,
        VK_SEPARATOR = 0x6C,
        VK_SUBTRACT = 0x6D,
        VK_DECIMAL = 0x6E,
        VK_DIVIDE = 0x6F,
        VK_F1 = 0x70,
        VK_F2 = 0x71,
        VK_F3 = 0x72,
        VK_F4 = 0x73,
        VK_F5 = 0x74,
        VK_F6 = 0x75,
        VK_F7 = 0x76,
        VK_F8 = 0x77,
        VK_F9 = 0x78,
        VK_F10 = 0x79,
        VK_F11 = 0x7A,
        VK_F12 = 0x7B,
        VK_F13 = 0x7C,
        VK_F14 = 0x7D,
        VK_F15 = 0x7E,
        VK_F16 = 0x7F,
        VK_F17 = unchecked((int)0x80),
        VK_F18 = unchecked((int)0x81),
        VK_F19 = unchecked((int)0x82),
        VK_F20 = unchecked((int)0x83),
        VK_F21 = unchecked((int)0x84),
        VK_F22 = unchecked((int)0x85),
        VK_F23 = unchecked((int)0x86),
        VK_F24 = unchecked((int)0x87),
        VK_NUMLOCK = 0x90,
        VK_SCROLL = 0x91,
        VK_LSHIFT = 0xA0,
        VK_RSHIFT = 0xA1,
        VK_LCONTROL = 0xA2,
        VK_RCONTROL = 0xA3,
        VK_LMENU = 0xA4,
        VK_RMENU = 0xA5,
        VK_PROCESSKEY = 0xE5,
        VK_ATTN = 0xF6,
        VK_CRSEL = 0xF7,
        VK_EXSEL = 0xF8,
        VK_EREOF = 0xF9,
        VK_PLAY = 0xFA,
        VK_ZOOM = 0xFB,
        VK_NONAME = 0xFC,
        VK_PA1 = 0xFD,
        VK_OEM_CLEAR = 0xFE,
        VS_FILE_INFO = 16,
        VS_VERSION_INFO = 1,
        VS_USER_DEFINED = 100,
        VS_FFI_SIGNATURE = unchecked((int)0xFEEF04BD),
        VS_FFI_STRUCVERSION = 0x00010000,
        VS_FFI_FILEFLAGSMASK = 0x0000003F,
        VS_FF_DEBUG = 0x00000001,
        VS_FF_PRERELEASE = 0x00000002,
        VS_FF_PATCHED = 0x00000004,
        VS_FF_PRIVATEBUILD = 0x00000008,
        VS_FF_INFOINFERRED = 0x00000010,
        VS_FF_SPECIALBUILD = 0x00000020,
        VOS_UNKNOWN = 0x00000000,
        VOS_DOS = 0x00010000,
        VOS_OS216 = 0x00020000,
        VOS_OS232 = 0x00030000,
        VOS_NT = 0x00040000,
        VOS__BASE = 0x00000000,
        VOS__WINDOWS16 = 0x00000001,
        VOS__PM16 = 0x00000002,
        VOS__PM32 = 0x00000003,
        VOS__WINDOWS32 = 0x00000004,
        VOS_DOS_WINDOWS16 = 0x00010001,
        VOS_DOS_WINDOWS32 = 0x00010004,
        VOS_OS216_PM16 = 0x00020002,
        VOS_OS232_PM32 = 0x00030003,
        VOS_NT_WINDOWS32 = 0x00040004,
        VFT_UNKNOWN = 0x00000000,
        VFT_APP = 0x00000001,
        VFT_DLL = 0x00000002,
        VFT_DRV = 0x00000003,
        VFT_FONT = 0x00000004,
        VFT_VXD = 0x00000005,
        VFT_STATIC_LIB = 0x00000007,
        VFT2_UNKNOWN = 0x00000000,
        VFT2_DRV_PRINTER = 0x00000001,
        VFT2_DRV_KEYBOARD = 0x00000002,
        VFT2_DRV_LANGUAGE = 0x00000003,
        VFT2_DRV_DISPLAY = 0x00000004,
        VFT2_DRV_MOUSE = 0x00000005,
        VFT2_DRV_NETWORK = 0x00000006,
        VFT2_DRV_SYSTEM = 0x00000007,
        VFT2_DRV_INSTALLABLE = 0x00000008,
        VFT2_DRV_SOUND = 0x00000009,
        VFT2_DRV_COMM = 0x0000000A,
        VFT2_DRV_INPUTMETHOD = 0x0000000B,
        VFT2_FONT_RASTER = 0x00000001,
        VFT2_FONT_VECTOR = 0x00000002,
        VFT2_FONT_TRUETYPE = 0x00000003,
        VFFF_ISSHAREDFILE = 0x0001,
        VFF_CURNEDEST = 0x0001,
        VFF_FILEINUSE = 0x0002,
        VFF_BUFFTOOSMALL = 0x0004,
        VIFF_FORCEINSTALL = 0x0001,
        VIFF_DONTDELETEOLD = 0x0002,
        VIF_TEMPFILE = 0x00000001,
        VIF_MISMATCH = 0x00000002,
        VIF_SRCOLD = 0x00000004,
        VIF_DIFFLANG = 0x00000008,
        VIF_DIFFCODEPG = 0x00000010,
        VIF_DIFFTYPE = 0x00000020,
        VIF_WRITEPROT = 0x00000040,
        VIF_FILEINUSE = 0x00000080,
        VIF_OUTOFSPACE = 0x00000100,
        VIF_ACCESSVIOLATION = 0x00000200,
        VIF_SHARINGVIOLATION = 0x00000400,
        VIF_CANNOTCREATE = 0x00000800,
        VIF_CANNOTDELETE = 0x00001000,
        VIF_CANNOTRENAME = 0x00002000,
        VIF_CANNOTDELETECUR = 0x00004000,
        VIF_OUTOFMEMORY = 0x00008000,
        VIF_CANNOTREADSRC = 0x00010000,
        VIF_CANNOTREADDST = 0x00020000,
        VIF_BUFFTOOSMALL = 0x00040000,
        VIEW_LARGEICONS = 0,
        VIEW_SMALLICONS = 1,
        VIEW_LIST = 2,
        VIEW_DETAILS = 3,
        VIEW_SORTNAME = 4,
        VIEW_SORTSIZE = 5,
        VIEW_SORTDATE = 6,
        VIEW_SORTTYPE = 7,
        VIEW_PARENTFOLDER = 8,
        VIEW_NETCONNECT = 9,
        VIEW_NETDISCONNECT = 10,
        VIEW_NEWFOLDER = 11,
        VIEW_VIEWMENU = 12;

        public const int WM_DDE_FIRST = 0x03E0,
        WM_DDE_INITIATE = (0x03E0),
                          WM_DDE_TERMINATE = (0x03E0+1),
                                             WM_DDE_ADVISE = (0x03E0+2),
                                                             WM_DDE_UNADVISE = (0x03E0+3),
                                                                               WM_DDE_ACK = (0x03E0+4),
                                                                                            WM_DDE_DATA = (0x03E0+5),
                                                                                                          WM_DDE_REQUEST = (0x03E0+6),
                                                                                                                           WM_DDE_POKE = (0x03E0+7),
                                                                                                                                         WM_DDE_EXECUTE = (0x03E0+8),
                                                                                                                                                          WM_DDE_LAST = (0x03E0+8),
                                                                                                                                                                        WAVERR_BASE = 32,
        WAVERR_BADFORMAT = (32+0),
                           WAVERR_STILLPLAYING = (32+1),
                                                 WAVERR_UNPREPARED = (32+2),
                                                                     WAVERR_SYNC = (32+3),
                                                                                   WAVERR_LASTERROR = (32+3),
                                                                                                      WOM_OPEN = 0x3BB,
        WOM_CLOSE = 0x3BC,
        WOM_DONE = 0x3BD,
        WIM_OPEN = 0x3BE,
        WIM_CLOSE = 0x3BF,
        WIM_DATA = 0x3C0,
        WAVE_FORMAT_QUERY = 0x0001,
        WAVE_ALLOWSYNC = 0x0002,
        WAVE_MAPPED = 0x0004,
        WAVE_FORMAT_DIRECT = 0x0008,
        WAVE_FORMAT_DIRECT_QUERY = (0x0001|0x0008),
                                   WHDR_DONE = 0x00000001,
        WHDR_PREPARED = 0x00000002,
        WHDR_BEGINLOOP = 0x00000004,
        WHDR_ENDLOOP = 0x00000008,
        WHDR_INQUEUE = 0x00000010,
        WAVECAPS_PITCH = 0x0001,
        WAVECAPS_PLAYBACKRATE = 0x0002,
        WAVECAPS_VOLUME = 0x0004,
        WAVECAPS_LRVOLUME = 0x0008,
        WAVECAPS_SYNC = 0x0010,
        WAVECAPS_SAMPLEACCURATE = 0x0020,
        WAVECAPS_DIRECTSOUND = 0x0040,
        WAVE_INVALIDFORMAT = 0x00000000,
        WAVE_FORMAT_1M08 = 0x00000001,
        WAVE_FORMAT_1S08 = 0x00000002,
        WAVE_FORMAT_1M16 = 0x00000004,
        WAVE_FORMAT_1S16 = 0x00000008,
        WAVE_FORMAT_2M08 = 0x00000010,
        WAVE_FORMAT_2S08 = 0x00000020,
        WAVE_FORMAT_2M16 = 0x00000040,
        WAVE_FORMAT_2S16 = 0x00000080,
        WAVE_FORMAT_4M08 = 0x00000100,
        WAVE_FORMAT_4S08 = 0x00000200,
        WAVE_FORMAT_4M16 = 0x00000400,
        WAVE_FORMAT_4S16 = 0x00000800,
        WAVE_FORMAT_PCM = 1,
        WIN32 = 100,
        WIZ_CXDLG = 276,
        WIZ_CYDLG = 140,
        WIZ_CXBMP = 80,
        WIZ_BODYX = 92,
        WIZ_BODYCX = 184,
        WIN_CERT_REVISION_1_0 = (0x0100),
                                WIN_CERT_TYPE_X509 = (0x0001),
                                                     WIN_CERT_TYPE_PKCS_SIGNED_DATA = (0x0002),
                                                                                      WIN_CERT_TYPE_RESERVED_1 = (0x0003),
                                                                                                                 WINDOW_BUFFER_SIZE_EVENT = 0x0004,
        WINVER = 0x0400,
        WHITEONBLACK = 2,
        WINDING = 2,
        WHITE_BRUSH = 0,
        WHITE_PEN = 6,
        WGL_FONT_LINES = 0,
        WGL_FONT_POLYGONS = 1,
        WGL_SWAP_MAIN_PLANE = 0x00000001,
        WGL_SWAP_OVERLAY1 = 0x00000002,
        WGL_SWAP_OVERLAY2 = 0x00000004,
        WGL_SWAP_OVERLAY3 = 0x00000008,
        WGL_SWAP_OVERLAY4 = 0x00000010,
        WGL_SWAP_OVERLAY5 = 0x00000020,
        WGL_SWAP_OVERLAY6 = 0x00000040,
        WGL_SWAP_OVERLAY7 = 0x00000080,
        WGL_SWAP_OVERLAY8 = 0x00000100,
        WGL_SWAP_OVERLAY9 = 0x00000200,
        WGL_SWAP_OVERLAY10 = 0x00000400,
        WGL_SWAP_OVERLAY11 = 0x00000800,
        WGL_SWAP_OVERLAY12 = 0x00001000,
        WGL_SWAP_OVERLAY13 = 0x00002000,
        WGL_SWAP_OVERLAY14 = 0x00004000,
        WGL_SWAP_OVERLAY15 = 0x00008000,
        WGL_SWAP_UNDERLAY1 = 0x00010000,
        WGL_SWAP_UNDERLAY2 = 0x00020000,
        WGL_SWAP_UNDERLAY3 = 0x00040000,
        WGL_SWAP_UNDERLAY4 = 0x00080000,
        WGL_SWAP_UNDERLAY5 = 0x00100000,
        WGL_SWAP_UNDERLAY6 = 0x00200000,
        WGL_SWAP_UNDERLAY7 = 0x00400000,
        WGL_SWAP_UNDERLAY8 = 0x00800000,
        WGL_SWAP_UNDERLAY9 = 0x01000000,
        WGL_SWAP_UNDERLAY10 = 0x02000000,
        WGL_SWAP_UNDERLAY11 = 0x04000000,
        WGL_SWAP_UNDERLAY12 = 0x08000000,
        WGL_SWAP_UNDERLAY13 = 0x10000000,
        WGL_SWAP_UNDERLAY14 = 0x20000000,
        WGL_SWAP_UNDERLAY15 = 0x40000000,
        WNNC_NET_MSNET = 0x00010000,
        WNNC_NET_LANMAN = 0x00020000,
        WNNC_NET_NETWARE = 0x00030000,
        WNNC_NET_VINES = 0x00040000,
        WNNC_NET_10NET = 0x00050000,
        WNNC_NET_LOCUS = 0x00060000,
        WNNC_NET_SUN_PC_NFS = 0x00070000,
        WNNC_NET_LANSTEP = 0x00080000,
        WNNC_NET_9TILES = 0x00090000,
        WNNC_NET_LANTASTIC = 0x000A0000,
        WNNC_NET_AS400 = 0x000B0000,
        WNNC_NET_FTP_NFS = 0x000C0000,
        WNNC_NET_PATHWORKS = 0x000D0000,
        WNNC_NET_LIFENET = 0x000E0000,
        WNNC_NET_POWERLAN = 0x000F0000,
        WNNC_NET_BWNFS = 0x00100000,
        WNNC_NET_COGENT = 0x00110000,
        WNNC_NET_FARALLON = 0x00120000,
        WNNC_NET_APPLETALK = 0x00130000,
        WNNC_NET_INTERGRAPH = 0x00140000,
        WNNC_NET_SYMFONET = 0x00150000,
        WNNC_NET_CLEARCASE = 0x00160000,
        WNFMT_MULTILINE = 0x01,
        WNFMT_ABBREVIATED = 0x02,
        WNFMT_INENUM = 0x10,
        WNFMT_CONNECTION = 0x20,
        WN_SUCCESS = 0,
        WN_NO_ERROR = 0,
        WN_NOT_SUPPORTED = 50,
        WN_CANCEL = 1223,
        WN_RETRY = 1237,
        WN_NET_ERROR = 59,
        WN_MORE_DATA = 234,
        WN_BAD_POINTER = 487,
        WN_BAD_VALUE = 87,
        WN_BAD_USER = 2202,
        WN_BAD_PASSWORD = 86,
        WN_ACCESS_DENIED = 5,
        WN_FUNCTION_BUSY = 170,
        WN_WINDOWS_ERROR = 59,
        WN_OUT_OF_MEMORY = 8,
        WN_NO_NETWORK = 1222,
        WN_EXTENDED_ERROR = 1208,
        WN_BAD_LEVEL = 124,
        WN_BAD_HANDLE = 6,
        WN_NOT_INITIALIZING = 1247,
        WN_NO_MORE_DEVICES = 1248,
        WN_NOT_CONNECTED = 2250,
        WN_OPEN_FILES = 2401,
        WN_DEVICE_IN_USE = 2404,
        WN_BAD_NETNAME = 67,
        WN_BAD_LOCALNAME = 1200,
        WN_ALREADY_CONNECTED = 85,
        WN_DEVICE_ERROR = 31,
        WN_CONNECTION_CLOSED = 1201,
        WN_NO_NET_OR_BAD_PATH = 1203,
        WN_BAD_PROVIDER = 1204,
        WN_CANNOT_OPEN_PROFILE = 1205,
        WN_BAD_PROFILE = 1206,
        WN_BAD_DEV_TYPE = 66,
        WN_DEVICE_ALREADY_REMEMBERED = 1202,
        WN_NO_MORE_ENTRIES = 259,
        WN_NOT_CONTAINER = 1207,
        WN_NOT_AUTHENTICATED = 1244,
        WN_NOT_LOGGED_ON = 1245,
        WN_NOT_VALIDATED = 1311,
        WNCON_FORNETCARD = 0x00000001,
        WNCON_NOTROUTED = 0x00000002,
        WNCON_SLOWLINK = 0x00000004,
        WNCON_DYNAMIC = 0x00000008,
        WC_DEFAULTCHECK = 0x00000100,
        WC_COMPOSITECHECK = 0x00000200,
        WC_DISCARDNS = 0x00000010,
        WC_SEPCHARS = 0x00000020,
        WC_DEFAULTCHAR = 0x00000040,
        WRITE_DAC = (0x00040000),
                    WRITE_OWNER = (0x00080000),
                                  WIN31_CLASS = 0,
        WH_MIN = (-1),
                 WH_MSGFILTER = (-1),
                                WH_JOURNALRECORD = 0,
        WH_JOURNALPLAYBACK = 1,
        WH_KEYBOARD = 2,
        WH_GETMESSAGE = 3,
        WH_CALLWNDPROC = 4,
        WH_CBT = 5,
        WH_SYSMSGFILTER = 6,
        WH_MOUSE = 7,
        WH_HARDWARE = 8,
        WH_DEBUG = 9,
        WH_SHELL = 10,
        WH_FOREGROUNDIDLE = 11,
        WH_CALLWNDPROCRET = 12,
        WH_MAX = 12;
        // WH_MAX = 11;
        public const int WH_MINHOOK = (-1),
                                      WH_MAXHOOK = 12,
        WINSTA_ENUMDESKTOPS = 0x0001,
        WINSTA_READATTRIBUTES = 0x0002,
        WINSTA_ACCESSCLIPBOARD = 0x0004,
        WINSTA_CREATEDESKTOP = 0x0008,
        WINSTA_WRITEATTRIBUTES = 0x0010,
        WINSTA_ACCESSGLOBALATOMS = 0x0020,
        WINSTA_EXITWINDOWS = 0x0040,
        WINSTA_ENUMERATE = 0x0100,
        WINSTA_READSCREEN = 0x0200,
        WSF_VISIBLE = 0x0001,
        WM_NULL = 0x0000,
        WM_CREATE = 0x0001,
        WM_DESTROY = 0x0002,
        WM_MOVE = 0x0003,
        WM_SIZE = 0x0005,
        WM_ACTIVATE = 0x0006,
        WA_INACTIVE = 0,
        WA_ACTIVE = 1,
        WA_CLICKACTIVE = 2,
        WM_SETFOCUS = 0x0007,
        WM_KILLFOCUS = 0x0008,
        WM_ENABLE = 0x000A,
        WM_SETREDRAW = 0x000B,
        WM_SETTEXT = 0x000C,
        WM_GETTEXT = 0x000D,
        WM_GETTEXTLENGTH = 0x000E,
        WM_PAINT = 0x000F,
        WM_CLOSE = 0x0010,
        WM_QUERYENDSESSION = 0x0011,
        WM_QUIT = 0x0012,
        WM_QUERYOPEN = 0x0013,
        WM_ERASEBKGND = 0x0014,
        WM_SYSCOLORCHANGE = 0x0015,
        WM_ENDSESSION = 0x0016,
        WM_SHOWWINDOW = 0x0018,
        WM_WININICHANGE = 0x001A,
        WM_SETTINGCHANGE = 0x001A,
        WM_DEVMODECHANGE = 0x001B,
        WM_ACTIVATEAPP = 0x001C,
        WM_FONTCHANGE = 0x001D,
        WM_TIMECHANGE = 0x001E,
        WM_CANCELMODE = 0x001F,
        WM_SETCURSOR = 0x0020,
        WM_MOUSEACTIVATE = 0x0021,
        WM_CHILDACTIVATE = 0x0022,
        WM_QUEUESYNC = 0x0023,
        WM_GETMINMAXINFO = 0x0024,
        WM_PAINTICON = 0x0026,
        WM_ICONERASEBKGND = 0x0027,
        WM_NEXTDLGCTL = 0x0028,
        WM_SPOOLERSTATUS = 0x002A,
        WM_DRAWITEM = 0x002B,
        WM_MEASUREITEM = 0x002C,
        WM_DELETEITEM = 0x002D,
        WM_VKEYTOITEM = 0x002E,
        WM_CHARTOITEM = 0x002F,
        WM_SETFONT = 0x0030,
        WM_GETFONT = 0x0031,
        WM_SETHOTKEY = 0x0032,
        WM_GETHOTKEY = 0x0033,
        WM_QUERYDRAGICON = 0x0037,
        WM_COMPAREITEM = 0x0039,
        WM_GETOBJECT = 0x003D,
        WM_COMPACTING = 0x0041,
        WM_COMMNOTIFY = 0x0044,
        WM_WINDOWPOSCHANGING = 0x0046,
        WM_WINDOWPOSCHANGED = 0x0047,
        WM_POWER = 0x0048,
        WM_COPYDATA = 0x004A,
        WM_CANCELJOURNAL = 0x004B,
        WM_NOTIFY = 0x004E,
        WM_INPUTLANGCHANGEREQUEST = 0x0050,
        WM_INPUTLANGCHANGE = 0x0051,
        WM_TCARD = 0x0052,
        WM_HELP = 0x0053,
        WM_USERCHANGED = 0x0054,
        WM_NOTIFYFORMAT = 0x0055,
        WM_CONTEXTMENU = 0x007B,
        WM_STYLECHANGING = 0x007C,
        WM_STYLECHANGED = 0x007D,
        WM_DISPLAYCHANGE = 0x007E,
        WM_GETICON = 0x007F,
        WM_SETICON = 0x0080,
        WM_NCCREATE = 0x0081,
        WM_NCDESTROY = 0x0082,
        WM_NCCALCSIZE = 0x0083,
        WM_NCHITTEST = 0x0084,
        WM_NCPAINT = 0x0085,
        WM_NCACTIVATE = 0x0086,
        WM_GETDLGCODE = 0x0087,
        WM_NCMOUSEMOVE = 0x00A0,
        WM_NCLBUTTONDOWN = 0x00A1,
        WM_NCLBUTTONUP = 0x00A2,
        WM_NCLBUTTONDBLCLK = 0x00A3,
        WM_NCRBUTTONDOWN = 0x00A4,
        WM_NCRBUTTONUP = 0x00A5,
        WM_NCRBUTTONDBLCLK = 0x00A6,
        WM_NCMBUTTONDOWN = 0x00A7,
        WM_NCMBUTTONUP = 0x00A8,
        WM_NCMBUTTONDBLCLK = 0x00A9,
        WM_KEYFIRST = 0x0100,
        WM_KEYDOWN = 0x0100,
        WM_KEYUP = 0x0101,
        WM_CHAR = 0x0102,
        WM_DEADCHAR = 0x0103,
        WM_SYSKEYDOWN = 0x0104,
        WM_SYSKEYUP = 0x0105,
        WM_SYSCHAR = 0x0106,
        WM_SYSDEADCHAR = 0x0107,
        WM_KEYLAST = 0x0108,
        WM_IME_STARTCOMPOSITION = 0x010D,
        WM_IME_ENDCOMPOSITION = 0x010E,
        WM_IME_COMPOSITION = 0x010F,
        WM_IME_KEYLAST = 0x010F,
        WM_INITDIALOG = 0x0110,
        WM_COMMAND = 0x0111,
        WM_SYSCOMMAND = 0x0112,
        WM_TIMER = 0x0113,
        WM_HSCROLL = 0x0114,
        WM_VSCROLL = 0x0115,
        WM_INITMENU = 0x0116,
        WM_INITMENUPOPUP = 0x0117,
        WM_MENUSELECT = 0x011F,
        WM_MENUCHAR = 0x0120,
        WM_ENTERIDLE = 0x0121,
        WM_CHANGEUISTATE = 0x0127,
        WM_UPDATEUISTATE = 0x0128,
        WM_QUERYUISTATE = 0x0129,
        WM_CTLCOLORMSGBOX = 0x0132,
        WM_CTLCOLOREDIT = 0x0133,
        WM_CTLCOLORLISTBOX = 0x0134,
        WM_CTLCOLORBTN = 0x0135,
        WM_CTLCOLORDLG = 0x0136,
        WM_CTLCOLORSCROLLBAR = 0x0137,
        WM_CTLCOLORSTATIC = 0x0138,
        WM_MOUSEFIRST = 0x0200,
        WM_MOUSEMOVE = 0x0200,
        WM_LBUTTONDOWN = 0x0201,
        WM_LBUTTONUP = 0x0202,
        WM_LBUTTONDBLCLK = 0x0203,
        WM_RBUTTONDOWN = 0x0204,
        WM_RBUTTONUP = 0x0205,
        WM_RBUTTONDBLCLK = 0x0206,
        WM_MBUTTONDOWN = 0x0207,
        WM_MBUTTONUP = 0x0208,
        WM_MBUTTONDBLCLK = 0x0209,
        WM_NCMOUSEHOVER = 0x02A0,
        WM_NCMOUSELEAVE = 0x02A2,
        WM_MOUSEWHEEL = 0x020A,
        WM_MOUSELAST = 0x020A;
        public const int WHEEL_DELTA = 120,
        WM_PARENTNOTIFY = 0x0210,
        WM_ENTERMENULOOP = 0x0211,
        WM_EXITMENULOOP = 0x0212,
        WM_NEXTMENU = 0x0213,
        WM_SIZING = 0x0214,
        WM_CAPTURECHANGED = 0x0215,
        WM_MOVING = 0x0216,
        WM_POWERBROADCAST = 0x0218,
        WM_DEVICECHANGE = 0x0219,
        WM_IME_SETCONTEXT = 0x0281,
        WM_IME_NOTIFY = 0x0282,
        WM_IME_CONTROL = 0x0283,
        WM_IME_COMPOSITIONFULL = 0x0284,
        WM_IME_SELECT = 0x0285,
        WM_IME_CHAR = 0x0286,
        WM_IME_KEYDOWN = 0x0290,
        WM_IME_KEYUP = 0x0291,
        WM_MDICREATE = 0x0220,
        WM_MDIDESTROY = 0x0221,
        WM_MDIACTIVATE = 0x0222,
        WM_MDIRESTORE = 0x0223,
        WM_MDINEXT = 0x0224,
        WM_MDIMAXIMIZE = 0x0225,
        WM_MDITILE = 0x0226,
        WM_MDICASCADE = 0x0227,
        WM_MDIICONARRANGE = 0x0228,
        WM_MDIGETACTIVE = 0x0229,
        WM_MDISETMENU = 0x0230,
        WM_ENTERSIZEMOVE = 0x0231,
        WM_EXITSIZEMOVE = 0x0232,
        WM_DROPFILES = 0x0233,
        WM_MDIREFRESHMENU = 0x0234,
        WM_MOUSEHOVER = 0x02A1,
        WM_MOUSELEAVE = 0x02A3,
        WM_CUT = 0x0300,
        WM_COPY = 0x0301,
        WM_PASTE = 0x0302,
        WM_CLEAR = 0x0303,
        WM_UNDO = 0x0304,
        WM_RENDERFORMAT = 0x0305,
        WM_RENDERALLFORMATS = 0x0306,
        WM_DESTROYCLIPBOARD = 0x0307,
        WM_DRAWCLIPBOARD = 0x0308,
        WM_PAINTCLIPBOARD = 0x0309,
        WM_VSCROLLCLIPBOARD = 0x030A,
        WM_SIZECLIPBOARD = 0x030B,
        WM_ASKCBFORMATNAME = 0x030C,
        WM_CHANGECBCHAIN = 0x030D,
        WM_HSCROLLCLIPBOARD = 0x030E,
        WM_QUERYNEWPALETTE = 0x030F,
        WM_PALETTEISCHANGING = 0x0310,
        WM_PALETTECHANGED = 0x0311,
        WM_HOTKEY = 0x0312,
        WM_PRINT = 0x0317,
        WM_PRINTCLIENT = 0x0318,
        WM_HANDHELDFIRST = 0x0358,
        WM_HANDHELDLAST = 0x035F,
        WM_AFXFIRST = 0x0360,
        WM_AFXLAST = 0x037F,
        WM_PENWINFIRST = 0x0380,
        WM_PENWINLAST = 0x038F,
        WM_APP = unchecked((int)0x8000),
        WM_USER = 0x0400,
        WMSZ_LEFT = 1,
        WMSZ_RIGHT = 2,
        WMSZ_TOP = 3,
        WMSZ_TOPLEFT = 4,
        WMSZ_TOPRIGHT = 5,
        WMSZ_BOTTOM = 6,
        WMSZ_BOTTOMLEFT = 7,
        WMSZ_BOTTOMRIGHT = 8,
        WVR_ALIGNTOP = 0x0010,
        WVR_ALIGNLEFT = 0x0020,
        WVR_ALIGNBOTTOM = 0x0040,
        WVR_ALIGNRIGHT = 0x0080,
        WVR_HREDRAW = 0x0100,
        WVR_VREDRAW = 0x0200,
        WVR_VALIDRECTS = 0x0400,
        WS_OVERLAPPED = 0x00000000,
        WS_POPUP = unchecked((int)0x80000000),
        WS_CHILD = 0x40000000,
        WS_MINIMIZE = 0x20000000,
        WS_VISIBLE = 0x10000000,
        WS_DISABLED = 0x08000000,
        WS_CLIPSIBLINGS = 0x04000000,
        WS_CLIPCHILDREN = 0x02000000,
        WS_MAXIMIZE = 0x01000000,
        WS_CAPTION = 0x00C00000,
        WS_BORDER = 0x00800000,
        WS_DLGFRAME = 0x00400000,
        WS_VSCROLL = 0x00200000,
        WS_HSCROLL = 0x00100000,
        WS_SYSMENU = 0x00080000,
        WS_THICKFRAME = 0x00040000,
        WS_GROUP = 0x00020000,
        WS_TABSTOP = 0x00010000,
        WS_MINIMIZEBOX = 0x00020000,
        WS_MAXIMIZEBOX = 0x00010000,
        WS_TILED = 0x00000000,
        WS_ICONIC = 0x20000000,
        WS_SIZEBOX = 0x00040000,
        WS_OVERLAPPEDWINDOW = (0x00000000|0x00C00000|0x00080000|0x00040000|0x00020000|0x00010000),
                              WS_POPUPWINDOW = (unchecked((int)0x80000000)|0x00800000|0x00080000),
                                               WS_CHILDWINDOW = (0x40000000),
                                                                WS_EX_DLGMODALFRAME = 0x00000001,
        WS_EX_NOPARENTNOTIFY = 0x00000004,
        WS_EX_TOPMOST = 0x00000008,
        WS_EX_ACCEPTFILES = 0x00000010,
        WS_EX_TRANSPARENT = 0x00000020,
        WS_EX_MDICHILD = 0x00000040,
        WS_EX_TOOLWINDOW = 0x00000080,
        WS_EX_WINDOWEDGE = 0x00000100,
        WS_EX_CLIENTEDGE = 0x00000200,
        WS_EX_CONTEXTHELP = 0x00000400,
        WS_EX_RIGHT = 0x00001000,
        WS_EX_LEFT = 0x00000000,
        WS_EX_RTLREADING = 0x00002000,
        WS_EX_LTRREADING = 0x00000000,
        WS_EX_LEFTSCROLLBAR = 0x00004000,
        WS_EX_RIGHTSCROLLBAR = 0x00000000,
        WS_EX_CONTROLPARENT = 0x00010000,
        WS_EX_STATICEDGE = 0x00020000,
        WS_EX_APPWINDOW = 0x00040000,
        WS_EX_OVERLAPPEDWINDOW = (0x00000100|0x00000200),
                                 WS_EX_PALETTEWINDOW = (0x00000100|0x00000080|0x00000008),

                                                       /* NT5 Begin */
                                                       WS_EX_LAYERED           = 0x00080000,
        WS_EX_NOINHERITLAYOUT   = 0x00100000, // Disable inheritence of mirroring by children
        WS_EX_LAYOUTRTL         = 0x00400000, // Right to left mirroring
        WS_EX_NOACTIVATE        = 0x08000000,
        /* NT5 End */

        WPF_SETMINPOSITION = 0x0001,
        WPF_RESTORETOMAXIMIZED = 0x0002,
        WB_LEFT = 0,
        WB_RIGHT = 1,
        WB_ISDELIMITER = 2,
        WDT_INPROC_CALL = (0x48746457),
                          WDT_REMOTE_CALL = (0x52746457),
                                            WM_CHOOSEFONT_GETLOGFONT = (0x0400+1),
                                                                       WM_PSD_PAGESETUPDLG = (0x0400),
                                                                                             WM_PSD_FULLPAGERECT = (0x0400+1),
                                                                                                                   WM_PSD_MINMARGINRECT = (0x0400+2),
                                                                                                                                          WM_PSD_MARGINRECT = (0x0400+3),
                                                                                                                                                              WM_PSD_GREEKTEXTRECT = (0x0400+4),
                                                                                                                                                                                     WM_PSD_ENVSTAMPRECT = (0x0400+5),
                                                                                                                                                                                                           WM_PSD_YAFULLPAGERECT = (0x0400+6),
                                                                                                                                                                                                                                   WAIT_IO_COMPLETION = (0x000000C0),
                                                                                                                                                                                                                                                        WS_TILEDWINDOW = (0x00000000|0x00C00000|0x00080000|0x00040000|0x00020000|0x00010000);

        public const int WAIT_OBJECT_0 = 0x00000000,
        WAIT_FAILED = unchecked((int)0xFFFFFFFF),
        WAIT_TIMEOUT = 0x00000102,
        WAIT_ABANDONED = 0x00000080,
        WAIT_ABANDONED_0 = WAIT_ABANDONED,
        WHITENESS = 0x00FF0062;


        public const int XST_NULL = 0,
        XST_INCOMPLETE = 1,
        XST_CONNECTED = 2,
        XST_INIT1 = 3,
        XST_INIT2 = 4,
        XST_REQSENT = 5,
        XST_DATARCVD = 6,
        XST_POKESENT = 7,
        XST_POKEACKRCVD = 8,
        XST_EXECSENT = 9,
        XST_EXECACKRCVD = 10,
        XST_ADVSENT = 11,
        XST_UNADVSENT = 12,
        XST_ADVACKRCVD = 13,
        XST_UNADVACKRCVD = 14,
        XST_ADVDATASENT = 15,
        XST_ADVDATAACKRCVD = 16,
        XTYPF_NOBLOCK = 0x0002,
        XTYPF_NODATA = 0x0004,
        XTYPF_ACKREQ = 0x0008,
        XCLASS_MASK = 0xFC00,
        XCLASS_BOOL = 0x1000,
        XCLASS_DATA = 0x2000,
        XCLASS_FLAGS = 0x4000,
        XCLASS_NOTIFICATION = unchecked((int)0x8000),
        XTYP_ERROR = (0x0000|unchecked((int)0x8000)|0x0002),
                     XTYP_ADVDATA = (0x0010|0x4000),
                                    XTYP_ADVREQ = (0x0020|0x2000|0x0002),
                                                  XTYP_ADVSTART = (0x0030|0x1000),
                                                                  XTYP_ADVSTOP = (0x0040|unchecked((int)0x8000)),
                                                                                 XTYP_EXECUTE = (0x0050|0x4000),
                                                                                                XTYP_CONNECT = (0x0060|0x1000|0x0002),
                                                                                                               XTYP_CONNECT_CONFIRM = (0x0070|unchecked((int)0x8000)|0x0002),
                                                                                                                                      XTYP_XACT_COMPLETE = (0x0080|unchecked((int)0x8000)),
                                                                                                                                                           XTYP_POKE = (0x0090|0x4000),
                                                                                                                                                                       XTYP_REGISTER = (0x00A0|unchecked((int)0x8000)|0x0002),
                                                                                                                                                                                       XTYP_REQUEST = (0x00B0|0x2000),
                                                                                                                                                                                                      XTYP_DISCONNECT = (0x00C0|unchecked((int)0x8000)|0x0002),
                                                                                                                                                                                                                        XTYP_UNREGISTER = (0x00D0|unchecked((int)0x8000)|0x0002),
                                                                                                                                                                                                                                          XTYP_WILDCONNECT = (0x00E0|0x2000|0x0002),
                                                                                                                                                                                                                                                             XTYP_MASK = 0x00F0,
        XTYP_SHIFT = 4,
        XTYP_MONITOR = (0x00F0|unchecked((int)0x8000)|0x0002);



















        public static readonly int CBEM_GETITEM = Marshal.SystemDefaultCharSize == 1 ? win.CBEM_GETITEMA : win.CBEM_GETITEMW;
        public static readonly int CBEM_SETITEM = Marshal.SystemDefaultCharSize == 1 ? win.CBEM_SETITEMA : win.CBEM_SETITEMW;
        public static readonly int CBEN_ENDEDIT = Marshal.SystemDefaultCharSize == 1 ? win.CBEN_ENDEDITA : win.CBEN_ENDEDITW;
        public static readonly int CBEM_INSERTITEM = Marshal.SystemDefaultCharSize == 1 ? win.CBEM_INSERTITEMA : win.CBEM_INSERTITEMW;
        public static readonly int LVM_GETITEMTEXT = Marshal.SystemDefaultCharSize == 1 ? win.LVM_GETITEMTEXTA : win.LVM_GETITEMTEXTW;
        public static readonly int LVM_SETITEMTEXT = Marshal.SystemDefaultCharSize == 1 ? win.LVM_SETITEMTEXTA : win.LVM_SETITEMTEXTW;
        public static readonly int ACM_OPEN = Marshal.SystemDefaultCharSize == 1 ? win.ACM_OPENA : win.ACM_OPENW;
        public static readonly int DTM_SETFORMAT = Marshal.SystemDefaultCharSize == 1 ? win.DTM_SETFORMATA : win.DTM_SETFORMATW;
        public static readonly int DTN_USERSTRING = Marshal.SystemDefaultCharSize == 1 ? win.DTN_USERSTRINGA : win.DTN_USERSTRINGW;
        public static readonly int DTN_WMKEYDOWN = Marshal.SystemDefaultCharSize == 1 ? win.DTN_WMKEYDOWNA : win.DTN_WMKEYDOWNW;
        public static readonly int DTN_FORMAT = Marshal.SystemDefaultCharSize == 1 ? win.DTN_FORMATA : win.DTN_FORMATW;
        public static readonly int DTN_FORMATQUERY = Marshal.SystemDefaultCharSize == 1 ? win.DTN_FORMATQUERYA : win.DTN_FORMATQUERYW;
        public static readonly int EMR_EXTTEXTOUT = Marshal.SystemDefaultCharSize == 1 ? win.EMR_EXTTEXTOUTA : win.EMR_EXTTEXTOUTW;
        public static readonly int EMR_POLYTEXTOUT = Marshal.SystemDefaultCharSize == 1 ? win.EMR_POLYTEXTOUTA : win.EMR_POLYTEXTOUTW;
        public static readonly int HDM_INSERTITEM = Marshal.SystemDefaultCharSize == 1 ? win.HDM_INSERTITEMA : win.HDM_INSERTITEMW;
        public static readonly int HDM_GETITEM = Marshal.SystemDefaultCharSize == 1 ? win.HDM_GETITEMA : win.HDM_GETITEMW;
        public static readonly int HDM_SETITEM = Marshal.SystemDefaultCharSize == 1 ? win.HDM_SETITEMA : win.HDM_SETITEMW;
        public static readonly int HDN_ITEMCHANGING = Marshal.SystemDefaultCharSize == 1 ? win.HDN_ITEMCHANGINGA : win.HDN_ITEMCHANGINGW;
        public static readonly int HDN_ITEMCHANGED = Marshal.SystemDefaultCharSize == 1 ? win.HDN_ITEMCHANGEDA : win.HDN_ITEMCHANGEDW;
        public static readonly int HDN_ITEMCLICK = Marshal.SystemDefaultCharSize == 1 ? win.HDN_ITEMCLICKA : win.HDN_ITEMCLICKW;
        public static readonly int HDN_ITEMDBLCLICK = Marshal.SystemDefaultCharSize == 1 ? win.HDN_ITEMDBLCLICKA : win.HDN_ITEMDBLCLICKW;
        public static readonly int HDN_DIVIDERDBLCLICK = Marshal.SystemDefaultCharSize == 1 ? win.HDN_DIVIDERDBLCLICKA : win.HDN_DIVIDERDBLCLICKW;
        public static readonly int HDN_BEGINTRACK = Marshal.SystemDefaultCharSize == 1 ? win.HDN_BEGINTRACKA : win.HDN_BEGINTRACKW;
        public static readonly int HDN_ENDTRACK = Marshal.SystemDefaultCharSize == 1 ? win.HDN_ENDTRACKA : win.HDN_ENDTRACKW;
        public static readonly int HDN_TRACK = Marshal.SystemDefaultCharSize == 1 ? win.HDN_TRACKA : win.HDN_TRACKW;
        public static readonly int HDN_GETDISPINFO = Marshal.SystemDefaultCharSize == 1 ? win.HDN_GETDISPINFOA : win.HDN_GETDISPINFOW;
        public static readonly int LVM_GETITEM = Marshal.SystemDefaultCharSize == 1 ? win.LVM_GETITEMA : win.LVM_GETITEMW;
        public static readonly int LVM_SETITEM = Marshal.SystemDefaultCharSize == 1 ? win.LVM_SETITEMA : win.LVM_SETITEMW;
        public static readonly int LVM_INSERTITEM = Marshal.SystemDefaultCharSize == 1 ? win.LVM_INSERTITEMA : win.LVM_INSERTITEMW;
        public static readonly int LVM_FINDITEM = Marshal.SystemDefaultCharSize == 1 ? win.LVM_FINDITEMA : win.LVM_FINDITEMW;
        public static readonly int LVM_GETSTRINGWIDTH = Marshal.SystemDefaultCharSize == 1 ? win.LVM_GETSTRINGWIDTHA : win.LVM_GETSTRINGWIDTHW;
        public static readonly int LVM_EDITLABEL = Marshal.SystemDefaultCharSize == 1 ? win.LVM_EDITLABELA : win.LVM_EDITLABELW;
        public static readonly int LVM_GETCOLUMN = Marshal.SystemDefaultCharSize == 1 ? win.LVM_GETCOLUMNA : win.LVM_GETCOLUMNW;
        public static readonly int LVM_SETCOLUMN = Marshal.SystemDefaultCharSize == 1 ? win.LVM_SETCOLUMNA : win.LVM_SETCOLUMNW;
        public static readonly int LVM_GETISEARCHSTRING = Marshal.SystemDefaultCharSize == 1 ? win.LVM_GETISEARCHSTRINGA : win.LVM_GETISEARCHSTRINGW;
        public static readonly int LVM_INSERTCOLUMN = Marshal.SystemDefaultCharSize == 1 ? win.LVM_INSERTCOLUMNA : win.LVM_INSERTCOLUMNW;
        public static readonly int LVN_BEGINLABELEDIT = Marshal.SystemDefaultCharSize == 1 ? win.LVN_BEGINLABELEDITA : win.LVN_BEGINLABELEDITW;
        public static readonly int LVN_ENDLABELEDIT = Marshal.SystemDefaultCharSize == 1 ? win.LVN_ENDLABELEDITA : win.LVN_ENDLABELEDITW;
        public static readonly int LVN_ODFINDITEM = Marshal.SystemDefaultCharSize == 1 ? win.LVN_ODFINDITEMA : win.LVN_ODFINDITEMW;
        public static readonly int LVN_GETDISPINFO = Marshal.SystemDefaultCharSize == 1 ? win.LVN_GETDISPINFOA : win.LVN_GETDISPINFOW;
        public static readonly int LVN_SETDISPINFO = Marshal.SystemDefaultCharSize == 1 ? win.LVN_SETDISPINFOA : win.LVN_SETDISPINFOW;
        public static readonly int PSM_SETTITLE = Marshal.SystemDefaultCharSize == 1 ? win.PSM_SETTITLEA : win.PSM_SETTITLEW;
        public static readonly int PSM_SETFINISHTEXT = Marshal.SystemDefaultCharSize == 1 ? win.PSM_SETFINISHTEXTA : win.PSM_SETFINISHTEXTW;
        public static readonly int RB_INSERTBAND = Marshal.SystemDefaultCharSize == 1 ? win.RB_INSERTBANDA : win.RB_INSERTBANDW;
        public static readonly int RB_SETBANDINFO = Marshal.SystemDefaultCharSize == 1 ? win.RB_SETBANDINFOA : win.RB_SETBANDINFOW;
        public static readonly int SB_SETTEXT = Marshal.SystemDefaultCharSize == 1 ? win.SB_SETTEXTA : win.SB_SETTEXTW;
        public static readonly int SB_GETTEXT = Marshal.SystemDefaultCharSize == 1 ? win.SB_GETTEXTA : win.SB_GETTEXTW;
        public static readonly int SB_GETTEXTLENGTH = Marshal.SystemDefaultCharSize == 1 ? win.SB_GETTEXTLENGTHA : win.SB_GETTEXTLENGTHW;
        public static readonly int SB_SETTIPTEXT = Marshal.SystemDefaultCharSize == 1 ? win.SB_SETTIPTEXTA : win.SB_SETTIPTEXTW;
        public static readonly int SB_GETTIPTEXT = Marshal.SystemDefaultCharSize == 1 ? win.SB_GETTIPTEXTA : win.SB_GETTIPTEXTW;
        public static readonly int TB_SAVERESTORE = Marshal.SystemDefaultCharSize == 1 ? win.TB_SAVERESTOREA : win.TB_SAVERESTOREW;
        public static readonly int TB_ADDSTRING = Marshal.SystemDefaultCharSize == 1 ? win.TB_ADDSTRINGA : win.TB_ADDSTRINGW;
        public static readonly int TB_GETBUTTONTEXT = Marshal.SystemDefaultCharSize == 1 ? win.TB_GETBUTTONTEXTA : win.TB_GETBUTTONTEXTW;
        public static readonly int TB_MAPACCELERATOR = Marshal.SystemDefaultCharSize == 1 ? win.TB_MAPACCELERATORA : win.TB_MAPACCELERATORW;
        public static readonly int TB_GETBUTTONINFO = Marshal.SystemDefaultCharSize == 1 ? win.TB_GETBUTTONINFOA : win.TB_GETBUTTONINFOW;
        public static readonly int TB_SETBUTTONINFO = Marshal.SystemDefaultCharSize == 1 ? win.TB_SETBUTTONINFOA : win.TB_SETBUTTONINFOW;
#if cpr
        public const int RB_GETBANDINFO = (Win32Lib.systemCommCtrlVersion >= Win32Lib.WIN32_IE400) ?
                                          ((Marshal.SystemDefaultCharSize == 1) ? win.RB_GETBANDINFOA : win.RB_GETBANDINFOW) :
                                          win.RB_GETBANDINFO_OLD;
        public const int TB_INSERTBUTTON = ((Marshal.SystemDefaultCharSize == 1) ||
                                            (Win32Lib.systemCommCtrlVersion < Win32Lib.WIN32_IE400)) ?
                                           win.TB_INSERTBUTTONA : win.TB_INSERTBUTTONW;
        public const int TB_ADDBUTTONS = ((Marshal.SystemDefaultCharSize == 1) ||
                                          (Win32Lib.systemCommCtrlVersion < Win32Lib.WIN32_IE400)) ?
                                         win.TB_ADDBUTTONSA : win.TB_ADDBUTTONSW;
#else
        public static readonly int RB_GETBANDINFO = (Marshal.SystemDefaultCharSize == 1) ? win.RB_GETBANDINFOA : win.RB_GETBANDINFOW;
        public static readonly int TB_INSERTBUTTON = (Marshal.SystemDefaultCharSize == 1) ? win.TB_INSERTBUTTONA : win.TB_INSERTBUTTONW;
        public static readonly int TB_ADDBUTTONS = (Marshal.SystemDefaultCharSize == 1) ? win.TB_ADDBUTTONSA : win.TB_ADDBUTTONSW;
#endif
        public static readonly int TBN_GETBUTTONINFO = Marshal.SystemDefaultCharSize == 1 ? win.TBN_GETBUTTONINFOA : win.TBN_GETBUTTONINFOW;
        public static readonly int TBN_GETINFOTIP = Marshal.SystemDefaultCharSize == 1 ? win.TBN_GETINFOTIPA : win.TBN_GETINFOTIPW;
        public static readonly int TBN_GETDISPINFO = Marshal.SystemDefaultCharSize == 1 ? win.TBN_GETDISPINFOA : win.TBN_GETDISPINFOW;
        public static readonly int TTM_ADDTOOL = Marshal.SystemDefaultCharSize == 1 ? win.TTM_ADDTOOLA : win.TTM_ADDTOOLW;
        public static readonly int TTM_DELTOOL = Marshal.SystemDefaultCharSize == 1 ? win.TTM_DELTOOLA : win.TTM_DELTOOLW;
        public static readonly int TTM_NEWTOOLRECT = Marshal.SystemDefaultCharSize == 1 ? win.TTM_NEWTOOLRECTA : win.TTM_NEWTOOLRECTW;
        public static readonly int TTM_GETTOOLINFO = Marshal.SystemDefaultCharSize == 1 ? win.TTM_GETTOOLINFOA : win.TTM_GETTOOLINFOW;
        public static readonly int TTM_SETTOOLINFO = Marshal.SystemDefaultCharSize == 1 ? win.TTM_SETTOOLINFOA : win.TTM_SETTOOLINFOW;
        public static readonly int TTM_HITTEST = Marshal.SystemDefaultCharSize == 1 ? win.TTM_HITTESTA : win.TTM_HITTESTW;
        public static readonly int TTM_GETTEXT = Marshal.SystemDefaultCharSize == 1 ? win.TTM_GETTEXTA : win.TTM_GETTEXTW;
        public static readonly int TTM_UPDATETIPTEXT = Marshal.SystemDefaultCharSize == 1 ? win.TTM_UPDATETIPTEXTA : win.TTM_UPDATETIPTEXTW;
        public static readonly int TTM_ENUMTOOLS = Marshal.SystemDefaultCharSize == 1 ? win.TTM_ENUMTOOLSA : win.TTM_ENUMTOOLSW;
        public static readonly int TTM_GETCURRENTTOOL = Marshal.SystemDefaultCharSize == 1 ? win.TTM_GETCURRENTTOOLA : win.TTM_GETCURRENTTOOLW;
        public static readonly int TTN_GETDISPINFO = Marshal.SystemDefaultCharSize == 1 ? win.TTN_GETDISPINFOA : win.TTN_GETDISPINFOW;
        public static readonly int TTN_NEEDTEXT = Marshal.SystemDefaultCharSize == 1 ? win.TTN_NEEDTEXTA : win.TTN_NEEDTEXTW;
        public static readonly int TVM_INSERTITEM = Marshal.SystemDefaultCharSize == 1 ? win.TVM_INSERTITEMA : win.TVM_INSERTITEMW;
        public static readonly int TVM_GETITEM = Marshal.SystemDefaultCharSize == 1 ? win.TVM_GETITEMA : win.TVM_GETITEMW;
        public static readonly int TVM_SETITEM = Marshal.SystemDefaultCharSize == 1 ? win.TVM_SETITEMA : win.TVM_SETITEMW;
        public static readonly int TVM_EDITLABEL = Marshal.SystemDefaultCharSize == 1 ? win.TVM_EDITLABELA : win.TVM_EDITLABELW;
        public static readonly int TVM_GETISEARCHSTRING = Marshal.SystemDefaultCharSize == 1 ? win.TVM_GETISEARCHSTRINGA : win.TVM_GETISEARCHSTRINGW;
        public static readonly int TVN_SELCHANGING = Marshal.SystemDefaultCharSize == 1 ? win.TVN_SELCHANGINGA : win.TVN_SELCHANGINGW;
        public static readonly int TVN_SELCHANGED = Marshal.SystemDefaultCharSize == 1 ? win.TVN_SELCHANGEDA : win.TVN_SELCHANGEDW;
        public static readonly int TVN_GETDISPINFO = Marshal.SystemDefaultCharSize == 1 ? win.TVN_GETDISPINFOA : win.TVN_GETDISPINFOW;
        public static readonly int TVN_SETDISPINFO = Marshal.SystemDefaultCharSize == 1 ? win.TVN_SETDISPINFOA : win.TVN_SETDISPINFOW;
        public static readonly int TVN_ITEMEXPANDING = Marshal.SystemDefaultCharSize == 1 ? win.TVN_ITEMEXPANDINGA : win.TVN_ITEMEXPANDINGW;
        public static readonly int TVN_ITEMEXPANDED = Marshal.SystemDefaultCharSize == 1 ? win.TVN_ITEMEXPANDEDA : win.TVN_ITEMEXPANDEDW;
        public static readonly int TVN_BEGINDRAG = Marshal.SystemDefaultCharSize == 1 ? win.TVN_BEGINDRAGA : win.TVN_BEGINDRAGW;
        public static readonly int TVN_BEGINRDRAG = Marshal.SystemDefaultCharSize == 1 ? win.TVN_BEGINRDRAGA : win.TVN_BEGINRDRAGW;
        public static readonly int TVN_DELETEITEM = Marshal.SystemDefaultCharSize == 1 ? win.TVN_DELETEITEMA : win.TVN_DELETEITEMW;
        public static readonly int TVN_BEGINLABELEDIT = Marshal.SystemDefaultCharSize == 1 ? win.TVN_BEGINLABELEDITA : win.TVN_BEGINLABELEDITW;
        public static readonly int TVN_ENDLABELEDIT = Marshal.SystemDefaultCharSize == 1 ? win.TVN_ENDLABELEDITA : win.TVN_ENDLABELEDITW;
        public static readonly int TCM_GETITEM = Marshal.SystemDefaultCharSize == 1 ? win.TCM_GETITEMA : win.TCM_GETITEMW;
        public static readonly int TCM_SETITEM = Marshal.SystemDefaultCharSize == 1 ? win.TCM_SETITEMA : win.TCM_SETITEMW;
        public static readonly int TCM_INSERTITEM = Marshal.SystemDefaultCharSize == 1 ? win.TCM_INSERTITEMA : win.TCM_INSERTITEMW;
        public static readonly int CP_WINNEUTRAL = Marshal.SystemDefaultCharSize == 1 ? win.CP_WINANSI : win.CP_WINUNICODE;

        //cpr  public static final int MCS_NOTODAY = (Win32Lib.systemCommCtrlVersion >= Win32Lib.WIN32_IE400) ? 0x0010 : 0x0008;
        public const int MCS_NOTODAY = 0x0010;

        public static readonly int WM_MOUSEENTER = Util.RegisterWindowMessage("WinFormsMouseEnter");















        public static readonly String LBSELCHSTRINGA = "commdlg_LBSelChangedNotify",
        SHAREVISTRINGA = "commdlg_ShareViolation",
        FILEOKSTRINGA = "commdlg_FileNameOK",
        COLOROKSTRINGA = "commdlg_ColorOK",
        SETRGBSTRINGA = "commdlg_SetRGBColor",
        HELPMSGSTRINGA = "commdlg_help",
        FINDMSGSTRINGA = "commdlg_FindReplace",
        LBSELCHSTRINGW = "commdlg_LBSelChangedNotify",
        SHAREVISTRINGW = "commdlg_ShareViolation",
        FILEOKSTRINGW = "commdlg_FileNameOK",
        COLOROKSTRINGW = "commdlg_ColorOK",
        SETRGBSTRINGW = "commdlg_SetRGBColor",
        HELPMSGSTRINGW = "commdlg_help",
        FINDMSGSTRINGW = "commdlg_FindReplace",
        SZDDESYS_TOPIC = "System",
        SZDDESYS_ITEM_TOPICS = "Topics",
        SZDDESYS_ITEM_SYSITEMS = "SysItems",
        SZDDESYS_ITEM_RTNMSG = "ReturnMessage",
        SZDDESYS_ITEM_STATUS = "Status",
        SZDDESYS_ITEM_FORMATS = "Formats",
        SZDDESYS_ITEM_HELP = "Help",
        SZDDE_ITEM_ITEMLIST = "TopicItemList",
        ALL_TRANSPORTS = "M???",
        MS_NBF = "MNBF",
        MS_DEF_PROV_A = "Microsoft Base Cryptographic Provider v1.0",
        MS_DEF_PROV_W = "Microsoft Base Cryptographic Provider v1.0",
        SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege",
        SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege",
        SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege",
        SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege",
        SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege",
        SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege",
        SE_TCB_NAME = "SeTcbPrivilege",
        SE_SECURITY_NAME = "SeSecurityPrivilege",
        SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege",
        SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege",
        SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege",
        SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege",
        SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege",
        SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege",
        SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege",
        SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege",
        SE_BACKUP_NAME = "SeBackupPrivilege",
        SE_RESTORE_NAME = "SeRestorePrivilege",
        SE_SHUTDOWN_NAME = "SeShutdownPrivilege",
        SE_DEBUG_NAME = "SeDebugPrivilege",
        SE_AUDIT_NAME = "SeAuditPrivilege",
        SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege",
        SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege",
        SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege",
        SPLREG_DEFAULT_SPOOL_DIRECTORY = "DefaultSpoolDirectory",
        SPLREG_PORT_THREAD_PRIORITY_DEFAULT = "PortThreadPriorityDefault",
        SPLREG_PORT_THREAD_PRIORITY = "PortThreadPriority",
        SPLREG_SCHEDULER_THREAD_PRIORITY_DEFAULT = "SchedulerThreadPriorityDefault",
        SPLREG_SCHEDULER_THREAD_PRIORITY = "SchedulerThreadPriority",
        SPLREG_BEEP_ENABLED = "BeepEnabled",
        SPLREG_NET_POPUP = "NetPopup",
        SPLREG_EVENT_LOG = "EventLog",
        SPLREG_MAJOR_VERSION = "MajorVersion",
        SPLREG_MINOR_VERSION = "MinorVersion",
        SPLREG_ARCHITECTURE = "Architecture",
        SERVICES_ACTIVE_DATABASEW = "ServicesActive",
        SERVICES_FAILED_DATABASEW = "ServicesFailed",
        SERVICES_ACTIVE_DATABASEA = "ServicesActive",
        SERVICES_FAILED_DATABASEA = "ServicesFailed",
        WC_HEADERA = "SysHeader32",
        WC_HEADERW = "SysHeader32",
        WC_HEADER = "SysHeader",
        
#if WINCTL                                        
        TOOLBARCLASSNAMEW = "WFCToolbarWindow32",
        TOOLBARCLASSNAMEA = "WFCToolbarWindow32",
        TOOLBARCLASSNAME = "WFCToolbarWindow32",
#else
        TOOLBARCLASSNAMEW = "ToolbarWindow32",
        TOOLBARCLASSNAMEA = "ToolbarWindow32",
        TOOLBARCLASSNAME = "ToolbarWindow32",
#endif 
       
        REBARCLASSNAMEW = "ReBarWindow32",
        REBARCLASSNAMEA = "ReBarWindow32",
        REBARCLASSNAME = "ReBarWindow32",
        
        
#if WINCTL        
        TOOLTIPS_CLASSW = "WFCTooltips32",
        TOOLTIPS_CLASSA = "WFCTooltips32",
        TOOLTIPS_CLASS = "WFCTooltips32",
#else
        TOOLTIPS_CLASSW = "tooltips_class32",
        TOOLTIPS_CLASSA = "tooltips_class32",
        TOOLTIPS_CLASS = "tooltips_class32",
#endif
        
        /*
        STATUSCLASSNAMEW = "msctls_statusbar32",
        STATUSCLASSNAMEA = "msctls_statusbar32",
        STATUSCLASSNAME = "msctls_statusbar32",
        TRACKBAR_CLASSA = "msctls_trackbar32",
        TRACKBAR_CLASSW = "msctls_trackbar32",
        TRACKBAR_CLASS = "msctls_trackbar32",
        */
        DRAGLISTMSGSTRING = "commctrl_DragListMsg",
        /*
        UPDOWN_CLASSA = "msctls_updown32",
        UPDOWN_CLASSW = "msctls_updown32",
        UPDOWN_CLASS = "msctls_updown32",
        PROGRESS_CLASSA = "msctls_progress32",
        PROGRESS_CLASSW = "msctls_progress32",
        PROGRESS_CLASS = "msctls_progress32",
        */
        HOTKEY_CLASSA = "msctls_hotkey32",
        HOTKEY_CLASSW = "msctls_hotkey32",
        HOTKEY_CLASS = "msctls_hotkey32",
        WC_BUTTON = "BUTTON",
        WC_COMBOBOX = "COMBOBOX",
        WC_EDIT = "EDIT",
        WC_LISTBOX = "LISTBOX",
        WC_MDICLIENT = "MDICLIENT",
        WC_SCROLLBAR = "SCROLLBAR",
        WC_RICHEDITA = "RichEdit32",
        WC_RICHEDITW = "RichEdit32",
        WC_RICHEDIT = "RichEdit32",
                 
#if WINCTL
        WC_DATETIMEPICKA = "WFCDateTimePick32",
        WC_DATETIMEPICKW = "WFCDateTimePick32",
        WC_DATETIMEPICK = "WFCDateTimePick32",
        WC_LISTVIEWA = "WFCListView32",
        WC_LISTVIEWW = "WFCListView32",
        WC_LISTVIEW = "WFCListView32",
        WC_MONTHCALA = "WFCMonthCal32",
        WC_MONTHCALW = "WFCMonthCal32",
        WC_MONTHCAL = "WFCMonthCal32",
        WC_PROGRESSA = "WFCProgress32",
        WC_PROGRESSW = "WFCProgress32",
        WC_PROGRESS = "WFCProgress32",
        WC_STATUSBARA = "WFCStatusBar32",
        WC_STATUSBARW = "WFCStatusBar32",
        WC_STATUSBAR = "WFCStatusBar32",
        WC_TOOLBAR = "WFCToolbarWindow32",
        WC_TRACKBARA = "WFCTrackbar32",
        WC_TRACKBARW = "WFCTrackbar32",
        WC_TRACKBAR = "WFCTrackbar32",
        WC_TREEVIEWA = "WFCTreeView32",
        WC_TREEVIEWW = "WFCTreeView32",
        WC_TREEVIEW = "WFCTreeView32",
#else
        WC_DATETIMEPICKA = "SysDateTimePick32",
        WC_DATETIMEPICKW = "SysDateTimePick32",
        WC_DATETIMEPICK = "SysDateTimePick32",
        WC_LISTVIEWA = "SysListView32",
        WC_LISTVIEWW = "SysListView32",
        WC_LISTVIEW = "SysListView32",
        WC_MONTHCALA = "SysMonthCal32",
        WC_MONTHCALW = "SysMonthCal32",
        WC_MONTHCAL = "SysMonthCal32",
        WC_PROGRESSA = "msctls_progress32",
        WC_PROGRESSW = "msctls_progress32",
        WC_PROGRESS = "msctls_progress32",
        WC_STATUSBARA = "msctls_statusbar32",
        WC_STATUSBARW = "msctls_statusbar32",
        WC_STATUSBAR = "msctls_statusbar32",
        WC_TOOLBAR = "ToolbarWindow32",
        WC_TRACKBARA = "msctls_trackbar32",
        WC_TRACKBARW = "msctls_trackbar32",
        WC_TRACKBAR = "msctls_trackbar32",
        WC_TREEVIEWA = "SysTreeView32",
        WC_TREEVIEWW = "SysTreeView32",
        WC_TREEVIEW = "SysTreeView32",
#endif
        
        WC_COMBOBOXEXW = "ComboBoxEx32",
        WC_COMBOBOXEXA = "ComboBoxEx32",
        WC_COMBOBOXEX = "ComboBoxEx32",
        WC_STATIC = "STATIC",
        
#if WINCTL                         
        WC_TABCONTROLA = "WFCTabControl32",
        WC_TABCONTROLW = "WFCTabControl32",
        WC_TABCONTROL = "WFCTabControl32",
#else        
        WC_TABCONTROLA = "SysTabControl32",
        WC_TABCONTROLW = "SysTabControl32",
        WC_TABCONTROL = "SysTabControl32",
#endif        
        
        /*
        ANIMATE_CLASSW = "SysAnimate32",
        ANIMATE_CLASSA = "SysAnimate32",
        ANIMATE_CLASS = "SysAnimate32",
        MONTHCAL_CLASSW = "SysMonthCal32",
        MONTHCAL_CLASSA = "SysMonthCal32",
        MONTHCAL_CLASS = "SysMonthCal32",
        DATETIMEPICK_CLASSW = "SysDateTimePick32",
        DATETIMEPICK_CLASSA = "SysDateTimePick32",
        DATETIMEPICK_CLASS = "SysDateTimePick32",
        */
        LBSELCHSTRING = "commdlg_LBSelChangedNotify",
        FINDMSGSTRING = "commdlg_FindReplace",
        SHAREVISTRING = "commdlg_ShareViolation",
        SERVICES_FAILED_DATABASE = "ServicesFailed",
        MS_DEF_PROV_ = "Microsoft Base Cryptographic Provider v1.0",
        HELPMSGSTRING = "commdlg_help",
        FILEOKSTRING = "commdlg_FileNameOK",
        SERVICES_ACTIVE_DATABASE = "ServicesActive",
        COLOROKSTRING = "commdlg_ColorOK",
        SETRGBSTRING = "commdlg_SetRGBColor",
        MSH_MOUSEWHEEL = "MSWHEEL_ROLLMSG",
        MSH_SCROLL_LINES = "MSH_SCROLL_LINES_MSG",
        MSH_WHEELSUPPORT = "MSH_WHEELSUPPORT_MSG",
        MOUSEZ_CLASSNAME = "MouseZ",
        MOUSEZ_TITLE = "Magellan MSWHEEL";


        public static RegistryHive
        HKEY_CLASSES_ROOT         = RegistryHive.ClassesRoot,
        HKEY_CURRENT_USER         = RegistryHive.CurrentUser,
        HKEY_LOCAL_MACHINE        = RegistryHive.LocalMachine,
        HKEY_USERS                = RegistryHive.Users,
        HKEY_PERFORMANCE_DATA     = RegistryHive.PerformanceData,
        HKEY_CURRENT_CONFIG       = RegistryHive.CurrentConfig,
        HKEY_DYN_DATA             = RegistryHive.DynData;


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\cookiecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="cookiecollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Collections;
    using System.Globalization;
    
    //
    // CookieCollection
    //
    //  A list of cookies maintained in Sorted order. Only one cookie with matching Name/Domain/Path 
    //

    /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    public class CookieCollection : ICollection {

    // fields
        internal enum Stamp {
                Check       = 0,
                Set         = 1,
                SetToUnused = 2,
                SetToMaxUsed= 3
        };
                

        internal int m_version;
        ArrayList m_list = new ArrayList();

        DateTime m_TimeStamp = DateTime.MinValue;
        bool m_has_other_versions = false;

    // constructors

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.CookieCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieCollection() {
        }

    // properties

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return true;
            }
        }

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Cookie this[int index] {
            get {
                if (index < 0 || index >= m_list.Count) {
                    throw new ArgumentOutOfRangeException("index");
                }
                return (Cookie)(m_list[index]);
            }
        }


        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Cookie this[string name] {

            get {
                foreach (Cookie c in m_list) {
                    if (string.Compare(c.Name, name, true, CultureInfo.InvariantCulture) == 0) {
                        return c;
                    }
                }
                return null;
            }
        }

    // methods

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(Cookie cookie) {
            if (cookie == null) {
                throw new ArgumentNullException("cookie");
            }
            ++m_version;
            int idx = IndexOf(cookie);
            if (idx == -1) {
                m_list.Add(cookie);
            }
            else {
                m_list[idx] = cookie;
            }
        }

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(CookieCollection cookies) {
            if (cookies == null) {
                throw new ArgumentNullException("cookies");
            }
            //if (cookies == this) {
            //    cookies = new CookieCollection(cookies);
            //}
            foreach (Cookie cookie in cookies) {
                Add(cookie);
            }
        }

    // ICollection interface

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get {
                return m_list.Count;
            }
        }

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            m_list.CopyTo(array, index);
        }

        
        internal DateTime TimeStamp(Stamp how) {
            switch (how) {
            case Stamp.Set:
                        m_TimeStamp = DateTime.Now;
                        break;
            case Stamp.SetToMaxUsed:
                        m_TimeStamp = DateTime.MaxValue;
                        break;
            case Stamp.SetToUnused: 
                        m_TimeStamp = DateTime.MinValue;
                        break;
            case Stamp.Check:     
            default:    
                        break;

            }
            return m_TimeStamp;
        }


        // This is for internal cookie container usage
        // For others not that m_has_other_versions gets changed ONLY in InternalAdd
        internal bool IsOtherVersionSeen{
            get {
                return m_has_other_versions;
            }
        }

        // If isStrict == false, assumes that incoming cookie is unique
        // If isStrict == true, replace the cookie if found same with newest Variant
        // returns 1 if added, 0 if replaced or rejected
        internal int InternalAdd(Cookie cookie, bool isStrict) {
            int ret = 1;

            if (isStrict) {
                IComparer comp = Cookie.GetComparer();
                int idx = 0;
                foreach (Cookie c in m_list) {
                    if (comp.Compare(cookie, c) == 0) {
                        ret = 0;    //will replace or reject
                        //Cookie2 spec requires that new Variant cookie overwrite the old one
                        if (c.Variant <= cookie.Variant) {
                            m_list[idx] = cookie;
                        }
                        break;
                    }
                    ++idx;
                }

                if (idx == m_list.Count) {
                    m_list.Add(cookie);
                }
            }
            else {
                m_list.Add(cookie);
            }


            if (cookie.Version != Cookie.MaxSupportedVersion) {
                m_has_other_versions = true;
            }
            return ret;
        }


        internal int IndexOf(Cookie cookie) {
                IComparer comp = Cookie.GetComparer();
                int idx = 0;
                foreach (Cookie c in m_list) {
                    if (comp.Compare(cookie, c) == 0) {
                        return idx;
                    }
                    ++idx;
                }
                return -1;
        }

        internal void RemoveAt(int idx) {
            m_list.RemoveAt(idx);
        }


    // IEnumerable interface

        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new CookieCollectionEnumerator(this);
        }

#if DEBUG
        /// <include file='doc\cookiecollection.uex' path='docs/doc[@for="CookieCollection.Dump"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dump() {
            Console.WriteLine("CookieCollection:");
            foreach (Cookie cookie in this) {
                cookie.Dump();
            }
        }
#endif

//Not used anymore delete ?
        private class CookieCollectionEnumerator : IEnumerator {

            CookieCollection m_cookies;
            int m_count;
            int m_index = -1;
            int m_version;

            internal CookieCollectionEnumerator(CookieCollection cookies) {
                m_cookies = cookies;
                m_count = cookies.Count;
                m_version = cookies.m_version;
            }

        // IEnumerator interface

            object IEnumerator.Current {
                get {
                    if (m_index < 0 || m_index >= m_count) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
                    }
                    if (m_version != m_cookies.m_version) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                    }
                    return m_cookies[m_index];
                }
            }

            bool IEnumerator.MoveNext() {
                if (m_version != m_cookies.m_version) {
                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                }
                if (++m_index < m_count) {
                    return true;
                }
                m_index = m_count;
                return false;
            }

            void IEnumerator.Reset() {
                m_index = -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\authenticationmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="AuthenticationManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.Reflection;
    using System.Security.Permissions;

    internal class NetAuthenticationWrapper {
        internal NetAuthenticationWrapper(ArrayList moduleList) {
            this.ModuleList = moduleList;
        }
        internal ArrayList ModuleList;
    }

    /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="AuthenticationManager"]/*' />
    /// <devdoc>
    ///    <para>Manages the authentication modules called during the client authentication
    ///       process.</para>
    /// </devdoc>
    public class AuthenticationManager {
        //
        // class members
        //
        private static PrefixLookup s_ModuleBinding = new PrefixLookup();
        private static ArrayList s_ModuleList;

        // not creatable...
        //
        private AuthenticationManager() {
        }

        //
        // ModuleList - static initialized property - 
        //  contains list of Modules used for Authentication
        //

        private static ArrayList ModuleList {

            get {

                //
                // GetConfig() might use us, so we have a circular dependency issue,
                // that causes us to nest here, we grab the lock, only
                // if we haven't initialized, or another thread is busy in initialization           
                //

                Type[] config = null;
                if (s_ModuleList == null) {
                    lock (typeof(AuthenticationManager)) {
                        if (s_ModuleList == null) {
                            GlobalLog.Print("AuthenticationManager::Initialize(): calling ConfigurationSettings.GetConfig()");                                                        
                            NetAuthenticationWrapper wrapper = ConfigurationSettings.GetConfig("system.net/authenticationModules") as NetAuthenticationWrapper;                                 
                            if (wrapper != null) {
                                config = (Type[])wrapper.ModuleList.ToArray(typeof(Type));
                            }

                            if (config == null) {
                                GlobalLog.Print("AuthenticationManager::Initialize(): creating default settings");
                                config = new Type[] {
#if COMNET_DUMMYAUTHCLIENT
                                    typeof(System.Net.DummyClient),
#endif // #if COMNET_DUMMYAUTHCLIENT
                                    typeof(System.Net.DigestClient),
                                    typeof(System.Net.NegotiateClient),
                                    typeof(System.Net.KerberosClient),
                                    typeof(System.Net.NtlmClient),
                                    typeof(System.Net.BasicClient)};
                            }

                            //
                            // Should be registered in a growing list of encryption/algorithm strengths
                            //  basically, walk through a list of Types, and create new Auth objects
                            //  from them.
                            //
                            // order is meaningful here:
                            // load the registered list of auth types
                            // with growing level of encryption.
                            //

                            ArrayList moduleList = new ArrayList();
                            IAuthenticationModule moduleToRegister;
                            foreach (Type type in config) {
                                try {
                                    moduleToRegister = Activator.CreateInstance(type,
                                                        BindingFlags.CreateInstance
                                                        | BindingFlags.Instance
                                                        | BindingFlags.NonPublic
                                                        | BindingFlags.Public,
                                                        null,          // Binder
                                                        new object[0], // no arguments
                                                        CultureInfo.InvariantCulture
                                                        ) as IAuthenticationModule;
                                    if (moduleToRegister != null) {
                                        GlobalLog.Print("WebRequest::Initialize(): Register:" + moduleToRegister.AuthenticationType);
                                        RemoveAuthenticationType(moduleList, moduleToRegister.AuthenticationType);
                                        moduleList.Add(moduleToRegister);
                                    }
                                }
                                catch (Exception exception) {
                                    //
                                    // ignore failure (log exception for debugging)
                                    //
                                    GlobalLog.Print("AuthenticationManager::constructor failed to initialize: " + exception.ToString());
                                }
                            }

                            s_ModuleList = moduleList; 
                        }
                    }
                }

                return s_ModuleList;
            }
        }


        private static void RemoveAuthenticationType(ArrayList list, string typeToRemove) {
            for (int i=0; i< list.Count; ++i) {
                if (string.Compare(((IAuthenticationModule)list[i]).AuthenticationType, typeToRemove, true, CultureInfo.InvariantCulture) ==0) {
                    list.RemoveAt(i);
                    break;
                }

            }
        }

        /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="AuthenticationManager.Authenticate"]/*' />
        /// <devdoc>
        ///    <para>Call each registered authentication module to determine the first module that
        ///       can respond to the authentication request.</para>
        /// </devdoc>
        public static Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials) {
            //
            // parameter validation
            //
            if (request == null) {
                throw new ArgumentNullException("request");
            }
            if (credentials == null) {
                throw new ArgumentNullException("credentials");
            }
            if (challenge==null) {
                throw new ArgumentNullException("challenge");
            }

            GlobalLog.Print("AuthenticationManager::Authenticate() challenge:[" + challenge + "]");

            Authorization response = null;

            lock (typeof(AuthenticationManager)) {
                //
                // fastest way of iterating on the ArryList
                //
                for (int i = 0; i < ModuleList.Count; i++) {
                    IAuthenticationModule authenticationModule = (IAuthenticationModule)ModuleList[i];
                    //
                    // the AuthenticationModule will
                    // 1) return a valid string on success
                    // 2) return null if it knows it cannot respond
                    // 3) throw if it could have responded but unexpectedly failed to do so
                    //
 
                    HttpWebRequest httpWebRequest = request as HttpWebRequest;
                    if (httpWebRequest != null) {
                        httpWebRequest.CurrentAuthenticationState.Module = authenticationModule;
                    }
                    response = authenticationModule.Authenticate(challenge, request, credentials);

                    if (response!=null) {
                        //
                        // fond the Authentication Module, return it
                        //
                        response.Module = authenticationModule;
                        GlobalLog.Print("AuthenticationManager::Authenticate() found IAuthenticationModule:[" + authenticationModule.AuthenticationType + "]");
                        break;
                    }
                }
            }

            return response;
        }

        /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="AuthenticationManager.PreAuthenticate"]/*' />
        /// <devdoc>
        ///    <para>Pre-authenticates a request.</para>
        /// </devdoc>
        public static Authorization PreAuthenticate(WebRequest request, ICredentials credentials) {
            GlobalLog.Print("AuthenticationManager::PreAuthenticate() request:" + ValidationHelper.HashString(request) + " credentials:" + ValidationHelper.HashString(credentials));
            if (request == null) {
                throw new ArgumentNullException("request");
            }
            if (credentials == null) {
                return null;
            }
            //
            // PrefixLookup is thread-safe
            //
            string moduleName = s_ModuleBinding.Lookup(((HttpWebRequest)request).ChallengedUri.AbsoluteUri) as string;
            GlobalLog.Print("AuthenticationManager::PreAuthenticate() s_ModuleBinding.Lookup returns:" + ValidationHelper.ToString(moduleName));
            if (moduleName == null) {
                return null;
            }

            IAuthenticationModule module = findModule(moduleName);
            if (module == null) {
                // The module could have been unregistered
                // No preauthentication is possible
                return null;
            }
            else {
                // Otherwise invoke the PreAuthenticate method
                
                HttpWebRequest httpWebRequest = request as HttpWebRequest;
                if (httpWebRequest != null) {
                    httpWebRequest.CurrentAuthenticationState.Module = module;
                }

                Authorization authorization = module.PreAuthenticate(request, credentials);
                GlobalLog.Print("AuthenticationManager::PreAuthenticate() IAuthenticationModule.PreAuthenticate() returned authorization:" + ValidationHelper.HashString(authorization));
                return authorization;
            }
        }


        /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="AuthenticationManager.Register"]/*' />
        /// <devdoc>
        ///    <para>Registers an authentication module with the authentication manager.</para>
        /// </devdoc>
        public static void Register(IAuthenticationModule authenticationModule) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            if (authenticationModule == null) {
                throw new ArgumentNullException("authenticationModule");
            }

            GlobalLog.Print("AuthenticationManager::Register() registering :[" + authenticationModule.AuthenticationType + "]");

            lock (typeof(AuthenticationManager)) {

                IAuthenticationModule existentModule = findModule(authenticationModule.AuthenticationType);

                if (existentModule != null) {
                    ModuleList.Remove(existentModule);
                }

                ModuleList.Add(authenticationModule);
            }
        }

        /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="AuthenticationManager.Unregister"]/*' />
        /// <devdoc>
        ///    <para>Unregisters authentication modules for an authentication scheme.</para>
        /// </devdoc>
        public static void Unregister(IAuthenticationModule authenticationModule) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            if (authenticationModule == null) {
                throw new ArgumentNullException("authenticationModule");
            }

            GlobalLog.Print("AuthenticationManager::Unregister() unregistering :[" + authenticationModule.AuthenticationType + "]");

            lock (typeof(AuthenticationManager)) {

                if (!ModuleList.Contains(authenticationModule)) {
                    throw new InvalidOperationException(SR.GetString(SR.net_authmodulenotregistered));
                }

                ModuleList.Remove(authenticationModule);
            }
        }
        /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="AuthenticationManager.Unregister1"]/*' />
        /// <devdoc>
        ///    <para>Unregisters authentication modules for an authentication scheme.</para>
        /// </devdoc>
        public static void Unregister(string authenticationScheme) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            if (authenticationScheme == null) {
                throw new ArgumentNullException("authenticationScheme");
            }

            GlobalLog.Print("AuthenticationManager::Unregister() unregistering :[" + authenticationScheme + "]");

            lock (typeof(AuthenticationManager)) {

                IAuthenticationModule existentModule = findModule(authenticationScheme);

                if (existentModule == null) {
                    throw new InvalidOperationException(SR.GetString(SR.net_authschemenotregistered));
                }

                ModuleList.Remove(existentModule);
            }
        }

        /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="AuthenticationManager.RegisteredModules"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a list of registered authentication modules.
        ///    </para>
        /// </devdoc>
        public static IEnumerator RegisteredModules {
            get {
                return ModuleList.GetEnumerator();
            }
        }

        /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="AuthenticationManager.BindModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Binds an authentication response to a request for pre-authentication.
        ///    </para>
        /// </devdoc>
        internal static void BindModule(WebRequest request, Authorization response) {
            createModuleBinding(request, response, response.Module);
        }

        //
        // Lookup module by AuthenticationType
        //
        private static IAuthenticationModule findModule(string authenticationType) {
            IAuthenticationModule returnAuthenticationModule = null;
            ArrayList moduleList = ModuleList;
            IAuthenticationModule authenticationModule;
            for (int k=0; k<moduleList.Count; k++) {
                authenticationModule = (IAuthenticationModule)moduleList[k];
                if (string.Compare(authenticationModule.AuthenticationType, authenticationType, true, CultureInfo.InvariantCulture) == 0) {
                    returnAuthenticationModule = authenticationModule;
                    break;
                }
            }
            return returnAuthenticationModule;
        }

        // This function returns a prefix of the given absolute Uri
        // which will be used for associating authentication information
        // The purpose is to associate the module-binding not with a single
        // Uri but some collection generalizing that Uri to the loosely-defined
        // notion of "protection realm"
        private static string generalize(Uri location) {
            string completeUri = location.AbsoluteUri;
            int lastFwdSlash = completeUri.LastIndexOf('/');
            if (lastFwdSlash < 0) {
                return completeUri;
            }
            return completeUri.Substring(0, lastFwdSlash+1);
        }

        // Create binding between an authorization response and the module
        // generating that response
        // This association is used for deciding which module to invoke
        // for preauthentication purposes
        private static void createModuleBinding(WebRequest request, Authorization response, IAuthenticationModule module) {
            if (!module.CanPreAuthenticate) {
                return;
            }

            if (response.ProtectionRealm!=null) {
                // The authentication module specified which Uri prefixes
                // will be preauthenticated
                string[] prefix = response.ProtectionRealm;

                for (int k=0; k<prefix.Length; k++) {
                    //
                    // PrefixLookup is thread-safe
                    //
                    s_ModuleBinding.Add(prefix[k], module.AuthenticationType);
                }
            }
            else {
                // Otherwise use the default policy for "fabricating"
                // some protection realm generalizing the particular Uri
                // Consider: should this be ChallengedUri?
                string prefix = generalize(request.RequestUri);
                //
                // PrefixLookup is thread-safe
                //
                s_ModuleBinding.Add(prefix, module.AuthenticationType);
            }

            return;
        }

        //
        // this method is called by the IAuthenticationModule implementations
        // to safely find their signature in a challenge. there's many ways to
        // fool an IAuthenticationModule and preventing it from finding it's challenge.
        // we won't try to be too smart, the only thing we'll do is avoid looking into
        // quoted strings preventing some nasty cases such as:
        // WWW-Authenticate: Digest username="NTLM", realm="wit", NTLM ...
        internal static int FindSubstringNotInQuotes(string challenge, string signature) {
            int index = -1;

            if (challenge != null && signature != null && challenge.Length>=signature.Length) {
                int firstQuote = -1, secondQuote = -1;

                for (int i = 0; i < challenge.Length; i++) {
                    //
                    // firstQuote>secondQuote means we are in a quoted string
                    //
                    /*
                    if (challenge[i]=='\\' && i+1 < challenge.Length && challenge[i+1]=='\"') {
                        // skip \"
                        i++;
                        continue;
                    }
                    */
                    if (challenge[i]=='\"') {
                        if (firstQuote <= secondQuote) {
                            firstQuote = i;
                        }
                        else {
                            secondQuote = i;
                        }
                    }
                    if (i==challenge.Length-1 || (challenge[i]=='\"' && firstQuote>secondQuote)) {
                        // see if the portion of challenge out of the quotes contains
                        // the signature of the IAuthenticationModule
                        if (i==challenge.Length-1) {
                            firstQuote = challenge.Length;
                        }
                        if (firstQuote<secondQuote + 3) {
                            continue;
                        }
                        index = challenge.IndexOf(signature, secondQuote + 1, firstQuote - secondQuote - 1);
                        if (index >= 0) {
                            break;
                        }
                    }
                }
            }

            GlobalLog.Print("AuthenticationManager::FindSubstringNotInQuotes(" + challenge + ", " + signature + ")=" + index.ToString());
            return index;
        }

        //
        // this method is called by the IAuthenticationModule implementations
        // (mainly Digest) to safely find their list of parameters in a challenge.
        // it returns the index of the first ',' that is not included in quotes,
        // -1 is returned on error or end of string. on return offset contains the
        // index of the first '=' that is not included in quotes, -1 if no '=' was found.
        //
        internal static int SplitNoQuotes(string challenge, ref int offset) {
            // GlobalLog.Print("SplitNoQuotes([" + challenge + "], " + offset.ToString() + ")");
            //
            // save offset
            //
            int realOffset = offset;
            //
            // default is not found
            //
            offset = -1;

            if (challenge != null && realOffset<challenge.Length) {
                int firstQuote = -1, secondQuote = -1;

                for (int i = realOffset; i < challenge.Length; i++) {
                    //
                    // firstQuote>secondQuote means we are in a quoted string
                    //
                    if (firstQuote>secondQuote && challenge[i]=='\\' && i+1 < challenge.Length && challenge[i+1]=='\"') {
                        //
                        // skip <\"> when in a quoted string
                        //
                        i++;
                    }
                    else if (challenge[i]=='\"') {
                        if (firstQuote <= secondQuote) {
                            firstQuote = i;
                        }
                        else {
                            secondQuote = i;
                        }
                    }
                    else if (challenge[i]=='=' && firstQuote<=secondQuote && offset<0) {
                        offset = i;
                    }
                    else if (challenge[i]==',' && firstQuote<=secondQuote) {
                        return i;
                    }
                }
            }

            return -1;
        }

        /// <include file='doc\AuthenticationManager.uex' path='docs/doc[@for="ConnectionGroupAuthentication.GetGroupAuthorization"]/*' />
        internal static Authorization GetGroupAuthorization(IAuthenticationModule thisModule, string token, bool finished, NTAuthentication authSession, bool shareAuthenticatedConnections) {
            return
                new Authorization(
                    token, 
                    finished, 
                    (shareAuthenticatedConnections) ? null : (thisModule.GetType().FullName + "/" + authSession.UniqueUserId) );

        }


    }; // class AuthenticationManager

    //
    // This internal class implements a data structure which can be
    // used for storing a set of objects keyed by string prefixes
    // Looking up an object given a string returns the value associated
    // with the longest matching prefix
    // (A prefix "matches" a string IFF the string starts with that prefix
    // The degree of the match is prefix length)
    //
    internal class PrefixLookup {
        //
        // our prefix store (a Hashtable) needs to support multiple readers and multiple writers.
        // the documentation on Hashtable says:
        // "A Hashtable can safely support one writer and multiple readers concurrently. 
        // To support multiple writers, all operations must be done through the wrapper 
        // returned by the Synchronized method."
        // it's safe enough, for our use, to just synchronize (with a call to lock()) all write operations
        // so we always fall in the supported "one writer and multiple readers" scenario.
        //
        private Hashtable m_Store = new Hashtable();

        internal void Add(string prefix, object value) {
            // Hashtable will overwrite existing key
            lock (m_Store) {
                // writers are locked
                m_Store[prefix] = value;
            }
        }

        internal void Remove(string prefix) {
            // Hashtable will be unchanged if key is not existing
            lock (m_Store) {
                // writers are locked
                m_Store.Remove(prefix);
            }
        }

        internal object Lookup(string lookupKey) {
            if (lookupKey==null) {
                return null;
            }
            object mostSpecificMatch = null;
            int longestMatchPrefix = 0;
            int prefixLen;
            lock (m_Store) {
                //
                // readers don't need to be locked, but we lock() because:
                // "The enumerator does not have exclusive access to the collection.
                // 
                // When an enumerator is instantiated, it takes a snapshot of the current state 
                // of the collection. If changes are made to the collection, such as adding, 
                // modifying or deleting elements, the snapshot gets out of sync and the 
                // enumerator throws an InvalidOperationException. Two enumerators instantiated 
                // from the same collection at the same time can have different snapshots of the 
                // collection."
                //
                // enumerate through every credential in the cache
                //
                string prefix;
                foreach (DictionaryEntry entry in m_Store) {
                    prefix = (string)entry.Key;
                    if (lookupKey.StartsWith(prefix)) {
                        prefixLen = prefix.Length;
                        //
                        // check if the match is better than the current-most-specific match
                        //
                        if (prefixLen>longestMatchPrefix) {
                            //
                            // Yes-- update the information about currently preferred match
                            //
                            longestMatchPrefix = prefixLen;
                            mostSpecificMatch = entry.Value;
                        }
                    }
                }
            }
            return mostSpecificMatch;
        }

    } // class PrefixLookup


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\cookieexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="cookieexception.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Runtime.Serialization;
    /// <include file='doc\cookieexception.uex' path='docs/doc[@for="CookieException"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    public class CookieException : FormatException, ISerializable {
        /// <include file='doc\cookieexception.uex' path='docs/doc[@for="CookieException.CookieException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieException() : base() {
        }

        internal CookieException(string message) : base(message) {
        }

        internal CookieException(string message, Exception inner) : base(message, inner) {
        }

        /// <include file='doc\cookieexception.uex' path='docs/doc[@for="CookieException.CookieException1"]/*' />
        protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext)
            : base(serializationInfo, streamingContext) {
        }

        /// <include file='doc\cookieexception.uex' path='docs/doc[@for="CookieException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            base.GetObjectData(serializationInfo, streamingContext);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\cookiecontainer.cs ===
//------------------------------------------------------------------------------
// <copyright file="cookiecontainer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Threading;
    using System.Globalization;
    
    internal struct HeaderVariantInfo {

        string m_name;
        CookieVariant m_variant;

        internal HeaderVariantInfo(string name, CookieVariant variant) {
            m_name = name;
            m_variant = variant;
        }

        internal string Name {
            get {
                return m_name;
            }
        }

        internal CookieVariant Variant {
            get {
                return m_variant;
            }
        }
    }

    //
    // CookieContainer
    //
    //  Manage cookies for a user (implicit). Based on RFC 2965
    //

    /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    public class CookieContainer {

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.DefaultCookieLimit"]/*' />
        public const int DefaultCookieLimit = 300;
        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.DefaultPerDomainCookieLimit"]/*' />
        public const int DefaultPerDomainCookieLimit = 20;
        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.DefaultCookieLengthLimit"]/*' />
        public const int DefaultCookieLengthLimit = 4096;

        static readonly HeaderVariantInfo [] HeaderInfo = {
            new HeaderVariantInfo(HttpKnownHeaderNames.SetCookie,  CookieVariant.Rfc2109),
            new HeaderVariantInfo(HttpKnownHeaderNames.SetCookie2, CookieVariant.Rfc2965)
        };

    // fields

        Hashtable m_domainTable = new Hashtable();
        int m_maxCookieSize = DefaultCookieLengthLimit;
        int m_maxCookies = DefaultCookieLimit;
        int m_maxCookiesPerDomain = DefaultPerDomainCookieLimit;
        int m_count = 0;
        string  m_fqdnMyDomain = String.Empty;

    // constructors

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.CookieContainer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieContainer() {

            IPHostEntry local=null;
            try {
                local = Dns.LocalHost;
            }
            catch {
                return;
            }

            int dot  = local.HostName.IndexOf('.');
            if(dot != -1) {
                m_fqdnMyDomain = local.HostName.Substring(dot);
            }
            //Otherwise it will remain string.Empty
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.CookieContainer1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieContainer(int capacity) : this(){
            if (capacity <= 0) {
                throw new ArgumentException("Capacity");
            }
            m_maxCookies = capacity;
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.CookieContainer2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieContainer(int capacity, int perDomainCapacity, int maxCookieSize) : this(capacity) {
            if (perDomainCapacity != Int32.MaxValue && (perDomainCapacity <= 0 || perDomainCapacity > capacity)) {
                throw new ArgumentException("PerDomainCapacity");
            }
            m_maxCookiesPerDomain = perDomainCapacity;
            if (maxCookieSize <= 0) {
                throw new ArgumentException("MaxCookieSize");
            }
            m_maxCookieSize = maxCookieSize;
        }

    // properties

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.Capacity"]/*' />
        /// <devdoc>
        ///    <para>Note that after shrinking the capacity Count can become greater than Capacity.</para>
        /// </devdoc>
        public int Capacity {
            get {
                return m_maxCookies;
            }
            set {
                if (value <= 0 || (value < m_maxCookiesPerDomain && m_maxCookiesPerDomain != Int32.MaxValue)) {
                    throw new ArgumentOutOfRangeException("value");
                }
                if (value < m_maxCookies) {
                    m_maxCookies = value;
                    AgeCookies(null);
                }
                m_maxCookies = value;
            }
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.Count"]/*' />
        /// <devdoc>
        ///    <para>returns the total number of cookies in the container.</para>
        /// </devdoc>
        public int Count {
            get {
                return m_count;
            }
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.MaxCookieSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int MaxCookieSize {
            get {
                return m_maxCookieSize;
            }
            set {
                if (value <= 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                m_maxCookieSize = value;
            }
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.PerDomainCapacity"]/*' />
        /// <devdoc>
        ///    <para>After shrinking domain capacity each domain will less hold than new domain capacity</para>
        /// </devdoc>
        public int PerDomainCapacity {
            get {
                return m_maxCookiesPerDomain;
            }
            set {
                if (value <= 0 || (value > m_maxCookies && value != Int32.MaxValue)) {
                    throw new ArgumentOutOfRangeException("value");
                }
                if (value < m_maxCookiesPerDomain) {
                    m_maxCookiesPerDomain = value;
                    AgeCookies(null);
                }
                m_maxCookiesPerDomain = value;
            }
        }

    // methods

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        //This method will construct faked URI, Domain property is required for param.
        public void Add(Cookie cookie) {
            if (cookie == null) {
                throw new ArgumentNullException("cookie");
            }

            if (cookie.Domain.Length == 0) {
                throw new ArgumentException("cookie.Domain");
            }

            // We don't know cookie verification status -> re-create cookie and verify it
            Cookie new_cookie = new Cookie(cookie.Name, cookie.Value);
            Uri uri;

            new_cookie.Version = cookie.Version;

            // We cannot add an invalid cookie into the container.
            // Trying to 'cook' Uri for the cookie verification
            string uriStr = (cookie.Secure ? Uri.UriSchemeHttps : Uri.UriSchemeHttp) + Uri.SchemeDelimiter ;

            if (cookie.Domain[0] == '.') {
                uriStr += "0";                      // Uri cctor should eat this, faked host.
                new_cookie.Domain = cookie.Domain;  // Otherwise keep Domain as implicitly set
            }
            uriStr += cookie.Domain;


            // Either keep Port as implici or set it according to original cookie
            if (cookie.PortList != null) {
                new_cookie.Port = cookie.Port;
                uriStr += ":"+ cookie.PortList[0];
            }

            // Path must be present, set to root by default
            new_cookie.Path = cookie.Path.Length == 0 ? "/" : cookie.Path;
            uriStr += cookie.Path;

            try {
                uri = new Uri(uriStr, false);
            }
            catch {
                throw new CookieException(SR.GetString(SR.net_cookie_attribute, "Domain", cookie.Domain));
            }

            new_cookie.VerifySetDefaults(CookieVariant.Unknown, uri, IsLocal(uri.Host), m_fqdnMyDomain, true, true);

            Add(new_cookie, true);
        }

        private void AddRemoveDomain(string key, PathList value) {
            // Hashtable support multiple readers ans one writer
            // Synchronize writers (make them to be just one)
            lock(this) {
                if (value == null) {
                    m_domainTable.Remove(key);
                }
                else {
                    m_domainTable[key] = value;
                }
            }
        }

        // This method is called *only* when cooke verification is done,
        // so unlike with public Add(Cookie cookie) the cookie is in sane condition
        internal void Add(Cookie cookie, bool throwOnError) {

            PathList pathList;

            if (cookie.Value.Length > m_maxCookieSize) {
                if (throwOnError) {
                    throw new CookieException(SR.GetString(SR.net_cookie_size, cookie.ToString(), m_maxCookieSize));
                }
                return;
            }

            try {

                pathList = (PathList)m_domainTable[cookie.DomainKey];
                if (pathList == null) {
                    pathList = new PathList();
                    AddRemoveDomain(cookie.DomainKey, pathList);
                }
                int domain_count = pathList.GetCookiesCount();

                CookieCollection cookies = (CookieCollection)pathList[cookie.Path];

                if (cookies == null) {
                    cookies = new CookieCollection();
                    pathList[cookie.Path] = cookies;
                }

                if(cookie.Expired) {
                    //Explicit removal command (Max-Age == 0)
                    lock (cookies) {
                        int idx = cookies.IndexOf(cookie);
                        if (idx != -1) {
                            cookies.RemoveAt(idx);
                            --m_count;
                        }
                    }
                }
                else {
                    //This is about real cookie adding, check Capacity first
                    if (domain_count >= m_maxCookiesPerDomain && !AgeCookies(cookie.DomainKey)) {
                            return; //cannot age -> reject new cookie
                    }
                    else if (this.m_count >= m_maxCookies && !AgeCookies(null)) {
                            return; //cannot age -> reject new cookie
                    }

                    //about to change the collection
                    lock (cookies) {
                        m_count += cookies.InternalAdd(cookie, true);
                    }
                }
            }
            catch (Exception e) {
                if (throwOnError) {
                    throw new CookieException(SR.GetString(SR.net_container_add_cookie), e);
                }
            }
        }

        //
        // This function, once called, must delete at least one cookie
        // If there are expired cookies in given scope they are cleaned up
        // If nothing found the least used Collection will be found and removed
        // from the container.
        //
        // Also note that expired cookies are also removed during request preparation
        // (this.GetCookies method)
        //
        // Param. 'domain' == null means to age in the whole container
        //
        private bool AgeCookies(string domain) {

            // border case => shrinked to zero
            if(m_maxCookies == 0 || m_maxCookiesPerDomain == 0) {
                m_domainTable = new Hashtable();
                m_count = 0;
                return false;
            }

            int      removed = 0;
            DateTime oldUsed = DateTime.MaxValue;
            DateTime tempUsed;

            CookieCollection lruCc = null;
            string   lruDomain =  null;
            string   tempDomain = null;

            PathList pathList;
            int domain_count = 0;
            int itemp = 0;
            float remainingFraction = 1.0F;    

            // the container was shrinked, might need additional cleanup for each domain
            if (m_count > m_maxCookies) {
                // Means the fraction of the container to be left
                // Each domain will be cut accordingly
                remainingFraction = (float)m_maxCookies/(float)m_count;

            }

            foreach (DictionaryEntry entry in m_domainTable) {
                if (domain == null) {
                    tempDomain = (string) entry.Key;
                    pathList = (PathList) entry.Value;          //aliasing to trick foreach
                }
                else {
                    tempDomain = domain;
                    pathList = (PathList) m_domainTable[domain];
                }

                domain_count = 0;                             // cookies in the domain
                foreach (CookieCollection cc in pathList.Values) {
                    itemp = ExpireCollection(cc);
                    removed += itemp;
                    m_count -= itemp;                      //update this container count;
                    domain_count += cc.Count;
                    // we also find the least used cookie collection in ENTIRE container
                    // we count the collection as LRU only if it holds 1+ elements
                    if (cc.Count > 0 && (tempUsed = cc.TimeStamp(CookieCollection.Stamp.Check)) < oldUsed) {
                        lruDomain = tempDomain;
                        lruCc = cc;
                        oldUsed = tempUsed;
                    }
                }

                // Check if we have reduced to the limit of the domain by expiration only
                int min_count = Math.Min((int)(domain_count*remainingFraction), Math.Min(m_maxCookiesPerDomain, m_maxCookies)-1);
                if (domain_count > min_count) {
                    //That case require sorting all domain collections by timestamp
                    Array cookies = Array.CreateInstance(typeof(CookieCollection), pathList.Count);
                    Array stamps  = Array.CreateInstance(typeof(DateTime), pathList.Count);
                    foreach (CookieCollection cc in pathList.Values) {
                        stamps.SetValue(cc.TimeStamp(CookieCollection.Stamp.Check), itemp);
                        cookies.SetValue(cc ,itemp );
                        ++itemp ;
                    }
                    Array.Sort(stamps, cookies);

                    itemp = 0;
                    for (int i = 0; i < pathList.Count; ++i) {
                        CookieCollection cc = (CookieCollection)cookies.GetValue(i);

                        lock (cc) {
                            while (domain_count > min_count && cc.Count > 0) {
                                cc.RemoveAt(0);
                                --domain_count;
                                --m_count;
                                ++removed;
                            }
                        }
                        if (domain_count <= min_count ) {
                            break;
                        }
                    }

                    if (domain_count > min_count && domain != null) {
                        //cannot complete aging of explicit domain (no cookie adding allowed)
                        return false;
                    }
                }

                // we have completed aging of specific domain
                if (domain != null) {
                    return true;
                }

            }

            //  The rest is  for entire container aging
            //  We must get at least one free slot.

            //Don't need to appy LRU if we already cleaned something
            if (removed != 0) {
                return true;
            }

            if (oldUsed == DateTime.MaxValue) {
            //Something strange. Either capacity is 0 or all collections are locked with cc.Used
                return false;
            }

            // Remove oldest cookies from the least used collection
            lock (lruCc) {
                while (m_count >= m_maxCookies && lruCc.Count > 0) {
                    lruCc.RemoveAt(0);
                    --m_count;
                }
            }
            return true;
        }

        //return number of cookies removed from the collection
        private int ExpireCollection(CookieCollection cc) {
            int oldCount = cc.Count;
            int idx = oldCount-1;

            // minor optimization by caching Now
            DateTime now = DateTime.Now;

            lock (cc) {
                //Cannot use enumerator as we are going to alter collection
                while (idx >= 0) {
                    Cookie cookie = cc[idx];
                    if (cookie.Expires <= now && cookie.Expires != DateTime.MinValue) {

                        cc.RemoveAt(idx);
                    }
                    --idx;
                }
            }
            return oldCount - cc.Count;
        }


        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.Add1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        // Consider V.Next
                // CONSIDER removing this method or adding Uri parameter to it
        public void Add(CookieCollection cookies) {
            if (cookies == null) {
                throw new ArgumentNullException("cookies");
            }
            foreach (Cookie c in cookies) {
                Add(c);
            }
        }

        //
        // This will try (if needed) get the full domain name of the host given the Uri
        // NEVER call this function from internal methods with 'fqdnRemote' == NULL
        // Since this method counts security issue for DNS and hence will slow
        // the performance
        //
        internal bool IsLocal(string host) {
            
            int dot = host.IndexOf('.');
            if (dot == -1) {
                // No choice but to treat it as a host on the local domain
                return true;
            }
            const string localAddr = "127.0.0.";//this covers not 100% cases since actually everything 127.x.x.x is a localhost
            const string localHost = "localhost";
            const string loopBack  = "loopback";
            if ((string.Compare(host, 0, localAddr, 0, localAddr.Length, false, CultureInfo.InvariantCulture) == 0) ||
                (string.Compare(host,localHost, true, CultureInfo.InvariantCulture) == 0) ||
                (string.Compare(host,loopBack, true, CultureInfo.InvariantCulture) == 0)) {
                return true;
            }
            return string.Compare(m_fqdnMyDomain, 0, host, dot, m_fqdnMyDomain.Length, true, CultureInfo.InvariantCulture) == 0;
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.Add2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(Uri uri, Cookie cookie) {
            if (uri == null) {
                throw new ArgumentNullException("uri");
            }
            if(cookie == null) {
                throw new ArgumentNullException("cookie");
            }
            cookie.VerifySetDefaults(CookieVariant.Unknown, uri, IsLocal(uri.Host), m_fqdnMyDomain, true, true);

            Add(cookie, true);
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.Add3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        public void Add(Uri uri, CookieCollection cookies) {
            if (uri == null) {
                throw new ArgumentNullException("uri");
            }
            if(cookies == null) {
                throw new ArgumentNullException("cookies");
            }
            bool isLocalDomain = IsLocal(uri.Host);
            foreach (Cookie c in cookies) {
                c.VerifySetDefaults(CookieVariant.Unknown, uri, isLocalDomain, m_fqdnMyDomain, true, true);
                Add(c, true);
            }
        }

        internal CookieCollection CookieCutter(Uri uri, string HeaderName, string setCookieHeader, bool isThrow) {

            CookieCollection cookies = new CookieCollection();

            CookieVariant variant = CookieVariant.Unknown;
            if (HeaderName == null) {
                variant = CookieVariant.Default;
            }
            else for (int i = 0; i < HeaderInfo.Length; ++i) {
                if ((String.Compare(HeaderName, HeaderInfo[i].Name, true, CultureInfo.InvariantCulture) == 0)) {
                        variant  = HeaderInfo[i].Variant;
                }
            }

            bool isLocalDomain = IsLocal(uri.Host);

            try {
                CookieParser parser = new CookieParser(setCookieHeader);
                do {

                    Cookie cookie = parser.Get();
                    if (cookie == null) {
//Console.WriteLine("CookieCutter: eof cookies");
                        break;
                    }

                    //Parser marks invalid cookies this way
                    if (cookie.Name == string.Empty) {
                        if(isThrow) {
                            throw new CookieException(SR.GetString(SR.net_cookie_format));
                        }
                        //Otherwise, ignore (reject) cookie
                        continue;
                    }

                    // this will set the default values from the response URI
                    // AND will check for cookie validity
                    if(!cookie.VerifySetDefaults(variant, uri, isLocalDomain, m_fqdnMyDomain, true, isThrow)) {
                        continue;
                    }
                    // If many same cookies arrive we collapse them into just one, hence setting
                    // parameter isStrict = true below
                    cookies.InternalAdd(cookie, true);

                } while (true);
            }
            catch (Exception e) {
                if(isThrow) {
                    throw new CookieException(SR.GetString(SR.net_cookie_parse_header, uri.AbsoluteUri), e);
                }
            }

            foreach (Cookie c in cookies) {
                Add(c, isThrow);
            }

            return cookies;
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.GetCookies"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieCollection GetCookies(Uri uri) {
            if (uri == null) {
                throw new ArgumentNullException("uri");
            }
            return InternalGetCookies(uri);
        }

        internal CookieCollection InternalGetCookies(Uri uri) {

            bool isSecure = (uri.Scheme == Uri.UriSchemeHttps);
            int  port = uri.Port;
            CookieCollection cookies = new CookieCollection();
            ArrayList nameKeys = new ArrayList();
            int firstCompatibleVersion0SpecKey = 0;

            string fqdnRemote = uri.Host;

            int dot = fqdnRemote.IndexOf('.');
            if (dot == -1) {
                // DNS.resolve may return short names even for other inet domains ;-(
                // We _don't_ know what the exact domain is, so try also grab short hostname cookies.
                nameKeys.Add(fqdnRemote);
                // grab long name from the local domain
                nameKeys.Add(fqdnRemote + m_fqdnMyDomain);
                // grab the local domain itself
                nameKeys.Add(m_fqdnMyDomain);
                firstCompatibleVersion0SpecKey = 3;
            }
            else {
                // grab the host itself
                nameKeys.Add(fqdnRemote);
                // grab the host domain
                nameKeys.Add(fqdnRemote.Substring(dot));
                firstCompatibleVersion0SpecKey = 2;
                // The following block is only for compatibility with Version0 spec.
                // Still, we'll add only Plain-Variant cookies if found under below keys
                if (fqdnRemote.Length > 2) {
                    // We ignore the '.' at the end on the name
                    int last = fqdnRemote.LastIndexOf('.', fqdnRemote.Length-2);
                    //AND keys with <2 dots inside.
                    if (last > 0) {
                        last = fqdnRemote.LastIndexOf('.', last-1);
                    }
                    if (last != -1) {
                        while ((dot < last) && (dot = fqdnRemote.IndexOf('.', dot+1)) != -1) {
                            nameKeys.Add(fqdnRemote.Substring(dot));
                        }
                    }
                }
            }

            foreach (string key in nameKeys) {
            bool found = false;
            bool defaultAdded = false;
            PathList pathList = (PathList)m_domainTable[key];
            --firstCompatibleVersion0SpecKey;

                if (pathList == null) {
                    continue;
                }

                foreach (DictionaryEntry entry in pathList) {
                    string path = (string)entry.Key;
                    if (uri.AbsolutePath.StartsWith(CookieParser.CheckQuoted(path))) {
                        found = true;

                        CookieCollection cc = (CookieCollection)entry.Value;
                        cc.TimeStamp(CookieCollection.Stamp.Set);
                        MergeUpdateCollections(cookies, cc, port, isSecure, (firstCompatibleVersion0SpecKey<0));

                        if (path == "/") {
                            defaultAdded = true;
                        }
                    }
                    else if (found) {
                        break;
                    }
                }

                if (!defaultAdded) {
                    CookieCollection cc = (CookieCollection)pathList["/"];

                    if (cc != null) {
                        cc.TimeStamp(CookieCollection.Stamp.Set);
                        MergeUpdateCollections(cookies, cc, port, isSecure, (firstCompatibleVersion0SpecKey<0));
                    }
                }

                // Remove unused domain
                // (This is the only place that does domain removal)
                if(pathList.Count == 0) {
                    AddRemoveDomain(key, null);
                }
            }
            return cookies;
        }

        private void MergeUpdateCollections(CookieCollection destination, CookieCollection source, int port, bool isSecure, bool isPlainOnly) {

            // we may change it
            lock (source) {

                //cannot use foreach as we going update 'source'
                for (int idx = 0 ; idx < source.Count; ++idx) {
                    bool to_add = false;

                    Cookie cookie = source[idx];

                    if (cookie.Expired) {
                        //If expired, remove from container and don't add to the destination
                        source.RemoveAt(idx);
                        --m_count;
                        --idx;
                    }
                    else {
                        //Add only if port does match to this request URI
                        //or was not present in the original response
                        if(isPlainOnly && cookie.Variant != CookieVariant.Plain) {
                            ;//don;t add
                        }
                        else if(cookie.PortList != null)
                        {
                            foreach (int p in cookie.PortList) {
                                if(p == port) {
                                    to_add = true;
                                    break;
                                }
                            }
                        }
                        else {
                            //it was implicit Port, always OK to add
                            to_add = true;
                        }

                        //refuse adding secure cookie into 'unsecure' destination
                        if (cookie.Secure && !isSecure) {
                            to_add = false;
                        }

                        if (to_add) {
                            // In 'source' are already orederd.
                            // If two same cookies come from dif 'source' then they
                            // will follow (not replace) each other.
                            destination.InternalAdd(cookie, false);
                        }

                    }
                }
            }
        }

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.GetCookieHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetCookieHeader(Uri uri) {
            if (uri == null) {
                throw new ArgumentNullException("uri");
            }
            string dummy;
            return GetCookieHeader(uri, out dummy);

        }

        internal string GetCookieHeader(Uri uri, out string optCookie2) {
            CookieCollection cookies = InternalGetCookies(uri);
            string cookieString = String.Empty;
            string delimiter = String.Empty;

            foreach (Cookie cookie in cookies) {
                cookieString += delimiter + cookie.ToString();
                delimiter = "; ";
            }
            optCookie2 = cookies.IsOtherVersionSeen ?
                          (Cookie.SpecialAttributeLiteral +
                           Cookie.VersionAttributeName +
                           Cookie.EqualsLiteral +
                           Cookie.MaxSupportedVersion.ToString()) : String.Empty;

            return cookieString;
        }


        //public CookieCollection Parse(string cookieName) {
        //    return new CookieCollection();
        //}

        //public WebHeaderCollection Headers() {
        //}

        //public void Remove(Cookie cookie) {
        //}

        //public void Remove(string cookieName) {
        //}

        //public void RemoveAll(Cookie cookie) {
        //}

        //public void RemoveAll(string cookieName) {
        //}

        //public void SetCookie(Cookie cookie) {
        //}

        //public void SetCookies(CookieCollection cookies) {
        //}

        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.SetCookies"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        //Consider V.Next
        // Consider adding a parameter with Cookie Header Name value (like "Set-Cookie2")
        // For now a Default value (see cookies.cs) will be used
        public void SetCookies(Uri uri, string cookieHeader) {
            if (uri == null) {
                throw new ArgumentNullException("uri");
            }
            if(cookieHeader == null) {
                throw new ArgumentNullException("cookieHeader");
            }
            CookieCutter(uri, null, cookieHeader, true); //will throw on error
        }

#if DEBUG
        /// <include file='doc\cookiecontainer.uex' path='docs/doc[@for="CookieContainer.Dump"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dump() {
            Console.WriteLine("CookieContainer:");
            foreach (DictionaryEntry de in m_domainTable) {
                Console.WriteLine("domain = \"" + de.Key + "\"");
                ((PathList)de.Value).Dump();
            }
        }
#endif

    }

    [Serializable]
    internal class PathList {
        SortedList m_list = (SortedList.Synchronized(new SortedList(PathListComparer.StaticInstance)));

        public PathList() {
        }

        public int Count {
            get {
                return m_list.Count;
            }
        }

        public int GetCookiesCount() {
                int count = 0;
                foreach (CookieCollection cc in  m_list.Values) {
                    count += cc.Count;
                }
                return count;
        }

        public ICollection Values {
            get {
                return m_list.Values;
            }
        }

        public object this[string s] {
            get {
                return m_list[s];
            }
            set {
                m_list[s] = value;
            }
        }

        public IEnumerator GetEnumerator() {
            return m_list.GetEnumerator();
        }

        [Serializable]
        class PathListComparer : IComparer {
            internal static readonly PathListComparer StaticInstance = new PathListComparer();

            int IComparer.Compare(object ol, object or) {
    //Console.WriteLine("PathListComparer.Compare(" + ol + ", " + or + ")");

                string pathLeft = CookieParser.CheckQuoted((string)ol);
                string pathRight = CookieParser.CheckQuoted((string)or);
                int ll = pathLeft.Length;
                int lr = pathRight.Length;
                int length = Math.Min(ll, lr);

                for (int i = 0; i < length; ++i) {
                    if (pathLeft[i] != pathRight[i]) {
    //Console.WriteLine(" returning " + (pathLeft[i] - pathRight[i]));
                        return pathLeft[i] - pathRight[i];
                    }
                }
    //Console.WriteLine(" returning " + (lr - ll));
                return lr - ll;
            }
        }


#if DEBUG
        public void Dump() {
            Console.WriteLine("PathList:");
            foreach (DictionaryEntry cookies in this) {
                Console.WriteLine("collection = \"" + cookies.Key + "\"");
                ((CookieCollection)cookies.Value).Dump();
            }
        }
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\credentialcache.cs ===
//------------------------------------------------------------------------------
// <copyright file="CredentialCache.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Globalization;
    
    // More sophisticated password cache that stores multiple
    // name-password pairs and associates these with host/realm
    /// <include file='doc\CredentialCache.uex' path='docs/doc[@for="CredentialCache"]/*' />
    /// <devdoc>
    ///    <para>Provides storage for multiple credentials.</para>
    /// </devdoc>
    public class CredentialCache : ICredentials, IEnumerable {

    // fields

        private Hashtable cache = new Hashtable();
        internal int m_version;

        //DELEGATION remove this member and cleanup the code once the issue becomes obsolete
        private int m_NumbDefaultCredInCache = 0;

        internal bool IsDefaultInCache {
            get {
                return m_NumbDefaultCredInCache != 0;
            }
        }

    // constructors

        /// <include file='doc\CredentialCache.uex' path='docs/doc[@for="CredentialCache.CredentialCache"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.CredentialCache'/> class.
        ///    </para>
        /// </devdoc>
        public CredentialCache() {
        }

    // properties

    // methods

        /// <include file='doc\CredentialCache.uex' path='docs/doc[@for="CredentialCache.Add"]/*' />
        /// <devdoc>
        /// <para>Adds a <see cref='System.Net.NetworkCredential'/>
        /// instance to the credential cache.</para>
        /// </devdoc>
        // UEUE
        public void Add(Uri uriPrefix, string authType, NetworkCredential cred) {
            //
            // parameter validation
            //
            if (uriPrefix==null) {
                throw new ArgumentNullException("uriPrefix");
            }
            if (authType==null) {
                throw new ArgumentNullException("authType");
            }
            if ((cred is SystemNetworkCredential)
                && !((String.Compare(authType, "NTLM", true, CultureInfo.InvariantCulture) == 0)
                     || (String.Compare(authType, "Kerberos", true, CultureInfo.InvariantCulture) == 0)
                     || (String.Compare(authType, "Negotiate", true, CultureInfo.InvariantCulture) == 0))) {
                throw new ArgumentException(SR.GetString(SR.net_nodefaultcreds, authType), "authType");
            }

            ++m_version;

            CredentialKey key = new CredentialKey(uriPrefix, authType);

            GlobalLog.Print("CredentialCache::Add() Adding key:[" + key.ToString() + "], cred:[" + cred.Domain + "],[" + cred.UserName + "],[" + cred.Password + "]");

            cache.Add(key, cred);
            if (cred is SystemNetworkCredential) {
                ++m_NumbDefaultCredInCache;
            }
        }

        /// <include file='doc\CredentialCache.uex' path='docs/doc[@for="CredentialCache.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes a <see cref='System.Net.NetworkCredential'/>
        /// instance from the credential cache.</para>
        /// </devdoc>
        public void Remove(Uri uriPrefix, string authType) {
            if (uriPrefix==null || authType==null) {
                // these couldn't possibly have been inserted into
                // the cache because of the test in Add()
                return;
            }

            ++m_version;

            CredentialKey key = new CredentialKey(uriPrefix, authType);

            GlobalLog.Print("CredentialCache::Remove() Removing key:[" + key.ToString() + "]");

            if (cache[key] is SystemNetworkCredential) {
                --m_NumbDefaultCredInCache;
            }
            cache.Remove(key);
        }

        /// <include file='doc\CredentialCache.uex' path='docs/doc[@for="CredentialCache.GetCredential"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Net.NetworkCredential'/>
        ///       instance associated with the supplied Uri and
        ///       authentication type.
        ///    </para>
        /// </devdoc>
        public NetworkCredential GetCredential(Uri uriPrefix, string authType) {
            if (uriPrefix==null)
                throw new ArgumentNullException("asyncResult");
    	    if (authType==null)
                throw new ArgumentNullException("authType");

            GlobalLog.Print("CredentialCache::GetCredential(uriPrefix=\"" + uriPrefix + "\", authType=\"" + authType + "\")");

            int longestMatchPrefix = -1;
            NetworkCredential mostSpecificMatch = null;
            IDictionaryEnumerator credEnum = cache.GetEnumerator();

            //
            // Enumerate through every credential in the cache
            //

            while (credEnum.MoveNext()) {

                CredentialKey key = (CredentialKey)credEnum.Key;

                //
                // Determine if this credential is applicable to the current Uri/AuthType
                //

                if (key.Match(uriPrefix, authType)) {

                    int prefixLen = key.UriPrefixLength;

                    //
                    // Check if the match is better than the current-most-specific match
                    //

                    if (prefixLen > longestMatchPrefix) {

                        //
                        // Yes-- update the information about currently preferred match
                        //

                        longestMatchPrefix = prefixLen;
                        mostSpecificMatch = (NetworkCredential)credEnum.Value;
                    }
                }
            }

            GlobalLog.Print("CredentialCache::GetCredential returning " + ((mostSpecificMatch==null)?"null":"(" + mostSpecificMatch.UserName + ":" + mostSpecificMatch.Password + ":" + mostSpecificMatch.Domain + ")"));

            return mostSpecificMatch;
        }

        /// <include file='doc\CredentialCache.uex' path='docs/doc[@for="CredentialCache.GetEnumerator"]/*' />
        /// <devdoc>
        ///    [To be supplied]
        /// </devdoc>

        //
        // IEnumerable interface
        //

        public IEnumerator GetEnumerator() {
            return new CredentialEnumerator(this, cache, m_version);
        }

        /// <include file='doc\CredentialCache.uex' path='docs/doc[@for="CredentialCache.DefaultCredentials"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the default system credentials from the <see cref='System.Net.CredentialCache'/>.
        ///    </para>
        /// </devdoc>
        public static ICredentials DefaultCredentials {
            get {
                //This check will not allow to use local user credentials at will.
                //Hence the username will not be exposed to the network
                new EnvironmentPermission(EnvironmentPermissionAccess.Read, "USERNAME").Demand();
                return SystemNetworkCredential.defaultCredential;
            }
        }

        private class CredentialEnumerator : IEnumerator {

        // fields

            private CredentialCache m_cache;
            private ICredentials[] m_array;
            private int m_index = -1;
            private int m_version;

        // constructors

            internal CredentialEnumerator(CredentialCache cache, Hashtable table, int version) {
                m_cache = cache;
                m_array = new ICredentials[table.Count];
                table.Values.CopyTo(m_array, 0);
                m_version = version;
            }

        // IEnumerator interface

        // properties

            object IEnumerator.Current {
                get {
                    if (m_index < 0 || m_index >= m_array.Length) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
                    }
                    if (m_version != m_cache.m_version) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                    }
                    return m_array[m_index];
                }
            }

        // methods

            bool IEnumerator.MoveNext() {
                if (m_version != m_cache.m_version) {
                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                }
                if (++m_index < m_array.Length) {
                    return true;
                }
                m_index = m_array.Length;
                return false;
            }

            void IEnumerator.Reset() {
                m_index = -1;
            }

        } // class CredentialEnumerator


    } // class CredentialCache



    // Abstraction for credentials in password-based
    // authentication schemes (basic, digest, NTLM, Kerberos)
    // Note this is not applicable to public-key based
    // systems such as SSL client authentication
    // "Password" here may be the clear text password or it
    // could be a one-way hash that is sufficient to
    // authenticate, as in HTTP/1.1 digest.

    //
    // Object representing default credentials
    //
    internal class SystemNetworkCredential : NetworkCredential {
        internal static readonly SystemNetworkCredential defaultCredential = new SystemNetworkCredential();

        public SystemNetworkCredential() :
            base(string.Empty, string.Empty, string.Empty) {
        }

        public new NetworkCredential GetCredential(Uri uri, string authType) {
            //
            // this is an empty cache that returns
            // always the same DefaultCredentials
            //
            return defaultCredential;
        }
    }


    internal class CredentialKey {

        internal Uri UriPrefix;
        internal int UriPrefixLength = -1;
        internal string AuthenticationType;

        internal CredentialKey(Uri uriPrefix, string authenticationType) {
            UriPrefix = uriPrefix;
            UriPrefixLength = UriPrefix.ToString().Length;
            AuthenticationType = authenticationType;
        }

        internal bool Match(Uri uri, string authenticationType) {
            if (uri==null || authenticationType==null) {
                return false;
            }
            //
            // If the protocols dont match this credential
            // is not applicable for the given Uri
            //
            if (String.Compare(authenticationType, AuthenticationType, true, CultureInfo.InvariantCulture) != 0) {
                return false;
            }

            GlobalLog.Print("CredentialKey::Match(" + UriPrefix.ToString() + " & " + uri.ToString() + ")");

            return uri.IsPrefix(UriPrefix);
        }


        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //

                m_HashCode = AuthenticationType.GetHashCode() + UriPrefixLength + UriPrefix.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

        public override bool Equals(object comparand) {
            CredentialKey comparedCredentialKey = comparand as CredentialKey;

            if (comparand==null) {
                //
                // this covers also the compared==null case
                //
                return false;
            }

            bool equals =
                AuthenticationType.Equals(comparedCredentialKey.AuthenticationType) &&
                UriPrefix.Equals(comparedCredentialKey.UriPrefix);

            GlobalLog.Print("CredentialKey::Equals(" + ToString() + ", " + comparedCredentialKey.ToString() + ") returns " + equals.ToString());

            return equals;
        }

        public override string ToString() {
            return "[" + UriPrefixLength.ToString() + "]:" + ValidationHelper.ToString(UriPrefix) + ":" + ValidationHelper.ToString(AuthenticationType);
        }

    } // class CredentialKey


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\dns.cs ===
//------------------------------------------------------------------------------
// <copyright file="DNS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Net {
    using System.Text;
    using System.Collections;
    using System.Net.Sockets;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Threading;
    using System.Security;

    /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns"]/*' />
    /// <devdoc>
    ///    <para>Provides simple
    ///       domain name resolution functionality.</para>
    /// </devdoc>

    public sealed class Dns {
        //
        // used by GetHostName() to preallocate a buffer for the call to gethostname.
        //
        private const int HostNameBufferLength = 256;
        private const int DefaultLocalHostTimeOut = 1 * (60 * 1000); // 1 min?
        private static DnsPermission s_DnsPermission = new DnsPermission(PermissionState.Unrestricted);
        //
        // RAID#100262
        // ws2_32!gethostbyname does not check the size of the hostname before passing the
        // buffer down, this causes a heap corruption. we need to check before calling into
        // ws2_32!gethostbyname until they fix it.
        //
        private const int MaxHostName = 126;

        // Static bool variable activates static socket initializing method
        // we need this because socket is in a different namespace
        private static bool         s_Initialized = Socket.InitializeSockets();
        private static int          s_LastLocalHostCount ;
        private static IPHostEntry  s_LocalHost ;


        //
        // Constructor is private to prevent instantiation
        //
        private Dns() {
        }


        /*++

        Routine Description:

            Takes a native pointer (expressed as an int) to a hostent structure,
            and converts the information in their to an IPHostEntry class. This
            involves walking through an array of native pointers, and a temporary
            ArrayList object is used in doing this.

        Arguments:

            nativePointer   - Native pointer to hostent structure.



        Return Value:

            An IPHostEntry structure.

        --*/

        private static IPHostEntry NativeToHostEntry(IntPtr nativePointer) {
            //
            // marshal pointer to struct
            //

            hostent Host = (hostent)Marshal.PtrToStructure(nativePointer, typeof(hostent));
            IPHostEntry HostEntry = new IPHostEntry();

            if (Host.h_name != IntPtr.Zero) {
                HostEntry.HostName = Marshal.PtrToStringAnsi(Host.h_name);
                GlobalLog.Print("HostEntry.HostName: " + HostEntry.HostName);
            }

            // decode h_addr_list to ArrayList of IP addresses.
            // The h_addr_list field is really a pointer to an array of pointers
            // to IP addresses. Loop through the array, and while the pointer
            // isn't NULL read the IP address, convert it to an IPAddress class,
            // and add it to the list.

            ArrayList TempList = new ArrayList();
            int IPAddressToAdd;
            string AliasToAdd;
            IntPtr currentArrayElement;

            //
            // get the first pointer in the array
            //
            currentArrayElement = Host.h_addr_list;
            nativePointer = Marshal.ReadIntPtr(currentArrayElement);

            while (nativePointer != IntPtr.Zero) {
                //
                // if it's not null it points to an IPAddress,
                // read it...
                //
                IPAddressToAdd = Marshal.ReadInt32(nativePointer);

                GlobalLog.Print("currentArrayElement: " + currentArrayElement.ToString() + " nativePointer: " + nativePointer.ToString() + " IPAddressToAdd:" + IPAddressToAdd.ToString());

                //
                // ...and add it to the list
                //
                TempList.Add(new IPAddress(IPAddressToAdd));

                //
                // now get the next pointer in the array and start over
                //
                currentArrayElement = IntPtrHelper.Add(currentArrayElement, IntPtr.Size);
                nativePointer = Marshal.ReadIntPtr(currentArrayElement);
            }

            HostEntry.AddressList = new IPAddress[TempList.Count];
            TempList.CopyTo(HostEntry.AddressList, 0);

            //
            // Now do the same thing for the aliases.
            //

            TempList.Clear();

            currentArrayElement = Host.h_aliases;
            nativePointer = Marshal.ReadIntPtr(currentArrayElement);

            while (nativePointer != IntPtr.Zero) {

                GlobalLog.Print("currentArrayElement: " + ((long)currentArrayElement).ToString() + "nativePointer: " + ((long)nativePointer).ToString());

                //
                // if it's not null it points to an Alias,
                // read it...
                //
                AliasToAdd = Marshal.PtrToStringAnsi(nativePointer);

                //
                // ...and add it to the list
                //
                TempList.Add(AliasToAdd);

                //
                // now get the next pointer in the array and start over
                //
                currentArrayElement = IntPtrHelper.Add(currentArrayElement, IntPtr.Size);
                nativePointer = Marshal.ReadIntPtr(currentArrayElement);

            }

            HostEntry.Aliases = new string[TempList.Count];
            TempList.CopyTo(HostEntry.Aliases, 0);

            return HostEntry;

        } // NativeToHostEntry

        /*****************************************************************************
         Function :    gethostbyname

         Abstract:     Queries DNS for hostname address

         Input Parameters: str (String to query)

         Returns: Void
        ******************************************************************************/

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.GetHostByName"]/*' />
        /// <devdoc>
        /// <para>Retrieves the <see cref='System.Net.IPHostEntry'/>
        /// information
        /// corresponding to the DNS name provided in the host
        /// parameter.</para>
        /// </devdoc>
        public static IPHostEntry GetHostByName(string hostName) {
            //
            // demand Unrestricted DnsPermission for this call
            //
            s_DnsPermission.Demand();

            if (hostName == null) {
                throw new ArgumentNullException("hostName");
            }
            if (hostName.Length>MaxHostName) {
                throw new ArgumentOutOfRangeException(SR.GetString(SR.net_toolong, "hostName", MaxHostName.ToString()));
            }

            GlobalLog.Print("Dns.GetHostByName: " + hostName);
            
            //
            // IPv6 Changes: IPv6 requires the use of getaddrinfo() rather
            //               than the traditional IPv4 gethostbyaddr() / gethostbyname().
            //               getaddrinfo() is also protocol independant in that it will also
            //               resolve IPv4 names / addresses. As a result, it is the preferred
            //               resolution mechanism on platforms that support it (Windows 5.1+).
            //               If getaddrinfo() is unsupported, IPv6 resolution does not work.
            //
            // Consider    : If IPv6 is disabled, we could detect IPv6 addresses
            //               and throw an unsupported platform exception.
            //
            // Note        : Whilst getaddrinfo is available on WinXP+, we only
            //               use it if IPv6 is enabled (platform is part of that
            //               decision). This is done to minimize the number of 
            //               possible tests that are needed.
            //
            if ( Socket.SupportsIPv6 ) {
                //
                // IPv6 enabled: use getaddrinfo() to obtain DNS information.
                //
                return Dns.GetAddrInfo(hostName);
            }
            else {
                //
                // IPv6 disabled: use gethostbyname() to obtain DNS information.
                //
                IntPtr nativePointer =
                    UnsafeNclNativeMethods.OSSOCK.gethostbyname(
                        hostName);

                if (nativePointer == IntPtr.Zero) {
                    //This is for compatiblity with NT4
                    SocketException e = new SocketException();
                    //This block supresses "unknown error" on NT4 when input is
                    //arbitrary IP address. It simulates same result as on Win2K.
                    try {
                        IPAddress address = IPAddress.Parse(hostName);
                        IPHostEntry ipHostEntry = new IPHostEntry();
                        ipHostEntry.HostName = string.Copy(hostName);
                        ipHostEntry.Aliases = new string[0];
                        ipHostEntry.AddressList = new IPAddress[] {address};
                        return ipHostEntry;
                    }
                    catch {
                        //Report original DNS error (not from IPAddress.Parse())
                        throw e;
                    }
                }

                return NativeToHostEntry(nativePointer);
            }

        } // GetHostByName



        //
        // Find out if we need to rebuild our LocalHost. If the process
        //  time has been running for a while the machine's IP addresses
        //  could have changed, this causing us to want to requery the info.
        //
        internal static bool IsLocalHostExpired() {
            int counter = Environment.TickCount;
            bool timerExpired = false;
            if (s_LastLocalHostCount > counter) {
                timerExpired = true;
            } else {
                counter -= s_LastLocalHostCount;
                if (counter > DefaultLocalHostTimeOut) {
                    timerExpired = true;
                }
            }
            return timerExpired;
        }
 
        //
        // Returns a list of our local addresses, caches the result of GetLocalHost
        //
        internal static IPHostEntry LocalHost {
            get {
                bool timerExpired = IsLocalHostExpired();
                if (s_LocalHost == null || timerExpired ) {
                    lock (typeof(Dns)) {
                        if (s_LocalHost == null || timerExpired ) {
                            s_LastLocalHostCount = Environment.TickCount;
                            s_LocalHost = GetLocalHost();
                        }
                    }
                }
                return s_LocalHost;
            }
        }
 
        //
        // Returns a list of our local addresses by calling gethostbyname with null.
        //
        private static IPHostEntry GetLocalHost() {
            GlobalLog.Print("Dns.GetLocalHost");
            //
            // IPv6 Changes: If IPv6 is enabled, we can't simply use the
            //               old IPv4 gethostbyname(null). Instead we need
            //               to do a more complete lookup.
            //
            if ( Socket.SupportsIPv6 ) {
                //
                // IPv6 enabled: use getaddrinfo() of the local host name
                // to obtain this information. Need to get the machines
                // name as well - do that here so that we don't need to
                // Assert DNS permissions.
                //
                StringBuilder hostname  = new StringBuilder(HostNameBufferLength);
                int           errorCode = UnsafeNclNativeMethods.OSSOCK.gethostname(hostname, HostNameBufferLength);

                if (errorCode != 0) {
                    throw new SocketException();
                }

                return GetHostByName(hostname.ToString());
            }
            else {
                //
                // IPv6 disabled: use gethostbyname() to obtain information.
                //
                IntPtr nativePointer =
                    UnsafeNclNativeMethods.OSSOCK.gethostbyname(
                        null);

                if (nativePointer == IntPtr.Zero) {
                    throw new SocketException();
                }

                return NativeToHostEntry(nativePointer);
            }

        } // GetLocalHost


        /*****************************************************************************
         Function :    gethostbyaddr

         Abstract:     Queries IP address string and tries to match with a host name

         Input Parameters: str (String to query)

         Returns: IPHostEntry
        ******************************************************************************/

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.GetHostByAddress"]/*' />
        /// <devdoc>
        /// <para>Creates an <see cref='System.Net.IPHostEntry'/>
        /// instance from an IP dotted address.</para>
        /// </devdoc>
        public static IPHostEntry GetHostByAddress(string address) {
            //
            // demand Unrestricted DnsPermission for this call
            //
            s_DnsPermission.Demand();

            if (address == null) {
                throw new ArgumentNullException("address");
            }

            GlobalLog.Print("Dns.GetHostByAddress: " + address);

            // convert String based address to bit encoded address stored in an int

            IPAddress ip_addr = IPAddress.Parse(address);

            return GetHostByAddress(ip_addr);

        } // GetHostByAddress

        /*****************************************************************************
         Function :    gethostbyaddr

         Abstract:     Queries IP address and tries to match with a host name

         Input Parameters: address (address to query)

         Returns: IPHostEntry
        ******************************************************************************/

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.GetHostByAddress1"]/*' />
        /// <devdoc>
        /// <para>Creates an <see cref='System.Net.IPHostEntry'/> instance from an <see cref='System.Net.IPAddress'/>
        /// instance.</para>
        /// </devdoc>
        public static IPHostEntry GetHostByAddress(IPAddress address) {
            //
            // demand Unrestricted DnsPermission for this call
            //
            s_DnsPermission.Demand();

            if (address == null) {
                throw new ArgumentNullException("address");
            }

            GlobalLog.Print("Dns.GetHostByAddress: " + address.ToString());
            //
            // IPv6 Changes: We need to use the new getnameinfo / getaddrinfo functions
            //               for resolution of IPv6 addresses.
            //
            if ( Socket.SupportsIPv6 ) {
                //
                // Try to get the data for the host from it's address
                //
                return GetAddrInfo(GetNameInfo(address));
            }

            //
            // If IPv6 is not enabled (maybe config switch) but we've been
            // given an IPv6 address then we need to bail out now.
            //
            if ( address.AddressFamily == AddressFamily.InterNetworkV6 ) {
                //
                // Protocol not supported
                //
                throw new SocketException(SocketErrors.WSAEPROTONOSUPPORT);
            }
            //
            // Use gethostbyaddr() to try to resolve the IP address
            //
            // End IPv6 Changes
            //
            int addressAsInt = unchecked((int)address.m_Address);

            IntPtr nativePointer =
                UnsafeNclNativeMethods.OSSOCK.gethostbyaddr(
                    ref addressAsInt,
                    Marshal.SizeOf(typeof(int)),
                    ProtocolFamily.InterNetwork);


            if (nativePointer == IntPtr.Zero) {
                throw new SocketException();
            }

            return NativeToHostEntry(nativePointer);

        } // GetHostByAddress

        /*****************************************************************************
         Function :    inet_ntoa

         Abstract:     Numerical IP value to IP address string

         Input Parameters: address

         Returns: String
        ******************************************************************************/

        /*
        /// <summary>
        ///    <para>Creates a string containing the
        ///       DNS name of the host specified in address.</para>
        /// </summary>
        /// <param name='address'>An <see cref='System.Net.IPAddress'/> instance representing the IP (or dotted IP) address of the host.</param>
        /// <returns>
        ///    <para>A string containing the DNS name of the host
        ///       specified in the address.</para>
        /// </returns>
        /// <exception cref='System.ArgumentNullException'><paramref name="address "/>is null.</exception>
        // obsolete, use ToString()
        public static string InetNtoa(IPAddress address) {
            if (address == null) {
                throw new ArgumentNullException("address");
            }

            return address.ToString();
        }
        */

        /*****************************************************************************
         Function :    gethostname

         Abstract:     Queries the hostname from DNS

         Input Parameters:

         Returns: String
        ******************************************************************************/

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.GetHostName"]/*' />
        /// <devdoc>
        ///    <para>Gets the host name of the local machine.</para>
        /// </devdoc>
        // UEUE: note that this method is not threadsafe!!
        public static string GetHostName() {
            //
            // demand Unrestricted DnsPermission for this call
            //
            s_DnsPermission.Demand();

            GlobalLog.Print("Dns.GetHostName");

            //
            // note that we could cache the result ourselves since you
            // wouldn't expect the hostname of the machine to change during
            // execution, but this might still happen and we would want to
            // react to that change.
            //
            StringBuilder sb = new StringBuilder(HostNameBufferLength);
            int errorCode = UnsafeNclNativeMethods.OSSOCK.gethostname(sb, HostNameBufferLength);

            //
            // if the call failed throw a SocketException()
            //
            if (errorCode != 0) {
                throw new SocketException();
            }
            return sb.ToString();
        } // GetHostName

        /*****************************************************************************
         Function :    resolve

         Abstract:     Converts IP/hostnames to IP numerical address using DNS
                       Additional methods provided for convenience
                       (These methods will resolve strings and hostnames. In case of
                       multiple IP addresses, the address returned is chosen arbitrarily.)

         Input Parameters: host/IP

         Returns: IPAddress
        ******************************************************************************/

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.Resolve"]/*' />
        /// <devdoc>
        /// <para>Creates an <see cref='System.Net.IPAddress'/>
        /// instance from a DNS hostname.</para>
        /// </devdoc>
        // UEUE
        public static IPHostEntry Resolve(string hostName) {
            //
            // demand Unrestricted DnsPermission for this call
            //
            s_DnsPermission.Demand();
            //This is a perf optimization, this method call others that will demand and we already did that.
            s_DnsPermission.Assert();
            
            IPHostEntry ipHostEntry = null;
            try {
                if (hostName == null) {
                    throw new ArgumentNullException("hostName");
                }

                GlobalLog.Print("Dns.Resolve: " + hostName);

                //
                // as a minor perf improvement, we'll look at the first character
                // in the hostName and if that's a digit, call GetHostByAddress() first.
                // note that GetHostByAddress() will succeed ONLY if the first character is a digit.
                // hence if this is not the case, below, we will only call GetHostByName()
                // specifically, on Win2k, only the following are valid:
                // "11.22.33.44" - success
                // "0x0B16212C" - success
                // while these will fail or return bogus data (note the prepended spaces):
                // " 11.22.33.44" - bogus data
                // " 0x0B16212C" - bogus data
                // " 0B16212C" - bogus data
                // "0B16212C" - failure
                //
                // IPv6 support: added ':' as a legal character in IP addresses so that
                //               we can attempt gethostbyaddress first.
                //
                if ( hostName.Length > 0 &&
                    ( ( hostName[0]>='0' && hostName[0]<='9' ) || // Possible IPv4 or IPv6 numeric
                      ( hostName.IndexOf(':') >= 0 ) ) ) {        // Possible IPv6 numeric
                    try {
                        ipHostEntry = GetHostByAddress(hostName);
                    }
                    catch {
                        //
                        // this can fail for weird hostnames like 3com.com
                        //
                    }
                }
                if (ipHostEntry==null) {
                    ipHostEntry = GetHostByName(hostName);
                }
            }
            finally {
                DnsPermission.RevertAssert();
            }

            return ipHostEntry;
        }


        internal static IPHostEntry InternalResolve(string hostName) {
            GlobalLog.Assert(hostName!=null, "hostName == null", "");
            GlobalLog.Print("Dns.InternalResolve: " + hostName);

            //
            // the differences between this method and the previous public
            // Resolve() are:
            //
            // 1) we bypass DNS permission check
            // 2) we don't throw any exceptions
            // 3) we don't do a reverse lookup for address strings, we just use them
            //
            // IPv6 Changes: It is not practical to embed the code for GetAddrInfo here, instead
            //               we call it and catch any exceptions.
            //

            if (hostName.Length > 0 && hostName.Length <= MaxHostName) {

                if ( Socket.SupportsIPv6 ) {
                    //
                    // IP Address ?
                    //
                    if (Char.IsDigit(hostName[0]) ||       // Possible IPv4 or IPv6 address
                        hostName.IndexOf(':') != -1) {     // Probable IPv6 address

                        try {
                            //
                            // Use IPAddress.Parse here - we'd need to copy too much
                            // code for a call to WSAStringToAddress.
                            //
                            IPAddress   address     = IPAddress.Parse(hostName);

                            IPHostEntry ipHostEntry = new IPHostEntry();
                            ipHostEntry.HostName    = hostName;
                            ipHostEntry.Aliases     = new string[0];
                            ipHostEntry.AddressList = new IPAddress[] { address };

                            GlobalLog.Print("Dns::InternalResolve() returned address:" + address.ToString());

                            return ipHostEntry;
                        }
                        catch {
                            //
                            // Invalid address string, fall through to DNS lookup
                            //
                            GlobalLog.Print("Dns::InternalResolve() parse address failed: " + hostName + " doing name resolution");
                        }
                    }

                    //
                    // Looks like a hostname (or failed address parsing)
                    //
                    try
                    {
                        return GetAddrInfo(hostName);
                    }
                    catch ( Exception ex )
                    {
                        GlobalLog.Print("Dns::InternalResolve() GetAddrInfo() threw: " + ex.Message);
                    }
                }
                else {
                    //
                    // IPv4-only branch.
                    //
                    if (Char.IsDigit(hostName[0])) {
                        int address = UnsafeNclNativeMethods.OSSOCK.inet_addr(hostName);
                        if (address != -1 || hostName == IPAddress.InaddrNoneString) {
                            //
                            // the call to inet_addr() succeeded
                            //
                            IPHostEntry ipHostEntry = new IPHostEntry();
                            ipHostEntry.HostName    = hostName;
                            ipHostEntry.Aliases     = new string[0];
                            ipHostEntry.AddressList = new IPAddress[] {new IPAddress(address)};

                            GlobalLog.Print("Dns::InternalResolve() returned address:" + address.ToString());
                            return ipHostEntry;
                        }
                    }

                    //
                    // we duplicate the code in GetHostByName() to avoid
                    // having to catch the thrown exception
                    //
                    IntPtr nativePointer = UnsafeNclNativeMethods.OSSOCK.gethostbyname(hostName);
                    if (nativePointer != IntPtr.Zero) {
                        GlobalLog.Print("Dns::InternalResolve() gethostbyname() returned nativePointer:" + nativePointer.ToString());
                        return NativeToHostEntry(nativePointer);
                    }
                }
            }

            GlobalLog.Print("Dns::InternalResolve() returning null");
            return null;
        }


        //
        // A note on the use of delegates for the follwoign Async APIs.
        // The concern is that a worker thread would be blocked if an
        // exception is thrown by the method that we delegate execution to.
        // We're actually guaranteed that the exception is caught and returned to
        // the user by the subsequent EndInvoke call.
        // This delegate async execution is something that the C# compiler and the EE
        // will manage, talk to JHawk for more details on what exactly happens.
        //
        private delegate IPHostEntry GetHostByNameDelegate(string hostName);
        private static GetHostByNameDelegate getHostByName = new GetHostByNameDelegate(Dns.GetHostByName);

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.BeginGetHostByName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static IAsyncResult BeginGetHostByName(string hostName, AsyncCallback requestCallback, object stateObject) {
            //
            // demand Unrestricted DnsPermission for this call
            //
            s_DnsPermission.Demand();

            if (hostName == null) {
                throw new ArgumentNullException("hostName");
            }

            GlobalLog.Print("Dns.BeginGetHostByName: " + hostName);

            return getHostByName.BeginInvoke(hostName, requestCallback, stateObject);

        } // BeginGetHostByName

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.EndGetHostByName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static IPHostEntry EndGetHostByName(IAsyncResult asyncResult) {
            //
            // parameter validation
            //
            if (asyncResult == null) {
                throw new ArgumentNullException("asyncResult");
            }

            GlobalLog.Print("Dns.EndGetHostByName");

            if (!asyncResult.IsCompleted) {
                asyncResult.AsyncWaitHandle.WaitOne();
            }
            return getHostByName.EndInvoke(asyncResult);

        } // EndGetHostByName()


        private delegate IPHostEntry ResolveDelegate(string hostName);
        private static ResolveDelegate resolve = new ResolveDelegate(Dns.Resolve);

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.BeginResolve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static IAsyncResult BeginResolve(string hostName, AsyncCallback requestCallback, object stateObject) {
            //
            // demand Unrestricted DnsPermission for this call
            //
            s_DnsPermission.Demand();

            if (hostName == null) {
                throw new ArgumentNullException("hostName");
            }

            GlobalLog.Print("Dns.BeginResolve: " + hostName);

            return resolve.BeginInvoke(hostName, requestCallback, stateObject);

        } // BeginResolve

        /// <include file='doc\DNS.uex' path='docs/doc[@for="Dns.EndResolve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static IPHostEntry EndResolve(IAsyncResult asyncResult) {
            //
            // parameter validation
            //
            if (asyncResult == null) {
                throw new ArgumentNullException("asyncResult");
            }

            GlobalLog.Print("Dns.EndResolve");

            if (!asyncResult.IsCompleted) {
                asyncResult.AsyncWaitHandle.WaitOne();
            }
            return resolve.EndInvoke(asyncResult);

        } // EndResolve()


        //
        // IPv6 Changes: Add getaddrinfo and getnameinfo methods.
        //
        private static IPHostEntry GetAddrInfo(string name) {
            //
            // Use SocketException here to show operation not supported
            // if, by some nefarious means, this method is called on an
            // unsupported platform.
            //
            if ( !ComNetOS.IsPostWin2K ) {
                throw new SocketException(SocketErrors.WSAEOPNOTSUPP);
            }

            IntPtr      root           = IntPtr.Zero;
            ArrayList   addresses      = new ArrayList();
            IntPtr      info_ptr       = IntPtr.Zero; 
            string      canonicalname  = null;
            AddressInfo hints = new AddressInfo();

            hints.ai_flags     = (int)AddressInfoHints.AI_CANONNAME;// gets the resolved name
            hints.ai_family    = (int)ProtocolFamily.Unspecified;   // gets all address families
            hints.ai_socktype  = 0;
            hints.ai_protocol  = 0;
            hints.ai_canonname = null;
            hints.ai_addr      = IntPtr.Zero;
            hints.ai_next      = IntPtr.Zero;

            //
            // Use try / finally so we always get a shot at freeaddrinfo
            //
            try {
                int errorCode  = UnsafeNclNativeMethods.OSSOCK.getaddrinfo(name,null,ref hints,ref root);

                if ( errorCode != 0 ) {
                    throw new SocketException();
                }

                info_ptr = root;
                //
                // Process the results
                //
                while ( info_ptr != IntPtr.Zero ) {
                    AddressInfo   addressinfo = (AddressInfo)Marshal.PtrToStructure(info_ptr, typeof(AddressInfo));
                    SocketAddress sockaddr;
                    //
                    // Retrieve the canonical name for the host - only appears in the first addressinfo
                    // entry in the returned array.
                    //
                    if ( addressinfo.ai_canonname != null ) {
                        canonicalname = addressinfo.ai_canonname;
                    }
                    //
                    // Only process IPv4 or IPv6 Addresses. Note that it's unlikely that we'll
                    // ever get any other address families, but better to be safe than sorry.
                    // We also filter based on whether IPv4 and IPv6 are supported on the current
                    // platform / machine.
                    //
                    if ( ( addressinfo.ai_family == (int)AddressFamily.InterNetwork   && Socket.SupportsIPv4 ) ||
                         ( addressinfo.ai_family == (int)AddressFamily.InterNetworkV6 && Socket.SupportsIPv6 ) )
                    {
                        sockaddr = new SocketAddress((AddressFamily)addressinfo.ai_family,addressinfo.ai_addrlen);
                        //
                        // Push address data into the socket address buffer
                        //
                        for ( int d = 0,s = addressinfo.ai_addr.ToInt32(); d < addressinfo.ai_addrlen; d++,s++) {
                            sockaddr.m_Buffer[d] = Marshal.ReadByte((IntPtr)s);
                        }
                        //
                        // NOTE: We need an IPAddress now, the only way to create it from a
                        //       SocketAddress is via IPEndPoint. This ought to be simpler.
                        //
                        if ( addressinfo.ai_family == (int)AddressFamily.InterNetwork )
                            addresses.Add( ((IPEndPoint)IPEndPoint.Any.Create(sockaddr)).Address );
                        else
                            addresses.Add( ((IPEndPoint)IPEndPoint.IPv6Any.Create(sockaddr)).Address );
                    }
                    //
                    // Next addressinfo entry
                    //
                    info_ptr = addressinfo.ai_next;
                }
            }
            finally {
                //
                // Clean up
                //
                if ( root != IntPtr.Zero ) {
                    UnsafeNclNativeMethods.OSSOCK.freeaddrinfo(root);
                }
            }
            
            //
            // Finally, put together the IPHostEntry
            //
            IPHostEntry hostinfo = new IPHostEntry();

            hostinfo.HostName    = (canonicalname != null) ? canonicalname : name;
            hostinfo.Aliases     = new string[0];
            hostinfo.AddressList = new IPAddress[addresses.Count];

            addresses.CopyTo(hostinfo.AddressList);

            return hostinfo;
        }

        private static string GetNameInfo(IPAddress addr) {
            //
            // Use SocketException here to show operation not supported
            // if, by some nefarious means, this method is called on an
            // unsupported platform.
            //
            if ( !ComNetOS.IsPostWin2K ) {
                throw new SocketException(SocketErrors.WSAEOPNOTSUPP);
            }

            SocketAddress address  = (new IPEndPoint(addr,0)).Serialize();
            StringBuilder hostname = new StringBuilder(1025);        // NI_MAXHOST

            int errorcode = UnsafeNclNativeMethods.OSSOCK.getnameinfo(
                address.m_Buffer,
                address.m_Size,
                hostname,
                hostname.Capacity,
                null,                  // We don't want a service name
                0,                     // so no need for buffer or length
                (int)NameInfoFlags.NI_NAMEREQD);

            if ( errorcode != 0 ) {
                throw new SocketException();
            }

            return hostname.ToString();
        }
        //
        // End IPv6 Changes
        //


    }; // class Dns


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\dnspermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="DnsPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Security;
    using System.Security.Permissions;
    using System.Globalization;
    
    //NOTE: While DnsPermissionAttribute resides in System.DLL,
    //      no classes from that DLL are able to make declarative usage of DnsPermission.

     /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermissionAttribute"]/*' />
    [   AttributeUsage( AttributeTargets.Method | AttributeTargets.Constructor |
                        AttributeTargets.Class  | AttributeTargets.Struct      |
                        AttributeTargets.Assembly,
                        AllowMultiple = true, Inherited = false )]

    [Serializable()] sealed public class DnsPermissionAttribute : CodeAccessSecurityAttribute
    {
        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermissionAttribute.DnsPermissionAttribute"]/*' />
        public DnsPermissionAttribute ( SecurityAction action ): base( action )
        {
        }

        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            if (Unrestricted) {
                return new DnsPermission( PermissionState.Unrestricted);
            }
            else {
                return new DnsPermission( PermissionState.None);
            }
        }
    }


    /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission"]/*' />
    /// <devdoc>
    ///    <para>
    ///    </para>
    /// </devdoc>
    [Serializable]
    public sealed class DnsPermission :  CodeAccessPermission, IUnrestrictedPermission {

        private bool                    m_noRestriction;

        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission.DnsPermission"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.DnsPermission'/>
        ///       class that passes all demands or that fails all demands.
        ///    </para>
        /// </devdoc>
        public DnsPermission(PermissionState state) {
            m_noRestriction = (state==PermissionState.Unrestricted);
        }

        internal DnsPermission(bool free) {
            m_noRestriction = free;
        }

        // IUnrestrictedPermission interface methods
        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission.IsUnrestricted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Checks the overall permission state of the object.
        ///    </para>
        /// </devdoc>
        public bool IsUnrestricted() {
            return m_noRestriction;
        }

        // IPermission interface methods
        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission.Copy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a copy of a <see cref='System.Net.DnsPermission'/> instance.
        ///    </para>
        /// </devdoc>
        public override IPermission Copy () {
            return new DnsPermission(m_noRestriction);
        }

        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission.Union"]/*' />
        /// <devdoc>
        /// <para>Returns the logical union between two <see cref='System.Net.DnsPermission'/> instances.</para>
        /// </devdoc>
        public override IPermission Union(IPermission target) {
            // Pattern suggested by Security engine
            if (target==null) {
                return this.Copy();
            }
            DnsPermission other = target as DnsPermission;
            if(other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }
            return new DnsPermission(m_noRestriction || other.m_noRestriction);
        }

        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission.Intersect"]/*' />
        /// <devdoc>
        /// <para>Returns the logical intersection between two <see cref='System.Net.DnsPermission'/> instances.</para>
        /// </devdoc>
        public override IPermission Intersect(IPermission target) {
            // Pattern suggested by Security engine
            if (target==null) {
                return null;
            }
            DnsPermission other = target as DnsPermission;
            if(other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }

            // return null if resulting permission is restricted and empty
            // Hence, the only way for a bool permission will be.
            if (this.m_noRestriction && other.m_noRestriction) {
                return new DnsPermission(true);
            }
            return null;
        }


        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission.IsSubsetOf"]/*' />
        /// <devdoc>
        /// <para>Compares two <see cref='System.Net.DnsPermission'/> instances.</para>
        /// </devdoc>
        public override bool IsSubsetOf(IPermission target) {
            // Pattern suggested by Security engine
            if (target == null) {
                return m_noRestriction == false;
            }
            DnsPermission other = target as DnsPermission;
            if (other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }
            //Here is the matrix of result based on m_noRestriction for me and she
            //    me.noRestriction      she.noRestriction   me.isSubsetOf(she)
            //                  0       0                   1
            //                  0       1                   1
            //                  1       0                   0
            //                  1       1                   1
            return (!m_noRestriction || other.m_noRestriction);
        }

        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission.FromXml"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override void FromXml(SecurityElement securityElement) {

            if (securityElement == null)
            {
                //
                // null SecurityElement
                //

                throw new ArgumentNullException("securityElement");
            }

            if (!securityElement.Tag.Equals("IPermission"))
            {
                //
                // SecurityElement must be a permission element
                //

                throw new ArgumentException("securityElement");
            }

            string className = securityElement.Attribute( "class" );

            if (className == null)
            {
                //
                // SecurityElement must be a permission element for this type
                //

                throw new ArgumentException("securityElement");
            }


            if (className.IndexOf( this.GetType().FullName ) < 0)
            {
                //
                // SecurityElement must be a permission element for this type
                //

                throw new ArgumentException("securityElement");
            }

            string str = securityElement.Attribute( "Unrestricted" );
            m_noRestriction = (str!=null?(0 == string.Compare( str, "true", true, CultureInfo.InvariantCulture)):false);
        }

        /// <include file='doc\DnsPermission.uex' path='docs/doc[@for="DnsPermission.ToXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override SecurityElement ToXml() {

            SecurityElement securityElement = new SecurityElement( "IPermission" );

            securityElement.AddAttribute( "class", this.GetType().FullName + ", " + this.GetType().Module.Assembly.FullName.Replace( '\"', '\'' ) );
            securityElement.AddAttribute( "version", "1" );

            if (m_noRestriction) {
                securityElement.AddAttribute( "Unrestricted", "true" );
            }

            return securityElement;
        }

    } // class DnsPermission


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\filewebrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="filewebrequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.IO;
    using System.Runtime.Serialization;
    using System.Threading;

    /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest"]/*' />
    [Serializable]
    public class FileWebRequest : WebRequest, ISerializable {

        delegate Stream AsyncGetRequestStream();
        delegate WebResponse AsyncGetResponse();

    // fields

        string m_connectionGroupName;
        long m_contentLength;
        ICredentials m_credentials;
        FileAccess m_fileAccess;
        AsyncGetRequestStream m_GetRequestStreamDelegate;
        AsyncGetResponse m_GetResponseDelegate;
        WebHeaderCollection m_headers;
        string m_method = "GET";
        bool m_preauthenticate;
        IWebProxy m_proxy;
        AutoResetEvent m_readerEvent;
        bool m_readPending;
        WebResponse m_response;
        Stream m_stream;
        bool m_syncHint;
        int m_timeout = WebRequest.DefaultTimeout;
        Uri m_uri;
        bool m_writePending;
        bool m_writing;

    // constructors

         internal FileWebRequest(Uri uri) {
            m_uri = uri;
            m_fileAccess = FileAccess.Read;
            m_headers = new WebHeaderCollection();
        }


        //
        // ISerializable constructor
        //
        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.FileWebRequest"]/*' />
        protected FileWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            m_headers               = (WebHeaderCollection)serializationInfo.GetValue("headers", typeof(WebHeaderCollection));
            m_proxy                 = (IWebProxy)serializationInfo.GetValue("proxy", typeof(IWebProxy));
            m_uri                   = (Uri)serializationInfo.GetValue("uri", typeof(Uri));
            m_connectionGroupName   = serializationInfo.GetString("connectionGroupName");
            m_method                = serializationInfo.GetString("method");
            m_contentLength         = serializationInfo.GetInt64("contentLength");
            m_timeout               = serializationInfo.GetInt32("timeout");
            m_fileAccess            = (FileAccess )serializationInfo.GetInt32("fileAccess");
            m_preauthenticate       = serializationInfo.GetBoolean("preauthenticate");
        }

        //
        // ISerializable method
        //
        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            serializationInfo.AddValue("headers", m_headers, typeof(WebHeaderCollection));
            serializationInfo.AddValue("proxy", m_proxy, typeof(IWebProxy));
            serializationInfo.AddValue("uri", m_uri, typeof(Uri));
            serializationInfo.AddValue("connectionGroupName", m_connectionGroupName);
            serializationInfo.AddValue("method", m_method);
            serializationInfo.AddValue("contentLength", m_contentLength);
            serializationInfo.AddValue("timeout", m_timeout);
            serializationInfo.AddValue("fileAccess", m_fileAccess);
            serializationInfo.AddValue("preauthenticate", m_preauthenticate);
        }


    // properties

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.ConnectionGroupName"]/*' />
        public override string ConnectionGroupName {
            get {
                return m_connectionGroupName;
            }
            set {
                m_connectionGroupName = value;
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.ContentLength"]/*' />
        public override long ContentLength {
            get {
                return m_contentLength;
            }
            set {
                if (value < 0) {
                    throw new ArgumentException("value");
                }
                m_contentLength = value;
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.ContentType"]/*' />
        public override string ContentType {
            get {
                return m_headers["Content-Type"];
            }
            set {
                m_headers["Content-Type"] = value;
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.Credentials"]/*' />
        public override ICredentials Credentials {
            get {
                return m_credentials;
            }
            set {
                m_credentials = value;
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.Headers"]/*' />
        public override WebHeaderCollection Headers {
            get {
                return m_headers;
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.Method"]/*' />
        public override string Method {
            get {
                return m_method;
            }
            set {
                if (ValidationHelper.IsBlankString(value)) {
                    throw new ArgumentException(SR.GetString(SR.net_badmethod));
                }
                m_method = value;       
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.PreAuthenticate"]/*' />
        public override bool PreAuthenticate {
            get {
                return m_preauthenticate;
            }
            set {
                m_preauthenticate = true;
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.RequestUri"]/*' />
        public override IWebProxy Proxy {
            get {
                return m_proxy;
            }
            set {
                m_proxy = value;
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.Timeout"]/*' />
        //UEUE changed default from infinite to 100 seconds
        public override int Timeout {
            get {
                return m_timeout;
            }
            set {
                if ((value < 0) && (value != System.Threading.Timeout.Infinite)) {
                    throw new ArgumentOutOfRangeException("value");
                }
                m_timeout = value;
            }
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.RequestUri1"]/*' />
        public override Uri RequestUri {
            get {
                return m_uri;
            }
        }

    // methods

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.BeginGetRequestStream"]/*' />
        public override IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state) {
            GlobalLog.Enter("FileWebRequest::BeginGetRequestStream");
            if (!CanGetRequestStream()) {
                Exception e = new ProtocolViolationException(SR.GetString(SR.net_nouploadonget));
                GlobalLog.LeaveException("FileWebRequest::BeginGetRequestStream", e);
                throw e;
            }
            if (m_response != null) {
                Exception e = new InvalidOperationException(SR.GetString(SR.net_reqsubmitted));
                GlobalLog.LeaveException("FileWebRequest::BeginGetRequestStream", e);
                throw e;
            }
            lock(this) {
                if (m_writePending) {
                    Exception e = new InvalidOperationException(SR.GetString(SR.net_repcall));
                    GlobalLog.LeaveException("FileWebRequest::BeginGetRequestStream", e);
                    throw e;
                }
                m_writePending = true;
            }
            m_GetRequestStreamDelegate = new AsyncGetRequestStream(InternalGetRequestStream);
            GlobalLog.Leave("FileWebRequest::BeginGetRequestStream");
            return m_GetRequestStreamDelegate.BeginInvoke(callback, state);
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.BeginGetResponse"]/*' />
        public override IAsyncResult BeginGetResponse(AsyncCallback callback, object state) {
            GlobalLog.Enter("FileWebRequest::BeginGetResponse");
            lock(this) {
                if (m_readPending) {
                    Exception e = new InvalidOperationException(SR.GetString(SR.net_repcall));
                    GlobalLog.LeaveException("FileWebRequest::BeginGetResponse", e);
                    throw e;
                }
                m_readPending = true;
            }
            m_GetResponseDelegate = new AsyncGetResponse(InternalGetResponse);
            GlobalLog.Leave("FileWebRequest::BeginGetResponse");
            return m_GetResponseDelegate.BeginInvoke(callback, state);
        }

        private bool CanGetRequestStream() {
            return !KnownVerbs.GetHttpVerbType(m_method).m_ContentBodyNotAllowed;
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.EndGetRequestStream"]/*' />
        public override Stream EndGetRequestStream(IAsyncResult asyncResult) {
            GlobalLog.Enter("FileWebRequest::EndGetRequestStream");
            if (asyncResult == null) {
                Exception e = new ArgumentNullException("asyncResult");
                GlobalLog.LeaveException("FileWebRequest::EndGetRequestStream", e);
                throw e;
            }
            if (!asyncResult.IsCompleted) {
                asyncResult.AsyncWaitHandle.WaitOne();
            }

            Stream stream = m_GetRequestStreamDelegate.EndInvoke(asyncResult);

            m_writePending = false;
            GlobalLog.Leave("FileWebRequest::EndGetRequestStream");
            return stream;
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.EndGetResponse"]/*' />
        public override WebResponse EndGetResponse(IAsyncResult asyncResult) {
            GlobalLog.Enter("FileWebRequest::EndGetResponse");
            if (asyncResult == null) {
                Exception e = new ArgumentNullException("asyncResult");
                GlobalLog.LeaveException("FileWebRequest::EndGetResponse", e);
                throw e;
            }
            if (!asyncResult.IsCompleted) {
                asyncResult.AsyncWaitHandle.WaitOne();
            }

            WebResponse response = m_GetResponseDelegate.EndInvoke(asyncResult);

            m_readPending = false;
            GlobalLog.Leave("FileWebRequest::EndGetResponse");
            return response;
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.GetRequestStream"]/*' />
        public override Stream GetRequestStream() {
            GlobalLog.Enter("FileWebRequest::GetRequestStream");

            IAsyncResult result = BeginGetRequestStream(null, null);

            if ((Timeout != System.Threading.Timeout.Infinite) && !result.IsCompleted) {
                if (!result.AsyncWaitHandle.WaitOne(Timeout, false) || !result.IsCompleted) {
                    if (m_stream != null) {
                        m_stream.Close();
                    }
                    Exception e = new WebException(SR.GetString(SR.net_timeout), WebExceptionStatus.Timeout);
                    GlobalLog.LeaveException("FileWebRequest::GetRequestStream", e);
                    throw e;
                }
            }
            GlobalLog.Leave("FileWebRequest::GetRequestStream");
            return EndGetRequestStream(result);
        }

        /// <include file='doc\filewebrequest.uex' path='docs/doc[@for="FileWebRequest.GetResponse"]/*' />
        public override WebResponse GetResponse() {
            GlobalLog.Enter("FileWebRequest::GetResponse");
            m_syncHint = true;

            IAsyncResult result = BeginGetResponse(null, null);

            if ((Timeout != System.Threading.Timeout.Infinite) && !result.IsCompleted) {
                if (!result.AsyncWaitHandle.WaitOne(Timeout, false) || !result.IsCompleted) {
                    if (m_response != null) {
                        m_response.Close();
                    }
                    Exception e = new WebException(SR.GetString(SR.net_timeout), WebExceptionStatus.Timeout);
                    GlobalLog.LeaveException("FileWebRequest::GetResponse", e);
                    throw e;
                }
            }
            GlobalLog.Leave("FileWebRequest::GetResponse");
            return EndGetResponse(result);
        }

        private Stream InternalGetRequestStream() {
            GlobalLog.Enter("FileWebRequest::InternalGetRequestStream");
            try {
                if (m_stream == null) {
                    m_stream = new FileWebStream(this,
                                                 m_uri.LocalPath,
                                                 FileMode.Create,
                                                 FileAccess.Write,
                                                 FileShare.Read
                                                 );
                    m_fileAccess = FileAccess.Write;
                    m_writing = true;
                }
            } catch (Exception e) {
                Exception ex = new WebException(e.Message, e);
                GlobalLog.LeaveException("FileWebRequest::InternalGetRequestStream", ex);
                throw ex;
            }
            GlobalLog.Leave("FileWebRequest::InternalGetRequestStream");
            return m_stream;
        }

        private WebResponse InternalGetResponse() {
            GlobalLog.Enter("FileWebRequest::InternalGetResponse");
            if (m_writePending || m_writing) {
                lock(this) {
                    if (m_writePending || m_writing) {
                        m_readerEvent = new AutoResetEvent(false);
                    }
                }
            }
            if (m_readerEvent != null) {
                m_readerEvent.WaitOne();
            }
            if (m_response == null) {
                m_response = new FileWebResponse(m_uri, m_fileAccess, !m_syncHint);
            }
            GlobalLog.Leave("FileWebRequest::InternalGetResponse");
            return m_response;
        }

        internal void UnblockReader() {
            GlobalLog.Enter("FileWebRequest::UnblockReader");
            lock(this) {
                if (m_readerEvent != null) {
                    m_readerEvent.Set();
                }
            }
            m_writing = false;
            GlobalLog.Leave("FileWebRequest::UnblockReader");
        }
    }

    internal class FileWebRequestCreator : IWebRequestCreate {

        internal FileWebRequestCreator() {
        }

        public WebRequest Create(Uri uri) {
            return new FileWebRequest(uri);
        }
    }

    internal class FileWebStream : FileStream {

        FileWebRequest m_request;

        public FileWebStream(FileWebRequest request,
                             string path,
                             FileMode mode,
                             FileAccess access,
                             FileShare sharing
                             ) : base(path,
                                      mode,
                                      access,
                                      sharing
                                      )
        {
            GlobalLog.Enter("FileWebStream::FileWebStream");
            m_request = request;
            GlobalLog.Leave("FileWebStream::FileWebStream");
        }

        public FileWebStream(string path,
                             FileMode mode,
                             FileAccess access,
                             FileShare sharing,
                             int length,
                             bool async
                             ) : base(path,
                                      mode,
                                      access,
                                      sharing,
                                      length,
                                      async
                                      )
        {
            GlobalLog.Enter("FileWebStream::FileWebStream");
            GlobalLog.Leave("FileWebStream::FileWebStream");
        }

        public override void Close() {
            GlobalLog.Enter("FileWebStream::Close");
            if (m_request != null) {
                m_request.UnblockReader();
            }
            base.Close();
            GlobalLog.Leave("FileWebStream::Close");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\endpoint.cs ===
//------------------------------------------------------------------------------
// <copyright file="EndPoint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using System.Net.Sockets;

namespace System.Net {

    // Generic abstraction to identify network addresses

    /// <include file='doc\EndPoint.uex' path='docs/doc[@for="EndPoint"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Identifies a network address.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public abstract class EndPoint {
        /// <include file='doc\EndPoint.uex' path='docs/doc[@for="EndPoint.AddressFamily"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the Address Family to which the EndPoint belongs.
        ///    </para>
        /// </devdoc>

        public virtual AddressFamily AddressFamily {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        /// <include file='doc\EndPoint.uex' path='docs/doc[@for="EndPoint.Serialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Serializes EndPoint information into a SocketAddress structure.
        ///    </para>
        /// </devdoc>
        public virtual SocketAddress Serialize() {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        /// <include file='doc\EndPoint.uex' path='docs/doc[@for="EndPoint.Create"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an EndPoint instance from a SocketAddress structure.
        ///    </para>
        /// </devdoc>
        public virtual EndPoint Create(SocketAddress socketAddress) {
            throw ExceptionHelper.MethodNotImplementedException;
        }

    }; // abstract class EndPoint


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\globalproxyselection.cs ===
//------------------------------------------------------------------------------
// <copyright file="GlobalProxySelection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Configuration;
    using System.Security.Permissions;

    internal class DefaultProxyHandlerWrapper { 
        internal DefaultProxyHandlerWrapper(IWebProxy webProxy) {
            this.WebProxy = webProxy;
        }
        internal IWebProxy WebProxy; 
    }



    //
    // This is the class where the assignment overrides
    //   needs to happen, stores the generic
    //

    /// <include file='doc\GlobalProxySelection.uex' path='docs/doc[@for="GlobalProxySelection"]/*' />
    /// <devdoc>
    /// <para>Contains a global proxy
    /// instance that is called on every request.</para>
    /// </devdoc>
    public class GlobalProxySelection {

        private static IWebProxy s_IWebProxy;        

        /// <include file='doc\GlobalProxySelection.uex' path='docs/doc[@for="GlobalProxySelection.Select"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Contains the global proxy object.
        ///    </para>
        /// </devdoc>
        public static IWebProxy Select {
            get {
                (new WebPermission(PermissionState.Unrestricted)).Demand();
                return SelectInternal;
            }
            set {
                (new WebPermission(PermissionState.Unrestricted)).Demand();
                SelectInternal=value;
            }
        }

        /// <include file='doc\GlobalProxySelection.uex' path='docs/doc[@for="GlobalProxySelection.GetEmptyWebProxy"]/*' />
        public static IWebProxy GetEmptyWebProxy() {
            return new EmptyWebProxy();
        }

        internal static IWebProxy SelectInternal {
            get {
                if (s_IWebProxy==null) {
                    lock (typeof(GlobalProxySelection)) {
                        if (s_IWebProxy==null) {
                            GlobalLog.Print("GlobalProxySelection::Initialize(): calling ConfigurationSettings.GetConfig()");
                            IWebProxy webProxy = null;
                            DefaultProxyHandlerWrapper wrapper = 
                                ConfigurationSettings.GetConfig("system.net/defaultProxy") as DefaultProxyHandlerWrapper;
                            if (wrapper!=null) {
                                webProxy = wrapper.WebProxy;
                            }

                            if (webProxy == null) {
                                GlobalLog.Print("GlobalProxySelection::Initialize(): creating default settings");
                                webProxy = new EmptyWebProxy();
                            }
                            s_IWebProxy = webProxy;                    
                        }
                    }
                }
                return s_IWebProxy;
            }
            set {
                lock(typeof(GlobalProxySelection)) {
                    if ( value == null ) {
                        throw new
                            ArgumentNullException ("GlobalProxySelection.Select",
                                SR.GetString(SR.net_nullproxynotallowed));
                    }
                    s_IWebProxy = value;
                }
            }
        }
    } // class GlobalProxySelection


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\filewebresponse.cs ===
//------------------------------------------------------------------------------
// <copyright file="filewebresponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Runtime.Serialization;
    using System.IO;

    /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse"]/*' />
    [Serializable]
    public class FileWebResponse : WebResponse, ISerializable, IDisposable {

        const int DefaultFileStreamBufferSize = 8192;
        const string DefaultFileContentType = "application/octet-stream";

    // fields

        bool m_closed;
        long m_contentLength;
        bool m_disposed;
        FileAccess m_fileAccess;
        WebHeaderCollection m_headers;
        Stream m_stream;
        Uri m_uri;

    // constructors

        internal FileWebResponse(Uri uri, FileAccess access, bool asyncHint) {
            GlobalLog.Enter("FileWebResponse::FileWebResponse", "uri="+uri+", access="+access+", asyncHint="+asyncHint);
            try {
                m_fileAccess = access;
                if (access == FileAccess.Write) {
                    m_stream = Stream.Null;
                } else {

                    //
                    // apparently, specifying async when the stream will be read
                    // synchronously, or vice versa, can lead to a 10x perf hit.
                    // While we don't know how the app will read the stream, we
                    // use the hint from whether the app called BeginGetResponse
                    // or GetResponse to supply the async flag to the stream ctor
                    //

                    m_stream = new FileWebStream(uri.LocalPath,
                                                 FileMode.Open,
                                                 FileAccess.Read,
                                                 FileShare.Read,
                                                 DefaultFileStreamBufferSize,
                                                 asyncHint
                                                 );
                    m_contentLength = m_stream.Length;
                }
                m_headers = new WebHeaderCollection();
                m_headers.AddInternal(HttpKnownHeaderNames.ContentLength, m_contentLength.ToString());
                m_headers.AddInternal(HttpKnownHeaderNames.ContentType, DefaultFileContentType);
                m_uri = uri;
            } catch (Exception e) {
                Exception ex = new WebException(e.Message, e, WebExceptionStatus.ConnectFailure, null);
                GlobalLog.LeaveException("FileWebResponse::FileWebResponse", ex);
                throw ex;
            }
            GlobalLog.Leave("FileWebResponse::FileWebResponse");
        }

        //
        // ISerializable constructor
        //
        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.FileWebResponse"]/*' />
        protected FileWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            m_headers               = (WebHeaderCollection)serializationInfo.GetValue("headers", typeof(WebHeaderCollection));
            m_uri                   = (Uri)serializationInfo.GetValue("uri", typeof(Uri));
            m_contentLength         = serializationInfo.GetInt64("contentLength");
            m_fileAccess            = (FileAccess )serializationInfo.GetInt32("fileAccess");
        }

        //
        // ISerializable method
        //
        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            serializationInfo.AddValue("headers", m_headers, typeof(WebHeaderCollection));
            serializationInfo.AddValue("uri", m_uri, typeof(Uri));
            serializationInfo.AddValue("contentLength", m_contentLength);
            serializationInfo.AddValue("fileAccess", m_fileAccess);
        }

    // properties

        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.ContentLength"]/*' />
        public override long ContentLength {
            get {
                CheckDisposed();
                return m_contentLength;
            }
        }

        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.ContentType"]/*' />
        public override string ContentType {
            get {
                CheckDisposed();
                return DefaultFileContentType;
            }
        }

        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.Headers"]/*' />
        public override WebHeaderCollection Headers {
            get {
                CheckDisposed();
                return m_headers;
            }
        }

        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.ResponseUri"]/*' />
        public override Uri ResponseUri {
            get {
                CheckDisposed();
                return m_uri;
            }
        }

    // methods

        private void CheckDisposed() {
            if (m_disposed) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
        }

        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.Close"]/*' />
        public override void Close() {
            GlobalLog.Enter("FileWebResponse::Close()");
            if (!m_closed) {
                m_closed = true;
                Stream chkStream = m_stream;
                if (chkStream!=null) {
                    chkStream.Close();
                    m_stream = null;
                }
            }
            GlobalLog.Leave("FileWebResponse::Close()");
        }

        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.GetResponseStream"]/*' />
        public override Stream GetResponseStream() {
            GlobalLog.Enter("FileWebResponse::GetResponseStream()");
            CheckDisposed();
            GlobalLog.Leave("FileWebResponse::GetResponseStream()");
            return m_stream;
        }

        //
        // IDisposable
        //

        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            GlobalLog.Enter("FileWebResponse::Dispose");
            Dispose(true);
            GC.SuppressFinalize(this);
            GlobalLog.Leave("FileWebResponse::Dispose");
        }

        /// <include file='doc\filewebresponse.uex' path='docs/doc[@for="FileWebResponse.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            GlobalLog.Enter("FileWebResponse::Dispose", "disposing="+disposing);
            if (!m_disposed) {
                m_disposed = true;
                if (disposing) {
                    Close();
                    m_headers = null;
                    m_uri = null;
                }
            }
            GlobalLog.Leave("FileWebResponse::Dispose");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httplistenerwebrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpListenerWebRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if COMNET_LISTENER

namespace System.Net {

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Net;
    using System.Net.Sockets;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;


    /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class HttpListenerWebRequest : WebRequest {

        // it doesn't make sense to build a Request that is not
        // coming from the network, so the constructor is internal, since
        // the only way to create such an object is by calling GetRequest()

        internal HttpListenerWebRequest(
            IntPtr addrOfPinnedBuffer,
            int bufferSize,
            IntPtr appPoolHandle ) {

            IntPtr BaseOffset = ComNetOS.IsWinNt ? IntPtr.Zero : addrOfPinnedBuffer;

            //
            // copy unmanaged pinned memory into a managed UL_HTTP_REQUEST
            // structure, and parse data into private members
            //

            UL_HTTP_REQUEST Request =
                (UL_HTTP_REQUEST)
                    Marshal.PtrToStructure( addrOfPinnedBuffer, typeof(UL_HTTP_REQUEST) );


            //
            // retrieve and save UL related stuff
            //

            m_AppPoolHandle = appPoolHandle;
            m_RequestId = Request.RequestId;

            GlobalLog.Print("HttpListenerWebRequest appPoolHandle:" + Convert.ToString(appPoolHandle) + " Request.RequestId:" + Convert.ToString(Request.RequestId) );


            //
            // retrieve and save HTTP related stuff
            //

            int tempIP;

            if (Request.pLocalAddress + 4 < addrOfPinnedBuffer + bufferSize) {
                tempIP = Marshal.ReadInt32( Request.pLocalAddress + BaseOffset );
                m_LocalIPAddress = new IPAddress( (int)
                                                  (((tempIP & 0xFF000000 ) >> 24 ) |
                                                   ((tempIP & 0x00FF0000 ) >>  8 ) |
                                                   ((tempIP & 0x0000FF00 ) <<  8 ) |
                                                   ((tempIP & 0x000000FF ) << 24 )) );
            }
            else {
                m_LocalIPAddress = new IPAddress( 0 );
            }

            if (Request.pRemoteAddress + 4 < addrOfPinnedBuffer + bufferSize) {
                tempIP = Marshal.ReadInt32( Request.pRemoteAddress + BaseOffset );
                m_RemoteIPAddress = new IPAddress( (int)
                                                   (((tempIP & 0xFF000000 ) >> 24 ) |
                                                    ((tempIP & 0x00FF0000 ) >>  8 ) |
                                                    ((tempIP & 0x0000FF00 ) <<  8 ) |
                                                    ((tempIP & 0x000000FF ) << 24 )) );
            }
            else {
                m_RemoteIPAddress = new IPAddress( 0 );
            }


            //
            // set the Uri
            // CODEWORK: the parser in UL already parses the Uri, take advantage
            // and to let the Uri object redo the work.
            //

            m_Uri = new Uri( Marshal.PtrToStringUni( Request.pFullUri + BaseOffset, Request.FullUriLength/2 ) );


            //
            // set the Verb
            //

            if (Request.Verb > (int)UL_HTTP_VERB.Enum.UlHttpVerbUnparsed && Request.Verb < (int)UL_HTTP_VERB.Enum.UlHttpVerbUnknown) {
                m_Method = UL_HTTP_VERB.ToString( Request.Verb );
            }
            else if (Request.Verb == (int)UL_HTTP_VERB.Enum.UlHttpVerbUnknown) {
                m_Method = Marshal.PtrToStringUni( Request.pUnknownVerb + BaseOffset, Request.UnknownVerbLength/2 );
            }
            else {
                throw new InvalidOperationException( "UlReceiveHttpRequest() sent bogus UL_HTTP_REQUEST.Verb" );
            }

            GlobalLog.Print("m_Method: " + m_Method );


            //
            // set the Known Headers ...
            //

            m_WebHeaders = new WebHeaderCollection();
            m_ContentLength = -1;

            int i, j;
            int NameLength, RawValueLength, pName, pRawValue;

            for (i = j = 0; i<40; i++,j+=2) {
                RawValueLength = Request.LengthValue[j];

                if (RawValueLength > 0) {
                    string HeaderValue = Marshal.PtrToStringUni( Request.LengthValue[j+1] + BaseOffset, RawValueLength/2 );

                    m_WebHeaders.AddInternal(
                                            UL_HTTP_REQUEST_HEADER_ID.ToString(i),
                                            HeaderValue  );

                    if (i == (int)UL_HTTP_REQUEST_HEADER_ID.Enum.UlHeaderContentLength) {
                        m_ContentLength = Convert.ToInt64( HeaderValue );
                    }

                    GlobalLog.Print("Known Headers: i: " + Convert.ToString(i) + " RawValueLength:" + Convert.ToString(RawValueLength) );
                }
            }

            //
            // ... and the Un-Known ones
            //

            IntPtr pUnknownHeaders = Request.pUnknownHeaders + BaseOffset;

            for (i = 0; i<Request.UnknownHeaderCount; i++, pUnknownHeaders += 16) {
                NameLength = Marshal.ReadInt32( pUnknownHeaders );
                pName = Marshal.ReadInt32( pUnknownHeaders + 4 );
                RawValueLength = (int)Marshal.ReadInt16( pUnknownHeaders + 8 );
                pRawValue = Marshal.ReadInt32( pUnknownHeaders + 12 );

                m_WebHeaders.AddInternal(
                                        Marshal.PtrToStringUni( pName + BaseOffset, NameLength/2 ),
                                        Marshal.PtrToStringUni( pRawValue + BaseOffset, RawValueLength/2 ) );
            }


            //
            // and finally stuff related to the headers (in a way)
            //

            //
            // set the Version and calc KeepAlive
            //

            if (Request.Version == (int)UL_HTTP_VERSION.Enum.UlHttpVersion09) {
                m_Version = new Version( 0, 9 );
                m_KeepAlive = false;
            }
            else if (Request.Version == (int)UL_HTTP_VERSION.Enum.UlHttpVersion10) {
                m_Version = new Version( 1, 0 );
                m_KeepAlive = m_WebHeaders[ HttpKnownHeaderNames.KeepAlive ] != null;
            }
            else if (Request.Version == (int)UL_HTTP_VERSION.Enum.UlHttpVersion11) {
                m_Version = new Version( 1, 1 );
                m_KeepAlive = Connection == null ? true : string.Compare( Connection, "keep-alive", true, CultureInfo.InvariantCulture) == 0;
            }
            else {
                throw new InvalidOperationException( "UlReceiveHttpRequest() sent bogus UL_HTTP_REQUEST.Version" );
            }

            GlobalLog.Print("Request unpacking is over, creating the ListenerRequestStream object" );

            m_RequestStream = new
                              ListenerRequestStream(
                                                   appPoolHandle,
                                                   m_RequestId,
                                                   m_ContentLength,
                                                   Request.EntityBodyLength,
                                                   Request.pEntityBody,
                                                   Request.MoreEntityBodyExists == 0 );

            GlobalLog.Print("HttpListenerWebRequest created. returning" );

            return;

        } // HttpListenerWebRequest

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.GetResponse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override WebResponse GetResponse() {
            //
            // check if the HttpListenerWebResponse was already handed to the user before
            //
            if (m_ListenerResponse==null) {
                //
                // if not created, create the HttpListenerWebResponse
                //
                m_ListenerResponse =
                    new HttpListenerWebResponse(
                        m_AppPoolHandle,
                        m_RequestId,
                        m_Version );
            }

            //
            // and return it to the user
            //
            return m_ListenerResponse;
        }



        //
        // properties that override form WebRequest
        //

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.GetRequestStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Stream GetRequestStream() {
            //
            // we don't need an async version of this method because
            // it's not a blocking call.
            //

            return m_RequestStream;
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.Method"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Method {
            get {
                return m_Method;
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.RequestUri"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Uri RequestUri {
            get {
                return m_Uri;
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override long ContentLength {
            get {
                return m_ContentLength;
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.ContentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ContentType {
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.ContentType ];
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.Headers"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override WebHeaderCollection Headers {
            get {
                return m_WebHeaders;
            }

        } // Headers

        //
        // properties that don't override
        //

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.ProtocolVersion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Version ProtocolVersion {
            get {
                return m_Version;
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.KeepAlive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool KeepAlive {
            get {
                return m_KeepAlive;
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.LocalIPAddress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IPAddress LocalIPAddress {
            get {
                return m_LocalIPAddress;
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.RemoteIPAddress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IPAddress RemoteIPAddress {
            get {
                return m_RemoteIPAddress;
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.Connection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Connection {
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.Connection ];
            }
        }

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.Accept"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Accept {
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.Accept ];
            }

        } // Accept

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.Referer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Referer {
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.Referer ];
            }

        } // Referer

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.UserAgent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string UserAgent {
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.UserAgent ];
            }

        } // UserAgent


        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.Expect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Expect {
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.Expect ];
            }

        } // Expect

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.IfModifiedSince"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime IfModifiedSince {
            get {
                string headerValue = m_WebHeaders[ HttpKnownHeaderNames.IfModifiedSince ];

                if (headerValue == null) {
                    return DateTime.Now;
                }

                return HttpProtocolUtils.string2date( headerValue );
            }

        } // IfModifiedSince

        /// <include file='doc\HttpListenerWebRequest.uex' path='docs/doc[@for="HttpListenerWebRequest.GetRequestHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetRequestHeader( string headerName ) {
            return m_WebHeaders[ headerName ];

        } // GetRequestHeader


        //
        // class members
        //

        //
        // HTTP related stuff (exposed as property)
        //

        private Uri m_Uri;
        private long m_ContentLength;
        private ListenerRequestStream m_RequestStream;
        private WebResponse m_ListenerResponse;
        private string m_Method;
        private bool m_KeepAlive;
        private Version m_Version;
        private WebHeaderCollection m_WebHeaders;
        private IPAddress m_LocalIPAddress;
        private IPAddress m_RemoteIPAddress;

        //
        // UL related stuff (may not be useful)
        //

        private long m_RequestId;
        private IntPtr m_AppPoolHandle;

    }; // class HttpListenerWebRequest


} // namespace System.Net

#endif // #if COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httplistenerwebresponse.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpListenerWebResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if COMNET_LISTENER

namespace System.Net {

    using System.Net.Sockets;
    using System.Collections;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Text;

    /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class HttpListenerWebResponse : WebResponse {

        internal HttpListenerWebResponse(
            IntPtr appPoolHandle,
            long requestId,
            Version clientVersion ) {

            m_RequestId = requestId;
            m_ReadyToSendHeaders = true;
            m_ResponseStream = null;
            m_AppPoolHandle = appPoolHandle;
            m_WebHeaders = new WebHeaderCollection();
            m_ContentLength = -1;
            m_ClientVersion = clientVersion;

            //
            // set default values
            //

            m_Status = HttpStatusCode.OK;
            m_StatusDescription = "Ok";
            m_Version = new Version(1,1);

            m_SendChunked = false;
            m_KeepAlive = true;

            return;
        }


        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.GetResponseStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Stream GetResponseStream() {
            GlobalLog.Print("entering GetResponseStream()" );

            //
            // check if the Stream was already handed to the user before
            //
            if (m_ResponseStream != null) {
                return m_ResponseStream;
            }

            //
            // CODEWORK: replace the bool variable with a check on the minimal
            // info that NEEDS to be set in a HTTP Response in order to send
            // the headers
            //
            if (m_StatusDescription == null || !m_ReadyToSendHeaders) {
                throw new InvalidOperationException(SR.GetString());
            }

            //
            // handing off the Stream object out of WebResponse, implies that
            // we're ready to send the response headers back to the client
            //

            int myFlags = 0;


            //
            // check ContentLength consistency
            //

            m_SendChunked = false;
            m_KeepAlive = true;

            if (m_ContentLength == -1) {
                //
                // server didn't specify response content length
                //

                if (m_ClientVersion.Major < 1 || ( m_ClientVersion.Major == 1 && m_ClientVersion.Minor < 1 )) {
                    //
                    // make sure there's no Keep-Alive header specified
                    //

                    m_WebHeaders.RemoveInternal(HttpKnownHeaderNames.KeepAlive);
                    m_KeepAlive = false;
                }
                else if (m_ClientVersion.Major == 1) {
                    //
                    // we need to chunk the response, regardless of what the
                    // user wanted to do
                    //

                    m_WebHeaders.AddInternal( HttpKnownHeaderNames.TransferEncoding, "chunked");

                    m_SendChunked = true;
                }
                else {
                    //
                    // this protocol version is not supported? ul should have
                    // responded with a 503
                    //

                    throw new ProtocolViolationException(SR.GetString(SR.net_invalidversion));
                }
            }
            else {
                m_WebHeaders.ChangeInternal( HttpKnownHeaderNames.ContentLength, Convert.ToString(m_ContentLength));

                myFlags = UlConstants.UL_SEND_RESPONSE_FLAG_MORE_DATA;
            }

            //
            // I'm going to make this REALLY inefficient, I'll fix it later
            // CODEWORK: make this incrementally computed
            //

            string Name, Value;
            int i, k, count, index, length, offset, TotalResponseSize, TotalKnownHeadersLength = 0, TotalUnknownHeadersLength = 0, UnknownHeaderCount = 0;

            i = 0;
            count = m_WebHeaders.Count;
            for (k = 0; k < count; k++) {
                Name = (string) m_WebHeaders.GetKey(k);
                Value = (string) m_WebHeaders.Get(k);
                index = UL_HTTP_RESPONSE_HEADER_ID.IndexOfKnownHeader( Name );

                if (index < 0) {
                    //
                    // unknown header
                    //

                    GlobalLog.Print(Name + " is unknown header Value:" + Value );

                    UnknownHeaderCount++;

                    TotalUnknownHeadersLength += Name.Length + Value.Length;
                }
                else {
                    //
                    // known header
                    //

                    GlobalLog.Print(Name + " is known header:" + Convert.ToString(index) + " Value:" + Value );

                    TotalKnownHeadersLength += Value.Length;
                }
            }

            TotalResponseSize =
            260 + // fixed size (includes know headers array)
            2 * m_StatusDescription.Length + // staus description
            2 * TotalKnownHeadersLength + // known headers
            4 * 4 * UnknownHeaderCount + // unknow headers array
            2 * TotalUnknownHeadersLength; // unknow headers

            //
            // allocate a managed UL_HTTP_RESPONSE structure, and store
            // unmanaged pinned memory pointers into structure members
            //
            IntPtr pResponse = Marshal.AllocHGlobal( TotalResponseSize );
            IntPtr pPointerOffset = ComNetOS.IsWinNt ? pResponse : IntPtr.Zero;

            GlobalLog.Print("Allocated " + Convert.ToString( TotalResponseSize ) + " bytes from:" + Convert.ToString(pResponse) + " to fit Response");            Marshal.WriteInt16( pResponse, 0, 0 ); // Flags
            Marshal.WriteInt16( pResponse, 2, (short)m_Status );
            Marshal.WriteInt32( pResponse, 12, UnknownHeaderCount );

            offset = 260;

            length = 2 * m_StatusDescription.Length;
            Marshal.WriteInt32( pResponse, 4, length );
            Marshal.WriteInt32( pResponse, 8, pPointerOffset + offset );
            Marshal.Copy( Encoding.Unicode.GetBytes( m_StatusDescription ), 0, pResponse + offset, length );
            offset += length;

            for (i = k = 0; i<30; i++, k+=2) {
                Name = UL_HTTP_RESPONSE_HEADER_ID.ToString(i);
                Value = m_WebHeaders[ Name ];

                Marshal.WriteInt64( pResponse, 20 + i*8, 0 );

                if (Value != null) {
                    //
                    // this known header key, has a value which is not null
                    //

                    length = 2 * Value.Length;
                    Marshal.WriteInt16( pResponse, 20 + i*8, (short)length ); // could use 32 as well because of padding
                    Marshal.WriteInt32( pResponse, 24 + i*8, pPointerOffset + offset );
                    Marshal.Copy( Encoding.Unicode.GetBytes( Value ), 0, pResponse + offset, length );

                    GlobalLog.Print("writing:" + Name + " from " + Convert.ToString(offset) + " to " + Convert.ToString(offset+length-1) );

                    offset += length;
                }
            }

            int pUnknownHeaders = offset;
            Marshal.WriteInt32( pResponse, 16, pPointerOffset + pUnknownHeaders );

            offset += UnknownHeaderCount * 16;

            i = 0;
            count = m_WebHeaders.Count;
            for (k = 0; k < count; k++) {
                Name = (string) m_WebHeaders.GetKey(k);
                Value = (string) m_WebHeaders.Get(k);
                index = UL_HTTP_RESPONSE_HEADER_ID.IndexOfKnownHeader( Name );

                if (index < 0) {
                    //
                    // unknown header
                    //

                    GlobalLog.Print(Name + " is unknown header offset:" + Convert.ToString(offset) );

                    length = 2 * Name.Length;
                    Marshal.WriteInt32( pResponse, pUnknownHeaders + i*16, length );
                    Marshal.WriteInt32( pResponse, pUnknownHeaders + 4 + i*16, pPointerOffset + offset );
                    Marshal.Copy( Encoding.Unicode.GetBytes( Name ), 0, pResponse + offset, length );

                    GlobalLog.Print("writing:" + Name + " from " + Convert.ToString(offset) + " to " + Convert.ToString(offset+length-1) );

                    offset += length;


                    length = 2 * Value.Length;
                    Marshal.WriteInt32( pResponse, pUnknownHeaders + 8 + i*16, length );
                    Marshal.WriteInt32( pResponse, pUnknownHeaders + 12 + i*16, pPointerOffset + offset );
                    Marshal.Copy( Encoding.Unicode.GetBytes( Value ), 0, pResponse + offset, length );

                    GlobalLog.Print("writing:" + Value + " from " + Convert.ToString(offset) + " to " + Convert.ToString(offset+length-1) );

                    offset += length;

                    i++;
                }
            }

            int DataWritten = 0;

            int result =
            ComNetOS.IsWinNt ?

            UlSysApi.UlSendHttpResponse(
                                       m_AppPoolHandle,
                                       m_RequestId,
                                       myFlags,
                                       pResponse,
                                       0,
                                       IntPtr.Zero,
                                       IntPtr.Zero,
                                       ref DataWritten,
                                       IntPtr.Zero)

            :

            UlVxdApi.UlSendHttpResponseHeaders(
                                              m_AppPoolHandle,
                                              m_RequestId,
                                              0,
                                              pResponse, // Response,
                                              TotalResponseSize,
                                              0,
                                              IntPtr.Zero,
                                              IntPtr.Zero,
                                              ref DataWritten,
                                              IntPtr.Zero);

            GlobalLog.Print("UlSendHttpResponseHeaders() DataWritten: " + Convert.ToString( DataWritten ) );

            Marshal.FreeHGlobal( pResponse );

            //
            // check return value, if IO is cancelled we'll throw
            //

            if (result != NativeMethods.ERROR_SUCCESS) {
                throw new IOException( "Request/Response processing was cancelled" );
            }

            //
            // don't touch m_WebHeaders & m_StatusDescription anymore
            //

            m_ReadyToSendHeaders = false;

            //
            // if not create the Stream
            //

            m_ResponseStream = new
                               ListenerResponseStream(
                                                     m_AppPoolHandle,
                                                     m_RequestId,
                                                     m_ContentLength,
                                                     m_SendChunked,
                                                     m_KeepAlive );

            //
            // and return it to the user
            //

            return m_ResponseStream;

        } // GetResponseStream()


        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.StatusCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpStatusCode StatusCode {
            set {
                if ((int)value >= 100 && (int)value <= 999) {
                    m_Status = value;
                }
                else {
                    throw new ProtocolViolationException(SR.GetString(SR.net_invalidstatus));
                }
            }
            get {
                return m_Status;
            }

        } // Status


        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.StatusDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string StatusDescription {
            set {
                m_StatusDescription = value;
            }
            get {
                return m_StatusDescription;
            }

        } // StatusDescription


        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override long ContentLength {
            set {
                m_ContentLength = value;
            }
            get {
                return m_ContentLength;
            }

        } // ContentLength

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.ContentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ContentType {
            set {
                m_WebHeaders.CheckUpdate(HttpKnownHeaderNames.ContentType, value);
            }
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.ContentType ];
            }

        } // ContentType

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.ProtocolVersion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Version ProtocolVersion {
            set {
                m_Version = value;
            }
            get {
                return m_Version;
            }

        } // Version

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.KeepAlive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool KeepAlive {
            set {
                m_KeepAlive = value;
            }
            get {
                return m_KeepAlive;
            }

        } // KeepAlive


        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.Connection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Connection {
            set {
                m_WebHeaders.CheckUpdate(HttpKnownHeaderNames.Connection, value);
            }
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.Connection ];
            }

        } // Connection

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.Server"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Server {
            set {
                m_WebHeaders.CheckUpdate(HttpKnownHeaderNames.Server, value);
            }
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.Server ];
            }

        } // Server


        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.Expect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Expect {
            set {
                m_WebHeaders.CheckUpdate(HttpKnownHeaderNames.Expect, value);
            }
            get {
                return m_WebHeaders[ HttpKnownHeaderNames.Expect ];
            }

        } // Expect

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.LastModified"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime LastModified {
            set {
                m_WebHeaders.SetAddVerified(HttpKnownHeaderNames.LastModified, HttpProtocolUtils.date2string(value));
            }
            get {
                string headerValue = m_WebHeaders[ HttpKnownHeaderNames.LastModified ];

                if (headerValue == null) {
                    return DateTime.Now;
                }

                return HttpProtocolUtils.string2date( headerValue );
            }

        } // LastModified

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.Date"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime Date {
            set {
                m_WebHeaders.SetAddVerified( HttpKnownHeaderNames.Date, HttpProtocolUtils.date2string(value));
            }
            get {
                string headerValue = m_WebHeaders[ HttpKnownHeaderNames.Date ];

                if (headerValue == null) {
                    return DateTime.Now;
                }

                return HttpProtocolUtils.string2date( headerValue );
            }

        } // Date

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.Headers"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override WebHeaderCollection Headers {
            get {
                return m_WebHeaders;
            }

        } // Headers

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.GetResponseHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetResponseHeader(string headerName) {
            return m_WebHeaders[ headerName ];

        } // GetResponseHeader()

        /// <include file='doc\HttpListenerWebResponse.uex' path='docs/doc[@for="HttpListenerWebResponse.SetResponseHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetResponseHeader(string headerName, string headerValue ) {
            m_WebHeaders[ headerName ] = headerValue;

            return;

        } // SetResponseHeader()


        //
        // class members
        //

        //
        // HTTP related stuff (exposed as property)
        //

        private long m_ContentLength;
        private string m_StatusDescription;
        private bool m_SendChunked;
        private bool m_KeepAlive;

        private HttpStatusCode m_Status;
        private Version m_Version;
        private Version m_ClientVersion;
        private WebHeaderCollection m_WebHeaders;

        private ListenerResponseStream m_ResponseStream;
        private bool m_ReadyToSendHeaders ;

        //
        // UL related stuff (may not be useful)
        //

        private long m_RequestId;
        private IntPtr m_AppPoolHandle;

    }; // class HttpListenerWebResponse


} // namespace System.Net

#endif // #if COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httpproxytunnelrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpProxyTunnelRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Threading;

    internal class HttpProxyTunnelRequest : HttpWebRequest {

        private static int m_UniqueGroupId;

        private Uri m_originServer;

        internal HttpProxyTunnelRequest(Uri proxyUri, Uri requestUri) : base(proxyUri) {

            GlobalLog.Enter("HttpProxyTunnelRequest::HttpProxyTunnelRequest",
                            "proxyUri="+proxyUri+", requestUri="+requestUri
                            );

            Method = "CONNECT";

            //
            // CONNECT requests cannot be pipelined
            //

            Pipelined = false;
            m_originServer = requestUri;

            //
            // each CONNECT request has a unique connection group name to avoid
            // non-CONNECT requests being made over the same connection
            //

            ConnectionGroupName = ServicePointManager.SpecialConnectGroupName + "(" + UniqueGroupId + ")";

            //
            // the CONNECT request must respond to a 407 as if it were a 401.
            // So we set up the server authentication state as if for a proxy
            //
            ServerAuthenticationState = new AuthenticationState(true);

            GlobalLog.Leave("HttpProxyTunnelRequest::HttpProxyTunnelRequest");
        }

        internal override string ConnectHostAndPort {
            get {
                return m_originServer.Host+":"+m_originServer.Port;
            }
        }

        internal override bool ShouldAddHostHeader {
            get {
                return true;
            }
        }

        private string UniqueGroupId {
            get {
                return (Interlocked.Increment(ref m_UniqueGroupId)).ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httpextension.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpExtension.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if HTTP_HEADER_EXTENSIONS_SUPPORTED

namespace System.Net {

//
// HTTPExtension - Handles basic Extension headers and stores ID, Uri, and actual
//      Header associated with them.
//

    /// <include file='doc\HttpExtension.uex' path='docs/doc[@for="HttpExtension"]/*' />
    /// <devdoc>
    ///    <para>Provides support for the HTTP Extension Framework defined in RFC 2774.</para>
    /// </devdoc>
    public class HttpExtension {

        private int    _ID;
        private string _Uri;
        private string _Header;
        private bool   _HasAddedExtensionHeader;

        /// <include file='doc\HttpExtension.uex' path='docs/doc[@for="HttpExtension.HttpExtension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpExtension(int id, string uri, string header) {
            _ID = id;
            _Uri = ValidationHelper.MakeStringEmpty(uri);
            _Header = ValidationHelper.MakeStringEmpty(header);
            _HasAddedExtensionHeader = false;
        }

        /// <include file='doc\HttpExtension.uex' path='docs/doc[@for="HttpExtension.ID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int ID {
            get {return _ID;}
            set {_ID = value;}
        }

        /// <include file='doc\HttpExtension.uex' path='docs/doc[@for="HttpExtension.Uri"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Uri {
            get {return _Uri;}
            set {_Uri = ValidationHelper.MakeStringEmpty(value);}
        }

        /// <include file='doc\HttpExtension.uex' path='docs/doc[@for="HttpExtension.Header"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Header {
            get {return _Header;}
            set {_Header = ValidationHelper.MakeStringEmpty(value);}
        }

        /// <include file='doc\HttpExtension.uex' path='docs/doc[@for="HttpExtension.HasAddedExtensionHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool HasAddedExtensionHeader {
            get {return _HasAddedExtensionHeader;}
            set {_HasAddedExtensionHeader = value;}
        }
    } // class HttpExtension
} // namespace System.Net

#endif // HTTP_HEADER_EXTENSIONS_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httpversion.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpVersion.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Configuration;
using System.Configuration.Assemblies;

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Util;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;



namespace System.Net {


    /// <include file='doc\HttpVersion.uex' path='docs/doc[@for="HttpVersion"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines the HTTP version number supported by the <see cref='System.Net.HttpWebRequest'/> and
    ///    <see cref='System.Net.HttpWebResponse'/> classes.
    ///    </para>
    /// </devdoc>
    public class HttpVersion {

        /// <include file='doc\HttpVersion.uex' path='docs/doc[@for="HttpVersion.Version10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Version  Version10 = new Version(1,0);
        /// <include file='doc\HttpVersion.uex' path='docs/doc[@for="HttpVersion.Version11"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Version  Version11 = new Version(1,1);



    } // class HttpVersion


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\iauthenticationmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="IAuthenticationModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Net {
    /// <include file='doc\IAuthenticationModule.uex' path='docs/doc[@for="IAuthenticationModule"]/*' />
    /// <devdoc>
    ///    <para>Provides the base authentication interface for Web client authentication
    ///       modules.</para>
    /// </devdoc>
    public interface IAuthenticationModule {
        /// <include file='doc\IAuthenticationModule.uex' path='docs/doc[@for="IAuthenticationModule.Authenticate"]/*' />
        /// <devdoc>
        /// <para>Returns an instance of the <see cref='System.Net.Authorization'/>
        /// class in response to the
        /// authentication challenge from a server.</para>
        /// </devdoc>
        Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);

        /// <include file='doc\IAuthenticationModule.uex' path='docs/doc[@for="IAuthenticationModule.PreAuthenticate"]/*' />
        /// <devdoc>
        /// <para>Returns an instance of the <see cref='System.Net.Authorization'/> class in response to an
        ///    authentication request to a server.</para>
        /// </devdoc>
        Authorization PreAuthenticate(WebRequest request, ICredentials credentials);

        /// <include file='doc\IAuthenticationModule.uex' path='docs/doc[@for="IAuthenticationModule.CanPreAuthenticate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the module implementing the interface supports
        ///       pre-authentication.
        ///    </para>
        /// </devdoc>
        bool CanPreAuthenticate { get;}

        /// <include file='doc\IAuthenticationModule.uex' path='docs/doc[@for="IAuthenticationModule.AuthenticationType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The authentication scheme used by the host.
        ///       .
        ///    </para>
        /// </devdoc>
        string AuthenticationType { get;}

    } // interface IAuthenticationModule


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httpwebrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpWebRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Collections;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Cryptography.X509Certificates;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Globalization;

    internal class AuthenticationState {

        // true if we already attempted pre-authentication regardless if it has been
        // 1) possible,
        // 2) succesfull or
        // 3) unsuccessfull
        internal bool                    TriedPreAuth;

        internal Authorization           Authorization;

        internal IAuthenticationModule   Module;

        // used to request a special connection for NTLM
        internal string                  UniqueGroupId;

        // used to distinguish proxy auth from server auth
        internal bool                    IsProxyAuth;

        internal string AuthenticateHeader {
            get {
                return IsProxyAuth ? HttpKnownHeaderNames.ProxyAuthenticate : HttpKnownHeaderNames.WWWAuthenticate;
            }
        }
        internal string AuthorizationHeader {
            get {
                return IsProxyAuth ? HttpKnownHeaderNames.ProxyAuthorization : HttpKnownHeaderNames.Authorization;
            }
        }
        internal HttpStatusCode StatusCodeMatch {
            get {
                return IsProxyAuth ? HttpStatusCode.ProxyAuthenticationRequired : HttpStatusCode.Unauthorized;
            }
        }

        internal AuthenticationState(bool isProxyAuth) {
            IsProxyAuth = isProxyAuth;
        }

        internal void PrepareState(HttpWebRequest httpWebRequest) {
            //
            // we need to do this to handle proxies in the correct way before
            // calling into the AuthenticationManager APIs
            //
            httpWebRequest.CurrentAuthenticationState = this;
            if (IsProxyAuth) {
                // Proxy Auth
                httpWebRequest.ChallengedUri = httpWebRequest.ServicePoint.Address;
            }
            else {
                // Server Auth
                httpWebRequest.ChallengedUri = httpWebRequest._Uri;
            }
            if (!IsProxyAuth && httpWebRequest.ServicePoint.InternalProxyServicePoint) {
                // here the NT-Security folks need us to attempt a a DNS lookup to figure out
                // the FQDN. only do the lookup for short names (no IP addresses or DNS names)
                // here we set it to null. the lookup will happen on demand in the appropriate module.
                httpWebRequest.ChallengedSpn = null;
            }
            else {
                // CONSIDER V.NEXT
                // for now avoid appending the non default port to the
                // SPN, sometime in the future we'll have to do this.
                // httpWebRequest.ChallengedSpn = httpWebRequest.ServicePoint.Address.IsDefaultPort ? httpWebRequest.ServicePoint.Hostname : httpWebRequest.ServicePoint.Hostname + ":" + httpWebRequest.ServicePoint.Address.Port;
                httpWebRequest.ChallengedSpn = httpWebRequest.ServicePoint.Hostname;
            }
        }

        internal void PreAuthIfNeeded(HttpWebRequest httpWebRequest, ICredentials authInfo) {
            //
            // attempt to do preauth, if needed
            //
            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::PreAuthIfNeeded() TriedPreAuth:" + TriedPreAuth.ToString() + " authInfo:" + ValidationHelper.HashString(authInfo));
            if (!TriedPreAuth) {
                TriedPreAuth = true;
                if (authInfo!=null) {
                    PrepareState(httpWebRequest);
                    Authorization preauth = null;
                    try {
                        preauth = AuthenticationManager.PreAuthenticate(httpWebRequest, authInfo);
                        GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::PreAuthIfNeeded() preauth:" + ValidationHelper.HashString(preauth));
                        if (preauth!=null && preauth.Message!=null) {
                            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::PreAuthIfNeeded() setting TriedPreAuth to Complete:" + preauth.Complete.ToString());
                            UniqueGroupId = preauth.ConnectionGroupId;
                            httpWebRequest.Headers.Set(AuthorizationHeader, preauth.Message);
                        }
                    }
                    catch (Exception exception) {
                        GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::PreAuthIfNeeded() PreAuthenticate() returned exception:" + exception.Message);
                        ClearSession(httpWebRequest);
                    }
                }
            }
        }

        //
        // attempts to authenticate the request:
        // returns true only if it succesfully called into the AuthenticationManager
        // and got back a valid Authorization and succesfully set the appropriate auth headers
        //
        internal bool AttemptAuthenticate(HttpWebRequest httpWebRequest, ICredentials authInfo) {
            //
            // Check for previous authentication attempts or the presence of credentials
            //
            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() httpWebRequest#" + ValidationHelper.HashString(httpWebRequest) + " AuthorizationHeader:" + AuthorizationHeader.ToString());

            if (Authorization!=null && Authorization.Complete) {
                //
                // here the design gets "dirty".
                // if this is proxy auth, we might have been challenged by an external
                // server as well. in this case we will have to clear our previous proxy
                // auth state before we go any further. this will be broken if the handshake
                // requires more than one dropped connection (which NTLM is a border case for,
                // since it droppes the connection on the 1st challenge but not on the second)
                //
                GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() Authorization!=null Authorization.Complete:" + Authorization.Complete.ToString());
                if (IsProxyAuth) {
                    //
                    // so, we got passed a 407 but now we got a 401, the proxy probably
                    // dropped the connection on us so we need to reset our proxy handshake
                    // Consider: this should have been taken care by Update()
                    //
                    GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() ProxyAuth cleaning up auth status");
                    ClearAuthReq(httpWebRequest);
                }
                return false;
            }

            if (authInfo==null) {
                GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() authInfo==null Authorization#" + ValidationHelper.HashString(Authorization));
                return false;
            }

            httpWebRequest.Headers.Remove(AuthorizationHeader);

            string challenge = httpWebRequest._HttpResponse.Headers[AuthenticateHeader];

            if (challenge==null) {
                //
                // the server sent no challenge, but this might be the case
                // in which we're succeeding an authorization handshake to
                // a proxy while a handshake with the server is still in progress.
                // if the handshake with the proxy is complete and we actually have
                // a handshake with the server in progress we can send the authorization header for the server as well.
                //
                if (!IsProxyAuth && Authorization!=null && httpWebRequest.ProxyAuthenticationState.Authorization!=null) {
                    httpWebRequest.Headers.Set(AuthorizationHeader, Authorization.Message);
                }
                GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() challenge==null Authorization#" + ValidationHelper.HashString(Authorization));
                return false;
            }

            //
            // if the AuthenticationManager throws on Authenticate,
            // bubble up that Exception to the user
            //
            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() challenge:" + challenge);

            PrepareState(httpWebRequest);
            try {
                Authorization = AuthenticationManager.Authenticate(challenge, httpWebRequest, authInfo);
            }
            catch (Exception exception) {
                httpWebRequest.SetResponse(exception);
                Authorization = null;
            }

            if (Authorization==null) {
                GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() Authorization==null");
                return false;
            }
            if (Authorization.Message==null) {
                GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() Authorization.Message==null");
                Authorization = null;
                return false;
            }

            UniqueGroupId = Authorization.ConnectionGroupId;
            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::AttemptAuthenticate() AuthorizationHeader:" + AuthorizationHeader + " blob: " + Authorization.Message.Length + "bytes Complete:" + Authorization.Complete.ToString());

            //
            // resubmit request
            //
            try {
                //
                // a "bad" module could try sending bad characters in the HTTP headers.
                // catch the exception from WebHeaderCollection.CheckBadChars()
                // fail the auth process
                // and return the exception to the user as InnerException
                //
                httpWebRequest.Headers.Set(AuthorizationHeader, Authorization.Message);
            }
            catch (Exception exception) {
                httpWebRequest.SetResponse(exception);
                Authorization = null;
                return false;
            }

            return true;
        }

        internal void ClearAuthReq(HttpWebRequest httpWebRequest) {
            //
            // if we are authenticating and we're being redirected to
            // another authentication space then remove the current
            // authentication header
            //
            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::ClearAuthReq() httpWebRequest#" + ValidationHelper.HashString(httpWebRequest) + " " + AuthorizationHeader.ToString() + ": " + ValidationHelper.ToString(httpWebRequest.Headers[AuthorizationHeader]));
            TriedPreAuth = false;
            Authorization = null;
            UniqueGroupId = null;
            httpWebRequest.Headers.Remove(AuthorizationHeader);
        }

        //
        // gives the IAuthenticationModule a chance to update its internal state.
        // do any necessary cleanup and update the Complete status of the associated Authorization.
        //
        internal void Update(HttpWebRequest httpWebRequest) {
            //
            // RAID#86753
            // mauroot: this is just a fix for redirection & kerberos.
            // we need to close the Context and call ISC() again with the final
            // blob returned from the server. to do this in general
            // we would probably need to change the IAuthenticationMdule interface and
            // add this Update() method. for now we just have it internally.
            //
            // actually this turns out to be quite handy for 2 more cases:
            // NTLM auth: we need to clear the connection group after we suceed to prevent leakage.
            // Digest auth: we need to support stale credentials, if we fail with a 401 and stale is true we need to retry.
            //
            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::Update() httpWebRequest#" + ValidationHelper.HashString(httpWebRequest) + " Authorization#" + ValidationHelper.HashString(Authorization) + " ResponseStatusCode:" + httpWebRequest.ResponseStatusCode.ToString());

            if (Authorization!=null) {

                PrepareState(httpWebRequest);

                ISessionAuthenticationModule myModule = Authorization.Module as ISessionAuthenticationModule;

                if (myModule!=null) {
                    //
                    // the whole point here is to complete the Security Context. Sometimes, though,
                    // a bad cgi script or a bad server, could miss sending back the final blob.
                    // in this case we won't be able to complete the handshake, but we'll have to clean up anyway.
                    //
                    string challenge = httpWebRequest._HttpResponse.Headers[AuthenticateHeader];
                    GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::Update() Complete:" + Authorization.Complete.ToString() + " Authorization.Module:" + ValidationHelper.ToString(Authorization.Module) + " challenge:" + ValidationHelper.ToString(challenge));
                    //
                    // here the design gets "dirty".
                    // if this is server auth, we might have been challenged by the proxy
                    // server as well. in this case we will have to clear our server auth state,
                    // but this might not be the current httpWebRequest.CurrentAuthenticationState.
                    //
                    AuthenticationState savedAuthenticationState = httpWebRequest.CurrentAuthenticationState;
                    if (!IsProxyAuth) {
                        httpWebRequest.CurrentAuthenticationState = this;
                    }

                    if (!IsProxyAuth && httpWebRequest.ResponseStatusCode==HttpStatusCode.ProxyAuthenticationRequired) {
                        //
                        // don't call Update on the module, since there's an ongoing
                        // handshake and we don't need to update any state in such a case
                        //
                        GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::Update() skipping call to " + myModule.ToString() + ".Update() since we need to reauthenticate with the proxy");
                    }
                    else {
                        //
                        // Update might fail, here we just make sure we catch anything
                        // that is happening in the module so we don't hang internally.
                        //
                        bool complete = true;
                        try {
                            complete = myModule.Update(challenge, httpWebRequest);
                            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::Update() " + myModule.ToString() + ".Update() returned complete:" + complete.ToString());
                        }
                        catch (Exception exception) {
                            GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::Update() " + myModule.ToString() + ".Update() caught exception:" + exception.Message);
                            ClearSession(httpWebRequest);
                        }

                        Authorization.SetComplete(complete);
                    }

                    if (!IsProxyAuth) {
                        httpWebRequest.CurrentAuthenticationState = savedAuthenticationState;
                    }
                }

                //
                // If authentication was successful, create binding between
                // the request and the authorization for future preauthentication
                //
                if (Authorization.Complete && httpWebRequest.ResponseStatusCode!=StatusCodeMatch) {
                    GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::Update() handshake is Complete calling BindModule()");
                    AuthenticationManager.BindModule(httpWebRequest, Authorization);
                }
            }
        }

        internal void ClearSession(HttpWebRequest httpWebRequest) {
            PrepareState(httpWebRequest);
            ISessionAuthenticationModule myModule = Module as ISessionAuthenticationModule;

            if (myModule!=null) {
                try {
                    myModule.ClearSession(httpWebRequest);
                }
                catch (Exception exception) {
                    GlobalLog.Print("AuthenticationState#" + ValidationHelper.HashString(this) + "::ClearSession() " + myModule.ToString() + ".Update() caught exception:" + exception.Message);
                }
            }

        }

    }


    internal delegate void UnlockConnectionDelegate();

    //
    // HttpWebRequest - perform the major body of HTTP request processing. Handles
    //      everything between issuing the HTTP header request to parsing the
    //      the HTTP response.  At that point, we hand off the request to the response
    //      object, where the programmer can query for headers or continue reading, usw.
    //

    /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest"]/*' />
    /// <devdoc>
    /// <para><see cref='System.Net.HttpWebRequest'/> is an HTTP-specific implementation of the <see cref='System.Net.WebRequest'/>
    /// class.</para>
    /// </devdoc>
    [Serializable]
    public class HttpWebRequest : WebRequest, ISerializable {

        // Read and Write async results
        private LazyAsyncResult         _WriteAResult;
        private LazyAsyncResult         _ReadAResult;

        // Delegate that can be called on Continue Response
        private HttpContinueDelegate    _ContinueDelegate;

        // Link back to the server point used for this request.
        private ServicePoint            _ServicePoint;

        // Auto Event used to control access to the GetResponse,
        //  to indicate a ready response

        // Auto Event used to indicate we allowed to write data
        private AutoResetEvent          _WriteEvent;
        // Auto Event used to indicate if we're still writing headers.
        private AutoResetEvent          _WriteInProgressEvent;

        private bool                    _HaveResponse;

        // set to true if this request failed during a connect
        private bool                    _OnceFailed;

        // set to true if this request has/will notify users callback of Write
        private bool                    _WriteNotifed;

        // this is generated by SetResponse
        internal HttpWebResponse         _HttpResponse;

        // generic exception created by SetResponse from Connection failures or other internal failures
        private Exception               _ResponseException;

        // set by Connection code upon completion
        private object                  _CoreResponse;

        private const int               RequestLineConstantSize = 12;
        private const int               RequestDefaultTime = 2 * (60) * 1000; // 2 mins

        // Size of '  HTTP/x.x\r\n'
        // which are the
        // unchanging pieces of the
        // request line.
        private static readonly byte[]  HttpBytes = new byte[]{(byte)'H', (byte)'T', (byte)'T', (byte)'P', (byte)'/'};

        internal static WaitOrTimerCallback m_EndWriteHeaders_Part2Callback = new WaitOrTimerCallback(EndWriteHeaders_Part2);

        // request values
        private string                  _Verb;
        // the actual verb set by caller or default
        private string                  _OriginVerb;

        // our HTTP header response, request, parsing and storage objects
        private WebHeaderCollection     _HttpRequestHeaders;

        // send buffer for output request with headers.
        private byte[]                  _WriteBuffer;

        // Property to set whether writes can be handled
        private HttpWriteMode           _HttpWriteMode;

        // is autoredirect ?
        private bool                    _AllowAutoRedirect = true;

        // the host, port, and path
        internal Uri                    _Uri;
        // the origin Uri host, port and path that never changes
        private Uri                     _OriginUri;
        // the Uri of the host we're authenticating (proxy/server)
        // used to match entries in the CredentialCache
        private Uri                     _ChallengedUri;
        private string                  _ChallengedSpn;


        // for which response ContentType we will look for and parse the CharacterSet
        private string                  _MediaType;

        // content length
        private long                    _ContentLength;

        // version of HTTP
        private Version                 _Version;
        // proxy or server HTTP version
        private Version                 _DestinationVersion;

        // proxy that we are using...
        private bool                    _ProxyUserSet;
        internal IWebProxy              _Proxy;

        private string                  _ConnectionGroupName;

        private bool                    _PreAuthenticate;

        private AuthenticationState     _ProxyAuthenticationState;
        private AuthenticationState     _ServerAuthenticationState;
        private AuthenticationState     _CurrentAuthenticationState;

        private ICredentials            _AuthInfo;
        private bool                    _RequestSubmitted;

        private HttpAbortDelegate       _AbortDelegate;
        private bool                    _Abort;

        private bool                    _ExpectContinue = true;
        private bool                    _KeepAlive;
        private bool                    _Pipelined;

        //
        // used to prevent Write Buffering,
        //  used otherwise for reposting POST, and PUTs in redirects
        //
        private ConnectStream           _SubmitWriteStream;
        private ConnectStream           _OldSubmitWriteStream;
        private bool                    _AllowWriteStreamBuffering;
        private bool                    _WriteStreamRetrieved;
        private int                     _MaximumAllowedRedirections;
        private int                     _AutoRedirects;
        private bool                    _Saw100Continue;

        // true when we are waiting on continue
        private bool                    _AcceptContinue;

        // true when we got a continue from server
        // private bool                    _AckContinue;

        //
        // generic version of _AutoRedirects above
        // used to count the number of requests made off this WebRequest
        //
        private int                     _RerequestCount;

        //
        // Timeout in milliseconds, if a synchronous request takes longer
        // than timeout, a WebException is thrown
        //
        private int                     _Timeout;

        //
        // Timeout for Read & Write on the Stream that we return through
        //  GetResponse().GetResponseStream() && GetRequestStream()
        //

        private int                     _ReadWriteTimeout;

        // default delay on the Stream.Read and Stream.Write operations
        private const int  DefaultReadWriteTimeout = 5 * 60 * 1000; // 5 mins

        //
        // Our ClientCertificates are non-null, if we are doing client auth
        //

        private X509CertificateCollection _ClientCertificates = new X509CertificateCollection();

        // time delay that we would wait for continue
        private const int  DefaultContinueTimeout  = 350; //ms


        // size of post data, that needs to be greater, before we wait for a continue response
        // private static int  DefaultRequireWaitForContinueSize = 2048; // bytes

#if HTTP_HEADER_EXTENSIONS_SUPPORTED
        // extension list for our namespace, used as counter, to pull a unque number out
        private int                     _NextExtension = 10;
#endif // HTTP_HEADER_EXTENSIONS_SUPPORTED

        private CookieContainer         _CookieContainer = null;

        private bool                    _LockConnection;

        private static int              _DefaultMaximumResponseHeadersLength = GetDefaultMaximumResponseHeadersLength();

        private int                     _MaximumResponseHeadersLength;

        //
        // Properties
        //

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.DefaultMaximumResponseHeadersLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the default for the MaximumResponseHeadersLength property.
        ///    </para>
        ///    <remarks>
        ///       This value can be set in the config file, the default can be overridden using the MaximumResponseHeadersLength property.
        ///    </remarks>
        /// </devdoc>
        public static int DefaultMaximumResponseHeadersLength {
            get {
                return _DefaultMaximumResponseHeadersLength;
            }
            set {
                (new WebPermission(PermissionState.Unrestricted)).Demand();
                if (value<0 && value!=-1) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.net_toosmall));
                }
                _DefaultMaximumResponseHeadersLength = value;
            }
        }
        private static int GetDefaultMaximumResponseHeadersLength() {
            NetConfiguration config = (NetConfiguration)System.Configuration.ConfigurationSettings.GetConfig("system.net/settings");
            if (config != null) {
                if (config.maximumResponseHeadersLength<0 && config.maximumResponseHeadersLength!=-1) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.net_toosmall));
                }
                return config.maximumResponseHeadersLength;
            }
            else {
                return 64;
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.MaximumResponseHeadersLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum allowed length of the response headers.
        ///    </para>
        ///    <remarks>
        ///       The length is measured in kilobytes (1024 bytes) and it includes the response status line and the response
        ///       headers as well as all extra control characters received as part of the HTTP protocol. A value of -1 means
        ///       no such limit will be imposed on the response headers, a value of 0 means that all requests will fail.
        ///    </remarks>
        /// </devdoc>
        public int MaximumResponseHeadersLength {
            get {
                return _MaximumResponseHeadersLength;
            }
            set {
                if (_RequestSubmitted) {
                    throw new InvalidOperationException(SR.GetString(SR.net_reqsubmitted));
                }
                if (value<0 && value!=-1) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.net_toosmall));
                }
                _MaximumResponseHeadersLength = value;
            }
        }


        //
        // AbortDelegate - set by ConnectionGroup when 
        //  the request is blocked waiting for a Connection
        //
        internal HttpAbortDelegate AbortDelegate {
            get {
                return _AbortDelegate;
            }
            set {
                _AbortDelegate = value;
            }
        }

        //
        // LockConnection - set to true when the 
        //  request needs exclusive access to the Connection
        //
        internal bool LockConnection {
            get {
                return _LockConnection;
            }
            set {
                if (value) {
                    Pipelined = false;
                }
                _LockConnection = value;
            }
        }

        //
        // UnlockConnectionDelegate - set by the Connection
        //  iff the Request is asking for exclusive access (ie LockConnection == true)
        //  in this case UnlockConnectionDelegate must be called when the Request
        //  has finished authentication. 
        //
        private UnlockConnectionDelegate _UnlockDelegate;
        internal UnlockConnectionDelegate UnlockConnectionDelegate {
            get {
                return _UnlockDelegate;
            }
            set {
                _UnlockDelegate = value;
            }
        }

        //
        // if the 100 Continue comes in around 350ms there might be race conditions
        // that make us set Understands100Continue to true when parsing the 100 response
        // in the Connection object and later make us set it to false if the
        // thread that is waiting comes in later than 350ms. to solve this we save info
        // on wether we did actually see the 100 continue. In that case, even if there's a
        // timeout, we won't set it to false.
        //
        internal bool Saw100Continue {
            get {
                return _Saw100Continue;
            }
            set {
                _Saw100Continue = value;
            }
        }

        internal bool UsesProxy {
            get {
                return ServicePoint.InternalProxyServicePoint;
            }
        }

        internal HttpStatusCode ResponseStatusCode {
            get {
                return _HttpResponse.StatusCode;
            }
        }

        internal bool UsesProxySemantics {
            get {
                bool tunnelRequest = this is HttpProxyTunnelRequest;
                return ServicePoint.InternalProxyServicePoint && ((_Uri.Scheme != Uri.UriSchemeHttps) || tunnelRequest);
            }
        }

        internal Uri ChallengedUri {
            get {
                return _ChallengedUri;
            }
            set {
                _ChallengedUri = value;
            }
        }

        internal string ChallengedSpn {
            get {
                return _ChallengedSpn;
            }
            set {
                _ChallengedSpn = value;
            }
        }

        internal AuthenticationState ProxyAuthenticationState {
            get {
                return _ProxyAuthenticationState;
            }
            set {
                _ProxyAuthenticationState = value;
            }
        }

        internal AuthenticationState ServerAuthenticationState {
            get {
                return _ServerAuthenticationState;
            }
            set {
                _ServerAuthenticationState = value;
            }
        }
        // the AuthenticationState we're using for authentication (proxy/server)
        // used to match entries in the Hashtable in NtlmClient & NegotiateClient
        internal AuthenticationState CurrentAuthenticationState {
            get {
                return _CurrentAuthenticationState;
            }
            set {
                _CurrentAuthenticationState = value;
            }
        }

        // DELEGATION: The member is accesed (optionally) from other thread during resubmit
        [NonSerialized]
        private DelegationFix m_DelegationFix = null;
        internal DelegationFix DelegationFix {
            get {
                return m_DelegationFix;
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.CookieContainer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieContainer CookieContainer {
            get {
                return _CookieContainer;
            }
            set {
                _CookieContainer = value;
            }
        }

        private bool _UnsafeAuthenticatedConnectionSharing; 

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.UnsafeAuthenticatedConnectionSharing"]/*' />
        /// <devdoc>
        ///    <para>Allows hi-speed NTLM connection sharing with keep-alive</para>
        /// </devdoc>
        public bool UnsafeAuthenticatedConnectionSharing { 
            get {
                return _UnsafeAuthenticatedConnectionSharing;   
            }
            set {
                (new WebPermission(PermissionState.Unrestricted)).Demand();
                _UnsafeAuthenticatedConnectionSharing = value;   
            }
        }

        /// <devdoc>
        ///    <para>
        ///     Removes the ConnectionGroup and the Connection resources
        ///     held open usually do to NTLM operations.
        ///     </para>
        /// </devdoc>
        private void ClearAuthenticatedConnectionResources() {
            if (!UnsafeAuthenticatedConnectionSharing && 
                    ((_ProxyAuthenticationState.UniqueGroupId != null) ||
                     (_ServerAuthenticationState.UniqueGroupId != null))) {
                ServicePoint.ReleaseConnectionGroup(GetConnectionGroupLine());
            }

            UnlockConnectionDelegate unlockConnectionDelegate = this.UnlockConnectionDelegate;
            try {
                if (unlockConnectionDelegate != null) {
                    unlockConnectionDelegate();
                }
                this.UnlockConnectionDelegate = null;
            } catch {
            }

            _ProxyAuthenticationState.ClearSession(this);
            _ServerAuthenticationState.ClearSession(this);
        }

        /// <devdoc>
        ///    <para>
        ///     Enables a variable that indicates that we are actively writeing 
        ///     headers to the wire.  When Set, this prevents resubmissions of requests
        ///     do an early response from the server.  Also resets a WriteInProgress event,
        ///     which prevents the resubmission continuing until we have finished the write.
        ///     </para>
        /// </devdoc>
        private bool _WriteInProgress;
        private void SetWriteInProgress() {
            lock (this) {
                _WriteInProgress = true;
                if (_WriteInProgressEvent != null) {
                    _WriteInProgressEvent.Reset();                    
                }
            }
        }

        /// <devdoc>
        ///    <para>Releases the WriteInProgress state, and allows resubmissions to continue. </para>
        /// </devdoc>
        private void ResetWriteInProgress() {
            lock (this) {
                _WriteInProgress = false;
                if (_WriteInProgressEvent != null) {
                    _WriteInProgressEvent.Set();
                }
            }
        }

        /// <devdoc>
        ///    <para>
        ///     Waits on an Event, under the conditions when a Write of Headers is in progress.
        ///     When this happens, we create an event, and sit on it until the Write of Headers
        ///     on another thread is completed.
        ///     </para>
        /// </devdoc>
        private void WaitWriteInProgress() {
            lock (this) {
                if (_WriteInProgress) {
                    if (_WriteInProgressEvent == null) {
                       _WriteInProgressEvent = new AutoResetEvent(false);                           
                    }
                }
            }

            if (_WriteInProgress) {
                if (_WriteInProgressEvent != null) {
                    _WriteInProgressEvent.WaitOne();                            
                }
            }
        }


        /*
            Accessor:   RequestUri

            This read-only propery returns the Uri for this request. The
            Uri object was created by the constructor and is always non-null.

            Note that it will always be the base Uri, and any redirects,
            or such will not be indicated.

            Input:

            Returns: The Uri object representing the Uri.


        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.RequestUri"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the original Uri of the request.
        ///    </para>
        /// </devdoc>
        public override Uri RequestUri {                                   // read-only
            get {
                return _OriginUri;
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.AllowWriteStreamBuffering"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables or disables buffering the data stream sent to the server.
        ///    </para>
        /// </devdoc>
        public bool AllowWriteStreamBuffering {
            get {
                return _AllowWriteStreamBuffering;
            }
            set {
                _AllowWriteStreamBuffering = value;
            }
        }

        /*
            Accessor:   ContentLength

            The property that controls the Content-Length of the request entity
            body. Getting this property returns the last value set, or -1 if
            no value has been set. Setting it sets the content length, and
            the application must write that much data to the stream. This property
            interacts with SendChunked.

            Input:
                Content length

            Returns: The value of the content length on get.

        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the Content-Length header of the request.
        ///    </para>
        /// </devdoc>
        public override long ContentLength {
            get {
                return _ContentLength;
            }
            set {
                if (_RequestSubmitted) {
                    throw new InvalidOperationException(SR.GetString(SR.net_writestarted));
                }
                if (value < 0) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.net_clsmall));
                }
                SetContentLength(value);
            }
        }
        internal void SetContentLength(long contentLength) {
            _ContentLength = contentLength;
            _HttpWriteMode = HttpWriteMode.Write;
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Timeout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        //UEUE changed default from infinite to 100 seconds
        public override int Timeout {
            get {
                return _Timeout;
            }
            set {
                if (value<0 && value!=System.Threading.Timeout.Infinite) {
                    throw new ArgumentOutOfRangeException("value");
                }
                _Timeout = value;
            }
        }


        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.ReadWriteTimeout"]/*' />
        /// <devdoc>
        ///    <para>Used to control the Timeout when calling Stream.Read && Stream.Write.
        ///         Effects Streams returned from GetResponse().GetResponseStream() && GetRequestStream().
        ///         Default is 5 mins.
        ///    </para>
        /// </devdoc>
        public int ReadWriteTimeout {
            get {
                return _ReadWriteTimeout;
            }
            set {
                if (_RequestSubmitted) {
                    throw new InvalidOperationException(SR.GetString(SR.net_reqsubmitted));
                }
                if (value<0 && value!=System.Threading.Timeout.Infinite) {
                    throw new ArgumentOutOfRangeException("value");
                }
                _ReadWriteTimeout = value;
            }
        }

        //
        // ClientCertificates - sets our certs for our reqest,
        //  uses a hash of the collection to create a private connection
        //  group, to prevent us from using the same Connection as
        //  non-Client Authenticated requests.
        //
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.ClientCertificates"]/*' />
        public X509CertificateCollection ClientCertificates {
            get {
                return _ClientCertificates;
            }
        }

        //
        // CoreResponse - set by Connection code upon completion
        //
        internal object CoreResponse {
            get {
                return _CoreResponse;
            }
            set {
                _CoreResponse = value;
            }
        }        


        /*
            Accessor:   BeginGetRequestStream

            Retreives the Request Stream from an HTTP Request uses an Async
              operation to do this, and the result is retrived async.

            Async operations include work in progess, this call is used to retrieve
             results by pushing the async operations to async worker thread on the callback.
            There are many open issues involved here including the handling of possible blocking
            within the bounds of the async worker thread or the case of Write and Read stream
            operations still blocking.


            Input:

            Returns: The Async Result


        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.BeginGetRequestStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginGetRequestStream");

            if (!CanGetRequestStream) {
                throw new ProtocolViolationException(SR.GetString(SR.net_nouploadonget));
            }

            // prevent someone from trying to send data without setting
            // a ContentLength or SendChunked when buffering is disabled and on a KeepAlive connection
            if (MissingEntityBodyDelimiter) {
                throw new ProtocolViolationException(SR.GetString(SR.net_contentlengthmissing));
            }

            // prevent someone from setting a Transfer Encoding without having SendChunked=true
            if (TransferEncodingWithoutChunked) {
                throw new InvalidOperationException(SR.GetString(SR.net_needchunked));
            }

            // used to make sure the user issues a GetRequestStream before GetResponse
            _WriteStreamRetrieved = true;

            Monitor.Enter(this);

            if (_WriteAResult != null) {

                Monitor.Exit(this);

                throw new InvalidOperationException(SR.GetString(SR.net_repcall));
            }

            // get async going
            LazyAsyncResult asyncResult =
                new LazyAsyncResult(
                    this,
                    state,
                    callback );

            _WriteAResult = asyncResult;
            Monitor.Exit(this);

            //
            // See if we're already submitted a request.
            //
            if (_RequestSubmitted) {
                // We already have. Make sure we have a write stream.
                if (_SubmitWriteStream != null) {
                    // It was, just return the stream.
                    try {
                        asyncResult.InvokeCallback(true, _SubmitWriteStream);
                    }
                    catch {
                        Abort();
                        throw;
                    }

                    goto done;
                }
                else {
                    //
                    // No write stream, this is an application error.
                    //
                    if (_ResponseException!=null) {
                        //
                        // somebody already aborted for some reason
                        // rethrow for the same reason
                        //
                        throw _ResponseException;
                    }
                    else {
                        throw new InvalidOperationException(SR.GetString(SR.net_reqsubmitted));
                    }
                }
            }

            // OK, we haven't submitted the request yet, so do so
            // now.
            //
            // CODEWORK: Need to handle the case here where we don't
            // know the server version (or it doesn't support chunked) and
            // we don't have a content length we can send. We need to return
            // a stream that just buffers the data and send the request
            // on close.

            // prevent new requests when low on resources
            if (System.Net.Connection.IsThreadPoolLow()) {
                Abort();
                throw new InvalidOperationException(SR.GetString(SR.net_needmorethreads));
            }

            if (_HttpWriteMode == HttpWriteMode.None) {
                _HttpWriteMode = HttpWriteMode.Write;
            }

            // save off verb from origin Verb
            GlobalLog.Print("HttpWebRequest#"+ValidationHelper.HashString(this)+": setting _Verb to _OriginVerb ["+_OriginVerb+"]");
            _Verb = _OriginVerb;
            BeginSubmitRequest(false);

done:
            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginGetRequestStream", ValidationHelper.HashString(asyncResult));
            return asyncResult;
        }

        /*
            Accessor:   EndGetRequestStream

            Retreives the Request Stream after an Async operation has completed


            Input:

            Returns: The Async Stream

        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.EndGetRequestStream"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override Stream EndGetRequestStream(IAsyncResult asyncResult) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndGetRequestStream", ValidationHelper.HashString(asyncResult));
            //
            // parameter validation
            //
            if (asyncResult == null) {
                throw new ArgumentNullException("asyncResult");
            }
            LazyAsyncResult castedAsyncResult = asyncResult as LazyAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndGetRequestStream"));
            }
            ConnectStream connectStream = castedAsyncResult.InternalWaitForCompletion() as ConnectStream;
            castedAsyncResult.EndCalled = true;

            CheckFinalStatus();

            if (connectStream==null) {
                //
                // OK, something happened on the request. We can't return
                // a stream here, so for now we'll throw an exception.
                // CODEWORK: figure out a new error handling mechanism and
                // use it here.
                //
                GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndGetRequestStream() throwing connectStream==null");
                if (_ResponseException!=null) {
                    //
                    // somebody already aborted for some reason
                    // rethrow for the same reason
                    //
                    throw _ResponseException;
                }
                else {
                    throw new InvalidOperationException(SR.GetString(SR.net_reqsubmitted));
                }
            }

            // Otherwise it worked, so return the HttpWebResponse.
            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndGetRequestStream", ValidationHelper.HashString(connectStream));
            return connectStream;
        }

        /*
            Accessor:   GetRequestStream

            The request stream property. This property returns a stream that the
            calling application can write on. Getting this property may cause the
            request to be sent, if it wasn't already. Getting this property after
            a request has been sent that doesn't have an entity body causes an
            exception to be thrown. This property is not settable.

            CODEWORK: Handle buffering the data in the case where we're sending
            a request to a server and we don't know the data size or if the server
            is 1.1.

            Input:

            Returns: A stream on which the client can write.


        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.GetRequestStream"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.IO.Stream'/> that the application can use to write request
        ///    data.</para>
        /// </devdoc>
        public override Stream GetRequestStream() {
            if (_SubmitWriteStream != null) {
                return _SubmitWriteStream;
            }

            IAsyncResult asyncResult = BeginGetRequestStream(null, null);

            if (_Timeout!=System.Threading.Timeout.Infinite && !asyncResult.IsCompleted) {
                asyncResult.AsyncWaitHandle.WaitOne(_Timeout, false);
                if (!asyncResult.IsCompleted) {
                    Abort();
                    throw new WebException(SR.GetString(SR.net_timeout), WebExceptionStatus.Timeout);
                }
            }
            return EndGetRequestStream(asyncResult);
        }


        //
        // This read-only propery does a test against the object to verify that
        // we're not sending data with a GET or HEAD, these are dissallowed by the HTTP spec.
        // Returns: true if we allow sending data for this request, false otherwise
        //
        private bool CanGetRequestStream {
            get {
                bool result = !KnownVerbs.GetHttpVerbType(_OriginVerb).m_ContentBodyNotAllowed;
                GlobalLog.Print("CanGetRequestStream("+_OriginVerb+"): " + result);
                return result;
            }
        }

        //
        // This read-only propery does a test against the object to verify if
        // we're allowed to get a Response Stream to read,
        // this is dissallowed per the HTTP spec for a HEAD request.
        // Returns: true if we allow sending data for this request, false otherwise
        //
        internal bool CanGetResponseStream {
            get {
                bool result = !KnownVerbs.GetHttpVerbType(_Verb).m_ExpectNoContentResponse;
                GlobalLog.Print("CanGetResponseStream("+_Verb+"): " + result);
                return result;
            }
        }

        //
        // This read-only propery describes whether we can
        // send this verb without content data.
        // Assumes Method is already set.
        // Returns: true, if we must send some kinda of content
        //
        internal bool RequireBody {
            get {
                bool result = KnownVerbs.GetHttpVerbType(_Verb).m_RequireContentBody;
                GlobalLog.Print("RequireBody("+_Verb+"): " + result);
                return result;
            }
        }

        private bool MissingEntityBodyDelimiter {
            get {
                return KeepAlive && RequireBody && ContentLength==-1 && !SendChunked && !AllowWriteStreamBuffering;
            }
        }

        private bool TransferEncodingWithoutChunked {
            get {
                return !SendChunked && !ValidationHelper.IsBlankString(TransferEncoding);
            }
        }

        private bool ChunkedUploadOnHttp10 { 
            get {
                return SendChunked && _DestinationVersion!=null && _DestinationVersion.Equals(HttpVersion.Version10);
            }
        }

        /*++

            CheckBuffering - Determine if we need buffering based on having no contentlength


                consider the case in which we have no entity body delimiters:
                    RequireBody && ContentLength==-1 && !SendChunked == true

                now we need to consider 3 cases:

                AllowWriteStreamBuffering (1)
                    - buffer internally all the data written to the request stream when the user
                      closes the request stream send it on the wire with a ContentLength

                !AllowWriteStreamBuffering
                    - can't buffer internally all the data written to the request stream
                      so the data MUST go to the wire and the server sees it: 2 cases

                    !KeepAlive (2)
                        - send a "Connection: close" header to the server. the server SHOULD
                          1) send a final response
                          2) read all the data on the connection and treat it as being part of the
                             entity body of this request.

                    KeepAlive (3)
                        - throw, we can't do this, 'cause the server wouldn't know when the data is over.


            Input:
                    None.

            Returns:
                    true if we need buffering, false otherwise.

        --*/

        internal bool CheckBuffering {
            //
            // ContentLength is not set, and user is not chunking, buffering is on
            // so force the code into writing (give the user a stream to write to)
            // and we'll buffer for him
            //
            get {
                bool checkBuffering =
                    RequireBody &&
                    ContentLength==-1 &&
                    !SendChunked &&
                    AllowWriteStreamBuffering &&
                    (_DestinationVersion==null || _DestinationVersion.CompareTo(HttpVersion.Version11)<0);

                GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::CheckBuffering() returns:" + checkBuffering.ToString());

                return checkBuffering;
            }
        }

        // This is a notify from the connection ReadCallback about
        // - error response received and
        // - the KeepAlive status agreed by both sides
        internal void ErrorStatusCodeNotify(Connection connection, bool isKeepAlive) {
            GlobalLog.Print("ErrorStatusCodeNotify:: Connection has reported Error Response Status");
            ConnectStream submitStream = this._SubmitWriteStream;
            if (submitStream != null && submitStream.Connection == connection) {
                submitStream.ErrorResponseNotify(isKeepAlive);
            }
            else {
                GlobalLog.Print("ErrorStatusCodeNotify:: IGNORE connection is not used");
            }
        }


        /*
            Method: DoSubmitRequestProcessing

            Does internal processing of redirect and request retries for authentication
            Assumes that it cannot block, this returns a state var indicating when it
            needs to block

            Assumes that we are never called with a null response

            Input:
                none

            Returns:
                HttpProcessingResult -

        */

        private HttpProcessingResult DoSubmitRequestProcessing() {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::DoSubmitRequestProcessing");
            //
            // OK, the submit request worked. Loop, waiting for a
            // valid response.
            //
            HttpProcessingResult result = HttpProcessingResult.Continue;

            GlobalLog.Assert(_HttpResponse != null, "_HttpResponse==null", "HttpWebRequest::DoSubmitRequestProcessing() should never be called with null response");

            _ProxyAuthenticationState.Update(this);
            _ServerAuthenticationState.Update(this);

            //
            // We have a response of some sort, see if we need to resubmit
            // it do to authentication, redirection or something
            // else, then handle clearing out state and draining out old response.
            //

            try {
                if (CheckResubmit()) {
                    //
                    // we handle upload redirects and auth,
                    // now resubmit request, but we wait
                    // first to make sure the Write of headers is done.
                    //

                    WaitWriteInProgress();    
                    ClearRequestForResubmit();
                    BeginSubmitRequest(true);

                    result = HttpProcessingResult.WriteWait;
                }
            } catch(Exception exception) {
                SetResponse(exception);
                throw;
            }

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::DoSubmitRequestProcessing", result.ToString());
            return result;
        }


        /*
            Accessor:   BeginGetResponse

            Used to query for the Response of an HTTP Request using Async


            Input:

            Returns: The Async Result


        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.BeginGetResponse"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override IAsyncResult BeginGetResponse(AsyncCallback callback, object state) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginGetResponse");

            // prevent someone from setting ContentLength/Chunked, and the doing a Get
            if (_HttpWriteMode!=HttpWriteMode.None && !CanGetRequestStream) {
                throw new ProtocolViolationException(SR.GetString(SR.net_nocontentlengthonget));
            }

            // prevent someone from trying to send data without setting
            // a ContentLength or SendChunked when buffering is disabled and on a KeepAlive connection
            if (MissingEntityBodyDelimiter) {
                throw new ProtocolViolationException(SR.GetString(SR.net_contentlengthmissing));
            }

            // prevent someone from setting a Transfer Encoding without having SendChunked=true
            if (TransferEncodingWithoutChunked) {
                throw new InvalidOperationException(SR.GetString(SR.net_needchunked));
            }

            Monitor.Enter(this);

            if (_ReadAResult != null) {
                Monitor.Exit(this);
                throw new InvalidOperationException(SR.GetString(SR.net_repcall));
            }

            // Set the async object, so we can save it for the callback
            //
            // We do this in an interlocked fashion. The checking and setting of
            // _ReadAResult must be interlocked with the check of _HaveResponse
            // to avoid a race condition with our async receive thread.

            //
            // get async going
            //

            LazyAsyncResult asyncResult =
                new LazyAsyncResult(
                    this,
                    state,
                    callback );

            _ReadAResult = asyncResult;

            // See if we already have a response. If we have, we can
            // just return it.

            if (_HaveResponse) {
                Monitor.Exit(this);

                // Already have a response, so return it if it's valid.

                if (_HttpResponse != null) {
                    try {
                        asyncResult.InvokeCallback(true, _HttpResponse);
                    }
                    catch {
                        Abort();
                        throw;
                    }
                    goto done;
                }
                else {
                    throw _ResponseException;
                }
            }
            else {
                Monitor.Exit(this);
            }

            // If we're here it's because we don't have the response yet. We may have
            // already submitted the request, but if not do so now.

            if (!_RequestSubmitted) {

                // prevent new requests when low on resources
                if (System.Net.Connection.IsThreadPoolLow()) {
                    Abort();
                    throw new InvalidOperationException(SR.GetString(SR.net_needmorethreads));
                }

                // Save Off verb, and use it to make the request
                GlobalLog.Print("HttpWebRequest#"+ValidationHelper.HashString(this)+": setting _Verb to _OriginVerb ["+_OriginVerb+"]");
                _Verb = _OriginVerb;

                // Start request, but don't block
                BeginSubmitRequest(false);

            }

done:
            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginGetResponse", ValidationHelper.HashString(asyncResult));
            return asyncResult;
        }

        /*
            Accessor:   EndGetResponse

            Retreives the Response Result from an HTTP Result after an Async operation
             has completed


            Input:

            Returns: The Response Result


        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.EndGetResponse"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override WebResponse EndGetResponse(IAsyncResult asyncResult) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndGetResponse", ValidationHelper.HashString(asyncResult));
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            LazyAsyncResult castedAsyncResult = asyncResult as LazyAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndGetResponse"));
            }

            //
            // Make sure that the caller has already gotten the request stream if
            // this is a write operation that requires data. Note that we can't
            // make sure he's written enough data, because he might still be
            // writing data on another thread.
            //
            if (_HttpWriteMode != HttpWriteMode.None && !_WriteStreamRetrieved) {
                // It's a write request and he hasn't retrieved the stream yet.
                // If this is a chunked request or a request with a C-L greater
                // than zero, this is an error

                if (_HttpWriteMode == HttpWriteMode.Chunked || _ContentLength > 0) {
                    throw new InvalidOperationException(SR.GetString(SR.net_mustwrite));
                }
            }

            HttpWebResponse httpWebResponse = (HttpWebResponse)castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            CheckFinalStatus();

            GlobalLog.Assert(httpWebResponse.ResponseStream != null, "httpWebResponse.ResponseStream == null", "");

            // Otherwise it worked, so return the HttpWebResponse.
            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndGetResponse", ValidationHelper.HashString(httpWebResponse));
            return httpWebResponse;
        }


        /*
            Accessor:   GetResponse

            The response property. This property returns the WebResponse for this
            request. This may require that a request be submitted first.

            The idea is that we look and see if a request has already been
            submitted. If one has, we'll just return the existing response
            (if it's not null). If we haven't submitted a request yet, we'll
            do so now, possible multiple times while we handle redirects
            etc.

            Input:

            Returns: The WebResponse for this request..


        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.GetResponse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a response from a request to an Internet resource.
        ///    </para>
        /// </devdoc>
        //UEUE

        public override WebResponse GetResponse() {

            if (_HaveResponse) {
                CheckFinalStatus();
                if (_HttpResponse != null) {
                    return _HttpResponse;
                }
            }

            IAsyncResult asyncResult = BeginGetResponse(null, null);

            if (_Timeout!=System.Threading.Timeout.Infinite && !asyncResult.IsCompleted) {
                asyncResult.AsyncWaitHandle.WaitOne(_Timeout, false);
                if (!asyncResult.IsCompleted) {
                    Abort();
                    throw new WebException(SR.GetString(SR.net_timeout), WebExceptionStatus.Timeout);
                }
            }

            return EndGetResponse(asyncResult);
        }

        /*
            Accessor:   Address

            This is just a simple Uri that is returned, indicating the end result
            of the request, after any possible Redirects, etc, that may transpire
            during the request.  This was added to handle this case since RequestUri
            will not change from the moment this Request is created.

            Input:

            Returns: The Uri for this request..


        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Address"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Uri that actually responded to the request.
        ///    </para>
        /// </devdoc>
        public Uri Address {
            get {
                return _Uri;
            }
        }


        /*
            Accessor:   ContinueDelegate

            Returns/Sets Deletegate used to signal us on Continue callback


            Input:

            Returns: The ContinueDelegate.


        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.ContinueDelegate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpContinueDelegate ContinueDelegate {
            get {
                return _ContinueDelegate;
            }
            set {
                _ContinueDelegate = value;
            }
        }



        /*
            Accessor:   SrvPoint

            Returns the service point we're using.

            CODEWORK: Make this do something, like look up the service point if
            we haven't already.

            Input:

            Returns: The service point.


        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.ServicePoint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the service point used for this request.
        ///    </para>
        /// </devdoc>
        public ServicePoint ServicePoint {
            get {
                return FindServicePoint(false);
            }
        }

        /*
            Accessor:   AllowAutoRedirect

            Controls the autoredirect flag.

            Input:  Boolean about whether or not to follow redirects automatically.

            Returns: The service point.


        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.AllowAutoRedirect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables or disables automatically following redirection responses.
        ///    </para>
        /// </devdoc>
        public bool AllowAutoRedirect {
            get {
                return _AllowAutoRedirect;
            }
            set {
                _AllowAutoRedirect = value;
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.MaximumAutomaticRedirections"]/*' />
        /// <devdoc>
        /// </devdoc>
        public int MaximumAutomaticRedirections {
            get {
                return _MaximumAllowedRedirections;
            }
            set {
                if (value <= 0) {
                    throw new ArgumentException(SR.GetString(SR.net_toosmall));
                }
                _MaximumAllowedRedirections = value;
            }
        }

        /*
            Accessor:   Method

            Gets/Sets the http method of this request.
            This method represents the initial origin Verb,
            this is unchanged/uneffected by redirects

            Input:  The method to be used.

            Returns: Method currently being used.


        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Method"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the request method.
        ///    </para>
        /// </devdoc>
        public override string Method {
            get {
                return _OriginVerb;
            }
            set {
                if (ValidationHelper.IsBlankString(value)) {
                    throw new ArgumentException(SR.GetString(SR.net_badmethod));
                }

                if (ValidationHelper.IsInvalidHttpString(value)) {
                    throw new ArgumentException(SR.GetString(SR.net_badmethod));
                }

                _Verb = _OriginVerb = value;
            }
        }

        internal string CurrentMethod {
            get {
                return _Verb;
            }
        }


        
        /*
            Accessor:   KeepAlive

            To the app, this means "I want to use a persistent connection if
            available" if set to true, or "I don't want to use a persistent
            connection", if set to false.

            This accessor allows the application simply to register its
            desires so far as persistence is concerned. We will act on this
            and the pipelined requirement (below) at the point that we come
            to choose or create a connection on the application's behalf

            Read:       returns the sense of the keep-alive request switch

            Write:      set the sense of the keep-alive request switch
        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.KeepAlive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the Keep-Alive header.
        ///    </para>
        /// </devdoc>
        public bool KeepAlive {
            get {
                return _KeepAlive;
            }
            set {
                _KeepAlive = value;
            }
        }

        /*
            Accessor:   Pipelined

            To the app, this means "I want to use pipelining if available" if
            set to true, or "I don't want to use pipelining", if set to false.
            We could infer the state of the keep-alive flag from this setting
            too, but we will decide that only at connection-initiation time.
            If the application sets pipelining but resets keep-alive then we
            will generate a non-pipelined, non-keep-alive request

            Read:       returns the sense of the pipelined request switch

            Write:      sets the sense of the pipelined request switch
        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Pipelined"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of Pipelined property.
        ///    </para>
        /// </devdoc>
        public bool Pipelined {
            get {
                return _Pipelined;
            }
            set {
                _Pipelined = value;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Used Internally to sense if we really can pipeline this request.
        ///    </para>
        /// </devdoc>
        internal bool InternalPipelined {
            get {
                return Pipelined;
            }
            set {
                Pipelined = value;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       True when we're uploading data with a ContentLength.
        ///    </para>
        /// </devdoc>
        internal bool UploadingBufferableData {
            get {
                return(_ContentLength >= 0) && (_HttpWriteMode == HttpWriteMode.Write);
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Credentials"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides authentication information for the request.
        ///    </para>
        /// </devdoc>
        public override ICredentials Credentials {
            get {
                return _AuthInfo;
            }
            set {
                _AuthInfo = value;
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.PreAuthenticate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables or disables pre-authentication.
        ///    </para>
        /// </devdoc>
        public override bool PreAuthenticate {
            get {
                return _PreAuthenticate;
            }
            set {
                _PreAuthenticate = value;
            }
        }

        //
        // ConnectionGroupName - used to control which group
        //  of connections we use, by default should be null
        //
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.ConnectionGroupName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ConnectionGroupName {
            get {
                return _ConnectionGroupName;
            }
            set {
                _ConnectionGroupName = value;
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Headers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A collection of HTTP headers stored as name value pairs.
        ///    </para>
        /// </devdoc>
        public override WebHeaderCollection Headers {
            get {
                return _HttpRequestHeaders;
            }
            set {

                // we can't change headers after they've already been sent
                if ( _RequestSubmitted ) {
                    throw new InvalidOperationException(SR.GetString(SR.net_reqsubmitted));
                }

                WebHeaderCollection webHeaders = value;
                WebHeaderCollection newWebHeaders = new WebHeaderCollection(true);

                // Copy And Validate -
                // Handle the case where their object tries to change
                //  name, value pairs after they call set, so therefore,
                //  we need to clone their headers.
                //

                foreach (String headerName in webHeaders.AllKeys ) {
                    newWebHeaders.Add(headerName,webHeaders[headerName]);
                }

                _HttpRequestHeaders = newWebHeaders;
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Proxy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the proxy information for a request.
        ///    </para>
        /// </devdoc>
        public override IWebProxy Proxy {
            get {
                (new WebPermission(PermissionState.Unrestricted)).Demand();
                return _Proxy;
            }
            set {
                (new WebPermission(PermissionState.Unrestricted)).Demand();
                // we can't change the proxy, while the request is already fired
                if ( _RequestSubmitted ) {
                    throw new InvalidOperationException(SR.GetString(SR.net_reqsubmitted));
                }
                if ( value == null ) {
                    throw new ArgumentNullException("value", SR.GetString(SR.net_nullproxynotallowed));
                }
                _ProxyUserSet = true;
                InternalProxy = value;
            }
        }

        internal IWebProxy InternalProxy {
            get {
                return _Proxy;
            }
            set {
                _Proxy = value;

                // since the service point is based on our proxy, make sure,
                // that we reresolve it
                ServicePoint servicePoint = FindServicePoint(true);
            }
        }

        //
        // SendChunked - set/gets the state of chunk transfer send mode,
        //  if true, we will attempt to upload/write bits using chunked property
        //

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.SendChunked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enable and disable sending chunked data to the server.
        ///    </para>
        /// </devdoc>
        public bool SendChunked {
            get {
                return _HttpWriteMode == HttpWriteMode.Chunked;
            }
            set {
                if (_RequestSubmitted) {
                    throw new InvalidOperationException(SR.GetString(SR.net_writestarted));
                }

                if (value) {
                    _HttpWriteMode = HttpWriteMode.Chunked;
                }
                else {
                    if (_ContentLength >= 0) {
                        _HttpWriteMode = HttpWriteMode.Write;
                    }
                    else {
                        _HttpWriteMode = HttpWriteMode.None;
                    }
                }
            }
        }


        // HTTP Version
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.ProtocolVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets and sets
        ///       the HTTP protocol version used in this request.
        ///    </para>
        /// </devdoc>
        public Version ProtocolVersion {
            get {
                return _Version;
            }
            set {
                if (! value.Equals( HttpVersion.Version10)  &&
                    ! value.Equals( HttpVersion.Version11)) {
                    throw new ArgumentException(SR.GetString(SR.net_wrongversion));
                }
                _Version = new Version(value.Major, value.Minor);
                if (_Version.Equals( HttpVersion.Version10 ))
                    _ExpectContinue = false;
                else
                    _ExpectContinue = true;
            }
        }

        internal Version InternalVersion {
            set {
                _DestinationVersion = value;
            }
        }

        /*
            Accessor:   ContentType

            The property that controls the type of the entity body.

            Input:
                string content-type, on null clears the content-type

            Returns: The value of the content type on get.


        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.ContentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets and sets the value of the Content-Type header.
        ///    </para>
        /// </devdoc>
        public override String ContentType {
            get {
                return _HttpRequestHeaders[HttpKnownHeaderNames.ContentType];
            }
            set {
                SetSpecialHeaders(HttpKnownHeaderNames.ContentType, value);
            }
        }

        // UEUE
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.MediaType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MediaType {
            get {
                return _MediaType;
            }
            set {
                _MediaType = value;
            }
        }


        /*
            Accessor:   TransferEncoding

            The property that controls the transfer encoding header

            Input:
                string transferencoding, null clears the transfer encoding header

            Returns: The value of the TransferEncoding on get.


        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.TransferEncoding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the Transfer-Encoding header.
        ///    </para>
        /// </devdoc>
        public string TransferEncoding {
            get {
                return _HttpRequestHeaders[HttpKnownHeaderNames.TransferEncoding];
            }
            set {
                bool fChunked;

                //
                // on blank string, remove current header
                //
                if (ValidationHelper.IsBlankString(value)) {
                    //
                    // if the value is blank, then remove the header
                    //
                    _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.TransferEncoding);

                    return;
                }

                //
                // if not check if the user is trying to set chunked:
                //

                string newValue = value.ToLower(CultureInfo.InvariantCulture);

                fChunked = (newValue.IndexOf("chunked") != -1);

                //
                // prevent them from adding chunked, or from adding an Encoding without
                //  turing on chunked, the reason is due to the HTTP Spec which prevents
                //  additional encoding types from being used without chunked
                //

                if (fChunked) {
                    throw new ArgumentException(SR.GetString(SR.net_nochunked));
                }
                else if (_HttpWriteMode != HttpWriteMode.Chunked ) {
                    throw new InvalidOperationException(SR.GetString(SR.net_needchunked));
                }
                else {
                    _HttpRequestHeaders.CheckUpdate(HttpKnownHeaderNames.TransferEncoding, value);
                }
            }
        }

        /*
            Accessor:   Connection

            The property that controls the connection header

            Input:
                string Connection, null clears the connection header

            Returns: The value of the connnection on get.

        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Connection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets and sets the value of the Connection header.
        ///    </para>
        /// </devdoc>
        public string Connection {
            get {
                return _HttpRequestHeaders[HttpKnownHeaderNames.Connection];
            }
            set {
                bool fKeepAlive;
                bool fClose;

                //
                // on blank string, remove current header
                //
                if (ValidationHelper.IsBlankString(value)) {
                    _HttpRequestHeaders.Remove(HttpKnownHeaderNames.Connection);
                    return;
                }

                string newValue = value.ToLower(CultureInfo.InvariantCulture);

                fKeepAlive = (newValue.IndexOf("keep-alive") != -1) ;
                fClose =  (newValue.IndexOf("close") != -1) ;

                //
                // Prevent keep-alive and close from being added
                //

                if (fKeepAlive ||
                    fClose) {
                    throw new ArgumentException(SR.GetString(SR.net_connarg));
                }
                else {
                    _HttpRequestHeaders.CheckUpdate(HttpKnownHeaderNames.Connection, value);
                }
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Accept"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the Accept header.
        ///    </para>
        /// </devdoc>
        public string Accept {
            get {
                return _HttpRequestHeaders[HttpKnownHeaderNames.Accept];
            }
            set {
                SetSpecialHeaders(HttpKnownHeaderNames.Accept, value);
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Referer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the Referer header.
        ///    </para>
        /// </devdoc>
        public string Referer {
            get {
                return _HttpRequestHeaders[HttpKnownHeaderNames.Referer];
            }
            set {
                SetSpecialHeaders(HttpKnownHeaderNames.Referer, value);
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.UserAgent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the User-Agent header.
        ///    </para>
        /// </devdoc>
        public string UserAgent {
            get {
                return _HttpRequestHeaders[HttpKnownHeaderNames.UserAgent];
            }
            set {
                SetSpecialHeaders(HttpKnownHeaderNames.UserAgent, value);
            }
        }


        /*
            Accessor:   Expect

            The property that controls the Expect header

            Input:
                string Expect, null clears the Expect except for 100-continue value

            Returns: The value of the Expect on get.

        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Expect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the Expect header.
        ///    </para>
        /// </devdoc>
        public string Expect {
            get {
                return _HttpRequestHeaders[HttpKnownHeaderNames.Expect];
            }
            set {
                // only remove everything other than 100-cont
                bool fContinue100;

                //
                // on blank string, remove current header
                //

                if (ValidationHelper.IsBlankString(value)) {
                    _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.Expect);
                    return;
                }

                //
                // Prevent 100-continues from being added
                //

                string newValue = value.ToLower(CultureInfo.InvariantCulture);

                fContinue100 = (newValue.IndexOf("100-continue") != -1) ;

                if (fContinue100) {
                    throw new ArgumentException(SR.GetString(SR.net_no100));
                }
                else {
                    _HttpRequestHeaders.CheckUpdate(HttpKnownHeaderNames.Expect, value);
                }
            }
        }


        /*
            Accessor:   IfModifiedSince

            The property that reads the IfModifiedSince

            Input:
                DateTime IsModifiedSince, null clears the IfModifiedSince header

            Returns: The value of the IfModifiedSince on get.

        */

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.IfModifiedSince"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the If-Modified-Since
        ///       header.
        ///    </para>
        /// </devdoc>
        public DateTime IfModifiedSince {
            get {
                string ifmodHeaderValue = _HttpRequestHeaders[HttpKnownHeaderNames.IfModifiedSince];

                if (ifmodHeaderValue == null) {
                    return DateTime.Now;
                }

                return HttpProtocolUtils.string2date(ifmodHeaderValue);
            }
            set {
                SetSpecialHeaders(HttpKnownHeaderNames.IfModifiedSince, HttpProtocolUtils.date2string(value));
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.HaveResponse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns <see langword='true'/> if a response has been received from the
        ///       server.
        ///    </para>
        /// </devdoc>
        public bool HaveResponse {
            get {
                return _HaveResponse;
            }
        }

        //
        // This property returns true, after we have notified the caller
        //  that they can post their data.
        //
        internal bool HaveWritten {
            get {
                return _WriteNotifed;
            }
        }

        //
        // This is set on failure of the request before reattempting a retransmit,
        // we do this on write/read failures so that we can recover from certain failures
        // that may be caused by intermittent server/network failures.
        // Returns: true, if we have seen some kind of failure.
        //
        internal bool OnceFailed {
            get {
                return _OnceFailed;
            }
            set {
                _OnceFailed = value;
            }
        }


        internal byte[] WriteBuffer {
            get {
                return _WriteBuffer;
            }
            set {
                _WriteBuffer = value;
            }
        }

        internal bool Aborted {
            get {
                return _Abort;
            }
        }

        //
        // Frequently usedheaders made available as properties,
        //   the following headers add or remove headers taking care
        //   of special cases due to their unquie qualities within
        //   the net handlers,
        //
        //  Note that all headers supported here will be disallowed,
        //    and not accessable through the normal Header objects.
        //

        /*
            Accessor:   SetSpecialHeaders

            Private method for removing duplicate code which removes and
              adds headers that are marked private

            Input:  HeaderName, value to set headers

            Returns: none


        */

        private void SetSpecialHeaders(string HeaderName, string value) {
            value = WebHeaderCollection.CheckBadChars(value, true);

            _HttpRequestHeaders.RemoveInternal(HeaderName);
            if (value.Length != 0) {
                _HttpRequestHeaders.AddInternal(HeaderName, value);
            }
        }

        /*
            Abort - Attempts to abort pending request,

            This calls into the delegate, and then closes any pending streams.

            Input: none

            Returns: none

        */
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.Abort"]/*' />
        public override void Abort()
        {
            _OnceFailed = true;

            //simple re-entrancy detection, nothing to do with a race
            if(_Abort) {
                return;
            }

            _Abort = true;

            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::Abort()");

            _ResponseException = new WebException(
                    NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.RequestCanceled),
                    WebExceptionStatus.RequestCanceled) ;

            _HaveResponse = true;

            ClearAuthenticatedConnectionResources();

            try {
                if ( _AbortDelegate != null ) {
                    _AbortDelegate();
                    _AbortDelegate = null;
                }
            }
            catch {
            }

            try {
                if (_SubmitWriteStream != null) {
                    _SubmitWriteStream.Abort();
                }
            }
            catch {
            }

            try {
                if (_HttpResponse != null) {
                    _HttpResponse.Abort();
                }
            }
            catch {
            }

            if (_WriteInProgress) {
                ResetWriteInProgress();
            }

        }


        /*
            FindServicePoint - Finds the ServicePoint for this request

            This calls the FindServicePoint off of the ServicePointManager
            to determine what ServicePoint to use.  When our proxy changes,
            or there is a redirect, this should be recalled to determine it.

            Input:  forceFind        - regardless of the status, always call FindServicePoint

            Returns: ServicePoint

        */
        private ServicePoint FindServicePoint(bool forceFind)
        {
            ServicePoint servicePoint = _ServicePoint;
            if ( servicePoint == null || forceFind ) {
                lock(this) { 
                    //
                    // we will call FindServicePoint - iff
                    //  - there is no service point ||
                    //  - we are forced to find one, usually due to changes of the proxy or redirection
                    //

                    if ( _ServicePoint == null || forceFind ) {

                        if (!_ProxyUserSet) {
                            _Proxy = GlobalProxySelection.SelectInternal;
                        }

                        _ServicePoint = ServicePointManager.FindServicePoint(_Uri, _Proxy);
                    }
                }
                servicePoint = _ServicePoint;                
            }

            return servicePoint;
        }

        /*
            InvokeGetRequestStreamCallback - Notify our GetRequestStream caller

            This is needed to tell our caller that we're finished,
            and he can go ahead and write to the stream.
        */
        private void InvokeGetRequestStreamCallback(bool signalled) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::InvokeGetRequestStreamCallback", signalled.ToString());

            LazyAsyncResult asyncResult = _WriteAResult;

            GlobalLog.Assert( // check that this is the correct request
                asyncResult == null || this == (HttpWebRequest)asyncResult.AsyncObject,
                "InvokeGetRequestStreamCallback: this != asyncResult.AsyncObject", "");

            GlobalLog.Assert( // check that the event didn't already complete
                asyncResult == null || !asyncResult.IsCompleted,
                "InvokeGetRequestStreamCallback: asyncResult already completed!", "");

            if (asyncResult != null) {
                _WriteAResult = null;

                // It's done now, mark it as completed.
                // Otherwise it worked, so return the stream.

                try {
                    asyncResult.InvokeCallback(!signalled, _SubmitWriteStream);
                }
                catch (Exception exception) {
                    Abort();
                    GlobalLog.LeaveException("HttpWebRequest#" + ValidationHelper.HashString(this) + "::InvokeGetRequestStreamCallback", exception);
                    throw;
                }
            }

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::InvokeGetRequestStreamCallback", "success");
        }

        /*
            RequestSubmitDone - Handle submit done callback.

            This is our submit done handler, called by the underlying connection
            code when a stream is available for our use. We save the stream for
            later use and signal the wait event.

            We also handle the continuation/termination of a BeginGetRequestStream,
            by saving out the result and calling its callback if needed.

            Input:  SubmitStream        - The stream we may write on.
                    Status              - The status of the submission.

            Returns: Nothing.

        */
        internal void SetRequestSubmitDone(ConnectStream submitStream) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetRequestSubmitDone", ValidationHelper.HashString(submitStream));

            if (_Abort) {
                try {
                    submitStream.Abort();
                }
                catch {
                }

                GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetRequestSubmitDone", "ABORT");
                return;
            }

             //This state should be set before invoking the callback
             //otherwise extra request will be issued without any
             //particular reason.

            _RequestSubmitted = true;

            if (AllowWriteStreamBuffering) {
                submitStream.EnableWriteBuffering();
            }

            submitStream.Timeout = ReadWriteTimeout;
            _SubmitWriteStream = submitStream;

            // Finish the submission of the request. If the asyncResult now
            // isn't null, mark it as completed.

            WebExceptionStatus Error = EndSubmitRequest();

            if (Error != WebExceptionStatus.Pending) {

                // check for failure
                if (Error != WebExceptionStatus.Success) {
                    // OK, something happened on the request, close down everything

                    if (Error != WebExceptionStatus.SendFailure) {
                        Abort();
                    } else {
                        // On SendFailure, we attempt not to Abort anything
                        // since we may later try to recover from this failure
                        // ASSUME: that WriteStream is closed by virtue of error
                        try {
                            if (_HttpResponse != null) {
                                _HttpResponse.Close();
                            }
                        }
                        catch {
                        }
                    }
                }

                // wake up any pending waits to write, since this is an error
                if ( _WriteEvent != null ) {
                    GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetRequestSubmitDone() calling _WriteEvent.Set()");
                    _WriteEvent.Set();
                }
            } // != Pending

            //
            // !!!! WARNING !!!!
            // do not add new code here, unless the WriteInProgress flag is set, or
            // the objects used are not effected by changes made to HttpWebRequest on 
            // another thread.
            //

            if (_Abort) {
                try {
                    submitStream.Abort();
                }
                catch {
                }
            }

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetRequestSubmitDone");
        }

        internal bool BufferHeaders {
            get {
                return RequireBody && ContentLength==-1 && !SendChunked && AllowWriteStreamBuffering;
            }
        }

        /*
            SetRequestContinue - Handle 100-continues on Posting

            This indicates to us that we need to continue posting,
            and there is no need to buffer because we are now

            Input:  Nothing

            Returns: Nothing.

        */
        internal void SetRequestContinue() {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetRequestContinue()");

            if (_AcceptContinue) {
                //_AckContinue = true;
                if ( _WriteEvent != null ) {
                    GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetRequestContinue() calling _WriteEvent.Set()");
                    _WriteEvent.Set();
                }
            }

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetRequestContinue");
        }

        /*++

        Routine Description:

            Wakes up blocked threads, so they can read response object,
              from the result

            We also handle the continuation/termination of a BeginGetResponse,
            by saving out the result and calling its callback if needed.

        Arguments:

            coreData - Contains the data used to create the Response object
            exception - true if we're allowed to throw an exception on error

        Return Value:

            none

        --*/
        internal void SetResponse(CoreResponseData coreResponseData) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse", "*** SETRESP ***");

            //
            // Since we are no longer attached to this Connection,
            // we null out our abort delegate.
            //

            _AbortDelegate = null;

            try {
                if (coreResponseData != null) {
                    coreResponseData.m_ConnectStream.Timeout = ReadWriteTimeout;
                    _HttpResponse = new HttpWebResponse(_Uri, _Verb, coreResponseData, _MediaType, UsesProxySemantics);
                    coreResponseData = null;
                }
                else {

                    //
                    // not sure how this would happen, but we should not throw an exception,
                    //  which we were earlier doing.
                    //

                    GlobalLog.Assert(false,
                                 "coreResponseData == null",
                                 "");

                   
                    GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse", "ASSERT");
                    return;
                }

                //
                // give apps the chance to examine the headers of the new response
                //

                if (_CookieContainer != null) {
                    CookieModule.OnReceivedHeaders(this);
                }

                // New Response

                HttpProcessingResult httpResult = HttpProcessingResult.Continue;

                // handle redirects, authentication, and such
                httpResult = DoSubmitRequestProcessing();

                if (httpResult == HttpProcessingResult.Continue) {
                    //
                    // Now grab crit sec here, before returning,
                    //  this is to prevent some one from reading
                    //  ReadAResult it as null before we finish
                    //  processing our response
                    //

                    LazyAsyncResult asyncResult = null;
                    lock(this) 
                    {
                        asyncResult = _ReadAResult;

                        GlobalLog.Assert(asyncResult == null || this == (HttpWebRequest)asyncResult.AsyncObject,
                                     "SetResponse: this != asyncResult.AsyncObject",
                                     "");

                        GlobalLog.Assert(asyncResult == null || !asyncResult.IsCompleted, "SetResponse: asyncResult already completed!", "");

                        _HaveResponse = true;

                        if (asyncResult != null) {
                            _ReadAResult = null;
                        }
                    }

                    if (asyncResult != null) {
                        asyncResult.InvokeCallback(false, _HttpResponse);
                    }

                    if ( _WriteEvent != null ) {
                        GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse(CoreResponseData) calling _WriteEvent.Set()");
                        _WriteEvent.Set();
                    }
                }
            } catch (Exception exception) { 
                Abort();
                GlobalLog.LeaveException("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse", exception);
                throw;
            }

            if (_Abort) {
                try {
                    if ( _HttpResponse != null ) {
                        _HttpResponse.Abort();
                    }
                }
                catch {
                }

                GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse", "ABORT");
                return;
            }

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse");
        }

        /*++

        Routine Description:

            Wakes up blocked threads, so they can throw exceptions.

        Arguments:

            None.

        Return Value:

            HttpWebResponse

        --*/
        internal void SetResponse(Exception E) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse", E.ToString() + "/*** SETRESPONSE IN ERROR ***");

            //
            // Since we are no longer attached to this Connection,
            // we null out our abort delegate.
            //
            _AbortDelegate = null;

            ClearAuthenticatedConnectionResources();

            if ( _WriteEvent != null ) {
                GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse(Exception) calling _WriteEvent.Set()");
                _WriteEvent.Set();
            }

            if ((E as WebException) == null) {
                if (_HttpResponse==null) {
                    E = new WebException(E.Message, E);
                }
                else {
                    E = new WebException(
                        SR.GetString(
                            SR.net_servererror,
                            NetRes.GetWebStatusCodeString(
                                ResponseStatusCode,
                                _HttpResponse.StatusDescription)),
                        E,
                        WebExceptionStatus.ProtocolError,
                        _HttpResponse );
                }
            }

            _ResponseException = E;

            // grab crit sec to protect BeginGetResponse/EndGetResponse code path
            Monitor.Enter(this);

            _HaveResponse = true;

            LazyAsyncResult writeAsyncResult = _WriteAResult;
            LazyAsyncResult readAsyncResult = _ReadAResult;

            _WriteAResult = null;
            _ReadAResult = null;

            Monitor.Exit(this);

            if (writeAsyncResult != null) {
                writeAsyncResult.InvokeCallback(false);
            }
            if (readAsyncResult != null) {
                readAsyncResult.InvokeCallback(false);
            }

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::SetResponse");
        }

        /*++

            BeginSubmitRequest: Begins Submit off a request to the network.

            This is called when we need to transmit an Async Request, but
            this function only servers to activate the submit, and does not
            actually block

            Called when we want to submit a request to the network. We do several
            things here - look for a proxy, find the service point, etc. In the
            end we call the service point to get access (via a stream) to the
            underlying connection, then serialize our headers onto that connection.
            The actual submission request to the service point is async, so we
            submit the request and then return, to allow the async to run its course.

            Input:
                forceFind - insures that always get a new ServicePoint,
                    needed on redirects, or where the ServicePoint may have changed

            Returns: Nothing

        --*/

        private void BeginSubmitRequest(bool forceFind) {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginSubmitRequest", forceFind.ToString());
            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + " " + Method + " " + Address);

            if (_Uri.Scheme == Uri.UriSchemeHttps) {
                ServicePointManager.GetConfig();
            }

            //DELEGATION: This is the place when user cannot add any credentials to the cache
            // Still we are in the main thread!
            // Now the time to decide do we need Delegation fix for this HTTP request
            if (!_RequestSubmitted) {
                CredentialCache cache;
                // Skip the fix if no credentials are used or they don't include a default one.
                if (_AuthInfo != null &&
                    (_AuthInfo is SystemNetworkCredential || ((cache = _AuthInfo as CredentialCache) != null  && cache.IsDefaultInCache))) {
                    m_DelegationFix = new DelegationFix();
                    GlobalLog.Print("DELEGATION: Created a Fix, Token = " + m_DelegationFix.Token.ToString());
                }
            }
            if (_SubmitWriteStream!=null) {
                long writeBytes = _SubmitWriteStream.BytesLeftToWrite;

                GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginSubmitRequest() _OldSubmitWriteStream:" + ValidationHelper.HashString(_OldSubmitWriteStream) + " _SubmitWriteStream:" + ValidationHelper.HashString(_SubmitWriteStream) + " writeBytes:" + writeBytes.ToString());

                // _OldSubmitWriteStream is the stream that holds real user data
                // In no case it can be overwritten.
                // For multiple resubmits the ContentLength was set already, so no need call it again.
                if (writeBytes == 0 && _OldSubmitWriteStream == null) { 
                    //
                    // we're resubmitting a request with an entity body
                    //
                    _OldSubmitWriteStream = _SubmitWriteStream;
                    if (_HttpWriteMode != HttpWriteMode.None) {
                        SetContentLength(_OldSubmitWriteStream.BufferedData.Length);
                    }
                    WriteBuffer = null;
                }
                else {
                    GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginSubmitRequest() got a _SubmitWriteStream.WriteBytes:" + writeBytes.ToString());
                }
            }

            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginSubmitRequest() _HaveResponse:" + _HaveResponse.ToString());
            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginSubmitRequest() _RequestSubmitted:" + _RequestSubmitted.ToString());
            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginSubmitRequest() Saw100Continue:" + Saw100Continue.ToString());

            // if we're submitting then we don't have a response
            _HaveResponse = false;
            _RequestSubmitted = true;

            ServicePoint servicePoint = FindServicePoint(forceFind);
            _ExpectContinue = _ExpectContinue && servicePoint.Expect100Continue;


            if ((_HttpWriteMode != HttpWriteMode.None) && (_WriteEvent == null)) {
                // don't create a WriteEvent until we are doing a Write
                GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginSubmitRequest() lazy allocation of _WriteEvent");
                _WriteEvent = new AutoResetEvent(false);
            }

            // _AbortDelegate gets set on submission process.
            servicePoint.SubmitRequest(this, GetConnectionGroupLine());            

            // prevent someone from sending chunked to a HTTP/1.0 server
            if (ChunkedUploadOnHttp10) {
                Abort();
                throw new ProtocolViolationException(SR.GetString(SR.net_nochunkuploadonhttp10));
            }

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::BeginSubmitRequest");
        }

        /*++

            EndSubmitRequest: End Submit off a request

            This Typically called by a callback that wishes to proced
             with the request that it issued before going async. This function
             continues by submitting Headers.  Assumes calling will block
             on ReadEvent to retrive response from server.

            Input: Nothing.

            Returns: Nothing

        --*/

        internal WebExceptionStatus EndSubmitRequest() {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndSubmitRequest");

            ConnectStream SubmitWriteStream = _SubmitWriteStream;

            if (SubmitWriteStream == null) {
                // An error on the submit request, so fail this.
                // Some sort of error on the submit request.

                GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndSubmitRequest", WebExceptionStatus.ProtocolError.ToString());
                return WebExceptionStatus.ProtocolError;
            }

            //
            // check to see if we need to buffer the headers and send them at
            // a later time, when we know content length
            //
            if (BufferHeaders) {
                InvokeGetRequestStreamCallback(false);
                GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndSubmitRequest", "InvokeGetRequestStreamCallback(BufferHeaders)");
                return WebExceptionStatus.Pending;
            }

            // waiting for a continue
            _AcceptContinue = true;

            // gather headers and write them to the stream
            if (WriteBuffer==null) {
                // if needed generate the headers
                // WriteBuffer might have been set to null by BeginSubmitRequest() if
                // resubmitting and headers have been changed (chunking, content length)
                MakeRequest();
            }

            GlobalLog.Assert(WriteBuffer != null && WriteBuffer[0] < 0x80 && WriteBuffer[0] != 0x0,
                             "HttpWebRequest::EndSubmitRequest Invalid WriteBuffer generated", "");

            SetWriteInProgress();
            WebExceptionStatus webExceptionStatus = SubmitWriteStream.WriteHeaders(this);
            ResetWriteInProgress();

            //
            // !!!! WARNING !!!!
            // do not add new code here, unless the WriteInProgress flag is set, or
            // the objects used are not effected by changes made to HttpWebRequest on 
            // another thread.
            //

            // we return pending, because the Connection code will handle this error, not us.
            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndSubmitRequest", webExceptionStatus.ToString());
            return webExceptionStatus;
        }

        private class EndWriteHeadersStatus {
            internal HttpWebRequest Request;
            internal int RerequestCount;

            internal EndWriteHeadersStatus(HttpWebRequest webRequest, int reRequestCount) {
                this.Request = webRequest;
                this.RerequestCount = reRequestCount;
            }
        }


        /*++

            EndWriteHeaders: End write of headers

            This Typically called by a callback that wishes to proceed
             with the finalization of writing headers

            Input: Nothing.

            Returns: bool - true if success, false if we need to go pending

        --*/
        internal bool EndWriteHeaders() {
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndWriteHeaders");
            //
            // if sending data and we sent a 100-continue to a 1.1 or better
            // server then synchronize with the 100-continue intermediate
            // response (or a final failure response)
            //
            _WriteNotifed = true;

            if (_HttpWriteMode!=HttpWriteMode.None && (_ContentLength!=0 || _HttpWriteMode == HttpWriteMode.Chunked) && _ServicePoint.Understands100Continue && _ExpectContinue) {
                if (!_WriteEvent.WaitOne(0, false)) {
                    //
                    // if the event wasn't already signaled, queue invocation to a ThreadPool's worker thread.
                    //
                    GlobalLog.Print("#" + GetHashCode() + ": *** registering " + DefaultContinueTimeout + "mSec wait for _WriteEvent");

                    ThreadPool.RegisterWaitForSingleObject(
                        _WriteEvent,
                        m_EndWriteHeaders_Part2Callback,
                        new EndWriteHeadersStatus(this, _RerequestCount),
                        DefaultContinueTimeout,
                        true
                        );

                    GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndWriteHeaders", false);
                    return false;
                }

                GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndWriteHeaders() *** _WriteEvent already signalled");
            }
            EndWriteHeaders_Part2(this, false);

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::EndWriteHeaders", true);
            return true;
        }

        private static void EndWriteHeaders_Part2(object state, bool signalled) {
            HttpWebRequest thisHttpWebRequest = state as HttpWebRequest;

            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(thisHttpWebRequest) + "::EndWriteHeaders_Part2", ValidationHelper.ToString(state) + "#" + ValidationHelper.HashString(state));

            if (thisHttpWebRequest == null) {
                int reRequestCount;
                EndWriteHeadersStatus endWriteStatus = state as EndWriteHeadersStatus;
                thisHttpWebRequest = endWriteStatus.Request;
                reRequestCount     = endWriteStatus.RerequestCount;

                // if another request was fired off since this one, then we need to ignore this callback
                if (reRequestCount != thisHttpWebRequest._RerequestCount) {
                    GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(thisHttpWebRequest) + "::EndWriteHeaders_Part2", "ignoring:" + reRequestCount.ToString());
                    return;
                }
            }            

            ConnectStream submitWriteStream = thisHttpWebRequest._SubmitWriteStream;

            GlobalLog.Print("EndWriteHeaders_Part2() ConnectStream#" + ValidationHelper.HashString(submitWriteStream) + " _HttpWriteMode:" + thisHttpWebRequest._HttpWriteMode + " _AcceptContinue:" + thisHttpWebRequest._AcceptContinue + " _HaveResponse:" + thisHttpWebRequest._HaveResponse);

            thisHttpWebRequest._AcceptContinue = false;

            if (thisHttpWebRequest._HttpWriteMode != HttpWriteMode.None) {

                GlobalLog.Assert(submitWriteStream != null, "HttpWebRequest::EndWriteHeaders_Part2() submitWriteStream == null", "");

                //
                // if we think that the server will send us a 100 Continue, but this time we
                // didn't get it in the DefaultContinueTimeout timeframe, we switch behaviour
                //
                if (thisHttpWebRequest._ExpectContinue && // if user didn't disable our behavior
                    !thisHttpWebRequest.Saw100Continue && // if we didn't see a 100 continue for this request at all
                    thisHttpWebRequest._ServicePoint.Understands100Continue && // and the service point understood 100 continue so far
                    !thisHttpWebRequest._WriteEvent.WaitOne(0, false)) { // and the wait timed out (>350ms)
                    //
                    // turn off expectation of 100 continue (we'll keep sending an
                    // "Expect: 100-continue" header to a 1.1 server though)
                    //
                    if (thisHttpWebRequest._HttpResponse==null || (int)thisHttpWebRequest._HttpResponse.StatusCode<=(int)HttpStatusRange.MaxOkStatus) {
                        GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(thisHttpWebRequest) + " ServicePoint#" + ValidationHelper.HashString(thisHttpWebRequest._ServicePoint) + " NO expected 100 Continue");
                        // we reduce the window for a race condition where the reader thread might have seen the 100 continue but we
                        // would turn it off here (the benefit of fixing the race making the assignment atomic is not worth the cost).
                        thisHttpWebRequest._ServicePoint.Understands100Continue = thisHttpWebRequest.Saw100Continue;
                    }
                }
                //
                // This is so lame, we need to Always buffer, because some
                //  servers send 100 Continue EVEN WHEN THEY MEAN TO REDIRECT,
                //  so we waste the cycles with buffering
                //
                GlobalLog.Print("EndWriteHeaders_Part2() AllowWriteStreamBuffering:" + thisHttpWebRequest.AllowWriteStreamBuffering);

                if (thisHttpWebRequest.AllowWriteStreamBuffering) {

                    GlobalLog.Print("EndWriteHeaders_Part2() BufferOnly:" + submitWriteStream.BufferOnly + " _OldSubmitWriteStream#" + ValidationHelper.HashString(thisHttpWebRequest._OldSubmitWriteStream) + " submitWriteStream#" + ValidationHelper.HashString(submitWriteStream));

                    if (submitWriteStream.BufferOnly) {
                        //
                        // if the ConnectStream was buffering the headers then
                        // there will not be an OldSubmitWriteStream. set it
                        // now to the newly created one.
                        //
                        thisHttpWebRequest._OldSubmitWriteStream = submitWriteStream;
                    }

                    GlobalLog.Print("EndWriteHeaders_Part2() _OldSubmitWriteStream#" + ValidationHelper.HashString(thisHttpWebRequest._OldSubmitWriteStream));

                    if (thisHttpWebRequest._OldSubmitWriteStream != null) {
                        submitWriteStream.ResubmitWrite(thisHttpWebRequest._OldSubmitWriteStream);
                        submitWriteStream.CloseInternal(true);
                    }
                }
            }
            else { // if (_HttpWriteMode == HttpWriteMode.None) {
                if (submitWriteStream != null) {
                    // close stream so the headers get sent
                    submitWriteStream.CloseInternal(true);
                    // disable write stream
                    submitWriteStream = null;
                }
                thisHttpWebRequest._OldSubmitWriteStream = null;
            }

            // callback processing - notify our caller that we're done
            thisHttpWebRequest.InvokeGetRequestStreamCallback(signalled);

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(thisHttpWebRequest) + "::EndWriteHeaders_Part2");
        }

        /*++

        Routine Description:

            Assembles the status line for an HTTP request
             specifically for CONNECT style verbs, that create a pipe

        Arguments:

            headersSize - size of the Header string that we send after
                this request line

        Return Value:

            int - number of bytes written out

        --*/
        private int GenerateConnectRequestLine(int headersSize) {
            int offset = 0;
            string host = ConnectHostAndPort;

            //
            // Handle Connect Case, i.e. "CONNECT hostname.domain.edu:999"
            //

            int writeBufferLength = _Verb.Length +
                                    host.Length +
                                    RequestLineConstantSize +
                                    headersSize;

            WriteBuffer = new byte[writeBufferLength];
            offset = Encoding.ASCII.GetBytes(_Verb, 0, _Verb.Length, WriteBuffer, 0);
            WriteBuffer[offset++] = (byte)' ';
            offset += Encoding.ASCII.GetBytes(host, 0, host.Length, WriteBuffer, offset);
            WriteBuffer[offset++] = (byte)' ';
            return offset;
        }

        internal virtual string ConnectHostAndPort {
            get {
                return _Uri.Host+":"+_Uri.Port;
            }
        }

        internal virtual bool ShouldAddHostHeader {
            get {
                return true;
            }
        }

        /*++

        Routine Description:

            Assembles the status line for an HTTP request
             specifically to a proxy...

        Arguments:

            headersSize - size of the Header string that we send after
                this request line

        Return Value:

            int - number of bytes written out

        --*/
        private int GenerateProxyRequestLine(int headersSize) {
            int offset = 0;
            string PortString = (_Uri.Port == _Uri.DefaultPortForScheme(_Uri.Scheme))
                                ? string.Empty : (":" + _Uri.Port.ToString("D"));

            //
            // Handle Proxy Case, i.e. "GET http://hostname-outside-of-proxy.somedomain.edu:999"
            // consider handling other schemes
            //
            string Scheme = "http://";

            int writeBufferLength = _Verb.Length +
                                 Scheme.Length + // http://
                                 _Uri.Host.Length +
                                 PortString.Length +  // i.e. :900
                                 _Uri.PathAndQuery.Length +
                                 RequestLineConstantSize +
                                 headersSize;

            WriteBuffer = new byte[writeBufferLength];
            offset = Encoding.ASCII.GetBytes(_Verb, 0, _Verb.Length, WriteBuffer, 0);
            WriteBuffer[offset++] = (byte)' ';
            offset += Encoding.ASCII.GetBytes(Scheme, 0, Scheme.Length, WriteBuffer, offset);
            offset += Encoding.ASCII.GetBytes(_Uri.Host, 0, _Uri.Host.Length, WriteBuffer, offset);
            offset += Encoding.ASCII.GetBytes(PortString, 0, PortString.Length, WriteBuffer, offset);
            offset += Encoding.ASCII.GetBytes(_Uri.PathAndQuery, 0, _Uri.PathAndQuery.Length, WriteBuffer, offset);
            WriteBuffer[offset++] = (byte)' ';
            return offset;
        }

        /*++

        Routine Description:

            Assembles the status/request line for the request.

        Arguments:

            headersSize - size of the Header string that we send after
                this request line

        Return Value:

            int - number of bytes written

        --*/
        private int GenerateRequestLine(int headersSize) {
            int offset = 0;

            int writeBufferLength =
                _Verb.Length +
                _Uri.PathAndQuery.Length +
                RequestLineConstantSize +
                headersSize;

            WriteBuffer = new byte[writeBufferLength];
            offset = Encoding.ASCII.GetBytes(_Verb, 0, _Verb.Length, WriteBuffer, 0);
            WriteBuffer[offset++] = (byte)' ';
            offset += Encoding.ASCII.GetBytes(_Uri.PathAndQuery, 0, _Uri.PathAndQuery.Length, WriteBuffer, offset);
            WriteBuffer[offset++] = (byte)' ';
            return offset;
        }

        /*++

        Routine Description:

            Assembles the data/headers for an HTTP request
             into a buffer

        Arguments:

            none.

        Return Value:

            none.

        --*/
        private void MakeRequest() {
            //
            // If we have content-length, use it, if we don't check for chunked
            //  sending mode, otherwise, if -1, then see to closing the connecition.
            // There's one extra case in which the user didn't set the ContentLength and is
            //  not chunking either. In this case we buffer the data and we'll send the
            //  ContentLength on re-write (see ReWrite());
            //
            GlobalLog.Enter("HttpWebRequest#" + ValidationHelper.HashString(this) + "::MakeRequest");

            int offset;

            if (_HttpWriteMode == HttpWriteMode.Write && _ContentLength != -1 && !KnownVerbs.GetHttpVerbType(_Verb).m_ContentBodyNotAllowed) {
                _HttpRequestHeaders.ChangeInternal(HttpKnownHeaderNames.ContentLength, _ContentLength.ToString());
            }
            else if (_HttpWriteMode == HttpWriteMode.Chunked) {
                _HttpRequestHeaders.AddInternal( HttpKnownHeaderNames.TransferEncoding, "chunked");
            }

            if (_ExpectContinue && ( _HttpWriteMode == HttpWriteMode.Chunked || _ContentLength > 0 )) {
                _HttpRequestHeaders.AddInternal( HttpKnownHeaderNames.Expect, "100-continue");
            }

#if TRAVE            
            _HttpRequestHeaders.Set("Cur-Hash-ID", GetHashCode().ToString());
            _HttpRequestHeaders.AddInternal("Hash-ID", GetHashCode().ToString());
#endif

            //
            // Behavior from Wininet, on Uris with Proxies, send Proxy-Connection: instead
            //  of Connection:
            //
            string connectionString = HttpKnownHeaderNames.Connection;
            if (UsesProxySemantics) {
                _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.Connection);
                connectionString = HttpKnownHeaderNames.ProxyConnection;
                if (!ValidationHelper.IsBlankString(Connection)) {
                    _HttpRequestHeaders.AddInternal(HttpKnownHeaderNames.ProxyConnection, _HttpRequestHeaders[HttpKnownHeaderNames.Connection]);
                }
            } else {
                _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.ProxyConnection);
            }

            if (_KeepAlive) {

                GlobalLog.Assert(_ServicePoint != null,
                             "MakeRequest: _ServicePoint == NULL",
                             "");

                if (_DestinationVersion == null ||
                    _Version.Equals( HttpVersion.Version10 ) ||
                    _DestinationVersion.Equals( HttpVersion.Version10 )) {
                    _HttpRequestHeaders.AddInternal( connectionString, "Keep-Alive");
                }
            }
            else {
                if (_Version.Equals( HttpVersion.Version11 )) {
                    _HttpRequestHeaders.AddInternal( connectionString, "Close");
                }
            }

            // Set HostName Header
            if (ShouldAddHostHeader) {
                _HttpRequestHeaders.ChangeInternal( HttpKnownHeaderNames.Host, (_Uri.IsDefaultPort ? _Uri.Host : ConnectHostAndPort));
            }

            // If pre-authentication is requested call the AuthenticationManager
            // and add authorization header if there is response
            if (PreAuthenticate) {
                if (UsesProxySemantics && _Proxy.Credentials!=null) {
                    _ChallengedUri = ServicePoint.Address;
                    _ProxyAuthenticationState.PreAuthIfNeeded(this, _Proxy.Credentials);
                }
                if (_AuthInfo!=null) {
                    _ChallengedUri = _Uri;
                    _ServerAuthenticationState.PreAuthIfNeeded(this, _AuthInfo);
                }
            }

            //
            // about to create the headers we're going to send. Check if any
            // modules want to inspect or modify them
            //

            if (_CookieContainer != null) {
                CookieModule.OnSendingHeaders(this);
            }

            //
            // Now create our headers by calling ToString, and then
            //   create a HTTP Request Line to go with it.
            //

            string requestHeadersString = _HttpRequestHeaders.ToString();
            int requestHeadersSize = WebHeaderCollection.HeaderEncoding.GetByteCount(requestHeadersString);

            // NOTE: Perhaps we should cache this on this-object in the future?
            HttpVerb httpVerbType = KnownVerbs.GetHttpVerbType(_Verb);
            
            if (httpVerbType.m_ConnectRequest) {
                // for connect verbs we need to specially handle it.
                offset = GenerateConnectRequestLine(requestHeadersSize);
            }
            else if (UsesProxySemantics) {                
                // depending on whether, we have a proxy, generate a proxy or normal request
                offset = GenerateProxyRequestLine(requestHeadersSize);
            }
            else {
                // default case for normal HTTP requests
                offset = GenerateRequestLine(requestHeadersSize);
            }

            Buffer.BlockCopy(HttpBytes, 0, WriteBuffer, offset, HttpBytes.Length);
            offset += HttpBytes.Length;

            WriteBuffer[offset++] = (byte)('0' + _Version.Major);
            WriteBuffer[offset++] = (byte)'.';
            WriteBuffer[offset++] = (byte)('0' + _Version.Minor);
            WriteBuffer[offset++] = (byte)'\r';
            WriteBuffer[offset++] = (byte)'\n';

            //
            // Serialze the headers out to the byte Buffer,
            //   by converting them to bytes from UNICODE
            //
            WebHeaderCollection.HeaderEncoding.GetBytes(requestHeadersString, 0, requestHeadersString.Length, WriteBuffer, offset);

            GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(this) + "::MakeRequest", offset.ToString());
        }

        /*++

        Routine Description:

            Basic Constructor for HTTP Protocol Class,
              initalizes to basic header state.

        Arguments:

            Uri     - Uri object for which we're creating.

        Return Value:

            None.

        --*/
        //
        // PERF:
        // removed some double initializations.
        // perf went from:
        // clocks per instruction CPI: 9,098.72 to 1,301.14
        // %app exclusive time: 2.92 to 0.43
        //
        internal HttpWebRequest(Uri uri) {
            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::.ctor(" + uri.ToString() + ")");
            //
            // internal constructor, HttpWebRequest cannot be created directly
            // but only through WebRequest.Create() method
            // set defaults
            //
            _HttpRequestHeaders         = new WebHeaderCollection(true);
            _Proxy                      = GlobalProxySelection.SelectInternal;
            _KeepAlive                  = true;
            _Pipelined                  = true;
            _AllowAutoRedirect          = true;
            _AllowWriteStreamBuffering  = true;
            _HttpWriteMode              = HttpWriteMode.None;
            _MaximumAllowedRedirections = 50;
            _Timeout                    = WebRequest.DefaultTimeout;
            _ReadWriteTimeout           = DefaultReadWriteTimeout;
            _MaximumResponseHeadersLength = DefaultMaximumResponseHeadersLength;
            _ContentLength              = -1;
            _OriginVerb                 = "GET";
            _Verb                       = _OriginVerb;
            _Version                    = HttpVersion.Version11;
            _OriginUri                  = uri;

#if HTTP_HEADER_EXTENSIONS_SUPPORTED
            _NextExtension      = 10;
#endif // HTTP_HEADER_EXTENSIONS_SUPPORTED
            CreateDefaultObjects();
        }

        private void CreateDefaultObjects() {
            _Uri                        = _OriginUri;
            _ProxyAuthenticationState   = new AuthenticationState(true);
            _ServerAuthenticationState  = new AuthenticationState(false);

#if COMNET_HTTPPERFCOUNTER
            NetworkingPerfCounters.IncrementHttpWebRequestCreated();
#endif // COMNET_HTTPPERFCOUNTER
        }


        //
        // ISerializable constructor
        //
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.HttpWebRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter =true)]
        protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext) {

            new WebPermission(PermissionState.Unrestricted).Demand();

            _HttpRequestHeaders = (WebHeaderCollection)serializationInfo.GetValue("_HttpRequestHeaders", typeof(WebHeaderCollection));
            _Proxy                      = (IWebProxy)serializationInfo.GetValue("_Proxy", typeof(IWebProxy));
            _KeepAlive                  = serializationInfo.GetBoolean("_KeepAlive");
            _Pipelined                  = serializationInfo.GetBoolean("_Pipelined");
            _AllowAutoRedirect          = serializationInfo.GetBoolean("_AllowAutoRedirect");
            _AllowWriteStreamBuffering  = serializationInfo.GetBoolean("_AllowWriteStreamBuffering");
            _HttpWriteMode              = (HttpWriteMode)serializationInfo.GetInt32("_HttpWriteMode");
            _MaximumAllowedRedirections = serializationInfo.GetInt32("_MaximumAllowedRedirections");
            _AutoRedirects              = serializationInfo.GetInt32("_AutoRedirects");
            _Timeout                    = serializationInfo.GetInt32("_Timeout");
            try {
                _ReadWriteTimeout       = serializationInfo.GetInt32("_ReadWriteTimeout");
            }
            catch {
                _ReadWriteTimeout       = DefaultReadWriteTimeout;
            }
            try {
                _MaximumResponseHeadersLength = serializationInfo.GetInt32("_MaximumResponseHeadersLength");
            }
            catch {
                _MaximumResponseHeadersLength = DefaultMaximumResponseHeadersLength;
            }
            _ContentLength              = serializationInfo.GetInt64("_ContentLength");
            _MediaType                  = serializationInfo.GetString("_MediaType");
            _OriginVerb                 = serializationInfo.GetString("_OriginVerb");
            _ConnectionGroupName        = serializationInfo.GetString("_ConnectionGroupName");
            _Version                    = (Version)serializationInfo.GetValue("_Version", typeof(Version));
            if (_Version.Equals( HttpVersion.Version10 ))
                _ExpectContinue = false;

            _OriginUri                  = (Uri)serializationInfo.GetValue("_OriginUri", typeof(Uri));
#if HTTP_HEADER_EXTENSIONS_SUPPORTED
            _NextExtension              = serializationInfo.GetInt32("_NextExtension");
#endif // HTTP_HEADER_EXTENSIONS_SUPPORTED

            CreateDefaultObjects();
        }

        //
        // ISerializable method
        //
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.GetObjectData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter =true)]
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            //
            // for now disregard streamingContext.
            // just Add all the members we need to deserialize to construct
            // the object at deserialization time
            //
            // the following runtime types already support serialization:
            // Boolean, Char, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, DateTime
            // for the others we need to provide our own serialization
            //
            serializationInfo.AddValue("_HttpRequestHeaders", _HttpRequestHeaders, typeof(WebHeaderCollection));
            serializationInfo.AddValue("_Proxy", _Proxy, typeof(IWebProxy));
            serializationInfo.AddValue("_KeepAlive", _KeepAlive);
            serializationInfo.AddValue("_Pipelined", _Pipelined);
            serializationInfo.AddValue("_AllowAutoRedirect", _AllowAutoRedirect);
            serializationInfo.AddValue("_AllowWriteStreamBuffering", _AllowWriteStreamBuffering);
            serializationInfo.AddValue("_HttpWriteMode", _HttpWriteMode);
            serializationInfo.AddValue("_MaximumAllowedRedirections", _MaximumAllowedRedirections);
            serializationInfo.AddValue("_AutoRedirects", _AutoRedirects);
            serializationInfo.AddValue("_Timeout", _Timeout);
            serializationInfo.AddValue("_ReadWriteTimeout", _ReadWriteTimeout);
            serializationInfo.AddValue("_MaximumResponseHeadersLength", _MaximumResponseHeadersLength);
            serializationInfo.AddValue("_ContentLength", _ContentLength);
            serializationInfo.AddValue("_MediaType", _MediaType);
            serializationInfo.AddValue("_OriginVerb", _OriginVerb);
            serializationInfo.AddValue("_ConnectionGroupName", _ConnectionGroupName);
            serializationInfo.AddValue("_Version", _Version, typeof(Version));
            serializationInfo.AddValue("_OriginUri", _OriginUri, typeof(Uri));
#if HTTP_HEADER_EXTENSIONS_SUPPORTED
            serializationInfo.AddValue("_NextExtension", _NextExtension);
#endif // HTTP_HEADER_EXTENSIONS_SUPPORTED
        }



        /*++

        Routine Description:

            GetConnectionGroupLine - Generates a string that
              allows a Connection to remain unique for a given NTLM auth
              user, this is needed to prevent multiple users from
              using the same sockets after they are authenticated.

        Arguments:

            None.

        Return Value:

            string - generated result

        --*/
        internal string GetConnectionGroupLine() {
            GlobalLog.Enter("GetConnectionGroupLine");

            // consider revisting this looking into how this would work,
            // if we were doing auth through both proxy and server,
            // I belive this can't work in any case, so we're okay.

            string internalConnectionGroupName = _ConnectionGroupName;

            //
            // for schemes of ssl, we need to create a special connection group
            //  otherwise, we'll try sharing proxy connections across SSL servers
            //  which won't work.
            //

            bool tunnelRequest = this is HttpProxyTunnelRequest;

            if (UnsafeAuthenticatedConnectionSharing) {
                internalConnectionGroupName += "U>";
            } else {
                internalConnectionGroupName += "S>";
            }

            if ((_Uri.Scheme == Uri.UriSchemeHttps) || tunnelRequest) {
                if (UsesProxy) {
                    internalConnectionGroupName = internalConnectionGroupName + ConnectHostAndPort + "$";
                }
                if ( _ClientCertificates.Count > 0 ) {
                    internalConnectionGroupName = internalConnectionGroupName + _ClientCertificates.GetHashCode().ToString();
                }
            }
            if ( _ProxyAuthenticationState.UniqueGroupId != null ) {
                GlobalLog.Leave("GetConnectionGroupLine", ValidationHelper.ToString(internalConnectionGroupName + _ProxyAuthenticationState.UniqueGroupId));
                return internalConnectionGroupName + _ProxyAuthenticationState.UniqueGroupId;
            }
            else if ( _ServerAuthenticationState.UniqueGroupId != null ) {
                GlobalLog.Leave("GetConnectionGroupLine", ValidationHelper.ToString(internalConnectionGroupName + _ServerAuthenticationState.UniqueGroupId));
                return internalConnectionGroupName + _ServerAuthenticationState.UniqueGroupId;
            }
            else {
                GlobalLog.Leave("GetConnectionGroupLine", ValidationHelper.ToString(internalConnectionGroupName));
                return internalConnectionGroupName;
            }
        }

        /*++

        Routine Description:

            CheckResubmitForAuth - Determines if a HTTP request needs to be
              resubmitted due to HTTP authenication

        Arguments:

            None.

        Return Value:

            true  - if we should reattempt submitting the request
            false - if the request is complete

        --*/
        private bool CheckResubmitForAuth() {
            GlobalLog.Enter("CheckResubmitForAuth");

            bool result = false;
            
            if (UsesProxySemantics && _Proxy.Credentials!=null) {
                result |= _ProxyAuthenticationState.AttemptAuthenticate(this, _Proxy.Credentials);
                GlobalLog.Print("CheckResubmitForAuth() _ProxyAuthenticationState.AttemptAuthenticate() returns result:" + result.ToString());
            }
            if (_AuthInfo != null) {
                result |= _ServerAuthenticationState.AttemptAuthenticate(this, _AuthInfo);
                GlobalLog.Print("CheckResubmitForAuth() _ServerAuthenticationState.AttemptAuthenticate() returns result:" + result.ToString());
            }
            GlobalLog.Leave("CheckResubmitForAuth", result);
            return result;
        }

        /*++

        Routine Description:

            CheckResubmit - Determines if a HTTP request needs to be
              resubmitted to a server point, this is called in Response
              Parsing to handle cases such as server Redirects,
              und Authentication

        Arguments:

            None.

        Return Value:

            true  - if we should reattempt submitting the request
            false - if the request is complete

        --*/
        private bool CheckResubmit() {
            GlobalLog.Enter("CheckResubmit");

            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::CheckResubmit()");


            if (ResponseStatusCode==HttpStatusCode.Unauthorized                 || // 401
                ResponseStatusCode==HttpStatusCode.ProxyAuthenticationRequired) {  // 407
                //
                // Check for Authentication
                //
                if (!CheckResubmitForAuth()) {
                    ClearAuthenticatedConnectionResources();
                    GlobalLog.Leave("CheckResubmit");
                    return false;
                }
            }
            else {

                ClearAuthenticatedConnectionResources();

                //
                // Check for Redirection
                //
                // Table View:
                // Method            301             302             303             307
                //    *                *               *             GET               *
                // POST              GET             GET             GET            POST
                //
                // Put another way:
                //  301 & 302  - All methods are redirected to the same method but POST. POST is redirected to a GET.
                //  303 - All methods are redirected to GET
                //  307 - All methods are redirected to the same method.
                //

                if (_AllowAutoRedirect && (
                    ResponseStatusCode==HttpStatusCode.Ambiguous          || // 300
                    ResponseStatusCode==HttpStatusCode.Moved              || // 301
                    ResponseStatusCode==HttpStatusCode.Redirect           || // 302
                    ResponseStatusCode==HttpStatusCode.RedirectMethod     || // 303
                    ResponseStatusCode==HttpStatusCode.RedirectKeepVerb)) {  // 307

                    _AutoRedirects += 1;
                    if (_AutoRedirects > _MaximumAllowedRedirections) {
                        GlobalLog.Leave("CheckResubmit");
                        return false;
                    }

                    string Location = _HttpResponse.Headers["Location"];
                    string newMethod = _Verb;
                    bool DisableUpload = false;

                    switch (ResponseStatusCode) {
                        case HttpStatusCode.Moved:
                        case HttpStatusCode.Redirect:
                            if (string.Compare(newMethod, "POST", true, CultureInfo.InvariantCulture) == 0) {
                                newMethod = "GET";
                                DisableUpload = true;
                            }
                            break;

                        case HttpStatusCode.RedirectKeepVerb:
                            break;

                        case HttpStatusCode.RedirectMethod:
                        default:
                            DisableUpload = true;
                            newMethod = "GET";
                            break;
                    }

                    GlobalLog.Print("Location = " + Location);

                    if (Location != null) {
                        // set possible new Method
                        GlobalLog.Print("HttpWebRequest#"+ValidationHelper.HashString(this)+": changing Verb from "+_Verb+" to "+newMethod);
                        _Verb = newMethod;
                        if (DisableUpload) {
                            GlobalLog.Print("HttpWebRequest#"+ValidationHelper.HashString(this)+": disabling upload");
                            _ContentLength = -1;
                            _HttpWriteMode = HttpWriteMode.None;
                        }

                        Uri previousUri = _Uri;

                        try {
                            _Uri = new Uri(_Uri, Location, true);
                        }
                        catch (Exception exception) {
                            _ResponseException = new WebException(SR.GetString(SR.net_resubmitprotofailed),
                                                               exception,
                                                               WebExceptionStatus.ProtocolError,
                                                               _HttpResponse
                                                              );
                            GlobalLog.Leave("CheckResubmit");
                            return false;
                        }

                        if (_Uri.Scheme != Uri.UriSchemeHttp &&
                            _Uri.Scheme != Uri.UriSchemeHttps) {
                            _ResponseException = new WebException(SR.GetString(SR.net_resubmitprotofailed),
                                                               null,
                                                               WebExceptionStatus.ProtocolError,
                                                               _HttpResponse
                                                              );

                            GlobalLog.Leave("CheckResubmit");
                            return false;  // can't handle these redirects
                        }

                        try {
                            //Check for permissions against redirect Uri
                            (new WebPermission(NetworkAccess.Connect, _Uri.AbsoluteUri)).Demand();
                        }
                        catch {
                            // We are on other thread.
                            // Don't let the thread die but pass the error on to the user thread.
                            _ResponseException = new SecurityException(SR.GetString(SR.net_redirect_perm),
                                                                    new WebException(SR.GetString(SR.net_resubmitcanceled),
                                                                    null,
                                                                    WebExceptionStatus.ProtocolError,
                                                                    _HttpResponse)
                                                                    );
                            GlobalLog.Leave("CheckResubmit");
                            return false;
                        }

                        //
                        // make sure we're not sending over credential information to an evil redirection
                        // URI. this will set our credentials to null unless the user is using DefaultCredentials
                        // or a CredentialCache, in which case he is responsible for binding the credentials to
                        // the proper Uri and AuthenticationScheme.
                        //

                        ICredentials authTemp = _AuthInfo as CredentialCache;

                        if (authTemp==null) {
                            //
                            // if it's not a CredentialCache it could still be DefaultCredentials
                            // check for this case as well
                            //
                            _AuthInfo = _AuthInfo as SystemNetworkCredential;
                        }
                        else {
                            _AuthInfo = authTemp;
                        }

                        //
                        // do the necessary cleanup on the Headers involved in the
                        // Authentication handshake.
                        //
                        _ProxyAuthenticationState.ClearAuthReq(this);
                        _ServerAuthenticationState.ClearAuthReq(this);

                        GlobalLog.Print("HttpWebRequest#"+ValidationHelper.HashString(this)+": _Verb="+_Verb);
                        // resubmit
                    }
                    else {
                        GlobalLog.Leave("CheckResubmit");
                        return false;
                    }
                }
                else { // if (_AllowAutoRedirect)
                    GlobalLog.Leave("CheckResubmit");
                    return false;
                }
            } // else

            if ((_HttpWriteMode != HttpWriteMode.None) && !AllowWriteStreamBuffering && _ContentLength != 0) {
                _ResponseException = new WebException(SR.GetString(SR.net_need_writebuffering),
                                                        null,
                                                        WebExceptionStatus.ProtocolError,
                                                        _HttpResponse);


                GlobalLog.Leave("CheckResubmit");
                return false;
            }

            if (System.Net.Connection.IsThreadPoolLow()) {
                _ResponseException = new InvalidOperationException(SR.GetString(SR.net_needmorethreads));
                return false;
            }

            GlobalLog.Leave("CheckResubmit");
            return true;
        }

        /*++

        Routine Description:

            ClearRequestForResubmit - prepares object for resubmission and recall
                of submit request, for redirects, authentication, and other uses
                This is needed to prevent duplicate headers being added, and other
                such things.

        Arguments:

            None.

        Return Value:

            None.

        --*/
        private void ClearRequestForResubmit() {

            _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.Host);
            _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.Connection);
            _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.ProxyConnection);
            _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.ContentLength);
            _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.TransferEncoding);
            _HttpRequestHeaders.RemoveInternal(HttpKnownHeaderNames.Expect);

            //
            // We just drain the response data, and throw
            // it away since we're redirecting, Close handles it.
            //
            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::ClearRequestForResubmit() closing ResponseStream");

            if (_HttpResponse.ResponseStream != null) {
                _HttpResponse.ResponseStream.CloseInternal(true);
            }

            if (_SubmitWriteStream != null) {
                //
                // RAID#86597
                // mauroot: we're uploading and need to resubmit for Authentication or Redirect.
                // if the response wants to keep alive the connection we shouldn't be closing
                // it (this would also brake connection-oriented authentication schemes such as NTLM).
                // so we need to flush all the data to the wire.
                // if the server is closing the connection, instead, we can just close our side as well.
                //
                //The other reason to wait for data flushing is when the connection is being closed
                //but the body is not written yet. Note that when IsStopped==true, the stream will NOT
                //write to the socket, rather buffer/trash til EOF
                if (_HttpResponse.KeepAlive || _SubmitWriteStream.IgnoreSocketWrite) {
                    //
                    // the server wants to keep the connection alive.
                    // if we're uploading data, we need to make sure that we upload all
                    // of it before we start resubmitting.
                    // give the stream to the user if he didn't get it yet.
                    // if the user has set ContentLength to a big number, then we might be able
                    // to just decide to close the connection, but we need to be careful to NTLM.
                    //
                    if (_HttpWriteMode==HttpWriteMode.Chunked || _ContentLength>0) {
                        //
                        // we're uploading
                        //
                        GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::ClearRequestForResubmit() _WriteAResult:" + ValidationHelper.ToString(_WriteAResult) + " _WriteStreamRetrieved:" + _WriteStreamRetrieved.ToString());

                        if (_WriteStreamRetrieved) {
                            //
                            // the user didn't get the stream yet, give it to him
                            //
                            GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::ClearRequestForResubmit() calling SetRequestContinue()");
                            SetRequestContinue();
                        }

                        //
                        // now wait for the user to write all the data to the stream
                        // since we can't keep the connection alive unless we flush all
                        // the data we have to the stream.
                        //
                        _SubmitWriteStream.WaitWriteDone();
                    }
                }                

                if (!_SubmitWriteStream.CallInProgress) {
                    GlobalLog.Print("HttpWebRequest#" + ValidationHelper.HashString(this) + "::ClearRequestForResubmit() closing RequestStream");
                    _SubmitWriteStream.CloseInternal(true);
                }
            }

            _RerequestCount += 1;


            //
            // we're done with this response: let garbage-collector have it
            //
            WriteBuffer  = null;
            _HttpResponse = null;
            _HaveResponse = false;
            _WriteNotifed = false;
        }

        /*++

            CheckFinalStatus - Check the final status of an HTTP response.

            This is a utility routine called from several places. We look
            at the final status of the HTTP response. If it's not 'success',
            we'll generate a WebException and throw that. Otherwise we'll
            do nothing.

            This should get merged into other code eventually. When all of
            the async work gets completed and we only generate a response in
            one place, this function should be called (or inlined) there.

            Input:

                Nothing.

            Returns:
                Nothing. May throw an exception.

        --*/

        private void CheckFinalStatus() {
            // Make sure we have seen a response. We might not have seen one
            // yet in some cases.

            Exception errorException = null;
            GlobalLog.Print("CheckFinalStatus");

            if (!_HaveResponse && !_Abort) {
                GlobalLog.Print("CheckFinalStatus - returning");
                return;
            }

            //DELEGATION: At this point no more requests are sent to the wire.
            //           AND We won;t keep a native handle for more than it's required
            if (m_DelegationFix != null) {
                lock(this) {
                    if (m_DelegationFix != null) {
                        m_DelegationFix.FreeToken();
                        m_DelegationFix = null;
                    }
                }
            }

            // Now see if we have a valid response. If not, throw the response
            // exception.

            errorException = _ResponseException;

            if (_HttpResponse != null) {
                errorException = _ResponseException;

                GlobalLog.Print("CheckFinalStatus - status" + (int)ResponseStatusCode);

                // We have a response. See if it's not valid. It's not valid if the
                // response code is greater than 399 (299 if we're not auto following
                // redirects.

                if (errorException == null && (int)ResponseStatusCode > (int)HttpStatusRange.MaxOkStatus) {
                    // Not a success status. Could be a redirect, which if OK if we're
                    // not auto following redirects.

                    if ((int)ResponseStatusCode > (int)HttpStatusRange.MaxRedirectionStatus ||
                        _AllowAutoRedirect) {


                        // Some sort of error. Generate, save and throw a new
                        // WebException.

                        if (_AutoRedirects > _MaximumAllowedRedirections) {
                            errorException = new WebException(
                                SR.GetString(SR.net_tooManyRedirections),
                                _ResponseException,
                                WebExceptionStatus.ProtocolError,
                                _HttpResponse );
                        }
                        else {
                            errorException = new WebException(
                                SR.GetString(SR.net_servererror,
                                    NetRes.GetWebStatusCodeString(ResponseStatusCode, _HttpResponse.StatusDescription)),
                                _ResponseException,
                                WebExceptionStatus.ProtocolError,
                                _HttpResponse );
                        }
                    }
                }

                // error, need to throw exception
                if (errorException != null) {
                    //
                    // Close the Stream to prevent it from breaking the
                    //  connection

                    if (_HttpResponse.ResponseStream != null) {

                        //
                        // copy off stream, don't just close it, if this
                        //  exception isn't handled, we've closed it,
                        //  if it is, then it gets read through a buffer.
                        //

                        ConnectStream connStream =  _HttpResponse.ResponseStream;
                        ConnectStream connNewStream = connStream.MakeMemoryStream();

                        _HttpResponse.ResponseStream = connNewStream;
                        connStream.CloseInternal(true);
                    }

                    _ResponseException = errorException;
                    _HttpResponse = null;
                }
            }

            if ( errorException != null) {
                if (_SubmitWriteStream != null) {
                    try {
                        _SubmitWriteStream.CloseInternal(true);
                    }
                    catch {
                    }
                }

                throw errorException;
            }
        }


        /*++

        Routine Description:
            Range requests to allow for queriable data
            Adds a simple range request header to outgoing request

        Arguments:

            From - Start of range request

            To - End of range

        Return Value:

            None.

        --*/
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.AddRange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a range header to the request for a specified range.
        ///    </para>
        /// </devdoc>
        public void AddRange(int from, int to) {
            AddRange("bytes", from, to);
        }


        /*++

        Routine Description:

            Adds a simple range request header to outgoing request

        Arguments:

            Range - Range, this is a negative range, to indicate last_char to range,
                            or postive to idicate 0 .. Range

        Return Value:

            None.

        --*/
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.AddRange1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a range header to a request for a specific
        ///       range from the beginning or end
        ///       of the requested data.
        ///       To add the range from the end pass negative value
        ///       To add the range from the some offset to the end pass positive value
        ///    </para>
        /// </devdoc>
        public void AddRange(int range) {
            AddRange("bytes", range);
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.AddRange2"]/*' />
        public void AddRange(string rangeSpecifier, int from, int to) {

            //
            // Do some range checking before assembling the header
            //

            if (rangeSpecifier == null) {
                throw new ArgumentNullException("rangeSpecifier");
            }
            if ((from < 0) || (to < 0)) {
                throw new ArgumentOutOfRangeException(SR.GetString(SR.net_rangetoosmall));
            }
            if (from > to) {
                throw new ArgumentOutOfRangeException(SR.GetString(SR.net_fromto));
            }
            if (!WebHeaderCollection.IsValidToken(rangeSpecifier)) {
                throw new ArgumentException(SR.GetString(SR.net_nottoken), "rangeSpecifier");
            }
            if (!AddRange(rangeSpecifier, from.ToString(), to.ToString())) {
                throw new InvalidOperationException(SR.GetString(SR.net_rangetype));
            }
        }

        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.AddRange3"]/*' />
        public void AddRange(string rangeSpecifier, int range) {
            if (rangeSpecifier == null) {
                throw new ArgumentNullException("rangeSpecifier");
            }
            if (!WebHeaderCollection.IsValidToken(rangeSpecifier)) {
                throw new ArgumentException(SR.GetString(SR.net_nottoken), "rangeSpecifier");
            }
            if (!AddRange(rangeSpecifier, range.ToString(), (range >= 0) ? "" : null)) {
                throw new InvalidOperationException(SR.GetString(SR.net_rangetype));
            }
        }

        //
        // bool AddRange(rangeSpecifier, from, to)
        //
        //  Add or extend a range header. Various range types can be specified
        //  via rangeSpecifier, but only one type of Range request will be made
        //  e.g. a byte-range request, or a row-range request. Range types
        //  cannot be mixed
        //

        private bool AddRange(string rangeSpecifier, string from, string to) {

            string curRange = _HttpRequestHeaders[HttpKnownHeaderNames.Range];

            if ((curRange == null) || (curRange.Length == 0)) {
                curRange = rangeSpecifier+"=";
            }
            else {
                if (String.Compare(curRange.Substring(0, curRange.IndexOf('=')), rangeSpecifier, true, CultureInfo.InvariantCulture) != 0) {
                    return false;
                }
                curRange = string.Empty;
            }
            curRange += from.ToString();
            if (to != null) {
                curRange += "-" + to;
            }
            _HttpRequestHeaders.SetAddVerified(HttpKnownHeaderNames.Range, curRange);
            return true;
        }

#if HTTP_HEADER_EXTENSIONS_SUPPORTED

        /*++

        Routine Description:

            Assembles and creates a new extension header, and
              returns an extension object that can be used to
              add extension headers

        Arguments:

            uri - Uri to use extension for

            header - header that matches the particular range request

        Return Value:

            None.

        --*/
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.CreateExtension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpExtension CreateExtension(string uri, string header) {
            int id = _NextExtension;
            HttpExtension extension = new HttpExtension(id, uri, header);

            _NextExtension++;

            return extension;
        }

        /*++

        Routine Description:

            Assembles and creates a new extension header,
              by adding it the extension object

        Arguments:

            extension - The Extension object, we pass it out and then use it as a
                container for storing our collection of Extension specific headers

            header - header that should be added

            value - header value that should be added

        Return Value:

            None.

        --*/
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.AddExtension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddExtension(HttpExtension extension, string header, string value) {
            StringBuilder sb = new StringBuilder(100);

            if (extension == null) {
                throw new ArgumentNullException("extension");
            }

            if (! extension.HasAddedExtensionHeader) {
                StringBuilder sb2 = new StringBuilder(100);

                extension.HasAddedExtensionHeader = true;
                sb2.Append(extension.Header);
                sb2.Append(": \"");
                sb2.Append(extension.Uri);
                sb2.Append("\"; ns=");
                sb2.Append(extension.ID);

                _HttpRequestHeaders.Add(sb2.ToString());
            }

            sb.Append(extension.ID);
            sb.Append('-');
            sb.Append(header);

            _HttpRequestHeaders.Add(sb.ToString(), value);
        }

#endif // HTTP_HEADER_EXTENSIONS_SUPPORTED

        //
        // The callback function called (either by the thread pool or the BeginGetRequest )
        // when IO completes.
        //

        //
        // Called after first Response Callback to continue processing
        //  of response, and handling of redirects retrives in the process
        //  thereof.
        //

        //
        // The callback function called (either by the thread pool or the BeginGetResponse)
        // when IO completes.
        //

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        /// <include file='doc\HttpWebRequest.uex' path='docs/doc[@for="HttpWebRequest.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }


#if COMNET_HTTPPERFCOUNTER
        ~HttpWebRequest() {
            NetworkingPerfCounters.IncrementHttpWebRequestCollected();
        }
#endif // COMNET_HTTPPERFCOUNTER


    }; // class HttpWebRequest


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httpweblistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpWebListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if COMNET_LISTENER

namespace System.Net {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Configuration.Assemblies;

    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Net;
    using System.Net.Sockets;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Security;
    using System.Security.Cryptography;
    using System.Security.Cryptography.X509Certificates;
    using System.Security.Permissions;
    using System.Security.Util;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class HttpWebListener : WebListener {

        //
        // Constructor:
        // in the constructor we just create an AppPool that will contain all uri
        // prefixes registration
        //

        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.HttpWebListener"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public
        HttpWebListener() {
            int result =

            ComNetOS.IsWinNt ?

            UlSysApi.UlCreateAppPool(
                                    ref m_AppPoolHandle,
                                    string.Empty,
                                    IntPtr.Zero,
                                    UlConstants.UL_OPTION_OVERLAPPED )

            :

            UlVxdApi.UlCreateAppPool(
                                    ref m_AppPoolHandle );

            if (result != NativeMethods.ERROR_SUCCESS) {
                throw new InvalidOperationException( "UlCreateAppPool() failed, err#" + Convert.ToString( result ) );
            }

            //
            // we count the number of instances so that in the destructor we are
            // able to correctly call UlTerminate() and be gracefully shutdown the
            // driver when this process no longer needs it
            //

            m_InstancesCounter++;

            GlobalLog.Print("UlCreateAppPool() succesfull, AppPool handle is "
                           + Convert.ToString( m_AppPoolHandle ) );

            return;

        } // WebListener()


        //
        // this is a static initializer, we need it basically to complete
        // the following two simple tasks:
        // 1 ) make sure we're running on Win9x or WinNt
        // 2 ) make sure ul is available and properly initialize it for the
        // appropriate system
        //

        private static bool
        m_InitializeUriListener() {
            if (ComNetOS.IsWinNt) {
                //
                // if this is WinNT we initialize ul.vxd
                //

                //
                // we need to create a special config group that allows for
                // transient registrations under the "http://*:80/" namespace
                // this will call UlInitialize() as well
                //

                int result = UlSysApi.UlCreateRootConfigGroup( "http://*:80/" );

                if (result != 0) {
                    throw new InvalidOperationException( "Failed Initializing ul.sys" );
                }

                GlobalLog.Print("UlCreateRootConfigGroup() succeeded" );

                /*
                //
                // if we use this initialization we will need tcgsec.exe to be
                // running in order to make this work
                //
    
                int result = UlSysApi.UlInitialize(0);
                
                if ( result != 0 ) {
                    throw new InvalidOperationException( "Failed Initializing ul.sys" );
                }
    
                GlobalLog.Print("UL.SYS correctly initialized" );
                */
            }
            else if (ComNetOS.IsWin9x) {
                //
                // if this is Win9x we initialize ul.vxd
                //

                int result = UlVxdApi.UlInitialize();

                if (result != 0) {
                    throw new InvalidOperationException( "Failed Initializing ul.vxd" );
                }

                GlobalLog.Print("UL.VXD correctly initialized" );
            }
            else {
                //
                // this is the only place in which we check for OperatingSystem other than
                // NT and Win9x, past this point we can assume that:
                // if it's not WinNt then it's Win9x.
                //

                throw new InvalidOperationException( "Illegal OperatingSystem version" );
            }

            return true;

        } // InitializeUriListener()


        //
        // Destructor: this is the implicit destructor for the class, it will
        // simply call the explicit one and return.
        //

        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.~HttpWebListener"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ~HttpWebListener() {
            Close();
            return;
        }


        //
        // this is the explicit destructor for the class, we decrement the
        // instance counter, and terminate ul if the current instances are 0
        //

        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.Close"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void
        Close() {
            RemoveAll();

            if (m_InstancesCounter-- == 0) {
                if (ComNetOS.IsWinNt) {
                    UlSysApi.UlTerminate();
                }
                else {
                    UlVxdApi.UlTerminate();
                }
            }

            return;

        } // Close()


        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.AddUriPrefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool
        AddUriPrefix(
                    string uriPrefix ) {

            //check permissions for URI being listened
            (new WebPermission(NetworkAccess.Accept, uriPrefix)).Demand();

            int result =

            ComNetOS.IsWinNt ?

            UlSysApi.UlAddTransientUrl(
                                      m_AppPoolHandle,
                                      uriPrefix )

            :

            UlVxdApi.UlRegisterUri(
                                  m_AppPoolHandle,
                                  uriPrefix );

            if (result != NativeMethods.ERROR_SUCCESS) {
                throw new InvalidOperationException( "UlRegisterUri() failed, err#" + Convert.ToString( result ) );
            }

            GlobalLog.Print("AddUriPrefix( " + uriPrefix + " ) handle:"
                           + Convert.ToString( m_AppPoolHandle ) );

            m_UriPrefixes.Add( uriPrefix );

            return true;

        } // AddUriPrefix()


        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.RemoveUriPrefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool
        RemoveUriPrefix(
            string uriPrefix ) {
            if (!m_UriPrefixes.Contains( uriPrefix )) {
                return false;
            }

            int result =
            ComNetOS.IsWinNt ?

            UlSysApi.UlRemoveTransientUrl(
                                         m_AppPoolHandle,
                                         uriPrefix )

            :

            UlVxdApi.UlUnregisterUri(
                                    m_AppPoolHandle,
                                    uriPrefix );

            if (result != NativeMethods.ERROR_SUCCESS) {
                throw new InvalidOperationException( "UlUnregisterUri() failed" );
            }

            m_UriPrefixes.Remove( uriPrefix );

            return true;

        } // RemoveUriPrefix()


        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void
        RemoveAll() {
            //
            // CODEWORK: we may want to add an API in ul to do this
            // it is available in ul.vxd so use it!
            //

            GlobalLog.Assert(
                        m_UriPrefixes != null,
                        "RemoveAll: m_UriPrefixes == null",
                        string.Empty );

            //
            // go through the uri list and unregister for each one of them
            //

            for (int i = 0; i < m_UriPrefixes.Count; i++) {

                RemoveUriPrefix( m_UriPrefixes[i] );
            }

            //
            // we clear the internal string table, even though it should
            // be empty now
            //

            m_UriPrefixes.Clear();

            return;

        } // RemoveAll()


        //
        // synchronous call, it calls into ul to get a parsed request and returns
        // a HttpListenerWebRequest object
        //

        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.GetRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override WebRequest
        GetRequest() {
            //
            // Validation
            //

            if (m_AppPoolHandle == NativeMethods.INVALID_HANDLE_VALUE) {
                throw new InvalidOperationException( "The AppPool handle is invalid" );
            }

            int result;

            int retries = 0;

            //
            // defined in ulcommonapi.cs
            //

            int RcvHeadersBufferSize = UlConstants.InitialBufferSize;

            // 
            // prepare ( allocate/pin ) buffers and data for the first unmanaged call
            //

            GCHandle PinnedBuffer;
            GCHandle NewPinnedBuffer;

            IntPtr AddrOfPinnedBuffer = IntPtr.Zero;
            IntPtr NewAddrOfPinnedBuffer = IntPtr.Zero;

            int BytesReturned = 0;
            long RequestId = 0;
            byte[] RcvHeadersBuffer = new byte[RcvHeadersBufferSize];

            // 
            // pin buffers and data for the unmanaged call
            //

            PinnedBuffer = GCHandle.Alloc( RcvHeadersBuffer, GCHandleType.Pinned );
            AddrOfPinnedBuffer = PinnedBuffer.AddrOfPinnedObject();

            // 
            // issue unmanaged blocking call until we read enough data:
            // usually starting with a InitialBufferSize==4096 bytes we should be
            // able to get all the headers ( and part of the entity body, if any
            // is present ), if we don't, if the call didn't fail for othe reasons,
            // we get indication in BytesReturned, on how big the buffer should be
            // to receive the data available, so usually the second call will
            // succeed, but we have to consider the case of two competing calls
            // for the same RequestId, and that's why we need a loop and not just
            // a try/retry-expecting-success fashion
            //

            for (;;) {
                //
                // check if we're in a healthy state
                //
                if (retries++ > m_MaxRetries) {
                    throw new InvalidOperationException( "UlReceiveHttpRequest() Too many retries" );
                }

                result =
                ComNetOS.IsWinNt ?

                UlSysApi.UlReceiveHttpRequest(
                                             m_AppPoolHandle,
                                             RequestId,
                                             UlConstants.UL_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                             AddrOfPinnedBuffer,
                                             RcvHeadersBufferSize,
                                             ref BytesReturned,
                                             IntPtr.Zero )

                :

                UlVxdApi.UlReceiveHttpRequestHeaders(
                                                    m_AppPoolHandle,
                                                    RequestId,
                                                    0,
                                                    AddrOfPinnedBuffer,
                                                    RcvHeadersBufferSize,
                                                    ref BytesReturned,
                                                    IntPtr.Zero );

                if (result == NativeMethods.ERROR_SUCCESS) {
                    //
                    // success, we are done.
                    //

                    break;
                }

                if (result == NativeMethods.ERROR_INVALID_PARAMETER) {
                    //
                    // we might get this if somebody stole our RequestId,
                    // set RequestId to null
                    //

                    RequestId = 0;

                    //
                    // and start all over again with the buffer we
                    // just allocated
                    //

                    continue;
                }

                //
                // let's check if ul is in good shape:
                //

                if (BytesReturned < RcvHeadersBufferSize) {
                    throw new InvalidOperationException( "UlReceiveHttpRequest() sent bogus BytesReturned: " + Convert.ToString( BytesReturned ) );
                }

                if (result == NativeMethods.ERROR_MORE_DATA) {
                    //
                    // the buffer was not big enough to fit the headers, we need
                    // to read the RequestId returned, grow the buffer, keeping
                    // the data already transferred
                    //

                    RequestId = Marshal.ReadInt64( IntPtrHelper.Add(AddrOfPinnedBuffer, m_RequestIdOffset) );

                    //
                    // CODEWORK: wait for the answer from LarrySu
                    //

                    //
                    // if the buffer size was too small, grow the buffer
                    // this reallocation dereferences the old buffer, but since
                    // this was previously pinned, it won't be garbage collected
                    // until we unpin it ( which we do below )
                    //

                    RcvHeadersBuffer = new byte[BytesReturned];

                    //
                    // pin the new one
                    //

                    NewPinnedBuffer = GCHandle.Alloc( RcvHeadersBuffer, GCHandleType.Pinned );
                    NewAddrOfPinnedBuffer = NewPinnedBuffer.AddrOfPinnedObject();

                    //
                    // copy the valid data
                    //

                    Marshal.Copy( AddrOfPinnedBuffer, RcvHeadersBuffer, 0, RcvHeadersBufferSize );
                    RcvHeadersBufferSize = BytesReturned;

                    //
                    // unpin the old buffer, reset pinned/unmanaged pointers
                    //

                    PinnedBuffer.Free();

                    PinnedBuffer = NewPinnedBuffer;
                    AddrOfPinnedBuffer = NewAddrOfPinnedBuffer;

                    //
                    // and start all over again with the new buffer
                    //

                    continue;
                }

                //
                // someother bad error, possible( ? ) return values are:
                //
                // ERROR_INVALID_HANDLE
                // ERROR_INSUFFICIENT_BUFFER
                // ERROR_OPERATION_ABORTED
                // ERROR_IO_PENDING
                //

                throw new InvalidOperationException( "UlReceiveHttpRequest() failed, err#" + Convert.ToString( result ) );
            }

            GlobalLog.Print("GetRequest RequestId:" + Convert.ToString(RequestId));            // 
            // translate unmanaged results into a new managed object
            //

            HttpListenerWebRequest
                myWebRequest =
                    new HttpListenerWebRequest( AddrOfPinnedBuffer, RcvHeadersBufferSize, m_AppPoolHandle );

            // 
            // free the unmanaged buffer ( deallocate/unpin ) after unmanaged call
            //

            PinnedBuffer.Free();

            return myWebRequest;

        } // GetRequest()


        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.BeginGetRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IAsyncResult
        BeginGetRequest(
                       AsyncCallback requestCallback,
                       Object stateObject ) {
            //
            // Validation
            //

            if (m_AppPoolHandle == NativeMethods.INVALID_HANDLE_VALUE) {
                throw new InvalidOperationException( "The AppPool handle is invalid" );
            }

            //
            // prepare the ListenerAsyncResult object ( this will have it's own
            // event that the user can wait on for IO completion - which means we
            // need to signal it when IO completes )
            //

            GlobalLog.Print("BeginGetRequest() creating ListenerAsyncResult" );

            ListenerAsyncResult AResult = new ListenerAsyncResult(
                                                                 stateObject,
                                                                 requestCallback );

            AutoResetEvent m_Event = new AutoResetEvent( false );

            Marshal.WriteIntPtr(
                              AResult.m_Overlapped,
                              Win32.OverlappedhEventOffset,
                              m_Event.Handle );

            // 
            // issue unmanaged call until we read enough data:
            // usually starting with a InitialBufferSize==4096 bytes we should be
            // able to get all the headers ( and part of the entity body, if any
            // is present ), if we don't, if the call didn't fail for othe reasons,
            // we get indication in BytesReturned, on how big the buffer should be
            // to receive the data available, so usually the second call will
            // succeed, but we have to consider the case of two competing calls
            // for the same RequestId, and that's why we need a loop and not just
            // a try/retry-expecting-success fashion
            //

            int result;

            for (;;) {
                //
                // check if we're in a healthy state
                //
                if (AResult.m_Retries++ > m_MaxRetries) {
                    throw new InvalidOperationException( "UlReceiveHttpRequest() Too many retries" );
                }

                result =
                ComNetOS.IsWinNt ?

                UlSysApi.UlReceiveHttpRequest(
                                             m_AppPoolHandle,
                                             AResult.m_RequestId,
                                             UlConstants.UL_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                             AResult.m_Buffer,
                                             AResult.m_BufferSize,
                                             ref AResult.m_BytesReturned,
                                             AResult.m_Overlapped )

                :

                UlVxdApi.UlReceiveHttpRequestHeaders(
                                                    m_AppPoolHandle,
                                                    AResult.m_RequestId,
                                                    0,
                                                    AResult.m_Buffer,
                                                    AResult.m_BufferSize,
                                                    ref AResult.m_BytesReturned,
                                                    AResult.m_Overlapped );

                GlobalLog.Print("UlReceiveHttpRequest() returns:"
                               + Convert.ToString( result ) );

                if (result == NativeMethods.ERROR_SUCCESS || result == NativeMethods.ERROR_IO_PENDING) {
                    //
                    // synchronous success or successfull pending: we are done
                    //

                    break;
                }

                if (result == NativeMethods.ERROR_INVALID_PARAMETER) {
                    //
                    // we might get this if somebody stole our RequestId,
                    // set RequestId to null
                    //

                    AResult.m_RequestId = 0;

                    //
                    // and start all over again with the buffer we
                    // just allocated
                    //

                    continue;
                }

                if (result == NativeMethods.ERROR_MORE_DATA) {
                    //
                    // the buffer was not big enough to fit the headers, we need
                    // to read the RequestId returned, grow the buffer, keeping
                    // the data already transferred
                    //

                    AResult.m_RequestId = Marshal.ReadInt64( IntPtrHelper.Add(AResult.m_Buffer, m_RequestIdOffset) );

                    //
                    // allocate a new buffer of the required size
                    //

                    IntPtr NewBuffer = Marshal.AllocHGlobal( AResult.m_BytesReturned );

                    //
                    // copy the data already read from the old buffer into the
                    // new one
                    //

                    NativeMethods.CopyMemory( NewBuffer, AResult.m_Buffer, AResult.m_BufferSize );


                    //
                    // free the old buffer
                    //

                    Marshal.FreeHGlobal( AResult.m_Buffer );

                    //
                    // update buffer pointer and size
                    //

                    AResult.m_Buffer = NewBuffer;
                    AResult.m_BufferSize = AResult.m_BytesReturned;
                    AResult.m_BytesReturned = 0;

                    //
                    // and start all over again with the new buffer
                    //

                    continue;
                }

                //
                // someother bad error, possible( ? ) return values are:
                //
                // ERROR_INVALID_HANDLE
                // ERROR_INSUFFICIENT_BUFFER
                // ERROR_OPERATION_ABORTED
                // ERROR_IO_PENDING
                //

                throw new InvalidOperationException( "UlReceiveHttpRequest() failed, err#" + Convert.ToString( result ) );
            }

            //
            // we get here only if a break happens, i.e.
            // 1) syncronous completion
            // 2) the IO pended
            //

            if (result == NativeMethods.ERROR_SUCCESS) {
                //
                // set syncronous completion to true
                //

                AResult.Complete( true );

                //
                // and call the internal callback
                //

                WaitCallback( AResult, false );
            }
            else {
                //
                // create a new delegate
                // and spin a new thread from the thread pool to wake up when the
                // event is signaled and call the delegate
                //

                ThreadPool.RegisterWaitForSingleObject(
                                                      m_Event,
                                                      new WaitOrTimerCallback( WaitCallback ),
                                                      AResult,
                                                      -1,
                                                      true );
            }

            GlobalLog.Print("returning AResult" );

            return AResult;

        } // StartListen()


        /// <include file='doc\HttpWebListener.uex' path='docs/doc[@for="HttpWebListener.EndGetRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override WebRequest
        EndGetRequest(
                     IAsyncResult asyncResult ) {
            return(WebRequest)(((ListenerAsyncResult)asyncResult).InternalWaitForCompletion());

        } // AddUri()


        private void
        WaitCallback(
                    Object state,
                    bool signaled ) {
            GlobalLog.Print("entering the WaitCallback()" );
            //
            // take the ListenerAsyncResult object from the state
            //

            ListenerAsyncResult AResult = ( ListenerAsyncResult ) state;

            GlobalLog.Print("got the AResult object" );

            bool syncComplete = AResult.CompletedSynchronously;

            if (!syncComplete) {
                //
                // we've been called by the thread, the event was signaled
                // call HackedGetOverlappedResult() to find out about the IO
                //

                GlobalLog.Print("WaitCallback()!call didn't complete sync calling HackedGetOverlappedResult():" );

                AResult.m_BytesReturned =
                Win32.HackedGetOverlappedResult(
                                               AResult.m_Overlapped );

                if (AResult.m_BytesReturned <= 0) {
                    //
                    // something went wrong throw for now, later we should
                    // call into ul call again
                    //

                    throw new InvalidOperationException( "UlReceiveHttpRequest(callback) failure m_BytesReturned:" + Convert.ToString( AResult.m_BytesReturned ) );
                }

                if (AResult.m_BufferSize < AResult.m_BytesReturned) {
                    //
                    // this is anlogous to the syncronous case in which we get
                    // result == NativeMethods.ERROR_MORE_DATA
                    // basically the buffer is not big enought to accomodate the
                    // reqeust that came in, so grow it to the needed size, copy
                    // the valid data, and reissue the async call and queue it
                    // up to the ThreadPool
                    //

                    throw new InvalidOperationException( "UlReceiveHttpRequest(callback) buffer too small, was:" + Convert.ToString( AResult.m_BufferSize ) + " should be:" + Convert.ToString( AResult.m_BytesReturned ) );
                }
            }

            GlobalLog.Print("WaitCallback()!I/O status is"
                           + " AResult.m_BytesReturned: " + Convert.ToString(AResult.m_BytesReturned)
                           + " AResult.m_Overlapped: " + Convert.ToString(AResult.m_Overlapped)
                           + " AResult.m_SyncComplete: " + Convert.ToString(AResult.CompletedSynchronously) );

            // 
            // complete the async IO and invoke the callback
            //

            AResult.InvokeCallback( syncComplete, new HttpListenerWebRequest( AResult.m_Buffer, AResult.m_BytesReturned, m_AppPoolHandle ) );

            return;

        } // WaitCallback()


        //
        // class members
        //

        private static bool m_IsInitialized = m_InitializeUriListener();
        private static int m_InstancesCounter = 0;

        private const int m_MaxRetries = 10;
        private const int m_RequestIdOffset = 8;

        private IntPtr m_AppPoolHandle = NativeMethods.INVALID_HANDLE_VALUE;
        private StringCollection m_UriPrefixes = new StringCollection();

    } // class HttpWebListener


} // namespace System.Net

#endif // #if COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httpstatuscode.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpStatusCode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Configuration;
using System.Configuration.Assemblies;

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Util;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;



namespace System.Net {

    //
    // Redirect Status code numbers that need to be defined.
    //

    /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode"]/*' />
    /// <devdoc>
    ///    <para>Contains the values of status
    ///       codes defined for the HTTP protocol.</para>
    /// </devdoc>
    //UEUE : Any int can be cast to a HttpStatusCode to allow checking for non http1.1 codes.
    public enum HttpStatusCode {

        //
        // Informational 1xx
        //
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Continue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Continue = 100,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.SwitchingProtocols"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SwitchingProtocols = 101,

        //
        // Successful 2xx
        //
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.OK"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OK = 200,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Created"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Created = 201,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Accepted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Accepted = 202,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.NonAuthoritativeInformation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NonAuthoritativeInformation = 203,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.NoContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NoContent = 204,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.ResetContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ResetContent = 205,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.PartialContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PartialContent = 206,

        //
        // Redirection 3xx
        //
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.MultipleChoices"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MultipleChoices = 300,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Ambiguous"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ambiguous = 300,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.MovedPermanently"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MovedPermanently = 301,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Moved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Moved = 301,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Found"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Found = 302,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Redirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Redirect = 302,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.SeeOther"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SeeOther = 303,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.RedirectMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RedirectMethod = 303,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.NotModified"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NotModified = 304,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.UseProxy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        UseProxy = 305,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Unused"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unused = 306,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.TemporaryRedirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        TemporaryRedirect = 307,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.RedirectKeepVerb"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RedirectKeepVerb = 307,

        //
        // Client Error 4xx
        //
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.BadRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BadRequest = 400,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Unauthorized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unauthorized = 401,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.PaymentRequired"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PaymentRequired = 402,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Forbidden"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Forbidden = 403,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.NotFound"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NotFound = 404,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.MethodNotAllowed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MethodNotAllowed = 405,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.NotAcceptable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NotAcceptable = 406,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.ProxyAuthenticationRequired"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ProxyAuthenticationRequired = 407,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.RequestTimeout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RequestTimeout = 408,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Conflict"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Conflict = 409,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.Gone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Gone = 410,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.LengthRequired"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LengthRequired = 411,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.PreconditionFailed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PreconditionFailed = 412,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.RequestEntityTooLarge"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RequestEntityTooLarge = 413,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.RequestUriTooLong"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RequestUriTooLong = 414,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.UnsupportedMediaType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        UnsupportedMediaType = 415,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.RequestedRangeNotSatisfiable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RequestedRangeNotSatisfiable = 416,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.ExpectationFailed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ExpectationFailed = 417,

        //
        // Server Error 5xx
        //
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.InternalServerError"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InternalServerError = 500,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.NotImplemented"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NotImplemented = 501,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.BadGateway"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BadGateway = 502,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.ServiceUnavailable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ServiceUnavailable = 503,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.GatewayTimeout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GatewayTimeout = 504,
        /// <include file='doc\HttpStatusCode.uex' path='docs/doc[@for="HttpStatusCode.HttpVersionNotSupported"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HttpVersionNotSupported = 505,

    }; // enum HttpStatusCode


    internal enum HttpStatusRange {

        MaxOkStatus = 299,

        MaxRedirectionStatus = 399

    }; // enum HttpStatusRange




/*
Fielding, et al.            Standards Track                     [Page 3]

RFC 2616                        HTTP/1.1                       June 1999


   10.1  Informational 1xx ...........................................57
   10.1.1   100 Continue .............................................58
   10.1.2   101 Switching Protocols ..................................58
   10.2  Successful 2xx ..............................................58
   10.2.1   200 OK ...................................................58
   10.2.2   201 Created ..............................................59
   10.2.3   202 Accepted .............................................59
   10.2.4   203 Non-Authoritative Information ........................59
   10.2.5   204 No Content ...........................................60
   10.2.6   205 Reset Content ........................................60
   10.2.7   206 Partial Content ......................................60
   10.3  Redirection 3xx .............................................61
   10.3.1   300 Multiple Choices .....................................61
   10.3.2   301 Moved Permanently ....................................62
   10.3.3   302 Found ................................................62
   10.3.4   303 See Other ............................................63
   10.3.5   304 Not Modified .........................................63
   10.3.6   305 Use Proxy ............................................64
   10.3.7   306 (Unused) .............................................64
   10.3.8   307 Temporary Redirect ...................................65
   10.4  Client Error 4xx ............................................65
   10.4.1    400 Bad Request .........................................65
   10.4.2    401 Unauthorized ........................................66
   10.4.3    402 Payment Required ....................................66
   10.4.4    403 Forbidden ...........................................66
   10.4.5    404 Not Found ...........................................66
   10.4.6    405 Method Not Allowed ..................................66
   10.4.7    406 Not Acceptable ......................................67
   10.4.8    407 Proxy Authentication Required .......................67
   10.4.9    408 Request Timeout .....................................67
   10.4.10   409 Conflict ............................................67
   10.4.11   410 Gone ................................................68
   10.4.12   411 Length Required .....................................68
   10.4.13   412 Precondition Failed .................................68
   10.4.14   413 Request Entity Too Large ............................69
   10.4.15   414 Request-URI Too Long ................................69
   10.4.16   415 Unsupported Media Type ..............................69
   10.4.17   416 Requested Range Not Satisfiable .....................69
   10.4.18   417 Expectation Failed ..................................70
   10.5  Server Error 5xx ............................................70
   10.5.1   500 Internal Server Error ................................70
   10.5.2   501 Not Implemented ......................................70
   10.5.3   502 Bad Gateway ..........................................70
   10.5.4   503 Service Unavailable ..................................70
   10.5.5   504 Gateway Timeout ......................................71
   10.5.6   505 HTTP Version Not Supported ...........................71
*/



} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\icertificatepolicy.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICertificatePolicy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Configuration;
using System.Configuration.Assemblies;

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Util;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;



namespace System.Net {


// CertificatePolicy
/// <include file='doc\ICertificatePolicy.uex' path='docs/doc[@for="ICertificatePolicy"]/*' />
/// <devdoc>
///    <para>
///       Validates
///       a server certificate.
///    </para>
/// </devdoc>
    public interface ICertificatePolicy {
        /// <include file='doc\ICertificatePolicy.uex' path='docs/doc[@for="ICertificatePolicy.CheckValidationResult"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Validates a server certificate.
        ///    </para>
        /// </devdoc>
        bool CheckValidationResult(ServicePoint srvPoint,
                                   X509Certificate certificate, 
                                   WebRequest request,
                                   int certificateProblem);


    } // interface ICertificatePolicy


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\httpwebresponse.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpWebResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------



namespace System.Net {

    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Cryptography.X509Certificates;
    using System.Globalization;
    
    //
    // HttpWebResponse - Handles retrival of HTTP Response headers, und Data reads.
    //

    /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse"]/*' />
    /// <devdoc>
    ///    <para>
    ///    An HTTP-specific implementation of the
    ///    <see cref='System.Net.WebResponse'/> class.
    /// </para>
    /// </devdoc>
    [Serializable]
    public class HttpWebResponse : WebResponse, ISerializable, IDisposable {

        // response Uri generated by the request.
        private Uri m_Uri;
        // response Verb gernated by the request
        private string m_Verb;
        // response values
        private HttpStatusCode m_StatusCode;
        private string m_StatusDescription;
        // ConnectStream - for reading actual data
        private ConnectStream m_ConnectStream;

        private WebHeaderCollection m_HttpResponseHeaders;

        // Content Length needed for symantics, -1 if chunked
        private long m_ContentLength;

        // for which response ContentType we will look for and parse the CharacterSet
        private string m_MediaType;

        private Version m_Version;

        // server certificate for secure connections
        internal X509Certificate m_Certificate;

        private string m_ContentType;
        private bool m_GotContentType;
        private CookieCollection m_cookies;
        private int m_HashCode; // = 0;
        private bool m_ComputedHashCode; // = false;
        private bool m_disposed; // = false;
        private bool m_UsesProxySemantics;

        //
        // Internal Access to the Response Stream,
        //  public method is GetResponseStream
        //
        internal ConnectStream ResponseStream {
            get {
                return m_ConnectStream;
            }
            set {
                m_ConnectStream = value;
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Cookies"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieCollection Cookies {
            get {
                CheckDisposed();
                if (m_cookies == null) {
                    m_cookies = new CookieCollection();
                }
                return m_cookies;
            }
            set {
                CheckDisposed();
                m_cookies = value;
            }
        }

        // retreives response header object
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Headers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the headers associated with this response from the server.
        ///    </para>
        /// </devdoc>
        public override WebHeaderCollection Headers {
            get {
                CheckDisposed();
                return m_HttpResponseHeaders;
            }
        }

        // ContentLength, -1 indicates unknown value
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the lenght of the content returned by the request.
        ///    </para>
        /// </devdoc>
        public override long ContentLength {
            get {
                return m_ContentLength;
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ContentEncoding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       method used to encode the body of the response.
        ///    </para>
        /// </devdoc>
        public String ContentEncoding {
            get {
                CheckDisposed();
                return GetResponseHeader(HttpKnownHeaderNames.ContentEncoding);
            }
        }

        // Returns the Content-Type of the response.

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ContentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the content type of the
        ///       response.
        ///    </para>
        /// </devdoc>
        public override string ContentType {
            get {
                CheckDisposed();
                GetContentType();
                return m_ContentType;
            }
        }

        private void GetContentType() {
            if (!m_GotContentType) {
                m_ContentType = GetResponseHeader(HttpKnownHeaderNames.ContentType);
                m_GotContentType = true;
            }
        }

        // UEUE
        // if the header is:
        // Content-Type: text/html; charset=ISO-8859-4
        // then if HttpWebRequest.MediaType == "text/html"
        // HttpWebResponse.ContentType == "text/html; charset=ISO-8859-4"
        // HttpWebResponse.CharacterSet == "charset=ISO-8859-4"
        // otherwise if HttpWebRequest.MediaType != "text/html"
        // HttpWebResponse.ContentType == "text/html; charset=ISO-8859-4"
        // HttpWebResponse.CharacterSet == ""
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.CharacterSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string CharacterSet {
            get {
                CheckDisposed();
                GetContentType();
                if (m_MediaType!=null && m_ContentType!=null && m_MediaType.Length>0) {
                    int k = m_ContentType.IndexOf(m_MediaType);
                    if (k>=0 && m_ContentType.Length>k+m_MediaType.Length && (m_ContentType[k+m_MediaType.Length]==';' || m_ContentType[k+m_MediaType.Length]==' ')) {
                        int i = m_ContentType.IndexOf("charset=");
                        if (i>=0) {
                            i += 8;
                            int j = m_ContentType.IndexOf(';', i);
                            if (j>=i) {
                                return m_ContentType.Substring(i,j-i);
                            }
                            return m_ContentType.Substring(i);
                        }
                    }
                }
                return string.Empty;
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Server"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the server that sent the response.
        ///    </para>
        /// </devdoc>
        public string Server {
            get {
                CheckDisposed();
                return GetResponseHeader(HttpKnownHeaderNames.Server);
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.LastModified"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the last
        ///       date and time that the content of the response was modified.
        ///    </para>
        /// </devdoc>
        public  DateTime LastModified {
            get {
                CheckDisposed();

                string lastmodHeaderValue = m_HttpResponseHeaders[HttpKnownHeaderNames.LastModified];

                if (lastmodHeaderValue == null) {
                    return DateTime.Now;
                }
                return HttpProtocolUtils.string2date(lastmodHeaderValue);
            }
        }

        // returns StatusCode
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.StatusCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a number indicating the status of the response.
        ///    </para>
        /// </devdoc>
        public HttpStatusCode StatusCode {
            get {
                return m_StatusCode;
            }
        }

        // returns StatusDescription
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.StatusDescription"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the status description returned with the response.
        ///    </para>
        /// </devdoc>
        public string StatusDescription {
            get {
                CheckDisposed();
                return m_StatusDescription;
            }
        }

        // HTTP Version
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ProtocolVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the version of the HTTP protocol used in the response.
        ///    </para>
        /// </devdoc>
        public Version ProtocolVersion {
            get {
                CheckDisposed();
                return m_Version;
            }
        }


        internal bool KeepAlive {
            get {
                if (ProtocolVersion==HttpVersion.Version10) {
                    string keepAliveHeader = Headers[HttpKnownHeaderNames.KeepAlive];
                    return keepAliveHeader!=null;
                }
                if (ProtocolVersion>=HttpVersion.Version11) {
                    string connectionHeader;
                    if (m_UsesProxySemantics) {
                        connectionHeader = Headers[HttpKnownHeaderNames.ProxyConnection];
                        if (connectionHeader!=null) {
                            return connectionHeader.ToLower(CultureInfo.InvariantCulture).IndexOf("close")<0 || connectionHeader.ToLower(CultureInfo.InvariantCulture).IndexOf("keep-alive")>=0;
                        }
                    }
                    connectionHeader = Headers[HttpKnownHeaderNames.Connection];
                    return connectionHeader==null || connectionHeader.ToLower(CultureInfo.InvariantCulture).IndexOf("close")<0 || connectionHeader.ToLower(CultureInfo.InvariantCulture).IndexOf("keep-alive")>=0;
                }
                return false;
            }
        }


        /*++

            ResponseStream - Return the response stream.

            This property returns the response stream for this response. The
            response stream will do de-chunking, etc. as needed.

            Input: Nothing. Property is readonly.

            Returns: Response stream for response.

        --*/


        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.GetResponseStream"]/*' />
        /// <devdoc>
        ///    <para>Gets the stream used for reading the body of the response from the
        ///       server.</para>
        /// </devdoc>
        public override Stream GetResponseStream() {
            CheckDisposed();

            if ( !CanGetResponseStream() )
            {
                // give a blank stream in the HEAD case, which = 0 bytes of data
                return Stream.Null;
            }
            return m_ConnectStream;
        }

        /*++

            Close - Closes the Response after the use.

            This causes the read stream to be closed.

        --*/

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Close"]/*' />
        public override void Close() {
            ConnectStream chkConnectStream = m_ConnectStream;
            if (chkConnectStream!=null) {
                chkConnectStream.Close();
            }
        }

        internal void Abort() {
            ConnectStream chkConnectStream = m_ConnectStream;
            if (chkConnectStream!=null) {
                chkConnectStream.Abort();
            }
        }

        // true if we success a call to get ResponseStream, note this code
        // is duplicated and should use code out of the HttpWebRequest
        internal bool CanGetResponseStream() {
            return !KnownVerbs.GetHttpVerbType(m_Verb).m_ExpectNoContentResponse;

        }

        internal HttpWebResponse(
            Uri responseUri,
            string verb,
            CoreResponseData coreData,
            string mediaType,
            bool usesProxySemantics) {

            m_Uri                       = responseUri;
            m_Verb                      = verb;
            m_MediaType                 = mediaType;
            m_UsesProxySemantics        = usesProxySemantics;

            m_ConnectStream             = coreData.m_ConnectStream;
            m_HttpResponseHeaders       = coreData.m_ResponseHeaders;
            m_ContentLength             = coreData.m_ContentLength;
            m_StatusCode                = coreData.m_StatusCode;
            m_StatusDescription         = coreData.m_StatusDescription;
            m_Version                   = coreData.m_Version;

            // handle Content-Location header, by combining it with the orginal request.
            string contentLocation = m_HttpResponseHeaders[HttpKnownHeaderNames.ContentLocation];

            if (contentLocation != null) {
                try {
                    m_Uri = new Uri(m_Uri, contentLocation);
                } catch (Exception e) {
                    GlobalLog.Assert(false, "Exception on Uri parsing", e.ToString());
                }
            }
        }

        //
        // ISerializable constructor
        //
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.HttpWebResponse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected HttpWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            m_HttpResponseHeaders   = (WebHeaderCollection)serializationInfo.GetValue("m_HttpResponseHeaders", typeof(WebHeaderCollection));
            m_Uri                   = (Uri)serializationInfo.GetValue("m_Uri", typeof(Uri));
            m_Certificate           = (X509Certificate)serializationInfo.GetValue("m_Certificate", typeof(X509Certificate));
            m_Version               = (Version)serializationInfo.GetValue("m_Version", typeof(Version));
            m_StatusCode            = (HttpStatusCode)serializationInfo.GetInt32("m_StatusCode");
            m_ContentLength         = serializationInfo.GetInt64("m_ContentLength");
            m_Verb                  = serializationInfo.GetString("m_Verb");
            m_StatusDescription     = serializationInfo.GetString("m_StatusDescription");
            m_MediaType             = serializationInfo.GetString("m_MediaType");
            m_ContentType           = serializationInfo.GetString("m_ContentType");
            m_GotContentType        = serializationInfo.GetBoolean("m_GotContentType");

            return;
        }

        //
        // ISerializable method
        //
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            //
            // for now disregard streamingContext.
            // just Add all the members we need to deserialize to construct
            // the object at deserialization time
            //
            // the following runtime types already support serialization:
            // Boolean, Char, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, DateTime
            // for the others we need to provide our own serialization
            //
            serializationInfo.AddValue("m_HttpResponseHeaders", m_HttpResponseHeaders, typeof(WebHeaderCollection));
            serializationInfo.AddValue("m_Uri", m_Uri, typeof(Uri));
            serializationInfo.AddValue("m_Certificate", m_Certificate, typeof(X509Certificate));
            serializationInfo.AddValue("m_Version", m_Version, typeof(Version));
            serializationInfo.AddValue("m_StatusCode", m_StatusCode);
            serializationInfo.AddValue("m_ContentLength", m_ContentLength);
            serializationInfo.AddValue("m_Verb", m_Verb);
            serializationInfo.AddValue("m_StatusDescription", m_StatusDescription);
            serializationInfo.AddValue("m_MediaType", m_MediaType);
            serializationInfo.AddValue("m_ContentType", m_ContentType);
            serializationInfo.AddValue("m_GotContentType", m_GotContentType);

            return;
        }




        /*++

        Routine Description:

            Gets response headers from parsed server response

        Arguments:

            headerName - HTTP header to search for matching header on.

        Return Value:

            string - contains the matched entry, if found

        --*/
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.GetResponseHeader"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a specified header value returned with the response.
        ///    </para>
        /// </devdoc>
        public string GetResponseHeader( string headerName ) {
            CheckDisposed();

            string headerValue = m_HttpResponseHeaders[headerName];

            return ( (headerValue==null) ? String.Empty : headerValue );
        }

#if HTTP_HEADER_EXTENSIONS_SUPPORTED
        // searches for extension header in response
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.GetExtension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetExtension(HttpExtension extension, string header) {
            CheckDisposed();
            return GetResponseHeader(header);
        }
#endif

        /*++

            ResponseUri  - Gets the final Response Uri, that includes any
             changes that may have transpired from the orginal Request

            This property returns Uri for this WebResponse.

            Input: Nothing.

            Returns: Response Uri for response.

                    read-only

        --*/

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ResponseUri"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Uniform Resource Indentifier (Uri) of the resource that returned the
        ///       response.
        ///    </para>
        /// </devdoc>
        public override Uri ResponseUri {                               // read-only
            get {
                CheckDisposed();
                return m_Uri;
            }
        }

        /*
            Accessor:   Method

            Gets/Sets the http method of this request.
            This method represents the Verb,
            after any redirects

            Returns: Method currently being used.


        */
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Method"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value of the method used to return the response.
        ///    </para>
        /// </devdoc>
        public string Method {
            get {
                CheckDisposed();
                return m_Verb;
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            CheckDisposed();
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

        //
        // IDisposable
        //

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (!m_disposed) {
                m_disposed = true;
                Close();
                if (disposing) {
                    m_Uri = null;
                    m_Verb = null;;
                    m_StatusDescription = null;
                    m_HttpResponseHeaders = null;
                    m_MediaType = null;
                    m_Version = null;
                    m_Certificate = null;
                    m_ContentType = null;
                    m_cookies = null;
                }
            }
        }

        private void CheckDisposed() {
            if (m_disposed) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
        }

    } // class HttpWebResponse


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\icredentials.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICredentials.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Net {

    //using System;
    //using System.Net;
    using System.Runtime.InteropServices;

    //
    // This is an extensible interface that authenticators
    // must implement to support credential lookup.
    // During execution of the protocol, if authentication
    // information is needed the GetCredential function will
    // be called with the host and realm information.
    //

    /// <include file='doc\ICredentials.uex' path='docs/doc[@for="ICredentials"]/*' />
    /// <devdoc>
    ///    <para>Provides the base authentication interface for Web client authentication.</para>
    /// </devdoc>
    public interface ICredentials {
        /// <include file='doc\ICredentials.uex' path='docs/doc[@for="ICredentials.GetCredential"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a NetworkCredential object that
        ///       is associated with the supplied host, realm, and authentication type.
        ///    </para>
        /// </devdoc>

        //
        // CONVENTION:
        // returns null if no information is available
        // for the specified host&realm
        //
        NetworkCredential GetCredential(Uri uri, String authType);

    } // interface ICredentials


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\ipaddress.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPAddress.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Net.Sockets;
    using System.Globalization;
    using System.Text;
    
    /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress"]/*' />
    /// <devdoc>
    ///    <para>Provides an internet protocol (IP) address.</para>
    /// </devdoc>
    [Serializable]
    public class IPAddress {

        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.Any"]/*' />
        public static readonly IPAddress Any = new IPAddress(0x0000000000000000);
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.Loopback"]/*' />
        public static readonly  IPAddress Loopback = new IPAddress(0x000000000100007F);
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.Broadcast"]/*' />
        public static readonly  IPAddress Broadcast = new IPAddress(0x00000000FFFFFFFF);
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.None"]/*' />
        public static readonly  IPAddress None = Broadcast;

        internal const long LoopbackMask = 0x000000000000007F;
        internal const string InaddrNoneString = "255.255.255.255";
        internal const string InaddrNoneStringHex = "0xff.0xff.0xff.0xff";
        internal const string InaddrNoneStringOct = "0377.0377.0377.0377";
        //
        // IPv6 Changes: make this internal so other NCL classes that understand about
        //               IPv4 and IPv4 can still access it rather than the obsolete property.
        //
        internal long m_Address;

#if COMNET_DISABLEIPV6
        internal static readonly IPAddress IPv6Any      = new IPAddress(new byte[]{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 });
        internal static readonly IPAddress IPv6Loopback = new IPAddress(new byte[]{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 });
        internal static readonly IPAddress IPv6None     = new IPAddress(new byte[]{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 });
#else
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.IPv6Any"]/*' />
        public static readonly IPAddress IPv6Any      = new IPAddress(new byte[]{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 });
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.IPv6Loopback"]/*' />
        public static readonly IPAddress IPv6Loopback = new IPAddress(new byte[]{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 });
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.IPv6None"]/*' />
        public static readonly IPAddress IPv6None     = new IPAddress(new byte[]{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 });
#endif

        /// <devdoc>
        ///   <para>
        ///     Default to IPv4 address
        ///   </para>
        /// </devdoc>
        private AddressFamily m_Family       = AddressFamily.InterNetwork;
        private ushort[]      m_Numbers      = new ushort[NumberOfLabels];
        private long          m_ScopeId      = 0;                             // really uint !
        private int           m_HashCode     = 0;

        internal const int NumberOfLabels = 8;
        private static bool         s_Initialized = Socket.InitializeSockets();


        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.IPAddress"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.IPAddress'/>
        ///       class with the specified
        ///       address.
        ///    </para>
        /// </devdoc>
        public IPAddress(long newAddress) {
            if (newAddress<0 || newAddress>0x00000000FFFFFFFF) {
                throw new ArgumentOutOfRangeException("newAddress");
            }
            m_Address = newAddress;
        }

#if COMNET_DISABLEIPV6
        //
        // Use internal instead of private to avoid having to amend IPEndPoint as well
        //
        internal IPAddress(byte[] address,long scopeid) {
#else
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.IPAddress1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Constructor for an IPv6 Address with a specified Scope.
        ///    </para>
        /// </devdoc>
        public IPAddress(byte[] address,long scopeid) {
#endif
            if ( address==null ) {
                throw new ArgumentNullException("address");
            }
            if ( address.Length != 16 ) {
                throw new ArgumentException("address");
            }

            m_Family = AddressFamily.InterNetworkV6;

            for (int i = 0; i < NumberOfLabels; i++) {
                m_Numbers[i] = (ushort)(address[i * 2] * 256 + address[i * 2 + 1]);
            }

            //
            // Consider: Since scope is only valid for link-local and site-local
            //           addresses we could implement some more robust checking here
            //
            if ( scopeid < 0 || scopeid > 0x00000000FFFFFFFF ) {
                throw new ArgumentOutOfRangeException("scopeid");
            }

            m_ScopeId = scopeid;
        }

#if COMNET_DISABLEIPV6
        //
        // Use internal instead of private to avoid having to amend Socket as well
        //
        internal IPAddress(byte[] address) : this(address,0) {
#else
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.IPAddress2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Constructor for IPv6 Address with a Scope of zero.
        ///    </para>
        /// </devdoc>
        public IPAddress(byte[] address) : this(address,0) {
#endif
        }

        //
        // we need this internally since we need to interface with winsock
        // and winsock only understands Int32
        //
        internal IPAddress(int newAddress) {
            m_Address = (long)newAddress & 0x00000000FFFFFFFF;
        }


        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.Parse"]/*' />
        /// <devdoc>
        /// <para>Converts an IP address string to an <see cref='System.Net.IPAddress'/>
        /// instance.</para>
        /// </devdoc>
        public static IPAddress Parse(string ipString) {
            if (ipString == null) {
                throw new ArgumentNullException("ipString");
            }

            //
            // IPv6 Changes: Detect probable IPv6 addresses and use separate
            //               parse method.
            //
            if ( ipString.IndexOf(':') != -1 ) {
                //
                // If the address string contains the colon character
                // then it can only be an IPv6 address. Use a separate
                // parse method to unpick it all. Note: we don't support
                // port specification at the end of address and so can
                // make this decision.
                //
                // We need to make sure that Socket is initialized for this
                // call !
                //
                bool ipv6 = Socket.SupportsIPv6;

                SocketAddress saddr = new SocketAddress(AddressFamily.InterNetworkV6,28);

                int errorCode =
                    UnsafeNclNativeMethods.OSSOCK.WSAStringToAddress(
                        ipString,
                        AddressFamily.InterNetworkV6,
                        IntPtr.Zero,
                        saddr.m_Buffer,
                        ref saddr.m_Size );

                if (errorCode!=SocketErrors.Success) {
                    GlobalLog.Print("IPAddress::Parse() IPv6 ipString:[" + ValidationHelper.ToString(ipString) + "] errorCode: " + errorCode.ToString());
                    throw new FormatException(SR.GetString(SR.dns_bad_ip_address), new SocketException());
                }
                //
                // We have to set up the address by hand now, to avoid initialization
                // recursion problems that we get if we use IPEndPoint.Create.
                //
                byte[] bytes = new byte[16];
                long   scope = 0;

                for ( int i = 0; i < 16; i++ ) {
                    bytes[i] = saddr[i + 8];
                }
                //
                // Scope
                //
                scope = (long)((saddr[27]<<24) +
                               (saddr[26]<<16) +
                               (saddr[25]<<8 ) +
                               (saddr[24]));

                return new IPAddress(bytes,scope);;
            }
            else
            {
                //
                // Cannot be an IPv6 address, so use the IPv4 routines to
                // parse the string representation.
                //
                int address = UnsafeNclNativeMethods.OSSOCK.inet_addr(ipString);
    
                GlobalLog.Print("IPAddress::Parse() ipString:" + ValidationHelper.ToString(ipString) + " inet_addr() returned address:" + address.ToString());
    
                if (address==-1
                    && string.Compare(ipString, InaddrNoneString, false, CultureInfo.InvariantCulture)!=0
                    && string.Compare(ipString, InaddrNoneStringHex, true, CultureInfo.InvariantCulture)!=0
                    && string.Compare(ipString, InaddrNoneStringOct, false, CultureInfo.InvariantCulture)!=0) {
                    throw new FormatException(SR.GetString(SR.dns_bad_ip_address));
                }
    
                IPAddress returnValue = new IPAddress(address);
    
                return returnValue;
            }
        } // Parse

        /*
         * Hand-written parser for IPv6 addresses is not used. We use WSAStringToAddress instead.
         *
        /// <devdoc>
        ///    <para>
        ///       Parse an IPv6 address string.
        ///    </para>
        /// </devdoc>
        private static IPAddress ParseIPv6(string value) {
            if ( value==null ) {
                throw new ArgumentNullException("value");
            }

            string    address    = null;
            string[]  elements   = null;
            string[]  parts      = null;
            IPAddress instance   = new IPAddress(0);
            int       compressor = -1;
            int       npos       = 7;
            int       i          = 0;

            //
            // Look for [...] wrappers
            //
            if ( value[0] == '[' ) {
                if ( value[value.Length - 1] == ']' ) {
                    //
                    // Peel out the middle part
                    //
                    address = value.Substring(1,value.Length - 2);
                }
                else {
                    throw new FormatException(SR.GetString(SR.dns_bad_ip_address));
                }
            }
            else {
                address = value;
            }

            //
            // Look for % scope identifier
            //
            if ( ( i = address.IndexOf('%') ) != -1 ) {
                //
                // Process the scope specification
                //
                try {
                    instance.m_ScopeId = UInt32.Parse(address.Substring(i + 1));
                }
                catch {
                    throw new FormatException(SR.GetString(SR.dns_bad_ip_address));
                }

                address = address.Substring(0,i);
            }

            //
            // Check for the :: case
            //
            if ( address == "::" ) {
                address = "::0";
            }

            //
            // Now break up the remaining parts of the address
            //
            elements = new string[8];
            parts    = address.Split(':');
            i        = parts.Length - 1;    // start at the end

            if ( parts.Length > 8 || parts.Length < 3 ) {
                throw new FormatException(SR.GetString(SR.dns_bad_ip_address));
            }

            //
            // Process the parts in reverse order
            //

            // 
            // Special case at the tail end: IPv4 addresses
            //
            if ( (parts[i].IndexOf('.') != -1) ) {
                //
                // Looks like an IPv4 address at the end.
                //
                if ( i > 6 ) { // parts.Length > 7 
                    throw new FormatException(SR.GetString(SR.dns_bad_ip_address));
                }
                else {
                    IPAddress x = IPAddress.Parse(parts[i]);
                    // 
                    // Now pack the numeric address in here
                    //
                    instance.m_Numbers[npos]    = (ushort)( ( x.Address & 0xFF000000 ) >> 24 );
                    instance.m_Numbers[npos--] += (ushort)( ( x.Address & 0x00FF0000 ) >> 8 );
                    instance.m_Numbers[npos]    = (ushort)( ( x.Address & 0x0000FF00 ) >> 8 );
                    instance.m_Numbers[npos--] += (ushort)( ( x.Address & 0x000000FF ) << 8 );

                    i--; // step back to previous part
                }
            }

            //
            // Now zip through the remainder
            //
            for ( ; i >= 0; i-- ) {
                if ( parts[i] == string.Empty ) {
                    //
                    // An empty part indicates either compressor or initial element
                    //
                    if ( compressor == -1 ) {
                        //
                        // Its the compressor, record it's position
                        //
                        compressor = i;
                        //
                        // Adjust position in the numbers array to account for
                        // the compressor.
                        //
                        while ( npos >= compressor ) {
                            instance.m_Numbers[npos--] = 0;
                        }
                    }
                    else {
                        //
                        // Might be a leading blank before the compressor (::1 case)
                        //
                        if ( compressor != 1 ) {
                            //
                            // Maybe not..
                            //
                            throw new FormatException(SR.GetString(SR.dns_bad_ip_address));
                        }
                        else {
                            instance.m_Numbers[npos--] = 0;
                        }
                    }
                }
                else {
                    //
                    // Check the part
                    //
                    instance.m_Numbers[npos--] = ParseIPv6Part(parts[i]);
                }
            }
            //
            // Make sure we filled the buffer
            //
            //if ( compressor == -1 && parts.Length != 8 ) {
            if ( npos != -1 ) {
                throw new FormatException(SR.GetString(SR.dns_bad_ip_address));
            }
            //
            // Update the address family
            //
            instance.m_Family = AddressFamily.InterNetworkV6;

            return instance;
        }

        private static ushort ParseIPv6Part(string part)
        {
            if ( part.Length > 4 ) {
                throw new FormatException(SR.GetString(SR.dns_bad_ip_address));
            }

            ushort number = 0;

            for ( int i = 0; i < part.Length; i++ ) {
                //
                // Uri.FromHex checks for valid hex characters
                //
                number = (ushort)(( number * 16 ) + Uri.FromHex(part[i]));
            }

            return number;
        }
        *
        * End of Hand-written parser
        */


        /**
         * @deprecated IPAddress.Address is address family dependant, use Equals method for comparison.
         */
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.Address"]/*' />
        /// <devdoc>
        ///     <para>
        ///         Mark this as deprecated.
        ///     </para>
        /// </devdoc>
#if !COMNET_DISABLEIPV6
        [Obsolete("IPAddress.Address is address family dependant, use Equals method for comparison.")]
#endif
        public long Address {
            get {
                //
                // IPv6 Changes: Can't do this for IPv6, so throw an exception.
                //
                // 
                if ( m_Family == AddressFamily.InterNetworkV6 ) {
                    throw new SocketException(SocketErrors.WSAEOPNOTSUPP);
                }
                else {
                    return m_Address;
                }
            }
            set {
                //
                // IPv6 Changes: Can't do this for IPv6 addresses
                if ( m_Family == AddressFamily.InterNetworkV6 ) {
                    throw new SocketException(SocketErrors.WSAEOPNOTSUPP);
                }
                else {
                    m_Address = value;
                }
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Provides a copy of the IPAddress internals as an array of bytes. 
        ///    </para>
        /// </devdoc>
        public byte[] GetAddressBytes() {
            byte[] bytes;
            if (m_Family == AddressFamily.InterNetworkV6 ) {
                bytes = new byte[NumberOfLabels * 2];

                int j = 0;
                for ( int i = 0; i < NumberOfLabels; i++) {
                    bytes[j++] = (byte)((this.m_Numbers[i] >> 8) & 0xFF);
                    bytes[j++] = (byte)((this.m_Numbers[i]     ) & 0xFF);
                }
            }
            else {
                bytes = new byte[4];
                bytes[0] = (byte)(m_Address);
                bytes[1] = (byte)(m_Address >> 8);
                bytes[2] = (byte)(m_Address >> 16);
                bytes[3] = (byte)(m_Address >> 24);
            }
            return bytes;
        }

        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.AddressFamily"]/*' />
        public AddressFamily AddressFamily {
            get {
                return m_Family;
            }
        }

#if COMNET_DISABLEIPV6
        //
        // Use internal instead of private to avoid having to modify IPEndPoint.cs
        //
        internal long ScopeId {
#else
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.ScopeId"]/*' />
        /// <devdoc>
        ///    <para>
        ///        IPv6 Scope identifier. This is really a uint32, but that isn't CLS compliant
        ///    </para>
        /// </devdoc>
        public long ScopeId {
#endif
            get {
                //
                // Not valid for IPv4 addresses
                //
                if ( m_Family == AddressFamily.InterNetwork ) {
                    throw new SocketException(SocketErrors.WSAEOPNOTSUPP);
                }
                    
                return m_ScopeId;
            }
            set {
                //
                // Not valid for IPv4 addresses
                //
                if ( m_Family == AddressFamily.InterNetwork ) {
                    throw new SocketException(SocketErrors.WSAEOPNOTSUPP);
                }
                    
                //
                // Consider: Since scope is only valid for link-local and site-local
                //           addresses we could implement some more robust checking here
                //
                if ( value < 0 || value > 0x00000000FFFFFFFF) {
                    throw new ArgumentOutOfRangeException("value");
                }

                m_ScopeId = value;
            }
        }

        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the Internet address to either standard dotted quad format
        ///       or standard IPv6 representation.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            //
            // IPv6 Changes: generate the IPV6 representation
            //
            if ( m_Family == AddressFamily.InterNetworkV6 ) {
                int addressStringLength = 256;

                StringBuilder addressString = new StringBuilder(addressStringLength);
                SocketAddress saddr = new SocketAddress(AddressFamily.InterNetworkV6,28);

                int j = 8;
                for ( int i = 0; i < NumberOfLabels; i++) {
                    saddr[j++] = (byte)(this.m_Numbers[i] >> 8);
                    saddr[j++] = (byte)(this.m_Numbers[i]);
                }
   
                if (m_ScopeId >0) {
                    saddr[24] = (byte)m_ScopeId;
                    saddr[25] = (byte)(m_ScopeId >> 8);
                    saddr[26] = (byte)(m_ScopeId >> 16);
                    saddr[27] = (byte)(m_ScopeId >> 24);
                }

                int errorCode =
                    UnsafeNclNativeMethods.OSSOCK.WSAAddressToString(
                    saddr.m_Buffer,
                    saddr.m_Size,
                    IntPtr.Zero,
                    addressString,
                    ref addressStringLength);

                if (errorCode!=SocketErrors.Success) {
                    SocketException socketException = new SocketException();
                    throw socketException;
                }
                return addressString.ToString();
            }
            else {
                return  (m_Address&0xFF).ToString() + "." +
                       ((m_Address>>8)&0xFF).ToString() + "." +
                       ((m_Address>>16)&0xFF).ToString() + "." +
                       ((m_Address>>24)&0xFF).ToString();
            }
        }

        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.HostToNetworkOrder"]/*' />
        public static long HostToNetworkOrder(long host) {
            return (((long)HostToNetworkOrder((int)host) & 0xFFFFFFFF) << 32)
                    | ((long)HostToNetworkOrder((int)(host >> 32)) & 0xFFFFFFFF);
        }
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.HostToNetworkOrder1"]/*' />
        public static int HostToNetworkOrder(int host) {
            return (((int)HostToNetworkOrder((short)host) & 0xFFFF) << 16)
                    | ((int)HostToNetworkOrder((short)(host >> 16)) & 0xFFFF);
        }
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.HostToNetworkOrder2"]/*' />
        public static short HostToNetworkOrder(short host) {
            return (short)((((int)host & 0xFF) << 8) | (int)((host >> 8) & 0xFF));
        }
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.NetworkToHostOrder"]/*' />
        public static long NetworkToHostOrder(long network) {
            return HostToNetworkOrder(network);
        }
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.NetworkToHostOrder1"]/*' />
        public static int NetworkToHostOrder(int network) {
            return HostToNetworkOrder(network);
        }
        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.NetworkToHostOrder2"]/*' />
        public static short NetworkToHostOrder(short network) {
            return HostToNetworkOrder(network);
        }

        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.IsLoopback"]/*' />
        public static bool IsLoopback(IPAddress address) {
            if ( address.m_Family == AddressFamily.InterNetworkV6 ) {
                //
                // Do Equals test for IPv6 addresses
                //
                return address.Equals(IPv6Loopback);
            }
            else {
                return ((address.m_Address & IPAddress.LoopbackMask) == (IPAddress.Loopback.m_Address & IPAddress.LoopbackMask));
            }
        }

        internal bool IsBroadcast {
            get {
                if ( m_Family == AddressFamily.InterNetworkV6 ) {
                    //
                    // No such thing as a broadcast address for IPv6
                    //
                    return false;
                }
                else {
                    return m_Address==Broadcast.m_Address;
                }
            }
        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv6 Multicast address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv6Multicast() {
            return ( m_Family == AddressFamily.InterNetworkV6 ) &&
                   ( ( this.m_Numbers[0] & 0xFF00 ) == 0xFF00 );

        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv6 Multicast Node local address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv6MulticastNodeLocal() {
            return ( IsIPv6Multicast() ) &&
                   ( ( this.m_Numbers[0] & 0x000F ) == 1 );

        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv6 Multicast Link local address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv6MulticastLinkLocal() {
            return ( IsIPv6Multicast() ) &&
                   ( ( this.m_Numbers[0] & 0x000F ) == 0x0002 );

        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv6 Multicast Site local address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv6MulticastSiteLocal() {
            return ( IsIPv6Multicast() ) &&
                   ( ( this.m_Numbers[0] & 0x000F ) == 0x0005 );

        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv6 Multicast Org local address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv6MulticastOrgLocal() {
            return ( IsIPv6Multicast() ) &&
                   ( ( this.m_Numbers[0] & 0x000F ) == 0x0008 );

        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv6 Multicast Global address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv6MulticastGlobal() {
            return ( IsIPv6Multicast() ) &&
                   ( ( this.m_Numbers[0] & 0x000F ) == 0x000E );

        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv6 Link Local address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv6LinkLocal() {
            return ( m_Family == AddressFamily.InterNetworkV6 ) &&
                   ( ( this.m_Numbers[0] & 0xFFC0 ) == 0xFE80 );
        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv6 Site Local address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv6SiteLocal() {
            return ( m_Family == AddressFamily.InterNetworkV6 ) &&
                   ( ( this.m_Numbers[0] & 0xFFC0 ) == 0xFEC0 );
        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv4 Mapped Address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv4Mapped() {
            return ( m_Family == AddressFamily.InterNetworkV6 ) &&
                   ( m_Numbers[0] == 0x0000 ) &&
                   ( m_Numbers[1] == 0x0000 ) &&
                   ( m_Numbers[2] == 0x0000 ) &&
                   ( m_Numbers[3] == 0x0000 ) &&
                   ( m_Numbers[4] == 0x0000 ) &&
                   ( m_Numbers[5] == 0xffff );
        }

        /// <devdoc>
        ///    <para>
        ///       V.Next: Determines if an address is an IPv4 Compatible Address
        ///    </para>
        /// </devdoc>
        internal bool IsIPv4Compatible() {
            return ( m_Family == AddressFamily.InterNetworkV6 ) &&
                   ( m_Numbers[0] == 0x0000 ) &&
                   ( m_Numbers[1] == 0x0000 ) &&
                   ( m_Numbers[2] == 0x0000 ) &&
                   ( m_Numbers[3] == 0x0000 ) &&
                   ( m_Numbers[4] == 0x0000 ) &&
                   ( m_Numbers[5] == 0x0000 ) &&
                   !( ( m_Numbers[6] == 0x0000 )              &&
                      ( ( m_Numbers[7] & 0xFF00 ) == 0x0000 ) &&
                      ( ( ( m_Numbers[7] & 0x00FF ) == 0x0000 ) || ( m_Numbers[7] & 0x00FF ) == 0x0001 ) );
        }

        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares two IP addresses.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object comparand) {
            if (!(comparand is IPAddress)) {
                return false;
            }
            //
            // Compare families before address representations
            //
            if ( m_Family != ((IPAddress)comparand).m_Family ) {
                return false;
            }
            if ( m_Family == AddressFamily.InterNetworkV6 ) {
                //
                // For IPv6 addresses, we must compare the full 128bit
                // representation.
                //
                for ( int i = 0; i < NumberOfLabels; i++) {
                    if ( ((IPAddress)comparand).m_Numbers[i] != this.m_Numbers[i] )
                        return false;
                }
                //
                // In addition, the scope id's must match as well
                //
                if ( ((IPAddress)comparand).m_ScopeId == this.m_ScopeId )
                    return true;
                else
                    return false;
            }
            else {
                //
                // For IPv4 addresses, compare the integer representation.
                //
                return ((IPAddress)comparand).m_Address==this.m_Address;
            }
        }

        /// <include file='doc\IPAddress.uex' path='docs/doc[@for="IPAddress.GetHashCode"]/*' />
        public override int GetHashCode() {
            //
            // For IPv6 addresses, we cannot simply return the integer
            // representation as the hashcode. Instead, we calculate
            // the hashcode from the string representation of the address.
            //
            if ( m_Family == AddressFamily.InterNetworkV6 ) {
                if ( m_HashCode == 0 )
                    m_HashCode = Uri.CalculateCaseInsensitiveHashCode(ToString());

                return m_HashCode;
            }
            else {
                //
                // For IPv4 addresses, we can simply use the integer
                // representation.
                //
                return unchecked((int)m_Address);
            }
        }

    } // class IPAddress


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\iphostentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPHostEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

// Host information
    /// <include file='doc\IPHostEntry.uex' path='docs/doc[@for="IPHostEntry"]/*' />
    /// <devdoc>
    ///    <para>Provides a container class for Internet host address information..</para>
    /// </devdoc>
    public class IPHostEntry {
        string hostName;
        string[] aliases;
        IPAddress[] addressList;

        /// <include file='doc\IPHostEntry.uex' path='docs/doc[@for="IPHostEntry.HostName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Contains the DNS
        ///       name of the host.
        ///    </para>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public string HostName {
            get {
                return hostName;
            }
            set {
                hostName = value;
            }
        }

        /// <include file='doc\IPHostEntry.uex' path='docs/doc[@for="IPHostEntry.Aliases"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides an
        ///       array of strings containing other DNS names that resolve to the IP addresses
        ///       in <paramref name='AddressList'/>.
        ///    </para>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public string[] Aliases {
            get {
                return aliases;
            }
            set {
                aliases = value;
            }
        }

        /// <include file='doc\IPHostEntry.uex' path='docs/doc[@for="IPHostEntry.AddressList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides an
        ///       array of <paramref name='IPAddress'/> objects.
        ///    </para>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public IPAddress[] AddressList {
            get {
                return addressList;
            }
            set {
                addressList = value;
            }
        }
    } // class IPHostEntry
} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\ipendpoint.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPEndPoint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Net.Sockets;

    /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides an IP address.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public class IPEndPoint : EndPoint {
        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.MinPort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the minimum acceptable value for the <see cref='System.Net.IPEndPoint.Port'/>
        ///       property.
        ///    </para>
        /// </devdoc>
        public const int MinPort = 0x00000000;
        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.MaxPort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the maximum acceptable value for the <see cref='System.Net.IPEndPoint.Port'/>
        ///       property.
        ///    </para>
        /// </devdoc>
        public const int MaxPort = 0x0000FFFF;

        private IPAddress m_Address;
        private int m_Port;
        private const int IPv6AddressSize = 28; // sizeof(sockaddr_in6)
        private const int IPv4AddressSize = 16;

        internal const int AnyPort = MinPort;

        internal static IPEndPoint Any     = new IPEndPoint(IPAddress.Any, AnyPort);
        internal static IPEndPoint IPv6Any = new IPEndPoint(IPAddress.IPv6Any,AnyPort);


        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.AddressFamily"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override AddressFamily AddressFamily {
            get {
                //
                // IPv6 Changes: Always delegate this to the address we are
                //               wrapping.
                //
                return m_Address.AddressFamily;
            }
        }

        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.IPEndPoint"]/*' />
        /// <devdoc>
        ///    <para>Creates a new instance of the IPEndPoint class with the specified address and
        ///       port.</para>
        /// </devdoc>
        public IPEndPoint(long address, int port) {
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }
            m_Port = port;
            m_Address = new IPAddress(address);
        }

        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.IPEndPoint1"]/*' />
        /// <devdoc>
        ///    <para>Creates a new instance of the IPEndPoint class with the specified address and port.</para>
        /// </devdoc>
        public IPEndPoint(IPAddress address, int port) {
            if (address==null) {
                throw new ArgumentNullException("address");
            }
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }
            m_Port = port;
            m_Address = address;
        }

        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.Address"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the IP address.
        ///    </para>
        /// </devdoc>
        public IPAddress Address {
            get {
                return m_Address;
            }
            set {
                m_Address = value;
            }
        }

        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.Port"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the port.
        ///    </para>
        /// </devdoc>
        public int Port {
            get {
                return m_Port;
            }
            set {
                if (!ValidationHelper.ValidateTcpPort(value)) {
                    throw new ArgumentOutOfRangeException("value");
                }
                m_Port = value;
            }
        }


        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {
            return Address.ToString() + ":" + Port.ToString();
        }

        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.Serialize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override SocketAddress Serialize() {
            if ( m_Address.AddressFamily == AddressFamily.InterNetworkV6 ) {
                //
                // IPv6 Changes: create a new SocketAddress that is large enough for an
                //               IPv6 address and then pack the address into it.
                //
                SocketAddress socketAddress = new SocketAddress(this.AddressFamily,IPv6AddressSize);
                //
                // populate it
                //
                socketAddress[2] = (byte)((this.Port>> 8) & 0xFF);
                socketAddress[3] = (byte)((this.Port    ) & 0xFF);
                //
                // Note: No handling for Flow Information
                //
                socketAddress[4]  = (byte)0;
                socketAddress[5]  = (byte)0;
                socketAddress[6]  = (byte)0;
                socketAddress[7]  = (byte)0;
                //
                // Scope serialization
                //
                long scope = this.Address.ScopeId;

                socketAddress[24] = (byte)scope;
                socketAddress[25] = (byte)(scope >> 8);
                socketAddress[26] = (byte)(scope >> 16);
                socketAddress[27] = (byte)(scope >> 24);
                //
                // Address serialization
                //
                byte[] addressBytes = this.Address.GetAddressBytes();

                for ( int i = 0; i < addressBytes.Length; i++ ) {
                    socketAddress[8 + i] = addressBytes[i];
                }

                GlobalLog.Print("IPEndPoint::Serialize(IPv6): " + this.ToString() );

                //
                // return it
                //
                return socketAddress;
            }
            else
            {
                //
                // create a new SocketAddress
                //
                SocketAddress socketAddress = new SocketAddress(m_Address.AddressFamily,IPv4AddressSize);
                //
                // populate it
                //
                socketAddress[2] = unchecked((byte)(this.Port>> 8));
                socketAddress[3] = unchecked((byte)(this.Port    ));
    
                socketAddress[4] = unchecked((byte)(this.Address.m_Address    ));
                socketAddress[5] = unchecked((byte)(this.Address.m_Address>> 8));
                socketAddress[6] = unchecked((byte)(this.Address.m_Address>>16));
                socketAddress[7] = unchecked((byte)(this.Address.m_Address>>24));
    
                GlobalLog.Print("IPEndPoint::Serialize: " + this.ToString() );
    
                //
                // return it
                //
                return socketAddress;
            }
        }

        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override EndPoint Create(SocketAddress socketAddress) {
            //
            // validate SocketAddress
            //
            if (socketAddress.Family != this.AddressFamily) {
                throw new ArgumentException(SR.GetString(SR.net_InvalidAddressFamily, socketAddress.Family.ToString(), this.GetType().FullName, this.AddressFamily.ToString()));
            }
            if (socketAddress.Size<8) {
                throw new ArgumentException(SR.GetString(SR.net_InvalidSocketAddressSize, socketAddress.GetType().FullName, this.GetType().FullName));
            }

            if ( this.AddressFamily == AddressFamily.InterNetworkV6 ) {
                //
                // IPv6 Changes: Extract the IPv6 Address information from the socket address
                //
                byte[] addr = new byte[16];
                for ( int i = 0; i < 16; i++ ) {
                    addr[i] = socketAddress[i + 8];
                }
                //
                // Port
                //
                int port = (int)((socketAddress[2]<<8 & 0xFF00) | (socketAddress[3]));
                //
                // Scope
                //
                long scope = (long)((socketAddress[27] << 24) +
                                    (socketAddress[26] << 16) +
                                    (socketAddress[25] << 8 ) +
                                    (socketAddress[24]));

                IPEndPoint created = new IPEndPoint(new IPAddress(addr,scope),port);

                GlobalLog.Print("IPEndPoint::Create IPv6: " + this.ToString() + " -> " + created.ToString() );

                return created;
            }
            else
            {

                //
                // strip out of SocketAddress information on the EndPoint
                //
                int port = (int)(
                        (socketAddress[2]<<8 & 0xFF00) |
                        (socketAddress[3])
                        );
    
                long address = (long)(
                        (socketAddress[4]     & 0x000000FF) |
                        (socketAddress[5]<<8  & 0x0000FF00) |
                        (socketAddress[6]<<16 & 0x00FF0000) |
                        (socketAddress[7]<<24)
                        ) & 0x00000000FFFFFFFF;
    
                IPEndPoint created = new IPEndPoint(address, port);
    
                GlobalLog.Print("IPEndPoint::Create: " + this.ToString() + " -> " + created.ToString() );
    
                //
                // return it
                //
                return created;
            }
        }


        //UEUE
        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.Equals"]/*' />
        public override bool Equals(object comparand) {
            if (!(comparand is IPEndPoint)) {
                return false;
            }
            return ((IPEndPoint)comparand).m_Address.Equals(m_Address) && ((IPEndPoint)comparand).m_Port==m_Port;
        }

        //UEUE
        /// <include file='doc\IPEndPoint.uex' path='docs/doc[@for="IPEndPoint.GetHashCode"]/*' />
        public override int GetHashCode() {
            return m_Address.GetHashCode() ^ m_Port;
        }


    }; // class IPEndPoint


} // namespace System.Net

//
// IPv6 Changes: Removed redundant IPv6 definitions that were part of V1.0
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\iwebproxy.cs ===
//------------------------------------------------------------------------------
// <copyright file="iwebproxy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Net {
    using System.Runtime.Serialization;

    /// <include file='doc\iwebproxy.uex' path='docs/doc[@for="IWebProxy"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Holds the interface for implementation of the proxy interface.
    ///       Used to implement and control proxy use of WebRequests. 
    ///    </para>
    /// </devdoc>
    public interface IWebProxy  { 
        /// <include file='doc\iwebproxy.uex' path='docs/doc[@for="IWebProxy.GetProxy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        Uri GetProxy( Uri destination );
        /// <include file='doc\iwebproxy.uex' path='docs/doc[@for="IWebProxy.IsBypassed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool IsBypassed(Uri host);
        /// <include file='doc\iwebproxy.uex' path='docs/doc[@for="IWebProxy.Credentials"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ICredentials Credentials { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\iweblistenercreate.cs ===
//------------------------------------------------------------------------------
// <copyright file="IWebListenerCreate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Configuration;
using System.Configuration.Assemblies;

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Util;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;



namespace System.Net {


#if COMNET_LISTENER

    /// <include file='doc\IWebListenerCreate.uex' path='docs/doc[@for="IWebListenerCreate"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IWebListenerCreate {
        /// <include file='doc\IWebListenerCreate.uex' path='docs/doc[@for="IWebListenerCreate.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>



//
// IWebListenerCreate - Interface for creating WebListeners.
//

        WebListener
        Create(
              string protocolName );




    } // interface IWebListenerCreate

#endif // #if COMNET_LISTENER


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if ENABLE_NclNativeMethods

//
// remove above #if statement if we ever need to put some
// PInvoke declaration in this bucket, until it remains empty
// it would just be waisting space to compile it.
//
namespace System.Net {
    using System.Runtime.InteropServices;

    [
    System.Runtime.InteropServices.ComVisible(false)
    ]
    internal class NclNativeMethods {
        //
        // this should remain empty
        //

    }; // class NclNativeMethods


} // namespace System.Net

#endif // #if ENABLE_NclNativeMethods
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\iwebrequestcreate.cs ===
//------------------------------------------------------------------------------
// <copyright file="IWebRequestCreate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Configuration;
using System.Configuration.Assemblies;

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Util;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;



namespace System.Net {


//
// IWebRequestCreate - Interface for creating WebRequests.
//

    /// <include file='doc\IWebRequestCreate.uex' path='docs/doc[@for="IWebRequestCreate"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The <see cref='System.Net.IWebRequestCreate'/> interface is used by the <see cref='System.Net.WebRequest'/>
    ///       class to create <see cref='System.Net.WebRequest'/>
    ///       instances for a registered scheme.
    ///    </para>
    /// </devdoc>
    public interface IWebRequestCreate {
        /// <include file='doc\IWebRequestCreate.uex' path='docs/doc[@for="IWebRequestCreate.Create"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Net.WebRequest'/>
        ///       instance.
        ///    </para>
        /// </devdoc>
        WebRequest Create(Uri uri);
    } // interface IWebRequestCreate


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\networkaccess.cs ===
//------------------------------------------------------------------------------
// <copyright file="NetworkAccess.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Configuration;
using System.Configuration.Assemblies;
 
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Util;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
 


namespace System.Net {


    /// <include file='doc\NetworkAccess.uex' path='docs/doc[@for="NetworkAccess"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines network access permissions.
    ///    </para>
    /// </devdoc>
    public  enum    NetworkAccess {
        /// <include file='doc\NetworkAccess.uex' path='docs/doc[@for="NetworkAccess.Accept"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An application is allowed to accept connections from the Internet.
        ///    </para>
        /// </devdoc>
        Accept  = 0x80,
        /// <include file='doc\NetworkAccess.uex' path='docs/doc[@for="NetworkAccess.Connect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An application is allowed to connect to Internet resources.
        ///    </para>
        /// </devdoc>
        Connect = 0x40



} // enum NetworkAccess


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\protocolviolationexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProtocolViolationException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Runtime.Serialization;
    /// <include file='doc\ProtocolViolationException.uex' path='docs/doc[@for="ProtocolViolationException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       An exception class used when an attempt is made to use an invalid
    ///       protocol.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public class ProtocolViolationException : InvalidOperationException, ISerializable {
        /// <include file='doc\ProtocolViolationException.uex' path='docs/doc[@for="ProtocolViolationException.ProtocolViolationException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.ProtocolViolationException'/>class.
        ///    </para>
        /// </devdoc>
        public ProtocolViolationException() : base() {
        }

        /// <include file='doc\ProtocolViolationException.uex' path='docs/doc[@for="ProtocolViolationException.ProtocolViolationException1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.ProtocolViolationException'/>
        ///       class with the specified message.
        ///    </para>
        /// </devdoc>
        public ProtocolViolationException(string message) : base(message) {
        }

        /// <include file='doc\ProtocolViolationException.uex' path='docs/doc[@for="ProtocolViolationException.ProtocolViolationException2"]/*' />
        protected ProtocolViolationException(SerializationInfo serializationInfo, StreamingContext streamingContext)
            : base(serializationInfo, streamingContext) {
        }

        /// <include file='doc\ProtocolViolationException.uex' path='docs/doc[@for="ProtocolViolationException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            base.GetObjectData(serializationInfo, streamingContext);
        }

    }; // class ProtocolViolationException


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if ENABLE_SafeNclNativeMethods

//
// remove above #if statement if we ever need to put some
// PInvoke declaration in this bucket, until it remains empty
// it would just be waisting space to compile it.
//
namespace System.Net {
    using System.Runtime.InteropServices;
    using System.Security.Permissions;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNclNativeMethods {

    }; // class SafeNativeMethods


} // namespace System.Net

#endif // #if ENABLE_SafeNclNativeMethods
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\servicepoint.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServicePoint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Net.Sockets;
    using System.Collections;
    using System.Threading;
    using System.Security.Permissions;
    using System.Security.Cryptography.X509Certificates;

    // ServicePoints are never created directly but always handed out by the
    // ServicePointManager. The ServicePointManager and the ServicePoints must be in
    // the same name space so that the ServicePointManager can call the
    // internal constructor

    /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint"]/*' />
    /// <devdoc>
    ///    <para>Provides connection management for other classes.</para>
    /// </devdoc>
    public class ServicePoint {
        //
        //  class Members
        //
        private bool                m_ProxyServicePoint = false;
        private bool                m_UserChangedLimit = false;
        private int                 m_ConnectionLimit;
        private ConnectionModes     m_ConnectionMode = ConnectionModes.Pipeline;
        private bool                m_SupportsPipelining;
        private Hashtable           m_ConnectionGroupList = new Hashtable(10);
        private Uri                 m_Address;
        private int                 m_MaxIdleTime;
        private DateTime            m_ExpiresAt;
        private string              m_ConnectionName;
        private IPHostEntryInfo     m_IPHostEntryInfos;
        private int                 m_CurrentAddressInfoIndex;
        private int                 m_ConnectionsSinceDns = -1;
        private int                 m_CurrentConnections;
        private X509Certificate     m_ServerCertificate;
        private X509Certificate     m_ClientCertificate;
        private bool                m_UseNagleAlgorithm = ServicePointManager.UseNagleAlgorithm;
        private bool                m_Expect100Continue = ServicePointManager.Expect100Continue;


        //
        // version and version-implied information
        //
        internal Version            m_Version;
        private bool                m_Understands100Continue = true;

        internal string Hostname {
            get {
                return m_IPHostEntryInfos == null? string.Empty: m_IPHostEntryInfos.HostName;
            }
        }
        //
        // Constants
        //

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.LoopbackConnectionLimit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The default number of loopback (local) connections allowed on a <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        internal const int LoopbackConnectionLimit = Int32.MaxValue;

        //
        // constructors
        //

        internal ServicePoint(Uri address, int maxServicePointIdleTime, int defaultConnectionLimit) {
            m_Address           = address;
            m_ConnectionName    = address.Scheme;
            m_MaxIdleTime       = maxServicePointIdleTime;
            m_ExpiresAt         = DateTime.MinValue;
            m_ConnectionLimit   = defaultConnectionLimit;

            // upon creation, the service point should be idle, by default
            MarkIdle();
        }

        // methods

        /*++

            FindConnectionGroup       -

            Searches for the a Group object that actually holds the connections
              that we want to peak at.


            Input:
                    request                 - Request that's being submitted.
                    connName                - Connection Name if needed

            Returns:
                    ConnectionGroup

        --*/

        internal ConnectionGroup FindConnectionGroup(string connName) {
            string lookupStr = ConnectionGroup.MakeQueryStr(connName);

            GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::FindConnectionGroup() lookupStr:[" + ValidationHelper.ToString(connName) + "]");

            ConnectionGroup entry = m_ConnectionGroupList[lookupStr] as ConnectionGroup;

            if (entry == null) {
                IPAddressInfo   RemoteInfo = GetCurrentIPAddressInfo();
                IPAddress       RemoteAddress = null;
                int             ConnLimit;

                if (RemoteInfo == null) {

                    GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::FindConnectionGroup() RemoteAddress:[(null)] m_UserChangedLimit:" + m_UserChangedLimit.ToString() + " m_ConnectionLimit:" + m_ConnectionLimit.ToString());

                    //
                    // If we don't have any information about the remote IP address,
                    // limit ourself to one connection until the address is resolved.
                    //
                    ConnLimit = 1; // ServicePointManager.DefaultConnectionLimit;
                    //
                    // if this is a user given number, then
                    // make sure to propagte this value
                    //
                    if (m_UserChangedLimit) {
                        ConnLimit = m_ConnectionLimit;
                    }
                }
                else {

                    RemoteAddress = RemoteInfo.Address;

                    if (!RemoteInfo.IsLoopback) {
                        ConnLimit = m_ConnectionLimit;
                    }
                    else {
                        ConnLimit = LoopbackConnectionLimit;
                    }

                    GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::FindConnectionGroup() RemoteAddress:[" + RemoteAddress.ToString() + "] ConnLimit:" + ConnLimit.ToString() + " m_ConnectionLimit:" + m_ConnectionLimit.ToString());
                }

                GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::FindConnectionGroup() creating ConnectionGroup ConnLimit:" + ConnLimit.ToString());

                entry = new ConnectionGroup(this,
                                            RemoteAddress,
                                            ConnLimit,
                                            connName);

                GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::FindConnectionGroup() adding ConnectionGroup lookupStr:[" + lookupStr + "]");

                m_ConnectionGroupList[lookupStr] = entry;
            }
            else {
                GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::FindConnectionGroup() using existing ConnectionGroup");
            }

            GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::FindConnectionGroup() ConnectionGroup.ConnLimit:" + entry.ConnectionLimit.ToString());

            return entry;
        }



        /*++

            SubmitRequest       - Submit a request for sending.

            The service point submit handler. This is called when a request needs
            to be submitted to the network. This routine is asynchronous; the caller
            passes in an HttpSubmitDelegate that is invoked when the caller
            can use the underlying network. The delegate is invoked with the
            stream that it can write to.


            In this version, we use HttpWebRequest. In the future we use IRequest

            Input:
                    Request                 - Request that's being submitted.
                    SubmitDelegate          - Delegate to be invoked.

            Returns:
                    Nothing.

        --*/

        internal virtual void SubmitRequest(HttpWebRequest request) {
            SubmitRequest(request, null);
        }

        internal void SubmitRequest(HttpWebRequest request, string connName) {
            //
            // We attempt to locate a free connection sitting on our list
            //  avoiding multiple loops of the same the list.
            //  We do this, by enumerating the list of the connections,
            //   looking for Free items, and the least busy item
            //

            Connection connToUse;
            ConnectionGroup connGroup;

            lock(this) {

                GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::SubmitRequest() Finding ConnectionGroup:[" + connName + "]");

                connGroup = FindConnectionGroup(connName);

                GlobalLog.Assert(
                    connGroup != null,
                    "ServicePoint::SubmitRequest(): connGroup == null",
                    "");

            }

            // for normal HTTP requests, just give the version from the ServicePoint
            if (request.Address.Scheme == Uri.UriSchemeHttp) {
                request.InternalVersion = ProtocolVersion;
            } else { 
                request.InternalVersion = connGroup.ProtocolVersion; 
            }


            do {

                connToUse = connGroup.FindConnection(request, connName);
            

                GlobalLog.Assert(
                    connToUse != null,
                    "ServicePoint::SubmitRequest(): connToUse == null",
                    "");

                // finally sumbit delegate
                if (connToUse.SubmitRequest(request)) {
                    break;
                }

            } while (true);
        }

        //public int CancelRequest (HttpWebRequest Request)

        // properties

        // Only the scheme and hostport, for example http://www.microsoft.com
        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.Address"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Uniform Resource Identifier of the <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        public Uri Address {
            get {
                return m_Address;
            }
        }

        // Max Idle Time, Default is 12 hours
        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.MaxIdleTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum idle time allowed for this <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        public int MaxIdleTime {
            get {
                return m_MaxIdleTime;
            }
            set {
                if ( !ValidationHelper.ValidateRange(value, Timeout.Infinite, Int32.MaxValue)) {
                    throw new ArgumentOutOfRangeException("MaxIdleTime");
                }
                lock(this) {
                    if ( !ValidationHelper.ValidateRange(value, Timeout.Infinite, Int32.MaxValue)) {
                        throw new ArgumentOutOfRangeException("MaxIdleTime");
                    }
                    // if we went idle, then reupdate our new idle time
                    if ( m_ExpiresAt != DateTime.MinValue ) {
                        // this is the base time, when we went idle
                        DateTime idleSince = this.IdleSince;
                        DateTime oldExpiresAt = this.ExpiresAt;

                        // reset our idle time
                        m_MaxIdleTime = value;

                        // now carefully update expiry Time
                        MarkIdle(idleSince);

                        if ( m_CurrentConnections == 0) {
                            ServicePointManager.UpdateIdleServicePoint(oldExpiresAt, this);
                        }
                    } else {
                        m_MaxIdleTime = value;
                    }
                }
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.UseNagleAlgorithm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the Nagling algorithm on the connections that are created to this <see cref='System.Net.ServicePoint'/>.
        ///       Changing this value does not affect existing connections but only to new ones that are created from that moment on.
        ///    </para>
        /// </devdoc>
        public bool UseNagleAlgorithm {
            get {
                return m_UseNagleAlgorithm;
            }
            set {
                m_UseNagleAlgorithm = value;
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.Expect100Continue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets indication whether 100-continue behaviour is desired when using this <see cref='System.Net.ServicePoint'/>.
        ///       Changing this value does not affect existing connections but only to new ones that are created from that moment on.
        ///    </para>
        /// </devdoc>
        public bool Expect100Continue {
            set {
                m_Expect100Continue = value;
            }
            get {
                return m_Expect100Continue;
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.IdleSince"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the date/time that the <see cref='System.Net.ServicePoint'/> went idle.
        ///    </para>
        /// </devdoc>
        public DateTime IdleSince {
            get {
                return m_ExpiresAt.AddMilliseconds((double) (-1 * m_MaxIdleTime));
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.ExpiresAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the date/time that the <see cref='System.Net.ServicePoint'/> went idle.
        ///    </para>
        /// </devdoc>
        internal DateTime ExpiresAt {
            get {
                return m_ExpiresAt;
            }
        }


        // HTTP Server Version
        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.ProtocolVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The version of the protocol being used on this <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        public virtual Version ProtocolVersion {
            get {
                return m_Version;
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.ConnectionName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the connection name established by the <see cref='System.Net.WebRequest'/> that created the connection.
        ///    </para>
        /// </devdoc>
        public string ConnectionName {
            get {
                return m_ConnectionName;
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.ConnectionMode"]/*' />
        /// <devdoc>
        ///    Gets the connection mode in use by the <see cref='System.Net.ServicePoint'/>. One of the <see cref='System.Net.ConnectionModes'/>
        ///    values.
        /// </devdoc>
        internal ConnectionModes ConnectionMode {
            get {
                return m_ConnectionMode;
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.ConnectionLimit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum number of connections allowed on this <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        public int ConnectionLimit {
            get {
                return m_ConnectionLimit;
            }
            set {
                if (value > 0) {
                    SetConnectionLimit(value, true);

                }
                else {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.net_toosmall));
                }
            }
        }

        private void SetConnectionLimit(int limit, bool fromUser) {
            lock (this) {
                // We'll only update the limit if the user hasn't previously
                // changed it or if this change is coming from the user.

                if (!m_UserChangedLimit || fromUser) {
                    // Save the value, and remember if it was changed by the
                    // user.

                    m_UserChangedLimit = fromUser;
                    m_ConnectionLimit = limit;

                    // Now walk through the connection groups on this service
                    // point, and update all of them with the new value.
                    //

                    IDictionaryEnumerator CGEnumerator;

                    CGEnumerator = m_ConnectionGroupList.GetEnumerator();

                    while (CGEnumerator.MoveNext()) {
                        ConnectionGroup CurrentCG =
                        (ConnectionGroup)CGEnumerator.Value;

                        //
                        // If this change came in from the user, we want to
                        // propagate it down to the underlying connection
                        // groups no matter what. If it's from some internal state
                        // change, we want to propagate it via the internal
                        // mechanism, which only sets it if it hasn't been set by
                        // the user.

                        if (fromUser) {
                            CurrentCG.ConnectionLimit = limit;
                        }
                        else {
                            CurrentCG.InternalConnectionLimit = limit;
                        }
                    }
                }

            }

        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.CurrentConnections"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current number of connections associated with this
        ///    <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        public int CurrentConnections {
            get {
                return m_CurrentConnections;
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.Certificate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the certificate received for this <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        public  X509Certificate Certificate {
            get {
                return m_ServerCertificate;
            }
        }

        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.ClientCertificate"]/*' />
        /// <devdoc>
        /// <para>
        /// Gets the Client Certificate sent by us to the Server.
        /// </para>
        /// </devdoc>
        public  X509Certificate ClientCertificate {
            get {
                return m_ClientCertificate;
            }
        }


        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.SupportsPipelining"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that the <see cref='System.Net.ServicePoint'/> supports pipelined connections.
        ///    </para>
        /// </devdoc>
        public bool SupportsPipelining {
            get {
                return m_SupportsPipelining;
            }
        }


        //
        // Internal Properties
        //

        internal bool Understands100Continue {
            set {
                m_Understands100Continue = value;
            }
            get {
                return m_Understands100Continue;
            }
        }

        //
        // InternalVersion
        //
        // Contains set accessor for Version property. Version is a read-only
        // property at the API
        //
        internal Version InternalVersion {
            set {
                m_Version = value;
                //
                // if version is greater than HTTP/1.1 and server undesrtood
                // 100 Continue so far keep expecting it.
                //
                Understands100Continue = Understands100Continue && m_Version.CompareTo(HttpVersion.Version11)>=0;
            }
        }

        //
        // InternalProxyServicePoint
        //
        // Indicates if we are using this service point to represent
        //  a proxy connection, if so we may have to use special
        //  semantics when creating connections
        //

        internal bool InternalProxyServicePoint {
            set {
                m_ProxyServicePoint = value;
            }
            get {
                return m_ProxyServicePoint;
            }
        }

        //
        // InternalConnectionLimit
        //
        // We can only automatically adjust the connection limit if the application
        // has not already done so
        //

        internal int InternalConnectionLimit {
            set {
                SetConnectionLimit(value, false);
            }
        }

        //
        // InternalClientCertificate
        //
        // Updated by Connection code upon completion of reading server response
        //

        internal X509Certificate InternalClientCertificate {
            set {
                m_ClientCertificate = value;
            }
        }

        //
        // IncrementConnection
        //
        // Call to indicate that we now are starting a new
        //  connection within this service point
        //

        internal void IncrementConnection() {
            GlobalLog.Print("IncrementConnection #" + m_CurrentConnections.ToString() + "  #" + this.GetHashCode().ToString());
            // we need these to be atomic operations
            lock(this) {
                m_CurrentConnections++;
                if (m_CurrentConnections == 1) {
                    ServicePointManager.RemoveIdleServicePoint(this);
                }
            }
        }

        //
        // DecrementConnection
        //
        // Call to indicate that we now are removing
        //  a connection within this connection group
        //

        internal void DecrementConnection() {
            GlobalLog.Print("DecrementConnection #" + m_CurrentConnections.ToString() + "  #" + this.GetHashCode().ToString());
            // we need these to be atomic operations
            lock(this) {
                m_CurrentConnections--;

                if (m_CurrentConnections == 0) {
                    MarkIdle();
                    ServicePointManager.AddIdleServicePoint(this);
                } else if ( m_CurrentConnections < 0 ) {
                    m_CurrentConnections = 0;
                }
            }
        }


        internal bool UserDefinedLimit {
            get {
                return m_UserChangedLimit;
            }
        }

        internal bool InternalSupportsPipelining {
            get {
                return m_SupportsPipelining;
            }
            set {
                m_SupportsPipelining = value;

                if (value) {
                    m_ConnectionMode = ConnectionModes.Pipeline;
                }
                else {
                    m_ConnectionMode = ConnectionModes.Persistent;
                }
            }
        }

        internal bool AcceptCertificate(TlsStream secureStream, WebRequest request) {
            X509Certificate newCertificate = secureStream.Certificate;

            if (ServicePointManager.CertificatePolicy!=null) {
                PolicyWrapper cpw = new PolicyWrapper(ServicePointManager.CertificatePolicy, this, request);

                bool acceptable = secureStream.VerifyServerCertificate(cpw);
                if (!acceptable) {
                    return false;
                }
            }

            m_ServerCertificate = newCertificate;
            m_ClientCertificate = secureStream.ClientCertificate;
            return true;
        }

        //
        // InternalTimedOut
        //
        // Indicates if the service point has timed out
        //

        internal bool InternalTimedOut() {
            return InternalTimedOut( DateTime.Now );
        }

        internal bool InternalTimedOut( DateTime now ) {
            return now >= m_ExpiresAt;
        }

        static internal bool InternalTimedOut( DateTime now, DateTime expiresAt ) {
            return now >= expiresAt;
        }

        //
        // MarkIdle
        //
        // Called when the ServicePoint goes idle,
        // in order to keep track of it's.
        //

        internal void MarkIdle() {
            MarkIdle(DateTime.Now);
        }

        internal void MarkIdle(DateTime idleSince) {
            m_ExpiresAt = idleSince.AddMilliseconds(m_MaxIdleTime);
        }

        internal void IncrementExpiresAt() {
            m_ExpiresAt = m_ExpiresAt.AddMilliseconds(1);
        }

        /*++

            SetAddressList - Set the list of IP addresses for this service point.

            This is a method called when the underlying code has resolved the
            destination to a list of IP addressess. We actually maintain some
            information about the viable IP addresses for this service point,
            like whether or not they're loopback, etc. So we walk through the
            list and set up an array of structures corresponding to the IP
            addresses.

            Note that it's possible to have some IP addresses be loopbacked
            and some not. This can happen if a server name maps to multiple
            physical servers and we're one of those servers.

            Input:
                    addressList     - Array of resolved IP addresses.

            Returns: Nothing.

        --*/
        private IPHostEntryInfo SetAddressList(IPHostEntry ipHostEntry) {
            GlobalLog.Print("SetAddressList("+ipHostEntry.HostName+")");
            //
            // Create an array of IPAddressInfo of the appropriate size, then
            // get a list of our local addresses. Walk through the input
            // address list. Copy each address in the address list into
            // our array, and if the address is a loopback address, mark it as
            // such.
            //
            IPAddress[] addressList = ipHostEntry.AddressList;
            IPAddressInfo[] TempInfo = new IPAddressInfo[addressList.Length];

            //
            // Walk through each member of the input list, copying it into our temp array.
            //
            int i, k;
            IPHostEntry ipLocalHostEntry = null;
            try {
                ipLocalHostEntry = Dns.LocalHost;
            }
            catch (Exception exception) {
                GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::SetAddressList() Dns.LocalHost threw exception:[" + ValidationHelper.ToString(exception) + "]");
            }
            for (i = 0; i < addressList.Length; i++) {
                TempInfo[i] = new IPAddressInfo(addressList[i]);

                // First, check to see if the current address is a  loopback
                // address.

                if (IPAddress.IsLoopback(TempInfo[i].Address)) {
                    TempInfo[i].IsLoopback = true;
                    continue;
                }

                // See if the current IP address is a local address, and if
                // so mark it as such.
                if (ipLocalHostEntry!=null) {
                    for (k = 0; k < ipLocalHostEntry.AddressList.Length; k++) {
                        //
                        // IPv6 Changes: Use .Equals for this check !
                        //
                        if ( TempInfo[i].Address.Equals(ipLocalHostEntry.AddressList[k]) ) {
                            TempInfo[i].IsLoopback = true;
                            break;
                        }
                    }
                }
            }

            //
            // now look for connection group objects that don't have
            // an IP address associated with them. When it finds one, it updates
            // the IP address and tries to update the connection limit.
            //
            lock (this) {
                // Walk through the connection groups on this service
                // point, and update the ones we need to with an IP
                // address.
                //

                IDictionaryEnumerator CGEnumerator;

                CGEnumerator = m_ConnectionGroupList.GetEnumerator();

                while (CGEnumerator.MoveNext()) {
                    ConnectionGroup CurrentCG = (ConnectionGroup)CGEnumerator.Value;

                    // If this connection group doesn't have an IP address
                    // assigned to it, give it one.

                    if (CurrentCG.RemoteIPAddress == null) {
                        GlobalLog.Print("ServicePoint::UpdateConnectionGroupAddresses null CurrentCG.RemoteIPAddress");

                        // Update the address.

                        CurrentCG.RemoteIPAddress = TempInfo[0].Address;

                        // Now update the connection limit based on what we know.

                        CurrentCG.InternalConnectionLimit = TempInfo[0].IsLoopback ? LoopbackConnectionLimit : m_ConnectionLimit;

                        GlobalLog.Print("ServicePoint::UpdateConnectionGroupAddresses CurrentCG.InternalConnectionLimit:" + CurrentCG.InternalConnectionLimit.ToString());
                    }

                    GlobalLog.Print("ServicePoint::UpdateConnectionGroupAddresses CurrentCG.RemoteIPAddress:" + CurrentCG.RemoteIPAddress.ToString());
                }
            }

            IPHostEntryInfo ipAddressInfoList = new IPHostEntryInfo(TempInfo, ipHostEntry.HostName);
            return ipAddressInfoList ;
        }

        /// <devdoc>
        ///    <para>
        ///       Sets connections in this group to not be KeepAlive.
        ///       This is called to force cleanup of the ConnectionGroup by the
        ///       NTLM and Negotiate authentication modules.
        ///    </para>
        /// </devdoc>
        internal void ReleaseConnectionGroup(string connName) {
            //
            // look up the ConnectionGroup based on the name
            //
            ConnectionGroup connectionGroup = FindConnectionGroup(connName);
            //
            // force all connections on the ConnectionGroup to not be KeepAlive
            //
            connectionGroup.DisableKeepAliveOnConnections();
            //
            // remove ConnectionGroup from our Hashtable
            //
            lock(this) {
                m_ConnectionGroupList.Remove(connName);
            }
        }

        /*++

            GetCurrentIPAddressInfo - Find an IP address to connect to.

            Called when we're creating a new connection group and need to find an
            IP address for that group. If we have an address info list, we'll
            select an address from that. Otherwise we'll return null.

            Input:
                    Nothing

            Returns: IPAddressInfo structure for address.

        --*/
        private IPAddressInfo GetCurrentIPAddressInfo() {
            IPAddressInfo ipAddressInfo = null;
            lock (this) {
                GlobalLog.Enter("ServicePoint#" + ValidationHelper.HashString(this) + "::GetCurrentIPAddressInfo() m_ConnectionsSinceDns:" + m_ConnectionsSinceDns.ToString());
                if (m_ConnectionsSinceDns<0) {
                    //
                    // never called DNS to initialize m_IPHostEntryInfos.
                    // call it now for the first time.
                    //
                    GlobalLog.Print("ServicePoint#" + ValidationHelper.HashString(this) + "::GetCurrentIPAddressInfo() calling GetNextIPAddressInfo()");
                    ipAddressInfo = GetNextIPAddressInfo();
                }
                else if (m_IPHostEntryInfos!=null && m_IPHostEntryInfos.IPAddressInfoList!=null && m_CurrentAddressInfoIndex<m_IPHostEntryInfos.IPAddressInfoList.Length) {
                    ipAddressInfo = m_IPHostEntryInfos.IPAddressInfoList[m_CurrentAddressInfoIndex];
                }
            }
            GlobalLog.Leave("ServicePoint#" + ValidationHelper.HashString(this) + "::GetCurrentIPAddressInfo", ValidationHelper.ToString(ipAddressInfo));
            return ipAddressInfo;
        }
        private IPAddressInfo GetNextIPAddressInfo() {
            IPHostEntry ipHostEntry;
            lock (this) {
                GlobalLog.Print("m_CurrentAddressInfoIndex = "+m_CurrentAddressInfoIndex);
                GlobalLog.Print("m_ConnectionsSinceDns = "+m_ConnectionsSinceDns);
                GlobalLog.Print("m_IPHostEntryInfos = "+m_IPHostEntryInfos);
                m_CurrentAddressInfoIndex++;
                if (m_ConnectionsSinceDns<0 || (m_ConnectionsSinceDns>0 && m_IPHostEntryInfos!=null && m_IPHostEntryInfos.IPAddressInfoList!=null && m_CurrentAddressInfoIndex==m_IPHostEntryInfos.IPAddressInfoList.Length)) {
                    //
                    // it's either the first time we get here or we reached the end
                    // of the list of valid IPAddressInfo that we can connect to.
                    // in this second case, since at least one of the IPAddressInfo we got
                    // from DNS was valid, we'll query DNS again in case we just need to
                    // refresh our internal list. note that we don't need to assert DnsPermission
                    // since the internal method we're calling (Dns.InternalResolve()) doesn't Demand() any
                    //
                    m_ConnectionsSinceDns = 0;
                    try {
                        GlobalLog.Print("ServicePoint::GetNextIPAddressInfo() calling Dns.InternalResolve() for:" + m_Address.Host);
                        ipHostEntry = Dns.InternalResolve(m_Address.Host);
                        GlobalLog.Print("ServicePoint::GetNextIPAddressInfo() Dns.InternalResolve() returns:" + ValidationHelper.ToString(ipHostEntry));
                        if (ipHostEntry!=null && ipHostEntry.AddressList!=null && ipHostEntry.AddressList.Length>0) {
                            //
                            // this call will reset m_IPHostEntryInfos
                            //
                            m_CurrentAddressInfoIndex = 0;
                            m_IPHostEntryInfos = SetAddressList(ipHostEntry);
                        }
                        else {
                            GlobalLog.Print("Dns.InternalResolve() failed with null");
                            m_IPHostEntryInfos = null;
                        }
                    }
                    catch ( Exception e ) {
                        GlobalLog.Print("Dns.InternalResolve() failed with exception: " + e.Message + " " + e.StackTrace);
                        m_IPHostEntryInfos = null;
                    }
                }
                if (m_IPHostEntryInfos!=null && m_IPHostEntryInfos.IPAddressInfoList!=null && m_CurrentAddressInfoIndex<m_IPHostEntryInfos.IPAddressInfoList.Length) {
                    GlobalLog.Print("GetNextIPAddressInfo() returning "+m_IPHostEntryInfos.IPAddressInfoList[m_CurrentAddressInfoIndex]);
                    return m_IPHostEntryInfos.IPAddressInfoList[m_CurrentAddressInfoIndex];
                }
                // If we walked the whole list in failure, than reset and retry DNS
                if (m_IPHostEntryInfos==null || m_IPHostEntryInfos.IPAddressInfoList==null || m_CurrentAddressInfoIndex>=m_IPHostEntryInfos.IPAddressInfoList.Length) {
                    GlobalLog.Print("setting m_ConnectionsSinceDns to -1");
                    m_ConnectionsSinceDns = -1;
                }
            }
            GlobalLog.Print("GetNextIPAddressInfo() returning null");
            return null;
        }

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        /// <include file='doc\ServicePoint.uex' path='docs/doc[@for="ServicePoint.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

        //
        // IPv6 support: this method actually returns the socket that was
        //               used to connect to the remote host. This is because the host may
        //               have multiple addresses, and on here do we actually know which
        //               one we used !
        //
        internal WebExceptionStatus ConnectSocket(Socket s4,Socket s6,ref Socket socket) {
            //
            // so, here we are: we have the EndPoint we need to connect to, all we
            // need to do is call into winsock and try to connect to this HTTP server.
            //
            // RAID#27438
            // this is how we do it:
            // we'll keep trying to Connect() until either:
            // (1) Connect() succeeds (on which we increment the number of connections opened) or
            // (2) we can't get any new address for this host.
            //
            // (1) is pretty easy, here's how we do (2):
            // we decide that (2) is happening when, after a brand new DNS query,
            // all IPAddress fail to connect. to do so we keep count of how many
            // connections have been successfull to any of the addresses in the list
            // returned by DNS (if the host is an IPAddress we'll have a single address
            // in the list so if that fails the algorithm will still work).
            //
            // when we're out of addresses we call again (or for the first time) into DNS.
            // on DNS failure, of course, we will error out.
            // otherwise, after getting the list of addresses, as a result of our DNS query,
            // we reset the number of connections opened
            // using the last DNS query to 0. after that we start using all addresses
            //

            //
            // we need this for the call to connect()
            //
            // SECURITY:
            // Since we are doing WebRequest, we don't require SocketPermissions
            // (asserting them)
            //
            // Consider V.Next: Change to declarative form (10x faster) but 
            // SocketPermission must be moved out of System.dll
            new SocketPermission(PermissionState.Unrestricted).Assert();

            IPEndPoint ipEndPoint;
            IPAddressInfo ipAddressInfo = GetCurrentIPAddressInfo();
            bool connectFailure = false;

            for (;;) {
                if (ipAddressInfo!=null) {
                    try {
                        ipEndPoint = new IPEndPoint(ipAddressInfo.Address, m_Address.Port);
                        GlobalLog.Print("ServicePoint::ConnectSocket() calling Connect() to:" + ipEndPoint.ToString());
                        //
                        // IPv6 Changes: Create the socket based on the AddressFamily of the endpoint. Take
                        //               a short lock to check whether the connect attempt is to be aborted
                        //               and update the socket to be aborted.
                        //
                        if ( ipEndPoint.Address.AddressFamily == AddressFamily.InterNetwork ) {
                            s4.Connect(ipEndPoint);
                            socket = s4;
                        }
                        else {
                            s6.Connect(ipEndPoint);
                            socket = s6;
                        }
                        Interlocked.Increment(ref m_ConnectionsSinceDns);
                        return WebExceptionStatus.Success;
                    }
                    catch {
                        connectFailure = true;
                    }
                }
                //
                // on failure jump to the next available IPAddressInfo. if it's null
                // there has been a DNS failure or all connections failed.
                //
                ipAddressInfo = GetNextIPAddressInfo();
                if (ipAddressInfo==null) {
                    if (!connectFailure) {

                        GlobalLog.Assert(
                            !connectFailure,
                            "connectFailure",
                            "");

                        return InternalProxyServicePoint ? WebExceptionStatus.ProxyNameResolutionFailure : WebExceptionStatus.NameResolutionFailure;
                    }

                    return WebExceptionStatus.ConnectFailure;
                }
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void Debug(int requestHash) {
            foreach(ConnectionGroup connectGroup in  m_ConnectionGroupList) {
                if (connectGroup!=null) {
                    try {
                        connectGroup.Debug(requestHash);
                    } catch {
                    }
                }
            }
        }

    }; // class ServicePoint

    internal class IPHostEntryInfo {
        public string HostName;
        public IPAddressInfo[] IPAddressInfoList;
        public IPHostEntryInfo(IPAddressInfo[] ipAddressInfoList, string hostName) {
            HostName = (((object)hostName) == null ? string.Empty : hostName);
            IPAddressInfoList = ipAddressInfoList;
        }
    }

    internal class IPAddressInfo {
        public  IPAddress       Address;
        public  bool            IsLoopback;
        public IPAddressInfo(IPAddress address) {
            Address = address;
        }
    }


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\networkcredential.cs ===
//------------------------------------------------------------------------------
// <copyright file="NetworkCredential.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security.Cryptography;
    using System.Security.Permissions;
    using System.Text;

    /// <include file='doc\NetworkCredential.uex' path='docs/doc[@for="NetworkCredential"]/*' />
    /// <devdoc>
    ///    <para>Provides credentials for password-based
    ///       authentication schemes such as basic, digest, NTLM and Kerberos.</para>
    /// </devdoc>
    public class NetworkCredential : ICredentials {

        private static SecurityPermission m_unmanagedPermission;
        private static EnvironmentPermission m_environmentUserNamePermission;
        private static EnvironmentPermission m_environmentDomainNamePermission;
        private static RNGCryptoServiceProvider m_random;
        private static SymmetricAlgorithm m_symmetricAlgorithm;

        private byte[] m_userName;
        private byte[] m_password;
        private byte[] m_domain;
        private byte[] m_encryptionIV;

        static NetworkCredential() {
            m_unmanagedPermission = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
            m_environmentUserNamePermission = new EnvironmentPermission(EnvironmentPermissionAccess.Read, "USERNAME");
            m_environmentDomainNamePermission = new EnvironmentPermission(EnvironmentPermissionAccess.Read, "USERDOMAIN");
            m_random = new RNGCryptoServiceProvider();
            m_symmetricAlgorithm = Rijndael.Create();

            byte[] encryptionKey = new byte[16];

            m_random.GetBytes(encryptionKey);
            m_symmetricAlgorithm.Key = encryptionKey;
        }

        /// <include file='doc\NetworkCredential.uex' path='docs/doc[@for="NetworkCredential.NetworkCredential2"]/*' />
        public NetworkCredential() {
            m_encryptionIV = new byte[16];
            m_random.GetBytes(m_encryptionIV);
            m_symmetricAlgorithm.IV = m_encryptionIV;
        }

        /// <include file='doc\NetworkCredential.uex' path='docs/doc[@for="NetworkCredential.NetworkCredential"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.NetworkCredential'/>
        ///       class with name and password set as specified.
        ///    </para>
        /// </devdoc>
        public NetworkCredential(string userName, string password)
        : this(userName, password, string.Empty) {
        }

        /// <include file='doc\NetworkCredential.uex' path='docs/doc[@for="NetworkCredential.NetworkCredential1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.NetworkCredential'/>
        ///       class with name and password set as specified.
        ///    </para>
        /// </devdoc>
        public NetworkCredential(string userName, string password, string domain) : this() {
            UserName = userName;
            Password = password;
            Domain = domain;
        }

        /// <include file='doc\NetworkCredential.uex' path='docs/doc[@for="NetworkCredential.UserName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The user name associated with this credential.
        ///    </para>
        /// </devdoc>
        public string UserName {
            get {
                m_environmentUserNamePermission.Demand();

                string decryptedString = Decrypt(m_userName);

                GlobalLog.Print("NetworkCredential::get_UserName: returning \"" + decryptedString + "\"");
                return decryptedString;
            }
            set {
                m_userName = Encrypt(value);
                GlobalLog.Print("NetworkCredential::set_UserName: value = " + value);
                GlobalLog.Print("NetworkCredential::set_UserName: m_userName:");
                GlobalLog.Dump(m_userName);
            }
        }

        /// <include file='doc\NetworkCredential.uex' path='docs/doc[@for="NetworkCredential.Password"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The password for the user name.
        ///    </para>
        /// </devdoc>
        public string Password {
            get {
                m_unmanagedPermission.Demand();

                string decryptedString = Decrypt(m_password);

                GlobalLog.Print("NetworkCredential::get_Password: returning \"" + decryptedString + "\"");
                return decryptedString;
            }
            set {
                m_password = Encrypt(value);
                GlobalLog.Print("NetworkCredential::set_Password: value = " + value);
                GlobalLog.Print("NetworkCredential::set_Password: m_password:");
                GlobalLog.Dump(m_password);
            }
        }

        /// <include file='doc\NetworkCredential.uex' path='docs/doc[@for="NetworkCredential.Domain"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The machine name that verifies
        ///       the credentials. Usually this is the host machine.
        ///    </para>
        /// </devdoc>
        public string Domain {
            get {
                m_environmentDomainNamePermission.Demand();

                string decryptedString = Decrypt(m_domain);

                GlobalLog.Print("NetworkCredential::get_Domain: returning \"" + decryptedString + "\"");
                return decryptedString;
            }
            set {
                m_domain = Encrypt(value);
                GlobalLog.Print("NetworkCredential::set_Domain: value = " + value);
                GlobalLog.Print("NetworkCredential::set_Domain: m_domain:");
                GlobalLog.Dump(m_domain);
            }
        }

        /// <include file='doc\NetworkCredential.uex' path='docs/doc[@for="NetworkCredential.GetCredential"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an instance of the NetworkCredential class for a Uri and
        ///       authentication type.
        ///    </para>
        /// </devdoc>
        public NetworkCredential GetCredential(Uri uri, String authType) {
            return this;
        }

        internal string Decrypt(byte[] ciphertext) {
            if (ciphertext == null) {
                return String.Empty;
            }

            MemoryStream ms = new MemoryStream();
            CryptoStream cs = new CryptoStream(ms, m_symmetricAlgorithm.CreateDecryptor(m_symmetricAlgorithm.Key, m_encryptionIV), CryptoStreamMode.Write);

            cs.Write(ciphertext, 0, ciphertext.Length);
            cs.FlushFinalBlock();

            byte[] decryptedBytes = ms.ToArray();

            cs.Close();
            return Encoding.UTF8.GetString(decryptedBytes);
        }

        internal byte[] Encrypt(string text) {
            if ((text == null) || (text.Length == 0)) {
                return null;
            }

            MemoryStream ms = new MemoryStream();
            CryptoStream cs = new CryptoStream(ms, m_symmetricAlgorithm.CreateEncryptor(m_symmetricAlgorithm.Key, m_encryptionIV), CryptoStreamMode.Write);

            byte[] stringBytes = Encoding.UTF8.GetBytes(text);

            cs.Write(stringBytes, 0, stringBytes.Length);
            cs.FlushFinalBlock();
            stringBytes = ms.ToArray();
            cs.Close();
            return stringBytes;
        }
    } // class NetworkCredential
} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\socketexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;
    using System.ComponentModel;
    using System.Runtime.Serialization;
    using System.Runtime.InteropServices;

    /// <include file='doc\SocketException.uex' path='docs/doc[@for="SocketException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides socket exceptions to the application.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public class SocketException : Win32Exception {
        /// <include file='doc\SocketException.uex' path='docs/doc[@for="SocketException.SocketException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.Sockets.SocketException'/> class with the default error code.
        ///    </para>
        /// </devdoc>
        public SocketException() : base(Marshal.GetLastWin32Error()) {
            GlobalLog.Print("SocketException::.ctor() " + NativeErrorCode.ToString() + ":" + Message);
        }

        /// <include file='doc\SocketException.uex' path='docs/doc[@for="SocketException.SocketException1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.Sockets.SocketException'/> class with the specified error code.
        ///    </para>
        /// </devdoc>
        public SocketException(int errorCode) : base(errorCode) {
            GlobalLog.Print("SocketException::.ctor(int) " + NativeErrorCode.ToString() + ":" + Message);
        }

        /// <include file='doc\SocketException.uex' path='docs/doc[@for="SocketException.SocketException2"]/*' />
        protected SocketException(SerializationInfo serializationInfo, StreamingContext streamingContext)
            : base(serializationInfo, streamingContext) {
            GlobalLog.Print("SocketException::.ctor(serialized) " + NativeErrorCode.ToString() + ":" + Message);
        }

        /// <include file='doc\SocketException.uex' path='docs/doc[@for="SocketException.ErrorCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int ErrorCode {
            //
            // the base class returns the HResult with this property
            // we need the Win32 Error Code, hence the override.
            //
            get {
                return NativeErrorCode;
            }
        }

    }; // class SocketException
    

} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\socketaddress.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketAddress.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System;
    using System.Runtime.InteropServices;
    using System.Net.Sockets;
    using System.Text;

    // a little perf app measured these times when comparing the internal
    // buffer implemented as a managed byte[] or unmanaged memory IntPtr
    // that's why we use byte[]
    // byte[] total ms:19656
    // IntPtr total ms:25671

    /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress"]/*' />
    /// <devdoc>
    ///    <para>
    ///       This class is used when subclassing EndPoint, and provides indication
    ///       on how to format the memeory buffers that winsock uses for network addresses.
    ///    </para>
    /// </devdoc>
    public class SocketAddress {

        internal int m_Size;
        internal byte[] m_Buffer;

        private const int WriteableOffset = 2;
        private const int MaxSize = 32; // IrDA requires 32 bytes
        private bool m_changed = true;
        private int m_hash;

        //
        // Address Family
        //
        /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress.Family"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AddressFamily Family {
            get {
                return
                    (AddressFamily)((int)(
                    (m_Buffer[1]<<8 & 0xFF00) |
                    (m_Buffer[0])
                    ));
            }
        }
        //
        // Size of this SocketAddress
        //
        /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress.Size"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Size {
            get {
                return m_Size;
            }
        }

        //
        // access to unmanaged serialized data. this doesn't
        // allow access to the first 2 bytes of unmanaged memory
        // that are supposed to contain the address family which
        // is readonly.
        //
        // SECREVIEW: you can still use negative offsets as a back door in case
        // winsock changes the way it uses SOCKADDR. maybe we want to prohibit it?
        // maybe we should make the class sealed to avoid potentially dangerous calls
        // into winsock with unproperly formatted data?
        //
        /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte this[int offset] {
            get {
                //
                // access
                //
                if (offset<0 || offset>=Size) {
                    throw new IndexOutOfRangeException();
                }
                return m_Buffer[offset];
            }
            set {
                if (offset<0 || offset>=Size) {
                    throw new IndexOutOfRangeException();
                }
                if (m_Buffer[offset] != value) {
                    m_changed = true;
                }
                m_Buffer[offset] = value;
            }
        }

        /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress.SocketAddress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SocketAddress(AddressFamily family) : this(family, MaxSize) {
        }

        /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress.SocketAddress1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SocketAddress(AddressFamily family, int size) {
            if (size<WriteableOffset) {
                //
                // it doesn't make sense to create a socket address with less tha
                // 2 bytes, that's where we store the address family.
                //
                throw new ArgumentOutOfRangeException("size");
            }
            m_Size = size;
            m_Buffer = new byte[size];
            m_Buffer[0] = (byte)(((short)family) & 0xFF);
            m_Buffer[1] = (byte)(((short)family>>8) & 0xFF);
        }

        /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress.Equals"]/*' />
        public override bool Equals(object comparand) {
            SocketAddress castedComparand = comparand as SocketAddress;
            if (castedComparand == null || this.Size != castedComparand.Size) {
                return false;
            }
            for(int i=0; i<this.Size; i++) {
                if(this[i]!=castedComparand[i]) {
                    return false;
                }
            }
            return true;
        }

        /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress.GetHashCode"]/*' />
        public override int GetHashCode() {
            if (m_changed) {
                m_changed = false;
                m_hash = 0;

                int i;
                int size = Size & ~3;

                for (i = 0; i < size; i += 4) {
                    m_hash ^= (int)m_Buffer[i]
                            | ((int)m_Buffer[i+1] << 8)
                            | ((int)m_Buffer[i+2] << 16)
                            | ((int)m_Buffer[i+3] << 24);
                }
                if ((Size & 3) != 0) {

                    int remnant = 0;
                    int shift = 0;

                    for (; i < Size; ++i) {
                        remnant |= ((int)m_Buffer[i]) << shift;
                        shift += 8;
                    }
                    m_hash ^= remnant;
                }
            }
            return m_hash;
        }

        /// <include file='doc\SocketAddress.uex' path='docs/doc[@for="SocketAddress.ToString"]/*' />
        public override string ToString() {
            StringBuilder bytes = new StringBuilder();
            for(int i=WriteableOffset; i<this.Size; i++) {
                if (i>WriteableOffset) {
                    bytes.Append(",");
                }
                bytes.Append(this[i].ToString());
            }
            return Family.ToString() + ":" + Size.ToString() + ":{" + bytes.ToString() + "}";
        }

    } // class SocketAddress


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\servicepointmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServicePointManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Security.Permissions;
    using System.Threading;
    using System.Configuration;

    // In whidbey this may get more valid values.
    /// <include file='doc\SecurityProtocolType.uex' path='docs/doc[@for="SecurityProtocolType"]/*' />
    [Flags]
    public enum SecurityProtocolType {

    /// <include file='doc\SecurityProtocolType.uex' path='docs/doc[@for="SecurityProtocolType.Ssl3"]/*' />
        Ssl3          = 0x00000020|0x00000010,      //SchProtocols.Ssl3Client|SchProtocols.Ssl3Server,

    /// <include file='doc\SecurityProtocolType.uex' path='docs/doc[@for="SecurityProtocolType.Tls"]/*' />
        Tls           = 0x00000080|0x00000040       //TlsClient|SchProtocols.TlsServer,
    }

    //
    // The ServicePointManager class hands out ServicePoints (may exist or be created
    // as needed) and makes sure they are garbage collected when they expire.
    // The ServicePointManager runs in its own thread so that it never
    //

    /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager"]/*' />
    /// <devdoc>
    /// <para>Manages the collection of <see cref='System.Net.ServicePoint'/> instances.</para>
    /// </devdoc>
    ///
    public class ServicePointManager {

        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.DefaultNonPersistentConnectionLimit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The number of non-persistant connections allowed on a <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        public const int DefaultNonPersistentConnectionLimit = 4;
        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.DefaultPersistentConnectionLimit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The default number of persistent connections allowed on a <see cref='System.Net.ServicePoint'/>.
        ///    </para>
        /// </devdoc>
        public const int DefaultPersistentConnectionLimit = 2;

        internal static readonly string SpecialConnectGroupName = "/.NET/NetClasses/HttpWebRequest/CONNECT__Group$$/";

        //
        // data  - only statics used
        //

        //
        // s_ServicePointTable - Uri of ServicePoint is the hash key
        // We provide our own comparer function that knows about Uris
        //
        private static Hashtable s_ServicePointTable = new Hashtable(10);
        private static int s_MaxServicePoints = 0;
        private static int s_MaxServicePointIdleTime = 15*60*1000; // TTL: Default value is 15 minutes
        private static ICertificatePolicy s_Policy = new DefaultCertPolicy();
        private static Hashtable s_ConfigTable = null;
        private static int s_ConnectionLimit = DefaultPersistentConnectionLimit;
        private static NetConfiguration s_NetConfig = null;
        private static SecurityProtocolType s_SecurityProtocolType = SecurityProtocolType.Ssl3;

        //
        // s_StrongReferenceServicePointList - holds a cache of links
        //  to service points that are idle, but not expired.  On each
        //  Find through the ServicePoint list, we peak in this list
        //  to see if any are expired.
        //

        private static SortedList s_StrongReferenceServicePointList = new SortedList(10);

        //
        // InternalConnectionLimit -
        //  set/get Connection Limit on demand, checking config beforehand
        //

        private static int InternalConnectionLimit {
            get {
                if (s_ConfigTable == null) {
                    // init config
                    s_ConfigTable = ConfigTable;
                }
                return s_ConnectionLimit;
            }
            set {
                if (s_ConfigTable == null) {
                    // init config
                    s_ConfigTable = ConfigTable;
                }
                s_ConnectionLimit = value;
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void Debug(int requestHash) {
            try {
                foreach(WeakReference servicePointReference in  s_ServicePointTable) {

                    ServicePoint servicePoint;

                    if ( servicePointReference != null && servicePointReference.IsAlive) {
                        servicePoint = (ServicePoint)servicePointReference.Target;
                    }
                    else {
                        servicePoint = null;
                    }

                    if (servicePoint!=null) {
                        servicePoint.Debug(requestHash);
                    }
                }
            }
            catch {
                Console.WriteLine("something threw");
            }
        }

        //
        // ConfigTable -
        // read ConfigTable from Config, or create
        //  a default on failure
        //

        private static Hashtable ConfigTable {
            get {
                if (s_ConfigTable == null) {
                    lock(typeof(ServicePointManager)) {
                        if (s_ConfigTable == null) {
                            Hashtable configTable;
                            configTable = (Hashtable)
                                ConfigurationSettings.GetConfig("system.net/connectionManagement");

                            if (configTable == null) {
                                configTable = new Hashtable();
                            }

                            // we piggy back loading the ConnectionLimit here
                            if (configTable.ContainsKey("*") ) {
                                int connectionLimit  = (int) configTable["*"];
                                if ( connectionLimit < 1 ) {
                                    connectionLimit = DefaultPersistentConnectionLimit;
                                }
                                s_ConnectionLimit = connectionLimit;
                            }
                            s_ConfigTable = configTable;
                        }
                    }
                }
                return s_ConfigTable;
            }
        }

        //
        // AddIdleServicePoint -
        //
        //  Adds a ServicePoint to our idle list, done, when a servicePoint
        //    detects that its connection count goes to 0.  And its ready to idle.
        //
        internal static void AddIdleServicePoint(ServicePoint servicePoint) {
            GlobalLog.Enter("ServicePointManager::AddIdleServicePoint() servicePoint#" + ValidationHelper.HashString(servicePoint) + " ExpiresAt:" + (servicePoint.ExpiresAt.ToFileTime()).ToString());
            lock (s_StrongReferenceServicePointList) {

                // DateTime.Now wasn't accurate enough to guarantee uniqueness
                while (s_StrongReferenceServicePointList.IndexOfKey(servicePoint.ExpiresAt) != -1) {
                    servicePoint.IncrementExpiresAt();
                }

                GlobalLog.Assert(
                    ! s_StrongReferenceServicePointList.ContainsValue(servicePoint),
                    "s_StrongReferenceServicePointList.ContainsValue(servicePoint)",
                    "s_StrongReferenceServicePointList should not have a value added twice" );

                s_StrongReferenceServicePointList.Add(servicePoint.ExpiresAt, servicePoint);
            }
            GlobalLog.Leave("ServicePointManager::AddIdleServicePoint");
        }

        //
        // RemoveIdleServicePoint -
        //
        //  Removes an Idled ServicePoint when it is resurected to
        //  begin doing connections again, assumes, the service point
        //  has not changed its idle time, since it went idle
        //

        internal static void RemoveIdleServicePoint(ServicePoint servicePoint) {
            GlobalLog.Enter("ServicePointManager::RemoveIdleServicePoint() servicePoint#" + ValidationHelper.HashString(servicePoint) + " ExpiresAt:" + (servicePoint.ExpiresAt.ToFileTime()).ToString());
            try {
                lock (s_StrongReferenceServicePointList) {
                    s_StrongReferenceServicePointList.Remove(servicePoint.ExpiresAt);
                }
            }
            catch (Exception exception) {
                GlobalLog.Print("ServicePointManager::RemoveIdleServicePoint() caught exception accessing s_StrongReferenceServicePointList:" + exception.ToString());
                GlobalLog.Assert(
                    false,
                    "Exception thrown in ServicePointManager::RemoveIdleServicePoint",
                    exception.Message );
            }
            GlobalLog.Leave("ServicePointManager::RemoveIdleServicePoint");
        }

        //
        // UpdateIdleServicePoint -
        //
        // Perform an update if the servicePoint changed its timeout
        //  value, most likly by an external call.  But we need to
        //  do this, otherwise the servicePoint may sit a while,
        //  before we recognize the change
        //

        internal static void UpdateIdleServicePoint(DateTime oldExpiresAt, ServicePoint servicePoint) {
            GlobalLog.Enter("ServicePointManager::UpdateIdleServicePoint() servicePoint#" + ValidationHelper.HashString(servicePoint) + " ExpiresAt:" + (servicePoint.ExpiresAt.ToFileTime()).ToString() + " oldExpiresAt:" + (oldExpiresAt.ToFileTime()).ToString());
            lock (s_StrongReferenceServicePointList) {

                try {
                    // may have already been deleted by scavenge

                    // if we for some reason changed ourselves,
                    // so that we don't expire early as planed,
                    // readd ourselves, so that we expire later
                    //

                    s_StrongReferenceServicePointList.Remove(oldExpiresAt);
                    s_StrongReferenceServicePointList.Add(servicePoint.ExpiresAt, servicePoint);
                }
                catch (Exception exception) {
                    GlobalLog.Print("ServicePointManager::UpdateIdleServicePoint() caught exception accessing s_StrongReferenceServicePointList:" + exception.ToString());
                }
            }
            GlobalLog.Leave("ServicePointManager::UpdateIdleServicePoint");
        }

        //
        // ScavengeIdleServicePoints -
        //
        //  Removes an Idled ServicePoint as it is detected to be
        //  expired and ready to be removed.  This is called fairly
        //  often, so we should be O(1) in the case when no service points
        //  have idled.
        //

        private static void ScavengeIdleServicePoints() {
            DateTime now = DateTime.Now;
            GlobalLog.Enter("ServicePointManager::ScavengeIdleServicePoints() now:" + (now.ToFileTime()).ToString());
            lock (s_StrongReferenceServicePointList) {
                while (s_StrongReferenceServicePointList.Count != 0 )  {
                    DateTime expiresAt = (DateTime) s_StrongReferenceServicePointList.GetKey(0);
                    if ( ServicePoint.InternalTimedOut(now, expiresAt) )  {
                        ServicePoint servicePoint = (ServicePoint)
                            s_StrongReferenceServicePointList.GetByIndex(0);
                        GlobalLog.Print("ServicePointManager::ScavengeIdleServicePoints() servicePoint#" + ValidationHelper.HashString(servicePoint) + " ExpiresAt:" + (servicePoint.ExpiresAt.ToFileTime()).ToString() + " is being removed");
                        s_StrongReferenceServicePointList.RemoveAt(0);
                    }
                    else {
                        // if the first in the list isn't expired, than no one later is either
                        break;
                    }
                }
            }
            GlobalLog.Leave("ServicePointManager::ScavengeIdleServicePoints");
        }


        //
        // constructors
        //

        private ServicePointManager() {
        }


        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.SecurityProtocol"]/*' />
        public static SecurityProtocolType SecurityProtocol {
            get {
                return s_SecurityProtocolType;
            }
            set {
                // current implementaion supports only ssl3 and Tls protocols.
                // preventing arbitrary user int values to go in.
                if ( value != SecurityProtocolType.Ssl3 &&
                     value != SecurityProtocolType.Tls  &&
                     value != (SecurityProtocolType.Ssl3|SecurityProtocolType.Tls)) {

                    throw new NotSupportedException("value");
                }
                s_SecurityProtocolType = value;
            }
        }

        //
        // accessors
        //

        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.MaxServicePoints"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the maximum number of <see cref='System.Net.ServicePoint'/> instances that should be maintained at any
        ///    time.</para>
        /// </devdoc>
        public static int MaxServicePoints {
            get {
                return s_MaxServicePoints;
            }
            set {
                (new WebPermission(PermissionState.Unrestricted)).Demand();
                if (!ValidationHelper.ValidateRange(value, 0, Int32.MaxValue)) {
                    throw new ArgumentOutOfRangeException("MaxServicePoints");
                }
                s_MaxServicePoints = value;
            }
        }

        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.DefaultConnectionLimit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int DefaultConnectionLimit {
            get {
                return InternalConnectionLimit;
            }
            set {

                (new WebPermission(PermissionState.Unrestricted)).Demand();

                if (value > 0) {
                    InternalConnectionLimit = value;

                }
                else {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.net_toosmall));
                }
            }
        }



        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.MaxServicePointIdleTime"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the maximum idle time in seconds of a <see cref='System.Net.ServicePoint'/>.</para>
        /// </devdoc>
        public static int MaxServicePointIdleTime {
            get {
                return s_MaxServicePointIdleTime;
            }
            set {
                (new WebPermission(PermissionState.Unrestricted)).Demand();
                if ( !ValidationHelper.ValidateRange(value, Timeout.Infinite, Int32.MaxValue)) {
                    throw new ArgumentOutOfRangeException("MaxServicePointIdleTime");
                }
                s_MaxServicePointIdleTime = value;
            }
        }

        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.UseNagleAlgorithm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets indication whether use of the Nagling algorithm is desired.
        ///       Changing this value does not affect existing <see cref='System.Net.ServicePoint'/> instances but only to new ones that are created from that moment on.
        ///    </para>
        /// </devdoc>
        public static bool UseNagleAlgorithm {
            get {
                GetConfig();
                return s_NetConfig.useNagleAlgorithm;
            }
            set {
                GetConfig();
                s_NetConfig.useNagleAlgorithm = value;
            }
        }

        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.Expect100Continue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets indication whether 100-continue behaviour is desired.
        ///       Changing this value does not affect existing <see cref='System.Net.ServicePoint'/> instances but only to new ones that are created from that moment on.
        ///    </para>
        /// </devdoc>
        public static bool Expect100Continue {
            get {
                GetConfig();
                return s_NetConfig.expect100Continue;
            }
            set {
                GetConfig();
                s_NetConfig.expect100Continue = value;
            }
        }

        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.CertificatePolicy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Defines the s_Policy for how to deal with server certificates.
        ///    </para>
        /// </devdoc>
        public static ICertificatePolicy CertificatePolicy {
            get {
                return s_Policy;
            }
            set {
                //Prevent for an applet to override default Certificate Policy
                (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();
                s_Policy = value;
            }
        }

        public static bool CheckCertificateRevocationList {
            get {
                GetConfig();
                return s_NetConfig.checkCertRevocationList;
            }
            set {
                //Prevent an applet to override default certificate checking
                (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();
                GetConfig();
                s_NetConfig.checkCertRevocationList = value;
            }
        }

        internal static bool CheckCertificateName {
            get {
                GetConfig();
                return s_NetConfig.checkCertName;
            }
        }


        internal static void GetConfig(){
            if (s_NetConfig == null) {
                lock(typeof(ServicePointManager)) {
                    if (s_NetConfig == null) {
                        s_NetConfig = (NetConfiguration)ConfigurationSettings.GetConfig("system.net/settings");
                    }
                    if (s_NetConfig == null) {
                        s_NetConfig = new NetConfiguration();
                    }
                }
            }
        }

        //
        // class methods
        //

        //
        // MakeQueryString - Just a short macro to handle creating the query
        //  string that we search for host ports in the host list
        //
        internal static string MakeQueryString(Uri address) {
            return address.Scheme + "://" + address.Host + ":" + address.Port.ToString();
        }

        //
        // FindServicePoint - Query using an Uri string for a given ServerPoint Object
        //

        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.FindServicePoint"]/*' />
        /// <devdoc>
        /// <para>Finds an existing <see cref='System.Net.ServicePoint'/> or creates a new <see cref='System.Net.ServicePoint'/> to manage communications to the
        ///    specified Uniform Resource Identifier.</para>
        /// </devdoc>
        public static ServicePoint FindServicePoint(Uri address) {
            return FindServicePoint(address, GlobalProxySelection.GetEmptyWebProxy());
        }


        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.FindServicePoint1"]/*' />
        /// <devdoc>
        /// <para>Finds an existing <see cref='System.Net.ServicePoint'/> or creates a new <see cref='System.Net.ServicePoint'/> to manage communications to the
        ///    specified Uniform Resource Identifier.</para>
        /// </devdoc>
        public static ServicePoint FindServicePoint(string uriString, IWebProxy proxy) {

            Uri uri = new Uri(uriString);

            return FindServicePoint(uri, proxy);
        }

        //
        // FindServicePoint - Query using an Uri for a given server point
        //

        /// <include file='doc\ServicePointManager.uex' path='docs/doc[@for="ServicePointManager.FindServicePoint2"]/*' />
        /// <devdoc>
        /// <para>Findes an existing <see cref='System.Net.ServicePoint'/> or creates a new <see cref='System.Net.ServicePoint'/> to manage communications to the specified <see cref='System.Uri'/>
        /// instance.</para>
        /// </devdoc>
        public static ServicePoint FindServicePoint(Uri address, IWebProxy proxy) {
            if (address==null) {
                throw new ArgumentNullException("address");
            }
            GlobalLog.Enter("ServicePointManager::FindServicePoint() address:" + address.ToString());

            string tempEntry;
            bool isProxyServicePoint = false;

            ScavengeIdleServicePoints();

            //
            // find proxy info, and then switch on proxy
            //
            if (proxy!=null && !proxy.IsBypassed(address)) {
                // use proxy support
                // rework address
                Uri proxyAddress = proxy.GetProxy(address);
                if (proxyAddress.Scheme!=Uri.UriSchemeHttp) {
                    // CONSIDER V.NEXT
                    // we might want to try to emulate IE's behaviour. it seems like if you set
                    // a proxy with an https scheme it will still connect to the same host using
                    // HTTP on the specified port or changing it to 80 if the default is specified.
                    Exception exception = new NotSupportedException(SR.GetString(SR.net_proxyschemenotsupported, proxyAddress.Scheme));
                    GlobalLog.LeaveException("ServicePointManager::FindServicePoint() proxy has unsupported scheme:" + proxyAddress.Scheme.ToString(), exception);
                    throw exception;
                }
                address = proxyAddress;

                isProxyServicePoint = true;

                //
                // Search for the correct proxy host,
                //  then match its acutal host by using ConnectionGroups
                //  which are located on the actual ServicePoint.
                //

                tempEntry = MakeQueryString(proxyAddress);
            }
            else {
                //
                // Typical Host lookup
                //
                tempEntry = MakeQueryString(address);
            }

            //
            // lookup service point in the table
            //
            ServicePoint servicePoint = null;

            lock (s_ServicePointTable) {
                //
                // once we grab the lock, check if it wasn't already added
                //
                WeakReference servicePointReference =  (WeakReference) s_ServicePointTable[tempEntry];

                if ( servicePointReference != null ) {
                    servicePoint = (ServicePoint)servicePointReference.Target;
                }

                if (servicePoint == null) {
                    //
                    // lookup failure or timeout, we need to create a new ServicePoint
                    //
                    if (s_MaxServicePoints<=0 || s_ServicePointTable.Count<s_MaxServicePoints) {
                        //
                        // Determine Connection Limit
                        //
                        int connectionLimit = InternalConnectionLimit;
                        string schemeHostPort = MakeQueryString(address);

                        if (ConfigTable.ContainsKey(schemeHostPort) ) {
                            connectionLimit = (int) ConfigTable[schemeHostPort];
                        }

                        // Note: we don't check permissions to access proxy.
                        //      Rather, we should protect proxy property from being changed

                        servicePoint = new ServicePoint(address, s_MaxServicePointIdleTime, connectionLimit);
                        servicePointReference = new WeakReference(servicePoint);

                        // only set this when created, donates a proxy, statt Server
                        servicePoint.InternalProxyServicePoint = isProxyServicePoint;

                        s_ServicePointTable[tempEntry] = servicePointReference;
                    }
                    else {
                        Exception exception = new InvalidOperationException(SR.GetString(SR.net_maxsrvpoints));
                        GlobalLog.LeaveException("ServicePointManager::FindServicePoint() reached the limit count:" + s_ServicePointTable.Count.ToString() + " limit:" + s_MaxServicePoints.ToString(), exception);
                        throw exception;
                    }
                }

            } // lock

            GlobalLog.Leave("ServicePointManager::FindServicePoint() servicePoint#" + ValidationHelper.HashString(servicePoint));

            return servicePoint;
        }

    } // class ServicePointManager


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\transporttype.cs ===
//------------------------------------------------------------------------------
// <copyright file="TransportType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System;


    /// <include file='doc\TransportType.uex' path='docs/doc[@for="TransportType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines the transport type allowed for the socket.
    ///    </para>
    /// </devdoc>
    public  enum TransportType {
        /// <include file='doc\TransportType.uex' path='docs/doc[@for="TransportType.Udp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Udp connections are allowed.
        ///    </para>
        /// </devdoc>
        Udp     = 0x1,
        /// <include file='doc\TransportType.uex' path='docs/doc[@for="TransportType.Connectionless"]/*' />
        Connectionless = 1,
        /// <include file='doc\TransportType.uex' path='docs/doc[@for="TransportType.Tcp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       TCP connections are allowed.
        ///    </para>
        /// </devdoc>
        Tcp     = 0x2,
        /// <include file='doc\TransportType.uex' path='docs/doc[@for="TransportType.ConnectionOriented"]/*' />
        ConnectionOriented = 2,
        /// <include file='doc\TransportType.uex' path='docs/doc[@for="TransportType.All"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Any connection is allowed.
        ///    </para>
        /// </devdoc>
        All     = 0x3

    } // enum TransportType

} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Text;
    using System.Net.Sockets;

    [
    System.Runtime.InteropServices.ComVisible(false),
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNclNativeMethods {

        //
        // ADVAPI32.dll
        //
        // DELEGATION: We use FOUR next methods to keep the impersonation across threads
        //             but only during access to default Credential handle via SSPI.
        private const string KERNEL32 = "kernel32.dll";
        private const string ADVAPI32 = "advapi32.dll";
        [DllImport(ADVAPI32)]
        internal static extern int SetThreadToken([In] IntPtr threadref,[In] IntPtr token);

        [DllImport(ADVAPI32)]
        internal static extern int RevertToSelf();

        [DllImport(ADVAPI32)]
        internal static extern int OpenThreadToken([In] IntPtr threadHandle,[In] UInt32 DesiredAccess,
                                                   [In] int OpenAsSelf,  [Out] out IntPtr TokenHandle);
        [DllImport(KERNEL32)]
        internal static extern IntPtr GetCurrentThread();

        //Once you remove it here, please uncomment below in this file
        [DllImport(KERNEL32)]
        public static extern int CloseHandle(
                                            IntPtr hDevice
                                            );

        //
        // UnsafeNclNativeMethods.OSSOCK class contains all Unsafe() calls and should all be protected
        // by the appropriate SocketPermission() to connect/accept to/from remote
        // peers over the network and to perform name resolution.
        // te following calls deal mainly with:
        // 1) socket calls
        // 2) DNS calls
        //

        //
        // here's a brief explanation of all possible decorations we use for PInvoke.
        // these are provided thanks to input and feedback from David Mortenson, and
        // are used in such a way that we hope to gain maximum performance from the
        // unmanaged/managed/unmanaged transition we need to undergo when calling into winsock:
        //
        // [In] (Note: this is similar to what msdn will show)
        // the managed data will be marshalled so that the unmanaged function can read it but even
        // if it is changed in unmanaged world, the changes won't be propagated to the managed data
        //
        // [Out] (Note: this is similar to what msdn will show)
        // the managed data will not be marshalled so that the unmanaged function will not see the
        // managed data, if the data changes in unmanaged world, these changes will be propagated by
        // the marshaller to the managed data
        //
        // objects are marshalled differently if they're:
        //
        // 1) structs
        // for structs, by default, the whole layout is pushed on the stack as it is.
        // in order to pass a pointer to the managed layout, we need to specify either the ref or out keyword.
        //
        //      a) for IN and OUT:
        //      [In, Out] ref Struct ([In, Out] is optional here)
        //
        //      b) for IN only (the managed data will be marshalled so that the unmanaged
        //      function can read it but even if it changes it the change won't be propagated
        //      to the managed struct)
        //      [In] ref Struct
        //
        //      c) for OUT only (the managed data will not be marshalled so that the
        //      unmanaged function cannot read, the changes done in unmanaged code will be
        //      propagated to the managed struct)
        //      [Out] out Struct ([Out] is optional here)
        //
        // 2) array or classes
        // for array or classes, by default, a pointer to the managed layout is passed.
        // we don't need to specify neither the ref nor the out keyword.
        //
        //      a) for IN and OUT:
        //      [In, Out] byte[]
        //
        //      b) for IN only (the managed data will be marshalled so that the unmanaged
        //      function can read it but even if it changes it the change won't be propagated
        //      to the managed struct)
        //      [In] byte[] ([In] is optional here)
        //
        //      c) for OUT only (the managed data will not be marshalled so that the
        //      unmanaged function cannot read, the changes done in unmanaged code will be
        //      propagated to the managed struct)
        //      [Out] byte[]
        //
        [
        System.Runtime.InteropServices.ComVisible(false),
        System.Security.SuppressUnmanagedCodeSecurityAttribute()
        ]
        internal class OSSOCK {

            private const string WS2_32 = "ws2_32.dll";

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSAStartup(
                                               [In] short wVersionRequested,
                                               [Out] out WSAData lpWSAData
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSACleanup();

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern IntPtr socket(
                                                [In] AddressFamily addressFamily,
                                                [In] SocketType socketType,
                                                [In] ProtocolType protocolType
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int ioctlsocket(
                                                [In] IntPtr socketHandle,
                                                [In] int cmd,
                                                [In, Out] ref long argp
                                                );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern IntPtr gethostbyname(
                                                  [In] string host
                                                  );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern IntPtr gethostbyaddr(
                                                  [In] ref int addr,
                                                  [In] int len,
                                                  [In] ProtocolFamily type
                                                  );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int gethostname(
                                                [Out] StringBuilder hostName,
                                                [In] int bufferLength
                                                );

            // this should belong to SafeNativeMethods, but it will not for simplicity
            [DllImport(WS2_32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int inet_addr(
                                              [In] string cp
                                              );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int getpeername(
                                                [In] IntPtr socketHandle,
                                                [Out] byte[] socketAddress,
                                                [In, Out] ref int socketAddressSize
                                                );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int getsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [Out] out int optionValue,
                                               [In, Out] ref int optionLength
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int getsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [Out] byte[] optionValue,
                                               [In, Out] ref int optionLength
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int getsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [Out] out Linger optionValue,
                                               [In, Out] ref int optionLength
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int getsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [Out] out IPMulticastRequest optionValue,
                                               [In, Out] ref int optionLength
                                               );

            //
            // IPv6 Changes: need to receive and IPv6MulticastRequest from getsockopt
            //
            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int getsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [Out] out IPv6MulticastRequest optionValue,
                                               [In, Out] ref int optionLength
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int setsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [In] ref int optionValue,
                                               [In] int optionLength
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int setsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [In] byte[] optionValue,
                                               [In] int optionLength
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int setsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [In] ref Linger linger,
                                               [In] int optionLength
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int setsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [In] ref IPMulticastRequest mreq,
                                               [In] int optionLength
                                               );
            
            //
            // IPv6 Changes: need to pass an IPv6MulticastRequest to setsockopt
            //
            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int setsockopt(
                                               [In] IntPtr socketHandle,
                                               [In] SocketOptionLevel optionLevel,
                                               [In] SocketOptionName optionName,
                                               [In] ref IPv6MulticastRequest mreq,
                                               [In] int optionLength
                                               );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int connect(
                                            [In] IntPtr socketHandle,
                                            [In] byte[] socketAddress,
                                            [In] int socketAddressSize
                                            );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int send(
                                         [In] IntPtr socketHandle,
                                         [In] IntPtr pinnedBuffer,
                                         [In] int len,
                                         [In] SocketFlags socketFlags
                                         );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int recv(
                                         [In] IntPtr socketHandle,
                                         [In] IntPtr pinnedBuffer,
                                         [In] int len,
                                         [In] SocketFlags socketFlags
                                         );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int closesocket(
                                                [In] IntPtr socketHandle
                                                );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern IntPtr accept(
                                           [In] IntPtr socketHandle,
                                           [Out] byte[] socketAddress,
                                           [In, Out] ref int socketAddressSize
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int listen(
                                           [In] IntPtr socketHandle,
                                           [In] int backlog
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int bind(
                                         [In] IntPtr socketHandle,
                                         [In] byte[] socketAddress,
                                         [In] int socketAddressSize
                                         );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int shutdown(
                                             [In] IntPtr socketHandle,
                                             [In] int how
                                             );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int sendto(
                                           [In] IntPtr socketHandle,
                                           [In] IntPtr pinnedBuffer,
                                           [In] int len,
                                           [In] SocketFlags socketFlags,
                                           [In] byte[] socketAddress,
                                           [In] int socketAddressSize
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int recvfrom(
                                             [In] IntPtr socketHandle,
                                             [In] IntPtr pinnedBuffer,
                                             [In] int len,
                                             [In] SocketFlags socketFlags,
                                             [Out] byte[] socketAddress,
                                             [In, Out] ref int socketAddressSize
                                             );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int getsockname(
                                                [In] IntPtr socketHandle,
                                                [Out] byte[] socketAddress,
                                                [In, Out] ref int socketAddressSize
                                                );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int select(
                                           [In] int ignoredParameter,
                                           [In, Out] ref FileDescriptorSet readfds,
                                           [In, Out] ref FileDescriptorSet writefds,
                                           [In, Out] ref FileDescriptorSet exceptfds,
                                           [In] ref TimeValue timeout
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int select(
                                           [In] int ignoredParameter,
                                           [In, Out] ref FileDescriptorSet readfds,
                                           [In, Out] ref FileDescriptorSet writefds,
                                           [In, Out] ref FileDescriptorSet exceptfds,
                                           [In] IntPtr nullTimeout
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int select(
                                           [In] int ignoredParameter,
                                           [In, Out] ref FileDescriptorSet readfds,
                                           [In] IntPtr ignoredA,
                                           [In] IntPtr ignoredB,
                                           [In] ref TimeValue timeout
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int select(
                                           [In] int ignoredParameter,
                                           [In, Out] ref FileDescriptorSet readfds,
                                           [In] IntPtr ignoredA,
                                           [In] IntPtr ignoredB,
                                           [In] IntPtr nullTimeout
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int select(
                                           [In] int ignoredParameter,
                                           [In] IntPtr ignoredA,
                                           [In, Out] ref FileDescriptorSet writefds,
                                           [In] IntPtr ignoredB,
                                           [In] ref TimeValue timeout
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int select(
                                           [In] int ignoredParameter,
                                           [In] IntPtr ignoredA,
                                           [In, Out] ref FileDescriptorSet writefds,
                                           [In] IntPtr ignoredB,
                                           [In] IntPtr nullTimeout
                                           );


            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int select(
                                           [In] int ignoredParameter,
                                           [In] IntPtr ignoredA,
                                           [In] IntPtr ignoredB,
                                           [In, Out] ref FileDescriptorSet exceptfds,
                                           [In] ref TimeValue timeout
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int select(
                                           [In] int ignoredParameter,
                                           [In] IntPtr ignoredA,
                                           [In] IntPtr ignoredB,
                                           [In, Out] ref FileDescriptorSet exceptfds,
                                           [In] IntPtr nullTimeout
                                           );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSASend(
                                              [In] IntPtr socketHandle,
                                              [In] ref WSABuffer Buffer,
                                              [In] int BufferCount,
                                              [In] IntPtr bytesTransferred,
                                              [In] SocketFlags socketFlags,
                                              [In] IntPtr overlapped,
                                              [In] IntPtr completionRoutine
                                              );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSASend(
                                              [In] IntPtr socketHandle,
                                              [In] WSABuffer[] BufferArray,
                                              [In] int BufferCount,
                                              [In] IntPtr bytesTransferred,
                                              [In] SocketFlags socketFlags,
                                              [In] IntPtr overlapped,
                                              [In] IntPtr completionRoutine
                                              );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSASendTo(
                                                [In] IntPtr socketHandle,
                                                [In] ref WSABuffer Buffer,
                                                [In] int BufferCount,
                                                [In] IntPtr BytesWritten,
                                                [In] SocketFlags socketFlags,
                                                [In] byte[] socketAddress,
                                                [In] int socketAddressSize,
                                                [In] IntPtr overlapped,
                                                [In] IntPtr completionRoutine
                                                );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSARecv(
                                              [In] IntPtr socketHandle,
                                              [In, Out] ref WSABuffer Buffer,
                                              [In] int BufferCount,
                                              [In] IntPtr bytesTransferred,
                                              [In, Out] ref SocketFlags socketFlags,
                                              [In] IntPtr overlapped,
                                              [In] IntPtr completionRoutine
                                              );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSARecvFrom(
                                                  [In] IntPtr socketHandle,
                                                  [In, Out] ref WSABuffer Buffer,
                                                  [In] int BufferCount,
                                                  [In] IntPtr bytesTransferred,
                                                  [In, Out] ref SocketFlags socketFlags,
                                                  [In] IntPtr socketAddressPointer,
                                                  [In] IntPtr socketAddressSizePointer,
                                                  [In] IntPtr overlapped,
                                                  [In] IntPtr completionRoutine
                                                  );


            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSAEventSelect(
                                                     [In] IntPtr socketHandle,
                                                     [In] IntPtr Event,
                                                     [In] AsyncEventBits NetworkEvents
                                                     );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern IntPtr WSASocket(
                                                    [In] AddressFamily addressFamily,
                                                    [In] SocketType socketType,
                                                    [In] ProtocolType protocolType,
                                                    [In] IntPtr protocolInfo, // will be WSAProtcolInfo protocolInfo once we include QOS APIs
                                                    [In] uint group,
                                                    [In] SocketConstructorFlags flags
                                                    );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSAIoctl(
                                                [In] IntPtr socketHandle,
                                                [In] int ioControlCode,
                                                [In] byte[] inBuffer,
                                                [In] int inBufferSize,
                                                [Out] byte[] outBuffer,
                                                [In] int outBufferSize,
                                                [Out] out int bytesTransferred,
                                                [In] IntPtr overlapped,
                                                [In] IntPtr completionRoutine
                                                );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int WSAEnumNetworkEvents(
                                                     [In] IntPtr socketHandle,
                                                     [In] IntPtr Event,
                                                     [In, Out] ref NetworkEvents networkEvents
                                                     );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern bool WSAGetOverlappedResult(
                                                     [In] IntPtr socketHandle,
                                                     [In] IntPtr overlapped,
                                                     [Out] out uint bytesTransferred,
                                                     [In] bool wait,
                                                     [In] IntPtr ignored
                                                     );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern uint WSAGetLastError();

            [DllImport(WS2_32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int WSAStringToAddress(
                [In] string addressString,
                [In] AddressFamily addressFamily,
                [In] IntPtr lpProtocolInfo, // always passing in a 0
                [Out] byte[] socketAddress,
                [In, Out] ref int socketAddressSize );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int WSAAddressToString(
                [In] byte[] socketAddress,
                [In] int socketAddressSize,
                [In] IntPtr lpProtocolInfo,// always passing in a 0
                [Out]StringBuilder addressString,
                [In, Out] ref int addressStringLength);

            //
            // IPv6 Changes: declare getaddrinfo, freeaddrinfo and getnameinfo
            //
            [DllImport(WS2_32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int getaddrinfo(
                [In]     string      nodename,
                [In]     string      servicename,
                [In]     IntPtr      hints,
                [In] ref IntPtr      returnedInfo );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int getaddrinfo(
                [In]     string      nodename,
                [In]     string      servicename,
                [In] ref AddressInfo hints,
                [In] ref IntPtr      returnedInfo );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern void freeaddrinfo(
                [In] IntPtr info );

            [DllImport(WS2_32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int getnameinfo(
                [In]         byte[]        sa,
                [In]         int           salen,
                [In,Out]     StringBuilder host,
                [In]         int           hostlen,
                [In,Out]     StringBuilder serv,
                [In]         int           servlen,
                [In]         int           flags);

            [DllImport(WS2_32, CharSet=CharSet.Auto, SetLastError=true)]
            internal static extern int WSAEnumProtocols(
                                                        [MarshalAs(UnmanagedType.LPArray)]
                                                        [In] int[]     lpiProtocols,
                                                        [In] IntPtr    lpProtocolBuffer,
                                                        [In] ref uint  lpdwBufferLength
                                                       );

        }; // class UnsafeNclNativeMethods.OSSOCK


        //
        // UnsafeNclNativeMethods.NativePKI class contains all Unsafe() calls and should all be protected
        // the appropriate WebPermission() to send WebRequest over the
        // wire. they deal mainly with:
        // 1) server certificate handling when doing https://
        //
        [
        System.Runtime.InteropServices.ComVisible(false),
        System.Security.SuppressUnmanagedCodeSecurityAttribute()
        ]
        internal class NativePKI {

            private const string CRYPT32 = "crypt32.dll";

            [DllImport(CRYPT32, CharSet=CharSet.Unicode, SetLastError=true)]
            public static extern  int CertGetCertificateChain(
                [In] IntPtr                 chainEngine,
                [In] IntPtr                 certContext,
                [In] IntPtr                 time,
                [In] IntPtr                 additionalStore,
                [In] ref ChainParameters    certCP,
                [In] int                    flags,
                [In] IntPtr                 reserved,
                [In] ref IntPtr             chainContext);

            [DllImport(CRYPT32, CharSet=CharSet.Unicode, SetLastError=true)]
            public static extern IntPtr CertFindChainInStore(
                [In] IntPtr hCertStore,
                [In] CertificateEncoding dwCertEncodingType,
                [In] int dwFindFlags,
                [In] int dwFindType,
                [In] CertChainFindByIssuer pvFindPara,
                [In] IntPtr pPrevCertContext);

            [DllImport(CRYPT32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern  int CertVerifyCertificateChainPolicy(
                [In] ChainPolicyType            policy,
                [In] IntPtr                     chainContext,
                [In] ref ChainPolicyParameter   cpp,
                [In, Out] ref ChainPolicyStatus ps);

            [DllImport(CRYPT32, CharSet=CharSet.Unicode, SetLastError=true)]
            public static extern void CertFreeCertificateChain(
                [In] IntPtr pChainContext);


            [DllImport(CRYPT32, CharSet=CharSet.Unicode, SetLastError=true)]
            public static extern IntPtr CertFindCertificateInStore(
                [In] IntPtr hCertStore,
                [In] CertificateEncoding dwCertEncodingType,
                [In] int dwFindFlags,
                [In] int dwFindType,
                [In] ref CryptoBlob pvFindPara,
                [In] IntPtr pPrevCertContext);

            [DllImport(CRYPT32, CharSet=CharSet.Unicode, SetLastError=true)]
            public static extern int CertFreeCertificateContext(
                [In] IntPtr certContext);

            [DllImport(CRYPT32, CharSet=CharSet.Unicode, SetLastError=true)]
            public static extern IntPtr CertOpenSystemStore(
                [In] IntPtr hProv,
                [In] string szSubsystemProtocol);

            [DllImport(CRYPT32, CharSet=CharSet.Unicode, SetLastError=true)]
            public static extern bool CertCloseStore(
                [In] IntPtr hCertStore,
                [In] int dwFlags);

/*            [DllImport(CRYPT32, CharSet=CharSet.Unicode, SetLastError=true)]
            public static extern IntPtr CertCreateCertificateContext(
                [In] int certEncodingType,
                [In] byte[] certEncoded,
                [In] int certEncodedSize);
*/

        }; // class UnsafeNclNativeMethods.NativePKI


        //
        // NativeNTSSPI, UnsafeNclNativeMethods.NativeAuthWin9xSSPI and UnsafeNclNativeMethods.NativeSSLWin9xSSPI
        // classes contain all Unsafe() calls and should all be protected
        // the appropriate WebPermission() to send WebRequest over the
        // wire. they deal mainly with:
        // 1) encryption/SSL handling when doing https://
        // 2) SSPI handling when doing HTTP authentication
        //

        //
        // We need to import the same interface from 3 different DLLs,
        //  Security.dll, Secur32.dll, and Schannel.Dll.
        //  Secur32.dll and Schannel.dll are for Win9x.
        //  Security.dll is for NT platforms.
        //
        [
        System.Runtime.InteropServices.ComVisible(false),
        System.Security.SuppressUnmanagedCodeSecurityAttribute()
        ]
        internal class NativeNTSSPI {

            private const string SECURITY = "security.dll";

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int EnumerateSecurityPackagesW(
                  [Out] out int pkgnum,
                  [Out] out IntPtr arrayptr);

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int FreeContextBuffer(
                  [In] IntPtr contextBuffer);

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleW(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In] ref AuthIdentity authdata,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );


            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleW(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In] IntPtr nullAuthData,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleW(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In] ref SChannelCred authdata,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int FreeCredentialsHandle(
                  [In] ref long handle
                  );

            //
            // we have two interfaces to this method call.
            // we will use the first one when we want to pass in a null
            // for the "context" and "inputBuffer" parameters
            //
            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int InitializeSecurityContextW(
                  [In, Out] ref long          credentialHandle,
                  [In] IntPtr                 context,
                  [In] string                 targetName,
                  [In] int                    requirements,
                  [In] int                    reservedI,
                  [In] int                    endianness,
                  [In] IntPtr                 inputBuffer,
                  [In] int                    reservedII,
                  [In, Out] ref long          newContext,
                  [In, Out] ref SecurityBufferDescriptor outputBuffer,
                  [In, Out] ref int           attributes,
                  [In, Out] ref long          timestamp
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int InitializeSecurityContextW(
                  [In, Out] ref long          credentialHandle,
                  [In, Out] ref long          context,
                  [In] string                 targetName,
                  [In] int                    requirements,
                  [In] int                    reservedI,
                  [In] int                    endianness,
                  [In, Out] ref SecurityBufferDescriptor inputBuffer,
                  [In] int                    reservedII,
                  [In, Out] ref long          newContext,
                  [In, Out] ref SecurityBufferDescriptor outputBuffer,
                  [In, Out] ref int           attributes,
                  [In, Out] ref long          timestamp
                  );


            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int DeleteSecurityContext(
                  [In] ref long handle
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int EncryptMessage(
                  [In] ref long             contextHandle,
                  [In] int                  qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor    input,
                  [In] int                  sequenceNumber
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int DecryptMessage(
                  [In] ref long             contextHandle,
                  [In] int                  qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor    input,
                  [In] int                  sequenceNumber
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int SealMessage(
                  [In] ref long            contextHandle,
                  [In] int                 qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor   input,
                  [In] int                 sequenceNumber
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int UnsealMessage(
                  [In] ref long          contextHandle,
                  [In, Out] ref SecurityBufferDescriptor input,
                  [In] int               qualityOfProtection,
                  [In] int               sequenceNumber
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern SecurityStatus QueryContextAttributes(
                  [In] ref long ContextHandle,
                  [In] int ulAttribute,
                  [In, Out] ref IntPtr name
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int QueryContextAttributes(
                  [In] ref long phContext,
                  [In] int      attribute,
                  [In] IntPtr   buffer
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int QueryCredentialAttributes(
                  [In] ref long  phContext,
                  [In] int       attribute,
                  [In] IntPtr    buffer
                  );

#if SERVER_SIDE_SSPI
            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int RevertSecurityContext(
                  [In] ref long phContext
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int ImpersonateSecurityContext(
                  [In] ref long phContext
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int AcceptSecurityContext(
                  [In] ref long                  credentialHandle,
                  [In] int                       context,
                  [In] int                       inputBuffer,
                  [In] int                       requirements,
                  [In] int                       endianness,
                  [In, Out] ref long             newContext,
                  [In, Out] ref SecurityBufferDescriptor    outputBuffer,
                  [Out] out int                  attributes,
                  [Out] out long                 timestamp
                  );

            [DllImport(SECURITY, CharSet=CharSet.Unicode, SetLastError=true)]
            internal static extern int AcceptSecurityContext(
                  [In] ref long                        credentialHandle,
                  [In, Out] ref long                   context,
                  [In] ref SecurityBufferDescriptor    inputBuffer,
                  [In] int                             requirements,
                  [In] int                             endianness,
                  [In, Out] ref long                   newContext,
                  [In, Out] ref SecurityBufferDescriptor    outputBuffer,
                  [Out] out int                        attributes,
                  [Out] out long                       timestamp
                  );
#endif // SERVER_SIDE_SSPI
        }; // class UnsafeNclNativeMethods.NativeNTSSPI

        [
        System.Runtime.InteropServices.ComVisible(false),
        System.Security.SuppressUnmanagedCodeSecurityAttribute()
        ]
        internal class NativeAuthWin9xSSPI {

            private const string SECUR32 = "secur32.dll";

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int EnumerateSecurityPackagesA(
                  [Out] out int pkgnum,
                  [Out] out IntPtr arrayptr
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int FreeContextBuffer(
                  [In] IntPtr contextBuffer);

            [DllImport(SECUR32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleA(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In] ref AuthIdentity authdata,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );


            [DllImport(SECUR32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleA(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In] IntPtr nullAuthData,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleA(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In, Out] ref SChannelCred authdata,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int FreeCredentialsHandle(
                  [In] ref long handle
                  );

            //
            // we have two interfaces to this method call.
            // we will use the first one when we want to pass in a null
            // for the "context" and "inputBuffer" parameters
            //
            [DllImport(SECUR32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int InitializeSecurityContextA(
                  [In, Out] ref long          credentialHandle,
                  [In] IntPtr                 context,
                  [In] string                 targetName,
                  [In] int                    requirements,
                  [In] int                    reservedI,
                  [In] int                    endianness,
                  [In] IntPtr                 inputBuffer,
                  [In] int                    reservedII,
                  [In, Out] ref long          newContext,
                  [In, Out] ref SecurityBufferDescriptor outputBuffer,
                  [In, Out] ref int           attributes,
                  [In, Out] ref long          timestamp
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int InitializeSecurityContextA(
                  [In, Out] ref long          credentialHandle,
                  [In, Out] ref long          context,
                  [In] string                 targetName,
                  [In] int                    requirements,
                  [In] int                    reservedI,
                  [In] int                    endianness,
                  [In, Out] ref SecurityBufferDescriptor inputBuffer,
                  [In] int                    reservedII,
                  [In, Out] ref long          newContext,
                  [In, Out] ref SecurityBufferDescriptor outputBuffer,
                  [In, Out] ref int           attributes,
                  [In, Out] ref long          timestamp
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int DeleteSecurityContext(
                  [In] ref long handle
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int EncryptMessage(
                  [In] ref long             contextHandle,
                  [In] int                  qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor    input,
                  [In] int                  sequenceNumber
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int DecryptMessage(
                  [In] ref long             contextHandle,
                  [In] int                  qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor    input,
                  [In] int                  sequenceNumber
                  );


            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int SealMessage(
                  [In] ref long            contextHandle,
                  [In] int                 qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor   input,
                  [In] int                 sequenceNumber
                  );


            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int UnsealMessage(
                  [In] ref long          contextHandle,
                  [In, Out] ref SecurityBufferDescriptor input,
                  [In] int               qualityOfProtection,
                  [In] int               sequenceNumber
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern SecurityStatus QueryContextAttributes(
                  [In] ref long ContextHandle,
                  [In] int ulAttribute,
                  [In, Out] ref IntPtr name
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int QueryContextAttributes(
                  [In] ref long phContext,
                  [In] int      attribute,
                  [In] IntPtr   buffer
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int QueryCredentialAttributes(
                  [In] ref long  phContext,
                  [In] int       attribute,
                  [In] IntPtr    buffer
                  );

#if SERVER_SIDE_SSPI
            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int RevertSecurityContext(
                  [In] ref long phContext
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int ImpersonateSecurityContext(
                  [In] ref long phContext
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int AcceptSecurityContext(
                  [In] ref long                  credentialHandle,
                  [In] int                       context,
                  [In] int                       inputBuffer,
                  [In] int                       requirements,
                  [In] int                       endianness,
                  [In, Out] ref long             newContext,
                  [In, Out] ref SecurityBufferDescriptor    outputBuffer,
                  [Out] out int                  attributes,
                  [Out] out long                 timestamp
                  );

            [DllImport(SECUR32, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int AcceptSecurityContext(
                  [In] ref long                        credentialHandle,
                  [In, Out] ref long                   context,
                  [In] ref SecurityBufferDescriptor    inputBuffer,
                  [In] int                             requirements,
                  [In] int                             endianness,
                  [In, Out] ref long                   newContext,
                  [In, Out] ref SecurityBufferDescriptor    outputBuffer,
                  [Out] out int                        attributes,
                  [Out] out long                       timestamp
                  );
#endif // SERVER_SIDE_SSPI
        }; // class UnsafeNclNativeMethods.NativeAuthWin9xSSPI

        [
        System.Runtime.InteropServices.ComVisible(false),
        System.Security.SuppressUnmanagedCodeSecurityAttribute()
        ]
        internal class NativeSSLWin9xSSPI {

            private const string SCHANNEL = "schannel.dll";

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int EnumerateSecurityPackagesA(
                  [Out] out int pkgnum,
                  [Out] out IntPtr arrayptr
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int FreeContextBuffer(
                  [In] IntPtr contextBuffer
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleA(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In] ref AuthIdentity authdata,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleA(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In] IntPtr nullAuthData,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int AcquireCredentialsHandleA(
                  [In] string principal,
                  [In] string moduleName,
                  [In] int usage,
                  [In] int logonID,
                  [In] ref SChannelCred authdata,
                  [In] int keyCallback,
                  [In] int keyArgument,
                  [In, Out] ref long handle,
                  [In, Out] ref long timestamp
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int FreeCredentialsHandle(
                  [In] ref long handle
                  );

            //
            // we have two interfaces to this method call.
            // we will use the first one when we want to pass in a null
            // for the "context" and "inputBuffer" parameters
            //
            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int InitializeSecurityContextA(
                  [In, Out] ref long          credentialHandle,
                  [In] IntPtr                 context,
                  [In] string                 targetName,
                  [In] int                    requirements,
                  [In] int                    reservedI,
                  [In] int                    endianness,
                  [In] IntPtr                 inputBuffer,
                  [In] int                    reservedII,
                  [In, Out] ref long          newContext,
                  [In, Out] ref SecurityBufferDescriptor outputBuffer,
                  [In, Out] ref int           attributes,
                  [In, Out] ref long          timestamp
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
            internal static extern int InitializeSecurityContextA(
                  [In, Out] ref long          credentialHandle,
                  [In, Out] ref long          context,
                  [In] string                 targetName,
                  [In] int                    requirements,
                  [In] int                    reservedI,
                  [In] int                    endianness,
                  [In, Out] ref SecurityBufferDescriptor inputBuffer,
                  [In] int                    reservedII,
                  [In, Out] ref long          newContext,
                  [In, Out] ref SecurityBufferDescriptor outputBuffer,
                  [In, Out] ref int           attributes,
                  [In, Out] ref long          timestamp
                  );


            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int DeleteSecurityContext(
                  [In] ref long handle
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int EncryptMessage(
                  [In] ref long             contextHandle,
                  [In] int                  qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor    input,
                  [In] int                  sequenceNumber
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int DecryptMessage(
                  [In] ref long             contextHandle,
                  [In] int                  qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor    input,
                  [In] int                  sequenceNumber
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int SealMessage(
                  [In] ref long            contextHandle,
                  [In] int                 qualityOfProtection,
                  [In, Out] ref SecurityBufferDescriptor   input,
                  [In] int                 sequenceNumber
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int UnsealMessage(
                  [In] ref long          contextHandle,
                  [In, Out] ref SecurityBufferDescriptor input,
                  [In] int               qualityOfProtection,
                  [In] int               sequenceNumber
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern SecurityStatus QueryContextAttributes(
                  [In] ref long ContextHandle,
                  [In] int ulAttribute,
                  [In, Out] ref IntPtr name
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int QueryContextAttributes(
                  [In] ref long phContext,
                  [In] int      attribute,
                  [In] IntPtr   buffer
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int QueryCredentialAttributes(
                  [In] ref long  phContext,
                  [In] int       attribute,
                  [In] IntPtr    buffer
                  );

#if SERVER_SIDE_SSPI
            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int RevertSecurityContext(
                  [In] ref long phContext
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int ImpersonateSecurityContext(
                  [In] ref long phContext
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int AcceptSecurityContext(
                  [In] ref long                  credentialHandle,
                  [In] int                       context,
                  [In] int                       inputBuffer,
                  [In] int                       requirements,
                  [In] int                       endianness,
                  [In, Out] ref long             newContext,
                  [In, Out] ref SecurityBufferDescriptor    outputBuffer,
                  [Out] out int                  attributes,
                  [Out] out long                 timestamp
                  );

            [DllImport(SCHANNEL, CharSet=CharSet.Ansi, SetLastError=true)]
            internal static extern int AcceptSecurityContext(
                  [In] ref long                        credentialHandle,
                  [In, Out] ref long                   context,
                  [In] ref SecurityBufferDescriptor    inputBuffer,
                  [In] int                             requirements,
                  [In] int                             endianness,
                  [In, Out] ref long                   newContext,
                  [In, Out] ref SecurityBufferDescriptor    outputBuffer,
                  [Out] out int                        attributes,
                  [Out] out long                       timestamp
                  );
#endif // SERVER_SIDE_SSPI
        }; // class UnsafeNclNativeMethods.NativeSSLWin9xSSPI

#if TRAVE
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        public static extern int GetCurrentThreadId();
#endif

#if COMNET_LISTENER

        //
        // these classes are not compiled as part of the product yet,
        // they probably will be in V2.
        //
        private const string ULAPI = "ulapi.dll";

        public static IntPtr INVALID_HANDLE_VALUE = (IntPtr)-1;

        [DllImport(KERNEL32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern void FillMemory(
                                            IntPtr destination,
                                            int size,
                                            byte fill
                                            );

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern void CopyMemoryW(IntPtr destination, string source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern void CopyMemoryW(IntPtr destination, char[] source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern void CopyMemoryW(StringBuilder destination, IntPtr source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern void CopyMemoryW(char[] destination, IntPtr source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern void CopyMemoryA(IntPtr destination, string source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern void CopyMemoryA(IntPtr destination, char[] source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern void CopyMemoryA(StringBuilder destination, IntPtr source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern void CopyMemoryA(char[] destination, IntPtr source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Auto, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern void CopyMemory(IntPtr destination, byte[] source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Auto, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern void CopyMemory(byte[] destination, IntPtr source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Auto, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern void CopyMemory(IntPtr destination, IntPtr source, int size);

        [DllImport(KERNEL32, ExactSpelling=true, CharSet=CharSet.Auto, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern void CopyMemory(IntPtr destination, string source, int size);

        [DllImport(KERNEL32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true, SetLastError=true)]
        public static extern IntPtr CreateFileA(
                                            string lpFileName,
                                            int dwDesiredAccess,
                                            int dwShareMode,
                                            IntPtr lpSecurityAttributes,
                                            int dwCreationDisposition,
                                            int dwFlagsAndAttributes,
                                            int hTemplateFile
                                            );

//        [DllImport(KERNEL32, CharSet=CharSet.Auto, SetLastError=true)]
//        public static extern int CloseHandle(
//                                            IntPtr hDevice
//                                            );

        [DllImport(KERNEL32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern bool DeviceIoControl(
                                                 IntPtr hDevice,
                                                 int dwIoControlCode,
                                                 int[] InBuffer,
                                                 int nInBufferSize,
                                                 int[] OutBuffer,
                                                 int nOutBufferSize,
                                                 ref int pBytesReturned,
                                                 IntPtr pOverlapped
                                                 );

        [DllImport(ADVAPI32, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern bool InitializeSecurityDescriptor(
                                                              IntPtr pSecurityDescriptor,
                                                              int dwRevision
                                                              );

        [DllImport(ADVAPI32, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern bool AllocateAndInitializeSid(
                                                          IntPtr pIdentifierAuthority,
                                                          byte nSubAuthorityCount,
                                                          int nSubAuthority0,
                                                          int nSubAuthority1,
                                                          int nSubAuthority2,
                                                          int nSubAuthority3,
                                                          int nSubAuthority4,
                                                          int nSubAuthority5,
                                                          int nSubAuthority6,
                                                          int nSubAuthority7,
                                                          ref IntPtr pSid
                                                          );

        [DllImport(ADVAPI32, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int GetLengthSid(
                                             IntPtr pSid
                                             );

        [DllImport(ADVAPI32, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int FreeSid(
                                        IntPtr pSid
                                        );

        [DllImport(ADVAPI32, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern bool InitializeAcl(
                                               IntPtr pAcl,
                                               int nAclLength,
                                               int dwAclRevision
                                               );

        [DllImport(ADVAPI32, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern bool AddAccessAllowedAce(
                                                     IntPtr pAcl,
                                                     int dwAceRevision,
                                                     int AccessMask,
                                                     IntPtr pSid
                                                     );

        [DllImport(ADVAPI32, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern bool SetSecurityDescriptorDacl(
                                                           IntPtr pSecurityDescriptor,
                                                           bool bDaclPresent,
                                                           IntPtr pDacl,
                                                           bool bDaclDefaulted
                                                           );


        //
        // ulapi.dll
        //
        // many of these APIs use unsigned numbers, but since signed numbers
        // will work as well for pointers & return values, we will use signed
        // numbers, ignoring the fact that there's no reasonable semantics
        // (for instance) for a negative pointer.
        //
        [DllImport(ULAPI, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int UlInitialize(
                                             int Reserved
                                             );


        [DllImport(ULAPI, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern void UlTerminate(
                                             );


        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlCreateAppPool(
                                                ref IntPtr pAppPoolHandle,
                                                string pAppPoolName,
                                                IntPtr pSecurityAttributes,
                                                int Options
                                                );


        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlAddTransientUrl(
                                                  IntPtr AppPoolHandle,
                                                  string pFullyQualifiedUrl
                                                  );


        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlRemoveTransientUrl(
                                                     IntPtr AppPoolHandle,
                                                     string pFullyQualifiedUrl
                                                     );


        [DllImport(ULAPI, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int UlReceiveHttpRequest(
                                                     IntPtr AppPoolHandle,
                                                     long RequestId,
                                                     int Flags,
                                                     IntPtr pRequestBuffer,
                                                     int RequestBufferLength,
                                                     ref int pBytesReturned,
                                                     IntPtr pOverlapped
                                                     );


        [DllImport(ULAPI, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int UlReceiveEntityBody(
                                                    IntPtr AppPoolHandle,
                                                    long RequestId,
                                                    int Flags,
                                                    IntPtr pEntityBuffer,
                                                    int EntityBufferLength,
                                                    ref int pBytesReturned,
                                                    IntPtr pOverlapped
                                                    );


        [DllImport(ULAPI, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int UlSendHttpResponse(
                                                   IntPtr AppPoolHandle,
                                                   long RequestId,
                                                   int Flags,
                                                   IntPtr pHttpResponse,
                                                   int EntityChunkCount,
                                                   IntPtr pEntityChunks,
                                                   IntPtr pCachePolicy,
                                                   ref int pBytesSent,
                                                   IntPtr pOverlapped
                                                   );


        [DllImport(ULAPI, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int UlSendEntityBody(
                                                 IntPtr AppPoolHandle,
                                                 long RequestId,
                                                 int Flags,
                                                 int EntityChunkCount,
                                                 IntPtr pEntityChunks,
                                                 ref int pBytesSent,
                                                 IntPtr pOverlapped
                                                 );


        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlOpenAppPool(
                                              ref IntPtr pAppPoolHandle,
                                              string pAppPoolName,
                                              int Options
                                              );



        //
        // the following we will only need
        // under NT for config group creation
        // CODEWORK:
        // make pSecurityDescriptor and pSecurityAttributes managed arrays
        // and use pinned buffers handles
        //
        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlOpenControlChannel(
                                                     ref IntPtr pControlChannel,
                                                     int Options
                                                     );

        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlSetControlChannelInformation(
                                                               IntPtr ControlChannelHandle,
                                                               int InformationClass,
                                                               ref int controlChannelInformation,
                                                               int Length
                                                               );

        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlSetConfigGroupInformation(
                                                            IntPtr ControlChannelHandle,
                                                            long ConfigGroupId,
                                                            int InformationClass,
                                                            IntPtr pConfigGroupInformation,
                                                            int Length
                                                            );

        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlCreateConfigGroup(
                                                    IntPtr ControlChannelHandle,
                                                    ref long pConfigGroupId
                                                    );

        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlDeleteConfigGroup(
                                                    IntPtr ControlChannelHandle,
                                                    long ConfigGroupId
                                                    );

        [DllImport(ULAPI, CharSet=CharSet.Unicode, SetLastError=true)]
        public static extern int UlAddUrlToConfigGroup(
                                                      IntPtr ControlChannelHandle,
                                                      long ConfigGroupId,
                                                      string pFullyQualifiedUrl,
                                                      int UrlContext
                                                      );

#endif // #if COMNET_LISTENER

    }; // class UnsafeNclNativeMethods


} // class namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\internal.cs ===
//------------------------------------------------------------------------------
// <copyright file="Internal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Reflection;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Net.Sockets;
    using System.Runtime.InteropServices;
    using System.Security.Cryptography.X509Certificates;
    using System.Text.RegularExpressions;
    using System.Security.Permissions;
     
    
    internal class NetConfiguration : ICloneable {
        internal bool checkCertRevocationList = false;
        internal bool checkCertName = true;
        internal bool ipv6Enabled = false;
        internal bool useNagleAlgorithm = true;
        internal bool expect100Continue = true;

        internal int maximumResponseHeadersLength = 64;

        public object Clone() {
            return MemberwiseClone();
        }
    }
    
    internal class IntPtrHelper {
        internal static IntPtr Add(IntPtr a, int b) {
            return (IntPtr) ((long) a + b);
        }

        internal static IntPtr Add(IntPtr a, IntPtr b) {
            return (IntPtr) ((long) a + (long)b);
        }

        internal static IntPtr Add(int a, IntPtr b) {
            return (IntPtr) ((long) a + (long)b);
        }
    }


    //
    // support class for Validation related stuff.
    //
    internal class ValidationHelper {

        public static string [] EmptyArray = new string[0];

        internal static readonly char[]  InvalidMethodChars =
                new char[]{
                ' ',
                '\r',
                '\n',
                '\t'
                };

        // invalid characters that cannot be found in a valid method-verb or http header
        internal static readonly char[]  InvalidParamChars =
                new char[]{
                '(',
                ')',
                '<',
                '>',
                '@',
                ',',
                ';',
                ':',
                '\\',
                '"',
                '\'',
                '/',
                '[',
                ']',
                '?',
                '=',
                '{',
                '}',
                ' ',
                '\t',
                '\r',
                '\n'};

        public static string [] MakeEmptyArrayNull(string [] stringArray) {
            if ( stringArray == null || stringArray.Length == 0 ) {
                return null;
            } else {
                return stringArray;
            }
        }

        public static string MakeStringNull(string stringValue) {
            if ( stringValue == null || stringValue.Length == 0) {
                return null;
            } else {
                return stringValue;
            }
        }

        public static string MakeStringEmpty(string stringValue) {
            if ( stringValue == null || stringValue.Length == 0) {
                return String.Empty;
            } else {
                return stringValue;
            }
        }

        public static int HashCode(object objectValue) {
            if (objectValue == null) {
                return -1;
            } else {
                return objectValue.GetHashCode();
            }
        }
        public static string ToString(object objectValue) {
            if (objectValue == null) {
                return "(null)";
            } else if (objectValue is string && ((string)objectValue).Length==0) {
                return "(string.empty)";
            } else {
                return objectValue.ToString();
            }
        }
        public static string HashString(object objectValue) {
            if (objectValue == null) {
                return "(null)";
            } else if (objectValue is string && ((string)objectValue).Length==0) {
                return "(string.empty)";
            } else {
                return objectValue.GetHashCode().ToString();
            }
        }

        public static bool IsInvalidHttpString(string stringValue) {
            if (stringValue.IndexOfAny(InvalidParamChars) != -1) {
                return true; //  valid
            }

            return false;
        }

        public static bool IsBlankString(string stringValue) {
            if (stringValue == null || stringValue.Length == 0) {
                return true;
            } else {
                return false;
            }
        }

        public static bool ValidateUInt32(long address) {
            // on false, API should throw new ArgumentOutOfRangeException("address");
            return address>=0x00000000 && address<=0xFFFFFFFF;
        }

        public static bool ValidateTcpPort(int port) {
            // on false, API should throw new ArgumentOutOfRangeException("port");
            return port>=IPEndPoint.MinPort && port<=IPEndPoint.MaxPort;
        }

        public static bool ValidateRange(int actual, int fromAllowed, int toAllowed) {
            // on false, API should throw new ArgumentOutOfRangeException("argument");
            return actual>=fromAllowed && actual<=toAllowed;
        }

        public static bool ValidateRange(long actual, long fromAllowed, long toAllowed) {
            // on false, API should throw new ArgumentOutOfRangeException("argument");
            return actual>=fromAllowed && actual<=toAllowed;
        }

    }

    internal class ExceptionHelper {
        private static NotImplementedException methodNotImplementedException;
        public static NotImplementedException MethodNotImplementedException {
            get {
                if (methodNotImplementedException==null) {
                    methodNotImplementedException = new NotImplementedException(SR.GetString(SR.net_MethodNotImplementedException));
                }
                return methodNotImplementedException;
            }
        }
        private static NotImplementedException propertyNotImplementedException;
        public static NotImplementedException PropertyNotImplementedException {
            get {
                if (propertyNotImplementedException==null) {
                    propertyNotImplementedException = new NotImplementedException(SR.GetString(SR.net_PropertyNotImplementedException));
                }
                return propertyNotImplementedException;
            }
        }
        private static NotSupportedException methodNotSupportedException;
        public static NotSupportedException MethodNotSupportedException {
            get {
                if (methodNotSupportedException==null) {
                    methodNotSupportedException = new NotSupportedException(SR.GetString(SR.net_MethodNotSupportedException));
                }
                return methodNotSupportedException;
            }
        }
        private static NotSupportedException propertyNotSupportedException;
        public static NotSupportedException PropertyNotSupportedException {
            get {
                if (propertyNotSupportedException==null) {
                    propertyNotSupportedException = new NotSupportedException(SR.GetString(SR.net_PropertyNotSupportedException));
                }
                return propertyNotSupportedException;
            }
        }
    }


    // We need to keep track of orginal thread credentials to support
    // authentication delegation on other threads that could be involved in the http request.
    // Search for DELEGATION keyword to remove this fix once the Common Language Runtime will start including
    // Thread Token into their stack compression stuff.
    //
/*******
#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define TOKEN_ASSIGN_PRIMARY    (0x0001)
#define TOKEN_DUPLICATE         (0x0002)
#define TOKEN_IMPERSONATE       (0x0004)
#define TOKEN_QUERY             (0x0008)
#define TOKEN_QUERY_SOURCE      (0x0010)
#define TOKEN_ADJUST_PRIVILEGES (0x0020)
#define TOKEN_ADJUST_GROUPS     (0x0040)
#define TOKEN_ADJUST_DEFAULT    (0x0080)
#define TOKEN_ADJUST_SESSIONID  (0x0100)
*******/


    internal class DelegationFix {
        const   UInt32 ThreadTokenAllAccess  = 0x000F0000 | 0x01FF;
        static  readonly IntPtr m_CurrentThread = UnsafeNclNativeMethods.GetCurrentThread();
        IntPtr  m_Token = IntPtr.Zero;

        public DelegationFix() {
            /*
            Note: right now we request "ThreadTokenAllAccess" rights and "OpenAsSelf" = true.
            BUT that could be tuned if any test issue arise.
            According to Praerit Garg:
            TOKEN_IMPERSONATE should be enough.  Also, I believe OpenAsSelf should be FALSE so that you use the clients token to do the accesscheck to get a handle back to the token
            As long as you understand the delegation rules on all flavors of NT, you are fine
               It doesnt work on NT4 with any version of Domain.
               It works on Win2K w/ Win2K/Whistler Domain provided the server is trusted for delegation and you authenticated the client using kerb and you are doing backend auth using Kerb
               It works on Whistler w/ Whistler domain provided the server is trusted to delegate to a particular backend server using Kerb client could have authenticated any which way.
            */
            if (System.Net.Sockets.ComNetOS.IsWinNt) {
                UnsafeNclNativeMethods.OpenThreadToken(m_CurrentThread, ThreadTokenAllAccess, 1,  out m_Token);
                GlobalLog.Print("DELEGATION: Current Thread = " + m_CurrentThread.ToString());
            }
        }

        ~DelegationFix() {
            //If any chance httpWebRequest.CheckFinalStatus() was not called
            FreeToken();
        }

        public IntPtr Token {
            get {
                return m_Token;
            }
        }

        public void SetToken() {
            if (m_Token != IntPtr.Zero) {
                if (UnsafeNclNativeMethods.SetThreadToken(IntPtr.Zero, m_Token) == 0) {
                    throw new SystemException(SR.GetString(SR.net_set_token));
                }
            }
        }

        public void RevertToken() {
            if (m_Token != IntPtr.Zero) {
                if (UnsafeNclNativeMethods.RevertToSelf() == 0) {
                    throw new SystemException(SR.GetString(SR.net_revert_token));
                }
            }
        }

        public void FreeToken() {
            if (m_Token != IntPtr.Zero) {
                UnsafeNclNativeMethods.CloseHandle(m_Token);
                m_Token = IntPtr.Zero;
            }
        }
    }


    //
    // interface used by SecureChannel for validation
    //
    internal interface  ICertificateDecider {
        bool  Accept(X509Certificate Certificate, int CertificateProblem);

    }

    internal enum SecurityStatus {
        OK                  =   0x00000000,
        OutOfMemory         =   unchecked((int)0x80090300),
        InvalidHandle       =   unchecked((int)0x80090301),
        Unsupported         =   unchecked((int)0x80090302),
        TargetUnknown       =   unchecked((int)0x80090303),
        InternalError       =   unchecked((int)0x80090304),
        PackageNotFound     =   unchecked((int)0x80090305),
        NotOwner            =   unchecked((int)0x80090306),
        CannotInstall       =   unchecked((int)0x80090307),
        InvalidToken        =   unchecked((int)0x80090308),
        UnknownCredential   =   unchecked((int)0x8009030D),
        NoCredentials       =   unchecked((int)0x8009030E),
        MessageAltered      =   unchecked((int)0x8009030F),

        ContinueNeeded      =   unchecked((int)0x00090312),
        CompleteNeeded      =   unchecked((int)0x00090313),
        CompAndContinue     =   unchecked((int)0x00090314),
        ContextExpired      =   unchecked((int)0x00090317),
        IncompleteMessage   =   unchecked((int)0x80090318),
        IncompleteCred      =   unchecked((int)0x80090320),
        BufferNotEnough     =   unchecked((int)0x80090321),
        WrongPrincipal      =   unchecked((int)0x80090322),
        UntrustedRoot       =   unchecked((int)0x80090325),
        UnknownCertificate  =   unchecked((int)0x80090327),

        CredentialsNeeded   =   unchecked((int)0x00090320),
        Renegotiate         =   unchecked((int)0x00090321),
    }

    internal enum   ContentType {
        ChangeCipherSpec = 0x14,
        Alert            = 0x15,
        HandShake        = 0x16,
        AppData          = 0x17,
        Unrecognized     = 0xFF,
    }

    internal enum ContextAttribute {
        //
        // look into <sspi.h> and <schannel.h>
        //
        Sizes               = 0x00,
        Names               = 0x01,
        Lifespan            = 0x02,
        DceInfo             = 0x03,
        StreamSizes         = 0x04,
        Authority           = 0x06,
        KeyInfo             = 0x05,
        PackageInfo         = 0x0A,
        RemoteCertificate   = 0x53,
        LocalCertificate    = 0x54,
        RootStore           = 0x55,
        IssuerListInfoEx    = 0x59,
        ConnectionInfo      = 0x5A,
    }


    internal enum Endianness {
        Network = 0x00,
        Native  = 0x10,
    }

    internal enum CredentialUse {
        Inbound     = 0x1,
        Outgoing    = 0x2,
        Both        = 0x3,
    }

    internal enum BufferType {
        Empty       = 0x00,
        Data        = 0x01,
        Token       = 0x02,
        Parameters  = 0x03,
        Missing     = 0x04,
        Extra       = 0x05,
        Trailer     = 0x06,
        Header      = 0x07,
    }

    internal enum ChainPolicyType {
        Base                = 1,
        Authenticode        = 2,
        Authenticode_TS     = 3,
        SSL                 = 4,
        BasicConstraints    = 5,
        NtAuth              = 6,
    }

    internal enum IgnoreCertProblem {
        not_time_valid              = 0x00000001,
        ctl_not_time_valid          = 0x00000002,
        not_time_nested             = 0x00000004,
        invalid_basic_constraints   = 0x00000008,

        all_not_time_valid          =
            not_time_valid          |
            ctl_not_time_valid      |
            not_time_nested,

        allow_unknown_ca            = 0x00000010,
        wrong_usage                 = 0x00000020,
        invalid_name                = 0x00000040,
        invalid_policy              = 0x00000080,
        end_rev_unknown             = 0x00000100,
        ctl_signer_rev_unknown      = 0x00000200,
        ca_rev_unknown              = 0x00000400,
        root_rev_unknown            = 0x00000800,

        all_rev_unknown             =
            end_rev_unknown         |
            ctl_signer_rev_unknown  |
            ca_rev_unknown          |
            root_rev_unknown,
    }

    internal enum CertUsage {
        MatchTypeAnd    = 0x00,
        MatchTypeOr     = 0x01,
    }

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct ChainPolicyParameter {
        public uint cbSize;
        public uint dwFlags;
        public IntPtr pvExtraPolicyPara;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct ExtraPolicyParameter 
    {
        public uint cbSize;        
        public uint dwAuthType;
        //#                       define      AUTHTYPE_CLIENT         1
        //#                       define      AUTHTYPE_SERVER         2
        public uint fdwChecks;
        public IntPtr pwszServerName; // used to check against CN=xxxx
    }

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct ChainPolicyStatus {
        public uint cbSize;
        public uint dwError;
        public uint lChainIndex;
        public uint lElementIndex;
        public int pvExtraPolicyStatus;
    }

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct CertEnhKeyUse {

        public uint cUsageIdentifier;
        public uint rgpszUsageIdentifier;

        public CertEnhKeyUse(uint uid, uint usgstr) {
            cUsageIdentifier = uid;
            rgpszUsageIdentifier = usgstr;
        }
#if TRAVE
        public override string ToString() {
            return "cUsageIdentifier="+cUsageIdentifier.ToString()+" rgpszUsageIdentifier="+rgpszUsageIdentifier.ToString();
        }
#endif
    };

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct CertUsageMatch {
        public uint dwType;
        public CertEnhKeyUse Usage;
#if TRAVE
        public override string ToString() {
            return "dwType="+dwType.ToString()+" "+Usage.ToString();
        }
#endif
    };

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct ChainParameters {
        public uint cbSize;
        public CertUsageMatch requestedUsage;
#if TRAVE
        public override string ToString() {
            return "cbSize="+cbSize.ToString()+" "+requestedUsage.ToString();
        }
#endif
    };


    internal class SecurityModInfo {

        public int      Capabilities;
        public short    Version;
        public short    RPCID;
        public int      MaxToken;
        public string   Name;
        public string   Comment;

        // construct the object given raw pointer to memory

        public SecurityModInfo(IntPtr ptr) {

            Capabilities    = Marshal.ReadInt32(ptr);
            Version         = Marshal.ReadInt16(IntPtrHelper.Add(ptr,4));
            RPCID           = Marshal.ReadInt16(IntPtrHelper.Add(ptr,6));
            MaxToken        = Marshal.ReadInt32(IntPtrHelper.Add(ptr,8));

            if ( ComNetOS.IsWin9x ) {
                Name            = Marshal.PtrToStringAnsi(Marshal.ReadIntPtr(IntPtrHelper.Add(ptr,12)));
                Comment         = Marshal.PtrToStringAnsi(Marshal.ReadIntPtr(IntPtrHelper.Add(ptr,12+IntPtr.Size)));
            } else {
                Name            = Marshal.PtrToStringUni(Marshal.ReadIntPtr(IntPtrHelper.Add(ptr,12)));
                Comment         = Marshal.PtrToStringUni(Marshal.ReadIntPtr(IntPtrHelper.Add(ptr,12+IntPtr.Size)));
            }
        }
    }

    internal class CertificateContextHandle {

        public IntPtr Handle = (IntPtr)0;

        internal CertificateContextHandle(IntPtr handle) {
            Handle = handle;
        }

        ~CertificateContextHandle() {
            if (Handle != (IntPtr)0) {
                UnsafeNclNativeMethods.NativePKI.CertFreeCertificateContext(Handle);
                Handle = (IntPtr)0;
            }
        }
    }

    internal class SecurityContext {
        public long Handle = -1;
        public long TimeStamp = 0;
        // CONSIDER V.NEXT
        // go back to private and implement explicit Dispose() pattern.
        private SSPIInterface m_SecModule;

        internal SecurityContext(SSPIInterface SecModule) {
            m_SecModule = SecModule;
        }

        ~SecurityContext() {
            Close();
        }
        internal void Close() {
            if (Handle != -1) {
                SSPIWrapper.DeleteSecurityContext(m_SecModule, Handle);
                Handle = -1;
            }
        }

    } // class SecurityContext

    internal class CredentialsHandle {

        public long Handle = -1;
        public long TimeStamp = 0;

        private SSPIInterface m_SecModule;

        internal CredentialsHandle(SSPIInterface SecModule) {
            m_SecModule = SecModule;
        }
        ~CredentialsHandle() {
            if (Handle != -1) {
                SSPIWrapper.FreeCredentialsHandle(m_SecModule, Handle);
                Handle = -1;
            }
        }

    } // class CredentialsHandle

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct CryptoBlob {
/*
typedef struct _CRYPTOAPI_BLOB {
  DWORD    cbData;
  BYTE*    pbData;
} CERT_NAME_BLOB, *PCERT_NAME_BLOB,
*/
        public int    dataSize;
        public IntPtr dataBlob;
    }

    // NOTE: manually marshalled
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal class IssuerListInfoEx {
/*
typedef struct _SecPkgContext_IssuerListInfoEx
{
    PCERT_NAME_BLOB     aIssuers;
    DWORD               cIssuers;
} SecPkgContext_IssuerListInfoEx, *PSecPkgContext_IssuerListInfoEx;
*/

        public IntPtr issuerArray;
        public int    issuerCount;

    }


    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal class CertChainFindByIssuer {
/*
typedef struct _CERT_CHAIN_FIND_BY_ISSUER_PARA {
    DWORD                                   cbSize;

    // If pszUsageIdentifier == NULL, matches any usage.
    LPCSTR                                  pszUsageIdentifier;

    // If dwKeySpec == 0, matches any KeySpec
    DWORD                                   dwKeySpec;

    // When CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG is set in dwFindFlags,
    // CryptAcquireCertificatePrivateKey is called to do the public key
    // comparison. The following flags can be set to enable caching
    // of the acquired private key. See the API for more details on these
    // flags.
    DWORD                                   dwAcquirePrivateKeyFlags;

    // Pointer to an array of X509, ASN.1 encoded issuer name blobs. If
    // cIssuer == 0, matches any issuer
    DWORD                                   cIssuer;
    CERT_NAME_BLOB                          *rgIssuer;

    // If NULL or Callback returns TRUE, builds the chain for the end
    // certificate having a private key with the specified KeySpec and
    // enhanced key usage.
    PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK pfnFindCallback;
    void                                    *pvFindArg;
} CERT_CHAIN_FIND_BY_ISSUER_PARA, *PCERT_CHAIN_FIND_ISSUER_PARA;
*/
        public int          size;

        //Must be ANSI for CAPI, and it's safe as only internal constants goes there (BestFitMapping sec issue)
        [MarshalAs(UnmanagedType.LPStr)]
        public string       usageIdentifier;

        public int          keySpec;
        public int          acquirePrivateKeyFlags;

        public int          issuerCount;
        public IntPtr       issuerArray;

        public IntPtr       findCallback; // not used
        public IntPtr       findArgument; // not used

        public CertChainFindByIssuer(int foo) {
            this.size            = Marshal.SizeOf(typeof(CertChainFindByIssuer));
            // Consistent key usage bits: DIGITAL_SIGNATURE
            // from:wincrypt.h #define szOID_PKIX_KP_CLIENT_AUTH       "1.3.6.1.5.5.7.3.2"
            this.usageIdentifier = "1.3.6.1.5.5.7.3.2";
        }
    }


    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct SChannelCred {

/*
typedef struct _SCHANNEL_CRED
{
    DWORD           dwVersion;      // always SCHANNEL_CRED_VERSION
    DWORD           cCreds;
    PCCERT_CONTEXT *paCred;
    HCERTSTORE      hRootStore;

    DWORD           cMappers;
    struct _HMAPPER **aphMappers;

    DWORD           cSupportedAlgs;
    ALG_ID *        palgSupportedAlgs;

    DWORD           grbitEnabledProtocols;
    DWORD           dwMinimumCipherStrength;
    DWORD           dwMaximumCipherStrength;
    DWORD           dwSessionLifespan;
    DWORD           dwFlags;
    DWORD           reserved;
} SCHANNEL_CRED, *PSCHANNEL_CRED;
*/

        public static int CurrentVersion = 0x4;

        public int version;
        public int cCreds;

        // ptr to an array of pointers
        public IntPtr certContextArray;

        public IntPtr rootStore;
        public int cMappers;
        public IntPtr phMappers;
        public int cSupportedAlgs;
        public IntPtr palgSupportedAlgs;
        public int grbitEnabledProtocols;
        public int dwMinimumCipherStrength;
        public int dwMaximumCipherStrength;
        public int dwSessionLifespan;
        public int dwFlags;
        public int reserved;

        [Flags]
        public enum Flags {
            NoSystemMapper = 0x02,
            NoNameCheck = 0x04,
            ValidateManual = 0x08,
            NoDefaultCred = 0x10,
            ValidateAuto = 0x20
        }

        public enum Protocols {
            SP_PROT_SSL2_CLIENT = (int)0x00000008,
            SP_PROT_SSL3_CLIENT = (int)0x00000020,
            SP_PROT_TLS1_CLIENT = (int)0x00000080,
            SP_PROT_SSL3TLS1_CLIENTS = (SP_PROT_TLS1_CLIENT | SP_PROT_SSL3_CLIENT),
            SP_PROT_UNI_CLIENT = unchecked((int)0x80000000)
        }

        public SChannelCred(int version) {
            this.version = version;
            certContextArray = IntPtr.Zero;
            rootStore = phMappers = palgSupportedAlgs = IntPtr.Zero;
            cCreds = cMappers = cSupportedAlgs = 0;
            grbitEnabledProtocols = 0;
            dwMinimumCipherStrength = dwMaximumCipherStrength = 0;
            dwSessionLifespan = dwFlags = reserved = 0;
        }

        [System.Diagnostics.Conditional("TRAVE")]
        internal void DebugDump() {
            GlobalLog.Print("SChannelCred #"+GetHashCode());
            GlobalLog.Print("    version                 = " + version);
            GlobalLog.Print("    cCreds                  = " + cCreds);
            GlobalLog.Print("    certContextArray        = " + String.Format("0x{0:x}", certContextArray));
            GlobalLog.Print("    rootStore               = " + String.Format("0x{0:x}", rootStore));
            GlobalLog.Print("    cMappers                = " + cMappers);
            GlobalLog.Print("    phMappers               = " + String.Format("0x{0:x}", phMappers));
            GlobalLog.Print("    cSupportedAlgs          = " + cSupportedAlgs);
            GlobalLog.Print("    palgSupportedAlgs       = " + String.Format("0x{0:x}", palgSupportedAlgs));
            GlobalLog.Print("    grbitEnabledProtocols   = " + String.Format("0x{0:x}", grbitEnabledProtocols));
            GlobalLog.Print("    dwMinimumCipherStrength = " + dwMinimumCipherStrength);
            GlobalLog.Print("    dwMaximumCipherStrength = " + dwMaximumCipherStrength);
            GlobalLog.Print("    dwSessionLifespan       = " + String.Format("0x{0:x}", dwSessionLifespan));
            GlobalLog.Print("    dwFlags                 = " + String.Format("0x{0:x}", dwFlags));
            GlobalLog.Print("    reserved                = " + String.Format("0x{0:x}", reserved));
        }
    } // SChannelCred

    internal class SecurityBufferClass {
        public int offset;
        public int size;
        public int type;
        public byte[] token;

        public SecurityBufferClass(byte[] data, int offset, int size, BufferType tokentype) {
            this.offset = offset;
            this.size   = (data == null) ? 0 : size;
            this.type   = (int)tokentype;
            this.token  = data;
        }

        public SecurityBufferClass(byte[] data, BufferType tokentype) {
            this.size   = (data == null) ? 0 : data.Length;
            this.type   = (int)tokentype;
            this.token  = data;
        }

        public SecurityBufferClass(int size, BufferType tokentype) {
            this.size   = size;
            this.type   = (int)tokentype;
            this.token  = (size == 0) ? null : new byte[size];
        }

        public SecurityBufferClass(int size, int tokentype) {
            this.size   = size;
            this.type   = tokentype;
            this.token  = (size==0) ? null : new byte[size];
        }

        public SecurityBufferClass(IntPtr unmanagedAddress) {
            this.size = Marshal.ReadInt32(unmanagedAddress);
            this.type = Marshal.ReadInt32(unmanagedAddress, 4);
            if (this.size > 0) {
                this.token = new byte[size];

                IntPtr voidptr = Marshal.ReadIntPtr(unmanagedAddress, 8);
                Marshal.Copy(voidptr, this.token, 0, this.size);
            }
            else {
                this.token = null;
            }

            GlobalLog.Print("Security Buffer dump: size:" + size.ToString() + " type:" + type.ToString() + " from addr:" + ((long)unmanagedAddress).ToString());
            GlobalLog.Dump(token, 128);
        }

        //
        // Write out unmanaged copy of the security buffer to the given address
        // The second parameter indicates whether to allocated space or use the
        // same allocation as the original security buffer **not implemented**
        //
        internal void unmanagedCopy(IntPtr unmanagedAddress) {

            IntPtr arrayBase;

            if (token == null) {
                arrayBase = IntPtr.Zero;
            }
            else {
                arrayBase = Marshal.UnsafeAddrOfPinnedArrayElement(token, offset);
            }
            Marshal.WriteInt32(unmanagedAddress,  0, size);
            Marshal.WriteInt32(unmanagedAddress,  4, type);
            Marshal.WriteIntPtr(unmanagedAddress, 8, arrayBase);
        }

        [System.Diagnostics.Conditional("TRAVE")]
        internal void DebugDump() {
#if TRAVE
            GlobalLog.Print("SecurityBufferClass #"+GetHashCode());
            GlobalLog.Print("    offset = " + String.Format("0x{0:x}", offset));
            GlobalLog.Print("    size   = " + size);
            GlobalLog.Print("    type   = " + String.Format("0x{0:x}", type) + " [" + MapSecBufferType(type) + "]");
            GlobalLog.Print("    token:");
            GlobalLog.Dump(token, 128);
        }

        internal string MapSecBufferType(int type) {

            string result = ((type & 0x80000000) == 0) ? "" : "SECBUFFER_READONLY ";
            type &= 0x0FFFFFFF;

            //
            // these #s from recent (March 2001) sspi.h
            //

            switch (type) {
            case 0: result += "SECBUFFER_EMPTY"; break;
            case 1: result += "SECBUFFER_DATA"; break;
            case 2: result += "SECBUFFER_TOKEN"; break;
            case 3: result += "SECBUFFER_PKG_PARAMS"; break;
            case 4: result += "SECBUFFER_MISSING"; break;
            case 5: result += "SECBUFFER_EXTRA"; break;
            case 6: result += "SECBUFFER_STREAM_TRAILER"; break;
            case 7: result += "SECBUFFER_STREAM_HEADER"; break;
            case 8: result += "SECBUFFER_NEGOTIATION_INFO"; break;
            case 9: result += "SECBUFFER_PADDING"; break;
            case 10: result += "SECBUFFER_STREAM"; break;
            case 11: result += "SECBUFFER_MECHLIST"; break;
            case 12: result += "SECBUFFER_MECHLIST_SIGNATURE"; break;
            case 13: result += "SECBUFFER_TARGET"; break;
            case 14: result += "SECBUFFER_CHANNEL_BINDINGS"; break;
            default: result += "?"; break;
            }
            return result;
#endif
        }
    } // SecurityBufferClass

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct SecurityBuffer{
/*
typedef struct _SecBuffer {
    ULONG        cbBuffer;
    ULONG        BufferType;
    PVOID        pvBuffer;
} SecBuffer, *PSecBuffer;
*/
        public int count;
        public int type;
        public IntPtr buffer;

        public static readonly int Size = Marshal.SizeOf(typeof(SecurityBuffer));
    }

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct SecurityBufferDescriptor {
/*
typedef struct _SecBufferDesc {
    ULONG        ulVersion;
    ULONG        cBuffers;
    PSecBuffer   pBuffers;
} SecBufferDesc, * PSecBufferDesc;
*/
        public int version;
        public int count;
        public IntPtr securityBufferArray;

        public static readonly int Size = Marshal.SizeOf(typeof(SecurityBufferDescriptor));

        public SecurityBufferDescriptor(int bufferCount) {
            GlobalLog.Print("SecurityBufferDescriptor - cnt");
            version = 0;
            count = bufferCount;
            securityBufferArray = Marshal.AllocHGlobal((IntPtr) (8 + SecurityBuffer.Size * count));
        }


        //
        // SecurityBufferDescriptor - constructor for an array of
        //   Buffered objects, assumes they are already pinned
        //
        public SecurityBufferDescriptor(SecurityBufferClass[] buffers) {
            GlobalLog.Print("SecurityBufferDescriptor - buffers[]");
            count = buffers.Length;
            version = 0;
            securityBufferArray = Marshal.AllocHGlobal((IntPtr) (SecurityBuffer.Size * count));
            for (int k = 0; k < count; k++) {
                buffers[k].DebugDump();
                buffers[k].unmanagedCopy(IntPtrHelper.Add(securityBufferArray,SecurityBuffer.Size * k));
            }
        }

        public SecurityBufferDescriptor(SecurityBufferClass singleBuffer) {
            GlobalLog.Print("SecurityBufferDescriptor - singleBuffer");
            version = 0;
            count = 1;
            securityBufferArray = Marshal.AllocHGlobal((IntPtr) SecurityBuffer.Size);
            singleBuffer.unmanagedCopy(securityBufferArray);
            singleBuffer.DebugDump();
        }

        public SecurityBufferClass[] marshall() {
            GlobalLog.Print("SecurityBufferDescriptor.marshall");
            SecurityBufferClass[] buffers = new SecurityBufferClass[count];
            for (int k = 0; k < count; k++) {
                buffers[k] = new SecurityBufferClass(IntPtrHelper.Add(securityBufferArray, SecurityBuffer.Size * k));
            }
            return buffers;
        }

        //
        // FreeAllBuffers - called to clean up unsafe SSPI buffers used to marshall
        //
        public void FreeAllBuffers(int flags) {
                        GlobalLog.Print("FreeAllBuffers: count:" + count.ToString() );

            bool fFreeSSPIBuffer = (flags & (int)ContextFlags.AllocateMemory) != 0 ? true : false;

            if (securityBufferArray != IntPtr.Zero) {
                for (int k = 0; k < count; k++) {

                    IntPtr secBufferPtr = IntPtrHelper.Add(securityBufferArray, SecurityBuffer.Size * k);
                    IntPtr arrayBase = Marshal.ReadIntPtr(secBufferPtr, 8);


                    if (arrayBase != IntPtr.Zero) {
                        // only free, if they were allocated by SSPI, otherwise,
                        //  this is taken care of later on by FreeGCHandles,
                        //  which is done late by the marshalling code, that
                        //  calls out in the SSPI Wrapper code.
                        if ( fFreeSSPIBuffer) {
                            if (ComNetOS.IsWin9x) {
                                UnsafeNclNativeMethods.NativeAuthWin9xSSPI.FreeContextBuffer(arrayBase);
                            } else {
                                UnsafeNclNativeMethods.NativeNTSSPI.FreeContextBuffer(arrayBase);
                            }
                        }
                    }
                }

                Marshal.FreeHGlobal(securityBufferArray);
                securityBufferArray = IntPtr.Zero;

            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public void dump() {
            Console.WriteLine("Security Buffer Description");
            Console.WriteLine("Count: " + count);
            Console.WriteLine("Pointer to array of buffers: " + securityBufferArray);
        }

        [System.Diagnostics.Conditional("TRAVE")]
        internal void DebugDump() {
            GlobalLog.Print("SecurityBufferDescriptor #" + GetHashCode());
            GlobalLog.Print("    version             = " + version);
            GlobalLog.Print("    count               = " + count);
            GlobalLog.Print("    securityBufferArray = " + String.Format("0x{0:x}", securityBufferArray));
        }
    } // SecurityBufferDescriptor

    internal  enum    CertificateEncoding {
        CryptAsnEncoding         = unchecked((int)0x00000001),
        CryptNdrEncoding         = unchecked((int)0x00000002),
        X509AsnEncoding          = unchecked((int)0x00000001),
        X509NdrEncoding          = unchecked((int)0x00000002),
        Pkcs7AsnEncoding         = unchecked((int)0x00010000),
        Pkcs7NdrEncoding         = unchecked((int)0x00020000),
    }


    internal  enum    CertificateProblem {
        OK                          =   0x00000000,
        TrustNOSIGNATURE            = unchecked((int)0x800B0100),
        CertEXPIRED                 = unchecked((int)0x800B0101),
        CertVALIDITYPERIODNESTING   = unchecked((int)0x800B0102),
        CertROLE                    = unchecked((int)0x800B0103),
        CertPATHLENCONST            = unchecked((int)0x800B0104),
        CertCRITICAL                = unchecked((int)0x800B0105),
        CertPURPOSE                 = unchecked((int)0x800B0106),
        CertISSUERCHAINING          = unchecked((int)0x800B0107),
        CertMALFORMED               = unchecked((int)0x800B0108),
        CertUNTRUSTEDROOT           = unchecked((int)0x800B0109),
        CertCHAINING                = unchecked((int)0x800B010A),
        CertREVOKED                 = unchecked((int)0x800B010C),
        CertUNTRUSTEDTESTROOT       = unchecked((int)0x800B010D),
        CertREVOCATION_FAILURE      = unchecked((int)0x800B010E),
        CertCN_NO_MATCH             = unchecked((int)0x800B010F),
        CertWRONG_USAGE             = unchecked((int)0x800B0110),
        TrustEXPLICITDISTRUST       = unchecked((int)0x800B0111),
        CertUNTRUSTEDCA             = unchecked((int)0x800B0112),
        CertINVALIDPOLICY           = unchecked((int)0x800B0113),
        CertINVALIDNAME             = unchecked((int)0x800B0114),

        CryptNOREVOCATIONCHECK       = unchecked((int)0x80092012),
        CryptREVOCATIONOFFLINE       = unchecked((int)0x80092013),

        TrustSYSTEMERROR            = unchecked((int)0x80096001),
        TrustNOSIGNERCERT           = unchecked((int)0x80096002),
        TrustCOUNTERSIGNER          = unchecked((int)0x80096003),
        TrustCERTSIGNATURE          = unchecked((int)0x80096004),
        TrustTIMESTAMP              = unchecked((int)0x80096005),
        TrustBADDIGEST              = unchecked((int)0x80096010),
        TrustBASICCONSTRAINTS       = unchecked((int)0x80096019),
        TrustFINANCIALCRITERIA      = unchecked((int)0x8009601E),  
    }

    //
    // WebRequestPrefixElement
    //
    // This is an element of the prefix list. It contains the prefix and the
    // interface to be called to create a request for that prefix.
    //

    /// <include file='doc\Internal.uex' path='docs/doc[@for="WebRequestPrefixElement"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    // internal class WebRequestPrefixElement {
    internal class WebRequestPrefixElement  {

        /// <include file='doc\Internal.uex' path='docs/doc[@for="WebRequestPrefixElement.Prefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    string              Prefix;
        /// <include file='doc\Internal.uex' path='docs/doc[@for="WebRequestPrefixElement.Creator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    IWebRequestCreate   Creator;

        /// <include file='doc\Internal.uex' path='docs/doc[@for="WebRequestPrefixElement.WebRequestPrefixElement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebRequestPrefixElement(string P, IWebRequestCreate C) {
            Prefix = P;
            Creator = C;
        }

    } // class PrefixListElement


    //
    // HttpRequestCreator.
    //
    // This is the class that we use to create HTTP and HTTPS requests.
    //

    internal class HttpRequestCreator : IWebRequestCreate {

        internal HttpRequestCreator() {
        }

        /*++

         Create - Create an HttpWebRequest.

            This is our method to create an HttpWebRequest. We register
            for HTTP and HTTPS Uris, and this method is called when a request
            needs to be created for one of those.


            Input:
                    Uri             - Uri for request being created.

            Returns:
                    The newly created HttpWebRequest.

         --*/

        public WebRequest Create( Uri Uri ) {

            //
            //Note, DNS permissions check will not happen on WebRequest
            //
            (new WebPermission(NetworkAccess.Connect, Uri.AbsoluteUri)).Demand();
            return new HttpWebRequest(Uri);
        }

    } // class HttpRequestCreator

    //
    //  CoreResponseData - Used to store result of HTTP header parsing and
    //      response parsing.  Also Contains new stream to use, and
    //      is used as core of new Response
    //
    internal class CoreResponseData {

        // Status Line Response Values
        public HttpStatusCode m_StatusCode;
        public string m_StatusDescription;
        public Version m_Version;

        // Content Length needed for semantics, -1 if chunked
        public long m_ContentLength;

        // Response Headers
        public WebHeaderCollection m_ResponseHeaders;

        // ConnectStream - for reading actual data
        public ConnectStream m_ConnectStream;
    }


    /*++

    StreamChunkBytes - A class to read a chunk stream from a ConnectStream.

    A simple little value class that implements the IReadChunkBytes
    interface.

    --*/
    internal class StreamChunkBytes : IReadChunkBytes {

        public  ConnectStream   ChunkStream;
        public  int             BytesRead = 0;
        public  int             TotalBytesRead = 0;
        private byte            PushByte;
        private bool            HavePush;

        public StreamChunkBytes(ConnectStream connectStream) {
            ChunkStream = connectStream;
            return;
        }

        public int NextByte {
            get {
                if (HavePush) {
                    HavePush = false;
                    return PushByte;
                }

                return ChunkStream.ReadSingleByte();
            }
            set {
                PushByte = (byte)value;
                HavePush = true;
            }
        }

    } // class StreamChunkBytes

    // Delegate type for a SubmitRequestDelegate.

    internal delegate void HttpSubmitDelegate(ConnectStream SubmitStream, WebExceptionStatus Status);

    // internal delegate bool HttpHeadersDelegate();

    internal delegate void HttpAbortDelegate();

    //
    // this class contains known header names
    //

    internal class HttpKnownHeaderNames {

        public const string CacheControl = "Cache-Control";
        public const string Connection = "Connection";
        public const string Date = "Date";
        public const string KeepAlive = "Keep-Alive";
        public const string Pragma = "Pragma";
        public const string ProxyConnection = "Proxy-Connection";
        public const string Trailer = "Trailer";
        public const string TransferEncoding = "Transfer-Encoding";
        public const string Upgrade = "Upgrade";
        public const string Via = "Via";
        public const string Warning = "Warning";
        public const string ContentLength = "Content-Length";
        public const string ContentType = "Content-Type";
        public const string ContentEncoding = "Content-Encoding";
        public const string ContentLanguage = "Content-Language";
        public const string ContentLocation = "Content-Location";
        public const string ContentRange = "Content-Range";
        public const string Expires = "Expires";
        public const string LastModified = "Last-Modified";
        public const string Age = "Age";
        public const string Location = "Location";
        public const string ProxyAuthenticate = "Proxy-Authenticate";
        public const string RetryAfter = "Retry-After";
        public const string Server = "Server";
        public const string SetCookie = "Set-Cookie";
        public const string SetCookie2 = "Set-Cookie2";
        public const string Vary = "Vary";
        public const string WWWAuthenticate = "WWW-Authenticate";
        public const string Accept = "Accept";
        public const string AcceptCharset = "Accept-Charset";
        public const string AcceptEncoding = "Accept-Encoding";
        public const string AcceptLanguage = "Accept-Language";
        public const string Authorization = "Authorization";
        public const string Cookie = "Cookie";
        public const string Cookie2 = "Cookie2";
        public const string Expect = "Expect";
        public const string From = "From";
        public const string Host = "Host";
        public const string IfMatch = "If-Match";
        public const string IfModifiedSince = "If-Modified-Since";
        public const string IfNoneMatch = "If-None-Match";
        public const string IfRange = "If-Range";
        public const string IfUnmodifiedSince = "If-Unmodified-Since";
        public const string MaxForwards = "Max-Forwards";
        public const string ProxyAuthorization = "Proxy-Authorization";
        public const string Referer = "Referer";
        public const string Range = "Range";
        public const string UserAgent = "User-Agent";
        public const string ContentMD5 = "Content-MD5";
        public const string ETag = "ETag";
        public const string TE = "TE";
        public const string Allow = "Allow";
        public const string AcceptRanges = "Accept-Ranges";
    }

    /// <include file='doc\Internal.uex' path='docs/doc[@for="HttpContinueDelegate"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will notify callers when a continue has been
    ///       received by the client.
    ///    </para>
    /// </devdoc>
    // Delegate type for us to notify callers when we receive a continue
    public delegate void HttpContinueDelegate(int StatusCode, WebHeaderCollection httpHeaders);

    //
    // HttpWriteMode - used to control the way in which an entity Body is posted.
    //
    internal enum HttpWriteMode {
        None    = 0,
        Chunked = 1,
        Write   = 2,
    }

    internal enum HttpProcessingResult {
        Continue  = 0,
        ReadWait  = 1,
        WriteWait = 2,
    }

    //
    // HttpVerb - used to define various per Verb Properties
    //

    //
    // Note - this is a place holder for Verb properties,
    //  the following two bools can most likely be combined into
    //  a single Enum type.  And the Verb can be incorporated.
    //

    internal class HttpVerb {

        internal bool m_RequireContentBody; // require content body to be sent
        internal bool m_ContentBodyNotAllowed; // not allowed to send content body
        internal bool m_ConnectRequest; // special semantics for a connect request
        internal bool m_ExpectNoContentResponse; // response will not have content body

        internal HttpVerb(bool RequireContentBody, bool ContentBodyNotAllowed, bool ConnectRequest, bool ExpectNoContentResponse) {

            m_RequireContentBody = RequireContentBody;
            m_ContentBodyNotAllowed = ContentBodyNotAllowed;
            m_ConnectRequest = ConnectRequest;
            m_ExpectNoContentResponse = ExpectNoContentResponse;
        }
    }


    //
    // KnownVerbs - Known Verbs are verbs that require special handling
    //

    internal class KnownVerbs {

        // Force an an init, before we use them
        private static ListDictionary namedHeaders = InitializeKnownVerbs();

        // default verb, contains default properties for an unidentifable verb.
        private static HttpVerb DefaultVerb;

        //
        // InitializeKnownVerbs - Does basic init for this object,
        //  such as creating defaultings and filling them
        //
        private static ListDictionary InitializeKnownVerbs() {

            namedHeaders = new ListDictionary(CaseInsensitiveString.StaticInstance);

            namedHeaders["GET"] = new HttpVerb(false, true, false, false);
            namedHeaders["CONNECT"] = new HttpVerb(false, true, true, false);
            namedHeaders["HEAD"] = new HttpVerb(false, true, false, true);
            namedHeaders["POST"] = new HttpVerb(true, false, false, false);
            namedHeaders["PUT"] = new HttpVerb(true, false, false, false);

            // default Verb
            KnownVerbs.DefaultVerb = new HttpVerb(false, false, false, false);

            return namedHeaders;
        }

        internal static HttpVerb GetHttpVerbType(String name) {

            HttpVerb obj = (HttpVerb)KnownVerbs.namedHeaders[name];

            return obj != null ? obj : KnownVerbs.DefaultVerb;
        }
    }


    //
    // HttpProtocolUtils - A collection of utility functions for HTTP usage.
    //

    internal class HttpProtocolUtils {


        private HttpProtocolUtils() {
        }

        //
        // extra buffers for build/parsing, recv/send HTTP data,
        //  at some point we should consolidate
        //


        // parse String to DateTime format.
        internal static DateTime
        string2date(String S) {
            DateTime dtOut;

            if (HttpDateParse.ParseHttpDate(
                                           S,
                                           out dtOut)) {
                return dtOut;
            }
            else {
                throw new ProtocolViolationException(SR.GetString(SR.net_baddate));
            }

        }

        // convert Date to String using RFC 1123 pattern
        internal static string
        date2string(DateTime D) {
            DateTimeFormatInfo dateFormat = new DateTimeFormatInfo();
            return D.ToUniversalTime().ToString("R", dateFormat);
        }
    }

    // Proxy class for linking between ICertificatePolicy <--> ICertificateDecider
    internal class  PolicyWrapper : ICertificateDecider {
        public PolicyWrapper(ICertificatePolicy policy, ServicePoint sp, WebRequest wr) {
            this.fwdPolicy = policy;
            srvPoint = sp;
            request = wr;
        }

        public bool    Accept(X509Certificate Certificate, int CertificateProblem) {
            return fwdPolicy.CheckValidationResult(srvPoint, Certificate, request, CertificateProblem);
        }

        private ICertificatePolicy  fwdPolicy;
        private ServicePoint        srvPoint;
        private WebRequest          request;
    }


    // Class implementing default certificate policy
    internal class DefaultCertPolicy : ICertificatePolicy {
        public bool CheckValidationResult(ServicePoint sp, X509Certificate cert, WebRequest request, int problem) {
            if (problem== (int) CertificateProblem.OK)
                return true;
            else
                return false;
        }
    }

    internal enum TriState {
        Unknown = -1,
        No = 0,
        Yes = 1
    }

    internal enum DefaultPorts {
        DEFAULT_FTP_PORT = 21,
        DEFAULT_GOPHER_PORT = 70,
        DEFAULT_HTTP_PORT = 80,
        DEFAULT_HTTPS_PORT = 443,
        DEFAULT_NNTP_PORT = 119,
        DEFAULT_SMTP_PORT = 25,
        DEFAULT_TELNET_PORT = 23
    }

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct hostent {
        public IntPtr   h_name;
        public IntPtr   h_aliases;
        public short    h_addrtype;
        public short    h_length;
        public IntPtr   h_addr_list;
    }


    [StructLayout(LayoutKind.Sequential)]
    internal struct Blob {
        public int cbSize;
        public int pBlobData;
    }

#if COMNET_LISTENER

    internal class UlConstants {

        internal const int InitialBufferSize = 4096;

        // form $(IISBASEDIR)\inc\uldef.h

        internal const int UL_OPTION_OVERLAPPED = 1;
        internal const int UL_OPTION_VALID = 1;

        internal const int UL_RECEIVE_REQUEST_FLAG_COPY_BODY = 1;
        internal const int UL_RECEIVE_REQUEST_FLAG_FLUSH_BODY = 2;
        internal const int UL_RECEIVE_REQUEST_FLAG_VALID = 3;

        internal const int UL_SEND_RESPONSE_FLAG_DISCONNECT = 1;
        internal const int UL_SEND_RESPONSE_FLAG_MORE_DATA = 2;
        internal const int UL_SEND_RESPONSE_FLAG_VALID = 3;

    } // Constants


    //
    // layout of the UL_HTTP_REQUEST structure passed along by ul.vxd/sys
    // after all the headers of a request was read from the sockets
    // the native UL_HTTP_REQUEST structure definition is to be found in:
    // $(IISABASEDIR)\inc\uldef.h
    //

    [StructLayout(LayoutKind.Sequential)]
    internal struct UL_HTTP_RESPONSE {
        internal short Flags;
        internal short StatusCode;
        internal int ReasonLength;
        internal IntPtr pReason;
        internal int UnknownHeaderCount;
        internal IntPtr pUnknownHeaders;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=60)]
        internal int[] LengthValue;

    } // UL_HTTP_RESPONSE



    [StructLayout(LayoutKind.Sequential)]
    internal struct UL_HTTP_REQUEST {
        internal long ConnectionId;
        internal long RequestId;
        internal long UriContext;
        internal int Version;
        internal int Verb;
        internal int Reason;
        internal short UnknownVerbLength;
        internal short RawUriLength;
        internal IntPtr pUnknownVerb;
        internal IntPtr pRawUri;
        internal short FullUriLength;
        internal short HostLength;
        internal short AbsPathLength;
        internal short QueryStringLength;
        internal IntPtr pFullUri;
        internal IntPtr pHost;
        internal IntPtr pAbsPath;
        internal IntPtr pQueryString;
        internal short RemoteAddressLength;
        internal short RemoteAddressType;
        internal short LocalAddressLength;
        internal short LocalAddressType;
        internal IntPtr pRemoteAddress;
        internal IntPtr pLocalAddress;
        internal int UnknownHeaderCount;
        internal IntPtr pUnknownHeaders;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=80)]
        internal int[] LengthValue;
        internal short MoreEntityBodyExists;
        internal short EntityBodyLength;
        internal IntPtr pEntityBody;

    } // UL_HTTP_REQUEST



    [StructLayout(LayoutKind.Sequential)]
    internal class UL_DATA_CHUNK {
        internal int DataChunkType; // 0 if data is from memory (see enum below)
        internal IntPtr pBuffer;
        internal int BufferLength;

    /*
    typedef enum _UL_DATA_CHUNK_TYPE {
    UlDataChunkFromMemory,
    UlDataChunkFromFileName,
    UlDataChunkFromFileHandle,

    UlDataChunkMaximum

    } UL_DATA_CHUNK_TYPE, *PUL_DATA_CHUNK_TYPE;
    */

    } // UL_DATA_CHUNK


    /////////////////////////////////////////////////////////////////
    // Utilities and useful constants.
    //
    /////////////////////////////////////////////////////////////////

    // The following enum declarations are
    // taken from (iisrearc)\inc\uldef.h

    internal class UL_HTTP_VERB {
        internal static string ToString( int position ) {
            return m_Strings[ position ];
        }

        internal static int Size {
            get { return m_Strings.Length;}
        }

        private static string[] m_Strings = {
            "Unparsed",
            "GET",
            "PUT",
            "HEAD",
            "POST",
            "DELETE",
            "TRACE",
            "TRACK",
            "OPTIONS",
            "MOVE",
            "COPY",
            "PROPFIND",
            "PROPPATCH",
            "MKCOL",
            "LOCK",
            "Unknown",
            "Invalid",
            "Maximum"};

        internal enum Enum {
            UlHttpVerbUnparsed,
            UlHttpVerbGET,
            UlHttpVerbPUT,
            UlHttpVerbHEAD,
            UlHttpVerbPOST,
            UlHttpVerbDELETE,
            UlHttpVerbTRACE,
            UlHttpVerbTRACK,
            UlHttpVerbOPTIONS,
            UlHttpVerbMOVE,
            UlHttpVerbCOPY,
            UlHttpVerbPROPFIND,
            UlHttpVerbPROPPATCH,
            UlHttpVerbMKCOL,
            UlHttpVerbLOCK,
            UlHttpVerbUnknown,
            UlHttpVerbInvalid,

            UlHttpVerbMaximum
        }

    } // UL_HTTP_VERB


    internal class UL_HTTP_VERSION {

        internal static string ToString( int position ) {
            return m_Strings[ position ];
        }

        internal static int Size {
            get { return m_Strings.Length;}
        }

        private static string[] m_Strings = {
            "Unknown",
            "",
            "HTTP/1.0",
            "HTTP/1.1",
            "Maximum"};

        internal enum Enum {
            UlHttpVersionUnknown,
            UlHttpVersion09,
            UlHttpVersion10,
            UlHttpVersion11,

            UlHttpVersionMaximum
        }

    } // UL_HTTP_VERSION



    // strings are defined in ( HEADER_MAP_ENTRY HeaderMapTable[] ) (iisrearc)\ul\drv\parse.c

    internal class UL_HTTP_RESPONSE_HEADER_ID {

        internal static string
        ToString( int position ) {
            return m_Strings[ position ];
        }

        internal static bool
        Contains( string Key ) {
            return Index( Key ) != -1;
        }

        internal static int
        Index( string Key ) {
            return Array.IndexOf( m_Strings, Key );
        }

        internal static int Size {
            get { return m_Strings.Length;}
        }

        internal enum Enum {
            UlHeaderCacheControl        = 0,        // general-header [section 4.5]
            UlHeaderConnection          ,           // general-header [section 4.5]
            UlHeaderDate                ,           // general-header [section 4.5]
            UlHeaderKeepAlive           ,           // general-header [not in rfc]
            UlHeaderPragma              ,           // general-header [section 4.5]
            UlHeaderTrailer             ,           // general-header [section 4.5]
            UlHeaderTransferEncoding    ,           // general-header [section 4.5]
            UlHeaderUpgrade             ,           // general-header [section 4.5]
            UlHeaderVia                 ,           // general-header [section 4.5]
            UlHeaderWarning             = 9,        // general-header [section 4.5]

            UlHeaderAllow               = 10,       // entity-header  [section 7.1]
            UlHeaderContentLength       ,           // entity-header  [section 7.1]
            UlHeaderContentType         ,           // entity-header  [section 7.1]
            UlHeaderContentEncoding     ,           // entity-header  [section 7.1]
            UlHeaderContentLanguage     ,           // entity-header  [section 7.1]
            UlHeaderContentLocation     ,           // entity-header  [section 7.1]
            UlHeaderContentMd5          ,           // entity-header  [section 7.1]
            UlHeaderContentRange        ,           // entity-header  [section 7.1]
            UlHeaderExpires             ,           // entity-header  [section 7.1]
            UlHeaderLastModified        = 19,       // entity-header  [section 7.1]

            UlHeaderAcceptRanges        = 20,       // response-header [section 6.2]
            UlHeaderAge                 ,           // response-header [section 6.2]
            UlHeaderEtag                ,           // response-header [section 6.2]
            UlHeaderLocation            ,           // response-header [section 6.2]
            UlHeaderProxyAuthenticate   ,           // response-header [section 6.2]
            UlHeaderRetryAfter          ,           // response-header [section 6.2]
            UlHeaderServer              ,           // response-header [section 6.2]
            UlHeaderSetCookie           ,           // response-header [not in rfc]
            UlHeaderVary                ,           // response-header [section 6.2]
            UlHeaderWwwAuthenticate     = 29,       // response-header [section 6.2]

            UlHeaderResponseMaximum     = 30,

            UlHeaderMaximum             = 40
        }

        private static string[]
        m_Strings = {
            "Cache-Control",
            "Connection",
            "Date",
            "Keep-Alive",
            "Pragma",
            "Trailer",
            "Transfer-Encoding",
            "Upgrade",
            "Via",
            "Warning",
            "Allow",
            "Content-Length",
            "Content-Type",
            "Content-Encoding",
            "Content-Language",
            "Content-Location",
            "Content-MD5",
            "Content-Range",
            "Expires",
            "Last-Modified",
            "Accept-Ranges",
            "Age",
            "ETag",
            "Location",
            "Proxy-Authenticate",
            "Retry-After",
            "Server",
            "Set-Cookie",
            "Vary",
            "WWW-Authenticate",
            "Response-Maximum"};

        internal static int
        IndexOfKnownHeader( string HeaderName ) {
            Object index = m_Hashtable[ HeaderName ];

            if (index != null) {
                return(int)index;
            }
            else {
                return -1;
            }
        }

        private static bool
        m_Initialize() {
            m_Max = (int)Enum.UlHeaderResponseMaximum;
            m_Hashtable = new Hashtable( m_Max );

            for (int i = 0; i < m_Max; i++) {
                m_Hashtable.Add( m_Strings[ i ], i );
            }

            return true;
        }

        private static int m_Max;
        private static Hashtable m_Hashtable;
        private static bool m_IsInitialized = m_Initialize();

    } // UL_HTTP_RESPONSE_HEADER_ID



    internal class UL_HTTP_REQUEST_HEADER_ID {

        internal static string ToString( int position ) {
            return m_Strings[ position ];
        }

        internal static bool Contains( string Key ) {
            return Index( Key ) != -1;
        }

        internal static int Index( string Key ) {
            return Array.IndexOf( m_Strings, Key );
        }

        internal static int Size {
            get { return m_Strings.Length;}
        }

        private static string[] m_Strings = {
            "Cache-Control",
            "Connection",
            "Date",
            "Keep-Alive",
            "Pragma",
            "Trailer",
            "Transfer-Encoding",
            "Upgrade",
            "Via",
            "Warning",
            "Allow",
            "Content-Length",
            "Content-Type",
            "Content-Encoding",
            "Content-Language",
            "Content-Location",
            "Content-MD5",
            "Content-Range",
            "Expires",
            "Last-Modified",
            "Accept",
            "Accept-Charset",
            "Accept-Encoding",
            "Accept-Language",
            "Authorization",
            "Cookie",
            "Expect",
            "From",
            "Host",
            "If-Match",
            "If-Modified-Since",
            "If-None-Match",
            "If-Range",
            "If-Unmodified-Since",
            "Max-Forwards",
            "Proxy-Authorization",
            "Referer",
            "Range",
            "Te",
            "User-Agent",
            "Request-Maximum"};

        internal enum Enum {
            UlHeaderCacheControl        = 0,        // general-header [section 4.5]
            UlHeaderConnection          ,           // general-header [section 4.5]
            UlHeaderDate                ,           // general-header [section 4.5]
            UlHeaderKeepAlive           ,           // general-header [not in rfc]
            UlHeaderPragma              ,           // general-header [section 4.5]
            UlHeaderTrailer             ,           // general-header [section 4.5]
            UlHeaderTransferEncoding    ,           // general-header [section 4.5]
            UlHeaderUpgrade             ,           // general-header [section 4.5]
            UlHeaderVia                 ,           // general-header [section 4.5]
            UlHeaderWarning             = 9,        // general-header [section 4.5]

            UlHeaderAllow               = 10,       // entity-header  [section 7.1]
            UlHeaderContentLength       ,           // entity-header  [section 7.1]
            UlHeaderContentType         ,           // entity-header  [section 7.1]
            UlHeaderContentEncoding     ,           // entity-header  [section 7.1]
            UlHeaderContentLanguage     ,           // entity-header  [section 7.1]
            UlHeaderContentLocation     ,           // entity-header  [section 7.1]
            UlHeaderContentMd5          ,           // entity-header  [section 7.1]
            UlHeaderContentRange        ,           // entity-header  [section 7.1]
            UlHeaderExpires             ,           // entity-header  [section 7.1]
            UlHeaderLastModified        = 19,       // entity-header  [section 7.1]

            UlHeaderAccept              = 20,       // request-header [section 5.3]
            UlHeaderAcceptCharset       ,           // request-header [section 5.3]
            UlHeaderAcceptEncoding      ,           // request-header [section 5.3]
            UlHeaderAcceptLanguage      ,           // request-header [section 5.3]
            UlHeaderAuthorization       ,           // request-header [section 5.3]
            UlHeaderCookie              ,           // request-header [not in rfc]
            UlHeaderExpect              ,           // request-header [section 5.3]
            UlHeaderFrom                ,           // request-header [section 5.3]
            UlHeaderHost                ,           // request-header [section 5.3]
            UlHeaderIfMatch             ,           // request-header [section 5.3]
            UlHeaderIfModifiedSince     ,           // request-header [section 5.3]
            UlHeaderIfNoneMatch         ,           // request-header [section 5.3]
            UlHeaderIfRange             ,           // request-header [section 5.3]
            UlHeaderIfUnmodifiedSince   ,           // request-header [section 5.3]
            UlHeaderMaxForwards         ,           // request-header [section 5.3]
            UlHeaderProxyAuthorization  ,           // request-header [section 5.3]
            UlHeaderReferer             ,           // request-header [section 5.3]
            UlHeaderRange               ,           // request-header [section 5.3]
            UlHeaderTe                  ,           // request-header [section 5.3]
            UlHeaderUserAgent           = 39,       // request-header [section 5.3]

            UlHeaderRequestMaximum      = 40,

            UlHeaderMaximum             = 40
        }

    } // UL_HTTP_REQUEST_HEADER_ID



    // the concept of an HttpWebListener object is 1:1 with an AppPool, i.e. a set of
    // uri prefixes for which we are provided ( after correct registration ) the
    // incoming HTTP requests for.

    // CODEWORK:
    // 1. avoid pinnning buffers when possible
    // 2. have a centralized store for known-header names
    // 3. have a centralized store for constants

    //
    // HttpListenerCreator.
    //
    // This is the class that we use to create HTTP listeners.
    //

    internal class HttpListenerCreator : IWebListenerCreate {

        internal HttpListenerCreator() {
        }

        /*++

         Create - Create an HttpListenerWebListener.

            This is our method to create an HttpListenerWebListener. We register
            for HTTP protocol, and this method is called when a listener
            needs to be created for this protocol.


            Input:
                    protocolName -
                            protocol name for which the listener is being
                            created.

            Returns:
                    The newly created WebListener.

         --*/

        public WebListener Create(string protocolName) {
            if (string.Compare(protocolName, "http", true, CultureInfo.InvariantCulture)!=0) {
                throw new NotSupportedException(SR.GetString(SR.net_ProtocolNotSupportedException, protocolName));

            }
            return new HttpWebListener();
        }

    } // class HttpListenerCreator


#endif // #if COMNET_LISTENER


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\webheadercollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebHeaderCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Collections.Specialized;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;

    //
    // HttpHeaders - this is our main HttpHeaders object,
    //  which is a simple collection of name-value pairs,
    //  along with additional methods that provide HTTP parsing
    //  collection to sendable buffer capablities and other enhansments
    //  We also provide validation of what headers are allowed to be added.
    //

    /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Contains protocol headers associated with a
    ///       request or response.
    ///    </para>
    /// </devdoc>
    [ComVisible(true), Serializable]
    public class WebHeaderCollection : NameValueCollection, ISerializable {
        //
        // Data and Constants
        //
        private const int ApproxAveHeaderLineSize = 30;
        private static readonly HeaderInfoTable HInfo = new HeaderInfoTable();

        //
        // m_IsHttpWebHeaderObject:
        // true if this object is created for internal use, in this case
        // we turn on checking when adding special headers.
        //
        private bool m_IsHttpWebHeaderObject = false;

        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.AddWithoutValidate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void AddWithoutValidate(string headerName, string headerValue) {
            headerName = CheckBadChars(headerName, false);
            headerValue = CheckBadChars(headerValue, true);
            GlobalLog.Print("WebHeaderCollection::AddWithoutValidate() calling base.Add() key:[" + headerName + "], value:[" + headerValue + "]");
            base.Add(headerName, headerValue);
        }


        internal void SetAddVerified(string name, string value) {
            if(HInfo[name].AllowMultiValues) {
                GlobalLog.Print("WebHeaderCollection::SetAddVerified() calling base.Add() key:[" + name + "], value:[" + value + "]");
                base.Add(name, value);
            }
            else {
                GlobalLog.Print("WebHeaderCollection::SetAddVerified() calling base.Set() key:[" + name + "], value:[" + value + "]");
                base.Set(name, value);
           }
        }

        // Below three methods are for fast headers manipulation, bypassing all the checks
        internal void AddInternal(string name, string value) {
            GlobalLog.Print("WebHeaderCollection::AddInternal() calling base.Add() key:[" + name + "], value:[" + value + "]");
            base.Add(name, value);
        }

        internal void ChangeInternal(string name, string value) {
            GlobalLog.Print("WebHeaderCollection::ChangeInternal() calling base.Set() key:[" + name + "], value:[" + value + "]");
            base.Set(name, value);
        }


        internal void RemoveInternal(string name) {
            GlobalLog.Print("WebHeaderCollection::RemoveInternal() calling base.Remove() key:[" + name + "]");
            base.Remove(name);
        }

        internal void CheckUpdate(string name, string value) {
            value = CheckBadChars(value, true);
            ChangeInternal(name, value);
        }

        //
        // CheckBadChars - throws on invalid chars to be not found in header name/value
        //
        internal static string CheckBadChars(string name, bool isHeaderValue) {

            if (name == null || name.Length == 0) {
                // emtpy name is invlaid
                if (!isHeaderValue) {
                    throw new ArgumentException("value");
                }
                //empty value is OK
                return string.Empty;
            }

            if (isHeaderValue) {
                // VALUE check
                //Trim spaces from both ends
                name = name.Trim();

                //First, check for correctly formed multi-line value
                //Second, check for absenece of CTL characters
                bool crlf = false;
                foreach (char c in name) {
                    if (c == 127 || (c < ' ' && !(c == '\t' || c == '\r' || c == '\n'))) {
                        throw new ArgumentException("value");
                    }

                    if (crlf) {
                        if (!(c == ' ' || c == '\t')) {
                            throw new ArgumentException("value");
                        }
                        crlf = false;
                    }else {
                        if (c == '\n') {
                            crlf = true;
                        }
                    }
                }
            }
            else {
                // NAME check
                //First, check for absence of separators and spaces
                if (name.IndexOfAny(ValidationHelper.InvalidParamChars) != -1) {
                    throw new ArgumentException("name");
                }

                //Second, check for non CTL ASCII-7 characters (32-126)
                if (ContainsNonAsciiChars(name)) {
                    throw new ArgumentException("name");
                }
            }
            return name;
        }

        internal static bool IsValidToken(string token) {
            return (token.Length > 0)
                && (token.IndexOfAny(ValidationHelper.InvalidParamChars) == -1)
                && !ContainsNonAsciiChars(token);
        }

        internal static bool ContainsNonAsciiChars(string token) {
            for (int i = 0; i < token.Length; ++i) {
                if ((token[i] < 0x20) || (token[i] > 0x7e)) {
                    return true;
                }
            }
            return false;
        }

        //
        // ThrowOnRestrictedHeader - generates an error if the user,
        //  passed in a reserved string as the header name
        //

        internal void ThrowOnRestrictedHeader(string headerName) {
            if (m_IsHttpWebHeaderObject && HInfo[headerName].IsRestricted ) {
                throw new ArgumentException(SR.GetString(SR.net_headerrestrict));
            }
        }

        //
        // Our Public METHOD set, most are inherited from NameValueCollection,
        //  not all methods from NameValueCollection are listed, even though usable -
        //
        //  this includes
        //  Add(name, value)
        //  Add(header)
        //  this[name] {set, get}
        //  Remove(name), returns bool
        //  Remove(name), returns void
        //  Set(name, value)
        //  ToString()
        //
        //  SplitValue(name, value)
        //  ToByteArray()
        //  ParseHeaders(char [], ...)
        //  ParseHeaders(byte [], ...)
        //

        // Add more headers; if "name" already exists it will
        // add concatenated value

        /*++

        Add -

        Routine Description:

            Adds headers with validation to see if they
             are "proper" headers.

            Will cause header to be concat to existing if already found.

            If the header is a special header, listed in RestrictedHeaders object,
            then this call will cause an exception indication as such.

        Arguments:

            name - header-name to add
            value - header-value to add, a header is already there, will concat this value

        Return Value:

            None

        --*/
        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a new header with the indicated name and value.
        ///    </para>
        /// </devdoc>
        public override void Add(string name, string value) {
            name = CheckBadChars(name, false);
            ThrowOnRestrictedHeader(name);
            value = CheckBadChars(value, true);
            GlobalLog.Print("WebHeaderCollection::Add() calling base.Add() key:[" + name + "], value:[" + value + "]");
            base.Add(name, value);
        }


        /*++

        Add -

        Routine Description:

            Adds headers with validation to see if they
             are "proper" headers.

            Assumes a combined a "Name: Value" string, and parses the two parts out.

            Will cause header to be concat to existing if already found.

            If the header is a speical header, listed in RestrictedHeaders object,
            then this call will cause an exception indication as such.

        Arguments:

            header - header name: value pair

        Return Value:

            None

        --*/
        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the indicated header.
        ///    </para>
        /// </devdoc>
        public void Add(string header) {
            if ( ValidationHelper.IsBlankString(header) ) {
                throw new ArgumentNullException("header");
            }

            int colpos = header.IndexOf(':');

            // check for badly formed header passed in
            if (colpos<0) {
                throw new ArgumentException("header");
            }

            string name = header.Substring(0, colpos);
            string value = header.Substring(colpos+1);

            name = CheckBadChars(name, false);
            ThrowOnRestrictedHeader(name);
            value = CheckBadChars(value, true);

            GlobalLog.Print("WebHeaderCollection::Add(" + header + ") calling base.Add() key:[" + name + "], value:[" + value + "]");
            base.Add(name, value);
        }

        /*++

        Set -

        Routine Description:

            Sets headers with validation to see if they
             are "proper" headers.

            If the header is a special header, listed in RestrictedHeaders object,
            then this call will cause an exception indication as such.

        Arguments:

            name - header-name to set
            value - header-value to set

        Return Value:

            None

        --*/
        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.Set"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the specified header to the specified value.
        ///    </para>
        /// </devdoc>
        public override void Set(string name, string value) {
            if ( ValidationHelper.IsBlankString(name) ) {
                throw new ArgumentNullException("name");
            }
            name  = CheckBadChars(name,  false);
            ThrowOnRestrictedHeader(name);
            value = CheckBadChars(value, true);
            GlobalLog.Print("WebHeaderCollection::Set() calling base.Set() key:[" + name + "], value:[" + value + "]");
            base.Set(name, value);
        }


        /*++

        Remove -

        Routine Description:

            Removes give header with validation to see if they
             are "proper" headers.

            If the header is a speical header, listed in RestrictedHeaders object,
            then this call will cause an exception indication as such.

        Arguments:

            name - header-name to remove

        Return Value:

            None

        --*/

        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified header.</para>
        /// </devdoc>
        public override void Remove(string name) {

            if ( ValidationHelper.IsBlankString(name) ) {
                throw new ArgumentNullException("name");
            }

            ThrowOnRestrictedHeader(name);
            name = CheckBadChars(name,  false);

            GlobalLog.Print("WebHeaderCollection::Remove() calling base.Remove() key:[" + name + "]");
            base.Remove(name);
        }

        /*++

        GetValues

        Routine Description:

            This method takes a header name and returns a string array representing
            the individual values for that headers. For example, if the headers
            contained the line Accept: text/plain, text/html then
            GetValues("Accept") would return an array of two strings: "text/plain"
            and "text/html".

        Arguments:

            header      - Name of the header.

        Return Value:

            string[] - array of parsed string objects

        --*/
        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.GetValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an array of header values stored in a
        ///       header.
        ///    </para>
        /// </devdoc>
        public override string[] GetValues(string header) {

            // First get the information about the header and the values for
            // the header.

            HeaderInfo Info = HInfo[header];
            string[] Values = base.GetValues(header);

            // If we have no information about the header or it doesn't allow
            // multiple values, just return the values.

            if (Info == null || Values == null || !Info.AllowMultiValues) {

                return Values;
            }

            // Here we have a multi value header. We need to go through
            // each entry in the multi values array, and if an entry itself
            // has multiple values we'll need to combine those in.
            //
            // We do some optimazation here, where we try not to copy the
            // values unless there really is one that have multiple values.

            string[] TempValues;
            ArrayList ValueList = null;

            int i;

            for (i = 0; i < Values.Length; i++) {

                // Parse this value header.
                TempValues = Info.Parser(Values[i]);

                // If we don't have an array list yet, see if this
                // value has multiple values.

                if (ValueList == null) {

                    // See if it has multiple values.

                    if (TempValues.Length > 1) {

                        // It does, so we need to create an array list that
                        // represents the Values, then trim out this one and
                        // the ones after it that haven't been parsed yet.

                        ValueList = new ArrayList(Values);

                        ValueList.RemoveRange(i, Values.Length - i);

                        ValueList.AddRange(TempValues);
                    }
                }
                else {

                    // We already have an ArrayList, so just add the values.

                    ValueList.AddRange(TempValues);
                }
            }

            // See if we have an ArrayList. If we don't, just return the values.
            // Otherwise convert the ArrayList to a string array and return that.

            if (ValueList != null) {

                string[] ReturnArray = new string[ValueList.Count];

                ValueList.CopyTo(ReturnArray);

                return ReturnArray;
            }

            return Values;
        }


        /*++

        ToString()  -

        Routine Description:

            Generates a string representation of the headers, that is ready to be sent
             except for it being in string format:

            the format looks like:

            Header-Name: Header-Value\r\n
            Header-Name2: Header-Value2\r\n
            ...
            Header-NameN: Header-ValueN\r\n
            \r\n

            Uses the string builder class to Append the elements together.

        Arguments:

            None.

        Return Value:

            string

        --*/

        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Obsolete.
        ///    </para>
        /// </devdoc>
        public override string ToString() {

            // create string builder class, use a default size, to prevent reallocations
            StringBuilder sb = new StringBuilder(ApproxAveHeaderLineSize * base.Count);

            for (int i = 0; i < base.Count ; i++) {

                string  key = (string) GetKey(i);
                string  val = (string) Get(i);

                GlobalLog.Print("WebHeaderCollection::ToString: key:[" + key + "] value:[" + val + "]");

                sb.Append(key).Append(": ");
                sb.Append(val).Append("\r\n");
            }

            sb.Append("\r\n");

            return sb.ToString();
        }


        /*++

        ToByteArray()  -

        Routine Description:

            Generates a byte array representation of the headers, that is ready to be sent.
            So it Serializes our headers into a byte array suitable for sending over the net.

            the format looks like:

            Header-Name1: Header-Value1\r\n
            Header-Name2: Header-Value2\r\n
            ...
            Header-NameN: Header-ValueN\r\n
            \r\n

            Uses the ToString() method to generate, and then performs conversion.

            Performance Note:  Why are we not doing a single copy/covert run?
            As the code before used to know the size of the output!
            Because according to Demitry, its cheaper to copy the headers twice,
            then it is to call the UNICODE to ANSI conversion code many times.

        Arguments:

            None.

        Return Value:

            byte [] - array of bytes values

        --*/
        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.ToByteArray"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Obsolete.
        ///    </para>
        /// </devdoc>
        public byte[] ToByteArray() {
            // Make sure the buffer is big enough.
            string tempStr = ToString();
            //
            // Use the string of headers, convert to Char Array,
            //  then convert to Bytes,
            //  serializing finally into the buffer, along the way.
            //
            byte[] buffer = HeaderEncoding.GetBytes(tempStr);
            return buffer;
        }

        /*++

        WebHeaderCollection  - Constructor

        Routine Description:

            Constructor !

        Arguments:

            None.

        Return Value:

            None.

        --*/
        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.WebHeaderCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.WebHeaderCollection'/>
        ///       class.
        ///    </para>
        /// </devdoc>


        public WebHeaderCollection() : base(CaseInsensitiveAscii.StaticInstance, CaseInsensitiveAscii.StaticInstance) {
        }

        /*++

        WebHeaderCollection  - Constructor

        Routine Description:

            Constructor  - private Constructor, called internally
                by SystemNet

        Arguments:

            None.

        Return Value:

            None.

        --*/
        internal WebHeaderCollection(bool internalCreate) : base(CaseInsensitiveAscii.StaticInstance, CaseInsensitiveAscii.StaticInstance) {
            m_IsHttpWebHeaderObject = internalCreate;
        }



        /*++

        Routine Description:

            This code is optimized for the case in which all the headers fit in the buffer.
            we support multiple re-entrance, but we won't save intermediate
            state, we will just roll back all the parsing done for the current header if we can't
            parse a whole one (including multiline) or decide something else ("invalid data" or "done parsing").

            we're going to cycle through the loop until we

            1) find an HTTP violation (in this case we return DataParseStatus.Invalid)
            2) we need more data (in this case we return DataParseStatus.NeedMoreData)
            3) we found the end of the headers and the beginning of the entity body (in this case we return DataParseStatus.Done)


        Arguments:

            buffer      - buffer containing the data to be parsed
            size        - size of the buffer
            unparsed    - offset of data yet to be parsed

        Return Value:

            DataParseStatus - status of parsing

        Revision:

            02/13/2001 rewrote the method from scratch.

        Perf Before:

            Fn Name,# calls.,% calls,%App.Incl.Time,%App.Excl.Time,%El.Incl.Time,%El.Excl.Time,AVG.App.Incl.Time (t),AVG.App.Excl.Time (t),AVG.El.Incl.Time (t),AVG.El.Excl.Time (t)
            System.Net.Connection.ParseResponseData,"1,832",0.09,16.55,1.54,18.08,0.63,"50,491.55","4,683.55","139,697.14","4,890.85"

            System.Net.WebHeaderCollection.ParseHeaders,"1,832",0.09,16.55,1.54,18.08,0.63,"50,491.55","4,683.55","139,697.14","4,890.85"

            System.Net.WebHeaderCollection.AddInternal,"12,815",0.62,7.94,0.37,10.74,0.18,"3,462.96",163.43,"11,865.19",204.09
            System.Net.ByteCharConverter.GetString,"25,631",1.25,7.08,1.49,6.7,0.85,"1,542.76",325.75,"3,703.04",467.15

        Perf After (AVG.App.Incl.Time (t) went from 50,491.55 to 30,932.03):

            Fn Name,# calls.,% calls,%App.Incl.Time,%App.Excl.Time,%El.Incl.Time,%El.Excl.Time,AVG.App.Incl.Time (t),AVG.App.Excl.Time (t),AVG.El.Incl.Time (t),AVG.El.Excl.Time (t)
            System.Net.Connection.ParseResponseData,"1,895",0.15,12.6,2.01,11.37,0.96,"30,932.03","4,937.95","58,858.95","4,975.81"

            System.Net.WebHeaderCollection.ParseHeaders,"1,895",0.15,12.6,2.01,11.37,0.96,"30,932.03","4,937.95","58,858.95","4,975.81"

            System.Text.Encoding.GetString,"26,530",2.11,5.26,2.18,6.32,1.13,921.48,381.94,"2,336.48",416.84
            System.Collections.Specialized.NameValueCollection.Add,"13,265",1.05,5.22,0.49,4.02,1.46,"1,830.31",172.96,"2,974.46","1,078.47"
            System.Collections.Specialized.NameObjectCollectionBase.get_Count,"1,895",0.15,0.11,0.11,0.07,0.07,281.2,274.18,351.15,344.12


        BreakPoint:

            b system.dll!System.Net.WebHeaderCollection::ParseHeaders

        --*/

        // we use this static class as a helper class to encode/decode HTTP headers.
        // what we need is a 1-1 correspondence between a char in the range U+0000-U+00FF
        // and a byte in the range 0x00-0xFF (which is the range that can hit the network).
        // this is accomplished by the ISO-88591-1 (Latin-1) encoding, when best fit mapping is disabled.
        //
        // - for decoding:
        //   we will use BCL's Latin1 decoding this is an optimized version that won't call into MB2WC.
        // - for encoding:
        //   we can't use GetEncoding(28591) Latin1 because WC2MB will do best fit mapping, so until they
        //   provide one that doesn't do best fit mapping we'll have our own encoder.
        internal class HeaderEncoding {
            static readonly Encoding NoBestFitMappingLatin1 = Encoding.GetEncoding(28591);
            internal static string GetString(byte[] bytes, int byteIndex, int byteCount) {
                return NoBestFitMappingLatin1.GetString(bytes, byteIndex, byteCount);
            }
            internal static int GetByteCount(string myString) {
                return myString.Length;
            }
            internal unsafe static void GetBytes(string myString, int charIndex, int charCount, byte[] bytes, int byteIndex) {
                if (myString.Length==0) {
                    return;
                }
                fixed (byte *bufferPointer = bytes) {
                    byte* newBufferPointer = bufferPointer + byteIndex;
                    int finalIndex = charIndex + charCount;
                    while (charIndex<finalIndex) {
                        *newBufferPointer++ = (byte)myString[charIndex++];
                    }
                }
            }
            internal unsafe static byte[] GetBytes(string myString) {
                byte[] bytes = new byte[myString.Length];
                if (myString.Length!=0) {
                    GetBytes(myString, 0, myString.Length, bytes, 0);
                }
                return bytes;
            }
        }

        internal DataParseStatus ParseHeaders(byte[] buffer, int size, ref int unparsed, ref int totalResponseHeadersLength, int maximumResponseHeadersLength) {
            int headerNameStartOffset = -1;
            int headerNameEndOffset = -1;
            int headerValueStartOffset = -1;
            int headerValueEndOffset = -1;
            int numberOfLf = -1;
            int index = unparsed;
            bool spaceAfterLf;
            string headerMultiLineValue;
            string headerName;
            string headerValue;

            // we need this because this method is entered multiple times.
            int localTotalResponseHeadersLength = totalResponseHeadersLength;

            DataParseStatus parseStatus = DataParseStatus.Invalid;

            GlobalLog.Enter("WebHeaderCollection::ParseHeaders(): size:" + size.ToString() + ", unparsed:" + unparsed.ToString() + " buffer:[" + Encoding.ASCII.GetString(buffer, unparsed, Math.Min(256, size-unparsed)) + "]");
            //GlobalLog.Print("WebHeaderCollection::ParseHeaders(): advancing. index=" + index.ToString() + " current character='" + ((char)buffer[index]).ToString() + "':" + ((int)buffer[index]).ToString() + " next character='" + ((char)buffer[index+1]).ToString() + "':" + ((int)buffer[index+1]).ToString());
            //GlobalLog.Print("WebHeaderCollection::ParseHeaders(): headerName:[" + headerName + "], headerValue:[" + headerValue + "], headerMultiLineValue:[" + headerMultiLineValue + "] numberOfLf=" + numberOfLf.ToString() + " index=" + index.ToString());
            //GlobalLog.Print("WebHeaderCollection::ParseHeaders(): headerNameStartOffset=" + headerNameStartOffset + " headerNameEndOffset=" + headerNameEndOffset + " headerValueStartOffset=" + headerValueStartOffset + " headerValueEndOffset=" + headerValueEndOffset);

            //
            // according to RFC216 a header can have the following syntax:
            //
            // message-header = field-name ":" [ field-value ]
            // field-name     = token
            // field-value    = *( field-content | LWS )
            // field-content  = <the OCTETs making up the field-value and consisting of either *TEXT or combinations of token, separators, and quoted-string>
            // TEXT           = <any OCTET except CTLs, but including LWS>
            // CTL            = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
            // SP             = <US-ASCII SP, space (32)>
            // HT             = <US-ASCII HT, horizontal-tab (9)>
            // CR             = <US-ASCII CR, carriage return (13)>
            // LF             = <US-ASCII LF, linefeed (10)>
            // LWS            = [CR LF] 1*( SP | HT )
            // CHAR           = <any US-ASCII character (octets 0 - 127)>
            // token          = 1*<any CHAR except CTLs or separators>
            // separators     = "(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\" | <"> | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HT
            // quoted-string  = ( <"> *(qdtext | quoted-pair ) <"> )
            // qdtext         = <any TEXT except <">>
            // quoted-pair    = "\" CHAR
            //

            //
            // At each iteration of the following loop we expect to parse a single HTTP header entirely.
            //
            for (;;) {
                //
                // trim leading whitespaces (LWS) just for extra robustness, in fact if there are leading white spaces then:
                // 1) it could be that after the status line we might have spaces. handle this.
                // 2) this should have been detected to be a multiline header so there'll be no spaces and we'll spend some time here.
                //
                headerName = string.Empty;
                headerValue = string.Empty;
                spaceAfterLf = false;
                headerMultiLineValue = null;

                if (Count==0) {
                    //
                    // so, restrict this extra trimming only on the first header line
                    //
                    while (index<size && (buffer[index]==' ' || buffer[index]=='\t')) {
                        index++;
                        if (maximumResponseHeadersLength>=0 && ++localTotalResponseHeadersLength>=maximumResponseHeadersLength) {
                            parseStatus = DataParseStatus.DataTooBig;
                            goto quit;
                        }
                    }
                    if (index==size) {
                        //
                        // we reached the end of the buffer. ask for more data.
                        //
                        parseStatus = DataParseStatus.NeedMoreData;
                        goto quit;
                    }
                }

                //
                // what we have here is the beginning of a new header
                //
                headerNameStartOffset = index;

                while (index<size && (buffer[index]!=':' && buffer[index]!='\n')) {
                    if (buffer[index]>' ') {
                        //
                        // if thre's an illegal character we should return DataParseStatus.Invalid
                        // instead we choose to be flexible, try to trim it, but include it in the string
                        //
                        headerNameEndOffset = index;
                    }
                    index++;
                    if (maximumResponseHeadersLength>=0 && ++localTotalResponseHeadersLength>=maximumResponseHeadersLength) {
                        parseStatus = DataParseStatus.DataTooBig;
                        goto quit;
                    }
                }
                if (index==size) {
                    //
                    // we reached the end of the buffer. ask for more data.
                    //
                    parseStatus = DataParseStatus.NeedMoreData;
                    goto quit;
                }

startOfValue:
                //
                // skip all [' ','\t',':','\r','\n'] characters until HeaderValue starts
                // if we didn't find any headers yet, we set numberOfLf to 1
                // so that we take the '\n' from the status line into account
                //

                numberOfLf = (Count==0 && headerNameEndOffset<0) ? 1 : 0;
                while (index<size && numberOfLf<2 && (buffer[index]<=' ' || buffer[index]==':')) {
                    if (buffer[index]=='\n') {
                        numberOfLf++;
                        spaceAfterLf = index+1<size && (buffer[index+1]==' ' || buffer[index+1]=='\t');
                    }
                    index++;
                    if (maximumResponseHeadersLength>=0 && ++localTotalResponseHeadersLength>=maximumResponseHeadersLength) {
                        parseStatus = DataParseStatus.DataTooBig;
                        goto quit;
                    }
                }
                if (numberOfLf==2 || (numberOfLf==1 && !spaceAfterLf)) {
                    //
                    // if we've counted two '\n' we got at the end of the headers even if we're past the end of the buffer
                    // if we've counted one '\n' and the first character after that was a ' ' or a '\t'
                    // no matter if we found a ':' or not, treat this as an empty header name.
                    //
                    goto addHeader;
                }
                if (index==size) {
                    //
                    // we reached the end of the buffer. ask for more data.
                    //
                    parseStatus = DataParseStatus.NeedMoreData;
                    goto quit;
                }

                headerValueStartOffset = index;

                while (index<size && buffer[index]!='\n') {
                    if (buffer[index]>' ') {
                        headerValueEndOffset = index;
                    }
                    index++;
                    if (maximumResponseHeadersLength>=0 && ++localTotalResponseHeadersLength>=maximumResponseHeadersLength) {
                        parseStatus = DataParseStatus.DataTooBig;
                        goto quit;
                    }
                }
                if (index==size) {
                    //
                    // we reached the end of the buffer. ask for more data.
                    //
                    parseStatus = DataParseStatus.NeedMoreData;
                    goto quit;
                }

                //
                // at this point we found either a '\n' or the end of the headers
                // hence we are at the end of the Header Line. 4 options:
                // 1) need more data
                // 2) if we find two '\n' => end of headers
                // 3) if we find one '\n' and a ' ' or a '\t' => multiline header
                // 4) if we find one '\n' and a valid char => next header
                //
                numberOfLf = 0;
                while (index<size && numberOfLf<2 && (buffer[index]=='\r' || buffer[index]=='\n')) {
                    if (buffer[index]=='\n') {
                        numberOfLf++;
                    }
                    index++;
                    if (maximumResponseHeadersLength>=0 && ++localTotalResponseHeadersLength>=maximumResponseHeadersLength) {
                        parseStatus = DataParseStatus.DataTooBig;
                        goto quit;
                    }
                }
                if (index==size && numberOfLf<2) {
                    //
                    // we reached the end of the buffer but not of the headers. ask for more data.
                    //
                    parseStatus = DataParseStatus.NeedMoreData;
                    goto quit;
                }

addHeader:
                if (headerValueStartOffset>=0 && headerValueStartOffset>headerNameEndOffset && headerValueEndOffset>=headerValueStartOffset) {
                    //
                    // Encoding fastest way to build the UNICODE string off the byte[]
                    //
                    headerValue = HeaderEncoding.GetString(buffer, headerValueStartOffset, headerValueEndOffset-headerValueStartOffset+1);
                }

                //
                // if we got here from the beginning of the for loop, headerMultiLineValue will be null
                // otherwise it will contain the headerValue constructed for the multiline header
                // add this line as well to it, separated by a single space
                //
                headerMultiLineValue = (headerMultiLineValue==null ? headerValue : headerMultiLineValue + " " + headerValue);

                if (index<size && numberOfLf==1 && (buffer[index]==' ' || buffer[index]=='\t')) {
                    //
                    // since we found only one Lf and the next header line begins with a Lws,
                    // this is the beginning of a multiline header.
                    // parse the next line into headerValue later it will be added to headerMultiLineValue
                    //
                    index++;
                    if (maximumResponseHeadersLength>=0 && ++localTotalResponseHeadersLength>=maximumResponseHeadersLength) {
                        parseStatus = DataParseStatus.DataTooBig;
                        goto quit;
                    }
                    goto startOfValue;
                }

                if (headerNameStartOffset>=0 && headerNameEndOffset>=headerNameStartOffset) {
                    //
                    // Encoding is the fastest way to build the UNICODE string off the byte[]
                    //
                    headerName = HeaderEncoding.GetString(buffer, headerNameStartOffset, headerNameEndOffset-headerNameStartOffset+1);
                }

                //
                // now it's finally safe to add the header if we have a name for it
                //
                if (headerName.Length>0) {
                    //
                    // the base clasee will check for pre-existing headerValue and append
                    // it using commas as indicated in the RFC
                    //
                    GlobalLog.Print("WebHeaderCollection::ParseHeaders() calling base.Add() key:[" + headerName + "], value:[" + headerMultiLineValue + "]");
                    base.Add(headerName, headerMultiLineValue);
                }

                //
                // and update unparsed
                //
                totalResponseHeadersLength = localTotalResponseHeadersLength;
                unparsed = index;

                if (numberOfLf==2) {
                    parseStatus = DataParseStatus.Done;
                    goto quit;
                }

            } // for (;;)

quit:
            GlobalLog.Leave("WebHeaderCollection::ParseHeaders() returning parseStatus:" + parseStatus.ToString());
            return parseStatus;
        }


        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.IsRestricted"]/*' />
        /// <devdoc>
        ///    <para>Tests if access to the HTTP header with the provided name is accessible for setting.</para>
        /// </devdoc>
        public static bool IsRestricted(string headerName) {
            if ( ValidationHelper.IsBlankString(headerName) ) {
                throw new ArgumentNullException("headerName");
            }
            return HInfo[CheckBadChars(headerName, false)].IsRestricted;
        }

        //
        // ISerializable constructor
        //
        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.WebHeaderCollection1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext)
        : base(CaseInsensitiveAscii.StaticInstance, CaseInsensitiveAscii.StaticInstance) {
            int count = serializationInfo.GetInt32("Count");
            for (int i = 0; i < count; i++) {
                string headerName = serializationInfo.GetString(i.ToString());
                string headerValue = serializationInfo.GetString((i+count).ToString());
                GlobalLog.Print("WebHeaderCollection::.ctor(ISerializable) calling base.Add() key:[" + headerName + "], value:[" + headerValue + "]");
                base.Add(headerName, headerValue);
            }
            return;
        }

        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.OnDeserialization"]/*' />
        public override void OnDeserialization(object sender) {
            //
            // until we use the base class serialization we need
            // to hide their implementation of this methos which
            // is unnecessarily throwing.
            //
            return;
        }

        //
        // ISerializable method
        //
        /// <include file='doc\WebHeaders.uex' path='docs/doc[@for="WebHeaderCollection.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            //
            // for now disregard streamingContext.
            //
            serializationInfo.AddValue("Count", base.Count);
            for (int i = 0; i < base.Count; i++) {
                serializationInfo.AddValue(i.ToString(), GetKey(i));
                serializationInfo.AddValue((i+base.Count).ToString(), Get(i));
            }
            return;
        }

    }; // class WebHeaderCollection


    internal class CaseInsensitiveAscii : IHashCodeProvider, IComparer {

        //
        // ASCII char ToLower table
        //

        internal static readonly CaseInsensitiveAscii StaticInstance = new CaseInsensitiveAscii();

        private static readonly byte[] AsciiToLower = new byte[] {

              0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
             10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
             30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
             40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
             50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
             60, 61, 62, 63, 64, 97, 98, 99,100,101, //  60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
            102,103,104,105,106,107,108,109,110,111, //  70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
            112,113,114,115,116,117,118,119,120,121, //  80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
            122, 91, 92, 93, 94, 95, 96, 97, 98, 99, //  90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
            100,101,102,103,104,105,106,107,108,109,
            110,111,112,113,114,115,116,117,118,119,
            120,121,122,123,124,125,126,127,128,129,
            130,131,132,133,134,135,136,137,138,139,
            140,141,142,143,144,145,146,147,148,149,
            150,151,152,153,154,155,156,157,158,159,
            160,161,162,163,164,165,166,167,168,169,
            170,171,172,173,174,175,176,177,178,179,
            180,181,182,183,184,185,186,187,188,189,
            190,191,192,193,194,195,196,197,198,199,
            200,201,202,203,204,205,206,207,208,209,
            210,211,212,213,214,215,216,217,218,219,
            220,221,222,223,224,225,226,227,228,229,
            230,231,232,233,234,235,236,237,238,239,
            240,241,242,243,244,245,246,247,248,249,
            250,251,252,253,254,255

        }; // ASCIIToLower

        //
        // ASCII string case insensitive hash function
        //

        public int GetHashCode(object myObject) {
            string myString = myObject as string;
            if (myObject == null) {
                return 0;
            }

            int myHashCode = myString.Length;

            if (myHashCode == 0) {
                return 0;
            }

            //
            // PERF:
            // removed the while. just use the firs character, the last and the length
            // perf went from:
            // clocks per instruction CPI: 206 to 82
            // %app exclusive time: 1.96 to 0.81

            myHashCode ^= AsciiToLower[(byte)myString[0]]<<24 ^ AsciiToLower[(byte)myString[myHashCode-1]]<<16;

            return myHashCode;
        }

        //
        // ASCII string case insensitive comparer
        //

        public int Compare(object firstObject, object secondObject) {
            string firstString = firstObject as string;
            string secondString = secondObject as string;
            if (firstObject == null) {
                return secondObject == null ? 0 : -1;
            }

            if (secondObject == null) {
                return 1;
            }

            int result = firstString.Length - secondString.Length;
            int comparisons = result > 0 ? secondString.Length : firstString.Length;
            int difference, index = 0;

            while ( index < comparisons ) {
                difference = (int)(AsciiToLower[ firstString[index] ] - AsciiToLower[ secondString[index] ]);

                if ( difference != 0 ) {
                    result = difference;
                    break;
                }

                index++;
            }

            return result;
        }

    } // class CaseInsensitiveAscii


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\webexceptionstatus.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebExceptionStatus.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the status of a network request.
    ///    </para>
    /// </devdoc>
    public enum WebExceptionStatus {
        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.Success"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No error was encountered.
        ///    </para>
        /// </devdoc>
        Success = 0,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.NameResolutionFailure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The name resolver service could not resolve the host name.
        ///    </para>
        /// </devdoc>
        NameResolutionFailure = 1,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.ConnectFailure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The remote service point could not be contacted at the transport level.
        ///    </para>
        /// </devdoc>
        ConnectFailure = 2,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.ReceiveFailure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A complete response was not received from the remote server.
        ///    </para>
        /// </devdoc>
        ReceiveFailure = 3,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.SendFailure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A complete request could not be sent to the remote server.
        ///    </para>
        /// </devdoc>
        SendFailure = 4,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.PipelineFailure"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        PipelineFailure = 5,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.RequestCanceled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The request was cancelled.
        ///    </para>
        /// </devdoc>
        RequestCanceled = 6,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.ProtocolError"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The response received from the server was complete but indicated a
        ///       protocol-level error. For example, an HTTP protocol error such as 401 Access
        ///       Denied would use this status.
        ///    </para>
        /// </devdoc>
        ProtocolError = 7,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.ConnectionClosed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The connection was prematurely closed.
        ///    </para>
        /// </devdoc>
        ConnectionClosed = 8,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.TrustFailure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A server certificate could not be validated.
        ///    </para>
        /// </devdoc>
        TrustFailure = 9,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.SecureChannelFailure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An error occurred in a secure channel link.
        ///    </para>
        /// </devdoc>
        SecureChannelFailure = 10,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.ServerProtocolViolation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ServerProtocolViolation = 11,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.KeepAliveFailure"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        KeepAliveFailure = 12,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.Pending"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Pending = 13,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.Timeout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Timeout = 14,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.ProxyNameResolutionFailure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Similar to NameResolution Failure, but for proxy failures.
        ///    </para>
        /// </devdoc>
        ProxyNameResolutionFailure = 15,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.UnknownError"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        UnknownError = 16,

        /// <include file='doc\WebExceptionStatus.uex' path='docs/doc[@for="WebExceptionStatus.MessageLengthLimitExceeded"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sending the request to the server or receiving the response from it,
        ///       required handling a message that exceeded the specified limit.
        ///    </para>
        /// </devdoc>
        MessageLengthLimitExceeded = 17,

    }; // enum WebExceptionStatus


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\weblistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


#if COMNET_LISTENER

namespace System.Net {
    using System;

    /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public abstract class WebListener {

        /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener.WebListener"]/*' />
        protected WebListener() {
        } // WebListener

        //
        // the following methods need to be implemented by all web listeners
        //

        /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener.Close"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void Close() {
            throw ExceptionHelper.MethodNotImplementedException;

        } // Close()

        /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener.AddUriPrefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool AddUriPrefix(string uriPrefix) {
            throw ExceptionHelper.MethodNotImplementedException;

        } // AddUriPrefix()


        /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener.RemoveUriPrefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool RemoveUriPrefix(string uriPrefix) {
            throw ExceptionHelper.MethodNotImplementedException;

        } // RemoveUriPrefix()


        /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void RemoveAll() {
            throw ExceptionHelper.MethodNotImplementedException;

        } // RemoveAll()


        /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener.GetRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual WebRequest GetRequest() {
            throw ExceptionHelper.MethodNotImplementedException;

        } // GetRequest()


        /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener.BeginGetRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual IAsyncResult BeginGetRequest(AsyncCallback requestCallback, Object stateObject) {
            throw ExceptionHelper.MethodNotImplementedException;

        } // StartListen()


        /// <include file='doc\WebListener.uex' path='docs/doc[@for="WebListener.EndGetRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual WebRequest EndGetRequest(IAsyncResult asyncResult) {
            throw ExceptionHelper.MethodNotImplementedException;

        } // AddUri()

    } // class WebListener


} // namespace System.Net


#endif // #if COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\socketpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Security;
    using System.Security.Permissions;
    using System.Globalization;

    //NOTE: While SocketPermissionAttribute resides in System.DLL,
    //      no classes from that DLL are able to make declarative usage of SocketPermission.

     /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermissionAttribute"]/*' />

    // THE syntax of this attribute is as followed
    // [SocketPermsion(SecurityAction.Assert, Access=Connect, Host=hostname, Transport=Tcp/Udp/All, port=portN/All)]
    // [SocketPermsion(SecurityAction.Assert, Access=Accept, Host=localname, Transport=Tcp/Udp/All, port=portN/All)]
    //
    // WHERE:
    //=======
    // - hostname is either a DNS hostname OR an IP address 1.2.3.4 or an IP wildcard 1.2.*.*
    // - protocol is either Tcp, Udp or All
    // - port is a numeric value or -1 that means "All Ports"
    //
    //  All the properites Host, Protocol and Port must be specified.
    // "localIP" means that you put here a valid address or DNS name or the localhost
    //
    //  NetworkAccess specifies the scope of permission, i.e. for connecting to remote peer,
    //  or for accepting data on the local resources.
    //

    [   AttributeUsage( AttributeTargets.Method | AttributeTargets.Constructor |
                        AttributeTargets.Class  | AttributeTargets.Struct      |
                        AttributeTargets.Assembly,
                        AllowMultiple = true, Inherited = false )]

    [Serializable]
    public sealed class SocketPermissionAttribute: CodeAccessSecurityAttribute
    {
        private string  m_access = null;
        private string  m_host   = null;
        private string  m_port   = null;
        private string  m_transport  = null;

        private const string strAccess     = "Access";
        private const string strConnect    = "Connect";
        private const string strAccept     = "Accept";
        private const string strHost       = "Host";
        private const string strTransport  = "Transport";
        private const string strPort       = "Port";

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermissionAttribute.SocketPermissionAttribute"]/*' />
        public SocketPermissionAttribute( SecurityAction action ): base( action )
        {
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermissionAttribute.NetworkAccess"]/*' />
        public string Access {
            get { return m_access; }
            set {
                if (m_access != null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_multi, strAccess, value));
                }
                m_access = value;
            }
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermissionAttribute.Host"]/*' />
        public string Host {
            get { return m_host; }
            set {
                if (m_host != null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_multi, strHost, value));
                }
                m_host = value;
            }
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermissionAttribute.Transport"]/*' />
        public string Transport {
            get { return m_transport;}
            set {
                if (m_transport != null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_multi, strTransport, value));
                }
                m_transport = value;
            }
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermissionAttribute.Port"]/*' />
        public string Port {
            get { return m_port;}
            set {
                if (m_port != null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_multi, strPort, value));
                }
                m_port = value;
            }
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            SocketPermission perm = null;
            if (Unrestricted) {
                perm = new SocketPermission( PermissionState.Unrestricted);
            }
            else {
                perm = new SocketPermission(PermissionState.None);
                if (m_access == null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_count, strAccess));
                }
                if (m_host == null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_count, strHost));
                }
                if (m_transport == null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_count, strTransport));
                }
                if (m_port == null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_count, strPort));
                }
                ParseAddPermissions(perm);
            }
            return perm;
        }


        private void ParseAddPermissions(SocketPermission perm) {

            NetworkAccess access;
            if (0 == string.Compare(m_access, strConnect, true, CultureInfo.InvariantCulture)) {
                access = NetworkAccess.Connect;
            }
            else
            if (0 == string.Compare(m_access, strAccept, true, CultureInfo.InvariantCulture)) {
                access = NetworkAccess.Accept;
            }
            else {
                throw new ArgumentException(SR.GetString(SR.net_perm_invalid_val, strAccess, m_access));
            }

            TransportType transport;
            try {
                transport = (TransportType) Enum.Parse(typeof(TransportType), m_transport, true);
            }
            catch (Exception e) {
                throw new ArgumentException(SR.GetString(SR.net_perm_invalid_val, strTransport, m_transport), e);
            }

            int port;
            if (string.Compare(m_port, "All", true, CultureInfo.InvariantCulture) == 0) {
                m_port = "-1";
            }
            try {
                port = Int32.Parse(m_port);
            }
            catch (Exception e) {
                throw new ArgumentException(SR.GetString(SR.net_perm_invalid_val, strPort, m_port), e);
            }

            if (!ValidationHelper.ValidateTcpPort(port) && port != SocketPermission.AllPorts) {
                throw new ArgumentOutOfRangeException(SR.GetString(SR.net_perm_invalid_val, strPort, m_port));
            }
            perm.AddPermission(access, transport, m_host, port);
        }

    }


    /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Controls rights to make or accept connections on a transport address.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public sealed class SocketPermission : CodeAccessPermission, IUnrestrictedPermission {

        private ArrayList m_connectList;
        private ArrayList m_acceptList;
        private bool m_noRestriction;


        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.ConnectList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the enumeration of permissions to connect a remote peer.
        ///    </para>
        /// </devdoc>
        public IEnumerator ConnectList    {get {return m_connectList.GetEnumerator();}}

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.AcceptList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the enumeration of permissions to accept incoming connections.
        ///    </para>
        /// </devdoc>
        public IEnumerator AcceptList     {get {return m_acceptList.GetEnumerator();}}


        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.AllPorts"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Defines a constant representing all ports.
        ///    </para>
        /// </devdoc>
        public const int AllPorts = unchecked((int)0xFFFFFFFF);

        //consider V.Next: to make it public in V2
        internal const int AnyPort = unchecked((int)0);

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.SocketPermission"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.SocketPermission'/>
        ///       class that passes all demands
        ///       or that fails all demands.
        ///    </para>
        /// </devdoc>
        public SocketPermission(PermissionState state) {
            initialize();
            m_noRestriction = (state == PermissionState.Unrestricted);
        }

        internal SocketPermission(bool free) {
            initialize();
            m_noRestriction = free;
        }


        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.SocketPermission1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the SocketPermissions class for the given transport address with the specified permission.
        ///    </para>
        /// </devdoc>
        public SocketPermission(NetworkAccess access, TransportType transport, String hostName, int portNumber) {
            initialize();
            m_noRestriction = false;
            AddPermission(access, transport, hostName, portNumber);
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.AddPermission"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a permission to the set of permissions for a transport address.
        ///    </para>
        /// </devdoc>
        public void AddPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber) {
            if (hostName == null) {
                throw new ArgumentNullException("hostName");
            }

            EndpointPermission endPoint = new EndpointPermission(hostName, portNumber, transport);

            AddPermission(access, endPoint);
        }

        internal void AddPermission(NetworkAccess access, EndpointPermission endPoint) {
            if (m_noRestriction) {    // Is the permission unrestricted?
                return;             // YES-- then additional endpoints have no effect
            }
            switch (access) {
                case NetworkAccess.Connect:
                    m_connectList.Add(endPoint);
                    break;

                case NetworkAccess.Accept:
                    m_acceptList.Add(endPoint);
                    break;
            }
        }

        // IUnrestrictedPermission interface methods
        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.IsUnrestricted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Checks the overall permission state of the object.
        ///    </para>
        /// </devdoc>
        public bool IsUnrestricted() {
            return m_noRestriction;
        }

        // IPermission interface methods
        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.Copy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates
        ///       a copy of a <see cref='System.Net.SocketPermission'/> instance.
        ///    </para>
        /// </devdoc>
        public override IPermission Copy() {

            SocketPermission sp = new SocketPermission(m_noRestriction);

            sp.m_connectList = (ArrayList)m_connectList.Clone();
            sp.m_acceptList = (ArrayList)m_acceptList.Clone();
                        return sp;
        }

        private bool FindSubset(ArrayList source, ArrayList target) {
            foreach (EndpointPermission e in source) {

                bool found = false;

                foreach (EndpointPermission ee in target) {
                    if (e.SubsetMatch(ee)) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return false;
                }
            }
            return true;
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.Union"]/*' />
        /// <devdoc>
        /// <para>Returns the logical union between two <see cref='System.Net.SocketPermission'/> instances.</para>
        /// </devdoc>
        public override IPermission Union(IPermission target) {
            // Pattern suggested by Security engine
            if (target==null) {
                return this.Copy();
            }
            SocketPermission other = target as SocketPermission;
            if(other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }
            if (m_noRestriction || other.m_noRestriction) {
                return new SocketPermission(true);
            }
            SocketPermission result = (SocketPermission)other.Copy();

            for (int i = 0; i < m_connectList.Count; i++) {
                result.AddPermission(NetworkAccess.Connect, (EndpointPermission)m_connectList[i]);
            }
            for (int i = 0; i < m_acceptList.Count; i++) {
                result.AddPermission(NetworkAccess.Accept, (EndpointPermission)m_acceptList[i]);
            }
            return result;
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.Intersect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the logical intersection between two <see cref='System.Net.SocketPermission'/> instances.
        ///    </para>
        /// </devdoc>
        public override IPermission Intersect(IPermission target) {
            // Pattern suggested by Security engine
            if (target == null) {
                return null;
            }

            SocketPermission other = target as SocketPermission;
            if(other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }

            SocketPermission result;
            if (m_noRestriction) {
                result = (SocketPermission)(other.Copy());
            }
            else if (other.m_noRestriction) {
                result = (SocketPermission)(this.Copy());
            }
            else {
                result = new SocketPermission(false);
                intersectLists(m_connectList, other.m_connectList, result.m_connectList);
                intersectLists(m_acceptList, other.m_acceptList, result.m_acceptList);
            }

            // return null if resulting permission is restricted and empty
            if (!result.m_noRestriction &&
                result.m_connectList.Count == 0 && result.m_acceptList.Count == 0) {
                return null;
            }
            return result;
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.IsSubsetOf"]/*' />
        /// <devdoc>
        /// <para>Compares two <see cref='System.Net.SocketPermission'/> instances.</para>
        /// </devdoc>
        public override bool IsSubsetOf(IPermission target) {
            // Pattern suggested by security engine
            if (target == null) {
                return (m_noRestriction == false && m_connectList.Count == 0 && m_acceptList.Count == 0);
            }

            SocketPermission other = target as SocketPermission;
            if (other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }

            if (other.IsUnrestricted()) {
                return true;
            } else if (this.IsUnrestricted()) {
                return false;
            } else if (this.m_acceptList.Count + this.m_connectList.Count ==0) {
                return true;
            } else if (other.m_acceptList.Count + other.m_connectList.Count ==0) {
                return false;
            }

            bool result = false;
            try {
                if (FindSubset(m_connectList, other.m_connectList) &&
                    FindSubset(m_acceptList, other.m_acceptList)) {
                    result = true;
                }
            }
            finally {
                //  This is around a back door into DNS
                //  Security engine will call isSubsetOf and probably have
                //  DNS permission asserted. We call DNS resolve.
                //  Before return do cleanup of DNS results.

                //  Only "this" needs cleanup, the policy object is not available for
                //  an application to look at.
                this.CleanupDNS();
            }

            return result;
        }

        //
        //This is to cleanup DNS resolution results
        //
        private void CleanupDNS() {
            foreach(EndpointPermission e in m_connectList) {
                //DNS hostnames never produce 'cached=true'
                if (e.cached) {
                    continue;
                }
                e.address = null;
            }

            foreach(EndpointPermission e in m_acceptList) {
                //DNS hostnames never produce 'cached=true'
                if (e.cached) {
                    continue;
                }
                e.address = null;
            }
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.FromXml"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override void FromXml(SecurityElement securityElement) {
            if (securityElement == null) {

                //
                // null SecurityElement
                //

                throw new ArgumentNullException("securityElement");
            }
            if (!securityElement.Tag.Equals("IPermission")) {

                //
                // SecurityElement must be a permission element
                //

                throw new ArgumentException("securityElement");
            }

            string className = securityElement.Attribute("class");

            if (className == null) {

                //
                // SecurityElement must be a permission element for this type
                //

                throw new ArgumentException("securityElement");
            }
            if (className.IndexOf(this.GetType().FullName) < 0) {

                //
                // SecurityElement must be a permission element for this type
                //

                throw new ArgumentException("securityElement");
            }

            //
            // Start recovering the state from XML encoding
            //

            initialize();


            String str = securityElement.Attribute("Unrestricted");

            if (str != null) {
                m_noRestriction = (0 == string.Compare( str, "true", true, CultureInfo.InvariantCulture));
                if(m_noRestriction)
                    return;
            }

            m_noRestriction = false;
            m_connectList = new ArrayList();
            m_acceptList = new ArrayList();

            SecurityElement et = securityElement.SearchForChildByTag("ConnectAccess");
            if (et != null) {
                ParseAddXmlElement(et, m_connectList, "ConnectAccess, ");
            }
            et = securityElement.SearchForChildByTag("AcceptAccess");
            if (et != null) {
                ParseAddXmlElement(et, m_acceptList, "AcceptAccess, ");
            }
        }

        private static void ParseAddXmlElement(SecurityElement et, ArrayList listToAdd, string accessStr) {

            foreach(SecurityElement uriElem in et.Children) {
                if (uriElem.Tag.Equals("ENDPOINT")) {
                    Hashtable attributes = uriElem.Attributes;
                    string tmpStr;

                    try {
                        tmpStr = attributes["host"] as string;
                    }
                    catch{
                        tmpStr = null;
                    }

                    if (tmpStr == null) {
                        throw new ArgumentNullException(accessStr + "host");
                    }
                    string host = tmpStr;

                    try {
                        tmpStr = attributes["transport"] as string;
                    }
                    catch{
                        tmpStr = null;
                    }
                    if (tmpStr == null) {
                        throw new ArgumentNullException(accessStr + "transport");
                    }
                    TransportType transport;
                    try {
                        transport = (TransportType) Enum.Parse(typeof(TransportType), tmpStr, true);
                    }
                    catch (Exception exception) {
                        throw new ArgumentException(accessStr + "transport", exception);
                    }

                    try {
                        tmpStr = attributes["port"] as string;
                    }
                    catch{
                        tmpStr = null;
                    }
                    if (tmpStr == null) {
                        throw new  ArgumentNullException(accessStr + "port");
                    }
                    if (string.Compare(tmpStr, "All", true, CultureInfo.InvariantCulture) == 0) {
                        tmpStr = "-1";
                    }
                    int port;
                    try {
                        port = Int32.Parse(tmpStr);
                    }
                    catch (Exception exception) {
                        throw new ArgumentException(SR.GetString(SR.net_perm_invalid_val, accessStr + "port", tmpStr), exception);
                    }

                    if (!ValidationHelper.ValidateTcpPort(port) && port != SocketPermission.AllPorts) {
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.net_perm_invalid_val, accessStr + "port", tmpStr));
                    }


                    listToAdd.Add(new EndpointPermission(host, port , transport));
                }
                else {
                    // improper tag found, just ignore
                }
            }
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="SocketPermission.ToXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override SecurityElement ToXml() {

            SecurityElement securityElement = new SecurityElement( "IPermission" );

            securityElement.AddAttribute("class", this.GetType().FullName + ", " + this.GetType().Module.Assembly.FullName.Replace( '\"', '\'' ));
            securityElement.AddAttribute("version", "1");

            if (!IsUnrestricted()) {
                if (m_connectList.Count > 0) {

                    SecurityElement permList = new SecurityElement("ConnectAccess");
                    foreach(EndpointPermission permission in m_connectList) {
                        SecurityElement endpoint = new SecurityElement("ENDPOINT");
                        endpoint.AddAttribute("host", permission.Hostname);
                        endpoint.AddAttribute("transport", permission.Transport.ToString());
                        endpoint.AddAttribute("port",   permission.Port != AllPorts?
                                                        permission.Port.ToString(): "All");
                        permList.AddChild(endpoint);
                    }
                    securityElement.AddChild(permList);
                }

                if (m_acceptList.Count > 0) {

                    SecurityElement permList = new SecurityElement("AcceptAccess");
                    foreach(EndpointPermission permission in m_acceptList) {
                        SecurityElement endpoint = new SecurityElement("ENDPOINT");
                        endpoint.AddAttribute("host", permission.Hostname);
                        endpoint.AddAttribute("transport", permission.Transport.ToString());
                        endpoint.AddAttribute("port",   permission.Port != AllPorts?
                                                        permission.Port.ToString(): "All");
                        permList.AddChild(endpoint);
                    }
                    securityElement.AddChild(permList);
                }
            }
            else {
                securityElement.AddAttribute("Unrestricted", "true");
            }
            return securityElement;
        }

        private void initialize() {
            m_noRestriction = false;
            m_connectList = new ArrayList();
            m_acceptList = new ArrayList();
        }

        private static void intersectLists(ArrayList A, ArrayList B, ArrayList result) {
            // The optimization is done according to the following truth
            // (A|B|C) intersect (B|C|E|D)) == B|C|(A inter E)|(A inter D)
            //
            // We also check on any duplicates in the result


            bool[] aDone=new bool[A.Count];            //used to avoid duplicates in result
            bool[] bDone=new bool[B.Count];
            int ia=0;
            int ib=0;
            // Round 1st
            // Getting rid of same permissons in the input arrays (assuming X /\ X = X)
            foreach (EndpointPermission a in  A) {
                ib = 0;
                foreach (EndpointPermission b in  B) {
                    // check to see if b is in the result already
                    if (!bDone[ib]) {
                        //if both elements are the same, copy it into result
                        if (a.Equals(b)) {
                            result.Add(a);
                            aDone[ia]=bDone[ib]=true;
                            //since permissions are ORed we can break and go to the next A
                            break;
                        }
                    }
                    ++ib;
                } //foreach b in B
                ++ia;
            } //foreach a in A

            ia = 0;
            // Round second
            // Grab only intersections of objects not found in both A and B
            foreach (EndpointPermission a in  A) {

                if (!aDone[ia]) {
                    ib = 0;
                    foreach(EndpointPermission b in B) {
                        if (!bDone[ib]) {
                            EndpointPermission intesection = a.Intersect(b);
                            if (intesection != null) {
                                bool found = false;
                                // check to see if we already have the same result
                                foreach (EndpointPermission  res in result) {
                                    if (res.Equals(intesection)) {
                                        found = true;
                                        break;
                                    }
                                }
                                if (!found) {
                                    result.Add(intesection);
                                }
                            }
                        } //!Done[ib]
                        ++ib;
                    } //foreach b in B
                } //!Done[ia]
                ++ia;
            } //foreach a in A
        }

    }// class SocketPermission


    /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="EndpointPermission"]/*' />
    /// <devdoc>
    ///       Represents an element of SocketPermission object contents.
    /// </devdoc>
    [Serializable]
    public class EndpointPermission {

        //
        // Consider V.Next
        //
        // This should be a HostNameType object that knows about DNS, IPv4 and
        // IPv6 addresses. IP (v4) address range needs to be superclassed off
        // IPv4Address
        //

        internal String hostname;
        internal int port;
        internal TransportType transport;
        internal bool wildcard;
        internal IPAddress[] address;
        internal bool cached = false;

        private static char[] DotSeparator = new char[] {'.'};
        private const String encSeperator = "#";

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="EndpointPermission.Hostname"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hostname part of EndpointPermission object
        ///    </para>
        /// </devdoc>
        public String           Hostname        { get {return hostname;}}

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="EndpointPermission.Transport"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the transport of EndpointPermission object
        ///    </para>
        /// </devdoc>
        public TransportType    Transport       { get {return transport;}}

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="EndpointPermission.Port"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the Port part of EndpointPermission object
        ///    </para>
        /// </devdoc>
        public int              Port            { get {return port;}}
        //
        // Consider V.Next
        //
        // w.r.t. hostname as a HostNameType above: if epname can't be validated
        // as a DNS name, IPv4 or IPv6 address, or a wildcard range of IP address
        // then this constructor should throw
        //

        internal EndpointPermission(String epname, int port, TransportType trtype) {

            if (CheckEndPointName(epname) == EndPointType.Invalid) {
                throw new ArgumentException(SR.GetString(SR.net_perm_epname, epname));
            }
            if (!ValidationHelper.ValidateTcpPort(port) && port != SocketPermission.AllPorts) {
                throw new ArgumentOutOfRangeException(SR.GetString(SR.net_perm_invalid_val, "Port", port.ToString()));
            }

            hostname = epname;
            this.port = port;
            transport = trtype;
            wildcard = false;
        }

        //
        // This is ONLY a syntatic check on equality, hostnames are compared as strings!
        //
        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="EndpointPermission.Equals"]/*' />
        public override bool Equals(object obj) {

            EndpointPermission ep = (EndpointPermission)obj;

            if (String.Compare(hostname, ep.hostname, true, CultureInfo.InvariantCulture) != 0) {
                return false;
            }
            if (port != ep.port) {
                return false;
            }
            if (transport != ep.transport) {
                return false;
            }
            return true;
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="EndpointPermission.GetHashCode"]/*' />
        public override int GetHashCode() {
            return ToString().GetHashCode();
        }

        //
        // Consider V.Next
        //
        // This isn't required if we use HostNameType
        //

        internal bool IsDns {
            get {
                if (IsValidWildcard) {
                    return false;
                }
                return CheckEndPointName(hostname) == EndPointType.DnsOrWildcard;
            }
        }


        //
        // In this version wildcards are only allowed over IP ranges
        // not DNS names. For example "*.microsoft.com" is not allowed
        // A valid wildcard will have exactly three periods
        //IPv6 wildcards are NOT supported
        //
        private bool IsValidWildcard {
            get {

                int len = hostname.Length;

                //
                // Check minimum length
                //

                if (len < 3) {
                    return false;
                }

                //
                // First and last characters cannot be periods
                //

                if ((hostname[0] == '.') || (hostname[len - 1] == '.')) {
                    return false;
                }

                int dotCount = 0;
                int anyCount = 0;

                for (int i = 0; i < hostname.Length; i++) {
                    if (hostname[i] == '.') {
                        dotCount++;
                    }
                    else if (hostname[i] == '*') {
                        ++anyCount;
                    }
                    else if (!Char.IsDigit(hostname[i])) {  // Not a digit?
                        return false;                       // Reject wildcard
                    }
                }
                return (dotCount == 3) && (anyCount > 0);
            }
        }

        internal bool MatchAddress(EndpointPermission e) {

            // For Asp.Net config we made it valid empty string in a hostname,
            // but it will match to nothing.
            if(this.Hostname.Length == 0 || e.Hostname.Length == 0) {
                return false;
            }

            //
            // This is a fix for INADDR_ANY in Bind()
            // if this.Hostname == "0.0.0.0" then it matches only to e.Hostname="*.*.*.*"
            //
            // The reason is to not pass "0.0.0.0" into Resolve()
            if(this.Hostname.Equals("0.0.0.0"))
            {
                if(e.Hostname.Equals("*.*.*.*") || e.Hostname.Equals("0.0.0.0"))
                    return true;
                return false;
            }

            if (IsDns && e.IsDns) {

                //
                // Consider V.Next
                //
                // This should just be == if we know these are both DNS
                // names. Use HostNameType
                //

                return (String.Compare(hostname, e.hostname, true, CultureInfo.InvariantCulture) == 0);
            }
            Resolve();
            e.Resolve();

            //
            // if Resolve() didn't work for some reason then we're out of luck
            //

            if (((address == null) && !wildcard) || ((e.address == null) && !e.wildcard)) {
                return false;
            }

            //
            // try matching IP addresses against other wildcard address(es) or
            // wildcard
            //

            if (this.wildcard && !e.wildcard) {
                return false;                           // as a wildcard I cannot be subset of a host.

            }
            else if (e.wildcard) {
                if (this.wildcard) {
                    // check against my _wildcard_
                    if (MatchWildcard(e.hostname)) {
                        return true;
                    }
                }
                else {
                    // check against my _addresses_
                    for (int i = 0; i < address.Length; ++i) {
                        if (e.MatchWildcard(address[i].ToString())) {
                            return true;
                        }
                    }
                }
            } else {
                //both are _not_ wildcards
                for (int i = 0; i < address.Length; ++i) {
                    for (int j = 0; j < e.address.Length; ++j) {
                        if (address[i].Equals(e.address[j])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        internal bool MatchWildcard(string str) {

            string [] wcPieces = hostname.Split(DotSeparator);
            string [] strPieces = str.Split(DotSeparator);

            if ((strPieces.Length != 4) || (wcPieces.Length != 4)) {
                return false;
            }
            for (int i = 0; i < 4; i++) {
                if ((strPieces[i] != wcPieces[i]) && (wcPieces[i] != "*")) {
                    return false;
                }
            }
            return true;
        }

        internal void Resolve() {

            //
            // if we already resolved this name then don't do it again
            //

            if (cached) {
                return;
            }

            //
            // IP wildcards are not resolved
            //

            if (wildcard) {
                return;
            }

            //
            // IP addresses with wildcards are allowed in permissions
            //

            if (IsValidWildcard) {
                wildcard = true;
                cached = true;
                return;
            }
            try {

                //
                // Check if the permission was specified as numeric IP,
                // "InetAddr" function will resolve it, otherwise it will
                // throw an exception that we catch below
                //

                IPAddress ipaddr = IPAddress.Parse(hostname);

                address = new IPAddress[1];
                address[0] = ipaddr;
                cached = true;
                return;
            }
            catch (SecurityException) {
                throw;
            }
            catch {
                // ignore first exception
            }

            //
            // Not numeric: use GetHostByName to determine addresses
            //

            try {
                IPHostEntry hostInfo = Dns.GetHostByName(hostname);

                address = hostInfo.AddressList;

                // NB: It never caches DNS responses
                //

            }
            catch (SecurityException) {
                throw;
            }
            catch {
                // ignore second exception
            }
        }

        internal bool SubsetMatch(EndpointPermission e) {
            return ((transport == e.transport) || (e.transport == TransportType.All))
                    && ((port == e.port) || (e.port == SocketPermission.AllPorts) || port == SocketPermission.AnyPort)
                    && MatchAddress(e);
        }

        /// <include file='doc\SocketPermission.uex' path='docs/doc[@for="EndpointPermission.ToString"]/*' />
        public override String ToString() {
            return hostname + encSeperator + port + encSeperator + ((int)transport).ToString();
        }

        internal EndpointPermission Intersect(EndpointPermission E) {

            String commonName=null;
            TransportType commonTransport;
            int commonPort;

            //
            // Look at the transport
            //

            if (transport == E.transport) {           // same transport
                commonTransport = transport;
            }
            // NO: check if one of the permissions authorize all transports
            else if (transport == TransportType.All) {
                commonTransport = E.transport;
            }
            else if (E.transport == TransportType.All) {
                commonTransport = transport;
            }
            else {   // transport dont match-- intersection is empty
                return null;
            }

            //
            // Determine common port
            //

            if (port == E.port) {
                commonPort = port;
            }
            else if (port == SocketPermission.AllPorts) {
                commonPort = E.port;
            }
            else if (E.port == SocketPermission.AllPorts) {
                commonPort = port;
            }
            else {
                return null;
            }

            //Work out common hostname part
            //
            // This is a fix for INADDR_ANY in Bind()
            // if this.Hostname == "0.0.0.0" then it matches only to e.Hostname="*.*.*.*"
            //
            // The reason is to not pass "0.0.0.0" into Resolve()
            if(this.Hostname.Equals("0.0.0.0"))
            {
                if(E.Hostname.Equals("*.*.*.*") || E.Hostname.Equals("0.0.0.0"))
                    commonName = this.Hostname;//i.e. 0.0.0.0
                else
                    return null;
            }
            else if(E.Hostname.Equals("0.0.0.0"))
            {
                if(this.Hostname.Equals("*.*.*.*") || this.Hostname.Equals("0.0.0.0"))
                    commonName = E.Hostname; //i.e. 0.0.0.0
                else
                    return null;
            }
            else if (IsDns && E.IsDns) {
                //
                // If both are DNS names we compare names as strings
                //
                if(String.Compare(hostname, E.hostname, true, CultureInfo.InvariantCulture) != 0) {
                    return null;
                }
                else {
                    commonName = hostname;
                }
            }
            else
            {
                Resolve();
                E.Resolve();
                //after this step we got both clases updated with valid
                //wildcard and address members. It's safe now to access those members directly

                //
                // if Resolve() didn't work for some reason then we're out of luck
                //

                if (((address == null) && !wildcard) || ((E.address == null) && !E.wildcard)) {
                    return null;
                }


                //
                // Find intersection of address lists
                if(wildcard && E.wildcard) {
                    string [] wcPieces = hostname.Split(DotSeparator);
                    string [] strPieces = E.hostname.Split(DotSeparator);
                    string  result="";

                    if ((strPieces.Length != 4) || (wcPieces.Length != 4)) {
                        return null;
                    }
                    for (int i = 0; i < 4; i++) {
                        if(i != 0) {
                            result+=".";
                        }
                        if (strPieces[i] == wcPieces[i]) {
                            result+=strPieces[i];
                        }
                        else
                        if (strPieces[i] == "*") {
                            result+=wcPieces[i];
                        }
                        else
                        if (wcPieces[i] == "*") {
                            result+=strPieces[i];
                        }
                        else
                            return null;
                    }
                    commonName = result;
                }else
                if (wildcard) {                                                 //if ME is a wildcard
                    //
                    //
                    // Check for wildcard IP matching
                    //
                    for (int i = 0; i < E.address.Length; ++i) {
                        if (MatchWildcard(E.address[i].ToString())) {
                            commonName = E.hostname;    //SHE fits into my wildcard
                            break;
                        }
                    }
                }
                else if (E.wildcard) {                                   //if SHE is a wildcard
                    for (int i = 0; i < address.Length; ++i) {
                        if (E.MatchWildcard(address[i].ToString())) {
                            commonName = hostname;      //ME fit  into her wildcard
                            break;
                        }
                    }
                }
                else
                {
                    //
                    // Not wildcard: check aginst  IP addresses list
                    //

                    if (address == E.address) {                 // they both are NOT null (already checked)
                        commonName = hostname;
                    }

                    //
                    // Search the IP addresses for match
                    //
                    for (int i = 0; commonName == null && i < address.Length; i++) {
                        for (int k = 0; k < E.address.Length; k++) {
                            if (address[i].Equals(E.address[k])) {
                                commonName = hostname;
                                break;
                            }
                        }
                    }
                }
                if(commonName == null) {
                    return null;
                }
            }

            return new EndpointPermission(commonName, commonPort, commonTransport);
        }
/*
FROM RFC 952
------------
ASSUMPTIONS
1   A "name" (Net, Host, Gateway, or Domain name) is a text string up
    to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus sign (-), and period (.).
    Note that periods are only allowed when they serve to delimit components of "domain style names".
    (See RFC-921, "Domain Name System Implementation Schedule", for background).
    No blank or space characters are permitted as part of a name.
    No distinction is made between upper and lower case.
    The first character must be an alpha character.
    The last character must not be a minus sign or period.
    Single character names or nicknames are not allowed.

    Implementaion below is relaxed in terms of:
    - Hostname may start with a digit (as per RFC1123 )
    - Hostname may contain '_' character (historical Inet issue)
    - Hostname may be a sinle-character string (historical Inet issue)
    - Hostname may contain '*' as a wildcard for an EndPointPermission
    - Hostname may be empty (to support config templates)
    - Hostname may be an IPv6 string comprised of A-F, 0-9, '.', ':', and '%' chars
*/
    private enum EndPointType {
            Invalid,
            IPv6,
            DnsOrWildcard,
            IPv4
    };

    private static EndPointType CheckEndPointName(string name) {
        if (name == null) {
            return EndPointType.Invalid;
        }
        bool isIPv6       = false;
        bool isDnsOrWC    = false;
        bool isHexLetter  = false;
        for(int i=0; i < name.Length; ++i) {
            char ch = name[i];
            switch(ch) {
            case '.':   //note _all_ dots name is an error
                        continue;
            case '-':   //if _all_ chars are those we call Dns (to confirm error)
            case '_':
            case '*':   isDnsOrWC = true;
                        continue;
            case ':':
            case '%':   isIPv6 = true;
                        continue;
            default:    break;
            }

            //Check on letters but NOT hex digits
            if ((ch > 'f' && ch <= 'z') || (ch > 'F' && ch <= 'Z')) {
                isDnsOrWC = true;
                continue;
            }
            //Check on HEX letters
            if((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F')) {
                isHexLetter = true;
                continue;
            }
            //Here only digits left (others are invalid)
            if (!(ch >= '0' && ch <= '9'))
                return EndPointType.Invalid;
        }

        // The logic is (solely for the purpose of SocketPermssion class)
        //  isIPv6 && isDnsOrWC   = EndPointType.Invalid
        //  isIPv6 && !isDnsOrWC  = EndPointType.IPv6
        //  !isIPv6 && isDnsOrWC  = EndPointType.DnsOrWildcard
        //  !isIPv6 && !isDnsOrWC && isHexLetter = EndPointType.DnsOrWildcard;
        //  else = EndPointType.IPv4
        return isIPv6 ? (isDnsOrWC? EndPointType.Invalid: EndPointType.IPv6)
                      : (isDnsOrWC? EndPointType.DnsOrWildcard :
                                    isHexLetter? EndPointType.DnsOrWildcard :EndPointType.IPv4);
    }


    } // class EndpointPermission


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\webexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Net {
    using System;
    using System.Runtime.Serialization;

    /*++

    Copyright (c) 2000 Microsoft Corporation

    Abstract:

        Contains the defintion for the WebException object. This is a subclass of
        Exception that contains a WebExceptionStatus and possible a reference to a
        WebResponse.


    Author:

        Henry Sanders (henrysa) 03-Feb-2000

    Revision History:

        03-Feb-2000 henrysa
            Created

    --*/


    /*++

        WebException - The WebException class

        This is the exception that is thrown by WebRequests when something untoward
        happens. It's a subclass of WebException that contains a WebExceptionStatus and possibly
        a reference to a WebResponse. The WebResponse is only present if we actually
        have a response from the remote server.

    --*/

    /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides network communication exceptions to the application.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public class WebException : InvalidOperationException, ISerializable {

        private WebExceptionStatus m_Status = WebExceptionStatus.UnknownError; //Should be changed to GeneralFailure;
        private WebResponse m_Response;

        /*++

            Constructor - default.

            This is the default constructor.

            Input: Nothing

            Returns: Nothing.

        --*/

        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.WebException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebException'/>
        ///       class with the default status
        ///    <see langword='Error'/> from the
        ///    <see cref='System.Net.WebExceptionStatus'/> values.
        ///    </para>
        /// </devdoc>
        public WebException() {

        }

        /*++

            Constructor - string.

            This is the constructor used when just a message string is to be
            given.

            Input:

                    Message         - Message string for exception.

            Returns: Nothing.

        --*/

        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.WebException1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebException'/> class with the specified error
        ///       message.
        ///    </para>
        /// </devdoc>
        public WebException(string message) : base(message) {
        }

        /*++

            Constructor - string and inner exception.

            This is the constructor used when a message string and inner
            exception are provided.

            Input:

                    Message         - Message string for exception.
                    InnerException  - Exception that caused this exception.

            Returns: Nothing.

        --*/

        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.WebException2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebException'/> class with the specified error
        ///       message and nested exception.
        ///    </para>
        /// </devdoc>
        public WebException(string message, Exception innerException) :
            base(message, innerException) {

        }

        /*++

             Constructor - string and net status.

             This is the constructor used when a message string and WebExceptionStatus
             is provided.

             Input:

                     Message         - Message string for exception.
                     Status          - Network status of exception

             Returns: Nothing.

         --*/

        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.WebException3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebException'/> class with the specified error
        ///       message and status.
        ///    </para>
        /// </devdoc>
        public WebException(string message, WebExceptionStatus status) : base(message) {
            m_Status = status;
        }

        /*++

             Constructor - The whole thing.

             This is the full version of the constructor. It takes a string,
             inner exception, WebExceptionStatus, and WebResponse.

             Input:

                     Message         - Message string for exception.
                     InnerException  - The exception that caused this one.
                     Status          - Network status of exception
                     Response        - The WebResponse we have.

             Returns: Nothing.

         --*/

        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.WebException4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebException'/> class with the specified error
        ///       message, nested exception, status and response.
        ///    </para>
        /// </devdoc>
        public WebException(string message,
                            Exception innerException,
                            WebExceptionStatus status,
                            WebResponse response) :
            base(message, innerException) {

            m_Status = status;
            m_Response = response;

        }


        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.WebException5"]/*' />
        protected WebException(SerializationInfo serializationInfo, StreamingContext streamingContext)
            : base(serializationInfo, streamingContext) {
        }

        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            base.GetObjectData(serializationInfo, streamingContext);
        }

        /*++

            Status - Return the status code.

            This is the property that returns the WebExceptionStatus code.

            Input: Nothing

            Returns: The WebExceptionStatus code.

        --*/

        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.Status"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the status of the response.
        ///    </para>
        /// </devdoc>
        public WebExceptionStatus Status {
            get {
                return m_Status;
            }
        }

        /*++

            Response - Return the WebResponse object.

            This is the property that returns the WebResponse object.

            Input: Nothing

            Returns: The WebResponse object.

        --*/

        /// <include file='doc\WebException.uex' path='docs/doc[@for="WebException.Response"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the error message returned from the remote host.
        ///    </para>
        /// </devdoc>
        public WebResponse Response {
            get {
                return m_Response;
            }
        }

    }; // class WebException


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\webclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="webclient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Text;
    using System.Globalization;

    /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [ComVisible(true)]
    //public sealed class WebClient : IComponent {
    public sealed class WebClient : Component {

    // fields

        const int DefaultCopyBufferLength = 8192;
        const int DefaultDownloadBufferLength = 65536;
        const string DefaultUploadFileContentType = "application/octet-stream";
        const string UploadFileContentType = "multipart/form-data";
        const string UploadValuesContentType = "application/x-www-form-urlencoded";

        Uri m_baseAddress;
        ICredentials m_credentials;
        WebHeaderCollection m_headers;
        NameValueCollection m_requestParameters;
        WebHeaderCollection m_responseHeaders;

    // constructors

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.WebClient"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebClient() {
        }

    // properties

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.BaseAddress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string BaseAddress {
            get {
                return (m_baseAddress == null) ? String.Empty : m_baseAddress.ToString();
            }
            set {
                if ((value == null) || (value.Length == 0)) {
                    m_baseAddress = null;
                } else {
                    try {
                        m_baseAddress = new Uri(value);
                    } catch (Exception e) {
                        throw new ArgumentException("value", e);
                    }
                }
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.Credentials"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICredentials Credentials {
            get {
                return m_credentials;
            }
            set {
                m_credentials = value;
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.Headers"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebHeaderCollection Headers {
            get {
                if (m_headers == null) {
                    m_headers = new WebHeaderCollection();
                }
                return m_headers;
            }
            set {
                m_headers = value;
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.QueryString"]/*' />
        public NameValueCollection QueryString {
            get {
                if (m_requestParameters == null) {
                    m_requestParameters = new NameValueCollection();
                }
                return m_requestParameters;
            }
            set {
                m_requestParameters = value;
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.ResponseHeaders"]/*' />
        public WebHeaderCollection ResponseHeaders {
            get {
                return m_responseHeaders;
            }
        }

    // methods

        private void CopyHeadersTo(WebRequest request) {
            if ((m_headers != null) && (request is HttpWebRequest))  {

                string accept = m_headers[HttpKnownHeaderNames.Accept];
                string connection = m_headers[HttpKnownHeaderNames.Connection];
                string contentType = m_headers[HttpKnownHeaderNames.ContentType];
                string expect = m_headers[HttpKnownHeaderNames.Expect];
                string referrer = m_headers[HttpKnownHeaderNames.Referer];
                string userAgent = m_headers[HttpKnownHeaderNames.UserAgent];

                m_headers.RemoveInternal(HttpKnownHeaderNames.Accept);
                m_headers.RemoveInternal(HttpKnownHeaderNames.Connection);
                m_headers.RemoveInternal(HttpKnownHeaderNames.ContentType);
                m_headers.RemoveInternal(HttpKnownHeaderNames.Expect);
                m_headers.RemoveInternal(HttpKnownHeaderNames.Referer);
                m_headers.RemoveInternal(HttpKnownHeaderNames.UserAgent);
                request.Headers = m_headers;
                if ((accept != null) && (accept.Length > 0)) {
                    ((HttpWebRequest)request).Accept = accept;
                }
                if ((connection != null) && (connection.Length > 0)) {
                    ((HttpWebRequest)request).Connection = connection;
                }
                if ((contentType != null) && (contentType.Length > 0)) {
                    ((HttpWebRequest)request).ContentType = contentType;
                }
                if ((expect != null) && (expect.Length > 0)) {
                    ((HttpWebRequest)request).Expect = expect;
                }
                if ((referrer != null) && (referrer.Length > 0)) {
                    ((HttpWebRequest)request).Referer = referrer;
                }
                if ((userAgent != null) && (userAgent.Length > 0)) {
                    ((HttpWebRequest)request).UserAgent = userAgent;
                }
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.DownloadData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] DownloadData(string address) {
            try {
                m_responseHeaders = null;

                WebRequest request = WebRequest.Create(GetUri(address));

                request.Credentials = Credentials;
                CopyHeadersTo(request);

                WebResponse response = request.GetResponse();

                m_responseHeaders = response.Headers;
                return ResponseAsBytes(response);
            } catch (Exception e) {
                if ((e is WebException) || (e is SecurityException)) {
                    throw;
                }
                throw new WebException(SR.GetString(SR.net_webclient), e);
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.DownloadFile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void DownloadFile(string address, string fileName) {

            FileStream fs = null;
            bool succeeded = false;

            try {
                m_responseHeaders = null;

                fs = new FileStream(fileName, FileMode.Create, FileAccess.Write);
                WebRequest request = WebRequest.Create(GetUri(address));

                request.Credentials = Credentials;
                CopyHeadersTo(request);

                WebResponse response = request.GetResponse();

                m_responseHeaders = response.Headers;

                long length = response.ContentLength;

                length = (length == -1 || length > Int32.MaxValue) ? Int32.MaxValue : length;

                byte[] buffer = new byte[Math.Min(DefaultCopyBufferLength, (int)length)];

                using (Stream s = response.GetResponseStream()) {

                    int nread;

                    do {
                        nread = s.Read(buffer, 0, (int)buffer.Length);
                        fs.Write(buffer, 0, nread);
                    } while (nread != 0);
                }
                succeeded = true;
            } catch (Exception e) {
                if ((e is WebException) || (e is SecurityException)) {
                    throw;
                }
                throw new WebException(SR.GetString(SR.net_webclient), e);
            } finally {
                if (fs != null) {
                    fs.Close();
                    fs = null;
                }
                if (!succeeded) {

                    //
                    // delete the file if we failed to download the content for
                    // whatever reason
                    //

                    try {
                        File.Delete(fileName);
                    } catch {
                    }
                }
            }
        }

        private Uri GetUri(string path) {

            Uri uri;

            try {
                if (m_baseAddress != null) {
                    uri = new Uri(m_baseAddress, path);
                } else {
                    uri = new Uri(path);
                }
                if (m_requestParameters != null) {

                    StringBuilder sb = new StringBuilder();
                    string delimiter = String.Empty;

                    for (int i = 0; i < m_requestParameters.Count; ++i) {
                        sb.Append(delimiter
                                  + m_requestParameters.AllKeys[i]
                                  + "="
                                  + m_requestParameters[i]
                                  );
                        delimiter = "&";
                    }

                    UriBuilder ub = new UriBuilder(uri);

                    ub.Query = sb.ToString();
                    uri = ub.Uri;
                }
            } catch (UriFormatException) {
                uri = new Uri(Path.GetFullPath(path));
            }
            return uri;
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.OpenRead"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Stream OpenRead(string address) {
            try {
                m_responseHeaders = null;

                WebRequest request = WebRequest.Create(GetUri(address));

                request.Credentials = Credentials;
                CopyHeadersTo(request);

                WebResponse response = request.GetResponse();

                m_responseHeaders = response.Headers;
                return response.GetResponseStream();
            } catch (Exception e) {
                if ((e is WebException) || (e is SecurityException)) {
                    throw;
                }
                throw new WebException(SR.GetString(SR.net_webclient), e);
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.OpenWrite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Stream OpenWrite(string address) {
            return OpenWrite(address, "POST");
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.OpenWrite1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Stream OpenWrite(string address, string method) {
            try {
                m_responseHeaders = null;

                Uri uri = GetUri(address);

                WebRequest request = WebRequest.Create(uri);

                request.Credentials = Credentials;
                CopyHeadersTo(request);
                request.Method = method;
                return new WebClientWriteStream(request.GetRequestStream(), request);
            } catch (Exception e) {
                if ((e is WebException) || (e is SecurityException)) {
                    throw;
                }
                throw new WebException(SR.GetString(SR.net_webclient), e);
            }
        }

        private byte[] ResponseAsBytes(WebResponse response) {

            long length = response.ContentLength;
            bool unknownsize = false;

            if (length == -1) {
                unknownsize = true;
                length = DefaultDownloadBufferLength;
            }

            byte[] buffer = new byte[(int)length];
            Stream s = response.GetResponseStream();
            int nread;
            int offset = 0;

            do {
                nread = s.Read(buffer, offset, (int)length - offset);
                offset += nread;
                if (unknownsize && offset == length) {
                    length += DefaultDownloadBufferLength;

                    byte[] newbuf = new byte[(int)length];

                    Buffer.BlockCopy(buffer, 0, newbuf, 0, offset);

                    buffer = newbuf;
                }
            } while (nread != 0);
            s.Close();
            if (unknownsize) {
                byte[] newbuf = new byte[offset];
                Buffer.BlockCopy(buffer, 0, newbuf, 0, offset);
                buffer = newbuf;
            }
            return buffer;
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.UploadData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] UploadData(string address, byte[] data) {
            return UploadData(address, "POST", data);
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.UploadData1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] UploadData(string address, string method, byte[] data) {
            try {
                m_responseHeaders = null;

                WebRequest request = WebRequest.Create(GetUri(address));

                request.Credentials = Credentials;
                CopyHeadersTo(request);
                request.Method = method;
                request.ContentLength = data.Length;

                using (Stream s = request.GetRequestStream()) {
                    s.Write(data, 0, data.Length);
                }

                WebResponse response = request.GetResponse();

                m_responseHeaders = response.Headers;
                return ResponseAsBytes(response);
            } catch (Exception e) {
                if ((e is WebException) || (e is SecurityException)) {
                    throw;
                }
                throw new WebException(SR.GetString(SR.net_webclient), e);
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.UploadFile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] UploadFile(string address, string fileName) {
            return UploadFile(address, "POST", fileName);
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.UploadFile1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] UploadFile(string address, string method, string fileName) {

            FileStream fs = null;

            try {
                fileName = Path.GetFullPath(fileName);

                string boundary = "---------------------" + DateTime.Now.Ticks.ToString("x");

                if (m_headers == null) {
                    m_headers = new WebHeaderCollection();
                }

                string contentType = m_headers[HttpKnownHeaderNames.ContentType];

                if (contentType != null) {
                    if (contentType.ToLower(CultureInfo.InvariantCulture).StartsWith("multipart/")) {
                        throw new WebException(SR.GetString(SR.net_webclient_Multipart));
                    }
                } else {
                    contentType = DefaultUploadFileContentType;
                }
                m_headers[HttpKnownHeaderNames.ContentType] = UploadFileContentType + "; boundary=" + boundary;
                m_responseHeaders = null;

                fs = new FileStream(fileName, FileMode.Open, FileAccess.Read);
                WebRequest request = WebRequest.Create(GetUri(address));

                request.Credentials = Credentials;
                CopyHeadersTo(request);
                request.Method = method;

                string formHeader = "--" + boundary + "\r\n"
                                  + "Content-Disposition: form-data; name=\"file\"; filename=\"" + Path.GetFileName(fileName) + "\"\r\n"
                                  + "Content-Type: " + contentType + "\r\n"
                                  + "\r\n";
                byte[] formHeaderBytes = Encoding.UTF8.GetBytes(formHeader);
                byte[] boundaryBytes = Encoding.ASCII.GetBytes("\r\n--" + boundary + "\r\n");

                long length = Int64.MaxValue;

                try {
                    length = fs.Length;
                    request.ContentLength = length + formHeaderBytes.Length + boundaryBytes.Length;
                } catch {
                    // ignore - can't get content-length from file stream
                }

                byte[] buffer = new byte[Math.Min(DefaultCopyBufferLength, (int)length)];

                using (Stream s = request.GetRequestStream()) {
                    s.Write(formHeaderBytes, 0, formHeaderBytes.Length);

                    int nread;

                    do {
                        nread = fs.Read(buffer, 0, (int)buffer.Length);
                        if (nread != 0) {
                            s.Write(buffer, 0, nread);
                        }
                    } while (nread != 0);
                    s.Write(boundaryBytes, 0, boundaryBytes.Length);
                }
                fs.Close();
                fs = null;

                WebResponse response = request.GetResponse();

                m_responseHeaders = response.Headers;
                return ResponseAsBytes(response);
            } catch (Exception e) {
                if (fs != null) {
                    fs.Close();
                    fs = null;
                }
                if ((e is WebException) || (e is SecurityException)) {
                    throw;
                }
                throw new WebException(SR.GetString(SR.net_webclient), e);
            }
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.UploadValues"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] UploadValues(string address, NameValueCollection data) {
            return UploadValues(address, "POST", data);
        }

        /// <include file='doc\webclient.uex' path='docs/doc[@for="WebClient.UploadValues1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] UploadValues(string address, string method, NameValueCollection data) {
            try {
                m_responseHeaders = null;
                if (m_headers == null) {
                    m_headers = new WebHeaderCollection();
                }

                string contentType = m_headers[HttpKnownHeaderNames.ContentType];

                if ((contentType != null) && (String.Compare(contentType, UploadValuesContentType, true, CultureInfo.InvariantCulture) != 0)) {
                    throw new WebException(SR.GetString(SR.net_webclient_ContentType));
                }
                m_headers[HttpKnownHeaderNames.ContentType] = UploadValuesContentType;

                WebRequest request = WebRequest.Create(GetUri(address));

                request.Credentials = Credentials;
                CopyHeadersTo(request);
                request.Method = method;

                using (Stream s = request.GetRequestStream()) {
                    using (StreamWriter sw = new StreamWriter(s, Encoding.ASCII)) {

                        string delimiter = String.Empty;

                        foreach (string name in data.AllKeys) {

                            string value = delimiter + UrlEncode(name) + "=" + UrlEncode(data[name]);

                            sw.Write(value);
                            delimiter = "&";
                        }
                        sw.Write("\r\n");
                    }
                }

                WebResponse response = request.GetResponse();

                m_responseHeaders = response.Headers;
                return ResponseAsBytes(response);
            } catch (Exception e) {
                if ((e is WebException) || (e is SecurityException)) {
                    throw;
                }
                throw new WebException(SR.GetString(SR.net_webclient), e);
            }
        }

        private static string UrlEncode(string str) {
            if (str == null)
                return null;
            return UrlEncode(str, Encoding.UTF8);
        }

        private static string UrlEncode(string str, Encoding e) {
            if (str == null)
                return null;
            return Encoding.ASCII.GetString(UrlEncodeToBytes(str, e));
        }

        private static byte[] UrlEncodeToBytes(string str, Encoding e) {
            if (str == null)
                return null;
            byte[] bytes = e.GetBytes(str);
            return UrlEncodeBytesToBytesInternal(bytes, 0, bytes.Length, false);
        }

        private static byte[] UrlEncodeBytesToBytesInternal(byte[] bytes, int offset, int count, bool alwaysCreateReturnValue) {
            int cSpaces = 0;
            int cUnsafe = 0;

            // count them first
            for (int i = 0; i < count; i++) {
                char ch = (char)bytes[offset+i];

                if (ch == ' ')
                    cSpaces++;
                else if (!IsSafe(ch))
                    cUnsafe++;
            }

            // nothing to expand?
            if (!alwaysCreateReturnValue && cSpaces == 0 && cUnsafe == 0)
                return bytes;

            // expand not 'safe' characters into %XX, spaces to +s
            byte[] expandedBytes = new byte[count + cUnsafe*2];
            int pos = 0;

            for (int i = 0; i < count; i++) {
                byte b = bytes[offset+i];
                char ch = (char)b;

                if (IsSafe(ch)) {
                    expandedBytes[pos++] = b;
                }
                else if (ch == ' ') {
                    expandedBytes[pos++] = (byte)'+';
                }
                else {
                    expandedBytes[pos++] = (byte)'%';
                    expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);
                    expandedBytes[pos++] = (byte)IntToHex(b & 0x0f);
                }
            }

            return expandedBytes;
        }

        private static char IntToHex(int n) {
            Debug.Assert(n < 0x10);

            if (n <= 9)
                return(char)(n + (int)'0');
            else
                return(char)(n - 10 + (int)'a');
        }

        private static bool IsSafe(char ch) {
            if (ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')
                return true;

            switch (ch) {
                case '-':
                case '_':
                case '.':
                case '!':
                case '*':
                case '\'':
                case '(':
                case ')':
                    return true;
            }

            return false;
        }
    }

    class WebClientWriteStream : Stream {

        private WebRequest m_request;
        private Stream m_stream;

        public WebClientWriteStream(Stream stream, WebRequest request) {
            m_request = request;
            m_stream = stream;
        }

        public override bool CanRead {
            get {
                return m_stream.CanRead;
            }
        }

        public override bool CanSeek {
            get {
                return m_stream.CanSeek;
            }
        }

        public override bool CanWrite {
            get {
                return m_stream.CanWrite;
            }
        }

        public override long Length {
            get {
                return m_stream.Length;
            }
        }

        public override long Position {
            get {
                return m_stream.Position;
            }
            set {
                m_stream.Position = value;
            }
        }

        public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback callback, object state) {
            return m_stream.BeginRead(buffer, offset, size, callback, state);
        }

        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int size, AsyncCallback callback, object state ) {
            return m_stream.BeginWrite(buffer, offset, size, callback, state);
        }

        public override void Close() {
            m_stream.Close();
            m_request.GetResponse().Close();
        }

        public override int EndRead(IAsyncResult result) {
            return m_stream.EndRead(result);
        }

        public override void EndWrite(IAsyncResult result) {
            m_stream.EndWrite(result);
        }

        public override void Flush() {
            m_stream.Flush();
        }

        public override int Read(byte[] buffer, int offset, int count) {
            return m_stream.Read(buffer, offset, count);
        }

        public override long Seek(long offset, SeekOrigin origin) {
            return m_stream.Seek(offset, origin);
        }

        public override void SetLength(long value) {
            m_stream.SetLength(value);
        }

        public override void Write(byte[] buffer, int offset, int count) {
            m_stream.Write(buffer, offset, count);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\webresponse.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Net {

    using System.Collections;
    using System.IO;
    using System.Runtime.Serialization;

    /*++

        WebResponse - The abstract base class for all WebResponse objects.


    --*/

    /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse"]/*' />
    /// <devdoc>
    ///    <para>
    ///       A
    ///       response from a Uniform Resource Indentifier (Uri). This is an abstract class.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public abstract class WebResponse : MarshalByRefObject, ISerializable, IDisposable {
        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.WebResponse"]/*' />
        /// <devdoc>
        ///    <para>Initializes a new
        ///       instance of the <see cref='System.Net.WebResponse'/>
        ///       class.</para>
        /// </devdoc>
        protected WebResponse() {
        }

        //
        // ISerializable constructor
        //
        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.WebResponse1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        //
        // ISerializable method
        //
        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            throw ExceptionHelper.MethodNotImplementedException;
        }


        /*++

            Close - Closes the Response after the use.

            This causes the read stream to be closed.

        --*/

        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.Close"]/*' />
        public virtual void Close() {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Close();
        }

        /*++

            ContentLength - Content length of response.

            This property returns the content length of the response.

        --*/

        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets or
        ///       sets
        ///       the content length of data being received.</para>
        /// </devdoc>
        public virtual long ContentLength {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }


        /*++

            ContentType - Content type of response.

            This property returns the content type of the response.

        --*/

        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.ContentType"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       gets
        ///       or sets the content type of the data being received.</para>
        /// </devdoc>
        public virtual string ContentType {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        /*++

            ResponseStream  - Get the response stream for this response.

            This property returns the response stream for this WebResponse.

            Input: Nothing.

            Returns: Response stream for response.

                    read-only

        --*/

        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.GetResponseStream"]/*' />
        /// <devdoc>
        /// <para>When overridden in a derived class, returns the <see cref='System.IO.Stream'/> object used
        ///    for reading data from the resource referenced in the <see cref='System.Net.WebRequest'/>
        ///    object.</para>
        /// </devdoc>
        public virtual Stream GetResponseStream() {
            throw ExceptionHelper.MethodNotImplementedException;
        }


        /*++

            ResponseUri  - Gets the final Response Uri, that includes any
             changes that may have transpired from the orginal request

            This property returns Uri for this WebResponse.

            Input: Nothing.

            Returns: Response Uri for response.

                    read-only

        --*/

        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.ResponseUri"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets the Uri that
        ///       actually responded to the request.</para>
        /// </devdoc>
        public virtual Uri ResponseUri {
            // read-only
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        /*++

            Headers  - Gets any request specific headers associated
             with this request, this is simply a name/value pair collection

            Input: Nothing.

            Returns: This property returns WebHeaderCollection.

                    read-only

        --*/

        /// <include file='doc\WebResponse.uex' path='docs/doc[@for="WebResponse.Headers"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets
        ///       a collection of header name-value pairs associated with this
        ///       request.</para>
        /// </devdoc>
        public virtual WebHeaderCollection Headers {
            // read-only
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }


    }; // class WebResponse


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\webrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Collections;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Configuration;
    using System.Globalization;
    
    //
    // WebRequest - the base class of all Web resource/protocol objects. Provides
    // common methods, data and proprties for making the top level request
    //

    /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest"]/*' />
    /// <devdoc>
    ///    <para>A request to a Uniform Resource Identifier (Uri). This
    ///       is an abstract class.</para>
    /// </devdoc>
    [Serializable]
    public abstract class WebRequest : MarshalByRefObject, ISerializable {

        internal const int DefaultTimeout = 100000; // default timeout is 100 seconds (ASP .NET is 90 seconds)
        private static ArrayList s_PrefixList;
        

        /*++

            Create - Create a WebRequest.

            This is the main creation routine. We take a Uri object, look
            up the Uri in the prefix match table, and invoke the appropriate
            handler to create the object. We also have a parameter that
            tells us whether or not to use the whole Uri or just the
            scheme portion of it.

            Input:

                RequestUri          - Uri object for request.
                UseUriBase          - True if we're only to look at the scheme
                                        portion of the Uri.

            Returns:

                Newly created WebRequest.
        --*/

        private static WebRequest Create(Uri requestUri, bool useUriBase) {
            string LookupUri;
            WebRequestPrefixElement Current = null;
            bool Found = false;

            if (!useUriBase) {
                LookupUri = requestUri.AbsoluteUri;
            }
            else {

                //
                // schemes are registered as <schemeName>":", so add the separator
                // to the string returned from the Uri object
                //

                LookupUri = requestUri.Scheme + ':';
            }

            int LookupLength = LookupUri.Length;

            // Copy the prefix list so that if it is updated it will
            // not affect us on this thread.

            ArrayList prefixList = PrefixList;

            // Look for the longest matching prefix.

            // Walk down the list of prefixes. The prefixes are kept longest
            // first. When we find a prefix that is shorter or the same size
            // as this Uri, we'll do a compare to see if they match. If they
            // do we'll break out of the loop and call the creator.

            for (int i = 0; i < prefixList.Count; i++) {
                Current = (WebRequestPrefixElement)prefixList[i];

                //
                // See if this prefix is short enough.
                //

                if (LookupLength >= Current.Prefix.Length) {

                    //
                    // It is. See if these match.
                    //

                    if (String.Compare(Current.Prefix,
                                       0,
                                       LookupUri,
                                       0,
                                       Current.Prefix.Length,
                                       true, 
                                       CultureInfo.InvariantCulture) == 0) {

                        //
                        // These match. Remember that we found it and break
                        // out.
                        //

                        Found = true;
                        break;
                    }
                }
            }

            if (Found) {

                //
                // We found a match, so just call the creator and return what it
                // does.
                //

                return Current.Creator.Create(requestUri);
            }

            //
            // Otherwise no match, throw an exception.
            //

            throw new NotSupportedException(SR.GetString(SR.net_unknown_prefix));
        }

        /*++

            Create - Create a WebRequest.

            An overloaded utility version of the real Create that takes a
            string instead of an Uri object.


            Input:

                RequestString       - Uri string to create.

            Returns:

                Newly created WebRequest.
        --*/

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.Create"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new <see cref='System.Net.WebRequest'/>
        ///       instance for
        ///       the specified Uri scheme.
        ///    </para>
        /// </devdoc>
        public static WebRequest Create(string requestUriString) {
            if (requestUriString == null) {
                throw new ArgumentNullException("requestUriString");
            }
            return Create(new Uri(requestUriString), false);
        }

        /*++

            Create - Create a WebRequest.

            Another overloaded version of the Create function that doesn't
            take the UseUriBase parameter.

            Input:

                RequestUri          - Uri object for request.

            Returns:

                Newly created WebRequest.
        --*/

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.Create1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new <see cref='System.Net.WebRequest'/> instance for the specified Uri scheme.
        ///    </para>
        /// </devdoc>
        public static WebRequest Create(Uri requestUri) {
            if (requestUri == null) {
                throw new ArgumentNullException("requestUri");
            }
            return Create(requestUri, false);
        }

        /*++

            CreateDefault - Create a default WebRequest.

            This is the creation routine that creates a default WebRequest.
            We take a Uri object and pass it to the base create routine,
            setting the useUriBase parameter to true.

            Input:

                RequestUri          - Uri object for request.

            Returns:

                Newly created WebRequest.
        --*/
        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.CreateDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static WebRequest CreateDefault(Uri requestUri) {
            if (requestUri == null) {
                throw new ArgumentNullException("requestUri");
            }
            return Create(requestUri, true);
        }

        /*++

            RegisterPrefix - Register an Uri prefix for creating WebRequests.

            This function registers a prefix for creating WebRequests. When an
            user wants to create a WebRequest, we scan a table looking for a
            longest prefix match for the Uri they're passing. We then invoke
            the sub creator for that prefix. This function puts entries in
            that table.

            We don't allow duplicate entries, so if there is a dup this call
            will fail.

        Input:

            Prefix           - Represents Uri prefix being registered.
            Creator         - Interface for sub creator.

        Returns:

            True if the registration worked, false otherwise.

        --*/
        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.RegisterPrefix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Registers a <see cref='System.Net.WebRequest'/> descendent
        ///       for a specific Uniform Resource Identifier.
        ///    </para>
        /// </devdoc>
        public static bool RegisterPrefix(string prefix, IWebRequestCreate creator) {

            bool Error = false;
            int i;
            WebRequestPrefixElement Current;

            if (prefix == null) {
                throw new ArgumentNullException("prefix");
            }
            if (creator == null) {
                throw new ArgumentNullException("creator");
            }

            new WebPermission(System.Security.Permissions.PermissionState.Unrestricted).Demand();

            // Lock this object, then walk down PrefixList looking for a place to
            // to insert this prefix.

            lock(typeof(WebRequest)) {
                //
                // clone the object and update the clone thus
                // allowing other threads to still read from it
                //

                ArrayList prefixList = (ArrayList) PrefixList.Clone();

                i = 0;

                // The prefix list is sorted with longest entries at the front. We
                // walk down the list until we find a prefix shorter than this
                // one, then we insert in front of it. Along the way we check
                // equal length prefixes to make sure this isn't a dupe.

                while (i < prefixList.Count) {
                    Current = (WebRequestPrefixElement)prefixList[i];

                    // See if the new one is longer than the one we're looking at.

                    if (prefix.Length > Current.Prefix.Length) {
                        // It is. Break out of the loop here.
                        break;
                    }

                    // If these are of equal length, compare them.

                    if (prefix.Length == Current.Prefix.Length) {
                        // They're the same length.
                        if (String.Compare(Current.Prefix, prefix, true, CultureInfo.InvariantCulture) == 0) {
                            // ...and the strings are identical. This is an error.

                            Error = true;
                            break;
                        }
                    }
                    i++;
                }

                // When we get here either i contains the index to insert at or
                // we've had an error, in which case Error is true.

                if (!Error) {
                    // No error, so insert.

                    prefixList.Insert(i,
                                        new WebRequestPrefixElement(prefix, creator)
                                       );

                    //
                    // no error, assign the clone to the static object, other
                    // threads using it will have copied the oriignal object already
                    //
                    PrefixList = prefixList;
                }


            }
            return !Error;
        }

        /*++

            PrefixList - Returns And Initialize our prefix list.


            This is the method that initializes the prefix list. We create
            an ArrayList for the PrefixList, then an HttpRequestCreator object,
            and then we register the HTTP and HTTPS prefixes.

            Input: Nothing

            Returns: true

        --*/
        private static ArrayList PrefixList {

            get { 
                //
                // GetConfig() might use us, so we have a circular dependency issue,
                // that causes us to nest here, we grab the lock, only
                // if we haven't initialized.
                //
                if (s_PrefixList == null) {
                    lock (typeof(WebRequest)) {
                        if (s_PrefixList == null) {
                            GlobalLog.Print("WebRequest::Initialize(): calling ConfigurationSettings.GetConfig()");
                            ArrayList prefixList = (ArrayList)ConfigurationSettings.GetConfig("system.net/webRequestModules");

                            if (prefixList == null) {
                                GlobalLog.Print("WebRequest::Initialize(): creating default settings");
                                HttpRequestCreator Creator = new HttpRequestCreator();

                                // longest prefixes must be the first
                                prefixList = new ArrayList();                                
                                prefixList.Add(new WebRequestPrefixElement("https", Creator)); // [0]
                                prefixList.Add(new WebRequestPrefixElement("http", Creator));  // [1]
                                prefixList.Add(new WebRequestPrefixElement("file", new FileWebRequestCreator())); // [2]
                            }

                            s_PrefixList = prefixList; 
                        }
                    }
                }

                return s_PrefixList;
            }
            set {
                s_PrefixList = value;
            }
        }

        // constructors

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.WebRequest"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.WebRequest'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        
        protected WebRequest() {
        }

        //
        // ISerializable constructor
        //
        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.WebRequest1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected WebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        //
        // ISerializable method
        //
        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            throw ExceptionHelper.MethodNotImplementedException;
        }



        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.Method"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets and
        ///       sets
        ///       the
        ///       protocol method used in this request. Default value should be
        ///       "GET".</para>
        /// </devdoc>
        public virtual string Method {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }


        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.RequestUri"]/*' />
        /// <devdoc>
        /// <para>When overridden in a derived class, gets a <see cref='Uri'/>
        /// instance representing the resource associated with
        /// the request.</para>
        /// </devdoc>
        public virtual Uri RequestUri {                               // read-only
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        //
        // This is a group of connections that may need to be used for
        //  grouping connecitons.
        //
        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.ConnectionGroupName"]/*' />
        /// <devdoc>
        /// </devdoc>
        public virtual string ConnectionGroupName {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }


        /*++

            Headers  - Gets any request specific headers associated
             with this request, this is simply a name/value pair collection

            Input: Nothing.

            Returns: This property returns WebHeaderCollection.

                    read-only

        --*/

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.Headers"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       gets
        ///       a collection of header name-value pairs associated with this
        ///       request.</para>
        /// </devdoc>
        public virtual WebHeaderCollection Headers {            
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }


        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>When
        ///       overridden in a derived class, gets
        ///       and sets
        ///       the
        ///       content length of request data being sent.</para>
        /// </devdoc>
        public virtual long ContentLength {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.ContentType"]/*' />
        /// <devdoc>
        ///    <para>When
        ///       overridden in a derived class, gets
        ///       and
        ///       sets
        ///       the content type of the request data being sent.</para>
        /// </devdoc>
        public virtual string ContentType {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.Credentials"]/*' />
        /// <devdoc>
        ///     <para>When overridden in a derived class, gets and sets the network
        ///       credentials used for authentication to this Uri.</para>
        /// </devdoc>
        public virtual ICredentials Credentials {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.Proxy"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       gets and set proxy info. </para>
        /// </devdoc>
        public virtual IWebProxy Proxy {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.PreAuthenticate"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       enables or disables pre-authentication.</para>
        /// </devdoc>
        public virtual bool PreAuthenticate {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }

        //
        // Timeout in milliseconds, if request  takes longer
        // than timeout, a WebException is thrown
        //
        //UEUE
        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.Timeout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual int Timeout {
            get {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
            set {
                throw ExceptionHelper.PropertyNotImplementedException;
            }
        }


        //
        // DataStream may need to be extended to UriDataStream or somesuch. We need
        // to be able to get the data available (do we?). This should be a method of
        // the stream, not of the net classes. Also, we need to know whether the
        // stream is seekable. Only streams via cache and via socket with Content-
        // Length are seekable
        //

        //
        // read-only
        //

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.GetRequestStream"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       returns a <see cref='System.IO.Stream'/> object that is used for writing data
        ///       to the resource identified by <see cref='WebRequest.RequestUri'/>
        ///       .</para>
        /// </devdoc>
        public virtual Stream GetRequestStream() {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.GetResponse"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       returns the response
        ///       to an Internet request.</para>
        /// </devdoc>
        public virtual WebResponse GetResponse() {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.BeginGetResponse"]/*' />
        /// <devdoc>
        ///    <para>Asynchronous version of GetResponse.</para>
        /// </devdoc>
        public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state) {
            throw ExceptionHelper.MethodNotImplementedException;
        }


        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.EndGetResponse"]/*' />
        /// <devdoc>
        ///    <para>Returns a WebResponse object.</para>
        /// </devdoc>
        public virtual WebResponse EndGetResponse(IAsyncResult asyncResult) {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.BeginGetRequestStream"]/*' />
        /// <devdoc>
        ///    <para>Asynchronous version of GetRequestStream
        ///       method.</para>
        /// </devdoc>
        public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, Object state) {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.EndGetRequestStream"]/*' />
        /// <devdoc>
        /// <para>Returns a <see cref='System.IO.Stream'/> object that is used for writing data to the resource
        ///    identified by <see cref='System.Net.WebRequest.RequestUri'/>
        ///    .</para>
        /// </devdoc>
        public virtual Stream EndGetRequestStream(IAsyncResult asyncResult) {
            throw ExceptionHelper.MethodNotImplementedException;
        }

        //
        // Aborts the Request
        //
        /// <include file='doc\WebRequest.uex' path='docs/doc[@for="WebRequest.Abort"]/*' />
        public virtual void Abort() {
            throw ExceptionHelper.MethodNotImplementedException;
        }



    } // class WebRequest

} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\x509certificatecollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="X509CertificateCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.Security.Cryptography.X509Certificates {
    using System;
    using System.Collections;
    
    
    /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection"]/*' />
    [Serializable()]
    public class X509CertificateCollection : CollectionBase {
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.X509CertificateCollection"]/*' />
        public X509CertificateCollection() {
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.X509CertificateCollection1"]/*' />
        public X509CertificateCollection(X509CertificateCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.X509CertificateCollection2"]/*' />
        public X509CertificateCollection(X509Certificate[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.this"]/*' />
        public X509Certificate this[int index] {
            get {
                return ((X509Certificate)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.Add"]/*' />
        public int Add(X509Certificate value) {
            return List.Add(value);
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.AddRange"]/*' />
        public void AddRange(X509Certificate[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; (i < value.Length); i = (i + 1)) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.AddRange1"]/*' />
        public void AddRange(X509CertificateCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; (i < value.Count); i = (i + 1)) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.Contains"]/*' />
        public bool Contains(X509Certificate value) {
            foreach (X509Certificate cert in List) {
                if (cert.Equals(value)) {
                    return true;
                }
            }
            return false;
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.CopyTo"]/*' />
        public void CopyTo(X509Certificate[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.IndexOf"]/*' />
        public int IndexOf(X509Certificate value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.Insert"]/*' />
        public void Insert(int index, X509Certificate value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.GetEnumerator"]/*' />
        public new X509CertificateEnumerator GetEnumerator() {
            return new X509CertificateEnumerator(this);
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.Remove"]/*' />
        public void Remove(X509Certificate value) {
            List.Remove(value);
        }

        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateCollection.GetHashCode"]/*' />
        public override int GetHashCode() {
            int hashCode = 0;

            foreach (X509Certificate cert in this) {                
                hashCode += cert.GetHashCode();  
            }

            return hashCode;
        }
        
        /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateEnumerator"]/*' />
        public class X509CertificateEnumerator : object, IEnumerator {
            
            private IEnumerator baseEnumerator;
            
            private IEnumerable temp;
            
            /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateEnumerator.X509CertificateEnumerator"]/*' />
            public X509CertificateEnumerator(X509CertificateCollection mappings) {
                this.temp = ((IEnumerable)(mappings));
                this.baseEnumerator = temp.GetEnumerator();
            }
            
            /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateEnumerator.Current"]/*' />
            public X509Certificate Current {
                get {
                    return ((X509Certificate)(baseEnumerator.Current));
                }
            }
            
            /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateEnumerator.IEnumerator.Current"]/*' />
            /// <internalonly/>
            object IEnumerator.Current {
                get {
                    return baseEnumerator.Current;
                }
            }
            
            /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateEnumerator.MoveNext"]/*' />
            public bool MoveNext() {
                return baseEnumerator.MoveNext();
            }
            
            /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateEnumerator.IEnumerator.MoveNext"]/*' />
            /// <internalonly/>
            bool IEnumerator.MoveNext() {
                return baseEnumerator.MoveNext();
            }
            
            /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateEnumerator.Reset"]/*' />
            public void Reset() {
                baseEnumerator.Reset();
            }
            
            /// <include file='doc\X509CertificateCollection.uex' path='docs/doc[@for="X509CertificateEnumerator.IEnumerator.Reset"]/*' />
            /// <internalonly/>
            void IEnumerator.Reset() {
                baseEnumerator.Reset();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\weblistenerfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebListenerFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Configuration;
using System.Configuration.Assemblies;

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Util;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;



namespace System.Net {


#if COMNET_LISTENER


/*++

    WebListenerFactory - Create WebListeners.

    This is the base factory class for creating WebListeners and registering
    handlers for protocl names.

--*/

    /// <include file='doc\WebListenerFactory.uex' path='docs/doc[@for="WebListenerFactory"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class WebListenerFactory {
        /*++
    
            Create - Create a WebListener.
    
            This is the main creation routine. We take a protocolName, look up
            in the table, and invoke the appropriate handler to create the object.
    
            Input:
    
                protocolName - protocol name associated with the listener.
    
            Returns:
    
                Newly created WebListener.
        --*/

        /// <include file='doc\WebListenerFactory.uex' path='docs/doc[@for="WebListenerFactory.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static WebListener Create(string protocolName) {
            bool Found;

            // Lock the list, then look for an existing handler

            lock( s_Creators ) {
                Found = s_Creators.ContainsKey( protocolName.ToLower(CultureInfo.InvariantCulture) );
            }

            if (Found) {
                //
                // Found a match, so just call the creator and return what it does
                //

                return((IWebListenerCreate)s_Creators[ protocolName.ToLower(CultureInfo.InvariantCulture) ]).Create( protocolName );
            }

            // Otherwise no match, throw an exception.

            throw new NotSupportedException(SR.GetString(), protocolName);

        } // Create()


        /*++
    
            Create - Create a WebListener.
    
            An overloaded utility version of the real Create that takes a
            string instead of an Uri object.
    
    
            Input:
    
                RequestString       - Uri string to create.
    
            Returns:
    
                Newly created WebListener.
        --*/

        /// <include file='doc\WebListenerFactory.uex' path='docs/doc[@for="WebListenerFactory.Create1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static WebListener Create() {
            //
            // default protocol name to "http"
            //

            return Create( "http" );

        } // Create()


        /*++
    
                    RegisterProtocolName - Register a protocol name for creating
                    WebListeners.
    
                    This function registers a protocol name for creating WebListeners.
                    When a user wants to create a WebListener, we scan a table looking for
                    a match for the protocol name they're passing. We then invoke the
                    sub creator for that protocol name. This function puts entries in
                    that table.
    
                    We don't allow duplicate entries, so if there is a dup this call
                    will fail.
    
        Input:
    
            protocolName    - Represents protocol name being registered.
            creator                 - Interface for sub creator.
    
        Returns:
    
            True if the registration worked, false otherwise.
    
        --*/

        /// <include file='doc\WebListenerFactory.uex' path='docs/doc[@for="WebListenerFactory.RegisterProtocolName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool RegisterProtocolName(string protocolName, IWebListenerCreate creator) {
            bool Error = false;

            // Lock the list, then look for an existing handler

            lock( s_Creators ) {
                if (s_Creators.ContainsKey( protocolName.ToLower(CultureInfo.InvariantCulture) )) {
                    Error = true;
                }
                else {
                    s_Creators[ protocolName.ToLower(CultureInfo.InvariantCulture) ] = creator;
                }
            }

            return !Error;

        } // RegisterProtocolName


        /*++
    
            InitializeProtocolNameList - Initialize our prefix list.
    
    
            This is the method that initializes the prefix list. We create
            an ArrayList for the ProtocolNameList, then an HttpRequestCreator object,
            and then we register the HTTP and HTTPS prefixes.
    
            Input: Nothing
    
            Returns: true
    
        --*/

        private static bool InitializeProtocolNameList() {
            s_Creators = new Hashtable();

            RegisterProtocolName( "http", new HttpListenerCreator() );

            return true;
        }

        private static Hashtable s_Creators;
        private static bool s_Initialized = InitializeProtocolNameList();

    } // class WebListenerFactory



#endif // #if COMNET_LISTENER




} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_bufferoffsetsize.cs ===
//------------------------------------------------------------------------------
// <copyright file="_BufferOffsetSize.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    //
    // this class is used by the BeginMultipleSend() API
    // to allow a user to send multiple buffers on a socket
    //
    internal class BufferOffsetSize {
        //
        // internal members
        //
        public byte[] Buffer;
        public int Offset;
        public int Size;

        public BufferOffsetSize(byte[] buffer, int offset, int size, bool copyBuffer) {
            GlobalLog.Assert(buffer!=null && buffer.Length>=size+offset, "BufferOffsetSize(Illegal parameters)", "");
            if (copyBuffer) {
                byte[] newBuffer = new byte[size];

                System.Buffer.BlockCopy(
                    buffer,     // src
                    offset,     // src index
                    newBuffer,  // dest
                    0,          // dest index
                    size );     // total size to copy

                offset = 0;
                buffer = newBuffer;
            }
            Buffer = buffer;
            Offset = offset;
            Size = size;
            GlobalLog.Print("BufferOffsetSize#" + ValidationHelper.HashString(this) + "::.ctor() copyBuffer:" + copyBuffer.ToString() + " this:[" + ToString() + "]");
        }

        public BufferOffsetSize(byte[] buffer, int offset, bool copyBuffer)
            : this(buffer, offset, buffer.Length - offset, copyBuffer) {
        }

        public BufferOffsetSize(int size, byte[] buffer, bool copyBuffer)
            : this(buffer, 0, size, copyBuffer) {
        }

        public BufferOffsetSize(byte[] buffer, bool copyBuffer)
            : this(buffer, 0, buffer.Length, copyBuffer) {
        }

#if TRAVE
        public override string ToString() {
            return "BufferOffsetSize#" + ValidationHelper.HashString(this) + " Buffer#" + ValidationHelper.HashString(Buffer) + " Offset:" + Offset.ToString() + " Size:" + Size.ToString();
        }
#endif

    } // class BufferOffsetSize



} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_basicclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="_BasicClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Text;
    using System.Globalization;
    using System.Security.Permissions;

    internal class BasicClient : IAuthenticationModule {

        internal const string AuthType = "Basic";
        internal static string Signature = AuthType.ToLower(CultureInfo.InvariantCulture);
        internal static int SignatureSize = Signature.Length;

        public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("BasicClient::Authenticate(): " + challenge);

            GlobalLog.Assert(credentials!=null, "BasicClient::Authenticate() credentials==null", "");
            if (credentials==null || credentials is SystemNetworkCredential) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "BasicClient::Authenticate() httpWebRequest==null", "");
            if (httpWebRequest==null || httpWebRequest.ChallengedUri==null) {
                //
                // there has been no challenge:
                // 1) the request never went on the wire
                // 2) somebody other than us is calling into AuthenticationManager
                //
                return null;
            }

            int index = AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {
                return null;
            }

            return Lookup(httpWebRequest, credentials);
        }

        public bool CanPreAuthenticate {
            get {
                return true;
            }
        }

        public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("BasicClient::PreAuthenticate()");

            GlobalLog.Assert(credentials!=null, "BasicClient::Authenticate() credentials==null", "");
            if (credentials==null || credentials is SystemNetworkCredential) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "BasicClient::Authenticate() httpWebRequest==null", "");
            if (httpWebRequest==null) {
                return null;
            }
            return Lookup(httpWebRequest, credentials);
        }

        public string AuthenticationType {
            get {
                return AuthType;
            }
        }

        /*
         *  This is to support built-in auth modules under semitrusted environment
         *  Used to get access to UserName, Domain and Password properties of NetworkCredentials
         *  Declarative Assert is much faster and we don;t call dangerous methods inside this one.
         */
        [EnvironmentPermission(SecurityAction.Assert,Unrestricted=true)]
        [SecurityPermissionAttribute( SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]

        private static Authorization Lookup(HttpWebRequest httpWebRequest, ICredentials credentials) {
            GlobalLog.Print("BasicClient::Lookup(): ChallengedUri:" + httpWebRequest.ChallengedUri.ToString());

            NetworkCredential NC = credentials.GetCredential(httpWebRequest.ChallengedUri, Signature);
            GlobalLog.Print("BasicClient::Lookup() GetCredential() returns:" + ValidationHelper.ToString(NC));

            if (NC==null) {
                return null;
            }

            string username = NC.UserName;
            string domain = NC.Domain;

            if (ValidationHelper.IsBlankString(username)) {
                return null;
            }

            string rawString = ((!ValidationHelper.IsBlankString(domain)) ? (domain + "\\") : "") + username + ":" + NC.Password;

            // The response is an "Authorization:" header where the value is
            // the text "Basic" followed by BASE64 encoded (as defined by RFC1341) value

            byte[] bytes = EncodingRightGetBytes(rawString);
            string responseHeader = BasicClient.AuthType + " " + Convert.ToBase64String(bytes);

            return new Authorization(responseHeader);
        }

        internal static byte[] EncodingRightGetBytes(string rawString) {
            GlobalLog.Enter("BasicClient::EncodingRightGetBytes", "[" + rawString.Length.ToString() + ":" + rawString + "]");
            //
            // this is lame. in order to know if there will not be any '?' translations (which means
            // we should use the Default Encoding) we need to attempt encoding and then decoding. this
            // is a limitation only on win9x, if we ever drop support for this platform there might be
            // a more efficient way of doing this.
            //
            GlobalLog.Print("BasicClient::EncodingRightGetBytes(): Default Encoding is:" + Encoding.Default.EncodingName);

            byte[] bytes = Encoding.Default.GetBytes(rawString);
            string rawCopy = Encoding.Default.GetString(bytes);
            bool canMapToCurrentCodePage = string.Compare(rawString, rawCopy, false, CultureInfo.InvariantCulture)==0;

            GlobalLog.Print("BasicClient::EncodingRightGetBytes(): canMapToCurrentCodePage:" + canMapToCurrentCodePage.ToString());

            //
            // if mapping to the current code page leaves characters out of the
            // [0x00, 0xFF] range, then we need to use the new encoding that IIS6.0
            // will support. do it when they decide it's good enough.
            // 
            if (!canMapToCurrentCodePage) {
                //
                // for now throw. when IIS 6.0 adds support test it.
                //
                throw ExceptionHelper.MethodNotSupportedException;
                /*
                GlobalLog.Print("BasicClient::EncodingRightGetBytes(): using:" + Encoding.UTF8.EncodingName);
                bytes = Encoding.UTF8.GetBytes(rawString);

                string blob = "=?utf-8?B?" + Convert.ToBase64String(bytes) + "?=";
                bytes = Encoding.ASCII.GetBytes(blob);
                */
            }

            GlobalLog.Dump(bytes);
            GlobalLog.Leave("BasicClient::EncodingRightGetBytes", bytes.Length.ToString());

            return bytes;
        }

    }; // class BasicClient


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\webproxy.cs ===
//------------------------------------------------------------------------------
// <copyright file="webproxy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


using System.Collections;
using System.Net;
using System.Text.RegularExpressions;
using System.Globalization;
using System.Security.Permissions;

namespace System.Net {
    using System.Runtime.Serialization;
    using System.Text.RegularExpressions;
    using Microsoft.Win32;

    /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Handles default proxy setting implimentation for the Http proxy.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public class WebProxy : IWebProxy, ISerializable {         

        //
        // _BypassOnLocal - means true, DO NOT use proxy on local connections, 
        //  on false, use proxy for local network connections
        //

        private bool _BypassOnLocal; 
        private Uri _ProxyAddress;  // Uri of proxy itself
        private ArrayList _BypassList; // list of overrides
        private Regex [] _RegExBypassList;
        private ICredentials _Credentials;         
        private Hashtable _LocalHostAddresses;
        private Hashtable _ProxyHostAddresses;
        private string _LocalDomain;

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy() 
            : this((Uri) null, false, null, null) { 
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(Uri Address) 
            : this(Address, false, null, null) {
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(Uri Address, bool BypassOnLocal) 
            : this(Address, BypassOnLocal, null, null) {
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(Uri Address, bool BypassOnLocal, string[] BypassList) 
            : this(Address, BypassOnLocal, BypassList, null) {
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal WebProxy(Hashtable proxyHostAddresses, bool BypassOnLocal, string[] BypassList) 
            : this((Uri) null, BypassOnLocal, BypassList, null) {                    
            _ProxyHostAddresses = proxyHostAddresses;           
            if (_ProxyHostAddresses != null ) {
                _ProxyAddress = (Uri) proxyHostAddresses["http"];
            }            
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(Uri Address, bool BypassOnLocal, string[] BypassList, ICredentials Credentials) {            
            _ProxyAddress = Address;               
            _BypassOnLocal = BypassOnLocal;
            if (BypassList != null) {
                _BypassList   = new ArrayList(BypassList);
                UpdateRegExList(true);
            }            
            _Credentials  = Credentials;
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(string Host, int Port) 
            : this(new Uri("http://" + Host + ":" + Port.ToString()), false, null, null) {
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(string Address) 
            : this(CreateProxyUri(Address), false, null, null) {
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(string Address, bool BypassOnLocal) 
            : this(CreateProxyUri(Address), BypassOnLocal, null, null) {
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(string Address, bool BypassOnLocal, string[] BypassList) 
            : this(CreateProxyUri(Address), BypassOnLocal, BypassList, null) {
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebProxy(string Address, bool BypassOnLocal, string[] BypassList, ICredentials Credentials) 
            : this(CreateProxyUri(Address), BypassOnLocal, BypassList, Credentials) {
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.Address"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Uri Address { 
            get {
               return _ProxyAddress;
            }
            set {
               _ProxyHostAddresses = null;  // hash list of proxies, we don't support this till Vnext
               _ProxyAddress = value; 
            }
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.BypassProxyOnLocal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool BypassProxyOnLocal { 
            get {
                return _BypassOnLocal;                
            }
            set {
                _BypassOnLocal = value;
            }
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.BypassList"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string[] BypassList { 
            get {
                if (_BypassList == null) {
                    _BypassList = new ArrayList();
                } 

                return (String []) 
                        _BypassList.ToArray(typeof(string));

            }
            set {
                _BypassList = new ArrayList(value);
                UpdateRegExList(true);
            }
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.Credentials"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICredentials Credentials { 
            get {
                return _Credentials;
            }
            set {
                _Credentials = value;                
            }
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.BypassArrayList"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ArrayList BypassArrayList {
            get {
                if ( _BypassList == null ) {
                    _BypassList = new ArrayList();
                }
                return _BypassList;
            }
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.GetProxy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Uri GetProxy( Uri destination ) {
            if ( IsBypassed(destination) ) {
                return destination;
            }
            Uri proxy;
            Hashtable proxyHostAddresses = _ProxyHostAddresses;
            if (proxyHostAddresses != null) {
                proxy = (Uri) proxyHostAddresses[destination.Scheme];
                return proxy;
            }
            proxy = _ProxyAddress;
            if (proxy != null) {
                return proxy;
            }
            return destination;
        }

        //
        // CreateProxyUri - maps string to Uri
        //

        private static Uri CreateProxyUri(string Address) { 
            if (Address == null) {
                return null;
            }
            if (Address.IndexOf("://") == -1) {
                Address = "http://" + Address;
            }

            return new Uri(Address);
        }

        //
        // UpdateRegExList - Update internal _RegExBypassList
        //  warning - can throw if the RegEx doesn't parse??
        // 

        private void UpdateRegExList(bool canThrow) {

            Regex [] regExBypassList = null;
            ArrayList bypassList = _BypassList;

            try {
                if ( bypassList != null && bypassList.Count > 0 ) {
                    regExBypassList = new Regex[bypassList.Count];

                    for (int i = 0; i < bypassList.Count; i++ ) {                
                        regExBypassList[i] = new Regex((string)bypassList[i], RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
                    }
                }
            } catch {
                if (!canThrow) {
                    _RegExBypassList = null;
                    return;
                }
                throw;
            }

            // only update here, cause it could throw earlier in the loop
            _RegExBypassList = regExBypassList;
        }



        //
        // IsMatchInBypassList - match input against _RegExBypassList
        // 

        private bool IsMatchInBypassList (Uri input) {

            UpdateRegExList(false);

            if ( _RegExBypassList == null ) {
                return false;
            }

            string matchUriString = input.Scheme + "://" + input.Host + (!input.IsDefaultPort ? (":"+input.Port) : "" );

            for (int i = 0; i < _BypassList.Count; i++ ) {                
                if (_RegExBypassList[i].IsMatch(matchUriString)) {
                    return true;
                }
            }

            return false;
        }


        private Hashtable LocalHostAddresses {
            get { 
                if (_LocalHostAddresses == null || Dns.IsLocalHostExpired()) {
                    lock (this) {
                        if (_LocalHostAddresses == null || Dns.IsLocalHostExpired()) {
                            Hashtable localHostAddresses = 
                                new Hashtable(CaseInsensitiveString.StaticInstance, CaseInsensitiveString.StaticInstance);

                            //localHostAddresses["127.0.0.1"] = true;
                            //localHostAddresses["localhost"] = true;
                            //localHostAddresses["loopback"] = true;
                            
                            try {
                                IPHostEntry hostEntry = Dns.LocalHost;
                                if (hostEntry != null) {
                                    if (hostEntry.HostName != null) {
                                        localHostAddresses[hostEntry.HostName] = true;
                                        int dot  = hostEntry.HostName.IndexOf('.');
                                        if(dot != -1) {
                                            _LocalDomain = hostEntry.HostName.Substring(dot);
                                        }
                                    }

                                    string [] aliases = hostEntry.Aliases;
                                    if (aliases != null) {
                                        foreach (string hostAlias in aliases) {
                                            localHostAddresses[hostAlias] = true;
                                        }
                                    }

                                    IPAddress [] ipAddresses = hostEntry.AddressList;
                                    if (ipAddresses != null) {
                                        foreach(IPAddress ipAddress in ipAddresses) {
                                            localHostAddresses[ipAddress.ToString()] = true;
                                        }
                                    }
                                }
                            } catch {
                            }

                            _LocalHostAddresses = localHostAddresses;
                        }
                    }
                }
                return _LocalHostAddresses;
            }
        }

/*
        private string _LocalHostName;
        private string LocalHostName {
            get {
                if (_LocalHostName == null) {
                    lock(this) {
                        if (_LocalHostName == null) {
                            try {
                                _LocalHostName = Dns.GetHostName();
                            } catch {
                            }
                        }
                    }
                }
                return _LocalHostName;
            }
        }
*/


        /// <devdoc>
        /// Determines if the host Uri should be routed locally or go through the proxy.
        /// </devdoc>
        private bool IsLocal(Uri host) {            
            string hostString = host.Host;
            int dot = hostString.IndexOf('.');

            if (dot == -1) {
                return true;
            }
            
            if (this.LocalHostAddresses[hostString] != null) {
                return true;
            }
            // _LocalDomain may be updated after accessing this.LocalHostAddresses
            string local = _LocalDomain;
            if (local !=  null && local.Length == (hostString.Length - dot) &&
                string.Compare(local, 0, hostString, dot, local.Length, true, CultureInfo.InvariantCulture) == 0) {
                return true;
            }

            return false;
        }

        /// <devdoc>
        /// Determines if the host Uri should be routed locally or go through a proxy.
        /// </devdoc>
        private bool IsLocalInProxyHash(Uri host) {
            Hashtable proxyHostAddresses = _ProxyHostAddresses;
            if (proxyHostAddresses != null) {
                Uri proxy = (Uri) proxyHostAddresses[host.Scheme];
                if (proxy == null) {
                    return true; // no proxy entry for this scheme, then bypass
                }
            }
            return false; 
        }


        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.IsBypassed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsBypassed(Uri host) {
            if (host.IsLoopback) {
                return true; // bypass localhost from using a proxy.
            }

            if ((_ProxyAddress == null && _ProxyHostAddresses == null) ||                       
                (_BypassOnLocal && IsLocal(host)) ||
                 IsMatchInBypassList(host) ||
                 IsLocalInProxyHash(host)) {
                return true; // bypass when non .'s and no proxy on local
            } else { 
                return false;
            }
        }

        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.GetDefaultProxy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static WebProxy GetDefaultProxy() {
            (new WebPermission(PermissionState.Unrestricted)).Demand();
            return ProxyRegBlob.GetIEProxy();
        }

        //
        // ISerializable constructor
        //
        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.WebProxy10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected WebProxy(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            _ProxyAddress   = (Uri)serializationInfo.GetValue("_ProxyAddress", typeof(Uri));
            _BypassOnLocal  = serializationInfo.GetBoolean("_BypassOnLocal");
            _BypassList     = (ArrayList)serializationInfo.GetValue("_BypassList", typeof(ArrayList));
            _Credentials    = null;

            return;
        }

        //
        // ISerializable method
        //
        /// <include file='doc\webproxy.uex' path='docs/doc[@for="WebProxy.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            //
            // for now disregard streamingContext.
            //
            serializationInfo.AddValue("_BypassOnLocal", _BypassOnLocal);
            serializationInfo.AddValue("_ProxyAddress", _ProxyAddress);
            serializationInfo.AddValue("_BypassList", _BypassList);

            return;
        }

    }; // class WebProxy


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\webpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Net {

    using System.Collections;
    using System.Security;
    using System.Security.Permissions;
    using System.Text.RegularExpressions;
    using System.Globalization;
    
    //NOTE: While WebPermissionAttribute resides in System.DLL,
    //      no classes from that DLL are able to make declarative usage of WebPermission.

    /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermissionAttribute"]/*' />

    // THE syntax of this attribute is as followed
    // [WebPermission(SecurityAction.Assert, Connect="http://hostname/path/url", Accept="http://localhost/path/url")]
    // [WebPermission(SecurityAction.Assert, ConnectPattern="http://hostname/www\.microsoft\.*/url/*", AcceptPattern="http://localhost/*")]

    // WHERE:
    //=======
    // - 'Connect' and 'Accept' keywords allow you to specify the final URI
    // - 'ConnectPattern' and 'AcceptPattern' keywords allow you to specify a set of URI in escaped Regex form

    [   AttributeUsage( AttributeTargets.Method | AttributeTargets.Constructor |
                        AttributeTargets.Class  | AttributeTargets.Struct      |
                        AttributeTargets.Assembly,
                        AllowMultiple = true, Inherited = false )]

    [Serializable()] sealed public class WebPermissionAttribute: CodeAccessSecurityAttribute
    {
        private object m_accept  = null;
        private object m_connect = null;

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermissionAttribute.WebPermissionAttribute"]/*' />
        public WebPermissionAttribute( SecurityAction action ): base( action )
        {
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermissionAttribute.Connect"]/*' />
        public string Connect {
            get { return m_connect.ToString(); }
            set {
                if (m_connect != null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_multi, "Connect", value));
                }
                m_connect = value;
            }
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermissionAttribute.Accept"]/*' />
        public string Accept {
            get { return m_accept.ToString();}
            set {
                if (m_accept != null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_multi, "Accept", value));
                }
                m_accept = value;
            }
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermissionAttribute.ConnectPattern"]/*' />
        public string ConnectPattern {
            get { return m_connect.ToString(); }
            set {
                if (m_connect != null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_multi, "ConnectPatern", value));
                }
                m_connect = new Regex(value, RegexOptions.IgnoreCase |
                                             RegexOptions.Compiled   |
                                             RegexOptions.Singleline |
                                             RegexOptions.CultureInvariant);
            }
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermissionAttribute.AcceptPattern"]/*' />
        public string AcceptPattern {
            get { return m_accept.ToString();}
            set {
                if (m_accept != null) {
                    throw new ArgumentException(SR.GetString(SR.net_perm_attrib_multi, "AcceptPattern", value));
                }
                m_accept  = new Regex(value, RegexOptions.IgnoreCase |
                                             RegexOptions.Compiled   |
                                             RegexOptions.Singleline |
                                             RegexOptions.CultureInvariant);
            }
        }


        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission()
        {
            WebPermission perm = null;
            if (Unrestricted) {
                perm = new WebPermission( PermissionState.Unrestricted);
            }
            else {
                perm = new WebPermission(PermissionState.None);
                if (m_accept != null) {
                    if (m_accept is Regex) {
                        perm.AddPermission(NetworkAccess.Accept, (Regex)m_accept);
                    }
                    else {
                        perm.AddPermission(NetworkAccess.Accept, m_accept.ToString());
                    }
                }
                if (m_connect != null) {
                    if (m_connect is Regex) {
                        perm.AddPermission(NetworkAccess.Connect, (Regex)m_connect);
                    }
                    else {
                        perm.AddPermission(NetworkAccess.Connect, m_connect.ToString());
                    }
                }
            }
            return perm;
        }

    }


    /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Controls rights to make or accept connections on a Web address.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public sealed class WebPermission : CodeAccessPermission, IUnrestrictedPermission {

        private bool m_noRestriction = false;
        private ArrayList m_connectList = new ArrayList();
        private ArrayList m_acceptList = new ArrayList();

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.ConnectList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the enumeration of permissions to connect a remote URI.
        ///    </para>
        /// </devdoc>
        public IEnumerator ConnectList    {get {return m_connectList.GetEnumerator();}}

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.AcceptList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the enumeration of permissions to export a local URI.
        ///    </para>
        /// </devdoc>
        public IEnumerator AcceptList     {get {return m_acceptList.GetEnumerator();}}

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.WebPermission"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebPermission'/>
        ///       class that passes all demands or
        ///       that fails all demands.
        ///    </para>
        /// </devdoc>
        public WebPermission(PermissionState state) {
            m_noRestriction = (state == PermissionState.Unrestricted);
        }

        internal WebPermission(bool unrestricted) {
            m_noRestriction = unrestricted;
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.WebPermission1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebPermission'/> class.
        ///    </para>
        /// </devdoc>
        public WebPermission() {
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.WebPermission2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebPermission'/>
        ///       class with the specified access rights for
        ///       the specified URI Pattern.
        ///       Suitable only for WebPermission policy object construction
        ///    </para>
        /// </devdoc>
        public WebPermission(NetworkAccess access, Regex uriRegex) {
            AddPermission(access, uriRegex);
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.WebPermission3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.WebPermission'/>
        ///       class with the specified access rights for
        ///       the specified Uniform Resource Identifier .
        ///       Suitable for requesting particular WebPermission
        ///    </para>
        /// </devdoc>
        public WebPermission(NetworkAccess access, String uriString) {
            AddPermission(access, uriString);
        }

        // Methods specific to this class
        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.AddPermission1"]/*' />
        /// <devdoc>
        ///   <para>
        ///      Adds a new instance of the WebPermission
        ///      class with the specified access rights for the particular Uniform Resource Identifier.
        ///    </para>
        /// </devdoc>
        public void AddPermission(NetworkAccess access, String  uriString) {
            if (!m_noRestriction) {
                if (uriString == null) {
                    throw new ArgumentNullException("uriString");
                }
                // We don't check for Uri correctness here cause of 15% performance impact.
                // Consider V.Next: Replace this method with the one taking Uri as a parameter.

                bool found = false;
                ArrayList list = (access == NetworkAccess.Connect) ? m_connectList: m_acceptList;

                // avoid duplicated strings in the list
                foreach (object obj in list) {
                    if ((obj is string) && (string.Compare(uriString, obj.ToString(), true, CultureInfo.InvariantCulture) == 0)) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    list.Add(uriString);
                }
            }
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.AddPermission2"]/*' />
        /// <devdoc>
        /// <para>Adds a new instance of the <see cref='System.Net.WebPermission'/>
        /// class with the specified access rights for the specified URI Pattern.
        /// Should be used during a policy object creation and not for particular URI permission check</para>
        /// </devdoc>
        public void AddPermission(NetworkAccess access, Regex uriRegex) {
            if (!m_noRestriction) {
                if (uriRegex == null) {
                    throw new ArgumentNullException("uriRegex");
                }
                bool found =false;
                ArrayList list = (access == NetworkAccess.Connect) ? m_connectList: m_acceptList;
                string regexString = uriRegex.ToString();
                // avoid duplicated regexes in the list
                foreach (object obj in list) {
                    if ((obj is Regex) && (string.Compare(regexString, obj.ToString(), true, CultureInfo.InvariantCulture) == 0)) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    list.Add(uriRegex);
                }
            }
        }

        //  Overloaded form using string inputs
        //  Enforces case-insensitive matching
        /// Adds a new instance of the System.Net.WebPermission
        /// class with the specified access rights for the specified URI Pattern
        internal void AddAsPattern(NetworkAccess access, String uriRegexPattern) {
            if (uriRegexPattern == null) {
                throw new ArgumentNullException("uriRegexPattern");
            }
            AddPermission(access, new Regex(uriRegexPattern,
                                                            RegexOptions.IgnoreCase |
                                                            RegexOptions.Compiled   |
                                                            RegexOptions.Singleline | 
                                                            RegexOptions.CultureInvariant ));
        }

        // IUnrestrictedPermission interface methods
        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.IsUnrestricted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Checks the overall permisison state of the object.
        ///    </para>
        /// </devdoc>
        public bool IsUnrestricted() {
            return m_noRestriction;
        }

        // IPermission interface methods
        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.Copy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a copy of a <see cref='System.Net.WebPermission'/> instance.
        ///    </para>
        /// </devdoc>
        public override IPermission Copy() {

            if (m_noRestriction) {
                return new WebPermission(true);
            }

            WebPermission wp = new WebPermission();

            wp.m_acceptList = (ArrayList)m_acceptList.Clone();
            wp.m_connectList = (ArrayList)m_connectList.Clone();
            return wp;
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.IsSubsetOf"]/*' />
        /// <devdoc>
        /// <para>Compares two <see cref='System.Net.WebPermission'/> instances.</para>
        /// </devdoc>
        public override bool IsSubsetOf(IPermission target) {
            // Pattern suggested by security engine
            if (target == null) {
                return (m_noRestriction == false && m_connectList.Count == 0 && m_acceptList.Count == 0);
            }

            WebPermission other = target as WebPermission;
            if (other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }

            if (other.IsUnrestricted()) {
                return true;
            } else if (this.IsUnrestricted()) {
                return false;
            } else if (this.m_acceptList.Count + this.m_connectList.Count ==0) {
                return true;
            } else if (other.m_acceptList.Count + other.m_connectList.Count ==0) {
                return false;
            }

            //
            // Besides SPECIAL case, this method is restricted to only final URIs (strings) on
            // the current object.
            // The restriction comes from the problem of finding a Regex to be a subset of another Regex
            //
            String UriString = null;

            foreach(object Uri in this.m_acceptList) {
                UriString = Uri as String;
                if(UriString == null) {
                    if(isSpecialSubsetCase(Uri.ToString(), other.m_acceptList))
                        continue;
                    throw new NotSupportedException(SR.GetString(SR.net_perm_both_regex));
               }
               if(!isMatchedURI(UriString, other.m_acceptList))
                  return false;
            }

            foreach(object Uri in this.m_connectList) {
                UriString = Uri as String;
                if(UriString == null) {
                    if(isSpecialSubsetCase(Uri.ToString(), other.m_connectList))
                        continue;
                    throw new NotSupportedException(SR.GetString(SR.net_perm_both_regex));
               }
                if(!isMatchedURI(UriString, other.m_connectList))
                    return false;
            }
            return true;
        }

        //Checks special case when testin Regex to be a subset of other Regex
        //Support only the case when  both Regexes are identical as strings.
        private static bool isSpecialSubsetCase(String regexToCheck, ArrayList permList) {

            foreach(object uriPattern in permList) {
                if(uriPattern is Regex) {
                    //regex parameter against regex permission
                   if (String.Compare(regexToCheck,uriPattern.ToString(), true, CultureInfo.InvariantCulture) == 0) {
                     return true;
                   }
                }
                else if (String.Compare(regexToCheck, Regex.Escape(uriPattern.ToString()), true, CultureInfo.InvariantCulture) == 0) {
                   //regex parameter against string permission
                   return true;
                }

            }
            return false;

       }

        // The union of two web permissions is formed by concatenating
        // the list of allowed regular expressions. There is no check
        // for duplicates/overlaps
        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.Union"]/*' />
        /// <devdoc>
        /// <para>Returns the logical union between two <see cref='System.Net.WebPermission'/> instances.</para>
        /// </devdoc>
        public override IPermission Union(IPermission target) {
            // Pattern suggested by Security engine
            if (target==null) {
                return this.Copy();
            }
            WebPermission other = target as WebPermission;
            if(other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }
            if (m_noRestriction || other.m_noRestriction) {
                return new WebPermission(true);
            }
            WebPermission result = (WebPermission)other.Copy();

            for (int i = 0; i < m_connectList.Count; i++) {
                Regex uriPattern = m_connectList[i] as Regex;
                if(uriPattern == null)
                    result.AddPermission(NetworkAccess.Connect, m_connectList[i].ToString());
                else
                    result.AddPermission(NetworkAccess.Connect, uriPattern);
            }
            for (int i = 0; i < m_acceptList.Count; i++) {
                Regex uriPattern = m_acceptList[i] as Regex;
                if(uriPattern == null)
                    result.AddPermission(NetworkAccess.Accept, m_acceptList[i].ToString());
                else
                    result.AddPermission(NetworkAccess.Accept, uriPattern);
            }
            return result;
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.Intersect"]/*' />
        /// <devdoc>
        /// <para>Returns the logical intersection between two <see cref='System.Net.WebPermission'/> instances.</para>
        /// </devdoc>
        public override IPermission Intersect(IPermission target) {
            // Pattern suggested by Security engine
            if (target == null) {
                return null;
            }

            WebPermission other = target as WebPermission;
            if(other == null) {
                throw new ArgumentException(SR.GetString(SR.net_perm_target));
            }

            WebPermission result;
            if (m_noRestriction) {
                result = (WebPermission)(other.Copy());
            }
            else if (other.m_noRestriction) {
                result = (WebPermission)(this.Copy());
            }
            else {
                result = new WebPermission(false);
                intersectList(m_connectList, other.m_connectList, result.m_connectList);
                intersectList(m_acceptList, other.m_acceptList, result.m_acceptList);
            }

            // return null if resulting permission is restricted and empty
            if (!result.m_noRestriction &&
                result.m_connectList.Count == 0 && result.m_acceptList.Count == 0) {
                return null;
            }
            return result;
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.FromXml"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override void FromXml(SecurityElement securityElement) {
            if (securityElement == null) {

                //
                // null SecurityElement
                //

                throw new ArgumentNullException("securityElement");
            }
            if (!securityElement.Tag.Equals("IPermission")) {

                //
                // SecurityElement must be a permission element
                //

                throw new ArgumentException("securityElement");
            }

            string className = securityElement.Attribute("class");

            if (className == null) {

                //
                // SecurityElement must be a permission element for this type
                //

                throw new ArgumentException("securityElement");
            }
            if (className.IndexOf(this.GetType().FullName) < 0) {

                //
                // SecurityElement must be a permission element for this type
                //

                throw new ArgumentException("securityElement");
            }

            String str = securityElement.Attribute("Unrestricted");

            if (str != null) {
                m_noRestriction = (0 == string.Compare( str, "true", true, CultureInfo.InvariantCulture));
                if(m_noRestriction)
                    return;
            }

            m_noRestriction = false;
            m_connectList = new ArrayList();
            m_acceptList = new ArrayList();

            SecurityElement et = securityElement.SearchForChildByTag("ConnectAccess");
            string uriPattern;

            if (et != null) {

                foreach(SecurityElement uriElem in et.Children) {
                    //NOTE: Any stuff coming from XML is treated as URI PATTERN!
                    if (uriElem.Tag.Equals("URI")) {
                        try {
                            uriPattern = uriElem.Attributes["uri"] as string;
                        }
                        catch {
                            uriPattern = null;
                        }
                        if (uriPattern == null) {
                            throw new ArgumentException(SR.GetString(SR.net_perm_invalid_val_in_element), "ConnectAccess");
                        }
                        AddAsPattern(NetworkAccess.Connect, uriPattern);
                    }
                    else {
                        // improper tag found, just ignore
                    }
                }
            }

            et = securityElement.SearchForChildByTag("AcceptAccess");
            if (et != null) {

                foreach(SecurityElement uriElem in et.Children) {
                    //NOTE: Any stuff coming from XML is treated as URI PATTERN!
                    if (uriElem.Tag.Equals("URI")) {
                        try {
                            uriPattern = uriElem.Attributes["uri"] as string;
                        }
                        catch {
                            uriPattern = null;
                        }
                        if (uriPattern == null) {
                            throw new ArgumentException(SR.GetString(SR.net_perm_invalid_val_in_element), "AcceptAccess");
                        }
                        AddAsPattern(NetworkAccess.Accept, uriPattern);
                    }
                    else {
                        // improper tag found, just ignore
                    }
                }
            }
        }

        /// <include file='doc\WebPermission.uex' path='docs/doc[@for="WebPermission.ToXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override SecurityElement ToXml() {

            SecurityElement securityElement = new SecurityElement("IPermission");

            securityElement.AddAttribute( "class", this.GetType().FullName + ", " + this.GetType().Module.Assembly.FullName.Replace( '\"', '\'' ) );
            securityElement.AddAttribute( "version", "1" );

            if (!IsUnrestricted()) {
                String tempStr=null;

                if (m_connectList != null && m_connectList.Count > 0) {
                    SecurityElement connectElement = new SecurityElement( "ConnectAccess" );

                    //NOTE All strings going to XML will become URI PATTERNS i.e. escaped to Regex
                    foreach(object Uri in m_connectList) {
                        String uriString = Uri as String;
                        if(uriString != null)
                            tempStr=Regex.Escape(uriString);
                        else
                            tempStr=Uri.ToString();
                        SecurityElement uripattern = new SecurityElement("URI");
                        uripattern.AddAttribute("uri", tempStr);
                        connectElement.AddChild(uripattern);
                    }

                    securityElement.AddChild( connectElement );
                }
                if (m_acceptList != null && m_acceptList.Count > 0) {
                    SecurityElement acceptElement = new SecurityElement( "AcceptAccess" );

                    //NOTE All strings going to XML will become URI PATTERNS i.e. escaped to Regex
                    foreach(object Uri in m_acceptList) {
                        String uriString = Uri as String;
                        if(uriString != null)
                            tempStr=Regex.Escape(uriString);
                        else
                            tempStr=Uri.ToString();
                        SecurityElement uripattern = new SecurityElement("URI");
                        uripattern.AddAttribute("uri", tempStr);
                        acceptElement.AddChild(uripattern);
                    }

                    securityElement.AddChild( acceptElement );
                }
            }
            else {
                securityElement.AddAttribute( "Unrestricted", "true" );
            }
            return securityElement;
        }

        // Verifies a single Uri against a set of regular expressions
        private bool isMatchedURI(String uriToCheck, ArrayList uriPatternList) {

            foreach(object uriPattern in uriPatternList) {
                Regex R = uriPattern as Regex;
                
                //perform case insensitive comparison of final URIs
                if(R == null) {  
                    if(String.Compare(uriToCheck, uriPattern.ToString(), true, CultureInfo.InvariantCulture) == 0) {
                        return true;
                    }
                    continue;
                }

                //Otherwise trying match final URI against given Regex pattern
                Match M = R.Match(uriToCheck);
                if ((M != null)                             // Found match for the regular expression?
                    && (M.Index == 0)                       // ... which starts at the begining
                    && (M.Length == uriToCheck.Length)) {   // ... and the whole string matched
                    return true;
                }

                try {
                    //
                    // check if the URI was presented in non-canonical form
                    //
                    string unescapedUri = (new Uri(uriToCheck)).ToString();
                    M = R.Match(unescapedUri);
                    if ((M != null)                             // Found match for the regular expression?
                        && (M.Index == 0)                       // ... which starts at the begining
                        && (M.Length == unescapedUri.Length)) {   // ... and the whole string matched
                        return true;
                    }
                }
                catch {
                    //Obviously the permission string is wrong, but we don't know how it went there.
                    //The best way (in V.next) would  be to replace AddPermisscion(string) with AddPermsission(Uri)
                    //For now let's just assume the check has failed
                    continue;
                }
            }
            return false;
        }

        // We should keep the result as compact as possible since otherwise even
        // simple scenarios in Policy Wizard won;t work due to repeated Union/Intersect calls
        // The issue comes from the "hard" Regex.IsSubsetOf(Regex) problem.
        private void intersectList(ArrayList A, ArrayList B, ArrayList result) {
            bool[]  aDone = new bool[A.Count];
            bool[]  bDone = new bool[B.Count];
            int     ia=0, ib;

            // The optimization is done according to the following truth
            // (A|B|C) intersect (B|C|E|D)) == B|C|(A inter E)|(A inter D)
            //
            // We also check on any duplicates in the result

            // Round 1st
            // Getting rid of same permissons in the input arrays (assuming X /\ X = X)
            foreach (object a in  A) {
                ib = 0;
                string stringA = a.ToString();
                foreach (object b in  B) {

                    // check to see if b is in the result already
                    if (!bDone[ib]) {

                        //if both are regexes or both are strings
                        if (((a is Regex) == (b is Regex)) &&
                            string.Compare(stringA, b.ToString(), true, CultureInfo.InvariantCulture) == 0) {
                            result.Add(a);
                            aDone[ia]=bDone[ib]=true;

                            //since permissions are ORed we can break and go to the next A
                            break;
                        }
                    }
                    ++ib;
                } //foreach b in B
                ++ia;
            } //foreach a in A

            ia = 0;
            // Round second
            // Grab only intersections of objects not found in both A and B
            foreach (object a in  A) {

                if (!aDone[ia]) {
                    ib = 0;
                    foreach(object b in B) {

                        if (!bDone[ib]) {
                            bool resultRegex;
                            object intesection = intersectPair(a, b, out resultRegex);

                            if (intesection != null) {
                                bool found = false;
                                string intersectionStr = intesection.ToString();
                                // check to see if we already have the same result
                                foreach (object obj in result) {
                                    if ((resultRegex == (obj is Regex))
                                         &&
                                        string.Compare(obj.ToString(), intersectionStr, true, CultureInfo.InvariantCulture) == 0) {

                                        found = true;
                                        break;
                                    }
                                }

                                if (!found) {
                                    result.Add(intesection);
                                }
                            }
                        }
                        ++ib;
                    }
                }
                ++ia;
            }
        }

        private object intersectPair(object L, object R, out bool isRegex) {

            //VERY OLD OPTION:  return new Regex("(?=(" + ((Regex)X[i]).ToString()+ "))(" + ((Regex)Y[j]).ToString() + ")","i");
            //STILL OLD OPTION: return new Regex("(?=.*?(" + L.ToString() + "))" + "(?=.*?(" + R.ToString() + "))");
            // check RegexSpec.doc
            //CURRENT OPTION:   return new Regex("(?=(" + L.ToString() + "))(" + R.ToString() + ")", RegexOptions.IgnoreCase );
            isRegex = false;
            Regex L_Pattern =L as Regex;
            Regex R_Pattern =R as Regex;

            if(L_Pattern != null && R_Pattern != null)  {       //both are Regex
                isRegex = true;
                return new Regex("(?=(" + L_Pattern.ToString() + "))(" + R_Pattern.ToString() + ")", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
            }
            else if(L_Pattern != null && R_Pattern == null) {   //only L is a Regex
                    String uriString = R.ToString();
                    Match M = L_Pattern.Match(uriString);
                    if ((M != null)                             // Found match for the regular expression?
                        && (M.Index == 0)                       // ... which starts at the begining
                        && (M.Length == uriString.Length)) { // ... and the whole string matched
                        return R;
                    }
                    return null;
            }
            else if(L_Pattern == null && R_Pattern != null) {   //only R is a Regex
                    String uriString = L.ToString();
                    Match M = R_Pattern.Match(uriString);
                    if ((M != null)                             // Found match for the regular expression?
                        && (M.Index == 0)                       // ... which starts at the begining
                        && (M.Length == uriString.Length)) { // ... and the whole string matched
                        return L;
                    }
                    return null;
           }
           //both are strings
           return String.Compare(L.ToString(),R.ToString(),true, CultureInfo.InvariantCulture)==0? L : null;
        }
    } // class WebPermission
} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_chunkparse.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ChunkParse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    /*++

        IReadChunkBytes - An interface for reading chunk streams.

        An interface implemented by objects that read from chuked
        streams. This interface is used by the chunk parsing
        utility functions.
    --*/

    internal interface IReadChunkBytes {

        int NextByte {get; set;}

    } // interface IReadChunkBytes

    internal class ChunkParse {

        /*++

            SkipPastCRLF - Skip past the terminating CRLF.

            An internal utility function. This is used to skip over any chunk
            extensions or footers in a chunked response. We look through the
            source bytes looking for the terminating CRLF, honoring any quoted
            strings we see in the process.

            Input:
                    Source      - An IReadChunkBytes interface which we can
                                    use to read the bytes from.


            Returns:

                The number of bytes we consumed, or -1 if there wasn't enough
                in the buffer. We'll return a 0 if there's some sort of syntax
                error.


        --*/
        internal static int
        SkipPastCRLF(IReadChunkBytes Source) {
            int         BytesRead;
            int         Current;
            bool        Escape;
            bool        InQS;
            bool        HaveCR;
            bool        HaveLF;

            BytesRead = 0;
            Escape = false;
            InQS = false;
            HaveCR = false;
            HaveLF = false;

            GlobalLog.Enter("SkipPastCRLF");

            // Loop through the buffer, looking at each byte. We have a
            // pseudo state machine going here, and the action we take
            // with each byte depends on the state.

            Current = Source.NextByte;
            BytesRead++;

            while (Current != -1) {

                // If we saw a CR last time, it must be followed by an unescaped
                // LF, otherwise it's an error. If it is followed by a LF, and
                // we're not in a quoted string, then we've found our termination.
                // If we are in a quoted string, this could be the start of a LWS
                // production. Remember that, and next time through we'll
                // check to make sure that this is an LWS production.

                if (HaveCR) {
                    if (Current != '\n') {
                        // CR w/o a trailing LF is an error.
                        GlobalLog.Leave("SkipPastCRLF", 0);
                        return 0;
                    }
                    else {
                        if (Escape) {
                            // We have an CR, but they're trying to escape the
                            // LF. This is an error.

                            GlobalLog.Leave("SkipPastCRLF", 0);
                            return 0;
                        }

                        // If we're not in a quoted string, we're done.

                        if (!InQS) {
                            // We've found the terminating CRLF pair.
                            GlobalLog.Leave("SkipPastCRLF", 0);
                            return BytesRead;
                        }
                        else {
                            // We're in a quoted string, so set HaveLF
                            // so we remember to check for a LWS production next
                            // time.

                            HaveLF = true;

                            // We've proceessed this byte, set Escape so we don't
                            // do it again.

                            Escape = true;
                        }
                    }

                    // We're past the CR now, don't remember it any more.

                    HaveCR = false;
                }
                else {
                    // If HaveLF is set, we must be in a quoted string and have
                    // seen a CRLF pair. Make sure this character is a space or
                    // tab.

                    if (HaveLF) {
                        // We have a LF. For this to be valid, we have to have a
                        // space or tab be the next character.

                        if (Current != ' ' && Current != '\t') {
                            // Not a continuation, so return an error.
                            GlobalLog.Leave("SkipPastCRLF", 0);
                            return 0;
                        }

                        Escape = true;  // Don't process this byte again.
                        HaveLF = false;
                    }
                }

                // If we're escaping, just skip the next character.
                if (!Escape) {
                    switch (Current) {
                        case '"':
                            if (InQS) {
                                InQS = false;
                            }
                            else {
                                InQS = true;
                            }
                            break;
                        case '\\':
                            if (InQS) {
                                Escape = true;
                            }
                            break;
                        case '\r':
                            HaveCR = true;
                            break;

                        case '\n':

                            // If we get here, we have a LF without a preceding CR.
                            // This is an error.

                            GlobalLog.Leave("SkipPastCRLF", 0);
                            return 0;

                        default:
                            break;
                    }
                }
                else {
                    // We're escaping, do nothing but rest the Escape flag.

                    Escape = false;
                }

                Current = Source.NextByte;
                BytesRead++;
            }

            // If we get here, we never saw the terminating CRLF, so return -1.

            GlobalLog.Leave("SkipPastCRLF", -1);
            return -1;
        }


        /*++

            GetChunkSize - Read the chunk size.

            An internal utility function. Reads the chunk size from a
            byte soruce, and returns the size or -1 if there isn't enough data.

            Input:
                    Source      - An IReadChunkBytes interface which we can
                                    use to read the bytes from.
                    chunkSize   - Out parameter for chunk size.

            Returns:

                The number of bytes we consumed, or -1 if there wasn't enough
                in the buffer. We'll also return 0 if we have some sort of
                syntax error.


        --*/
        internal static int
        GetChunkSize(IReadChunkBytes Source, out int chunkSize) {
            int         BytesRead;
            int         Size;
            int         Current;

            GlobalLog.Enter("GetChunkSize");
            Size = 0;

            //
            // Loop while we have data. If we run out of data and exit the loop
            // at the bottom, then we've run out of data and haven't found the
            // length.

            Current = Source.NextByte;
            BytesRead = 0;

            if (Current == 10 || Current == 13) {
                GlobalLog.Print(" Got Char: " + Current.ToString());
                BytesRead++;
                Current = Source.NextByte;
            }

            while (Current != -1) {
                // Get the next byte, and decode it.

                if (Current >= '0' && Current <= '9') {
                    // Normalize it to 0 based.

                    Current -= '0';

                }
                else {
                    // If we're here, this might be a hex digit.
                    // If it is, normalize it to 10 based.

                    if (Current >= 'a' && Current <= 'f') {
                        Current -= 'a';
                    }
                    else {
                        if (Current >= 'A' && Current <= 'F') {
                            Current -= 'A';
                        }
                        else {
                            // Done with the decoding. If we haven't actually
                            // decoded a digit yet, we'll end up returning
                            // 0, which will signal the error.


                            // Push back the byte we read and didn't use.

                            Source.NextByte = Current;

                            chunkSize = Size;

                            // Return how many bytes we took.

                            GlobalLog.Print("*Size* = " + Size.ToString());
                            GlobalLog.Leave("GetChunkSize", BytesRead);
                            return BytesRead;

                        }
                    }

                    // If we get here we've had an A-F digit, add 10
                    // to it to normalize it.

                    Current += 10;
                }

                // Update the size and our state.

                Size *= 16;
                Size += Current;

                BytesRead++;
                Current = Source.NextByte;
            }

            chunkSize = Size;
            GlobalLog.Print("*Size* = " + Size.ToString());
            GlobalLog.Leave("GetChunkSize", -1);
            return -1;
        }
    } // ChunkParse
} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_connectiongroup.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ConnectionGroup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Diagnostics;
    using System.Threading;

    //
    // ConnectionGroup groups a list of connections within the ServerPoint context,
    //   this used to keep context for things such as proxies or seperate clients.
    //

    internal class ConnectionGroup {

        //
        // Members
        //

        private ServicePoint    m_ServicePoint;
        private string          m_Name;
        private int             m_ConnectionLimit;
        private bool            m_UserDefinedLimit;
        private ArrayList       m_ConnectionList;
        private IPAddress       m_IPAddress;
        private Version         m_Version;
        const   int             defConnectionListSize  = 3;

        private object          m_Event;
        private Queue           m_AuthenticationRequestQueue;
        private bool            m_AuthenticationGroup;
        private bool            m_Abort;
        private HttpAbortDelegate   m_AbortDelegate;

        //
        // Constructors
        //

        internal ConnectionGroup(
            ServicePoint   servicePoint,
            IPAddress      ipAddress,
            int            connectionLimit,
            String         connName) {

            m_ServicePoint      = servicePoint;
            m_ConnectionLimit   = connectionLimit;
            m_UserDefinedLimit  = servicePoint.UserDefinedLimit;
            m_ConnectionList    = new ArrayList(defConnectionListSize); //it may grow beyond
            m_IPAddress         = ipAddress;
            m_Name              = MakeQueryStr(connName);
            m_AbortDelegate     = new HttpAbortDelegate(Abort);

            GlobalLog.Print("ConnectionGroup::.ctor m_ConnectionLimit:" + m_ConnectionLimit.ToString());
        }

        //
        // Accessors
        //
        public string Name {
            get {
                return m_Name;
            }
        }

        public int CurrentConnections {
            get {
                return m_ConnectionList.Count;
            }
        }

        public int ConnectionLimit {
            get {
                return m_ConnectionLimit;
            }
            set {
                m_ConnectionLimit = value;
                m_UserDefinedLimit = true;
                GlobalLog.Print("ConnectionGroup::ConnectionLimit.set m_ConnectionLimit:" + m_ConnectionLimit.ToString());
            }
        }

        internal int InternalConnectionLimit {
            get {
                return m_ConnectionLimit;
            }
            set {
                if (!m_UserDefinedLimit) {
                    m_ConnectionLimit = value;
                    GlobalLog.Print("ConnectionGroup::InternalConnectionLimit.set m_ConnectionLimit:" + m_ConnectionLimit.ToString());
                }
            }
        }

        internal Version ProtocolVersion {
            get {
                return m_Version;
            }
            set {
                m_Version = value;
            }
        }

        internal IPAddress RemoteIPAddress {
            get {
                return m_IPAddress;
            }
            set {
                m_IPAddress = value;
            }
        }

        private ManualResetEvent AsyncWaitHandle {
            get {
                if (m_Event == null) {
                    //
                    // lazy allocation of the event:
                    // if this property is never accessed this object is never created
                    //
                    Interlocked.CompareExchange(ref m_Event, new ManualResetEvent(false), null);
                }

                ManualResetEvent castedEvent = (ManualResetEvent)m_Event;

                return castedEvent;
            }
        } 

        private Queue AuthenticationRequestQueue {
            get {
                if (m_AuthenticationRequestQueue == null) {
                    lock (m_ConnectionList) {
                        if (m_AuthenticationRequestQueue == null) {
                            m_AuthenticationRequestQueue = new Queue();
                        }
                    }
                }
                return m_AuthenticationRequestQueue;
            }
            set {
                m_AuthenticationRequestQueue = value;
            }
        }

        //
        // Methods
        //

        internal static string MakeQueryStr(string connName) {
            return ((connName == null) ? "" : connName);
        }


        /// <devdoc>
        ///    <para>         
        ///       These methods are made available to the underlying Connection
        ///       object so that we don't leak them because we're keeping a local
        ///       reference in our m_ConnectionList.
        ///       Called by the Connection's constructor
        ///    </para>
        /// </devdoc>
        public void Associate(WeakReference connection) {
            lock (m_ConnectionList) {
                m_ConnectionList.Add(connection);                
            }
            GlobalLog.Print("ConnectionGroup::Associate() Connection:" + connection.Target.GetHashCode());
        }
        
        
        
        /// <devdoc>
        ///    <para>         
        ///       Used by the Connection's explicit finalizer (note this is
        ///       not a destructor, since that's never calld unless we
        ///       remove reference to the object from our internal list)        
        ///    </para>
        /// </devdoc>
        public void Disassociate(WeakReference connection) {
            lock (m_ConnectionList) {
                m_ConnectionList.Remove(connection);
            }
        }

        /// <devdoc>
        ///    <para>         
        ///       Called when a connection is idle and ready to process new requests
        ///    </para>
        /// </devdoc>
        internal void ConnectionGoneIdle() {
            if (m_AuthenticationGroup) {
                lock (m_ConnectionList) {
                    AsyncWaitHandle.Set();                    
                }
            }
        }

        /// <devdoc>
        ///    <para>         
        ///       Causes an abort of any aborted requests waiting in the ConnectionGroup
        ///    </para>
        /// </devdoc>
        private void Abort() {            
            lock (m_ConnectionList) {
                m_Abort = true;
                AsyncWaitHandle.Set();
            }
        }

        /// <devdoc>
        ///    <para>         
        ///       Removes aborted requests from our queue. 
        ///    </para>
        /// </devdoc>
        private void PruneAbortedRequests() {
            lock (m_ConnectionList) {
                Queue updatedQueue = new Queue();
                foreach(HttpWebRequest request in AuthenticationRequestQueue) {
                    if (!request.Aborted) {
                        updatedQueue.Enqueue(request);
                    }
                }
                AuthenticationRequestQueue = updatedQueue;
                m_Abort = false;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Forces all connections on the ConnectionGroup to not be KeepAlive.
        ///    </para>
        /// </devdoc>
        internal void DisableKeepAliveOnConnections() {
            lock (m_ConnectionList) {
                GlobalLog.Print("ConnectionGroup#" + ValidationHelper.HashString(this) + "::DisableKeepAliveOnConnections() Count:" + m_ConnectionList.Count);
                foreach (WeakReference currentConnectionReference in m_ConnectionList) {
                    Connection currentConnection = null;
                    if (currentConnectionReference!=null) {
                        currentConnection = currentConnectionReference.Target as Connection;
                    }
                    //
                    // If the weak reference is alive, set KeepAlive to false
                    //
                    if (currentConnection != null) {
                        GlobalLog.Print("ConnectionGroup#" + ValidationHelper.HashString(this) + "::DisableKeepAliveOnConnections() setting KeepAlive to false Connection#" + ValidationHelper.HashString(currentConnection));
                        currentConnection.CloseOnIdle();
                    }
                }
                m_ConnectionList.Clear();
            }
        }



        /// <devdoc>
        ///    <para>         
        ///       Attempts to match a request with a connection, if a connection is unassigned ie not locked with 
        ///         a request, then the least busy connections is returned in "leastbusyConnection."  If the 
        ///         connection limit allows, and all connections are busy, a new one is allocated and returned.
        ///
        ///     RETURNS: a Connection shown to match a previously locked Request/Connection (OTHERWISE)
        ///              leasebusyConnection - will contain a newly allocated Connection or least Busy one
        ///              suiteable for requests.
        ///
        ///     NOTE: For Whidbey: try to integrate this code into FindConnection()
        ///    </para>
        /// </devdoc>
        private Connection FindMatchingConnection(HttpWebRequest request, string connName, out Connection leastbusyConnection) {            
            int minBusyCount = Int32.MaxValue;
            bool freeConnectionsAvail = false;

            leastbusyConnection = null;

            lock (m_ConnectionList) {

                //
                // go through the list of open connections to this service point and pick
                // the first empty one or, if none is empty, pick the least busy one.
                //
                bool completed; 
                do {
                    minBusyCount = Int32.MaxValue;
                    completed = true; // by default, only once through the outer loop
                    foreach (WeakReference currentConnectionReference in m_ConnectionList) {
                        Connection currentConnection = null;
                        if (currentConnectionReference!=null) {
                            currentConnection = currentConnectionReference.Target as Connection;
                        }
                        //
                        // If the weak reference is alive, see if its not busy, 
                        //  otherwise make sure to remove it from the list
                        //
                        if (currentConnection != null) {
                            GlobalLog.Print("ConnectionGroup::FindConnection currentConnection.BusyCount:" + currentConnection.BusyCount.ToString());

                            if (currentConnection.LockedRequest == request) {
                                leastbusyConnection = currentConnection;
                                return currentConnection; 
                            }

                            GlobalLog.Print("ConnectionGroup::FindConnection: lockedRequest# " + ((currentConnection.LockedRequest == null) ? "null" : currentConnection.LockedRequest.GetHashCode().ToString()));
                            if (currentConnection.BusyCount < minBusyCount && currentConnection.LockedRequest == null) {
                                leastbusyConnection = currentConnection;
                                minBusyCount = currentConnection.BusyCount;
                                if (minBusyCount == 0) {
                                    freeConnectionsAvail = true;
                                }
                            }
                        }
                        else {
                            m_ConnectionList.Remove(currentConnectionReference);
                            completed = false;
                            // now start iterating again because we changed the ArrayList
                            break;
                        }
                    }
                } while (!completed);

                //
                // If there is NOT a Connection free, then we allocate a new Connection
                //
                if (!freeConnectionsAvail && CurrentConnections < InternalConnectionLimit) {
                    //
                    // If we can create a new connection, then do it,
                    // this may have complications in pipeling because
                    // we may wish to optimize this case by actually
                    // using existing connections, rather than creating new ones
                    //
                    // Note: this implicately results in a this.Associate being called.
                    //
                    
                    GlobalLog.Print("ConnectionGroup::FindConnection [returning new Connection] CurrentConnections:" + CurrentConnections.ToString() + " InternalConnectionLimit:" + InternalConnectionLimit.ToString());

                    leastbusyConnection =
                        new Connection(
                            this,
                            m_ServicePoint,
                            m_IPAddress,
                            m_ServicePoint.ProtocolVersion,
                            m_ServicePoint.SupportsPipelining
                            );
                    
                }

            }

            return null; // only if we have a locked Connection that matches can return non-null
        }

        /// <devdoc>
        ///    <para>         
        ///       Used by the ServicePoint to find a free or new Connection 
        ///       for use in making Requests, this is done with the cavet,
        ///       that once a Connection is "locked" it can only be used
        ///       by a specific request.
        ///
        ///     NOTE: For Whidbey: try to integrate this code into FindConnection()
        ///    </para>
        /// </devdoc>
        private Connection FindConnectionAuthenticationGroup(HttpWebRequest request, string connName) {
            Connection leastBusyConnection = null;
            
            GlobalLog.Print("ConnectionGroup::FindConnectionAuthenticationGroup [" + connName + "] m_ConnectionList.Count:" + m_ConnectionList.Count.ToString());

            //
            // First try and find a free Connection (i.e. one not busy with Authentication handshake)
            //   or try to find a Request that has already locked a specific Connection,
            //   if a matching Connection is found, then we're done
            //
            lock (m_ConnectionList) {
                Connection matchingConnection;
                matchingConnection = FindMatchingConnection(request, connName, out leastBusyConnection);
                if (matchingConnection != null) {
                    return matchingConnection;
                }

                if (AuthenticationRequestQueue.Count == 0) {
                    if (leastBusyConnection != null) {
                        if (request.LockConnection) {
                            GlobalLog.Print("Assigning New Locked Request#" + request.GetHashCode().ToString());
                            leastBusyConnection.LockedRequest = request;
                        }
                        return leastBusyConnection;                    
                    }
                } else if (leastBusyConnection != null) {
                    AsyncWaitHandle.Set();
                }
                AuthenticationRequestQueue.Enqueue(request);
            }

            //
            // If all the Connections are busy, then we queue ourselves and need to wait.   As soon as 
            //   one of the Connections are free, we grab the lock, and see if we find ourselves
            //   at the head of the queue.  If not, we loop backaround. 
            //   Care is taken to examine the request when we wakeup, in case the request is aborted.
            //
            while (true) {
                GlobalLog.Print("waiting");
                request.AbortDelegate = m_AbortDelegate;
                AsyncWaitHandle.WaitOne();
                GlobalLog.Print("wait up");
                lock(m_ConnectionList) {
                    if (m_Abort) {
                        PruneAbortedRequests();
                    }
                    if (request.Aborted) {
                        throw new WebException(
                            NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.RequestCanceled),
                            WebExceptionStatus.RequestCanceled);
                    }

                    FindMatchingConnection(request, connName, out leastBusyConnection);
                    if (AuthenticationRequestQueue.Peek() == request) {
                        GlobalLog.Print("dequeue");
                        AuthenticationRequestQueue.Dequeue();                                                                        
                        if (leastBusyConnection != null) {
                            if (request.LockConnection) {
                                leastBusyConnection.LockedRequest = request;
                            }
                            return leastBusyConnection;                    
                        }
                        AuthenticationRequestQueue.Enqueue(request);
                    }
                    if (leastBusyConnection == null) {
                        AsyncWaitHandle.Reset();
                    }
                }
            }
        }

        /// <devdoc>
        ///    <para>         
        ///       Used by the ServicePoint to find a free or new Connection 
        ///       for use in making Requests.  Under NTLM and Negotiate requests,
        ///       this function depricates itself and switches the object over to 
        ///       using a new code path (see FindConnectionAuthenticationGroup). 
        ///    </para>
        /// </devdoc>
        public Connection FindConnection(HttpWebRequest request, string connName) {
            Connection leastbusyConnection = null;
            Connection newConnection = null;
            bool freeConnectionsAvail = false;

            if (m_AuthenticationGroup || request.LockConnection) {
                m_AuthenticationGroup = true;
                return FindConnectionAuthenticationGroup(request, connName);
            }
            
            GlobalLog.Print("ConnectionGroup::FindConnection [" + connName + "] m_ConnectionList.Count:" + m_ConnectionList.Count.ToString());

            lock (m_ConnectionList) {

                //
                // go through the list of open connections to this service point and pick
                // the first empty one or, if none is empty, pick the least busy one.
                //
                bool completed; 
                do {
                    int minBusyCount = Int32.MaxValue;
                    completed = true; // by default, only once through the outer loop
                    foreach (WeakReference currentConnectionReference in m_ConnectionList) {
                        Connection currentConnection = null;
                        if (currentConnectionReference!=null) {
                            currentConnection = currentConnectionReference.Target as Connection;
                        }
                        //
                        // If the weak reference is alive, see if its not busy, 
                        //  otherwise make sure to remove it from the list
                        //
                        if (currentConnection != null) {
                            GlobalLog.Print("ConnectionGroup::FindConnection currentConnection.BusyCount:" + currentConnection.BusyCount.ToString());
                            if (currentConnection.BusyCount < minBusyCount) {
                                leastbusyConnection = currentConnection;
                                minBusyCount = currentConnection.BusyCount;
                                if (minBusyCount == 0) {
                                    freeConnectionsAvail = true;
                                    break;
                                }
                            }
                        }
                        else {
                            m_ConnectionList.Remove(currentConnectionReference);
                            completed = false;
                            // now start iterating again because we changed the ArrayList
                            break;
                        }
                    }
                } while (!completed);
                

                //
                // If there is NOT a Connection free, then we allocate a new Connection
                //
                if (!freeConnectionsAvail && CurrentConnections < InternalConnectionLimit) {
                    //
                    // If we can create a new connection, then do it,
                    // this may have complications in pipeling because
                    // we may wish to optimize this case by actually
                    // using existing connections, rather than creating new ones
                    //
                    // Note: this implicately results in a this.Associate being called.
                    //
                    
                    GlobalLog.Print("ConnectionGroup::FindConnection [returning new Connection] freeConnectionsAvail:" + freeConnectionsAvail.ToString() + " CurrentConnections:" + CurrentConnections.ToString() + " InternalConnectionLimit:" + InternalConnectionLimit.ToString());

                    newConnection =
                        new Connection(
                            this,
                            m_ServicePoint,
                            m_IPAddress,
                            m_ServicePoint.ProtocolVersion,
                            m_ServicePoint.SupportsPipelining
                            );
                            
                    
                }
                else {
                    //
                    // All connections are busy, use the least busy one
                    //

                    GlobalLog.Print("ConnectionGroup::FindConnection [returning leastbusyConnection] freeConnectionsAvail:" + freeConnectionsAvail.ToString() + " CurrentConnections:" + CurrentConnections.ToString() + " InternalConnectionLimit:" + InternalConnectionLimit.ToString());
                    GlobalLog.Assert(leastbusyConnection != null, "Connect.leastbusyConnection != null", "All connections have BusyCount equal to Int32.MaxValue");                        

                    newConnection = leastbusyConnection;
                }
            }

            return newConnection;
        }


        [System.Diagnostics.Conditional("DEBUG")]
        internal void Debug(int requestHash) {
            foreach(WeakReference connectionReference in  m_ConnectionList) {
                Connection connection;

                if ( connectionReference != null && connectionReference.IsAlive) {
                    connection = (Connection)connectionReference.Target;
                } else {
                    connection = null;
                }

                if (connection!=null) {
                    connection.Debug(requestHash);
                }
            }
        }

    } // class ConnectionGroup


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_emptywebproxy.cs ===
//------------------------------------------------------------------------------
// <copyright file="_emptywebproxy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------



namespace System.Net {

    internal sealed class EmptyWebProxy : IWebProxy {

        private ICredentials m_credentials;

        public EmptyWebProxy() {
        }

        //
        // IWebProxy interface
        //

        public Uri GetProxy(Uri uri) {
            // this method won't get called by NetClasses because of the IsBypassed test below
            return uri; 
        }

        public bool IsBypassed(Uri uri) {
            return true; // no proxy, always bypasses
        }

        public ICredentials Credentials {
            get {
                return m_credentials;
            }
            set {
                m_credentials = value; // doesn't do anything, but doesn't break contract either
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_dummyclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="_DummyClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if COMNET_DUMMYAUTHCLIENT

namespace System.Net {
    using System.Collections;
    using System.Net.Sockets;

    internal class DummyClient : IAuthenticationModule {

        internal const string AuthType = "Dummy";
        internal static string Signature = AuthType.ToLower(CultureInfo.InvariantCulture);
        internal static int SignatureSize = Signature.Length;

        internal static Hashtable sessions = new Hashtable();

        public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("DummyClient::Authenticate(): " + challenge);

            GlobalLog.Assert(credentials!=null, "DummyClient::Authenticate() credentials==null", "");
            if (credentials == null) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "DummyClient::Authenticate() httpWebRequest==null", "");
            if (httpWebRequest==null || httpWebRequest.ChallengedUri==null) {
                //
                // there has been no challenge:
                // 1) the request never went on the wire
                // 2) somebody other than us is calling into AuthenticationManager
                //
                return null;
            }

            int index = AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {
                return null;
            }

            int blobBegin = index + SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //
            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            string authSession = sessions[httpWebRequest.AuthenticationState] as string;
            GlobalLog.Print("DummyClient::Authenticate() key:" + ValidationHelper.HashString(httpWebRequest.AuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));

            if (authSession==null) {
                NetworkCredential NC = credentials.GetCredential(httpWebRequest.ChallengedUri, Signature);
                GlobalLog.Print("DummyClient::Authenticate() GetCredential() returns:" + ValidationHelper.ToString(NC));

                if (NC==null || NC.UserName==null || (NC.UserName.Length==0 && !(NC is SystemNetworkCredential))) {
                    return null;
                }
                else {
                    authSession = (NC is SystemNetworkCredential) ? string.Empty : NC.domain + "/" + NC.userName;
                }

                GlobalLog.Print("DummyClient::Authenticate() adding authSession:" + ValidationHelper.HashString(authSession) + " for:" + ValidationHelper.HashString(httpWebRequest.AuthenticationState));
                sessions.Add(httpWebRequest.AuthenticationState, authSession);
            }

            int step = Int32.Parse(incoming);
            string clientResponse = (step-1).ToString();
            bool handshakeComplete = step==0;

            if (handshakeComplete) {
                GlobalLog.Print("DummyClient::Authenticate() removing authSession:" + ValidationHelper.HashString(authSession) + " from:" + ValidationHelper.HashString(httpWebRequest.AuthenticationState));
                sessions.Remove(httpWebRequest.AuthenticationState);
            }
            else {
                GlobalLog.Print("DummyClient::Authenticate() keeping authSession:" + ValidationHelper.HashString(authSession) + " for:" + ValidationHelper.HashString(httpWebRequest.AuthenticationState));
            }

            return new Authorization(AuthType + " " + clientResponse, handshakeComplete, string.Empty);
        }

        public bool CanPreAuthenticate {
            get {
                return false;
            }
        }

        public Authorization PreAuthenticate(WebRequest webRequest, ICredentials Credentials) {
            return null;
        }

        public string AuthenticationType {
            get {
                return AuthType;
            }
        }

    }; // class DummyClient


} // namespace System.Net

#endif // #if COMNET_DUMMYAUTHCLIENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_digestclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="_DigestClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Net.Sockets;
    using System.Collections;
    using System.Text;
    using System.Security.Cryptography;
    using System.Security.Permissions;
    using System.Globalization;

    internal class DigestClient : ISessionAuthenticationModule {

        internal const string AuthType = "Digest";
        internal static string Signature = AuthType.ToLower(CultureInfo.InvariantCulture);
        internal static int SignatureSize = Signature.Length;

        private static PrefixLookup challengeCache = new PrefixLookup();

        public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("DigestClient::Authenticate(): " + challenge);

#if XP_WDIGEST
            if (ComNetOS.IsPostWin2K) {
                return XPDigestClient.Authenticate(challenge, webRequest, credentials);
            }
#endif // #if XP_WDIGEST

            GlobalLog.Assert(credentials!=null, "DigestClient::Authenticate() credentials==null", "");
            if (credentials==null || credentials is SystemNetworkCredential) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "DigestClient::Authenticate() httpWebRequest==null", "");
            if (httpWebRequest==null || httpWebRequest.ChallengedUri==null) {
                //
                // there has been no challenge:
                // 1) the request never went on the wire
                // 2) somebody other than us is calling into AuthenticationManager
                //
                return null;
            }

            int index = AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {
                return null;
            }

            string[] prefixes = null;
            string rootPath = httpWebRequest.ChallengedUri.Scheme + "://" + httpWebRequest.ChallengedUri.Host;

            HttpDigestChallenge digestChallenge = HttpDigest.Interpret(challenge, index, httpWebRequest);
            if (digestChallenge==null) {
                return null;
            }

            if (digestChallenge.Domain==null) {
                challengeCache.Add(rootPath, digestChallenge);
            }
            else {
                prefixes = digestChallenge.Domain.Split(" ".ToCharArray());
                for (int i=0; i<prefixes.Length; i++) {
                    challengeCache.Add(prefixes[i], digestChallenge);
                }
            }

            Authorization digestResponse = HttpDigest.Authenticate(digestChallenge, credentials);
            if (digestResponse!=null) {
                if (prefixes==null) {
                    digestResponse.ProtectionRealm = new string[1];
                    digestResponse.ProtectionRealm[0] = rootPath;
                }
                else {
                    digestResponse.ProtectionRealm = prefixes;
                }
            }

            return digestResponse;
        }

        public bool CanPreAuthenticate {
            get {
                return true;
            }
        }

        public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("DigestClient::PreAuthenticate()");

#if XP_WDIGEST
            if (ComNetOS.IsPostWin2K) {
                return XPDigestClient.PreAuthenticate(webRequest, credentials);
            }
#endif // #if XP_WDIGEST

            GlobalLog.Assert(credentials!=null, "DigestClient::PreAuthenticate() credentials==null", "");
            if (credentials==null || credentials is SystemNetworkCredential) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;
            GlobalLog.Assert(httpWebRequest!=null, "DigestClient::PreAuthenticate() httpWebRequest==null", "");
            if (httpWebRequest==null) {
                return null;
            }

            HttpDigestChallenge storedHDC = (HttpDigestChallenge)challengeCache.Lookup(httpWebRequest.ChallengedUri.AbsoluteUri);
            if (storedHDC==null) {
                return null;
            }

            HttpDigestChallenge modifiedHDC = storedHDC.CopyAndIncrementNonce();
            modifiedHDC.HostName            = httpWebRequest.ChallengedUri.Host;
            modifiedHDC.Method              = httpWebRequest.CurrentMethod;
            // Consider:
            // I have also tried PathAndQuery against both IIS 5.0 and IIS 6.0 servers.
            // it didn't make a difference. PathAndQuery is a more complete piece of information
            // investigate with Kevin Damour if WDigest.dll wants the quesry string or not.
            modifiedHDC.Uri             = httpWebRequest.Address.AbsolutePath;
            modifiedHDC.ChallengedUri   = httpWebRequest.ChallengedUri;

            Authorization digestResponse = HttpDigest.Authenticate(modifiedHDC, credentials);

            return digestResponse;
        }

        public string AuthenticationType {
            get {
                return AuthType;
            }
        }

        public bool Update(string challenge, WebRequest webRequest) {
            GlobalLog.Print("DigestClient::Update(): [" + challenge + "]");

#if XP_WDIGEST
            if (ComNetOS.IsPostWin2K) {
                return XPDigestClient.Update(challenge, webRequest);
            }
#endif // #if XP_WDIGEST

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "DigestClient::Update() httpWebRequest==null", "");
            GlobalLog.Assert(httpWebRequest.ChallengedUri!=null, "DigestClient::Update() httpWebRequest.ChallengedUri==null", "");

            // here's how we know if the handshake is complete when we get the response back,
            // (keeping in mind that we need to support stale credentials):
            // !40X - complete & success
            // 40X & stale=false - complete & failure
            // 40X & stale=true - !complete

            if (httpWebRequest.ResponseStatusCode!=httpWebRequest.CurrentAuthenticationState.StatusCodeMatch) {
                GlobalLog.Print("DigestClient::Update(): no status code match. returning true");
                return true;
            }

            int index = challenge==null ? -1 : AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {
                GlobalLog.Print("DigestClient::Update(): no challenge. returning true");
                return true;
            }

            int blobBegin = index + SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //
            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            HttpDigestChallenge digestChallenge = HttpDigest.Interpret(challenge, index, httpWebRequest);
            if (digestChallenge==null) {
                GlobalLog.Print("DigestClient::Update(): not a valid digest challenge. returning true");
                return true;
            }

            GlobalLog.Print("DigestClient::Update(): returning digestChallenge.Stale:" + digestChallenge.Stale.ToString());

            return !digestChallenge.Stale;
        }

        public void ClearSession(WebRequest webRequest) {
        }

        public bool CanUseDefaultCredentials {
            get {
                return false;
            }
        }

    }; // class DigestClient


    internal class HttpDigestChallenge {

        // General authentication related information
        internal string   HostName;
        internal string   Realm;
        internal Uri      ChallengedUri;

        // Digest specific fields
        internal string   Uri;
        internal string   Nonce;
        internal string   Opaque;
        internal bool     Stale;
        internal string   Algorithm;
        internal string   Method;
        internal string   Domain;
        internal string   QualityOfProtection;
        internal string   ClientNonce;
        internal int      NonceCount;
        internal string   Charset;

        internal bool     UTF8Charset;
        internal bool     QopPresent;

        internal MD5CryptoServiceProvider MD5provider = new MD5CryptoServiceProvider();

        public HttpDigestChallenge CopyAndIncrementNonce() {
            HttpDigestChallenge challengeCopy = null;
            lock(this) {
                challengeCopy = this.MemberwiseClone() as HttpDigestChallenge;
                ++NonceCount;
            }
            challengeCopy.MD5provider = new MD5CryptoServiceProvider();
            return challengeCopy;
        }

        public bool defineAttribute(string name, string value) {
            name = name.Trim().ToLower(CultureInfo.InvariantCulture);

            if (name.Equals(HttpDigest.DA_algorithm)) {
                Algorithm = value;
            }
            else if (name.Equals(HttpDigest.DA_cnonce)) {
                ClientNonce = value;
            }
            else if (name.Equals(HttpDigest.DA_nc)) {
                NonceCount = Int32.Parse(value);
            }
            else if (name.Equals(HttpDigest.DA_nonce)) {
                Nonce = value;
            }
            else if (name.Equals(HttpDigest.DA_opaque)) {
                Opaque = value;
            }
            else if (name.Equals(HttpDigest.DA_qop)) {
                QualityOfProtection = value;
                QopPresent = QualityOfProtection!=null && QualityOfProtection.Length>0;
            }
            else if (name.Equals(HttpDigest.DA_realm)) {
                Realm = value;
            }
            else if (name.Equals(HttpDigest.DA_domain)) {
                Domain = value;
            }
            else if (name.Equals(HttpDigest.DA_response)) {
            }
            else if (name.Equals(HttpDigest.DA_stale)) {
                Stale = value.ToLower(CultureInfo.InvariantCulture).Equals("true");
            }
            else if (name.Equals(HttpDigest.DA_uri)) {
                Uri = value;
            }
            else if (name.Equals(HttpDigest.DA_charset)) {
                Charset = value;
            }
            else if (name.Equals(HttpDigest.DA_username)) {
            }
            else {
                //
                // the token is not recognized, this usually
                // happens when there are multiple challenges
                //
                return false;
            }

            return true;
        }
    }


    internal class HttpDigest {
        //
        // these are the tokens defined by Digest
        // http://www.ietf.org/rfc/rfc2831.txt
        //
        internal const string DA_algorithm  = "algorithm";
        internal const string DA_cnonce     = "cnonce"; // client-nonce
        internal const string DA_domain     = "domain";
        internal const string DA_nc         = "nc"; // nonce-count
        internal const string DA_nonce      = "nonce";
        internal const string DA_opaque     = "opaque";
        internal const string DA_qop        = "qop"; // quality-of-protection
        internal const string DA_realm      = "realm";
        internal const string DA_response   = "response";
        internal const string DA_stale      = "stale";
        internal const string DA_uri        = "uri";
        internal const string DA_username   = "username";
        internal const string DA_charset    = "charset";

        private const string SupportedQuality = "auth";
        private const string ValidSeparator = ", \"\'\t\r\n";

        //
        // consider internally caching the nonces sent to us by a server so that
        // we can correctly send out nonce counts for subsequent requests

        //
        // used to create a random nonce
        //
        private static readonly RNGCryptoServiceProvider RandomGenerator = new RNGCryptoServiceProvider();
        //
        // this method parses the challenge and breaks it into the
        // fundamental pieces that Digest defines and understands
        //
        public static HttpDigestChallenge Interpret(string challenge, int startingPoint, HttpWebRequest httpWebRequest) {
            HttpDigestChallenge hdc = new HttpDigestChallenge();
            hdc.HostName        = httpWebRequest.ChallengedUri.Host;
            hdc.Method          = httpWebRequest.CurrentMethod;
            hdc.Uri             = httpWebRequest.Address.AbsolutePath;
            hdc.ChallengedUri   = httpWebRequest.ChallengedUri;

            //
            // define the part of the challenge we really care about
            //
            startingPoint += DigestClient.SignatureSize;

            bool valid;
            int start, offset, index;
            string name, value;

            // forst time parse looking for a charset="utf-8" directive
            // not too bad, IIS 6.0, by default, sends this as the first directive.
            // if the server does not send this we'll end up parsing twice.
            start = startingPoint;
            for (;;) {
                offset = start;
                index = AuthenticationManager.SplitNoQuotes(challenge, ref offset);
                if (offset<0) {
                    break;
                }
                name = challenge.Substring(start, offset-start);
                if (string.Compare(name, DA_charset, true, CultureInfo.InvariantCulture)==0) {
                    if (index<0) {
                        value = unquote(challenge.Substring(offset+1));
                    }
                    else {
                        value = unquote(challenge.Substring(offset+1, index-offset-1));
                    }
                    GlobalLog.Print("HttpDigest::Interpret() server provided a hint to use [" + value + "] encoding");
                    if (string.Compare(value, "utf-8", true, CultureInfo.InvariantCulture)==0) {
                        hdc.UTF8Charset = true;
                        break;
                    }
                }
                if (index<0) {
                    break;
                }
                start = ++index;
            }

            // this time go through the directives, parse them and call defineAttribute()
            start = startingPoint;
            for (;;) {
                offset = start;
                index = AuthenticationManager.SplitNoQuotes(challenge, ref offset);
                GlobalLog.Print("HttpDigest::Interpret() SplitNoQuotes() returning index:" + index.ToString() + " offset:" + offset.ToString());
                if (offset<0) {
                    break;
                }
                name = challenge.Substring(start, offset-start);
                if (index<0) {
                    value = unquote(challenge.Substring(offset+1));
                }
                else {
                    value = unquote(challenge.Substring(offset+1, index-offset-1));
                }
                if (hdc.UTF8Charset) {
                    bool isAscii = true;
                    for (int i=0; i<value.Length; i++) {
                        if (value[i]>(char)0x7F) {
                            isAscii = false;
                            break;
                        }
                    }
                    if (!isAscii) {
                        GlobalLog.Print("HttpDigest::Interpret() UTF8 decoding required value:[" + value + "]");
                        byte[] bytes = new byte[value.Length];
                        for (int i=0; i<value.Length; i++) {
                            bytes[i] = (byte)value[i];
                        }
                        value = Encoding.UTF8.GetString(bytes);
                        GlobalLog.Print("HttpDigest::Interpret() UTF8 decoded value:[" + value + "]");
                    }
                    else {
                        GlobalLog.Print("HttpDigest::Interpret() no need for special encoding");
                    }
                }
                valid = hdc.defineAttribute(name, value);
                GlobalLog.Print("HttpDigest::Interpret() defineAttribute(" + name + ", " + value + ") returns " + valid.ToString());
                if (index<0 || !valid) {
                    break;
                }
                start = ++index;
            }

            return hdc;
        }

        private enum Charset {
            ASCII,
            ANSI,
            UTF8
        }

        private static string CharsetEncode(string rawString, Charset charset) {
#if TRAVE
            GlobalLog.Print("HttpDigest::CharsetEncode() encoding rawString:[" + rawString + "] Chars(rawString):[" + Chars(rawString) + "] charset:[" + charset + "]");
#endif // #if TRAVE
            if (charset==Charset.UTF8 || charset==Charset.ANSI) {
                byte[] bytes = charset==Charset.UTF8 ? Encoding.UTF8.GetBytes(rawString) : Encoding.Default.GetBytes(rawString);
                // the following code is the same as:
                // rawString = Encoding.Default.GetString(bytes);
                // but it's faster.
                char[] chars = new char[bytes.Length];
                bytes.CopyTo(chars, 0);
                rawString = new string(chars);
            }
#if TRAVE
            GlobalLog.Print("HttpDigest::CharsetEncode() encoded rawString:[" + rawString + "] Chars(rawString):[" + Chars(rawString) + "] charset:[" + charset + "]");
#endif // #if TRAVE
            return rawString;
        }

        private static Charset DetectCharset(string rawString) {
            Charset charset = Charset.ASCII;
            for (int i=0; i<rawString.Length; i++) {
                if (rawString[i]>(char)0x7F) {
                    GlobalLog.Print("HttpDigest::Authenticate() found non ASCII character:[" + ((int)rawString[i]).ToString() + "] at offset i:[" + i.ToString() + "] charset:[" + charset.ToString() + "]");
                    // lame, but the only way we can tell if we can use default ANSI encoding is see
                    // in the encode/decode process there is no loss of information.
                    byte[] bytes = Encoding.Default.GetBytes(rawString);
                    string rawCopy = Encoding.Default.GetString(bytes);
                    charset = string.Compare(rawString, rawCopy, false, CultureInfo.InvariantCulture)==0 ? Charset.ANSI : Charset.UTF8;
                    break;
                }
            }
            GlobalLog.Print("HttpDigest::DetectCharset() rawString:[" + rawString + "] has charset:[" + charset.ToString() + "]");
            return charset;
        }

#if TRAVE
        private static string Chars(string rawString) {
            string returnString = "[";
            for (int i=0; i<rawString.Length; i++) {
                if (i>0) {
                    returnString += ",";
                }
                returnString += ((int)rawString[i]).ToString();
            }
            return returnString + "]";
        }
#endif // #if TRAVE

        /*
         *  This is to support built-in auth modules under semitrusted environment
         *  Used to get access to UserName, Domain and Password properties of NetworkCredentials
         *  Declarative Assert is much faster and we don;t call dangerous methods inside this one.
         */
        [EnvironmentPermission(SecurityAction.Assert,Unrestricted=true)]
        [SecurityPermissionAttribute( SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
        //
        // CONSIDER V.NEXT
        // creating a static hashtable for server nonces and keep track of nonce count
        //
        public static Authorization Authenticate(HttpDigestChallenge digestChallenge, ICredentials credentials) {
            NetworkCredential NC = credentials.GetCredential(digestChallenge.ChallengedUri, DigestClient.Signature);
            GlobalLog.Print("HttpDigest::Authenticate() GetCredential() returns:" + ValidationHelper.ToString(NC));

            if (NC==null) {
                return null;
            }
            string username = NC.UserName;
            if (ValidationHelper.IsBlankString(username)) {
                return null;
            }
            string password = NC.Password;

            if (digestChallenge.QopPresent) {
                if (digestChallenge.ClientNonce==null || digestChallenge.Stale) {
                    GlobalLog.Print("HttpDigest::Authenticate() QopPresent:True, need new nonce. digestChallenge.ClientNonce:" + ValidationHelper.ToString(digestChallenge.ClientNonce) + " digestChallenge.Stale:" + digestChallenge.Stale.ToString());
                    digestChallenge.ClientNonce = createNonce(32);
                    digestChallenge.NonceCount = 1;
                }
                else {
                    GlobalLog.Print("HttpDigest::Authenticate() QopPresent:True, reusing nonce. digestChallenge.NonceCount:" + digestChallenge.NonceCount.ToString());
                    digestChallenge.NonceCount++;
                }
            }

            StringBuilder authorization = new StringBuilder();

            //
            // look at username & password, if it's not ASCII we need to attempt some
            // kind of encoding because we need to calculate the hash on byte[]
            //
            Charset usernameCharset = DetectCharset(username);
            if (!digestChallenge.UTF8Charset && usernameCharset==Charset.UTF8) {
                GlobalLog.Print("HttpDigest::Authenticate() can't authenticate with UNICODE username. failing auth.");
                return null;
            }
            Charset passwordCharset = DetectCharset(password);
            if (!digestChallenge.UTF8Charset && passwordCharset==Charset.UTF8) {
                GlobalLog.Print("HttpDigest::Authenticate() can't authenticate with UNICODE password. failing auth.");
                return null;
            }
            if (digestChallenge.UTF8Charset) {
                // on the wire always use UTF8 when the server supports it
                authorization.Append(pair(DA_charset, "utf-8", false));
                authorization.Append(",");
                if (usernameCharset==Charset.UTF8) {
                    username = CharsetEncode(username, Charset.UTF8);
                    authorization.Append(pair(DA_username, username, true));
                    authorization.Append(",");
                }
                else {
                    authorization.Append(pair(DA_username, CharsetEncode(username, Charset.UTF8), true));
                    authorization.Append(",");
                    username = CharsetEncode(username, usernameCharset);
                }
            }
            else {
                // otherwise UTF8 is not required
                username = CharsetEncode(username, usernameCharset);
                authorization.Append(pair(DA_username, username, true));
                authorization.Append(",");
            }

            password = CharsetEncode(password, passwordCharset);

            // no special encoding for the realm since we're just going to echo it back (encoding must have happened on the server).
            authorization.Append(pair(DA_realm, digestChallenge.Realm, true));
            authorization.Append(",");
            authorization.Append(pair(DA_nonce, digestChallenge.Nonce, true));
            authorization.Append(",");
            authorization.Append(pair(DA_uri, digestChallenge.Uri, true));

            if (digestChallenge.QopPresent) {
                //
                // RAID#47397
                // send only the QualityOfProtection we're using
                // since we support only "auth" that's what we will send out
                //
                if (digestChallenge.Algorithm!=null) {
                    //
                    // consider: should we default to "MD5" here? IE does
                    //
                    authorization.Append(",");
                    authorization.Append(pair(DA_algorithm, digestChallenge.Algorithm, true)); // IE sends quotes - IIS needs them
                }
                authorization.Append(",");
                authorization.Append(pair(DA_cnonce, digestChallenge.ClientNonce, true));
                authorization.Append(",");
                authorization.Append(pair(DA_nc, digestChallenge.NonceCount.ToString("x8"), false));
                authorization.Append(",");
                authorization.Append(pair(DA_qop, SupportedQuality, true)); // IE sends quotes - IIS needs them
            }

            // warning: this must be computed here
            string responseValue = HttpDigest.responseValue(digestChallenge, username, password);
            if (responseValue==null) {
                return null;
            }

            authorization.Append(",");
            authorization.Append(pair(DA_response, responseValue, true)); // IE sends quotes - IIS needs them

            if (digestChallenge.Opaque!=null) {
                authorization.Append(",");
                authorization.Append(pair(DA_opaque, digestChallenge.Opaque, true));
            }

            GlobalLog.Print("HttpDigest::Authenticate() digestChallenge.Stale:" + digestChallenge.Stale.ToString());

            // completion is decided in Update()
            Authorization finalAuthorization = new Authorization(DigestClient.AuthType + " " + authorization.ToString(), false);

            return finalAuthorization;
        }

        internal static string unquote(string quotedString) {
            return quotedString.Trim().Trim("\"".ToCharArray());
        }

        // Returns the string consisting of <name> followed by
        // an equal sign, followed by the <value> in double-quotes
        private static string pair(string name, string value, bool quote) {
            if (quote) {
                return name + "=\"" + value + "\"";
            }
            return name + "=" + value;
        }

        //
        // this method computes the response-value according to the
        // rules described in RFC2831 section 2.1.2.1
        //
        private static string responseValue(HttpDigestChallenge challenge, string username, string password) {
            string secretString = computeSecret(challenge, username, password);
            if (secretString == null) {
                return null;
            }

            string dataString = computeData(challenge);
            if (dataString == null) {
                return null;
            }

            string secret = hashString(secretString, challenge.MD5provider);
            string hexMD2 = hashString(dataString, challenge.MD5provider);

            string data =
                challenge.Nonce + ":" +
                    (challenge.QopPresent ?
                        challenge.NonceCount.ToString("x8") + ":" +
                        challenge.ClientNonce + ":" +
                        challenge.QualityOfProtection + ":" +
                        hexMD2
                        :
                        hexMD2);

            return hashString(secret + ":" + data, challenge.MD5provider);
        }

        private static string computeSecret(HttpDigestChallenge challenge, string username, string password) {
            if (challenge.Algorithm==null || string.Compare(challenge.Algorithm, "md5" ,true, CultureInfo.InvariantCulture)==0) {
                return username + ":" + challenge.Realm + ":" + password;
            }
            else if (string.Compare(challenge.Algorithm, "md5-sess" ,true, CultureInfo.InvariantCulture)==0) {
                return hashString(username + ":" + challenge.Realm + ":" + password, challenge.MD5provider) + ":" + challenge.Nonce + ":" + challenge.ClientNonce;
            }

            throw new NotSupportedException(SR.GetString(SR.net_HashAlgorithmNotSupportedException, challenge.Algorithm));
        }


        private static string computeData(HttpDigestChallenge challenge) {
            // we only support "auth" QualityOfProtection. if it's not what the server wants we'll throw:
            // the case in which the server sends no qop directive defaults to "auth" QualityOfProtection.
            if (challenge.QopPresent) {
                int index = 0;
                while (index>=0) {
                    // find the next occurence of "auth"
                    index = challenge.QualityOfProtection.IndexOf(SupportedQuality, index);
                    if (index<0) {
                        throw new NotSupportedException(SR.GetString(SR.net_QOPNotSupportedException, challenge.QualityOfProtection));
                    }
                    // if it's a whole word we're done
                    if ((index==0 || ValidSeparator.IndexOf(challenge.QualityOfProtection[index - 1])>=0) &&
                        (index+SupportedQuality.Length==challenge.QualityOfProtection.Length || ValidSeparator.IndexOf(challenge.QualityOfProtection[index + SupportedQuality.Length])>=0) ) {
                        break;
                    }
                    index += SupportedQuality.Length;
                }
            }
            return challenge.Method + ":" + challenge.Uri;
        }

        private static string hashString(string myString, MD5CryptoServiceProvider MD5provider) {
            GlobalLog.Enter("HttpDigest::hashString", "[" + myString.Length.ToString() + ":" + myString + "]");
            byte[] encodedBytes = new byte[myString.Length];
            for (int i=0; i<myString.Length; i++) {
                encodedBytes[i] = (byte)myString[i];
            }
            byte[] hash = MD5provider.ComputeHash(encodedBytes);
            string hashString = hexEncode(hash);
            GlobalLog.Leave("HttpDigest::hashString", "[" + hashString.Length.ToString() + ":" + hashString + "]");
            return hashString;
        }

        private static string hexEncode(byte[] rawbytes) {
            int size = rawbytes.Length;
            char[] wa = new char[2*size];

            for (int i=0, dp=0; i<size; i++) {
                // warning: these ARE case sensitive
                wa[dp++] = Uri.HexLowerChars[rawbytes[i]>>4];
                wa[dp++] = Uri.HexLowerChars[rawbytes[i]&0x0F];
            }

            return new string(wa);
        }

        /* returns a random nonce of given length */
        private static string createNonce(int length) {
            // we'd need less (half of that), but this makes the code much simpler
            int bytesNeeded = length;
            byte[] randomBytes = new byte[bytesNeeded];
            char[] digits = new char[length];
            RandomGenerator.GetBytes(randomBytes);
            for (int i=0; i<length; i++) {
                // warning: these ARE case sensitive
                digits[i] = Uri.HexLowerChars[randomBytes[i]%0x0F];
            }
            return new string(digits);
        }

    }; // class HttpDigest


#if XP_WDIGEST
    //
    // Windows XP will ship with a dll called WDigest.dll, that supports the Digest
    // authentication scheme (in addition to support for HTTP client sides,
    // it also supports HTTP erver side and SASL) through SSPI. On XP, start using that.
    //
    internal class XPDigestClient {

        internal static Hashtable sessions = new Hashtable();

        public static Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("XPDigestClient::Authenticate(): " + challenge);

            GlobalLog.Assert(credentials!=null, "XPDigestClient::Authenticate() credentials==null", "");
            if (credentials == null) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "XPDigestClient::Authenticate() httpWebRequest==null", "");
            if (httpWebRequest==null || httpWebRequest.ChallengedUri==null) {
                //
                // there has been no challenge:
                // 1) the request never went on the wire
                // 2) somebody other than us is calling into AuthenticationManager
                //
                return null;
            }

            int index = AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), DigestClient.Signature);
            if (index < 0) {
                return null;
            }

            int blobBegin = index + DigestClient.SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //
            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            NTAuthentication authSession = sessions[httpWebRequest.CurrentAuthenticationState] as NTAuthentication;
            GlobalLog.Print("XPDigestClient::Authenticate() key:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));

            if (authSession==null) {
                NetworkCredential NC = credentials.GetCredential(httpWebRequest.ChallengedUri, DigestClient.Signature);
                GlobalLog.Print("XPDigestClient::Authenticate() GetCredential() returns:" + ValidationHelper.ToString(NC));

                if (NC==null) {
                    return null;
                }
                string username = NC.UserName;
                if (username==null || (username.Length==0 && !(NC is SystemNetworkCredential))) {
                    return null;
                }
                authSession =
                    new NTAuthentication(
                        "WDigest",
                        NC,
                        httpWebRequest.ChallengedUri.AbsolutePath,
                        httpWebRequest.DelegationFix);

                GlobalLog.Print("XPDigestClient::Authenticate() adding authSession:" + ValidationHelper.HashString(authSession) + " for:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState));
                sessions.Add(httpWebRequest.CurrentAuthenticationState, authSession);
            }

            bool handshakeComplete;
            string clientResponse = authSession.GetOutgoingDigestBlob(incoming, httpWebRequest.CurrentMethod, out handshakeComplete);

            GlobalLog.Print("XPDigestClient::Authenticate() GetOutgoingDigestBlob(" + incoming + ") returns:" + ValidationHelper.ToString(clientResponse));

            GlobalLog.Assert(handshakeComplete, "XPDigestClient::Authenticate() handshakeComplete==false", "");
            if (!handshakeComplete) {
                return null;
            }

            // completion is decided in Update()
            Authorization finalAuthorization = new Authorization(DigestClient.AuthType + " " + clientResponse, false);

            return finalAuthorization;
        }

        public static Authorization PreAuthenticate(WebRequest webRequest, ICredentials Credentials) {
            //
            // NYI
            //
            return null;
        }

        public static bool Update(string challenge, WebRequest webRequest) {
            GlobalLog.Print("XPDigestClient::Update(): " + challenge);

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "XPDigestClient::Update() httpWebRequest==null", "");
            if (httpWebRequest==null || httpWebRequest.ChallengedUri==null) {
                //
                // there has been no challenge:
                // 1) the request never went on the wire
                // 2) somebody other than us is calling into AuthenticationManager
                //
                GlobalLog.Print("XPDigestClient::Update(): no request. returning true");
                return true;
            }

            NTAuthentication authSession = sessions[httpWebRequest.CurrentAuthenticationState] as NTAuthentication;
            GlobalLog.Print("XPDigestClient::Update() key:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));
            if (authSession==null) {
                return false;
            }

            int index = challenge==null ? -1 : AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), DigestClient.Signature);
            if (index < 0) {
                GlobalLog.Print("XPDigestClient::Update(): no challenge. returning true");
                return true;
            }

            // here's how we know if the handshake is complete when we get the response back,
            // (keeping in mind that we need to support stale credentials):
            // !40X - complete & success
            // 40X & stale=false - complete & failure
            // 40X & stale=true - !complete

            if (httpWebRequest.ResponseStatusCode!=httpWebRequest.CurrentAuthenticationState.StatusCodeMatch) {
                GlobalLog.Print("XPDigestClient::Update() removing authSession:" + ValidationHelper.HashString(authSession) + " from:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState));
                sessions.Remove(httpWebRequest.CurrentAuthenticationState);

                GlobalLog.Print("XPDigestClient::Update(): no status code match. returning true");
                return true;
            }

            int blobBegin = index + DigestClient.SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //
            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            // we should get here only on invalid or stale credentials:

            bool handshakeComplete;
            string clientResponse = authSession.GetOutgoingDigestBlob(incoming, httpWebRequest.CurrentMethod, out handshakeComplete);

            GlobalLog.Print("XPDigestClient::Update() GetOutgoingDigestBlob(" + incoming + ") returns:" + ValidationHelper.ToString(clientResponse));

            GlobalLog.Assert(handshakeComplete, "XPDigestClient::Update() handshakeComplete==false", "");

            GlobalLog.Print("XPDigestClient::Update() GetOutgoingBlob() returns clientResponse:[" + ValidationHelper.ToString(clientResponse) + "] handshakeComplete:" + handshakeComplete.ToString());

            return handshakeComplete;
        }

        public void ClearSession(WebRequest webRequest) {
            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;
            sessions.Remove(httpWebRequest.CurrentAuthenticationState);
        }


    }; // class XPDigestClient

#endif // #if XP_WDIGEST


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_cookiemodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="_CookieModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    internal class CookieModule {

    // fields

    // constructors

    // properties

    // methods                                  

        internal static void OnSendingHeaders(HttpWebRequest httpWebRequest) {
            GlobalLog.Print("CookieModule::OnSendingHeaders()");
            try {
                if (httpWebRequest.CookieContainer == null) {
                    return;
                }
                //
                // remove all current cookies. This could be a redirect
                //
                httpWebRequest.Headers.RemoveInternal(HttpKnownHeaderNames.Cookie);
                //
                // add in the new headers from the cookie container for this request
                //
                string optCookie2;
                string cookieString = httpWebRequest.CookieContainer.GetCookieHeader(
                                                                            httpWebRequest.Address,
                                                                            out optCookie2);

                if (cookieString.Length > 0) {
                    GlobalLog.Print("CookieModule::OnSendingHeaders() setting Cookie header to:[" + cookieString + "]");
                    httpWebRequest.Headers[HttpKnownHeaderNames.Cookie] = cookieString;

//Consider V.Next
//Consider enabling automatic Cookie2: on the  request
//                    if (optCookie2.Length != 0) {
//                        httpWebRequest.Headers[HttpKnownHeaderNames.Cookie2] = optCookie2;
//                    }
                }
            }
            catch {
            }

        }

        internal static void OnReceivedHeaders(HttpWebRequest httpWebRequest) {
            GlobalLog.Print("CookieModule.OnReceivedHeaders()");
            //
            // if the app doesn't want us to handle cookies then there's nothing
            // to do. Note that we're leaving open the possibility that these
            // settings could be changed between the request being made and the
            // response received
            //
            try {
                if (httpWebRequest.CookieContainer == null) {
                    return;
                }

                //
                // add any received cookies for this response to the container
                //
                HttpWebResponse response = (HttpWebResponse)httpWebRequest._HttpResponse;
                CookieCollection cookies = null;
                try {
                    string cookieString = response.Headers[HttpKnownHeaderNames.SetCookie];
                    GlobalLog.Print("CookieModule::OnSendingHeaders() received Set-Cookie:[" + cookieString + "]");
                    if ((cookieString != null) && (cookieString.Length > 0)) {
                        cookies = httpWebRequest.CookieContainer.CookieCutter(
                                                            response.ResponseUri,
                                                            HttpKnownHeaderNames.SetCookie,
                                                            cookieString,
                                                            false);
                    }
                }
                catch {
                }

                try {
                    string cookieString = response.Headers[HttpKnownHeaderNames.SetCookie2];
                    GlobalLog.Print("CookieModule::OnSendingHeaders() received Set-Cookie2:[" + cookieString + "]");
                    if ((cookieString != null) && (cookieString.Length > 0)) {
                        CookieCollection cookies2 = httpWebRequest.CookieContainer.CookieCutter(
                                                                    response.ResponseUri,
                                                                    HttpKnownHeaderNames.SetCookie2,
                                                                    cookieString,
                                                                    false);
                        if (cookies != null && cookies.Count != 0) {
                            cookies.Add(cookies2);
                        }
                        else {
                            cookies = cookies2;
                        }
                    }
                }
                catch {
                }
                if (cookies != null) {
                    response.Cookies = cookies;
                }
            }
            catch {
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_connectstream.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ConnectStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Diagnostics;
    using System.IO;
    using System.Net.Sockets;
    using System.Runtime.InteropServices;
    using System.Threading;

    /*++

        ConnectStream  - a stream interface to a Connection object.

        This class implements the Stream interface, as well as a
        WriteHeaders call. Inside this stream we handle details like
        chunking, dechunking and tracking of ContentLength. To write
        or read data, we call a method on the connection object. The
        connection object is responsible for protocol stuff that happens
        'below' the level of the HTTP request, for example MUX or SSL

    --*/

    internal class ConnectStream : Stream, IDisposable {

        private     int             m_CallNesting;          // > 0 if we're in a Read/Write call
        private     ScatterGatherBuffers
                                    m_BufferedData;        // list of sent buffers in case of resubmit (redirect/authentication).
        private     bool            m_WriteBufferEnable;    // enabled Write Buffer
        private     bool            m_BufferOnly;           // don't write data to the connection, only buffer it
        private     long            m_TotalBytesToWrite;    // Total bytes to be written to the connection (headers excluded).
        private     long            m_BytesLeftToWrite;     // Total bytes left to be written.
        private     Connection      m_Connection;           // Connection for I/O.
        private     bool            m_WriteStream;          // True if this is a write stream.
        private     byte[]          m_ReadBuffer;           // Read buffer for read stream.
        private     int             m_ReadOffset;           // Offset into m_ReadBuffer.
        private     int             m_ReadBufferSize;       // Bytes left in m_ReadBuffer.
        private     long            m_ReadBytes;            // Total bytes to read on stream, -1 for read to end.
        private     bool            m_Chunked;              // True if we're doing chunked read.
        private     int             m_DoneCalled;           // 0 at init, 1 after we've called Read/Write Done
        private     int             m_ShutDown;             // 0 at init, 1 after we've called Complete
        private     bool            m_NeedCallDone;         // True if we need to call the Connection.ReadDone
                                                            // or Connection.WriteDone method after all data is
                                                            // processed after we've read all the data.
        private     Exception       m_ErrorException;       // non-null if we've seen an error on this connection.
        private     bool            m_ChunkEofRecvd;        // True, if we've seen an EOF, or reached a EOF state for no more reads
        private     int             m_ChunkSize;            // Number of bytes in current chunk.
        private     byte[]          m_TempBuffer;           // A temporary buffer.
        private     bool            m_ChunkedNeedCRLFRead;  // true - when we need to read a /r/n before a chunk size
        private     bool            m_Draining;             // true - when we're draining. needed to handle chunked draining.        

        private const long m_MaxDrainBytes = 64 * 1024; // 64 K - greater than, we should just close the connection
        private static readonly byte[] m_CRLF = new byte[]{(byte)'\r', (byte)'\n'};
        private static readonly byte[] m_ChunkTerminator = new byte[]{(byte)'0', (byte)'\r',(byte)'\n', (byte)'\r', (byte)'\n'};

        private static readonly WaitCallback m_ReadChunkedCallbackDelegate = new WaitCallback(ReadChunkedCallback);
        private static readonly AsyncCallback m_ReadCallbackDelegate = new AsyncCallback(ReadCallback);
        private static readonly AsyncCallback m_WriteCallbackDelegate = new AsyncCallback(WriteCallback);

        private HttpWebRequest m_Request;

        private ManualResetEvent m_WriteDoneEvent;
        private void SetWriteDone() {
            BytesLeftToWrite = 0;
            if (m_WriteDoneEvent!=null) {
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::SetWriteDone() setting WriteDoneEvent#" + ValidationHelper.HashString(m_WriteDoneEvent) + " BytesLeftToWrite:" + BytesLeftToWrite);
                m_WriteDoneEvent.Set();
            }
        }
        internal void WaitWriteDone() {
            if (BytesLeftToWrite==0) {
                return;
            }
            if (m_WriteDoneEvent==null) {
                m_WriteDoneEvent = new ManualResetEvent(false);
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::WaitWriteDone() created WriteDoneEvent#" + ValidationHelper.HashString(m_WriteDoneEvent) + " BytesLeftToWrite:" + BytesLeftToWrite);
            }
            if (BytesLeftToWrite!=0) {
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::WaitWriteDone() waiting WriteDoneEvent#" + ValidationHelper.HashString(m_WriteDoneEvent) + " BytesLeftToWrite:" + BytesLeftToWrite);
                m_WriteDoneEvent.WaitOne();
            }
        }

        //
        // Timeout - timeout in ms for sync reads & writes, passed in HttpWebRequest
        //    should make this part of Stream base class for next version
        //
        private int m_Timeout;
        internal int Timeout {
            set {
                m_Timeout = value;
            }
            get {
                return m_Timeout;
            }
        }

        //
        // If IgnoreSocketWrite==true then no data will be sent to the wire
        //
        private bool m_IgnoreSocketWrite;
        internal bool IgnoreSocketWrite {
            get {
                return m_IgnoreSocketWrite;
            }
        }
        //
        // If the KeepAlive=true then we  must prepare for a write socket error still trying flush the body
        // If the KeepAlive=false then we should cease body writing as the connection is dying
        //
        private bool m_ErrorResponseStatus;
        internal void ErrorResponseNotify(bool isKeepAlive) {
            GlobalLog.Print("ConnectStream:: Got notification on Error Response, KeepAlive = " + isKeepAlive);
            m_ErrorResponseStatus = true;
            m_IgnoreSocketWrite = !isKeepAlive;
        }


        private static bool s_UnloadInProgress = false;
        internal static void AppDomainUnloadEvent(object sender, EventArgs e) {
            s_UnloadInProgress = true;
        }

        static ConnectStream() {
            AppDomain.CurrentDomain.DomainUnload += new EventHandler(AppDomainUnloadEvent);
        }

        /*++
            Write Constructor for this class. This is the write constructor;
            it takes as a parameter the amount of entity body data to be written,
            with a value of -1 meaning to write it out as chunked. The other
            parameter is the Connection of which we'll be writing.

            Right now we use the DefaultBufferSize for the stream. In
            the future we'd like to pass a 0 and have the stream be
            unbuffered for write.

            Input:

                Conn            - Connection for this stream.
                BytesToWrite    - Total bytes to be written, or -1
                                    if we're doing chunked encoding.

            Returns:

                Nothing.

        --*/

        public ConnectStream(
            Connection connection,
            long bytesToWrite,
            HttpWebRequest request ) {

            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::.ctor(Write)");

            m_TotalBytesToWrite = m_BytesLeftToWrite = bytesToWrite;
            m_Connection = connection;
            m_WriteStream = true;
            m_NeedCallDone = true;
            m_Timeout = System.Threading.Timeout.Infinite; 
            //
            // we need to save a reference to the request for two things
            // 1. In case of buffer-only we kick in actual submition when the stream is closed by a user
            // 2. In case of write stream abort() we notify the request so the response stream is handled properly
            //
            m_Request = request;
            if (request.BufferHeaders) {
                m_BufferOnly = true;
                EnableWriteBuffering();
            }

            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::.ctor() Connection:" + ValidationHelper.HashString(m_Connection) + " TotalBytesToWrite:" + bytesToWrite.ToString());
        }

        /*++

            Read constructor for this class. This constructor takes in
            the connection and some information about a buffer that already
            contains data. Reads from this stream will read first from the
            buffer, and after that is exhausted will read from the connection.

            We also take in a size of bytes to read, or -1 if we're to read
            to connection close, and a flag indicating whether or now
            we're chunked.

            Input:

                Conn                - Connection for this stream.
                buffer              - Initial buffer to read from.
                offset              - offset into buffer to start reading.
                size               - number of bytes in buffer to read.
                readSize            - Number of bytes allowed to be read from
                                        the stream, -1 for read to connection
                                        close.
                chunked             - True if we're doing chunked decoding.
                needReadDone        - True if we're to call read done at the
                                        end of the read.

            Returns:

                Nothing.

        --*/

        public ConnectStream(
            Connection connection,
            byte[] buffer,
            int offset,
            int bufferCount,
            long readCount,
            bool chunked,
            bool needReadDone
#if DEBUG
            ,HttpWebRequest request
#endif
            ) {

            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::.ctor(Read)");

            m_ReadBuffer = buffer;
            m_ReadOffset = offset;
            m_ReadBufferSize = bufferCount;
            m_ReadBytes = readCount;
            m_NeedCallDone = needReadDone;
            m_Timeout = System.Threading.Timeout.Infinite; 
            m_Chunked = chunked;
            m_Connection = connection;
            m_TempBuffer = new byte[2];

#if DEBUG
            m_Request = request;
#endif

            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::.ctor() Connection:" + ValidationHelper.HashString(m_Connection) + " m_ReadBytes:" + m_ReadBytes.ToString() + " m_NeedCallDone:" + m_NeedCallDone.ToString() + " m_Chunked:" + m_Chunked.ToString());

            if (m_ReadBytes == 0) {
                CallDone();
            }
        }

        internal Connection Connection {
            get {
                return m_Connection;
            }
        }

        internal bool BufferOnly {
            get {
                return m_BufferOnly;
            }
        }

        internal ScatterGatherBuffers BufferedData {
            get {
                return m_BufferedData;
            }
            set {
                m_BufferedData = value;
            }
        }

        private long TotalBytesToWrite {
            get {
                return m_TotalBytesToWrite;
            }
            set {
                m_TotalBytesToWrite = value;
            }
        }

        private bool WriteChunked {
            get {
                return m_TotalBytesToWrite==-1;
            }
        }

        internal long BytesLeftToWrite {
            get {
                return m_BytesLeftToWrite;
            }
            set {
                m_BytesLeftToWrite = value;
            }
        }

        internal bool CallInProgress {
            get {
                return (m_CallNesting > 0);
            }
        }

        internal bool AnotherCallInProgress(int callNesting) {
            return (callNesting > 1);
        }


        /*++

            Stream ContentLength. This is actual size of the stream we are reading,
            as opposed to the content-length returned from the server.  This is used
            today mainly for HEAD requests, which return a content-length, but actually
            have a 0 sized stream.

            Input: Content-Length of data to read.

            Returns: Content-Length left to read of data through this stream.

         --*/

        internal long StreamContentLength {
            get {
                return m_ReadBytes;
            }
            set {
                m_ReadBytes = value;

                if (m_ReadBytes == 0) {
                    CallDone();
                }
            }
        }


        /*++

            ErrorInStream - indicates an exception was caught
            internally due to a stream error, and that I/O
            operations should not continue

            Input: Nothing.

            Returns: True if there is an error

         --*/

        private bool ErrorInStream {
            get {
                return (m_ErrorException != null) ? true : false;
            }
        }

        /*++

            CallDone - calls out to the Connection that spawned this
            Stream (using the DoneRead/DoneWrite method).
            If the Connection specified that we don't need to
            do this, or if we've already done this already, then
            we return silently.

            Input: Nothing.

            Returns: Nothing.

         --*/

        private void CallDone() {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::CallDone");

            if ( Interlocked.Increment( ref m_DoneCalled) == 1 ) {

                if (!m_NeedCallDone) {
                    GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::CallDone", "!m_NeedCallDone");
                    return;
                }

                ConnectionReturnResult returnResult = null;
                if (!m_WriteStream) {
#if DEBUG
                    GlobalLog.DebugRemoveRequest(m_Request);
#endif
                    m_Connection.ReadStartNextRequest(true, ref returnResult);
                }
                else {
                    if (BytesLeftToWrite>0 && !IgnoreSocketWrite) {
                        //
                        // we have buffered data to send
                        //
                        m_Connection.WriteStartNextRequest(BufferedData, ref returnResult);
                    }
                    else {
                        //
                        // just start the next request
                        //
                        m_Connection.WriteStartNextRequest(null, ref returnResult);
                    }
                }

                ConnectionReturnResult.SetResponses(returnResult);
            }
            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::CallDone");
        }

        /*++

            Read property for this class. We return the readability of
            this stream. This is a read only property.

            Input: Nothing.

            Returns: True if this is a read stream, false otherwise.

         --*/

        public override bool CanRead {
            get {
                return !m_WriteStream && (m_ShutDown == 0);
            }
        }

        /*++

            Seek property for this class. Since this stream is not
            seekable, we just return false. This is a read only property.

            Input: Nothing.

            Returns: false

         --*/

        public override bool CanSeek {
            get {
                return false;
            }
        }

        /*++

            CanWrite property for this class. We return the writeability of
            this stream. This is a read only property.

            Input: Nothing.

            Returns: True if this is a write stream, false otherwise.

         --*/

        public override bool CanWrite {
            get {
                return m_WriteStream && (m_ShutDown == 0);
            }
        }


        /*++

            DataAvailable property for this class. This property check to see
            if at least one byte of data is currently available. This is a read
            only property.

            Input: Nothing.

            Returns: True if data is available, false otherwise.

         --*/
        public bool DataAvailable {
            get {
                //
                // Data is available if this is not a write stream and either
                // we have data buffered or the underlying connection has
                // data.
                //
                return !m_WriteStream && (m_ReadBufferSize != 0 || m_Connection.DataAvailable);
            }
        }

        /*++

            Length property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Length {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }
        }

        /*++

            Position property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Position {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }

            set {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }
        }


        /*++

            Eof property to indicate when the read is no longer allowed,
            because all data has been already read from socket.

            Input: Nothing.

            Returns: true/false depending on whether we are complete

         --*/

        internal bool Eof {
            get {
                if (ErrorInStream) {
                    return true;
                }
                else if (m_Chunked) {
                    return m_ChunkEofRecvd;
                }
                else if (m_ReadBytes == 0) {
                    return true;
                }
                else if (m_ReadBytes == -1) {
                    return(m_DoneCalled > 0 && m_ReadBufferSize <= 0);
                }
                else {
                    return false;
                }
            }
        }

        /*++
            Uses an old Stream to resubmit buffered data using the current
             stream, this is used in cases of POST, or authentication,
             where we need to buffer upload data so that it can be resubmitted

            Input:

                OldStream - Old Stream that was previously used

            Returns:

                Nothing.

        --*/

        internal void ResubmitWrite(ConnectStream oldStream) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::ResubmitWrite", "ConnectStream");
            //
            // we're going to resubmit
            //
            ScatterGatherBuffers bufferedData = oldStream.BufferedData;

            Interlocked.Increment( ref m_CallNesting );
            GlobalLog.Print("Inc: " + m_CallNesting.ToString());

            try {
                //
                // no need to buffer here:
                // we're already resubmitting buffered data give it to the connection to put it on the wire again
                // we set BytesLeftToWrite to 0 'cause even on failure there can be no recovery,
                // so just leave it to IOError() to clean up and don't call ResubmitWrite()
                //
                m_Connection.Write(bufferedData);
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::ResubmitWrite() sent:" + bufferedData.Length.ToString() );
            }
            catch {
                IOError();
            }

            Interlocked.Decrement( ref m_CallNesting );
            GlobalLog.Print("Dec: " + m_CallNesting.ToString());

            SetWriteDone();
            CallDone();

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::ResubmitWrite", BytesLeftToWrite.ToString());
        }


        //
        // called by HttpWebRequest if AllowWriteStreamBuffering is true on that instance
        //
        internal void EnableWriteBuffering() {
            if (m_WriteStream && BufferedData==null) {
                //
                // create stream on demand, only if needed
                //
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::WriteBufferEnable_set() Write() creating ScatterGatherBuffers");
                BufferedData = new ScatterGatherBuffers();
            }
            m_WriteBufferEnable = true;
        }

        /*++
            FillFromBufferedData - This fills in a buffer from data that we have buffered.

            This method pulls out the buffered data that may have been provided as
            excess actual data from the header parsing

            Input:

                buffer          - Buffer to read into.
                offset          - Offset in buffer to read into.
                size           - Size in bytes to read.

            Returns:
                Number of bytes read.

        --*/
        private int FillFromBufferedData(byte [] buffer, ref int offset, ref int size ) {
            //
            // if there's no stuff in our read buffer just return 0
            //
            if (m_ReadBufferSize == 0) {
                return 0;
            }

            //
            // There's stuff in our read buffer. Figure out how much to take,
            // which is the minimum of what we have and what we're to read,
            // and copy it out.
            //
            int BytesTransferred = Math.Min(size, (int)m_ReadBufferSize);

            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::FillFromBufferedData() Filling bytes: " + BytesTransferred.ToString());

            Buffer.BlockCopy(
                m_ReadBuffer,
                m_ReadOffset,
                buffer,
                offset,
                BytesTransferred);

            // Update our internal read buffer state with what we took.

            m_ReadOffset += BytesTransferred;
            m_ReadBufferSize -= BytesTransferred;

            // If the read buffer size has gone to 0, null out our pointer
            // to it so maybe it'll be garbage-collected faster.

            if (m_ReadBufferSize == 0) {
                m_ReadBuffer = null;
            }

            // Update what we're to read and the caller's offset.

            size -= BytesTransferred;
            offset += BytesTransferred;

            return BytesTransferred;
        }

        //
        // calls the other version of FillFromBufferedData and returns
        // true if we've filled the entire buffer
        //
        private bool FillFromBufferedData(NestedSingleAsyncResult castedAsyncResult, byte[] buffer, ref int offset, ref int size) {
            GlobalLog.Enter("FillFromBufferedData", offset.ToString() + ", " + size.ToString());

            // attempt to pull data from Buffer first.
            int BytesTransferred = FillFromBufferedData(buffer, ref offset, ref size);

            castedAsyncResult.BytesTransferred += BytesTransferred;

            // RAID#122234
            // we should change the comment above to:
            // true if we've read at least 1 byte in the buffer
            // and the test below to:
            // if (BytesTransferred>0) {
            if (size==0) {
                GlobalLog.Leave("FillFromBufferedData", true);
                return true;
            }

            GlobalLog.Leave("FillFromBufferedData", false);
            return false;
        }


        /*++
            Write

            This function write data to the network. If we were given a definite
            content length when constructed, we won't write more than that amount
            of data to the network. If the caller tries to do that, we'll throw
            an exception. If we're doing chunking, we'll chunk it up before
            sending to the connection.


            Input:

                buffer          - buffer to write.
                offset          - offset in buffer to write from.
                size           - size in bytes to write.

            Returns:
                Nothing.

        --*/
        public override void Write(byte[] buffer, int offset, int size) {
            //
            // if needed, buffering will happen in BeginWrite()
            //
            if (!m_WriteStream) {
                throw new NotSupportedException(SR.GetString(SR.net_readonlystream));
            }
            IAsyncResult asyncResult = BeginWrite(buffer, offset, size, null, null);
            if (Timeout!=System.Threading.Timeout.Infinite && !asyncResult.IsCompleted) {
                asyncResult.AsyncWaitHandle.WaitOne(Timeout, false);
                if (!asyncResult.IsCompleted) {
                    Abort();
                    throw new WebException(SR.GetString(SR.net_timeout), WebExceptionStatus.Timeout);
                }
            }
            EndWrite(asyncResult);
        }



        /*++
            BeginWrite - Does async write to the Stream

            Splits the operation into two outcomes, for the
            non-chunking case, we calculate size to write,
            then call BeginWrite on the Connection directly,
            and then we're finish, for the Chunked case,
            we procede with use two callbacks to continue the
            chunking after the first write, and then second write.
            In order that all of the Chunk data/header/terminator,
            in the correct format are sent.

            Input:

                buffer          - Buffer to write into.
                offset          - Offset in buffer to write into.
                size           - Size in bytes to write.
                callback        - the callback to be called on result
                state           - object to be passed to callback

            Returns:
                IAsyncResult    - the async result

        --*/

        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int size, AsyncCallback callback, object state ) {
            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite " + ValidationHelper.HashString(m_Connection) + ", " + offset.ToString() + ", " + size.ToString());
            //
            // parameter validation
            //
            if (!m_WriteStream) {
                throw new NotSupportedException(SR.GetString(SR.net_readonlystream));
            }
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            //
            // if we have a stream error, or we've already shut down this socket
            //  then we must prevent new BeginRead/BeginWrite's from getting
            //  submited to the socket, since we've already closed the stream.
            //
            if (ErrorInStream) {
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite() throwing:" + m_ErrorException.ToString());
                throw m_ErrorException;
            }
            if (m_ShutDown != 0 && !IgnoreSocketWrite) {
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite() throwing");
                throw new WebException(
                            NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.ConnectionClosed),
                            WebExceptionStatus.ConnectionClosed);
            }
            //
            // if we fail/hang this call for some reason,
            // this Nesting count we be non-0, so that when we
            // close this stream, we will abort the socket.
            //

            if (AnotherCallInProgress(Interlocked.Increment( ref m_CallNesting ))) {
                Interlocked.Decrement( ref m_CallNesting );
                throw new NotSupportedException(SR.GetString(SR.net_no_concurrent_io_allowed));
            }
            GlobalLog.Print("Inc: " + m_CallNesting.ToString());

            //
            // buffer data to the ScatterGatherBuffers
            // regardles of chunking, we buffer the data as if we were not chunking
            // and on resubmit, we don't bother chunking.
            //
            if (m_WriteBufferEnable) {
                //
                // if we don't need to, we shouldn't send data on the wire as well
                // but in this case we gave a stream to the user so we have transport
                //
                BufferedData.Write(buffer, offset, size);
            }

            if (BufferOnly || IgnoreSocketWrite) {
                //
                // We're not putting this data on the wire
                //
                NestedSingleAsyncResult asyncResult = new NestedSingleAsyncResult(this, state, callback, buffer, offset, size);

                //
                // done. complete the IO.
                //
                asyncResult.InvokeCallback(true);
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite() BufferOnly");
                return asyncResult;
            }
            else if (WriteChunked) {
                //
                // We're chunking. Write the chunk header out first,
                // then the data, then a CRLF.
                // for this we'll use BeginMultipleSend();
                //
                int chunkHeaderOffset = 0;
                byte[] chunkHeaderBuffer = GetChunkHeader(size, out chunkHeaderOffset);

                BufferOffsetSize[] buffers = new BufferOffsetSize[3];
                buffers[0] = new BufferOffsetSize(chunkHeaderBuffer, chunkHeaderOffset, chunkHeaderBuffer.Length - chunkHeaderOffset, false);
                buffers[1] = new BufferOffsetSize(buffer, offset, size, false);
                buffers[2] = new BufferOffsetSize(m_CRLF, 0, m_CRLF.Length, false);

                NestedMultipleAsyncResult asyncResult = new NestedMultipleAsyncResult(this, state, callback, buffers);
                //
                // See if we're chunking. If not, make sure we're not sending too much data.
                //
                if (size == 0) {
                    asyncResult.InvokeCallback(true);

                    GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite");
                    return asyncResult;
                }

                //
                // after setting up the buffers and error checking do the async Write Call
                //
                try {
                    asyncResult.NestedAsyncResult =
                        m_Connection.BeginMultipleWrite(
                            buffers,
                            m_WriteCallbackDelegate,
                            asyncResult );
                } catch (Exception exception) {
                    if (m_ErrorResponseStatus) {
                        // We already got a error response, hence server could drop the connection,
                        // Here we are recovering for future (optional) resubmit ...
                        m_IgnoreSocketWrite = true;
                        GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite() IGNORE write fault");
                    }
                    else {
                        // Note we could swallow this since receive callback is already posted and
                        // should give us similar failure
                        IOError(exception);
                        GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite() throwing:" + exception.ToString());
                        throw;
                    }
                }

                if (asyncResult.NestedAsyncResult == null) {
                    //
                    // we're buffering, IO is complete
                    //
                    asyncResult.InvokeCallback(true);
                }

                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite chunked");
                return asyncResult;
            }
            else {
                //
                // We're not chunking. See if we're sending too much; if not,
                // go ahead and write it.
                //
                NestedSingleAsyncResult asyncResult = new NestedSingleAsyncResult(this, state, callback, buffer, offset, size);
                //
                // See if we're chunking. If not, make sure we're not sending too much data.
                //
                if (size == 0) {
                    asyncResult.InvokeCallback(true);

                    GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite");
                    return asyncResult;
                }

                if (BytesLeftToWrite != -1) {
                    //
                    // but only check if we aren't writing to an unknown content-length size,
                    // as we can be buffering.
                    //
                    if (BytesLeftToWrite < (long)size) {
                        //
                        // writing too much data.
                        //
                        GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite()");
                        throw new ProtocolViolationException(SR.GetString(SR.net_entitytoobig));
                    }
                    //
                    // Otherwise update our bytes left to send and send it.
                    //
                    BytesLeftToWrite -= (long)size;
                }

                // we're going to nest this asyncResult below
                asyncResult.Nested = true;

                //
                // After doing, the m_WriteByte size calculations, and error checking
                //  here doing the async Write Call
                //

                try {
                    asyncResult.NestedAsyncResult =
                        m_Connection.BeginWrite(
                            buffer,
                            offset,
                            size,
                            m_WriteCallbackDelegate,
                            asyncResult );
                } catch (Exception exception) {
                    if (m_ErrorResponseStatus) {
                        // We already got a error response, hence server could drop the connection,
                        // Here we are recovering for future (optional) resubmit ...
                        m_IgnoreSocketWrite = true;
                        GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite() IGNORE write fault");
                    }
                    else {
                        // Note we could swallow this since receive callback is already posted and
                        // should give us similar failure
                        IOError(exception);
                        GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite() throwing:" + exception.ToString());
                        throw;
                    }
                }

                if (asyncResult.NestedAsyncResult == null) {
                    //
                    // we're buffering, IO is complete
                    //
                    asyncResult.InvokeCallback(true);
                }

                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginWrite");
                return asyncResult;
            }
        }

        /*++
            WriteDataCallback

            This is a callback, that is part of the main BeginWrite
            code, this is part of the normal transfer code.

            Input:

               asyncResult - IAsyncResult generated from BeginWrite

            Returns:

               None

        --*/
        private static void WriteCallback(IAsyncResult asyncResult) {
            //
            // we called m_Connection.BeginWrite() previously that call
            // completed and called our internal callback
            // we passed the NestedSingleAsyncResult (that we then returned to the user)
            // as the state of this call, so build it back:
            //
            if (asyncResult.AsyncState is NestedSingleAsyncResult) {
                NestedSingleAsyncResult castedAsyncResult = (NestedSingleAsyncResult)asyncResult.AsyncState;
                ConnectStream thisConnectStream = (ConnectStream)castedAsyncResult.AsyncObject;

                try {
                    thisConnectStream.m_Connection.EndWrite(asyncResult);
                    //
                    // call the user's callback, with success
                    //
                    castedAsyncResult.InvokeCallback(false);
                }
                catch (Exception exception) {
                    if (thisConnectStream.m_ErrorResponseStatus) {
                        // We already got a error response, hence server could drop the connection,
                        // Here we are recovering for future (optional) resubmit ...
                        thisConnectStream.m_IgnoreSocketWrite = true;
                        GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(thisConnectStream) + "::EndWrite() IGNORE write fault");
                        castedAsyncResult.InvokeCallback(false);
                    }
                    else {
                        //
                        // call the user's callback, with exception
                        //
                        castedAsyncResult.InvokeCallback(false, exception);
                    }
                }
            }
            else {
                NestedMultipleAsyncResult castedAsyncResult = (NestedMultipleAsyncResult)asyncResult.AsyncState;
                ConnectStream thisConnectStream = (ConnectStream)castedAsyncResult.AsyncObject;

                try {
                    thisConnectStream.m_Connection.EndMultipleWrite(asyncResult);
                    //
                    // call the user's callback, with success
                    //
                    castedAsyncResult.InvokeCallback(false);
                }
                catch (Exception exception) {
                    if (thisConnectStream.m_ErrorResponseStatus) {
                        // We already got a error response, hence server could drop the connection,
                        // Here we are recovering for future (optional) resubmit ...
                        thisConnectStream.m_IgnoreSocketWrite = true;
                        GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(thisConnectStream) + "::EndWrite() IGNORE write fault");
                        castedAsyncResult.InvokeCallback(false);
                    }
                    else {
                        //
                        // call the user's callback, with exception
                        //
                        castedAsyncResult.InvokeCallback(false, exception);
                    }
                }
            }
        }

        /*++
            EndWrite - Finishes off async write of data, just calls into
                m_Connection.EndWrite to get the result.

            Input:

                asyncResult     - The AsyncResult returned by BeginWrite


        --*/
        public override void EndWrite(IAsyncResult asyncResult) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::EndWrite");
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            LazyAsyncResult castedAsyncResult = asyncResult as LazyAsyncResult;

            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndWrite"));
            }

            castedAsyncResult.EndCalled = true;

            //
            // wait & then check for errors
            //

            object returnValue = castedAsyncResult.InternalWaitForCompletion();

            if (ErrorInStream) {
                GlobalLog.LeaveException("ConnectStream#" + ValidationHelper.HashString(this) + "::EndWrite", m_ErrorException);
                throw m_ErrorException;
            }

            Exception exception = returnValue as Exception;

            if (exception!=null) {
                IOError(exception);
                GlobalLog.LeaveException("ConnectStream#" + ValidationHelper.HashString(this) + "::EndWrite", exception);
                throw exception;
            }

            Interlocked.Decrement( ref m_CallNesting );
            GlobalLog.Print("Dec: " + m_CallNesting.ToString());

            if (BytesLeftToWrite==0) {
                SetWriteDone();
            }

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::EndWrite");
        }


        /*++
            Read - Read from the connection.
            ReadWithoutValidation

            This method reads from the network, or our internal buffer if there's
            data in that. If there's not, we'll read from the network. If we're

            doing chunked decoding, we'll decode it before returning from this
            call.


            Input:

                buffer          - Buffer to read into.
                offset          - Offset in buffer to read into.
                size           - Size in bytes to read.

            Returns:
                Nothing.

        --*/
        public override int Read([In, Out] byte[] buffer, int offset, int size) {
            //
            // we implement this function easily by just
            //  simply calling the async version and blocking,
            //  but for performance reasons, lets leave it.
            //
            if (m_WriteStream) {
                throw new NotSupportedException(SR.GetString(SR.net_writeonlystream));
            }
            IAsyncResult asyncResult = BeginRead(buffer, offset, size, null, null);

            if (Timeout!=System.Threading.Timeout.Infinite && !asyncResult.IsCompleted) {
                asyncResult.AsyncWaitHandle.WaitOne(Timeout, false);
                if (!asyncResult.IsCompleted) {
                    Abort();
                    throw new WebException(SR.GetString(SR.net_timeout), WebExceptionStatus.Timeout);
                }
            }
            return EndRead(asyncResult);
        }


        /*++
            ReadWithoutValidation - Read from the connection.

            Sync version of BeginReadWithoutValidation

            This method reads from the network, or our internal buffer if there's
            data in that. If there's not, we'll read from the network. If we're
            doing chunked decoding, we'll decode it before returning from this
            call.

        --*/
        private int ReadWithoutValidation([In, Out] byte[] buffer, int offset, int size) {
            GlobalLog.Print("int ConnectStream::ReadWithoutValidation()");
            GlobalLog.Print("(start)m_ReadBytes = "+m_ReadBytes);


// ********** WARNING - updating logic below should also be updated in BeginReadWithoutValidation *****************
            
            //
            // Figure out how much we should really read.
            //

            int bytesToRead = 0;

            if (m_Chunked) {
                if (!m_ChunkEofRecvd) {

                    // See if we have more left from a previous
                    // chunk.
                    if (m_ChunkSize != 0) {
                        bytesToRead = Math.Min(size, m_ChunkSize);
                    } else {
                        // read size of next chunk
                        try {
                            bytesToRead = ReadChunkedSync(buffer, offset, size);
                            m_ChunkSize -= bytesToRead;
                        }
                        catch (Exception exception) {
                            IOError(exception);
                            throw;
                        }

                        return bytesToRead;                                                    
                    }
                }
            } else {

                //
                // Not doing chunked, so don't read more than is left.
                //

                if (m_ReadBytes != -1) {
                    bytesToRead = Math.Min((int)m_ReadBytes, size);
                }
                else {
                    bytesToRead = size;
                }
            }

            // If we're not going to read anything, either because they're
            // not asking for anything or there's nothing left, bail
            // out now.

            if (bytesToRead == 0 || this.Eof) {            
                return 0;
            }

            try {
                bytesToRead = InternalRead(buffer, offset, bytesToRead);
            }
            catch (Exception exception) {
                IOError(exception);
                throw;
            }

            GlobalLog.Print("bytesTransfered = "+bytesToRead);
            int bytesTransferred = bytesToRead;

            if (m_Chunked) {
                m_ChunkSize -= bytesTransferred;
            } else {

                bool DoneReading = false;

                //
                // return the actual bytes read from the wire + plus possible bytes read from buffer
                //
                if (bytesTransferred < 0) {
                    //
                    // Had some sort of error on the read. Close
                    // the stream, which will clean everything up.
                    // Sometimes a server will abruptly drop the connection,
                    // if we don't have content-length and chunk info, then it may not be an error
                    //

                    if (m_ReadBytes != -1) {
                        IOError();
                    }
                    else {
                        DoneReading = true;
                        //
                        // Note,
                        //  we should probaly put more logic in here, as to when to actually
                        //  except this an error and when to just silently close
                        //
                        bytesTransferred = 0;
                    }
                }

                if (bytesTransferred == 0) {
                    //
                    // We read 0 bytes from the connection. This is OK if we're
                    // reading to end, it's an error otherwise.
                    //
                    if (m_ReadBytes != -1) {
                        IOError();
                    }
                    else {
                        //
                        // We're reading to end, and we found the end, by reading 0 bytes
                        //
                        DoneReading = true;
                    }
                }
         
                //
                // Not chunking. Update our read bytes state and return what we've read.
                //

                if (m_ReadBytes != -1) {
                    m_ReadBytes -= bytesTransferred;

                    GlobalLog.Assert(
                                m_ReadBytes >= 0,
                                "ConnectStream: Attempting to read more bytes than avail",
                                "m_ReadBytes < 0"
                                );

                    GlobalLog.Print("m_ReadBytes = "+m_ReadBytes);
                }

                if (m_ReadBytes == 0 || DoneReading) {
                    // We're all done reading, tell the connection that.
                    m_ReadBytes = 0;

                    //
                    // indicate to cache that read completed OK
                    //

                    CallDone();
                }
            }
            GlobalLog.Print("bytesTransfered = "+bytesToRead);
            GlobalLog.Print("(end)m_ReadBytes = "+m_ReadBytes);
// ********** WARNING - updating logic above should also be updated in BeginReadWithoutValidation and EndReadWithoutValidation *****************
            return bytesTransferred;            
        }



        /*++
            BeginRead - Read from the connection.
            BeginReadWithoutValidation

            This method reads from the network, or our internal buffer if there's
            data in that. If there's not, we'll read from the network. If we're
            doing chunked decoding, we'll decode it before returning from this
            call.


            Input:

                buffer          - Buffer to read into.
                offset          - Offset in buffer to read into.
                size           - Size in bytes to read.

            Returns:
                Nothing.

        --*/

        public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback callback, object state) {
            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginRead() " + ValidationHelper.HashString(m_Connection) + ", " + offset.ToString() + ", " + size.ToString());
            //
            // parameter validation
            //
            if (m_WriteStream) {
                throw new NotSupportedException(SR.GetString(SR.net_writeonlystream));
            }
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            //
            // if we have a stream error, or we've already shut down this socket
            //  then we must prevent new BeginRead/BeginWrite's from getting
            //  submited to the socket, since we've already closed the stream.
            //

            if (ErrorInStream) {
                throw m_ErrorException;
            }

            if (m_ShutDown != 0) {
                throw new WebException(
                            NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.ConnectionClosed),
                            WebExceptionStatus.ConnectionClosed);
            }

            //
            // if we fail/hang this call for some reason,
            // this Nesting count we be non-0, so that when we
            // close this stream, we will abort the socket.
            //

            if (AnotherCallInProgress(Interlocked.Increment( ref m_CallNesting ))) {
                Interlocked.Decrement( ref m_CallNesting );
                throw new NotSupportedException(SR.GetString(SR.net_no_concurrent_io_allowed));
            }
            GlobalLog.Print("Inc: " + m_CallNesting.ToString());

            IAsyncResult result =
                BeginReadWithoutValidation(
                        buffer,
                        offset,
                        size,
                        callback,
                        state);

            return result;
        }


        /*++
            BeginReadWithoutValidation - Read from the connection.

            internal version of BeginRead above, without validation

            This method reads from the network, or our internal buffer if there's
            data in that. If there's not, we'll read from the network. If we're
            doing chunked decoding, we'll decode it before returning from this
            call.


            Input:

                buffer          - Buffer to read into.
                offset          - Offset in buffer to read into.
                size           - Size in bytes to read.

            Returns:
                Nothing.

        --*/

        private IAsyncResult BeginReadWithoutValidation(byte[] buffer, int offset, int size, AsyncCallback callback, object state) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginRead", ValidationHelper.HashString(m_Connection) + ", " + offset.ToString() + ", " + size.ToString());

            //
            // Figure out how much we should really read.
            //

            NestedSingleAsyncResult castedAsyncResult = new NestedSingleAsyncResult(this, state, callback, buffer, offset, size);

            int bytesToRead = 0;

            if (m_Chunked) {

                if (!m_ChunkEofRecvd) {

                    // See if we have more left from a previous
                    // chunk.

                    if (m_ChunkSize != 0) {
                        bytesToRead = Math.Min(size, m_ChunkSize);
                    } else {
                        // otherwise we queue a work item to parse the chunk
                        // Consider:
                        // Will we have an issue of thread dying off if we make a IO Read from that thread???
                        ThreadPool.QueueUserWorkItem(
                                                    m_ReadChunkedCallbackDelegate,
                                                    castedAsyncResult
                                                    );

                        GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginRead");
                        return castedAsyncResult;
                    }

                }
            } else {

                //
                // Not doing chunked, so don't read more than is left.
                //

                if (m_ReadBytes != -1) {
                    bytesToRead = Math.Min((int)m_ReadBytes, size);
                }
                else {
                    bytesToRead = size;
                }
            }

            // If we're not going to read anything, either because they're
            // not asking for anything or there's nothing left, bail
            // out now.

            if (bytesToRead == 0 || this.Eof) {
                castedAsyncResult.InvokeCallback(true, 0);
                GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginRead");
                return castedAsyncResult;
            }

            try {
                InternalBeginRead(bytesToRead, castedAsyncResult, false);
            }
            catch (Exception exception) {
                IOError(exception);
                GlobalLog.LeaveException("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginRead", exception);
                throw;
            }

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::BeginRead");
            return castedAsyncResult;
        }



        /*++
            InternalBeginRead

            This is an interal version of BeginRead without validation,
             that is called from the Chunked code as well the normal codepaths.

            Input:

               castedAsyncResult - IAsyncResult generated from BeginRead

            Returns:

               None

        --*/

        private void InternalBeginRead(int bytesToRead, NestedSingleAsyncResult castedAsyncResult, bool fromCallback) {
            GlobalLog.Enter("ConnectStream::InternalBeginRead", bytesToRead.ToString()+", "+ValidationHelper.HashString(castedAsyncResult)+", "+fromCallback.ToString());

            //
            // Attempt to fill in our entired read from,
            //  data previously buffered, if this completely
            //  satisfies us, then we are done, complete sync
            //

            bool completedSync = (m_ReadBufferSize > 0) ?
                FillFromBufferedData(
                    castedAsyncResult,
                    castedAsyncResult.Buffer,
                    ref castedAsyncResult.Offset,
                    ref bytesToRead ) : false;

            if (completedSync) {
                castedAsyncResult.InvokeCallback(!fromCallback, bytesToRead);
                GlobalLog.Leave("ConnectStream::InternalBeginRead");
                return;
            }

            // we're going to nest this asyncResult below
            // this is needed because a callback may be invoked
            // before the call itsefl returns to set NestedAsyncResult

            castedAsyncResult.Nested = true;

            //
            // otherwise, we need to read more data from the connection.
            //

            if (ErrorInStream) {
                GlobalLog.LeaveException("ConnectStream::InternalBeginRead", m_ErrorException);
                throw m_ErrorException;
            }

            GlobalLog.Assert(
                (m_DoneCalled == 0 || m_ReadBytes != -1),
                "BeginRead: Calling BeginRead after ReadDone", "(m_DoneCalled > 0 && m_ReadBytes == -1)");

            castedAsyncResult.NestedAsyncResult =
                m_Connection.BeginRead(
                    castedAsyncResult.Buffer,
                    castedAsyncResult.Offset,
                    bytesToRead,
                    m_ReadCallbackDelegate,
                    castedAsyncResult );

            // a null return indicates that the connection was closed underneath us.
            if (castedAsyncResult.NestedAsyncResult == null) {
                m_ErrorException =
                    new WebException(
                            NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.RequestCanceled),
                            WebExceptionStatus.RequestCanceled);

                GlobalLog.LeaveException("ConnectStream::InternalBeginRead", m_ErrorException);
                throw m_ErrorException;
            }

            GlobalLog.Leave("ConnectStream::InternalBeginRead");
        }

        /*++
            InternalRead

            This is an interal version of Read without validation,
             that is called from the Chunked code as well the normal codepaths.

        --*/

        private int InternalRead(byte[] buffer, int offset, int size) {
            // Read anything first out of the buffer
            int bytesToRead = FillFromBufferedData(buffer, ref offset, ref size);
            if (bytesToRead>0) {
                return bytesToRead;
            }

            // otherwise, we need to read more data from the connection.
            if (ErrorInStream) {
                GlobalLog.LeaveException("ConnectStream::InternalBeginRead", m_ErrorException);
                throw m_ErrorException;
            }
            
            bytesToRead = m_Connection.Read(
                    buffer,
                    offset,
                    size);

            return bytesToRead;
        }


        /*++
            ReadCallback

            This is a callback, that is part of the main BeginRead
            code, this is part of the normal transfer code.

            Input:

               asyncResult - IAsyncResult generated from BeginWrite

            Returns:

               None

        --*/
        private static void ReadCallback(IAsyncResult asyncResult) {
            GlobalLog.Enter("ConnectStream::ReadCallback", "asyncResult=#"+ValidationHelper.HashString(asyncResult));
            //
            // we called m_Connection.BeginRead() previously that call
            // completed and called our internal callback
            // we passed the NestedSingleAsyncResult (that we then returned to the user)
            // as the state of this call, so build it back:
            //
            NestedSingleAsyncResult castedAsyncResult = (NestedSingleAsyncResult)asyncResult.AsyncState;
            ConnectStream thisConnectStream = (ConnectStream)castedAsyncResult.AsyncObject;

            try {
                int bytesTransferred = thisConnectStream.m_Connection.EndRead(asyncResult);
                //
                // call the user's callback, with success
                //
                castedAsyncResult.InvokeCallback(false, bytesTransferred);
            }
            catch (Exception exception) {
                //
                // call the user's callback, with exception
                //
                castedAsyncResult.InvokeCallback(false, exception);
            }
            GlobalLog.Leave("ConnectStream::ReadCallback");
        }


        /*++
            EndRead - Finishes off the Read for the Connection
            EndReadWithoutValidation

            This method completes the async call created from BeginRead,
            it attempts to determine how many bytes were actually read,
            and if any errors occured.

            Input:
                asyncResult - created by BeginRead

            Returns:
                int - size of bytes read, or < 0 on error

        --*/

        public override int EndRead(IAsyncResult asyncResult) {
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            NestedSingleAsyncResult castedAsyncResult = asyncResult as NestedSingleAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndRead"));
            }

            castedAsyncResult.EndCalled = true;

            //
            // Wait & get Response
            //

            int bytesTransfered = this.EndReadWithoutValidation(castedAsyncResult);

            Interlocked.Decrement( ref m_CallNesting );
            GlobalLog.Print("Dec: " + m_CallNesting.ToString());

            return bytesTransfered;
        }


        /*++
            EndReadWithoutValidation - Finishes off the Read for the Connection
                Called internally by EndRead.

            This method completes the async call created from BeginRead,
            it attempts to determine how many bytes were actually read,
            and if any errors occured.

            Input:
                asyncResult - created by BeginRead

            Returns:
                int - size of bytes read, or < 0 on error

        --*/
        private int EndReadWithoutValidation(NestedSingleAsyncResult castedAsyncResult) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::EndReadWithoutValidation", ValidationHelper.HashString(castedAsyncResult));
            //
            // Wait & get Response
            //
            object returnValue = castedAsyncResult.InternalWaitForCompletion();

            if (ErrorInStream) {
                GlobalLog.LeaveException("ConnectStream::EndReadWithoutValidation", m_ErrorException);
                throw m_ErrorException;
            }

            int BytesTransferred = 0;

            if (m_Chunked) {

                if (returnValue is Exception) {
                    IOError((Exception) returnValue);
                    BytesTransferred = -1;
                } else {
                    if (castedAsyncResult.Nested) {

                        BytesTransferred = -1;

                        if (returnValue is int) {
                            BytesTransferred = (int)returnValue;
                        } // otherwise its an exception ?

                        if (BytesTransferred < 0) {
                            IOError();
                            BytesTransferred = 0;
                        }
                    }

                    BytesTransferred += castedAsyncResult.BytesTransferred;

                    m_ChunkSize -= BytesTransferred;
                }

            } else {

                //
                // we're not chunking, a note about error
                //  checking here, in some cases due to 1.0
                //  servers we need to read until 0 bytes,
                //  or a server reset, therefore, we may need
                //  ignore sockets errors
                //

                bool DoneReading = false;

                // if its finished without async, just use what was read already from the buffer,
                // otherwise we call the Connection's EndRead to find out
                if (castedAsyncResult.Nested) {

                    BytesTransferred = -1;

                    if (returnValue is int) {
                        BytesTransferred = (int)returnValue;
                    }

                    //
                    // return the actual bytes read from the wire + plus possible bytes read from buffer
                    //
                    if (BytesTransferred < 0) {
                        //
                        // Had some sort of error on the read. Close
                        // the stream, which will clean everything up.
                        // Sometimes a server will abruptly drop the connection,
                        // if we don't have content-length and chunk info, then it may not be an error
                        //

                        if (m_ReadBytes != -1) {
                            IOError();
                        }
                        else {
                            DoneReading = true;
                            //
                            // Note,
                            //  we should probaly put more logic in here, as to when to actually
                            //  except this an error and when to just silently close
                            //
                            BytesTransferred = 0;
                        }
                    }

                    if (BytesTransferred == 0) {
                        //
                        // We read 0 bytes from the connection. This is OK if we're
                        // reading to end, it's an error otherwise.
                        //
                        if (m_ReadBytes != -1) {
                            IOError();
                        }
                        else {
                            //
                            // We're reading to end, and we found the end, by reading 0 bytes
                            //
                            DoneReading = true;
                        }
                    }
                }

                BytesTransferred += castedAsyncResult.BytesTransferred;

                //
                // Not chunking. Update our read bytes state and return what we've read.
                //
                if (m_ReadBytes != -1) {
                    m_ReadBytes -= BytesTransferred;

                    GlobalLog.Assert(
                                m_ReadBytes >= 0,
                                "ConnectStream: Attempting to read more bytes than avail",
                                "m_ReadBytes < 0"
                                );

                    GlobalLog.Print("m_ReadBytes = "+m_ReadBytes);
                }

                if (m_ReadBytes == 0 || DoneReading) {
                    // We're all done reading, tell the connection that.
                    m_ReadBytes = 0;

                    //
                    // indicate to cache that read completed OK
                    //

                    CallDone();
                }
            }

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::EndRead", BytesTransferred);
            return BytesTransferred;
        }


        /*++
            ReadSingleByte - Read a single byte from the stream.

            A utility function to read a single byte from the stream. Could be
            done via ReadCoreNormal, but this is slightly more efficient.

            Input:


            Returns:
                The byte read as an int, or -1 if we couldn't read.

        --*/
        internal int ReadSingleByte() {
            if (ErrorInStream) {
                return -1;
            }

            if (m_ReadBufferSize != 0) {
                m_ReadBufferSize--;
                return (int)m_ReadBuffer[m_ReadOffset++];
            }
            else {
                int bytesTransferred = m_Connection.Read(m_TempBuffer, 0, 1);

                if (bytesTransferred <= 0) {
                    return -1;
                }

                return (int)m_TempBuffer[0];
            }
        }


        /*++
           ReadCRLF

            A utility routine that tries to read the CRLF at the end of a
            chunk.


            Input:

                buffer          - buffer to read into

            Returns:
                int - number of bytes read

        --*/
        private int ReadCRLF(byte[] buffer) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::ReadCRLF");
            int offset = 0;
            int size = m_CRLF.Length;

            int BytesRead = FillFromBufferedData(buffer, ref offset, ref size);

            if (BytesRead >= 0 && BytesRead != m_CRLF.Length) {
                do {
                    int bytesTransferred = m_Connection.Read(buffer, offset, size);

                    if (bytesTransferred <= 0) {
                        GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::ReadCRLF", bytesTransferred);
                        throw new IOException(SR.GetString(SR.net_io_readfailure));
                    } else {
                        size   -= bytesTransferred;
                        offset += bytesTransferred;
                    }
                } while ( size > 0 );
            }

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::ReadCRLF", BytesRead);
            return BytesRead;
        }


        /*++
            ReadChunkedCallback

            This is callback, that parses and does a chunked read.
            It is here that we attempt to Read enough bytes
            to determine the size of the next chunk of data,
            and parse through any headers/control information
            asscoiated with that chunk.

            Input:

               asyncResult - IAsyncResult generated from ConnectStream.BeginRead

        --*/
        private static void ReadChunkedCallback(object state) {

// ********** WARNING - updating logic below should also be updated in ReadChunkedSync *****************

            NestedSingleAsyncResult castedAsyncResult = state as NestedSingleAsyncResult;
            ConnectStream thisConnectStream = castedAsyncResult.AsyncObject as ConnectStream;

            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(thisConnectStream) + "::ReadChunkedCallback", ValidationHelper.HashString(castedAsyncResult));

            try {
                if (!thisConnectStream.m_Draining && thisConnectStream.m_ShutDown != 0) {
                    // throw on shutdown only if we're not draining the socket.
                    Exception exception =
                        new WebException(
                            NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.ConnectionClosed),
                            WebExceptionStatus.ConnectionClosed);

                    castedAsyncResult.InvokeCallback(false, exception);
                    GlobalLog.LeaveException("ReadChunkedCallback", exception);
                    return;
                }
                else if (thisConnectStream.m_ErrorException!=null) {
                    // throw on IO error even if we're draining the socket.
                    castedAsyncResult.InvokeCallback(false, thisConnectStream.m_ErrorException);
                    GlobalLog.LeaveException("ReadChunkedCallback", thisConnectStream.m_ErrorException);
                    return;
                }
                if (thisConnectStream.m_ChunkedNeedCRLFRead) {
                    thisConnectStream.ReadCRLF(thisConnectStream.m_TempBuffer);
                    thisConnectStream.m_ChunkedNeedCRLFRead = false;
                }

                StreamChunkBytes ReadByteBuffer = new StreamChunkBytes(thisConnectStream);

                // We need to determine size of next chunk,
                // by carefully reading, byte by byte

                thisConnectStream.m_ChunkSize = thisConnectStream.ProcessReadChunkedSize(ReadByteBuffer);

                // If this isn't a zero length chunk, read it.
                if (thisConnectStream.m_ChunkSize != 0) {
                    thisConnectStream.m_ChunkedNeedCRLFRead = true;

                    thisConnectStream.InternalBeginRead(Math.Min(castedAsyncResult.Size, thisConnectStream.m_ChunkSize), castedAsyncResult, true);
                }
                else {
                    // We've found the terminating 0 length chunk. We may be very well looking
                    // at an extension footer or the very final CRLF.

                    thisConnectStream.ReadCRLF(thisConnectStream.m_TempBuffer);
                    thisConnectStream.RemoveTrailers(ReadByteBuffer);

                    // Remember that we've found this, so we don't try and dechunk
                    // more.

                    thisConnectStream.m_ReadBytes = 0;
                    thisConnectStream.m_ChunkEofRecvd = true;

                    thisConnectStream.CallDone();

                    // we're done reading, return 0 bytes
                    castedAsyncResult.InvokeCallback(false, 0);
                }
                GlobalLog.Leave("ReadChunkedCallback");
            }
            catch (Exception exception) {
                castedAsyncResult.InvokeCallback(false, exception);
                GlobalLog.LeaveException("ReadChunkedCallback", exception);
            }

// ********** WARNING - updating logic above should also be updated in ReadChunkedSync *****************
        }

        /*++
            ReadChunkedSync

            Parses and does a chunked read.
            It is here that we attempt to Read enough bytes
            to determine the size of the next chunk of data,
            and parse through any headers/control information
            asscoiated with that chunk.

            Returns:

               None

        --*/
        private int ReadChunkedSync(byte[] buffer, int offset, int size) {
            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::ReadChunkedSync");

// ********** WARNING - updating logic below should also be updated in ReadChunkedCallback *****************

            if (!m_Draining && m_ShutDown != 0) {
                // throw on shutdown only if we're not draining the socket.
                Exception exception =
                    new WebException(
                        NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.ConnectionClosed),
                        WebExceptionStatus.ConnectionClosed);

                throw exception;
            }
            else if (m_ErrorException!=null) {
                // throw on IO error even if we're draining the socket.
                throw m_ErrorException;
            }
            if (m_ChunkedNeedCRLFRead) {
                ReadCRLF(m_TempBuffer);
                m_ChunkedNeedCRLFRead = false;
            }

            StreamChunkBytes ReadByteBuffer = new StreamChunkBytes(this);

            // We need to determine size of next chunk,
            // by carefully reading, byte by byte

            m_ChunkSize = ProcessReadChunkedSize(ReadByteBuffer);

            // If this isn't a zero length chunk, read it.
            if (m_ChunkSize != 0) {
                m_ChunkedNeedCRLFRead = true;
                return InternalRead(buffer, offset, Math.Min(size, m_ChunkSize));
            }
            else {
                // We've found the terminating 0 length chunk. We may be very well looking
                // at an extension footer or the very final CRLF.

                ReadCRLF(m_TempBuffer);
                RemoveTrailers(ReadByteBuffer);

                // Remember that we've found this, so we don't try and dechunk
                // more.

                m_ReadBytes = 0;
                m_ChunkEofRecvd = true;

                CallDone();

                // we're done reading, return 0 bytes
                return 0;
            }

 // ********** WARNING - updating logic above should also be updated in ReadChunkedAsync *****************
        }


        /*++
            ProcessReadChunkedSize

            This is a continuation of the ReadChunkedCallback,
            and is used to parse out the size of a chunk

            Input:

               TheByteRead - single byte read from wire to process

               castedAsyncResult - Async Chunked State information

            Returns:

               None

        --*/
        private int ProcessReadChunkedSize(StreamChunkBytes ReadByteBuffer) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::ProcessReadChunkedSize");

            // now get the chunk size.
            int chunkSize;
            int BytesRead = ChunkParse.GetChunkSize(ReadByteBuffer, out chunkSize);

            if (BytesRead <= 0) {
                GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::ProcessReadChunkedSize - error");
                throw new IOException(SR.GetString(SR.net_io_readfailure));
            }

            // Now skip past and extensions and the CRLF.
            BytesRead = ChunkParse.SkipPastCRLF(ReadByteBuffer);

            if (BytesRead <= 0) {
                GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::ProcessReadChunkedSize - error");
                throw new IOException(SR.GetString(SR.net_io_readfailure));
            }

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::ProcessReadChunkedSize", chunkSize);
            return chunkSize;
        }


        /*++
            RemoveTrailers

            This handles possible trailer headers that are found after the
            last chunk.  Currently we throw them away for this version.

            Input:

               ReadByteBuffer -

            Returns:

               None - throws on exception

        --*/
        private void RemoveTrailers(StreamChunkBytes ReadByteBuffer) {
            while (m_TempBuffer[0] != '\r' && m_TempBuffer[1] != '\n') {
                int BytesRead = ChunkParse.SkipPastCRLF(ReadByteBuffer);

                if (BytesRead <= 0) {
                    throw new IOException(SR.GetString(SR.net_io_readfailure));
                }

                ReadCRLF(m_TempBuffer);
            }
        }



        /*++
            WriteHeaders

            This function writes header data to the network. Headers are special
            in that they don't have any non-header transforms applied to them,
            and are not subject to content-length constraints. We just write them
            through, and if we're done writing headers we tell the connection that.

            Input:

                httpWebRequest      - request whose headers we're about to write.
                writeDoneDelegate   - delegate we call to find out if we have a write stream.

            Returns:
                WebExceptionStatus.Pending      - we don't have a stream yet.
                WebExceptionStatus.SendFailure  - there was an error while writing to the wire.
                WebExceptionStatus.Success      - success.

        --*/
        internal virtual WebExceptionStatus WriteHeaders(HttpWebRequest httpWebRequest) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::WriteHeaders", "Connection#" + ValidationHelper.HashString(m_Connection) + ", " + httpWebRequest.WriteBuffer.Length.ToString());

            if (ErrorInStream) {
                GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::WriteHeaders", "ErrorInStream");
                return WebExceptionStatus.SendFailure;
            }

            Interlocked.Increment( ref m_CallNesting );
            GlobalLog.Print("Inc: " + m_CallNesting.ToString());

            try {
                //
                // no need to buffer here:
                // on resubmit, the headers, which may be changed, will be sent from
                // the HttpWebRequest object when calling into this method again.
                //
                m_Connection.Write(httpWebRequest.WriteBuffer, 0, httpWebRequest.WriteBuffer.Length);
            } catch {
                IOError();
                GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::WriteHeaders", "Exception");
                return WebExceptionStatus.SendFailure;
            }

            Interlocked.Decrement( ref m_CallNesting );
            GlobalLog.Print("Dec: " + m_CallNesting.ToString());

            bool completed = httpWebRequest.EndWriteHeaders();

            if (!completed) {
                // indicates that we're going pending
                GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::WriteHeaders", "Pending");
                return WebExceptionStatus.Pending;
            }

            if (BytesLeftToWrite == 0) {
                //
                // didn't go pending, no data to write. we're done.
                //
                CallDone();
            }

            byte[] writeBuffer = httpWebRequest.WriteBuffer; // nolonger valid after CallDone
            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::WriteHeaders", ((writeBuffer != null) ? writeBuffer.Length.ToString() : "writeBuffer==null"));
            return WebExceptionStatus.Success;
        }

        private void SafeSetSocketTimeout(bool set) {
            Connection connection = m_Connection;
            if (Timeout!=System.Threading.Timeout.Infinite) {
                if ( connection != null ) {
                    NetworkStream networkStream = connection.Transport;
                    if (networkStream != null) {
                        Socket streamSocket = networkStream.m_StreamSocket;
                        if (streamSocket != null) {
                            if (set) {
                                streamSocket.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout, Timeout);
                            } else {
                                streamSocket.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout, -1);
                            }
                        }
                    }
                }
            }
        }


        /*++
            Close - Close the stream

            Called when the stream is closed. We close our parent stream first.
            Then if this is a write stream, we'll send the terminating chunk
            (if needed) and call the connection DoneWriting() method.

            Input:

                Nothing.

            Returns:

                Nothing.

        --*/

        public override void Close() {
            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::Close()");
            this.CloseInternal(false);
        }

        void IDisposable.Dispose() {
            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::Dispose()");
            this.CloseInternal(false);
        }

        internal void Abort() {
            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::Abort");
            Interlocked.Increment( ref m_CallNesting );
            GlobalLog.Print("Inc: " + m_CallNesting.ToString());

            CloseInternal(true, true);
        }

        internal void CloseInternal(bool internalCall) {
            CloseInternal(internalCall, false);
        }

        // The number should be reasonalbly large
        private const int AlreadyAborted = 777777;
        protected void CloseInternal(bool internalCall, bool ignoreShutDownCheck) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal", internalCall.ToString());

            bool normalShutDown = false;
            Exception exceptionOnWrite = null;

            //
            // We have to prevent recursion, because we'll call our parents, close,
            // which might try to flush data. If we're in an error situation, that
            // will cause an error on the write, which will cause Close to be called
            // again, etc.
            //
            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() m_ShutDown:" + m_ShutDown.ToString() + " m_CallNesting:" + m_CallNesting.ToString() + " m_DoneCalled:" + m_DoneCalled.ToString());

            if (IgnoreSocketWrite) {
                // This is a WriteStream for sure and we started buffering it.
                // request.ClearRequestForResubmit may wait a user to close the stream so
                // resubmit can kick in
                GlobalLog.Assert(m_WriteStream == true, "ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal NOT m_WriteStream", "");
                if (!internalCall) {
                    SetWriteDone();
                }
            }

            //If this is an abort (ignoreShutDownCheck == true) of a write stream then we will call request.Abort()
            //that will call us again. To prevent a recursion here, only one abort is allowed.
            //However, Abort must still override previous normal close if any.
            if (ignoreShutDownCheck) {
                if (Interlocked.Exchange(ref m_ShutDown, AlreadyAborted) >= AlreadyAborted) {
                    GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal", "already has been Aborted");
                    return;
                }
            }
            else {
                //If m_ShutDown != 0, then this method has been already called before, 
                //Hence disregard this (presumably normal) extra close 
                if (Interlocked.Increment(ref m_ShutDown) > 1) {
                    GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal", "already has been closed");
                    return;
                }
            }

            //
            // Since this should be the last call made, we should be at 1
            //  and can leave it that way.  If we're not, then,
            //  chances are we're in an error state, and we need to Close()
            //  our connection.
            //

            if (Interlocked.Increment( ref m_CallNesting ) == 1) {
                normalShutDown = !s_UnloadInProgress;
            }
            GlobalLog.Print("Inc: " + m_CallNesting.ToString());

            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() normalShutDown:" + normalShutDown.ToString() + " m_CallNesting:" + m_CallNesting.ToString() + " m_DoneCalled:" + m_DoneCalled.ToString());

            if (IgnoreSocketWrite) {
                ;
            }
            else if (!m_WriteStream) {
                //
                // read stream
                //
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() Nesting: " + m_CallNesting.ToString());

                if (normalShutDown) {
                    GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() read stream, calling DrainSocket()");
                    normalShutDown = DrainSocket();
                }
            }
            else {
                //
                // write stream. terminate our chunking if needed.
                //
                try {
                    if (!ErrorInStream && normalShutDown) {
                        //
                        // if not error already, then...
                        // first handle chunking case
                        //
                        if (WriteChunked) {
                            //
                            // no need to buffer here:
                            // on resubmit, we won't be chunking anyway this will send 5 bytes on the wire
                            //
                            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() Chunked, writing ChunkTerminator");
                            try {
                                // The idea behind is that closed stream must not write anything to the wire
                                // Still if we are chunking, the now buffering and future resubmit is possible
                                if (!m_IgnoreSocketWrite) {
                                    m_IgnoreSocketWrite = true;
                                    SafeSetSocketTimeout(true);
                                    m_Connection.Write(m_ChunkTerminator, 0, m_ChunkTerminator.Length);
                                    SafeSetSocketTimeout(false);
                                }
                            }
                            catch {
                                    GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() IGNORE chunk write fault");
                                }
                            // if we completed writing this stream, then no more bytes to write out.
                            // If USER is closing the chunking stream while buffering, do trigger optionally waiting resubmit
                            if (!internalCall) {
                                SetWriteDone();
                            }
                        }
                        else if (BytesLeftToWrite>0) {
                            //
                            // not enough bytes written to client
                            //
                            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() TotalBytesToWrite:" + TotalBytesToWrite.ToString() + " BytesLeftToWrite:" + BytesLeftToWrite.ToString() + " throwing not enough bytes written");
                            throw new IOException(SR.GetString(SR.net_io_notenoughbyteswritten));
                        }
                        else if (BufferOnly) {
                            //
                            // now we need to use the saved reference to the request the client
                            // closed the write stream. we need to wake up the request, so that it
                            // sends the headers and kick off resubmitting of buffered entity body
                            //
                            GlobalLog.Assert(m_Request!=null, "ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal m_Request==null", "");
                            //
                            // set the Content Length
                            //
                            BytesLeftToWrite = TotalBytesToWrite = BufferedData.Length;
                            m_Request.SetContentLength(TotalBytesToWrite);
                            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() set ContentLength to:" + BufferedData.Length.ToString() + " now calling EndSubmitRequest()");
                            //
                            // writing the headers will kick off the whole request submission process
                            // (including waiting for the 100 Continue and writing the whole entity body)
                            //
                            SafeSetSocketTimeout(true);
                            m_Request.EndSubmitRequest();
                            SafeSetSocketTimeout(false);

                            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal", "Done");
                            return;
                        }
                    }
                    else {
                        normalShutDown = false;
                        GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() ErrorInStream:" + ErrorInStream.ToString());
                    }
                }
                catch (Exception exception) {
                    exceptionOnWrite = new WebException(
                        NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.RequestCanceled),
                        exception,
                        WebExceptionStatus.RequestCanceled,
                        null);

                    normalShutDown = false;
                    GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() exceptionOnWrite:" + exceptionOnWrite.Message);
                }
            }

            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() normalShutDown:" + normalShutDown.ToString() + " m_CallNesting:" + m_CallNesting.ToString() + " m_DoneCalled:" + m_DoneCalled.ToString());

            if (!normalShutDown && m_DoneCalled==0) {
                // If a normal Close (ignoreShutDownCheck == false) has turned into Abort _inside_ this method,
                // then check if another abort has been charged from other thread
                if (!ignoreShutDownCheck && Interlocked.Exchange(ref m_ShutDown, AlreadyAborted) >= AlreadyAborted){
                    GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal", "other thread has charged Abort(), canceling that one");
                    return;
                }
                //
                // then abort the connection if we finished in error
                //   note: if m_DoneCalled != 0, then we no longer have
                //   control of the socket, so closing would cause us
                //   to close someone else's socket/connection.
                //
                m_ErrorException =
                    new WebException(
                        NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.RequestCanceled),
                        WebExceptionStatus.RequestCanceled);

                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() Aborting the connection");

                m_Connection.Abort();
                // For write stream Abort() we depend on either of two, i.e:
                // 1. The connection BeginRead is curently posted (means there are no response headers received yet)
                // 2. The response (read) stream must be closed as well if aborted this (write) stream.
                // Next block takesm care of (2) since otherwise, (1) is true.
                if (m_WriteStream) {
                    HttpWebRequest req = m_Request;
                    if (req != null) {
                        req.Abort();
                    }
                }

                if (exceptionOnWrite != null) {
                    GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() calling CallDone() on exceptionOnWrite:" + exceptionOnWrite.Message);

                    CallDone();

                    if (!internalCall) {
                        GlobalLog.LeaveException("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() throwing:", exceptionOnWrite);
                        throw exceptionOnWrite;
                    }
                }
            }
            //
            // Let the connection know we're done writing or reading.
            //
            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal() calling CallDone()");

            CallDone();

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::CloseInternal", "Done");
        }


        /*++
            Flush - Flush the stream

            Called when the user wants to flush the stream. This is meaningless to
            us, so we just ignore it.

            Input:

                Nothing.

            Returns:

                Nothing.



        --*/
        public override void Flush() {
        }

        /*++
            Seek - Seek on the stream

            Called when the user wants to seek the stream. Since we don't support
            seek, we'll throw an exception.

            Input:

                offset      - offset to see
                origin      - where to start seeking

            Returns:

                Throws exception



        --*/
        public override long Seek(long offset, SeekOrigin origin) {
            throw new NotSupportedException(SR.GetString(SR.net_noseek));
        }

        /*++
            SetLength - Set the length on the stream

            Called when the user wants to set the stream length. Since we don't
            support seek, we'll throw an exception.

            Input:

                value       - length of stream to set

            Returns:

                Throws exception



        --*/
        public override void SetLength(long value) {
            throw new NotSupportedException(SR.GetString(SR.net_noseek));
        }

        /*++
            MakeMemoryStream

            This creates a Clone of this stream with all the network contents
            drained out into a buffer, thus allowing us to close the stream

            Input:

               None

            Returns:

               ConnectStream - Stream with all contents in memory buffered

        --*/

        internal virtual ConnectStream MakeMemoryStream() {
            MemoryStream BufferStream = new MemoryStream(0);      // buffered Stream to save off data


            //
            // Without enough threads, we could deadlock draining the socket
            //

            if (Connection.IsThreadPoolLow()) {
                return null;
            }

            //
            // First, Remove buffer and copy to new buffer,
            //  then begin read of bytes from wire into buffer
            //

            if (!m_Chunked) {
                long ReadBytes = m_ReadBytes;

                if (m_ReadBufferSize != 0) {
                    // There's stuff in our read buffer.

                    BufferStream.Write(m_ReadBuffer, m_ReadOffset, (int)m_ReadBufferSize);

                    // Update our internal read buffer state with what we took.

                    m_ReadOffset += m_ReadBufferSize;

                    if (m_ReadBytes != -1) {
                        m_ReadBytes -= m_ReadBufferSize;
                        GlobalLog.Assert(m_ReadBytes >= 0,
                                     "ConnectStream: Attempting to read more bytes than avail",
                                     "m_ReadBytes < 0");

                        GlobalLog.Print("m_ReadBytes = "+m_ReadBytes);
                    }

                    m_ReadBufferSize = 0;

                    // If the read buffer size has gone to 0, null out our pointer
                    // to it so maybe it'll be garbage-collected faster.
                    m_ReadBuffer = null;
                }
            }

            //
            // Now drain the socket the old, slow way by reading or parsing Chunked stuff
            //

            if (!this.Eof) {
                byte [] Buffer = new byte[1024];
                int BytesTransferred = 0;

                try {
                    while (!ErrorInStream && m_ShutDown == 0 && (BytesTransferred = Read(Buffer, 0, 1024)) > 0) {
                        BufferStream.Write(Buffer, 0, BytesTransferred);
                    }
                }
                catch {
                }
            }

            return
                new ConnectStream(
                    null,
                    BufferStream.ToArray(),
                    0,
                    (int)BufferStream.Length, // watch out for the cast here?
                    BufferStream.Length,
                    false,
                    false
#if DEBUG
                    ,null
#endif
                    );
        }

        /*++
            DrainSocket - Reads data from the connection, till we'll ready
                to finish off the stream, or close the connection for good.


            returns - bool true on success, false on failure

        --*/
        private bool DrainSocket() {
            GlobalLog.Enter("ConnectStream::DrainSocket");

            //
            // Without enough threads, we could deadlock draining the socket
            //

            if (Connection.IsThreadPoolLow()) {
                GlobalLog.Leave("ConnectStream::DrainSocket", false);
                return false;
            }

            //
            // If its not chunked and we have a read buffer, don't waste time coping the data
            //  around againg, just pretend its gone, i.exception. make it die
            //
            long ReadBytes = m_ReadBytes;

            if (!m_Chunked) {

                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::DrainSocket() m_ReadBytes:" + m_ReadBytes.ToString() + " m_ReadBufferSize:" + m_ReadBufferSize.ToString());

                if (m_ReadBufferSize != 0) {
                    //
                    // There's stuff in our read buffer.
                    // Update our internal read buffer state with what we took.
                    //
                    m_ReadOffset += m_ReadBufferSize;

                    GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::DrainSocket() m_ReadBytes:" + m_ReadBytes.ToString() + " m_ReadOffset:" + m_ReadOffset.ToString());

                    if (m_ReadBytes != -1) {

                        m_ReadBytes -= m_ReadBufferSize;

                        GlobalLog.Print("m_ReadBytes = "+m_ReadBytes);

                        // error handling, we shouldn't hang here if trying to drain, and there
                        //  is a mismatch with Content-Length and actual bytes.
                        //
                        //  Note: I've seen this often happen with yahoo sites where they return 204
                        //  in violation of HTTP/1.1 with a Content-Length > 0

                        if (m_ReadBytes < 0) {
                            GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::DrainSocket() m_ReadBytes:" + m_ReadBytes.ToString() + " incorrect Content-Length? setting m_ReadBytes to 0 and returning false.");
                            m_ReadBytes = 0;
                            GlobalLog.Leave("ConnectStream::DrainSocket", false);
                            return false;
                        }
                    }
                    m_ReadBufferSize = 0;

                    // If the read buffer size has gone to 0, null out our pointer
                    // to it so maybe it'll be garbage-collected faster.
                    m_ReadBuffer = null;
                }

                // exit out of drain Socket when there is no connection-length,
                // it doesn't make sense to drain a possible empty socket,
                // when we're just going to close it.
                if (ReadBytes == -1) {
                    GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::DrainSocket() ReadBytes==-1, returning true");
                    return true;
                }
            }

            //
            // in error or Eof, we may be in a weird state
            //  so we need return if we as if we don't have any more
            //  space to read, note Eof is true when there is an error
            //

            if (this.Eof) {
                GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::DrainSocket() Eof, returning true");
                return true;
            }


            //
            // If we're draining more than 64K, then we should
            //  just close the socket, since it would be costly to
            //  do this.
            //

            if (m_ReadBytes > m_MaxDrainBytes) {
                GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::DrainSocket() m_ReadBytes:" + m_ReadBytes.ToString() + " too large, Closing the Connection");
                m_Connection.Abort(false);
                GlobalLog.Leave("ConnectStream::DrainSocket", true);
                return true;
            }

            //
            // Now drain the socket the old, slow way by reading or pasing Chunked stuff
            //
            m_Draining = true;
            int bytesRead;
            for (;;) {
                try {
                    bytesRead = this.ReadWithoutValidation(drainingBuffer, 0, drainingBuffer.Length);
                    GlobalLog.Print("ConnectStream#" + ValidationHelper.HashString(this) + "::DrainSocket() drained bytesRead:" + m_ReadBytes.ToString() + " bytes");
                    if (bytesRead<=0) {
                        break;
                    }
                }
                catch (Exception) {
                    //
                    // ignore exceptions
                    //
                    break;
                }
            }

            GlobalLog.Leave("ConnectStream::DrainSocket", true);
            return true;
        }

        private static byte[] drainingBuffer = new byte[1024];

        /*++
            IOError - Handle an IOError on the stream.

            Called when we get an error doing IO on the stream. We'll call
            the read done and write done methods as appropriate, set the error
            flag, and throw an I/O exception.

            Input:

                exception       - optional Exception that will be later thrown

            Returns:

                Nothing.



        --*/
        private void IOError() {
            this.IOError(null);
        }

        private void IOError(Exception exception) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::IOError", "Connection# " + ValidationHelper.HashString(m_Connection));

            string Msg;

            if ( exception == null ) {
                if ( !m_WriteStream ) {
                    Msg = SR.GetString(SR.net_io_readfailure);
                } else {
                    Msg = SR.GetString(SR.net_io_writefailure);
                }

                exception = new IOException(Msg);
            }

            //
            // we're finished for reading, so make it so.
            //
            m_ChunkEofRecvd = true;

            //
            // we've got an error set it
            //
            m_ErrorException = exception;

            CallDone();

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::IOError");
        }


        /*++

            GetChunkHeader

            A private utility routine to convert an integer to a chunk header,
            which is an ASCII hex number followed by a CRLF. The header is retuned
            as a byte array.

            Input:

                size        - Chunk size to be encoded
                offset      - Out parameter where we store offset into buffer.

            Returns:

                A byte array with the header in int.

        --*/

        private byte[] GetChunkHeader(int size, out int offset) {
            GlobalLog.Enter("ConnectStream#" + ValidationHelper.HashString(this) + "::GetChunkHeader", "size:" + size.ToString());

            uint Mask = 0xf0000000;
            byte[] Header = new byte[10];
            int i;
            offset = -1;

            //
            // Loop through the size, looking at each nibble. If it's not 0
            // convert it to hex. Save the index of the first non-zero
            // byte.
            //
            for (i = 0; i < 8; i++, size <<= 4) {
                //
                // offset == -1 means that we haven't found a non-zero nibble
                // yet. If we haven't found one, and the current one is zero,
                // don't do anything.
                //
                if (offset == -1) {
                    if ((size & Mask) == 0) {
                        continue;
                    }
                }

                //
                // Either we have a non-zero nibble or we're no longer skipping
                // leading zeros. Convert this nibble to ASCII and save it.
                //
                uint Temp = (uint)size >> 28;

                if (Temp < 10) {
                    Header[i] = (byte)(Temp + '0');
                }
                else {
                    Header[i] = (byte)((Temp - 10) + 'A');
                }

                //
                // If we haven't found a non-zero nibble yet, we've found one
                // now, so remember that.
                //
                if (offset == -1) {
                    offset = i;
                }
            }

            Header[8] = (byte)'\r';
            Header[9] = (byte)'\n';

            GlobalLog.Leave("ConnectStream#" + ValidationHelper.HashString(this) + "::GetChunkHeader");
            return Header;
        }

    } // class ConnectStream


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_connection.cs ===
//------------------------------------------------------------------------------
// <copyright file="_Connection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Diagnostics;
    using System.IO;
    using System.Net.Sockets;
    using System.Text;
    using System.Threading;
    using System.Security;
    using System.Globalization;
    
    internal enum ReadState {
        Start,
        StatusLine, // about to parse status line
        Headers,    // reading headers
        Data        // now read data
    }

    internal enum DataParseStatus {
        NeedMoreData,       // need more data
        ContinueParsing,    // continue parsing
        Done,               // done
        Invalid,            // bad data format
        DataTooBig,         // data exceeds the allowed size
    }

    internal enum WriteBufferState {
        Disabled,
        Headers,
        Buffer,
        Playback,
    }

    internal enum ConnectionFailureGroup {
        Receive,
        Connect,
        ConnectReadStarted,
        Parsing
    }

    /*++

        BufferChunkBytes - A class to read a chunk stream from a buffer.

        A simple little value class that implements the IReadChunkBytes
        interface.

    --*/
    internal struct BufferChunkBytes : IReadChunkBytes {

        public byte[] Buffer;
        public int Offset;
        public int Count;

        public int NextByte {
            get {
                if (Count != 0) {
                    Count--;
                    return (int)Buffer[Offset++];
                }
                return -1;
            }
            set {
                Count++;
                Offset--;
                Buffer[Offset] = (byte)value;
            }
        }
    }

    //
    // ConnectionReturnResult - used to spool requests that have been completed,
    //  and need to be notified.
    //

    internal class ConnectionReturnResult {

        private static readonly WaitCallback s_InvokeConnectionCallback = new WaitCallback(InvokeConnectionCallback);

        private ArrayList m_RequestList = new ArrayList();

        internal static void SetResponse(ConnectionReturnResult returnResult, HttpWebRequest request, CoreResponseData coreResponseData) {
            try {
                request.SetResponse(coreResponseData);
            }
            catch {
                if (returnResult != null && returnResult.m_RequestList.Count>0) {
                    ThreadPool.QueueUserWorkItem(s_InvokeConnectionCallback, returnResult);
                }
                throw;
            }
            if (returnResult!= null) {
                ConnectionReturnResult.SetResponses(returnResult);
            }
        }

        internal static void Add(ref ConnectionReturnResult returnResult, HttpWebRequest request, CoreResponseData coreResponseData) {
            if (returnResult == null) {
                returnResult = new ConnectionReturnResult();
            }
            request.CoreResponse = coreResponseData;
            returnResult.m_RequestList.Add(request);
        }

        internal static void AddException(ref ConnectionReturnResult returnResult, HttpWebRequest request, Exception exception) {
            if (returnResult == null) {
                returnResult = new ConnectionReturnResult();
            }
            request.CoreResponse = exception;
            returnResult.m_RequestList.Add(request);
        }

        internal static void AddExceptionRange(ref ConnectionReturnResult returnResult, HttpWebRequest [] requests, Exception exception) {
            if (returnResult == null) {
                returnResult = new ConnectionReturnResult();
            }
            foreach (HttpWebRequest request in requests) {
                request.CoreResponse = exception;
            }
            returnResult.m_RequestList.AddRange(requests);
        }

        internal static void SetResponses(ConnectionReturnResult returnResult) {
            if (returnResult==null){
                return;
            }
            for (int i=0;i<returnResult.m_RequestList.Count;i++) {
                try {
                    HttpWebRequest request = (HttpWebRequest) returnResult.m_RequestList[i];
                    CoreResponseData coreResponseData = request.CoreResponse as CoreResponseData;

                    if (coreResponseData != null) {
                        request.SetResponse(coreResponseData);
                    }
                    else {
                        GlobalLog.DebugRemoveRequest(request);
                        Exception exception = request.CoreResponse as Exception;
                        request.SetResponse(exception);
                    }
                }
                catch {
                    // on error, with more than one callback need to queue others off to another thread
                    returnResult.m_RequestList.RemoveRange(0,(i+1));
                    if (returnResult.m_RequestList.Count>0) {
                        ThreadPool.QueueUserWorkItem(s_InvokeConnectionCallback, returnResult);
                    }
                    throw;
                }
            }

            returnResult.m_RequestList.Clear();
        }

        private static void InvokeConnectionCallback(object objectReturnResult) {
            ConnectionReturnResult returnResult = (ConnectionReturnResult)objectReturnResult;
            SetResponses(returnResult);
        }
    }

    //
    // Connection - this is the Connection used to parse
    //   server responses, queue requests, and pipeline requests
    //
    internal class Connection {

        //
        // class members
        //

        private bool                m_CanPipeline;
        private bool                m_Pipelining;
        private bool                m_KeepAlive;
        private WebExceptionStatus  m_Error;
        private byte[]              m_ReadBuffer;
        private int                 m_BytesRead;
        private int                 m_HeadersBytesUnparsed;
        private int                 m_BytesScanned;
        private int                 m_TotalResponseHeadersLength;
        private int                 m_MaximumResponseHeadersLength;
        private CoreResponseData    m_ResponseData;
        private ReadState           m_ReadState;
        private ArrayList           m_WaitList;
        private ArrayList           m_WriteList;
        private int                 m_CurrentRequestIndex;
        private int []              m_StatusLineInts;
        private string              m_StatusDescription;
        private int                 m_StatusState;
        private ConnectionGroup     m_ConnectionGroup;
        private WeakReference       m_WeakReference;
        private bool                m_Idle;
        private ServicePoint        m_Server;
        private Version             m_Version;
        private NetworkStream       m_Transport;

        // Manual Event used to indicate when we are
        // allowed to fire StartConnection i.e. not during ReadCallback()'s stack

        private ManualResetEvent    m_ReadCallbackEvent;
        private WaitOrTimerCallback m_StartConnectionDelegate;
        private static readonly WaitCallback m_PostReceiveDelegate = new WaitCallback(DoPostReceiveCallback);
        private static readonly AsyncCallback m_ReadCallback = new AsyncCallback(ReadCallback);

        //
        // Abort handling variables. When trying to abort the
        // connection, we set m_Abort = true, and close m_AbortSocket
        // if its non-null. m_AbortDelegate, is returned to every
        // request from our SubmitRequest method.  Calling m_AbortDelegate
        // drives us into Abort mode.
        //
        private bool              m_Abort;
        private HttpAbortDelegate m_AbortDelegate;
        private Socket            m_AbortSocket;
        private Socket            m_AbortSocket6;

        private UnlockConnectionDelegate m_ConnectionUnlock;

        //
        // when calling Read from the Socket, we will try to read up to
        // 4K (1 page), and then give data to the user from the buffer
        // until we can. when we cannot, we'll read from the Socket again.
        //
        private const int           m_ReadBufferSize = 4096;

        //
        // m_ReadDone and m_Write - no two vars are so complicated,
        //  as these two. Used for m_WriteList managment, most be under crit
        //  section when accessing.
        //
        // m_ReadDone tracks the item at the end or
        //  just recenlty removed from the m_WriteList. While a
        //  pending BeginRead is in place, we need this to be false, in
        //  order to indicate to tell the WriteDone callback, that we can
        //  handle errors/resets.  The only exception is when the m_WriteList
        //  is empty, and there are no outstanding requests, then all it can
        //  be true.
        //
        // m_WriteDone tracks the item just added at the begining of the m_WriteList.
        //  this needs to be false while we about to write something, but have not
        //  yet begin or finished the write.  Upon completion, its set to true,
        //  so that DoneReading/ReadStartNextRequest can close the socket, without fear
        //  of a errand writer still banging away on another thread.
        //

        private bool m_ReadDone;
        private bool m_WriteDone;
        private bool m_Free;

        //
        // m_Tunnelling is true when this connection is establishing a tunnel
        // through a proxy. After the tunnel is established, this connection
        // will be retired
        //

        private bool m_Tunnelling;

        internal bool Tunnelling {
            get {
                return m_Tunnelling;
            }
            set {
                m_Tunnelling = value;
            }
        }

        private Exception m_UnderlyingException;

        private Exception UnderlyingException {
            get {
                return m_UnderlyingException;
            }
            set {
                m_UnderlyingException = value;
            }
        }

        //
        // m_LockedRequest is the request that needs exclusive access to this connection
        //  the ConnectionGroup should proctect the Connection object from any new 
        //  Requests being queued, until this m_LockedRequest is finished.
        //

        private HttpWebRequest      m_LockedRequest;

        internal HttpWebRequest LockedRequest {
            get {
                return m_LockedRequest;
            }
            set {
                if (m_LockedRequest != null && value != m_LockedRequest) {
                    m_LockedRequest.UnlockConnectionDelegate = null;
                }
                GlobalLog.Print("LockedRequest: old#"+ ((m_LockedRequest!=null)?m_LockedRequest.GetHashCode().ToString():"null") +  " new#" + ((value!=null)?value.GetHashCode().ToString():"null"));
                m_LockedRequest = value;
                if (m_LockedRequest != null) {
                    m_LockedRequest.UnlockConnectionDelegate = m_ConnectionUnlock;
                }
            }
        }


        /// <devdoc>
        ///    <para>
        ///       Delegate called when the request is finished using this Connection
        ///         exclusively.  Called in Abort cases and after NTLM authenticaiton completes.
        ///    </para>
        /// </devdoc>
        internal void UnlockRequest() {
            GlobalLog.Print("UnlockRequest called cnt#" + this.GetHashCode().ToString());
            LockedRequest = null;
            CheckIdle();
        }


#if TRAVE
        private string MyLocalEndPoint {
            get {
                try {
                    return Transport.StreamSocket.LocalEndPoint.ToString();
                }
                catch {
                    return "no connection";
                }
            }
        }

        private string MyLocalPort {
            get {
                try {
                    if (Transport == null || Transport.StreamSocket == null || Transport.StreamSocket.LocalEndPoint == null) {
                        return "no connection";
                    }
                    return ((IPEndPoint)Transport.StreamSocket.LocalEndPoint).Port.ToString();
                }
                catch {
                    return "no connection";
                }
            }
        }
#endif


        public Connection(
            ConnectionGroup   connectionGroup,
            ServicePoint      servicePoint,
            IPAddress         remoteAddress,
            Version           version,
            bool              supportsPipeline
            ) {
            //
            // add this Connection to the pool in the connection group,
            //  keep a weak reference to it
            //
            m_ConnectionGroup = connectionGroup;
            m_WeakReference = new WeakReference(this);
            m_ConnectionGroup.Associate(m_WeakReference);
            m_Idle = true;
            m_Free = true;
            m_CanPipeline = supportsPipeline;
            m_Server = servicePoint;
            m_Version = version;
            m_ReadBuffer = new byte[m_ReadBufferSize];
            m_CurrentRequestIndex = 0;
            m_ReadState = ReadState.Start;
            m_WaitList = new ArrayList();
            m_WriteList = new ArrayList();
            m_ReadCallbackEvent = new ManualResetEvent(true);
            m_StartConnectionDelegate = new WaitOrTimerCallback(StartConnectionCallback);
            m_AbortDelegate = new HttpAbortDelegate(Abort);
            m_ConnectionUnlock = new UnlockConnectionDelegate(UnlockRequest);
            // for status line parsing
            m_StatusLineInts = new int[MaxStatusInts];
            InitializeParseStatueLine();
        }

        ~Connection() {
            //
            // remove this Connection from the pool in the connection group
            //
#if TRAVE
            GlobalLog.Print("+++ ["+MyLocalPort+"] Connection #"+GetHashCode()+" disassociating "+ValidationHelper.HashString(m_WeakReference));
#endif
            m_ConnectionGroup.Disassociate(m_WeakReference);
        }

        internal NetworkStream Transport {
            get {
                return m_Transport;
            }
        }

        public int BusyCount {
            get {
                return (m_ReadDone?0:1) + 2 * (m_WaitList.Count + m_WriteList.Count);
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates true if the threadpool is low on threads,
        ///       in this case we need to refuse to start new requests,
        ///       and avoid blocking.
        ///    </para>
        /// </devdoc>
        static internal bool IsThreadPoolLow() {

            if (ComNetOS.IsAspNetServer) {
                return false;
            }

            int workerThreads, completionPortThreads;
            ThreadPool.GetAvailableThreads(out workerThreads, out completionPortThreads);

            if (workerThreads < 2 || (ComNetOS.IsWinNt && completionPortThreads < 2)) {
                return true;
            }

            return false;
        }

        /*++

            SubmitRequest       - Submit a request for sending.

            The core submit handler. This is called when a request needs to be
            submitted to the network. This routine is asynchronous; the caller
            passes in an HttpSubmitDelegate that we invoke when the caller
            can use the underlying network. The delegate is invoked with the
            stream that it can right to.

            Input:
                    Request                 - Request that's being submitted.
                    SubmitDelegate          - Delegate to be invoked.

            Returns:
                    true when the Request was correctly submitted

        --*/

        public bool SubmitRequest(HttpWebRequest Request) {

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::SubmitRequest", ValidationHelper.HashString(Request));
            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::SubmitRequest_Cnt# " + ValidationHelper.HashString(this));
            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::SubmitRequest state, m_Free:" + m_Free.ToString() + " m_WaitList.Count:" + m_WaitList.Count.ToString());            
            
            Request.AbortDelegate = m_AbortDelegate;

            // See if the connection is free, and if the underlying socket or
            // stream is set up. If it is, we can assign this connection to the
            // request right now. Otherwise we'll have to put this request on
            // on the wait list until it its turn.

            Monitor.Enter(this);

            //
            // If the connection has already been locked by another request, then 
            // we fail the submission on this Connection.
            //

            if (LockedRequest != null && LockedRequest != Request) { 
                Monitor.Exit(this);
                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::SubmitRequest");
                return false;
            }

            GlobalLog.DebugAddRequest(Request, this, 0);

            if (m_Free) {

                // Connection is free. Mark it as busy and see if underlying
                // socket is up.

                m_Free = false;
                //
                // by virtue of calling StartRequest, we need to make sure,
                // m_ReadDone is false when we have nothing in the WriteQueue
                //
                if (m_WriteList.Count == 0 ) {
                    m_ReadDone = false;
                }

                //
                // StartRequest will call Monitor.Exit(this) sometime
                //
                StartRequest(Request);
            }
            else {
                m_WaitList.Add(Request);
#if TRAVE
                if (Tunnelling) {
                    GlobalLog.Print("*** ["+MyLocalPort+"] ERROR: adding "+Request+"#"+Request.GetHashCode()+" request to tunnelling connection #"+GetHashCode()+" WaitList");
                }
                else {
                    GlobalLog.Print("*** ["+MyLocalPort+"] adding "+Request+"#"+Request.GetHashCode()+" request to non-tunnelling connection #"+GetHashCode()+" WaitList, total="+m_WaitList.Count);
                }
#endif
                CheckNonIdle();
                Monitor.Exit(this);
            }

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::SubmitRequest");
            return true;
        }

        /*++

            StartRequest       - Start a request going.

            Routine to start a request. Called when we know the connection is
            free and we want to get a request going. This routine initializes
            some state, adds the request to the write queue, and checks to
            see whether or not the underlying connection is alive. If it's
            not, it queues a request to get it going. If the connection
            was alive we call the callback delegate of the request.

            This routine MUST BE called with the critcal section held.

            Input:
                    Request                 - Request that's being started.
                    SubmitDelegate          - Delegate to be invoked.

            Returns:
                    True if request was started, false otherwise.

        --*/

#if DEBUG
        internal bool m_StartDelegateQueued = false;
#endif

        private void StartRequest(HttpWebRequest Request) {
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::StartRequest", ValidationHelper.HashString(Request));
            bool needReConnect = false;

            // Initialze state, and add the request to the write queue.

            // disable pipeling in certain cases such as when the Request disables it,
            // OR if the request is made using a Verb that cannot be pipelined,
            // BUT!! What about special verbs with data?? Should we not disable then too?

            m_Pipelining = m_CanPipeline && Request.InternalPipelined && (!Request.RequireBody);
            m_KeepAlive = Request.KeepAlive;

            // start of write process, disable done-ness flag
            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::StartRequest() setting m_WriteDone:" + m_WriteDone.ToString() + " to false");
            m_WriteDone = false;

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::StartRequest() _WriteList Add " + ValidationHelper.HashString(Request) + " - cnt#" + ValidationHelper.HashString(this) );
            m_WriteList.Add(Request);
            GlobalLog.Print(m_WriteList.Count+" requests queued");
            CheckNonIdle();

            // with no transport around, we will have to create one, therefore, we can't have
            //  the possiblity to even have a DoneReading().

            if (Transport == null) {
                m_ReadDone = false;
                needReConnect = true;
            }

            if (Request is HttpProxyTunnelRequest) {
#if TRAVE
                GlobalLog.Print("*** ["+MyLocalPort+"] Setting Tunnelling = true in SR on #"+GetHashCode());
#endif
                Tunnelling = true;
            }
#if TRAVE
            else {
                if (Tunnelling) {
                    GlobalLog.Print("*** ["+MyLocalPort+"] ERROR: Already tunnelling during non-tunnel request on #"+GetHashCode());
                }
                GlobalLog.Assert(!Tunnelling, "*** ["+MyLocalPort+"] ERROR: Already tunnelling during non-tunnel request on #"+GetHashCode(), "");
            }
#endif
            Monitor.Exit(this);

            //
            // When we're uploading data, to a 1.0 server, we need to buffer
            //  in order to determine content length
            //
            if (Request.CheckBuffering) {
                Request.SetRequestContinue();
            }

            if (needReConnect) {
                // Socket is not alive. Queue a request to the thread pool
                // to get it going.

                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::StartRequest() Queue StartConnection Delegate ");
#if DEBUG
                m_StartDelegateQueued = true;
                try {
#endif
                    ThreadPool.RegisterWaitForSingleObject(
                                m_ReadCallbackEvent,
                                m_StartConnectionDelegate,
                                Request,
                                -1,
                                true);
#if DEBUG
                }
                catch (Exception exception) {
                    GlobalLog.Assert(false, exception.ToString(), "");
                }
#endif

                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::StartRequest", "needReConnect");
                return;
            }


            // Call the Request to let them know that we have a write-stream

            Request.SetRequestSubmitDone(
                new ConnectStream(
                    this,
                    Request.SendChunked ? -1 : (Request.ContentLength>0 ? Request.ContentLength : 0),
                    Request )
                    );

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::StartRequest");
        }

        /*++

            CheckNextRequest

            Gets the next request from the wait queue, if there is one.

            Must be called with the crit sec held.


        --*/
        private HttpWebRequest CheckNextRequest() {
            if (m_WaitList.Count == 0) {
                //
                // We're free now, if we're not going to close the connection soon.
                //
                m_Free = m_KeepAlive;
#if TRAVE
                GlobalLog.Print("*** ["+MyLocalPort+"] would set Tunnelling = false in CNR #1 on #"+GetHashCode());
#endif
                //Tunnelling = false;
                return null;
            }
            else {
                HttpWebRequest NextRequest = (HttpWebRequest)m_WaitList[0];

                //
                // When we're uploading data, to a 1.0 server, we need to buffer
                //  in order to determine content length
                //
                if (NextRequest.CheckBuffering) {
                    NextRequest.SetRequestContinue();
                }

                if (!NextRequest.InternalPipelined || NextRequest.RequireBody) {
                    m_Pipelining = false;

                    if (m_WriteList.Count != 0) {
                        NextRequest = null;
                    }
                }
                else {
                    m_Pipelining = m_CanPipeline;
                }

                if (NextRequest != null) {
                    RemoveAtAndUpdateServicePoint(m_WaitList, 0);
#if TRAVE
                    GlobalLog.Print("*** ["+MyLocalPort+"] would set Tunnelling = false in CNR #2 on #"+GetHashCode());
#endif
                    //Tunnelling = false;
                }

                return NextRequest;
            }
        }


        /*++

            StartConnectionCallback - Start a connection.

            Utility routine to connect and post the initial receive. Called
            by the thread pool when we need to connect. We open the
            connection and post the intital receive, and then we
            call the delegate for the request that caused us to be called,
            which should always be the last request on the write queue.

            Input:
                    state       - A reference to the request that caused
                                - us to be called.

            Returns:


        --*/
        private void StartConnectionCallback(object state, bool wasSignalled) {
#if DEBUG
            m_StartDelegateQueued = false;
#endif
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::StartConnectionCallback",  ValidationHelper.HashString(state));

            //
            // Our assumptions upon entering
            //

            GlobalLog.Assert(Transport == null,
                         "StartConnectionCallback: Transport != null", "");

            GlobalLog.Assert(m_WriteList.Count != 0,
                         "StartConnectionCallback: m_WriteList.Count == 0 - cnt#" + ValidationHelper.HashString(this), "");

            GlobalLog.Assert((m_WriteList.Count == 1),
                         "StartConnectionCallback: WriteList is not sized 1 - cnt#" + ValidationHelper.HashString(this), "");

            ConnectionReturnResult returnResult = null;
            WebExceptionStatus ws = WebExceptionStatus.ConnectFailure;
            Exception unhandledException = null;
            bool readStarted = false;

            try {

                HttpWebRequest httpWebRequest = (HttpWebRequest)state;

                GlobalLog.Assert((HttpWebRequest)m_WriteList[m_WriteList.Count - 1] == httpWebRequest,
                             "StartConnectionCallback: Last request on write list does not match", "");

                //
                // Check for Abort, then create a socket,
                //  then resolve DNS and connect
                //

                if (m_Abort) {
                    ws = WebExceptionStatus.RequestCanceled;
                    goto report_error;
                }

                Socket socket = null;

                //
                // if we will not create a tunnel through a proxy then create
                // and connect the socket we will use for the connection
                //

                if ((httpWebRequest.Address.Scheme != Uri.UriSchemeHttps) || !m_Server.InternalProxyServicePoint) {
                    //
                    // IPv6 Support: If IPv6 is enabled, then we create a second socket that ServicePoint
                    //               will use if it wants to connect via IPv6.
                    //
                    m_AbortSocket  = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);
                    m_AbortSocket6 = null;

                    if ( Socket.SupportsIPv6 ) {
                        m_AbortSocket6 = new Socket(AddressFamily.InterNetworkV6,SocketType.Stream,ProtocolType.Tcp);
                    }

                    ws = m_Server.ConnectSocket(m_AbortSocket,m_AbortSocket6,ref socket);

                    if (ws != WebExceptionStatus.Success) {
                        goto report_error;
                    }

                    if (m_Abort) {
                        ws = WebExceptionStatus.RequestCanceled;
                        goto report_error;
                    }
                    //
                    // There should be no means for socket to be null at this
                    // point, but the damage is greater if we just carry on 
                    // without ensuring that it's good.
                    //
                    if ( socket == null ) {
                        ws = WebExceptionStatus.ConnectFailure;
                        goto report_error;
                    }

                    GlobalLog.Print("*** ["+socket.LocalEndPoint+"] connected socket on connection #"+GetHashCode());

                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::StartConnectionCallback() ConnectSocket() returns:" + ws.ToString());
                    //
                    // Decide which socket to retain
                    //
                    if ( socket.AddressFamily == AddressFamily.InterNetwork ) {
                        if ( m_AbortSocket6 != null ) {
                            m_AbortSocket6.Close();
                            m_AbortSocket6 = null;
                        }
                    }
                    else {
                        m_AbortSocket.Close();
                        m_AbortSocket = null;
                    }

                    /*
                        RLF 01/31/01

                        'Un-disable' Nagle. The majority of our perf issues on POST
                        were caused by waiting for 350mSec on every request due to a
                        threading issue.

                        The general concensus seems to be that it isn't necessary to
                        disable Nagle at any rate because a) HTTP doesn't send small
                        packets, b) modern TCP actually handles the situation of a
                        small segment at the end of a transmission without waiting for
                        an outstanding ACK.
                    */

                    //
                    // disable Nagle algorithm. Nagle tries to reduce the number of
                    // small packets being sent and their consequent acknowledgments. It
                    // attempts to wait until a larger amount of data has been collected
                    // before sending. This can cause us to wait unnecessarily when
                    // sending POST data e.g. because we wait for the server (which is
                    // also Nagling) to send ACKs. The ACKs are delayed from the server
                    // because it tries to piggyback them on data packets it will send
                    // to us. Since the server is just waiting for our data, and doesn't
                    // have anything to send to us, it waits in vain.
                    //
                    // The potential disadvantage is that if we try to send small packets,
                    // they will be individually sent and ACKed, reducing network
                    // utilization. But because we buffer @ connection level & @ TCP
                    // level, this shouldn't be an issue
                    //

                    // make this configurable from the user:
                    if (!m_Server.UseNagleAlgorithm) {
                        socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, 1);
                    }
                }

                //
                // create the transport connection from the connected socket, or
                // if tunnelling, generate a new connection through the proxy
                //

                ws = ConstructTransport(socket, ref m_Transport, httpWebRequest);

                if (ws != WebExceptionStatus.Success || Transport==null) {
                    goto report_error;
                }

                m_Error = WebExceptionStatus.Success;

                // advance back to state 0
                m_ReadState = ReadState.Start;

                // from this port forward, Abort should be done through Transport
                m_AbortSocket  = null;
                m_AbortSocket6 = null;

                readStarted = true;

                // Call the routine to post an asynchronous receive to the socket.
                try {
                    DoPostReceiveCallback(this);
                } catch {
                    readStarted = false;
                    throw;
                }

                httpWebRequest.SetRequestSubmitDone(
                    new ConnectStream(
                        this,
                        httpWebRequest.SendChunked ? -1 : (httpWebRequest.ContentLength>0 ? httpWebRequest.ContentLength : 0),
                        httpWebRequest )
                    );

                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::StartConnectionCallback");
                return;
            }
            catch (Exception exception) {
                unhandledException = exception;
            }

    report_error:

            // disable Abort directly on socket
            m_AbortSocket  = null;
            m_AbortSocket6 = null;

            if (m_Abort) {
                ws = WebExceptionStatus.RequestCanceled;
            }

            // if the read is already started, then we need to wait for its failure, before shutting down
            HandleError(ws, (readStarted ? ConnectionFailureGroup.ConnectReadStarted : ConnectionFailureGroup.Connect), ref returnResult);
            ConnectionReturnResult.SetResponses(returnResult);

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::StartConnectionCallback", "on error");
            if (unhandledException!= null) {
                throw new IOException(SR.GetString(SR.net_io_transportfailure), unhandledException);
            }
        }

        internal void WriteStartNextRequest(ScatterGatherBuffers writeBuffer, ref ConnectionReturnResult returnResult) {
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::WriteStartNextRequest");
            //
            // If we've been buffering, data in order to determina
            //  data size length for eing/Put, then now at this
            //  point do the actual upload
            //
            if (writeBuffer!=null) {
                try {
                    //
                    // Upload entity body data that has been buffered now
                    //
                    Write(writeBuffer);
                }
                catch (Exception exception) {
                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::WriteStartNextRequest(ScatterGatherBuffers) caught Exception:" + exception.Message);
                    m_Error = WebExceptionStatus.SendFailure;
                }
            }

            Monitor.Enter(this);

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::WriteStartNextRequest() setting m_WriteDone:" + m_WriteDone.ToString() + " to true");
            m_WriteDone = true;

            HttpWebRequest NextRequest = null;

            //
            // If we're not doing keep alive, and the read on this connection
            // has already completed, now is the time to close the
            // connection.
            //
            if (!m_KeepAlive || m_Error != WebExceptionStatus.Success) {
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::WriteStartNextRequest() _WriteList (size) " + m_WriteList.Count.ToString() + " - cnt#" + ValidationHelper.HashString(this));
                if (m_ReadDone) {
                    // We could be closing because of an unexpected keep-alive
                    // failure, ie we pipelined a few requests and in the middle
                    // the remote server stopped doing keep alive. In this
                    // case m_Error could be success, which would be misleading.
                    // So in that case we'll set it to connection closed.

                    if (m_Error == WebExceptionStatus.Success) {
                        // Only reason we could have gotten here is because
                        // we're not keeping the connection alive.

                        GlobalLog.Assert(!m_KeepAlive,
                                     "WriteStartNextRequest: m_KeepAlive is true",
                                     "Closing connection with both keepalive true and m_Error == success"
                                    );

                        m_Error = WebExceptionStatus.KeepAliveFailure;

                    }

                    // CloseConnectionSocket is called with the critical section
                    // held. Note that we know since it's not a keep-alive
                    // connection the read half wouldn't have posted a receive
                    // for this connection, so it's OK to call
                    // CloseConnectionSocket now.

                    CloseConnectionSocket(m_Error, ref returnResult);
                }
                else {
                    if (m_Error!=WebExceptionStatus.Success) {
                        GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::WriteStartNextRequest() Send Failire");
                    }

                    Monitor.Exit(this);
                }

                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::WriteStartNextRequest[2]");
                return;
            }

            // If we're pipelining, we get get the next request going
            // as soon as the write is done. Otherwise we have to wait
            // until both read and write are done.

            if (m_Pipelining || m_ReadDone) {
                NextRequest = CheckNextRequest();
            }

            if (NextRequest != null) {

                // need to disable read done, since we're about to post
                // another read callback, and add a request

                if (m_WriteList.Count == 0) {
                    m_ReadDone = false;
                }

                StartRequest(NextRequest);
            }
            else {
                Monitor.Exit(this);
            }

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::WriteStartNextRequest");
        }


        /*++

            ReadStartNextRequest

            This method is called by a stream interface when it's done reading.
            We might possible free up the connection for another request here.

            Called when we think we might need to start another request because
            a read completed.

            Input:

                PostReceive         - true if we need to get another receive
                                        going.

            Returns:

                true if this routine closes the connection or the connection
                will close soon, false otherwise.

        --*/
        internal bool ReadStartNextRequest(bool PostReceive, ref ConnectionReturnResult returnResult) {
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::ReadStartNextRequest", PostReceive.ToString());
            HttpWebRequest NextRequest = null;

            Monitor.Enter(this);

            m_ReadDone = true;
            //if (Tunnelling) {
#if TRAVE
                GlobalLog.Print("*** ["+MyLocalPort+"] would set Tunnelling = false in RSNR on #"+GetHashCode());
#endif
                //Tunnelling = false;
            //}

            CheckIdle();

            //
            // Since this is called after we're done reading the current
            // request, if we're not doing keepalive and we're done
            // writing we can close the connection now.
            //
            if (!m_KeepAlive || m_Error != WebExceptionStatus.Success) {
                GlobalLog.Print("RSNReq kp=" + m_KeepAlive.ToString() + " wd=" + m_WriteDone.ToString());
                if (m_WriteDone) {
                    // We could be closing because of an unexpected keep-alive
                    // failure, ie we pipelined a few requests and in the middle
                    // the remote server stopped doing keep alive. In this
                    // case m_Error could be success, which would be misleading.
                    // So in that case we'll set it to connection closed.

                    if (m_Error == WebExceptionStatus.Success && m_KeepAlive) {
                        // Only reason we could have gotten here is because
                        // we're not keeping the connection alive.

                        GlobalLog.Assert(!m_KeepAlive,
                                     "m_WriteDone: m_KeepAlive is true",
                                     "Closing connection with both keepalive true and m_Error == success"
                                    );

                        m_Error = WebExceptionStatus.KeepAliveFailure;
                    }

                    // CloseConnectionSocket has to be called with the critical
                    // section held.

                    CloseConnectionSocket(m_Error, ref returnResult);
                }
                else {
                    Monitor.Exit(this);
                }

                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ReadStartNextRequest", true);
                return true;
            }

            // If we're not pipelining, and the writing is done, we can
            // get the next request going now.
            //
            if (!m_Pipelining && m_WriteDone) {
                // The connection is free. If we're not keepalive, go
                // ahead and close it.

                NextRequest = CheckNextRequest();
            }

            //
            // If we're going to read another request,
            //  then make sure we're not not finished reading
            //

            if (m_WriteList.Count != 0 ) {
                m_ReadDone = false;
            }

            //
            // If we had another request, get it going,
            //  but only in the non-pipelining case
            //

            if (NextRequest != null) {

                // by virtue of calling StartRequest, we need to make sure,
                // m_ReadDone is false when we have nothing in the WriteQueue

                if (m_WriteList.Count == 0) {
                    m_ReadDone = false;
                }
                StartRequest(NextRequest);
            }
            else {
                //Balancing lock
                Monitor.Exit(this);
            }

            // If we need to post a receive, do so now.
            // There are some variations:
            //   - Transport is null and WILL re-connect: Then m_PostReceiveDelegate is called directly from connection callback
            //   - Transport is null and NO re-connect: Then m_PostReceiveDelegate should not be posted as causing IO error anyway
            //   - Transport becomes null SOON after this queueing: Then we get exception in m_PostReceiveDelegate that can 
            //     happen anyway as we use deffered read and cannot guarantee that transport be alive at the time of processing.
            //     The last case is handled either by furture reconnect or it will report IO error to the app.
            if (Transport != null && PostReceive) {
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::StartRequest() ThreadPool.QueueUserWorkItem(m_PostReceiveDelegate, this)");
                ThreadPool.QueueUserWorkItem(m_PostReceiveDelegate, this);
            }


            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ReadStartNextRequest", false);
            return false;
        }

        /*++

        Routine Description:

           Clears out common member vars used for Status Line parsing

        Arguments:

           None.

        Return Value:

           None.

        --*/

        private void InitializeParseStatueLine() {
            m_StatusState = BeforeVersionNumbers;
            m_StatusDescription = String.Empty;
            Array.Clear( m_StatusLineInts, 0, MaxStatusInts );
        }

        /*++

        Routine Description:

           Performs status line parsing on incomming server responses

        Arguments:

           statusLine - status line that we wish to parse
           statusLineLength - length of the array
           bytesScanned - actual bytes that we've successfully parsed
           statusLineInts - array of ints contanes result
           statusDescription - string with discription
           statusStatus     - state stored between parse attempts

        Return Value:

           bool - Success true/false

        --*/

        private const int BeforeVersionNumbers = 0;
        private const int MajorVersionNumber   = 1;
        private const int MinorVersionNumber   = 2;
        private const int StatusCodeNumber     = 3;
        private const int AfterStatusCode      = 4;
        private const int MaxStatusInts        = 4;

        private
        DataParseStatus
        ParseStatusLine(
                       byte [] statusLine,
                       int statusLineLength,
                       ref int bytesParsed,
                       ref int [] statusLineInts,
                       ref string statusDescription,
                       ref int statusState
                       ) {

            DataParseStatus parseStatus = DataParseStatus.Done;
            int bytesScanned = bytesParsed;

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::ParseStatusLine", statusLineLength.ToString() + ", " + bytesParsed.ToString() );

            GlobalLog.Assert((statusLineLength - bytesParsed) >= 0,
                "(statusLineLength - bytesParsed) < 0",
                "negative status line" );

            int statusLineSize = 0;
            int startIndexStatusDescription = -1;
            int lastUnSpaceIndex = 0;

            //
            // While walking the Status Line looking for terminating \r\n,
            //   we extract the Major.Minor Versions and Status Code in that order.
            //   text and spaces will lie between/before/after the three numbers
            //   but the idea is to remember which number we're calculating based on a numeric state
            //   If all goes well the loop will churn out an array with the 3 numbers plugged in as DWORDs
            //

            while ((bytesParsed < statusLineLength) && (statusLine[bytesParsed] != '\r') && (statusLine[bytesParsed] != '\n')) {
                // below should be wrapped in while (response[i] != ' ') to be more robust???
                switch (statusState) {
                    case BeforeVersionNumbers:
                        if (statusLine[bytesParsed] == '/') {
                            //INET_ASSERT(statusState == BeforeVersionNumbers);
                            statusState++; // = MajorVersionNumber
                        }
                        else if (statusLine[bytesParsed] == ' ') {
                            statusState = StatusCodeNumber;
                        }

                        break;

                    case MajorVersionNumber:

                        if (statusLine[bytesParsed] == '.') {
                            //INET_ASSERT(statusState == MajorVersionNumber);
                            statusState++; // = MinorVersionNumber
                            break;
                        }
                        // fall through
                        goto
                    case MinorVersionNumber;

                    case MinorVersionNumber:

                        if (statusLine[bytesParsed] == ' ') {
                            //INET_ASSERT(statusState == MinorVersionNumber);
                            statusState++; // = StatusCodeNumber
                            break;
                        }
                        // fall through
                        goto
                    case StatusCodeNumber;

                    case StatusCodeNumber:

                        if (Char.IsDigit((char)statusLine[bytesParsed])) {
                            int val = statusLine[bytesParsed] - '0';
                            statusLineInts[statusState] = statusLineInts[statusState] * 10 + val;
                        }
                        else if (statusLineInts[StatusCodeNumber] > 0) {
                            //
                            // we eat spaces before status code is found,
                            //  once we have the status code we can go on to the next
                            //  state on the next non-digit. This is done
                            //  to cover cases with several spaces between version
                            //  and the status code number.
                            //

                            statusState++; // = AfterStatusCode
                            break;
                        }
                        else if (!Char.IsWhiteSpace((char) statusLine[bytesParsed])) {
                            statusLineInts[statusState] = (int)-1;
                        }

                        break;

                    case AfterStatusCode:
                        if (statusLine[bytesParsed] != ' ') {
                            lastUnSpaceIndex = bytesParsed;

                            if (startIndexStatusDescription == -1) {
                                startIndexStatusDescription = bytesParsed;
                            }
                        }

                        break;

                }
                ++bytesParsed;
                if (m_MaximumResponseHeadersLength>=0 && ++m_TotalResponseHeadersLength>=m_MaximumResponseHeadersLength) {
                    parseStatus = DataParseStatus.DataTooBig;
                    goto quit;
                }
            }

            statusLineSize = bytesParsed;

            // add to Description if already partialy parsed
            if (startIndexStatusDescription != -1) {
                statusDescription +=
                Encoding.ASCII.GetString(
                                        statusLine,
                                        startIndexStatusDescription,
                                        lastUnSpaceIndex - startIndexStatusDescription + 1 );
            }

            if (bytesParsed == statusLineLength) {
                //
                // response now points one past the end of the buffer. We may be looking
                // over the edge...
                //
                // if we're at the end of the connection then the server sent us an
                // incorrectly formatted response. Probably an error.
                //
                // Otherwise its a partial response. We need more
                //
                parseStatus = DataParseStatus.NeedMoreData;
                //
                // if we really hit the end of the response then update the amount of
                // headers scanned
                //
                GlobalLog.Assert(bytesParsed==bytesParsed, "Connection#" + ValidationHelper.HashString(this) + "::ParseStatusLine() " + bytesParsed.ToString() + "!=" + bytesParsed.ToString(), "bytesParsed!=bytesParsed");
                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ParseStatusLine", parseStatus.ToString());
                return parseStatus;
            }

            while ((bytesParsed < statusLineLength)
                   && ((statusLine[bytesParsed] == '\r') || (statusLine[bytesParsed] == ' '))) {
                ++bytesParsed;
                if (m_MaximumResponseHeadersLength>=0 && ++m_TotalResponseHeadersLength>=m_MaximumResponseHeadersLength) {
                    parseStatus = DataParseStatus.DataTooBig;
                    goto quit;
                }
            }

            if (bytesParsed == statusLineLength) {

                //
                // hit end of buffer without finding LF
                //

                parseStatus = DataParseStatus.NeedMoreData;
                goto quit;

            }
            else if (statusLine[bytesParsed] == '\n') {
                ++bytesParsed;
                if (m_MaximumResponseHeadersLength>=0 && ++m_TotalResponseHeadersLength>=m_MaximumResponseHeadersLength) {
                    parseStatus = DataParseStatus.DataTooBig;
                    goto quit;
                }
                //
                // if we found the empty line then we are done
                //
                parseStatus = DataParseStatus.Done;
            }


            //
            // Now we have our parsed header to add to the array
            //

quit:

            if (parseStatus == DataParseStatus.Done && statusState != AfterStatusCode) {

                // need to handle the case where we parse the StatusCode,
                //  but didn't get a status Line, and there was no space afer it.

                if (statusState != StatusCodeNumber ||
                     statusLineInts[StatusCodeNumber] <= 0)
                {

                    //
                    // we're done with the status line, if we didn't parse all the
                    // numbers needed this is invalid protocol on the server
                    //

                    parseStatus = DataParseStatus.Invalid;
                }
            }

            GlobalLog.Print("m_ResponseData._StatusCode = " + statusLineInts[StatusCodeNumber].ToString());
            GlobalLog.Print("m_StatusLineInts[MajorVersionNumber] = " + statusLineInts[MajorVersionNumber].ToString());
            GlobalLog.Print("m_StatusLineInts[MinorVersionNumber] = " + statusLineInts[MinorVersionNumber].ToString());
            GlobalLog.Print("Status = " + statusDescription);

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ParseStatusLine", parseStatus.ToString());
            return parseStatus;
        }


        /*++

        Routine Description:

           SetStatusLineParsed - processes the result of status line,
             after it has been parsed, reads vars and formats result of parsing

        Arguments:

           None - uses member vars

        Return Value:

           None

        --*/

        private
        void
        SetStatusLineParsed() {
            // transfer this to response data
            m_ResponseData.m_StatusCode = (HttpStatusCode)m_StatusLineInts[StatusCodeNumber];
            m_ResponseData.m_StatusDescription = m_StatusDescription;

            // on bad version codes we need to catch the exception.
            try {
                m_ResponseData.m_Version =
                new Version(
                           m_StatusLineInts[MajorVersionNumber],
                           m_StatusLineInts[MinorVersionNumber] );
            }
            catch {
                m_ResponseData.m_Version = new Version(0,0);
            }

            if (m_Version == null) {
                m_Version = m_ResponseData.m_Version;
                if (m_Server.ProtocolVersion == null) {
                    if (m_Version.Equals( HttpVersion.Version11 )) {
                        m_Server.InternalSupportsPipelining = true;
                    }
                    else if (m_Version.Equals( HttpVersion.Version10 )) {
                        m_Server.InternalConnectionLimit = ServicePointManager.DefaultNonPersistentConnectionLimit;
                    }

                    //
                    // set this last - its the basis of the test for known version
                    // in future connection objects. There is still the slight
                    // possibility of a race condition because we are setting 2
                    // pieces of information here. We should be guarded though by
                    // the fact that IsUnkown tests both version numbers for the
                    // TriState.Unknown value and returns true if either version
                    // number has this value
                    //

                    m_Server.InternalVersion = m_Version;
                }
                m_ConnectionGroup.ProtocolVersion = m_Version;
                m_CanPipeline = m_Server.SupportsPipelining;
            }
        }

        /*++

            NotifyRequestOfResponse

            Queues up a request to be notified later on that we have a response
            this is needed since calling the request at this point could be dangerous
            due to it faulting, recalling Connection methods, etc.

            WARNING: This function can throw.

        --*/

        private void NotifyRequestOfResponse(HttpWebRequest request, ref ConnectionReturnResult returnResult, bool readDoneExpected) {
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::NotifyRequestOfResponse", "Request:" + ValidationHelper.HashString(request));

            // for HEAD reqs, 1xx,204,304 responses assume a 0 content-length
            UpdateContentLength(request);
            UpdateSelectedClientCertificate(request);

    #if DEBUG
            if (readDoneExpected) {
                GlobalLog.DebugUpdateRequest(request, this, GlobalLog.WaitingForReadDoneFlag);
            }
            else {
                GlobalLog.DebugRemoveRequest(request);
            }
    #endif

            if (readDoneExpected && !m_Pipelining) {
                ConnectionReturnResult.SetResponse(returnResult, request, m_ResponseData);
                // WARNING: At this point, we could throw on the line above
            }
            else {
                ConnectionReturnResult.Add(ref returnResult, request, m_ResponseData);
            }
            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::NotifyRequestOfResponse");
        }



        /*++

            NotifyRequestOfError

            Queues up a request to be notified later on that we have a response
            this is needed since calling the request at this point could be dangerous
            due to it faulting, recalling Connection methods, etc.

            NOTE: This is only called today on Parsing errors, to handle the case,
            where the request dequeued, but then an error is discovered before the error
            can be transfered to HandleError handling

        --*/

        private void NotifyRequestOfError(HttpWebRequest request, ref ConnectionReturnResult returnResult) {

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::NotifyRequestOfError() Request:" + ValidationHelper.HashString(request));

            ConnectionReturnResult.AddException(
                ref returnResult,
                request,
                new WebException(
                            NetRes.GetWebStatusString("net_connclosed", WebExceptionStatus.ServerProtocolViolation),
                            null,
                            WebExceptionStatus.ServerProtocolViolation,
                            null /* no response */ ));
        }




        /*++

            UpdateSelectedClientCertificate

            Called to fix up our Client Certificate on our ServicePoint. This is
            mainly used as a debugging tool for the App Writer, so that he can
            confirm what certificate is getting sent to the server.

        --*/

        private void UpdateSelectedClientCertificate(HttpWebRequest request) {
            if (request.ClientCertificates.Count > 0 ) {
                TlsStream tlsStream = Transport as TlsStream;
                if (tlsStream != null) {
                    try {
                        m_Server.InternalClientCertificate = tlsStream.ClientCertificate;
                    }
                    catch (Exception exception) {
                        GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::UpdateSelectedClientCertificate() caught:" + exception.Message);
                    }
                }
            }
        }

        /*++

            UpdateContentLength

            Called to fix up content length.  This handles special
            cases where a Response is returned without a response body.

        --*/
        private void UpdateContentLength(HttpWebRequest request) {

            //
            // for HEAD requests, we cannot read any data
            //  remove Contentlength from stream in that case
            //

            // from HTTP/1.1 spec :
            //
            // Any response message which "MUST NOT" include a message-body (such
            //  as the 1xx, 204, and 304 responses and any response to a HEAD
            //  request) is always terminated by the first empty line after the
            //  header fields, regardless of the entity-header fields present in
            //  the message.


            if (!request.CanGetResponseStream ||
                m_ResponseData.m_StatusCode < HttpStatusCode.OK ||
                m_ResponseData.m_StatusCode == HttpStatusCode.NoContent ||
                m_ResponseData.m_StatusCode == HttpStatusCode.NotModified ) {
                //
                // set Response stream content-length to 0 for non-Response responses
                //
                m_ResponseData.m_ConnectStream.StreamContentLength = 0;
                //
                // for Http/1.0 servers, we can't be sure what their behavior
                //  in this case, so the best thing is to disable KeepAlive
                //
                if (m_Version.Equals(HttpVersion.Version10)) {
                    m_KeepAlive = false;
                }
            }
        }


        /*++

            ProcessHeaderData - Pulls out Content-length, and other critical
                data from the newly parsed headers

            Input:

                Nothing.

            Returns:

                long - size of contentLength that we are to use

        --*/
        private long ProcessHeaderData( ref bool fHaveChunked ) {

            long contentLength;

            fHaveChunked = false;

            //
            // First, get "content-length" for data size, we'll need to handle
            //  chunked here later.
            //

            string Content = m_ResponseData.m_ResponseHeaders[ HttpKnownHeaderNames.ContentLength ];

            contentLength = -1;

            if (Content != null) {

                //
                // Attempt to parse the Content-Length integer,
                //   in some very rare cases, a proxy server may
                //   send us a pair of numbers in comma delimated
                //   fashion, so we need to handle this case, by
                //   catching an exception thrown by the normal code.
                //   Why so complicated?  Cause we need to optimize for
                //   the normal code path.
                //

                try
                {
                    contentLength = Int64.Parse(Content.Substring(Content.IndexOf(':')+1));
                }
                catch
                {
                    try
                    {
                        string contentLengthString = Content.Substring(Content.IndexOf(':')+1);

                        // in the case, where we could get 2 Content-Length's parse out only one
                        int index = contentLengthString.LastIndexOf(',')+1;

                        if (index != -1 ) {
                            contentLengthString = contentLengthString.Substring(index);
                        }

                        contentLength = Int64.Parse(contentLengthString);
                    }
                    catch
                    {
                    }
                }
            }

            // ** else ** signal no content-length present??? or error out?
            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::ProcessHeaderData() Content-Length parsed: " + contentLength.ToString());

            //
            // Check for "transfer-encoding,"  then check for "chunked"
            //

            string transfer = m_ResponseData.m_ResponseHeaders["Transfer-Encoding"];

            if (transfer != null) {
                transfer = transfer.ToLower(CultureInfo.InvariantCulture);
                if (transfer.IndexOf("chunked") != -1) {
                    fHaveChunked = true;
                    contentLength = -1; // signal that we need chunked
                }
            }

            if (m_KeepAlive) {

                string connection = m_ResponseData.m_ResponseHeaders[ HttpKnownHeaderNames.Connection ];
                bool haveClose = false;
                bool haveKeepAlive = false;

                if (connection == null && m_Server.InternalProxyServicePoint) {
                    connection = m_ResponseData.m_ResponseHeaders[ HttpKnownHeaderNames.ProxyConnection ];
                }

                if (connection != null) {
                    connection = connection.ToLower(CultureInfo.InvariantCulture);
                    if (connection.IndexOf("keep-alive") != -1) {
                        haveKeepAlive = true;
                    }
                    else if (connection.IndexOf("close") != -1) {
                        haveClose = true;
                    }
                }
                if ((haveClose && m_Version.Equals( HttpVersion.Version11 )) ||
                    (!haveKeepAlive && m_Version.Equals( HttpVersion.Version10 ))) {
                    lock (this) {
                        m_KeepAlive = false;
                        m_Free = false;
                    }
                }

                // if no content-length and no chunked, then turn off keep-alive
                if (contentLength == -1 && ! fHaveChunked) {
                    lock (this) {
                        m_KeepAlive = false;
                    }
                }
            }

            return contentLength;
        }

        /*++

            CopyOutStreamData

            Copies Stream Data out of buffer and cleans up buffer for continued
            reading, also creates the stream

                Returns: true if the connection is closed or closing, false otherwise.

        --*/
        private bool CopyOutStreamData(
            HttpWebRequest Request,
            int BytesScanned,
            int LengthToCopy,
            long ContentLength,
            bool Chunked,
            ref ConnectionReturnResult returnResult
            )
        {
            GlobalLog.Enter("CopyOutStreamData", "Request=#"+ValidationHelper.HashString(Request)+", BytesScanned="+BytesScanned+", LengthToCopy="+LengthToCopy+", ContentLength="+ContentLength+", Chunked="+Chunked);

            // copy data off to other buffer for stream to use
            byte[] tempBuffer = new byte[LengthToCopy];

            // make copy of data for stream to use
            Buffer.BlockCopy(
                m_ReadBuffer,      // src
                BytesScanned,      // src index
                tempBuffer,        // dest
                0,                 // dest index
                LengthToCopy );    // total size to copy

            // create new stream with copied data
            m_ResponseData.m_ConnectStream =
                new ConnectStream(
                    this,
                    tempBuffer,
                    0,               // index
                    LengthToCopy,    // buffer Size
                    ContentLength,
                    Chunked,
                    false           // don't need a read done call
#if DEBUG
                    ,Request
#endif
                    );

            // set Response Struc.
            m_ResponseData.m_ContentLength = ContentLength;

            GlobalLog.Assert(
                Request != null,
                "Connection#" + ValidationHelper.HashString(this) + "::CopyOutStreamData(): Request == null",
                "");

            // WARNING: This function may throw
            NotifyRequestOfResponse(Request, ref returnResult, false);

            bool closing = ReadStartNextRequest(false, ref returnResult);

            GlobalLog.Leave("CopyOutStreamData", closing);
            return closing;
        } // CopyOutStreamData

        /*++

            ParseStreamData

            Handles parsing of the blocks of data received after buffer,
             distributes the data to stream constructors as needed

            returnResult - contains a object containing Requests
                that must be notified upon return from callback

        --*/
        private DataParseStatus ParseStreamData(ref ConnectionReturnResult returnResult) {
            GlobalLog.Enter("ParseStreamData");

            bool fHaveChunked = false;

            // content-length if there is one
            long ContentLength = ProcessHeaderData(ref fHaveChunked);

            // bytes left over that have not been parsed
            int BufferLeft = (m_BytesRead - m_BytesScanned);

            HttpWebRequest Request;

            // dequeue Request from WriteList
            lock(this) {

                if ( m_WriteList.Count == 0 ) {
                    GlobalLog.Leave("ParseStreamData");
                    return DataParseStatus.Invalid;
                }

                Request = (HttpWebRequest)m_WriteList[0];
                RemoveAtAndUpdateServicePoint(m_WriteList, 0);
            }

            if ((int)m_ResponseData.m_StatusCode > (int)HttpStatusRange.MaxOkStatus) {
                // This will tell the request to be prepared for possible connection drop
                // Also that will stop writing on the wire if the connection is not kept alive
                Request.ErrorStatusCodeNotify(this, m_KeepAlive);
            }

            //
            //  Need to handle left over data to pass
            //  to next Stream.
            //

            if (m_CanPipeline) {

                int BytesToCopy;

                //
                // If pipeling, then look for extra data that could
                //  be part of of another stream, if its there,
                //  then we need to copy it, add it to a stream,
                //  and then continue with the next headers
                //

                if (!fHaveChunked) {
                    if (ContentLength > (long)Int32.MaxValue) {
                        BytesToCopy = -1;
                    }
                    else {
                        BytesToCopy = (int)ContentLength;
                    }
                }
                else {
                    BytesToCopy = FindChunkEntitySize(m_ReadBuffer,
                                                      m_BytesScanned,
                                                      BufferLeft);

                    if (BytesToCopy == 0) {
                        // If we get a 0 back, we had some sort of error in
                        // parsing the chunk.

                        NotifyRequestOfError(Request, ref returnResult);
                        GlobalLog.Leave("ParseStreamData");
                        return DataParseStatus.Invalid;
                    }
                }

                GlobalLog.Print("ParseStreamData: BytesToCopy="+BytesToCopy+", BufferLeft="+BufferLeft);

                if (BytesToCopy != -1 && BytesToCopy <= BufferLeft) {

                    int BytesScanned = m_BytesScanned;

                    //
                    // Copies Stream Data, and Creates a Stream
                    //

                    m_BytesScanned += BytesToCopy;

                    NetworkStream chkTransport = Transport;

                    bool ConnClosing =
                        CopyOutStreamData(
                           Request,
                           BytesScanned,
                           BytesToCopy,
                           ContentLength,
                           fHaveChunked,
                           ref returnResult
                           );

                    if (ConnClosing || (chkTransport != Transport)) {
                        GlobalLog.Leave("ParseStreamData");
                        return DataParseStatus.Done;
                    }

                    // keep parsing if we have more data
                    if (BytesToCopy != BufferLeft) {
                        GlobalLog.Leave("ParseStreamData");
                        return DataParseStatus.ContinueParsing;
                    }
                    GlobalLog.Leave("ParseStreamData");
                    return DataParseStatus.NeedMoreData; // more reading

                }
            }

            // - fall through or if not Pipe Lined!

            //
            // This is the default case where we have a buffer,
            //   with no more streams except the last one to create
            //   so we create it, and away for the stream to be read
            //   before we get to our next set of headers and possible
            //   new stream
            //

            m_ResponseData.m_ConnectStream =
                new ConnectStream(
                    this,
                    m_ReadBuffer,
                    m_BytesScanned,               // index
                    m_BytesRead - m_BytesScanned, // int bufferCount
                    ContentLength,
                    fHaveChunked,
                    true                          // is this always true here - perhaps not in nonP-L case?
#if DEBUG
                    ,Request
#endif
                    );

            m_ResponseData.m_ContentLength = ContentLength;

            // clear vars
            m_BytesRead    = 0;
            m_BytesScanned = 0;

            // WARNING: This function may throw
            NotifyRequestOfResponse(Request, ref returnResult, true);

            GlobalLog.Leave("ParseStreamData");
            return DataParseStatus.Done; // stop reading
        }

        /*++

            ParseResponseData - Parses the incomming headers, and handles
              creation of new streams that are found while parsing, and passes
              extra data the new streams

            Input:

                returnResult - returns an object containing items that need to be called
                    at the end of the read callback

            Returns:

                bool - true if one should continue reading more data

        --*/
        private DataParseStatus ParseResponseData(ref ConnectionReturnResult returnResult) {

            DataParseStatus parseStatus = DataParseStatus.NeedMoreData;
            DataParseStatus parseSubStatus;

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData()");

            // loop in case of multiple sets of headers or streams,
            //  that may be generated due to a pipelined response

            do {

                // Invariants: at the start of this loop, m_BytesRead
                // is the number of bytes in the buffer, and m_BytesScanned
                // is how many bytes of the buffer we've consumed so far.
                // and the m_ReadState var will be updated at end of
                // each code path, call to this function to reflect,
                // the state, or error condition of the parsing of data
                //
                // We use the following variables in the code below:
                //
                //  m_ReadState - tracks the current state of our Parsing in a
                //      response. z.B.
                //      Start - initial start state and begining of response
                //      StatusLine - the first line sent in response, include status code
                //      Headers - \r\n delimiated Header parsing until we find entity body
                //      Data - Entity Body parsing, if we have all data, we create stream directly
                //
                //  m_ResponseData - An object used to gather Stream, Headers, and other
                //      tidbits so that a Request/Response can receive this data when
                //      this code is finished processing
                //
                //  m_ReadBuffer - Of course the buffer of data we are parsing from
                //
                //  m_CurrentRequestIndex - index into the window of a buffer where
                //      we are currently parsing.  Since there can be multiple requests
                //      this index is used to the track the offset, based off of 0
                //
                //  m_BytesScanned - The bytes scanned in this buffer so far,
                //      since its always assumed that parse to completion, this
                //      var becomes ended of known data at the end of this function,
                //      based off of 0
                //
                //  m_BytesRead - The total bytes read in buffer, should be const,
                //      till its updated at end of function.
                //
                //  m_HeadersBytesUnparsed - The bytes scanned in the headers,
                //      needs to be seperate because headers are not always completely
                //      parsed to completion on each interation
                //

                //
                // Now attempt to parse the data,
                //   we first parse status line,
                //   then read headers,
                //   and finally transfer results to a new stream, and tell request
                //

                switch (m_ReadState) {

                    case ReadState.Start:
                        m_ResponseData = new CoreResponseData();
                        m_ReadState = ReadState.StatusLine;
                        m_CurrentRequestIndex = m_BytesScanned;
                        m_TotalResponseHeadersLength = 0;
                        try {
                            GlobalLog.Assert(m_WriteList.Count > 0, "Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() (1) m_WriteList.Count <= 0", "");
                            m_MaximumResponseHeadersLength = ((HttpWebRequest)m_WriteList[0]).MaximumResponseHeadersLength * 1024;
                        }
                        catch {
                            parseStatus = DataParseStatus.Invalid;
                            m_ReadState = ReadState.Start;
                            break;
                        }
                        InitializeParseStatueLine();
                        goto case ReadState.StatusLine;

                    case ReadState.StatusLine:
                        //
                        // Reads HTTP status response line
                        //
                        parseSubStatus =
                            ParseStatusLine(
                                m_ReadBuffer, // buffer we're working with
                                m_BytesRead,  // total bytes read so far
                                ref m_BytesScanned, // index off of what we've scanned
                                ref m_StatusLineInts,
                                ref m_StatusDescription,
                                ref m_StatusState );

                        if (parseSubStatus == DataParseStatus.Invalid || parseSubStatus == DataParseStatus.DataTooBig) {
                            //
                            // report error
                            //
                            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() ParseStatusLine() parseSubStatus:" + parseSubStatus.ToString());
                            parseStatus = parseSubStatus;

                            // advance back to state 0, in failure
                            m_ReadState = ReadState.Start;
                            break;
                        }
                        else if (parseSubStatus == DataParseStatus.Done) {
                            SetStatusLineParsed();
                            m_ReadState = ReadState.Headers;
                            m_HeadersBytesUnparsed = m_BytesScanned;
                            m_ResponseData.m_ResponseHeaders = new WebHeaderCollection(true);

                            goto case ReadState.Headers;
                        }
                        else if (parseSubStatus == DataParseStatus.NeedMoreData) {
                            m_HeadersBytesUnparsed = m_BytesScanned;
                        }

                        break; // read more data

                    case ReadState.Headers:
                        //
                        // Parse additional lines of header-name: value pairs
                        //
                        if (m_HeadersBytesUnparsed>=m_BytesRead) {
                            //
                            // we already can tell we need more data
                            //
                            break;
                        }

                        parseSubStatus =
                            m_ResponseData.m_ResponseHeaders.ParseHeaders(
                                m_ReadBuffer,
                                m_BytesRead,
                                ref m_HeadersBytesUnparsed,
                                ref m_TotalResponseHeadersLength,
                                m_MaximumResponseHeadersLength );

                        if (parseSubStatus == DataParseStatus.Invalid || parseSubStatus == DataParseStatus.DataTooBig) {
                            //
                            // report error
                            //
                            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() ParseHeaders() parseSubStatus:" + parseSubStatus.ToString());
                            parseStatus = parseSubStatus;

                            // advance back to state 0, in failure
                            m_ReadState = ReadState.Start;

                            break;
                        }
                        else if (parseSubStatus == DataParseStatus.Done) {

                            m_BytesScanned = m_HeadersBytesUnparsed; // update actual size of scanned headers

                            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() got (" + ((int)m_ResponseData.m_StatusCode).ToString() + ") from the server");

                            // If we have an HTTP continue, eat these headers and look
                            //  for the 200 OK
                            if (m_ResponseData.m_StatusCode == HttpStatusCode.Continue) {

                                // wakeup post code if needed
                                HttpWebRequest Request;
                                try {
                                    GlobalLog.Assert(m_WriteList.Count > 0, "Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() (2) m_WriteList.Count <= 0", "");
                                    Request = (HttpWebRequest)m_WriteList[0];
                                }
                                catch {
                                    parseStatus = DataParseStatus.Invalid;
                                    m_ReadState = ReadState.Start;
                                    break;
                                }

                                GlobalLog.Assert(
                                    Request != null,
                                    "Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData(): Request == null",
                                    "");

                                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() HttpWebRequest#" + ValidationHelper.HashString(Request));

                                //
                                // we got a 100 Continue. set this on the HttpWebRequest
                                //
                                Request.Saw100Continue = true;
                                if (!m_Server.Understands100Continue) {
                                    //
                                    // and start expecting it again if this behaviour was turned off
                                    //
                                    GlobalLog.Leave("HttpWebRequest#" + ValidationHelper.HashString(Request) + " ServicePoint#" + ValidationHelper.HashString(m_Server) + " sent UNexpected 100 Continue");
                                    m_Server.Understands100Continue = true;
                                }

                                //
                                // set Continue Ack on Request.
                                //
                                if (Request.ContinueDelegate != null) {
                                    //
                                    // invoke the 100 continue delegate if the user supplied one
                                    //
                                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() calling ContinueDelegate()");
                                    Request.ContinueDelegate((int)m_ResponseData.m_StatusCode, m_ResponseData.m_ResponseHeaders);
                                }

                                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() calling SetRequestContinue()");
                                Request.SetRequestContinue();
                                m_ReadState = ReadState.Start;

                                goto case ReadState.Start;
                            }

                            m_ReadState = ReadState.Data;
                            goto case ReadState.Data;
                        }

                        // need more data,
                        //
                        // But unfornately ParseHeaders does not work,
                        //   the same way as all other code in this function,
                        //   since its old code, it assumes BytesScanned bytes will be always
                        //   around between calls until it has all the data, but that is NOT
                        //   true, since we can do block copy between calls.
                        //
                        //  To handle this we fix up the offsets.

                        // We assume we scanned all the way to the end of valid buffer data
                        m_BytesScanned = m_BytesRead;

                        break;

                    case ReadState.Data:

                        // (check status code for continue handling)
                        // 1. Figure out if its Chunked, content-length, or encoded
                        // 2. Takes extra data, place in stream(s)
                        // 3. Wake up blocked stream requests
                        //

                        // advance back to state 0
                        m_ReadState = ReadState.Start;

                        // parse and create a stream if needed
                        DataParseStatus result = ParseStreamData(ref returnResult);

                        GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData() result - " + result.ToString());

                        switch (result) {

                            case DataParseStatus.NeedMoreData:
                                //
                                // cont reading. Only way we can get here is if the request consumed
                                // all the bytes in the buffer. So reset everything.
                                //
                                m_BytesRead = 0;
                                m_BytesScanned = 0;
                                m_CurrentRequestIndex = 0;

                                parseStatus = DataParseStatus.NeedMoreData;
                                break;

                            case DataParseStatus.ContinueParsing:

                                continue;

                            case DataParseStatus.Invalid:
                            case DataParseStatus.Done:

                                //
                                // NOTE: WARNING: READ THIS:
                                //  Upon update of this code, keep in mind,
                                //  that when DataParseStatus.Done is returned
                                //  from ParseStreamData, it can mean that ReadStartNextRequest()
                                //  has been called.  That means that we should no longer
                                //  change ALL this.m_* vars, since those variables, can now
                                //  be used on other threads.
                                //


                                // DataParseStatus.Done will cause an error below

                                parseStatus = result;
                                break;
                        }
                        break;
                }

                break;

            } while (true);

            GlobalLog.Print("m_ReadState - " + m_ReadState.ToString());
            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ParseResponseData()", parseStatus.ToString());
            return parseStatus;
        }

        /// <devdoc>
        ///    <para>
        ///       Cause the Connection to Close and Abort its socket,
        ///         after the next request is completed.  If the Connection
        ///         is already idle, then Aborts the socket immediately.
        ///    </para>
        /// </devdoc>
        internal void CloseOnIdle() {
            m_KeepAlive = false;
            CheckIdle();
            if (m_Idle) {
                Abort(false);
            }
        }

        /*++

            Abort - closes the socket and aborts the Connection

                this is needed by the stream to quickly dispatch
                this connection faster, than having to completely drain
                the whole socket

                Or this is also used to Abort the socket, when the
                ConnectionStream is prematurely closed.

                This works by closing the Socket from underneath
                the Connection, which then causes all Socket calls
                to error out.  Once they error, they enter Error handling
                code which realizes that we're doing an Abort, and errors
                appropriately.

            Input:

                Nothing.

            Returns:

                Nothing.

        --*/
        internal void Abort() {
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::Abort", m_Abort.ToString());
            // This is not about a race condition. 
            // Rather many guys can come here one after the other.
            if (!m_Abort) {
                Abort(true);
            }
            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::Abort()");
        }

        internal void Abort(bool isAbortState)
        {
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::Abort(State)", "abortState = " + isAbortState.ToString());            
            
            if (isAbortState) {
                m_Abort = true;
                UnlockRequest();
            }

            Socket socket = m_AbortSocket;
            if (socket != null) {
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::Abort() closing abortSocket:" + ValidationHelper.HashString(socket));
                socket.Close();
            }
            //
            // Abort the IPv6 Socket as well
            //
            socket = m_AbortSocket6;
            if (socket != null) {
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::Abort() closing abortSocket:" + ValidationHelper.HashString(socket));
                socket.Close();
            }

            NetworkStream chkTransport = Transport;
            if (chkTransport != null) {
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::Abort() closing transport:" + ValidationHelper.HashString(chkTransport));
                chkTransport.Close();
             }
             //m_Transport = null;

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::Abort(State)");
        }


        /*++

            CloseConnectionSocket - close the socket.

            This method is called when we want to close the conection.
            It must be called with the critical section held.

            The key thing about this method is that it's only called
            when we know that we don't have an async read pending with
            the socket, either because we're being called from the read
            callback or we're called after an error from a user read (the
            user read couldn't have happened if we have a read down).
            Because of this it's OK for us to null out the socket and
            let the next caller try to autoreconnect. This makes life
            simpler, all connection closes (either ours or server
            initiated) eventually go through here. This is also the
            only place that can null out the socket - if that happens somewhere
            else, we get into a race condition where an autoreconnect can happen
            while we still have a receive buffer down, which could result in
            two buffers at once.

            As to what we do: we loop through our write list and pull requests
            off it, and give each request an error failure. Then we close the
            socket and null out our reference, and go ahead and let the next
            request go.

            Input:

                status      - WebExceptionStatus indicating the reason that this method
                                was called. This may be WebExceptionStatus.Success,
                                indicating a normal shutdown.

            Returns:

                Nothing.

        --*/
        private void CloseConnectionSocket(WebExceptionStatus status, ref ConnectionReturnResult returnResult) {

            HttpWebRequest[] ReqArray = null;
            HttpWebRequest NextRequest;
            Exception innerException = null;
            bool Retry = true;

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::CloseConnectionSocket", status.ToString());
            GlobalLog.Print("_WriteList Clear() + (size) " + m_WriteList.Count.ToString() + " - cnt#" + ValidationHelper.HashString(this));

            // gets set to null below
            NetworkStream chkTransport = Transport;

            // gets our Schannel W32 generated Exception, so we know why it really failed
            if ((status == WebExceptionStatus.SecureChannelFailure ||
                 status == WebExceptionStatus.TrustFailure) &&
                  chkTransport is TlsStream )
            {
                // assumption is if this error is Set we have TlsStream
                TlsStream tlsStream = (TlsStream) chkTransport;
                innerException = tlsStream.InnerException;
                Retry = false;
            } else {
                innerException = UnderlyingException;
                UnderlyingException = null;
            }

            // in the case of abort, disable retry
            if (m_Abort) {
                Retry = false;
                status = WebExceptionStatus.RequestCanceled;
                // remove abort
                m_Abort = false; // reset
            }

            DebugDumpArrayListEntries(m_WriteList);

            if ( m_WriteList.Count == 0 ) {
                Retry = false;
                m_Transport = null;
            }
            else {
                ReqArray = new HttpWebRequest[m_WriteList.Count];
                m_WriteList.CopyTo(ReqArray, 0);
                m_WriteList.Clear();
                m_Transport = null;
            }

            
            //
            // (assumes under crit sec)
            // Copy WriteList off
            // Clear WriteList
            // Search CopiedWriteList for any bad entries and leaves
            //  (this list will get walked through and scanvanged with SetResponse(error))
            // If all are Good Entries to allow for retry and then adds them to beginning of WaitList
            // then clears any error code in m_Error
            //

            if (Retry) {
                foreach (HttpWebRequest Request in ReqArray) {
                    if (!Request.OnceFailed && !(Request.RequireBody && Request.HaveWritten)) {
                        // disable pipeline/mark failure for next time
                        Request.InternalPipelined = false;
                        Request.OnceFailed = true;
                    }
                    else {
                        Retry = false;
                    }
                }

                // if there is something to retry, then readd it to get sent
                //  again on the wait list
                if (Retry && ReqArray.Length > 0) {
                    m_Error = WebExceptionStatus.Success;
                    m_ReadState = ReadState.Start; // FIXFIX
                    m_WaitList.InsertRange(0, ReqArray);

                    CheckNonIdle();

                    ReqArray = null;
                }
                else {
                    Retry = false;
                }
            }

            if (Retry) {
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::CloseConnectionSocket() retrying requests");
            } else {
                //
                // Don't disable this connection as a locked request for 
                //   NTLM authentication, only release the lock when 
                //   the request itself has established an error
                //

                if (LockedRequest != null && status != WebExceptionStatus.Success) {
                    HttpWebRequest lockedRequest = LockedRequest;
                    bool callUnlockRequest = false; 
                    GlobalLog.Print("Looking For Req#" + ValidationHelper.HashString(lockedRequest));
                    if (ReqArray != null) {
                        foreach (HttpWebRequest request in ReqArray) {
                            if (request == lockedRequest) {
                                callUnlockRequest = true;
                                break;
                            }
                        }
                    }

                    if (callUnlockRequest) {
                        UnlockRequest();
                    }
                }
            }


            NextRequest = CheckNextRequest();

            if (NextRequest == null) {
                // If we don't have another request, then mark the connection
                // as free now. In general, the connection gets marked as
                // busy once we stop doing keep alive on it.

                m_Free = true;
            }

            if (NextRequest != null) {
                m_Free = false;
                StartRequest(NextRequest);
            }
            else {
                Monitor.Exit(this);
            }

            if (chkTransport != null) {
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::CloseConnectionSocket() closing transport:" + ValidationHelper.HashString(chkTransport));
                chkTransport.Close();
            }

            //
            // On Error from connection,
            //  walk through failed entries and set failure
            //

            if (ReqArray != null) {
                if (status == WebExceptionStatus.Success) {
                    status = WebExceptionStatus.ConnectionClosed;
                }

                ConnectionReturnResult.AddExceptionRange(
                    ref returnResult,
                    ReqArray,
                    new WebException(
                            NetRes.GetWebStatusString("net_connclosed", status),
                            innerException,
                            status,
                            null /* no response */ ));
            }

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::CloseConnectionSocket");
        }

        /*++

            HandleError - Handle a protocol error from the server.

            This method is called when we've detected some sort of fatal protocol
            violation while parsing a response, receiving data from the server,
            or failing to connect to the server. We'll fabricate
            a WebException and then call CloseConnection which closes the
            connection as well as informs the Request through a callback.

            Input:
                    webExceptionStatus -
                    connectFailure -
                    readFailure -

            Returns: Nothing

        --*/
        private void HandleError(WebExceptionStatus webExceptionStatus, ConnectionFailureGroup failureGroup, ref ConnectionReturnResult returnResult) {

            Monitor.Enter(this);

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::HandleError() writeListcount: " + m_WriteList.Count.ToString() + " m_WriteDone:" + m_WriteDone.ToString() + " failureGroup:" + failureGroup.ToString());

            if (failureGroup != ConnectionFailureGroup.Receive) {
                if ((m_WriteList.Count!=0) && (failureGroup != ConnectionFailureGroup.Connect)) {
                    HttpWebRequest Request = (HttpWebRequest)m_WriteList[0];
                    Request.OnceFailed = true;
                    GlobalLog.Print("Request = " + ValidationHelper.HashString(Request));
                }
                else {
                    // if there are no WriteList requests, then we can
                    //  assume that WriteDone is true, this is usually
                    //  caused by servers send illegal data (e.g. bad contentlengths),

                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::HandleError() setting m_WriteDone:" + m_WriteDone.ToString() + " to true");
                    m_WriteDone = true;
                }
            }

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::HandleError() m_WriteDone:" + m_WriteDone.ToString());

            m_ResponseData = null;
            //m_ReadState = ReadState.Start;
            m_ReadDone = true;
#if TRAVE
            GlobalLog.Print("*** ["+MyLocalPort+"] would set Tunnelling = false in HandleError on #"+GetHashCode());
#endif
            //Tunnelling = false;
            m_Error = webExceptionStatus;

            // It's possible that we could have a write in progress, and we
            // don't want to close the connection underneath him. Since thisConnection
            // is a completion of our read buffer, it's safe for us to
            // set thisConnection.m_ReadDone to true. So if there's not a write in
            // progress, close the connection. If there a write in progress,
            // wait for the write to complete before closing the socket.

            if (m_WriteDone) {
                CloseConnectionSocket(m_Error, ref returnResult);
            }
            else {
                Monitor.Exit(this);
            }
        }




        /*++

            ReadCallback - Performs read callback processing on connection
                handles getting headers parsed and streams created

            Input:

                Nothing.

            Returns:

                Nothing

        --*/
        private static void ReadCallback(IAsyncResult asyncResult) {
            //
            // parameter validation
            //
            GlobalLog.Assert(
                asyncResult != null,
                "asyncResult == null",
                "Connection::ReadCallback null asyncResult" );

            GlobalLog.Assert(
                (asyncResult is OverlappedAsyncResult || asyncResult is LazyAsyncResult),
                "asyncResult is not OverlappedAsyncResult",
                "Connection::ReadCallback bad asyncResult" );

            Connection thisConnection = asyncResult.AsyncState as Connection;

            GlobalLog.Assert(
                thisConnection != null,
                "thisConnection == null",
                "Connection::ReadCallback null thisConnection" );

            Exception unhandledException = null;
            ConnectionReturnResult returnResult = null;

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback", ValidationHelper.HashString(asyncResult) + ", " + ValidationHelper.HashString(thisConnection));

            try {
                NetworkStream chkTransport = thisConnection.Transport;

                if (chkTransport == null) {
                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() chkTransport == null");
                    goto done;
                }

                int bytesTransferred = -1;

                WebExceptionStatus errorStatus = WebExceptionStatus.ReceiveFailure;

                    try {
                        bytesTransferred = chkTransport.EndRead(asyncResult);
                    }
                catch (Exception) {

                    // need to handle SSL errors too
                    if ( chkTransport is TlsStream )  {
                        errorStatus = WebExceptionStatus.SecureChannelFailure;
                    }
                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() EndRead() threw errorStatus:" + errorStatus.ToString() + " bytesTransferred:" + bytesTransferred.ToString());
                }

                // we're in the callback
                thisConnection.m_ReadCallbackEvent.Reset();

                if (bytesTransferred <= 0) {
                    thisConnection.HandleError(errorStatus, ConnectionFailureGroup.Receive, ref returnResult);
                    thisConnection.m_ReadCallbackEvent.Set();
                    goto done;
                }

                // Otherwise, we've got data.
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() m_BytesRead:" + thisConnection.m_BytesRead.ToString() + "(+= bytesTransferred:" + bytesTransferred.ToString() + ")");
                GlobalLog.Dump(thisConnection.m_ReadBuffer, thisConnection.m_BytesScanned, bytesTransferred);
                thisConnection.m_BytesRead += bytesTransferred;

                // We have the parsing code seperated out in ParseResponseData
                //
                // If we don't have all the headers yet. Resubmit the receive,
                // passing in the bytes read total as our index. When we get
                // back here we'll end up reparsing from the beginning, which is
                // OK. because this shouldn't be a performance case.

                DataParseStatus parseStatus = thisConnection.ParseResponseData(ref returnResult);

                if (parseStatus == DataParseStatus.Invalid || parseStatus == DataParseStatus.DataTooBig) {
                    //
                    // report error
                    //
                    if (parseStatus == DataParseStatus.Invalid) {
                        thisConnection.HandleError(WebExceptionStatus.ServerProtocolViolation, ConnectionFailureGroup.Parsing, ref returnResult);
                    }
                    else {
                        thisConnection.HandleError(WebExceptionStatus.MessageLengthLimitExceeded, ConnectionFailureGroup.Parsing, ref returnResult);
                    }
                    thisConnection.m_ReadCallbackEvent.Set();

                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() parseStatus:" + parseStatus.ToString());
                    goto done;
                }

                if (parseStatus == DataParseStatus.Done) {
                    //
                    // we need to grow the buffer, move the unparsed data to the beginning of the buffer before reading more data.
                    //
                    thisConnection.m_ReadCallbackEvent.Set();

                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() parseStatus == DataParseStatus.Done");
                    goto done;
                }

                //
                // we may reach the end of our buffer only when parsing headers.
                // this can happen when the header section is bigger than our initial 4k guess
                // which should be a good assumption in 99.9% of the cases. what we do here is:
                // 1) move unparsed data to the beginning of the buffer and read more data in the
                //    remaining part of the data.
                // 2) if there's a single BIG header (bigger than the current size) we will need to
                //    grow the buffer before we move data over and read more data.
                //
                if ((thisConnection.m_ReadState==ReadState.Headers || thisConnection.m_ReadState==ReadState.StatusLine)&& thisConnection.m_BytesRead==thisConnection.m_ReadBuffer.Length) {
                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() OLD buffer. m_ReadBuffer.Length:" + thisConnection.m_ReadBuffer.Length.ToString() + " m_BytesRead:" + thisConnection.m_BytesRead.ToString() + " m_BytesScanned:" + thisConnection.m_BytesScanned.ToString() + " m_HeadersBytesUnparsed:" + thisConnection.m_HeadersBytesUnparsed.ToString());
                    int unparsedDataSize = thisConnection.m_BytesRead-thisConnection.m_HeadersBytesUnparsed;
                    if (thisConnection.m_HeadersBytesUnparsed==0) {
                        //
                        // 2) we need to grow the buffer, move the unparsed data to the beginning of the buffer before reading more data.
                        // since the buffer size is 4k, should we just double
                        //
                        byte[] newReadBuffer = new byte[thisConnection.m_ReadBuffer.Length * 2 /*+ m_ReadBufferSize*/];
                        Buffer.BlockCopy(thisConnection.m_ReadBuffer, thisConnection.m_HeadersBytesUnparsed, newReadBuffer, 0, unparsedDataSize);
                        thisConnection.m_ReadBuffer = newReadBuffer;
                    }
                    else {
                        //
                        // just move data around in the same buffer.
                        //
                        Buffer.BlockCopy(thisConnection.m_ReadBuffer, thisConnection.m_HeadersBytesUnparsed, thisConnection.m_ReadBuffer, 0, unparsedDataSize);
                    }
                    //
                    // update indexes and offsets in the new buffer
                    //
                    thisConnection.m_BytesRead = unparsedDataSize;
                    thisConnection.m_BytesScanned = unparsedDataSize;
                    thisConnection.m_HeadersBytesUnparsed = 0;
                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() NEW buffer. m_ReadBuffer.Length:" + thisConnection.m_ReadBuffer.Length.ToString() + " m_BytesRead:" + thisConnection.m_BytesRead.ToString() + " m_BytesScanned:" + thisConnection.m_BytesScanned.ToString() + " m_HeadersBytesUnparsed:" + thisConnection.m_HeadersBytesUnparsed.ToString());
                }

                //
                // Don't need to queue this here, because we know we're on a thread
                // pool thread already.
                //
                thisConnection.m_ReadCallbackEvent.Set();

                if (chkTransport != thisConnection.Transport) {
                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() chkTransport != Transport");
                    goto done;
                }

                try  {
                    chkTransport.BeginRead(
                        thisConnection.m_ReadBuffer,
                        thisConnection.m_BytesScanned,
                        thisConnection.m_ReadBuffer.Length - thisConnection.m_BytesScanned,
                        m_ReadCallback,
                        thisConnection);

                }
                catch (Exception exception)  {
                    //
                    // don't report an error here! Since we made a call already,
                    //  this we cause an additional Callback to be generated,
                    //  and thus closing the Connection here by calling HandleError,
                    //  would just result in causing us to error twice.
                    //

                    GlobalLog.Print("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback() exception in BeginRead:" + exception.Message);
                    thisConnection.HandleError(errorStatus, ConnectionFailureGroup.Receive, ref returnResult);
                }
            }
            catch (Exception exception) {
                unhandledException = exception;
                thisConnection.HandleError(WebExceptionStatus.ConnectFailure, ConnectionFailureGroup.Connect, ref returnResult);
            }

done:
            ConnectionReturnResult.SetResponses(returnResult);
            if (unhandledException!=null) {
                throw new IOException(SR.GetString(SR.net_io_readfailure), unhandledException);
            }
            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(thisConnection) + "::ReadCallback");
        }

        /*++

            Write - write data either directly to network or to a defered buffer

            This method is called by a stream interface to write data to the
            network.  We figure out based on state, either to buffer or
            to forward the data on to write to the network.

            Input:

                buffer          - buffer to write.
                offset          - offset in buffer to write from.
                size           - size in bytes to write.


        --*/
        internal void Write(byte[] buffer, int offset, int size) {
            //
            // parameter validation
            //
            GlobalLog.Assert(
                buffer!=null,
                "buffer== null",
                "Connection.Write(byte[]) - failed internal parameter validation" );

            GlobalLog.Assert(
                buffer.Length>=size+offset,
                "buffer.Length<size+offset",
                "Connection.Write(byte[]) - failed internal parameter validation" );

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::Write(byte[]) cnt#" + ValidationHelper.HashString(this) + "trns#" + ValidationHelper.HashString(Transport));

#if TRAVE
            GlobalLog.Print("+++ ["+MyLocalPort+"] Connection: Writing data on #"+GetHashCode());
#endif

            NetworkStream chkTransport = Transport;

            try {
                GlobalLog.Dump(buffer, offset, size);
                if (chkTransport==null) {
                    throw new IOException(SR.GetString(SR.net_io_writefailure));
                }
                chkTransport.Write(buffer, offset, size);
            }
            catch (Exception exception) {
                m_Error = WebExceptionStatus.SendFailure;
                GlobalLog.LeaveException("Connection#" + ValidationHelper.HashString(this) + "::Write(byte[])", exception);
                throw;
            }

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::Write(byte[]) this:" + ValidationHelper.HashString(this) + " size:" + size.ToString());
        }

        //
        // this API is called by ConnectStream, only when resubmitting
        // so we sent the headers already in HttpWebRequest.EndSubmitRequest()
        // which calls ConnectStream.WriteHeaders()
        // only after it queues async call to HttpWebRequest.EndWriteHeaders()
        // which calls ConnectStream.ResubmitWrite()
        // which calls in here
        //
        internal void Write(ScatterGatherBuffers writeBuffer) {
            //
            // parameter validation
            //
            GlobalLog.Assert(
                writeBuffer!=null,
                "writeBuffer==null",
                "Connection.Write(ScatterGatherBuffers) - failed internal parameter validation" );

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::Write(ScatterGatherBuffers) cnt#" + ValidationHelper.HashString(this) + "trns#" + ValidationHelper.HashString(Transport));

#if TRAVE
            GlobalLog.Print("+++ ["+MyLocalPort+"] Connection: Writing data on #"+GetHashCode());
#endif

            NetworkStream chkTransport = Transport;
            if (chkTransport==null) {
                Exception exception = new IOException(SR.GetString(SR.net_io_writefailure));
                GlobalLog.LeaveException("Connection#" + ValidationHelper.HashString(this) + "::Write(ScatterGatherBuffers)", exception);
                throw exception;
            }

            try {
                //
                // set up array for MultipleWrite call
                // note that GetBuffers returns null if we never wrote to it.
                //
                BufferOffsetSize[] buffers = writeBuffer.GetBuffers();
                if (buffers!=null) {
                    //
                    // This will block writing the buffers out.
                    //
                    chkTransport.MultipleWrite(buffers);
                }
            }
            catch (Exception exception) {
                m_Error = WebExceptionStatus.SendFailure;
                GlobalLog.LeaveException("Connection#" + ValidationHelper.HashString(this) + "::Write(ScatterGatherBuffers)", exception);
                throw;
            }

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::Write(ScatterGatherBuffers) this:" + ValidationHelper.HashString(this) + " writeBuffer.Size:" + writeBuffer.Length.ToString());
        }


        /*++

            Read - Read data from the network.

            This method is called by a stream interface to read data from the
            network. We just call our socket to read the data. In the future,
            we might want to do some muxing or other stuff here.

            Input:

                buffer          - buffer to read into.
                offset          - offset in buffer to read into.
                size           - size in bytes to read.


        --*/
        internal int Read(byte[] buffer, int offset, int size) {
            //
            // parameter validation
            //
            GlobalLog.Assert(
                buffer!=null,
                "buffer== null",
                "Connection.Read(byte[]) - failed internal parameter validation" );

            GlobalLog.Assert(
                buffer.Length>=size+offset,
                "buffer.Length<size+offset",
                "Connection.Read(byte[]) - failed internal parameter validation" );

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::Read(byte[]) cnt#" + ValidationHelper.HashString(this) + "trns#" + ValidationHelper.HashString(Transport));

            int bytesTransferred = -1;

            NetworkStream chkTransport = Transport;

            try {
                if (chkTransport!=null) {
                    bytesTransferred = chkTransport.Read(buffer, offset, size);
                }
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                m_Error = WebExceptionStatus.ReceiveFailure;
                GlobalLog.LeaveException("Connection#" + ValidationHelper.HashString(this) + "::Read(byte[])", exception);
                throw;
            }

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::Read(byte[]) this:" + ValidationHelper.HashString(this) + " bytesTransferred:" + bytesTransferred.ToString());

            return bytesTransferred;
        }


        /*++

            BeginRead - Asyncronous Read data from the network

            This method is called by a stream interface to read data from the
            network. We just call our transport to read the data.

            In this case, we provide a simple wrapper to the async version
            of this function.  In the future we may want to do
            more here, or less, as we could just pass a stream through.

            Input:

                buffer          - buffer to read into.
                offset          - offset in buffer to read into.
                size           - size in bytes to read.
                callback        - delegate called on completion of async Read
                state           - private state that may wish to be kept through call


        --*/
        internal IAsyncResult BeginRead(
            byte[] buffer,
            int offset,
            int size,
            AsyncCallback callback,
            object state ) {

            NetworkStream chkTransport = Transport;

            if (chkTransport == null) {
                return null;
            }

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::BeginRead() cnt#" + ValidationHelper.HashString(this) + "trns#" + ValidationHelper.HashString(chkTransport));
            try {
                IAsyncResult asyncResult =
                    chkTransport.BeginRead(
                        buffer,
                        offset,
                        size,
                        callback,
                        state );

                return asyncResult;
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set m_Error and rethrow, since this is expected behaviour
                //
                m_Error = WebExceptionStatus.ReceiveFailure;
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::BeginRead() exception - " + exception.Message);
                throw;
            }
        }

        /*++

            EndRead - Asyncronous Read completion

            This method is called by a stream interface to complete
            the reading.  It handles this by retreiving result of the
            operation.

            Input:
                asyncResult     - Async Result given to us in BeginRead call


        --*/
        internal int EndRead(IAsyncResult asyncResult) {
            GlobalLog.Assert(
                asyncResult!=null,
                "asyncResult!=null",
                "Connection#" + ValidationHelper.HashString(this) + "::EndRead()" );

            NetworkStream chkTransport = Transport;
            if (chkTransport == null) {
                return -1;
            }

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::EndRead() cnt#" + ValidationHelper.HashString(this) + "trns#" + ValidationHelper.HashString(chkTransport));

            int bytesTransferred;

            try {
                bytesTransferred = chkTransport.EndRead(asyncResult);
            }
            catch (Exception exception) {
                m_Error = WebExceptionStatus.ReceiveFailure;
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::EndRead() exception - " + exception.Message);
                bytesTransferred = -1;
            }

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::EndRead() rtn = " + bytesTransferred.ToString() + "cnt#" + ValidationHelper.HashString(this));

            return bytesTransferred;
        }


        /*++

            BeginWrite - Asyncronous Write data to the network

            This method is called by a stream interface to write data to the
            network. We just call our transport to write the data.

            In this case, we provide a simple wrapper to the async version
            of this function.  In the future we may want to do
            more here, or less, as we could just pass a stream through.

            Input:

                buffer          - buffer to write from.
                offset          - offset in buffer to write from.
                size           - size in bytes to write.
                callback        - delegate called on completion of async Write
                state           - private state that may wish to be kept through call


        --*/
        internal IAsyncResult BeginWrite(
            byte[] buffer,
            int offset,
            int size,
            AsyncCallback callback,
            object state ) {

#if TRAVE
            GlobalLog.Print("+++ ["+MyLocalPort+"] Connection: Writing data on #"+GetHashCode());
#endif

            NetworkStream chkTransport = Transport;

            try {
                GlobalLog.Dump(buffer, offset, size);
                if (chkTransport==null) {
                    throw new IOException(SR.GetString(SR.net_io_writefailure));
                }
                IAsyncResult asyncResult =
                    chkTransport.BeginWrite(
                        buffer,
                        offset,
                        size,
                        callback,
                        state );

                return asyncResult;
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                m_Error = WebExceptionStatus.SendFailure;
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::BeginWrite() exception - " + exception.Message);
                throw;
            }
        }

        internal IAsyncResult BeginMultipleWrite(
            BufferOffsetSize[] buffers,
            AsyncCallback callback,
            Object state) {

#if TRAVE
            GlobalLog.Print("+++ ["+MyLocalPort+"] Connection: Writing data on #"+GetHashCode());
#endif

            NetworkStream chkTransport = Transport;

            try {
                if (chkTransport==null) {
                    throw new IOException(SR.GetString(SR.net_io_writefailure));
                }
                IAsyncResult asyncResult =
                    chkTransport.BeginMultipleWrite(
                        buffers,
                        callback,
                        state );

                return asyncResult;
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                m_Error = WebExceptionStatus.SendFailure;
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::BeginMultipleWrite() exception - " + exception.Message);
                throw;
            }
        }

        /*++

            EndWrite - Asyncronous Write completion

            This method is called by a stream interface to complete
            the writeing.  It handles this by retreiving result of the
            operation.

            Input:
                asyncResult     - Async Result given to us in BeginWrite call


        --*/
        internal void EndWrite(IAsyncResult asyncResult) {
            GlobalLog.Assert(
                asyncResult!=null,
                "asyncResult!=null",
                "Connection#" + ValidationHelper.HashString(this) + "::EndWrite()" );

            // refuse the write on bad transport
            NetworkStream chkTransport = Transport;
            if (chkTransport == null) {
                return;
            }

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::EndWrite() cnt#" + ValidationHelper.HashString(this) + "trns#" + ValidationHelper.HashString(chkTransport));

            try {
                chkTransport.EndWrite(asyncResult);
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                m_Error = WebExceptionStatus.SendFailure;
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::EndWrite() exception - " + exception.Message);
                throw;
            }
        }

        internal void EndMultipleWrite(IAsyncResult asyncResult) {
            GlobalLog.Assert(
                asyncResult!=null,
                "asyncResult!=null",
                "Connection#" + ValidationHelper.HashString(this) + "::EndMultipleWrite()" );

            // refuse the write on null transport
            NetworkStream chkTransport = Transport;
            if (chkTransport == null) {
                return;
            }

            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::EndMultipleWrite() cnt#" + ValidationHelper.HashString(this) + "trns#" + ValidationHelper.HashString(chkTransport));

            try {
                chkTransport.EndMultipleWrite(asyncResult);
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                m_Error = WebExceptionStatus.SendFailure;
                GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::EndMultipleWrite() exception - " + exception.Message);
                throw;
            }
        }


        /*++

            DataAvailable - See if there's data to be read.

            This is a function called by a client to see if data is available
            to be read. We just pass through to the underlying stream to see,
            as there is no read buffering in the connection object itself.

            Input:
                    Nothing.

            Returns:
                    True is there is data available to be read, false if not.
        --*/
        public bool DataAvailable {
            get {
                NetworkStream chkTransport = Transport;

                return chkTransport!=null && chkTransport.DataAvailable;
            }
        }

        /*++

            FindChunkEntitySize - Find the total size of a chunked entity body.

            An internal utility function. This is called when we have chunk encoded
            data in our internal receive buffer and want to know how big the total
            entity body is. We'll parse through it, looking for the terminating
            0CRLFCRLF string. We return -1 if we can't find it.

            Input:
                    buffer              - Buffer to be checked
                    offset              - Offset into buffer to start checking.
                    size               - Number of bytes to check.

            Returns:

                    The total size of the chunked entity body, or -1
                    if it can't find determine it. We'll return 0 if there's a
                    syntax error ensizeered.



        --*/
        private static int FindChunkEntitySize(byte[] buffer, int offset, int size) {
            BufferChunkBytes BufferStruct = new BufferChunkBytes();

            int EndOffset, StartOffset, BytesTaken, ChunkLength;
            StartOffset = offset;
            EndOffset = offset + size;
            BufferStruct.Buffer = buffer;

            //
            // While we haven't reached the end, loop through the buffer. Get
            // the chunk length, and if we can do that and it's not zero figure
            // out how many bytes are taken up by extensions and CRLF. If we
            // have enough for that, add the chunk length to our offset and see
            // if we've reached the end. If the chunk length is 0 at any point
            // we might have all the chunks. Skip the CRLF and footers and next
            // CRLF, and if that all works return the index where we are.
            //

            while (offset < EndOffset) {
                // Read the chunk size.

                BufferStruct.Offset = offset;
                BufferStruct.Count = size;

                BytesTaken = ChunkParse.GetChunkSize(BufferStruct, out ChunkLength);

                // See if we have enough data to read the chunk size.

                if (BytesTaken == -1) {
                    // Didn't,  so return -1.
                    return -1;
                }

                // Make sure we didn't have a syntax error in the parse.

                if (BytesTaken == 0) {
                    return 0;
                }

                // Update our state for what we've taken.

                offset += BytesTaken;
                size -= BytesTaken;

                // If the chunk length isn't 0, skip the extensions and CRLF.

                if (ChunkLength != 0) {
                    // Not zero, skip extensions.

                    BufferStruct.Offset = offset;
                    BufferStruct.Count = size;

                    BytesTaken = ChunkParse.SkipPastCRLF(BufferStruct);

                    // If we ran out of buffer doing it or had an error, return -1.

                    if (BytesTaken <= 0) {
                        return BytesTaken;
                    }

                    // Update our state for what we took.

                    offset += BytesTaken;
                    size -= BytesTaken;

                    // Now update our state for the chunk length and trailing CRLF.
                    offset += (ChunkLength + CRLFSize);
                    size -= (ChunkLength + CRLFSize);


                }
                else {
                    // The chunk length is 0. Skip the CRLF, then the footers.

                    if (size < CRLFSize) {
                        // Not enough left for CRLF

                        return -1;
                    }

                    offset += CRLFSize;
                    size -= CRLFSize;

                    // Skip the footers. We'll loop while we don't have a CRLF
                    // at the current offset.
                    while (size >= CRLFSize &&
                           (buffer[offset] != '\r' && buffer[offset + 1] != '\n')
                          ) {
                        BufferStruct.Offset = offset;
                        BufferStruct.Count = size;

                        BytesTaken = ChunkParse.SkipPastCRLF(BufferStruct);

                        // Make sure we had enough.

                        if (BytesTaken <= 0) {
                            return BytesTaken;
                        }

                        // Had enough, so update our sizes.
                        offset += BytesTaken;
                        size -= BytesTaken;
                    }

                    // If we get here, either we found the last CRLF or we ran out
                    // of buffer. See which it is.

                    if (size >= CRLFSize) {
                        // Found the last bit, return the size including the last CRLF
                        // after that.

                        return(offset + CRLFSize) - StartOffset;
                    }
                    else {
                        // Ran out of buffer.
                        return -1;
                    }
                }

            }

            return -1;
        }

        /*++

            DoPostReceiveCallback - Post a receive from a worker thread.

            This is our delegate, used for posting receives from a worker thread.
            We do this when we can't be sure that we're already on a worker thread,
            and we don't want to post from a client thread because if it goes away
            I/O gets cancelled.

            Input:

            state           - a null object

            Returns:

        --*/
        private static void DoPostReceiveCallback(object state) {
            Connection thisConnection = state as Connection;

            GlobalLog.Assert(thisConnection!=null, "Connection#" + ValidationHelper.HashString(thisConnection) + "::DoPostReceiveCallback() thisConnection==null", "");

            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(thisConnection) + "::DoPostReceiveCallback", "Cnt#" + ValidationHelper.HashString(thisConnection));

            thisConnection.m_BytesRead = 0;
            thisConnection.m_BytesScanned = 0;
            thisConnection.m_HeadersBytesUnparsed = 0;

            NetworkStream chkTransport = thisConnection.Transport;

            try {
                if (chkTransport==null) {
                    throw new IOException(SR.GetString(SR.net_io_readfailure));
                }
               chkTransport.BeginRead(
                    thisConnection.m_ReadBuffer,
                    0,
                    thisConnection.m_ReadBuffer.Length,
                    m_ReadCallback,
                    thisConnection );
            }
            catch (Exception exception) {
                ConnectionReturnResult returnResult = null;
                thisConnection.HandleError(WebExceptionStatus.ReceiveFailure, ConnectionFailureGroup.Receive, ref returnResult);
                ConnectionReturnResult.SetResponses(returnResult);
                GlobalLog.LeaveException("Connection#" + ValidationHelper.HashString(thisConnection) + "::DoPostReceiveCallback", exception);
                return;
            }

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(thisConnection) + "::DoPostReceiveCallback");
        }



        /*++

            ConstructTransport - Creates a transport for a given stream,
            and constructors a transport capable of handling it.

            Input:
                    socket - socket
                    result -
                    request -

            Returns:
                   WebExceptionStatus
        --*/
        private WebExceptionStatus ConstructTransport(Socket socket, ref NetworkStream result, HttpWebRequest request) {
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::ConstructTransport", "Socket#"+ValidationHelper.HashString(socket)+", ref NetworkStream, request#"+request.GetHashCode());
            //
            // for now we will look at the scheme and infer SSL if the scheme is "https"
            // in the future this will be replaced by full-extensible
            // scheme for cascadable streams in the future
            //
            Uri destination = request.Address;

            if (destination.Scheme != Uri.UriSchemeHttps) {
                //
                // for HTTP we're done
                //
                try {
                    result = new NetworkStream(socket, true);
                }
                catch {
                    GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ConstructTransport");
                    return WebExceptionStatus.ConnectFailure;
                }
                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ConstructTransport");
                return WebExceptionStatus.Success;
            }

            //
            // we have to do our tunneling first for proxy case
            //
            if (m_Server.InternalProxyServicePoint) {

                bool success = TunnelThroughProxy(m_Server.Address, request, out socket);

                if (!success) {
                    GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ConstructTransport");
                    return WebExceptionStatus.ConnectFailure;
                }
            }
            //
            // For SSL/TLS there is another stream in the hierarchy
            //
            WebExceptionStatus webStatus = ConstructTlsChannel(destination.Host, request, ref result, socket);

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ConstructTransport");
            return webStatus;
        }

        private bool TunnelThroughProxy(Uri proxy, HttpWebRequest originalRequest, out Socket socket) {
            GlobalLog.Enter("TunnelThroughProxy", "proxy="+proxy+", originalRequest #"+ValidationHelper.HashString(originalRequest));

            bool result = false;
            HttpProxyTunnelRequest connectRequest = null;

            socket = null;

            try {
                connectRequest = new HttpProxyTunnelRequest(
                    proxy,
                    new Uri("https://" + originalRequest.Address.Host + ":" + originalRequest.Address.Port)
                    );

                connectRequest.Credentials = originalRequest.InternalProxy.Credentials;
                connectRequest.InternalProxy = GlobalProxySelection.GetEmptyWebProxy();
                connectRequest.PreAuthenticate = true;

                HttpWebResponse connectResponse = (HttpWebResponse)connectRequest.GetResponse();
                ConnectStream connectStream = (ConnectStream)connectResponse.GetResponseStream();

                socket = connectStream.Connection.Transport.StreamSocket;
                connectStream.Connection.Transport.StreamSocket = null;
                // CODEREVIEW:
                // Richard, Arthur put this in but I don't know if it applies.
                // connectStream.Connection.ReleaseConnectionGroup();
                result = true;
            }
            catch (Exception exception) {
                GlobalLog.Print("exception occurred: " + exception);
                UnderlyingException = exception;
            }

            GlobalLog.Leave("TunnelThroughProxy", result);

            return result;
        }

        private WebExceptionStatus ConstructTlsChannel(String hostname, HttpWebRequest request, ref NetworkStream result, Socket socket) {
            GlobalLog.Enter("Connection#" + ValidationHelper.HashString(this) + "::ConstructTlsChannel");
            TlsStream tlsStream = new TlsStream(hostname, socket, true, request.ClientCertificates/*m_Server.ClientCertificate*/);

            // leave Stream, so that we know what Exception got thrown
            result = tlsStream;

            if (tlsStream.Status != WebExceptionStatus.Success) {
                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ConstructTlsChannel");
                return WebExceptionStatus.SecureChannelFailure;
            }

            //
            // Set the X509 certificate on the service point
            //
            bool validCertificate = m_Server.AcceptCertificate(tlsStream, request);

            if (!validCertificate) {
                //
                // Trust failure?
                //
                GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ConstructTlsChannel");
                return WebExceptionStatus.TrustFailure;
            }

            //
            // Successfully completed TLS handshake
            //

            GlobalLog.Leave("Connection#" + ValidationHelper.HashString(this) + "::ConstructTlsChannel");
            return WebExceptionStatus.Success;
        }

        private const int CRLFSize = 2;

        //
        // CheckNonIdle - called after update of the WriteList/WaitList,
        //   upon the departure of our Idle state our, BusyCount will
        //   go to non-0, then we need to mark this transition
        //

        private void CheckNonIdle() {
            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::CheckNonIdle()");
            if (m_Idle && this.BusyCount != 0 ) {
                m_Idle = false;
                m_Server.IncrementConnection();
            }
        }

        //
        // CheckIdle - called after update of the WriteList/WaitList,
        //    specifically called after we remove entries
        //

        private void CheckIdle() {
            GlobalLog.Print("Connection#" + ValidationHelper.HashString(this) + "::CheckIdle()");
            if (!m_Idle && this.BusyCount == 0)  {
                m_Idle = true;
                m_Server.DecrementConnection();
                m_ConnectionGroup.ConnectionGoneIdle();
            }
        }


        //
        // DebugDumpArrayListEntries - debug goop
        //
        [System.Diagnostics.Conditional("TRAVE")]
        private void DebugDumpArrayListEntries(ArrayList list) {
            for (int i = 0; i < list.Count; i++) {
                GlobalLog.Print("_WriteList[" + i.ToString() + "] Req: #" + ValidationHelper.HashString(((HttpWebRequest)list[i])));
            }
        }

        //
        // Validation & debugging
        //
        [System.Diagnostics.Conditional("DEBUG")]
        internal void Debug(int requestHash) {

            bool dump = (requestHash == 0) ? true : false;

            Console.WriteLine("Cnt#" + this.GetHashCode());

            if ( ! dump ) {
                foreach(HttpWebRequest request in  m_WriteList) {
                    if (request.GetHashCode() == requestHash) {
                        Console.WriteLine("Found-WriteList");
                        Dump();
                        return;
                    }
                }

                foreach(HttpWebRequest request in  m_WaitList) {
                    if (request.GetHashCode() == requestHash) {
                        Console.WriteLine("Found-WaitList");
                        Dump();
                        return;
                    }
                }
            }
            else {
                Dump();
                DebugDumpArrayListEntries(m_WriteList);
                DebugDumpArrayListEntries(m_WaitList);
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void Dump() {
            Console.WriteLine("m_CanPipeline:" + m_CanPipeline);
            Console.WriteLine("m_Pipelining:" + m_Pipelining);
            Console.WriteLine("m_KeepAlive:" + m_KeepAlive);
            Console.WriteLine("m_Error:" + m_Error);
            Console.WriteLine("m_ReadBuffer:" + m_ReadBuffer);
            Console.WriteLine("m_BytesRead:" + m_BytesRead);
            Console.WriteLine("m_HeadersBytesUnparsed:" + m_HeadersBytesUnparsed);
            Console.WriteLine("m_BytesScanned:" + m_BytesScanned);
            Console.WriteLine("m_ResponseData:" + m_ResponseData);
            Console.WriteLine("m_ReadState:" + m_ReadState);
            Console.WriteLine("m_CurrentRequestIndex:" + m_CurrentRequestIndex);
            Console.WriteLine("m_StatusLineInts:" + m_StatusLineInts);
            Console.WriteLine("m_StatusDescription:" + m_StatusDescription);
            Console.WriteLine("m_StatusState:" + m_StatusState);
            Console.WriteLine("m_ConnectionGroup:" + m_ConnectionGroup);
            Console.WriteLine("m_WeakReference:" + m_WeakReference);
            Console.WriteLine("m_Idle:" + m_Idle);
            Console.WriteLine("m_Server:" + m_Server);
            Console.WriteLine("m_Version:" + m_Version);
            Console.WriteLine("Transport:" + Transport);

            if ( Transport is TlsStream ) {
                TlsStream tlsStream = Transport as TlsStream;
                tlsStream.Debug();
            }
            else if (Transport!=null && Transport.m_StreamSocket!=null) {
                Transport.m_StreamSocket.Debug();
            }

            Console.WriteLine("m_ReadCallbackEvent:" + m_ReadCallbackEvent);
            Console.WriteLine("m_StartConnectionDelegate:" + m_StartConnectionDelegate);

            Console.WriteLine("m_Abort:" + m_Abort);
            Console.WriteLine("m_AbortSocket:" + m_AbortSocket);
            Console.WriteLine("m_AbortSocket6:" + m_AbortSocket6);
            Console.WriteLine("m_AbortDelegate:" + m_AbortDelegate);

            Console.WriteLine("m_ReadDone:" + m_ReadDone);
            Console.WriteLine("m_WriteDone:" + m_WriteDone);
            Console.WriteLine("m_Free:" + m_Free);

        }

        //
        // RemoveAtAndUpdateServicePoint -
        //    this method will pop from the Wait or from the Write List.
        //    we use it in order for us to track connection usage and
        //    detect when this connection to the service point goes idle.
        //
        private void RemoveAtAndUpdateServicePoint(ArrayList list, int index) {

            if ( list == m_WriteList ) {
                GlobalLog.Print("list(wLst-Cnt:" + this.GetHashCode() + ").RemoveAt(" + index + ") current Count:" + list.Count.ToString());
            }
            else {
                GlobalLog.Print("list(waitL-Cnt:" + this.GetHashCode() + ").RemoveAt(" + index + ") current Count:" + list.Count.ToString());
            }

            list.RemoveAt(index);

            CheckIdle();
        }

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }
    } // class Connection
} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_headerinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="_HeaderInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    internal delegate string[] HeaderParser(string value);

    internal class HeaderInfo {

        internal bool IsRestricted;
        internal HeaderParser Parser;

        //
        // Note that the HeaderName field is not always valid, and should not
        // be used after initialization. In particular, the HeaderInfo returned
        // for an unknown header will not have the correct header name.
        //

        internal string HeaderName;
        internal bool AllowMultiValues;

        internal HeaderInfo(string name, bool restricted, bool multi, HeaderParser p) {
            HeaderName = name;
            IsRestricted = restricted;
            Parser = p;
            AllowMultiValues = multi;
        }
    }
} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_headerinfotable.cs ===
//------------------------------------------------------------------------------
// <copyright file="_HeaderInfoTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    
    internal class HeaderInfoTable {

        private static Hashtable HeaderHashTable;

        private static HeaderParser SingleParser = new HeaderParser(ParseSingleValue);
        private static HeaderParser MultiParser = new HeaderParser(ParseMultiValue);

        private static string[] ParseSingleValue(string value) {
            return new string[1] {value};
        }

        //
        // CODEWORK - this is ugly. Fix this to make more efficient, like maybe
        // not adding to the stringtable unless there's multiple values.
        //

        private static string[] ParseMultiValue(string value) {
            StringCollection tempStringCollection = new StringCollection();

            bool inquote = false;
            int chIndex = 0;
            char[] vp = new char[value.Length];
            string singleValue;

            for (int i = 0; i < value.Length; i++) {
                if (value[i] == '\"') {
                    inquote = !inquote;
                }
                else if ((value[i] == ',') && !inquote) {
                    singleValue = new String(vp, 0, chIndex);
                    tempStringCollection.Add(singleValue.Trim());
                    chIndex = 0;
                    continue;
                }
                vp[chIndex++] = value[i];
            }

            //
            // Now add the last of the header values to the stringtable.
            //

            if (chIndex != 0) {
                singleValue = new String(vp, 0, chIndex);
                tempStringCollection.Add(singleValue.Trim());
            }

            string[] stringArray = new string[tempStringCollection.Count];

            tempStringCollection.CopyTo(stringArray, 0) ;

            return stringArray;
        }

        private static HeaderInfo UnknownHeaderInfo =
            new HeaderInfo(String.Empty, false, false, SingleParser);

        // internal HeaderInfoTable() {}

        private static bool m_Initialized = Initialize();

        private static bool Initialize() {

            HeaderInfo[] InfoArray = new HeaderInfo[] {
                new HeaderInfo(HttpKnownHeaderNames.Age, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.Allow, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Accept, true, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Authorization, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.AcceptRanges, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.AcceptCharset, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.AcceptEncoding, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.AcceptLanguage, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Cookie, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Connection, true, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.ContentMD5, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.ContentType, true, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.CacheControl, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.ContentRange, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.ContentLength, true, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.ContentEncoding, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.ContentLanguage, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.ContentLocation, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.Date, true, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.ETag, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.Expect, true, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Expires, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.From, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.Host, true, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.IfMatch, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.IfRange, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.IfNoneMatch, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.IfModifiedSince, true, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.IfUnmodifiedSince, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.Location, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.LastModified, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.MaxForwards, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.Pragma, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.ProxyAuthenticate, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.ProxyAuthorization, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.ProxyConnection, true, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Range, true, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Referer, true, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.RetryAfter, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.Server, false, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.SetCookie, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.SetCookie2, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.TE, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Trailer, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.TransferEncoding, true , true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Upgrade, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.UserAgent, true, false, SingleParser),
                new HeaderInfo(HttpKnownHeaderNames.Via, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Vary, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.Warning, false, true, MultiParser),
                new HeaderInfo(HttpKnownHeaderNames.WWWAuthenticate, false, true, SingleParser)
            };

            HeaderHashTable =
                new Hashtable(
                    InfoArray.Length * 2,
                    CaseInsensitiveAscii.StaticInstance,
                    CaseInsensitiveAscii.StaticInstance );

            for (int i = 0; i < InfoArray.Length; i++) {
                HeaderHashTable[InfoArray[i].HeaderName] = InfoArray[i];
            }

            //
            // feed this guy to the garbage-collector as soon as possible
            //
            InfoArray = null;

            return true;
        }

        internal HeaderInfo this[string name] {
            get {
                HeaderInfo tempHeaderInfo = (HeaderInfo)HeaderHashTable[name];

                if (tempHeaderInfo == null) {
                    return UnknownHeaderInfo;
                }

                return tempHeaderInfo;
            }
        }

    } // class HeaderInfoTable


    internal class CaseInsensitiveString : IComparer, IHashCodeProvider {

        internal static CaseInsensitiveString StaticInstance = new CaseInsensitiveString();

        //
        // StringHashFunction - A simple Hash object used to
        //  to handle hasing for our RestrictedHeaders Hash Table.
        //
        public int GetHashCode(object obj) {
            string myString = (string) obj;

            int myHashCode = (int)Char.ToLower(myString[0], CultureInfo.InvariantCulture) * 50 + myString.Length;

            return myHashCode;
        }
        //
        // CaseInsensitiveCompare - used to provide a comparer function,
        //  also used by our RestrictedHeaders HashTable
        //
        public int Compare(object x, object y) {
            string firstString = (string)x;
            string secondString = (string)y;
            //
            // use case-insensitive comparison method in System::String
            //
            int result = String.Compare(firstString, secondString, true, CultureInfo.InvariantCulture);

            GlobalLog.Print("Compare2[" + firstString + "," + secondString + "]:" + result.ToString());

            return result;
        }
    }


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_isessionauthenticationmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ICompleteAuthenticationModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Net {

    internal interface ISessionAuthenticationModule : IAuthenticationModule {

        bool Update(string challenge, WebRequest webRequest);

        void ClearSession(WebRequest webRequest);

        bool CanUseDefaultCredentials { get; }

    } // interface ISessionAuthenticationModule


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_httpdateparse.cs ===
//------------------------------------------------------------------------------
// <copyright file="_HTTPDateParse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System.Globalization;

namespace System.Net {
    internal class HttpDateParse {
        private const int BASE_DEC  = 10; // base 10

        //
        // Date indicies used to figure out what each entry is.
        //


        private const int DATE_INDEX_DAY_OF_WEEK     = 0;

        private const int DATE_1123_INDEX_DAY        = 1;
        private const int DATE_1123_INDEX_MONTH      = 2;
        private const int DATE_1123_INDEX_YEAR       = 3;
        private const int DATE_1123_INDEX_HRS        = 4;
        private const int DATE_1123_INDEX_MINS       = 5;
        private const int DATE_1123_INDEX_SECS       = 6;

        private const int DATE_ANSI_INDEX_MONTH      = 1;
        private const int DATE_ANSI_INDEX_DAY        = 2;
        private const int DATE_ANSI_INDEX_HRS        = 3;
        private const int DATE_ANSI_INDEX_MINS       = 4;
        private const int DATE_ANSI_INDEX_SECS       = 5;
        private const int DATE_ANSI_INDEX_YEAR       = 6;

        private const int DATE_INDEX_TZ              = 7;

        private const int DATE_INDEX_LAST            = DATE_INDEX_TZ;
        private const int MAX_FIELD_DATE_ENTRIES           = (DATE_INDEX_LAST+1);

        //
        // DATE_TOKEN's DWORD values used to determine what day/month we're on
        //

        private const int DATE_TOKEN_JANUARY      = 1;
        private const int DATE_TOKEN_FEBRUARY     = 2;
        private const int DATE_TOKEN_MARCH        = 3;
        private const int DATE_TOKEN_APRIL        = 4;
        private const int DATE_TOKEN_MAY          = 5;
        private const int DATE_TOKEN_JUNE         = 6;
        private const int DATE_TOKEN_JULY         = 7;
        private const int DATE_TOKEN_AUGUST       = 8;
        private const int DATE_TOKEN_SEPTEMBER    = 9;
        private const int DATE_TOKEN_OCTOBER      = 10;
        private const int DATE_TOKEN_NOVEMBER     = 11;
        private const int DATE_TOKEN_DECEMBER     = 12;

        private const int DATE_TOKEN_LAST_MONTH   = (DATE_TOKEN_DECEMBER+1);

        private const int DATE_TOKEN_SUNDAY       = 0;
        private const int DATE_TOKEN_MONDAY       = 1;
        private const int DATE_TOKEN_TUESDAY      = 2;
        private const int DATE_TOKEN_WEDNESDAY    = 3;
        private const int DATE_TOKEN_THURSDAY     = 4;
        private const int DATE_TOKEN_FRIDAY       = 5;
        private const int DATE_TOKEN_SATURDAY     = 6;

        private const int DATE_TOKEN_LAST_DAY     = (DATE_TOKEN_SATURDAY+1);

        private const int DATE_TOKEN_GMT          = -1000;

        private const int DATE_TOKEN_LAST         = DATE_TOKEN_GMT;

        private const int DATE_TOKEN_ERROR        = (DATE_TOKEN_LAST+1);


        //
        // MAKE_UPPER - takes an assumed lower character and bit manipulates into a upper.
        //              (make sure the character is Lower case alpha char to begin,
        //               otherwise it corrupts)
        //

        private
        static
        char
        MAKE_UPPER(char c) {
            return(Char.ToUpper(c, CultureInfo.InvariantCulture));
        }

        /*++

        Routine Description:

            Looks at the first three bytes of string to determine if we're looking
                at a Day of the Week, or Month, or "GMT" string.  Is inlined so that
                the compiler can optimize this code into the caller FInternalParseHttpDate.

        Arguments:

            lpszDay - a string ptr to the first byte of the string in question.

        Return Value:

            DWORD
            Success - The Correct date token, 0-6 for day of the week, 1-14 for month, etc

            Failure - DATE_TOKEN_ERROR

        --*/

        private
        static
        int
        MapDayMonthToDword(
                          char [] lpszDay,
                          int index
                          ) {
            switch (MAKE_UPPER(lpszDay[index])) { // make uppercase
                case 'A':
                    switch (MAKE_UPPER(lpszDay[index+1])) {
                        case 'P':
                            return DATE_TOKEN_APRIL;
                        case 'U':
                            return DATE_TOKEN_AUGUST;

                    }
                    return DATE_TOKEN_ERROR;

                case 'D':
                    return DATE_TOKEN_DECEMBER;

                case 'F':
                    switch (MAKE_UPPER(lpszDay[index+1])) {
                        case 'R':
                            return DATE_TOKEN_FRIDAY;
                        case 'E':
                            return DATE_TOKEN_FEBRUARY;
                    }

                    return DATE_TOKEN_ERROR;

                case 'G':
                    return DATE_TOKEN_GMT;

                case 'M':

                    switch (MAKE_UPPER(lpszDay[index+1])) {
                        case 'O':
                            return DATE_TOKEN_MONDAY;
                        case 'A':
                            switch (MAKE_UPPER(lpszDay[index+2])) {
                                case 'R':
                                    return DATE_TOKEN_MARCH;
                                case 'Y':
                                    return DATE_TOKEN_MAY;
                            }

                            // fall through to error
                            break;
                    }

                    return DATE_TOKEN_ERROR;

                case 'N':
                    return DATE_TOKEN_NOVEMBER;

                case 'J':

                    switch (MAKE_UPPER(lpszDay[index+1])) {
                        case 'A':
                            return DATE_TOKEN_JANUARY;

                        case 'U':
                            switch (MAKE_UPPER(lpszDay[index+2])) {
                                case 'N':
                                    return DATE_TOKEN_JUNE;
                                case 'L':
                                    return DATE_TOKEN_JULY;
                            }

                            // fall through to error
                            break;
                    }

                    return DATE_TOKEN_ERROR;

                case 'O':
                    return DATE_TOKEN_OCTOBER;

                case 'S':

                    switch (MAKE_UPPER(lpszDay[index+1])) {
                        case 'A':
                            return DATE_TOKEN_SATURDAY;
                        case 'U':
                            return DATE_TOKEN_SUNDAY;
                        case 'E':
                            return DATE_TOKEN_SEPTEMBER;
                    }

                    return DATE_TOKEN_ERROR;


                case 'T':
                    switch (MAKE_UPPER(lpszDay[index+1])) {
                        case 'U':
                            return DATE_TOKEN_TUESDAY;
                        case 'H':
                            return DATE_TOKEN_THURSDAY;
                    }

                    return DATE_TOKEN_ERROR;

                case 'U':
                    return DATE_TOKEN_GMT;

                case 'W':
                    return DATE_TOKEN_WEDNESDAY;

            }

            return DATE_TOKEN_ERROR;
        }

        /*++

        Routine Description:

            Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
             a FILETIME/SYSTEMTIME time format.

            Important this a time-critical function and should only be changed
             with the intention of optimizing or a critical need work item.

        Arguments:

            lpft - Ptr to FILETIME structure.  Used to store converted result.
                    Must be NULL if not intended to be used !!!

            lpSysTime - Ptr to SYSTEMTIME struture. Used to return Systime if needed.

            lpcszDateStr - Const Date string to parse.

        Return Value:

            BOOL
            Success - TRUE

            Failure - FALSE

        --*/
        public
        static
        bool
        ParseHttpDate(
                     String DateString,
                     out DateTime dtOut
                     ) {
            int index = 0;
            int i = 0, iLastLettered = -1;
            bool fIsANSIDateFormat = false;
            int [] rgdwDateParseResults = new int[MAX_FIELD_DATE_ENTRIES];
            bool fRet = true;
            char [] lpInputBuffer = DateString.ToCharArray();

            dtOut = new DateTime();

            //
            // Date Parsing v2 (1 more to go), and here is how it works...
            //  We take a date string and churn through it once, converting
            //  integers to integers, Month,Day, and GMT strings into integers,
            //  and all is then placed IN order in a temp array.
            //
            // At the completetion of the parse stage, we simple look at
            //  the data, and then map the results into the correct
            //  places in the SYSTIME structure.  Simple, No allocations, and
            //  No dirting the data.
            //
            // The end of the function does something munging and pretting
            //  up of the results to handle the year 2000, and TZ offsets
            //  Note: do we need to fully handle TZs anymore?
            //

            while (index < DateString.Length && i < MAX_FIELD_DATE_ENTRIES) {
                if (lpInputBuffer[index] >= '0' && lpInputBuffer[index] <= '9') {
                    //
                    // we have a numerical entry, scan through it and convent to DWORD
                    //

                    rgdwDateParseResults[i] = 0;

                    do {
                        rgdwDateParseResults[i] *= BASE_DEC;
                        rgdwDateParseResults[i] += (lpInputBuffer[index] - '0');
                        index++;
                    } while (index < DateString.Length &&
                             lpInputBuffer[index] >= '0' &&
                             lpInputBuffer[index] <= '9');

                    i++; // next token
                }
                else if ((lpInputBuffer[index] >= 'A' && lpInputBuffer[index] <= 'Z') ||
                         (lpInputBuffer[index] >= 'a' && lpInputBuffer[index] <= 'z')) {
                    //
                    // we have a string, should be a day, month, or GMT
                    //   lets skim to the end of the string
                    //

                    rgdwDateParseResults[i] =
                    MapDayMonthToDword(lpInputBuffer, index);

                    iLastLettered = i;

                    // We want to ignore the possibility of a time zone such as PST or EST in a non-standard
                    // date format such as "Thu Dec 17 16:01:28 PST 1998" (Notice that the year is _after_ the time zone
                    if ((rgdwDateParseResults[i] == DATE_TOKEN_ERROR)
                        &&
                        !(fIsANSIDateFormat && (i==DATE_ANSI_INDEX_YEAR))) {
                        fRet = false;
                        goto quit;
                    }

                    //
                    // At this point if we have a vaild string
                    //  at this index, we know for sure that we're
                    //  looking at a ANSI type DATE format.
                    //

                    if (i == DATE_ANSI_INDEX_MONTH) {
                        fIsANSIDateFormat = true;
                    }

                    //
                    // Read past the end of the current set of alpha characters,
                    //  as MapDayMonthToDword only peeks at a few characters
                    //

                    do {
                        index++;
                    } while (index < DateString.Length &&
                             ( (lpInputBuffer[index] >= 'A' && lpInputBuffer[index] <= 'Z') ||
                               (lpInputBuffer[index] >= 'a' && lpInputBuffer[index] <= 'z') ));

                    i++; // next token
                }
                else {
                    //
                    // For the generic case its either a space, comma, semi-colon, etc.
                    //  the point is we really don't care, nor do we need to waste time
                    //  worring about it (the orginal code did).   The point is we
                    //  care about the actual date information, So we just advance to the
                    //  next lexume.
                    //

                    index++;
                }
            }

            //
            // We're finished parsing the string, now take the parsed tokens
            //  and turn them to the actual structured information we care about.
            //  So we build lpSysTime from the Array, using a local if none is passed in.
            //

            int year;
            int month;
            int day;
            int hour;
            int minute;
            int second;
            int millisecond;

            millisecond =  0;

            if (fIsANSIDateFormat) {
                day    = rgdwDateParseResults[DATE_ANSI_INDEX_DAY];
                month  = rgdwDateParseResults[DATE_ANSI_INDEX_MONTH];
                hour   = rgdwDateParseResults[DATE_ANSI_INDEX_HRS];
                minute = rgdwDateParseResults[DATE_ANSI_INDEX_MINS];
                second = rgdwDateParseResults[DATE_ANSI_INDEX_SECS];
                if (iLastLettered != DATE_ANSI_INDEX_YEAR) {
                    year   = rgdwDateParseResults[DATE_ANSI_INDEX_YEAR];
                }
                else {
                    // This is a fix to get around toString/toGMTstring (where the timezone is
                    // appended at the end. (See above)
                    year   = rgdwDateParseResults[DATE_INDEX_TZ];
                }
            }
            else {
                day    = rgdwDateParseResults[DATE_1123_INDEX_DAY];
                month  = rgdwDateParseResults[DATE_1123_INDEX_MONTH];
                year   = rgdwDateParseResults[DATE_1123_INDEX_YEAR];
                hour   = rgdwDateParseResults[DATE_1123_INDEX_HRS];
                minute = rgdwDateParseResults[DATE_1123_INDEX_MINS];
                second = rgdwDateParseResults[DATE_1123_INDEX_SECS];
            }

            //
            // Normalize the year, 90 == 1990, handle the year 2000, 02 == 2002
            //  This is Year 2000 handling folks!!!  We get this wrong and
            //  we all look bad.
            //

            if (year < 100) {
                year += ((year < 80) ? 2000 : 1900);
            }

            //
            // if we got misformed time, then plug in the current time
            // !lpszHrs || !lpszMins || !lpszSec
            //

            if ((i < 4)
                || (day > 31)
                || (hour > 23)
                || (minute > 59)
                || (second > 59)) {
                fRet = false;
                goto quit;
            }

            //
            // Now do the DateTime conversion
            //

            dtOut = new DateTime (year, month, day, hour, minute, second, millisecond);

            //
            // we want the system time to be accurate. This is _suhlow_
            // The time passed in is in the local time zone; we have to convert this into GMT.
            //

            if (iLastLettered==DATE_ANSI_INDEX_YEAR) {
                // this should be an unusual case.
                dtOut = dtOut.ToUniversalTime();
            }

            //
            // If we have an Offset to another Time Zone
            //   then convert to appropriate GMT time
            //

            if ((i > DATE_INDEX_TZ &&
                 rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT)) {

                //
                // if we received +/-nnnn as offset (hhmm), modify the output FILETIME
                //

                double offset;

                offset = (double) rgdwDateParseResults[DATE_INDEX_TZ];
                dtOut.AddHours(offset);
            }

            // In the end, we leave it all in LocalTime

            dtOut = dtOut.ToLocalTime();

            quit:

            return fRet;
        }


        public static  bool
        ParseCookieDate(string dateString, out DateTime dtOut) {
            //
            // The format variants
            //
            // 1) .NET HttpCookie   = "dd-MMM-yyyy HH:mm:ss GMT'"
            // 2) Version0          = "dd-MMM-yy HH:mm:ss GMT"
            // 3) Some funky form   = "dd MMM yyyy HH:mm:ss GMT"
            //
            // In all above cases we also accept single digit dd,hh,mm,ss
            // That's said what IE does.

            dtOut = DateTime.MinValue;
            char[] buffer = dateString.ToCharArray();
            char ch;

            if (buffer.Length < 18) { //cover all before "ss" in the longest case
                return false;
            }

            int idx = 0;
            // Take the date
            int  day=0;
            if (!Char.IsDigit(ch = buffer[idx++]))  {return false;}
            else                                    {day = ch-'0';}
            if (!Char.IsDigit(ch = buffer[idx++]))  {--idx;}                //one digit was used for a date
            else                                    {day = day*10 +(ch-'0');}
            
            
            if (day > 31)  {return false;}

            ++idx;  //ignore delimiter and position on Month

            // Take the Month
            int month = MapDayMonthToDword(buffer, idx);
            if (month == DATE_TOKEN_ERROR)                   {return false;}

            idx+=4; //position after Month and ignore delimiter

            // Take the year
            int year=0;
            int i;
            for (i=0; i < 4; ++i) {
                if (!Char.IsDigit(ch = buffer[i+idx])) {
                    // YY case
                    if (i != 2)             {return false;}
                    else                    {break;}
                }
                year = year*10 + (ch-'0');
            }

            //check for two digits
            if (i == 2) {
                year += ((year < 80) ? 2000 : 1900);
            }

            i += idx;       //from now on 'i' is used as an index
            if (buffer[i++] != ' ')             {return false;}

            //Take the hour
            int  hour=0;
            if (!Char.IsDigit(ch = buffer[i++])) {return false;}
            else                                 {hour = ch-'0';}
            if (!Char.IsDigit(ch = buffer[i++])) {--i;}                     //accept single digit
            else                                 {hour = hour*10 +(ch-'0');}

            if (hour > 24 || buffer[i++] != ':') {return false;}

            //Take the min
            int  min=0;
            if (!Char.IsDigit(ch = buffer[i++])) {return false;}
            else                                 {min = ch-'0';}
            if (!Char.IsDigit(ch = buffer[i++])) {--i;}                     //accept single digit
            else                                 {min = min*10 +(ch-'0');}

            if (min > 60 || buffer[i++] != ':')  {return false;}

            //Check that the rest will fit the buffer size "[s]s GMT"
            if ((buffer.Length - i) < 5)       {return false;}

            //Take the sec
            int  sec=0;
            if (!Char.IsDigit(ch = buffer[i++])) {return false;}
            else                                 {sec = ch-'0';}
            if (!Char.IsDigit(ch = buffer[i++])) {--i;}                     //accept single digit
            else                                 {sec = sec*10 +(ch-'0');}

            if (sec > 60 || buffer[i++] != ' ')  {return false;}

            //Test GMT
            if((buffer.Length - i) < 3 || buffer[i++] != 'G' || buffer[i++] != 'M' || buffer[i++] != 'T') {
                return false;
            }

            dtOut = new DateTime (year, month, day, hour, min, sec, 0).ToLocalTime();
            return true;
        }
    }

} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_kerberosclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="_KerberosClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Collections;
    using System.Net.Sockets;
    using System.Security.Permissions;
    using System.Globalization;
    
    internal class KerberosClient : ISessionAuthenticationModule {

        internal const string AuthType = "Kerberos";
        internal static string Signature = AuthType.ToLower(CultureInfo.InvariantCulture);
        internal static int SignatureSize = Signature.Length;

        internal static Hashtable sessions = new Hashtable();

        // we can't work on non-NT platforms, so we shut off with an exception
        // NOTE this exception IS caught internally.
        public KerberosClient() {
            if (!ComNetOS.IsWin2K) {
                throw new NotSupportedException(SR.GetString(SR.Win2000Required));
            }
        }

        /*
         *  This is to support built-in auth modules under semitrusted environment
         *  Used to get access to UserName, Domain and Password properties of NetworkCredentials
         *  Declarative Assert is much faster and we don;t call dangerous methods inside this one.
         */
        [EnvironmentPermission(SecurityAction.Assert,Unrestricted=true)]
        [SecurityPermissionAttribute( SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]

        public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("KerberosClient::Authenticate(): " + challenge);

            GlobalLog.Assert(credentials!=null, "KerberosClient::Authenticate() credentials==null", "");
            if (credentials == null) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "KerberosClient::Authenticate() httpWebRequest==null", "");
            if (httpWebRequest==null || httpWebRequest.ChallengedUri==null) {
                //
                // there has been no challenge:
                // 1) the request never went on the wire
                // 2) somebody other than us is calling into AuthenticationManager
                //
                return null;
            }

            int index = AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {
                return null;
            }

            int blobBegin = index + SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //
            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            NTAuthentication authSession = sessions[httpWebRequest.CurrentAuthenticationState] as NTAuthentication;
            GlobalLog.Print("KerberosClient::Authenticate() key:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));

            if (authSession==null) {
                NetworkCredential NC = credentials.GetCredential(httpWebRequest.ChallengedUri, Signature);
                GlobalLog.Print("KerberosClient::Authenticate() GetCredential() returns:" + ValidationHelper.ToString(NC));

                if (NC == null) {
                    return null;
                }
                string username = NC.UserName;
                if (username == null || (username.Length == 0 && !(NC is SystemNetworkCredential))) {
                    return null;
                }

                if (httpWebRequest.ChallengedSpn==null) {
                    string host = httpWebRequest.ChallengedUri.Host;
                    if (httpWebRequest.ChallengedUri.HostNameType!=UriHostNameType.IPv6 && httpWebRequest.ChallengedUri.HostNameType!=UriHostNameType.IPv4 && host.IndexOf('.')==-1) {
                        // only do the DNS lookup for short names, no form of IP addess
                        (new DnsPermission(PermissionState.Unrestricted)).Assert();
                        try {
                            host = Dns.GetHostByName(host).HostName;
                            GlobalLog.Print("KerberosClient::Authenticate() Dns returned host:" + ValidationHelper.ToString(host));
                        }
                        catch (Exception exception) {
                            GlobalLog.Print("KerberosClient::Authenticate() GetHostByName(host) failed:" + ValidationHelper.ToString(exception));
                        }
                        finally {
                            DnsPermission.RevertAssert();
                        }
                    }
                    // CONSIDER V.NEXT
                    // for now avoid appending the non default port to the
                    // SPN, sometime in the future we'll have to do this.
                    // httpWebRequest.ChallengedSpn = httpWebRequest.ChallengedUri.IsDefaultPort ? host : host + ":" + httpWebRequest.ChallengedUri.Port;
                    httpWebRequest.ChallengedSpn = host;
                }
                GlobalLog.Print("KerberosClient::Authenticate() ChallengedSpn:" + ValidationHelper.ToString(httpWebRequest.ChallengedSpn));

                authSession =
                    new NTAuthentication(
                        AuthType,
                        NC,
                        "HTTP/" + httpWebRequest.ChallengedSpn,
                        httpWebRequest.DelegationFix);

                GlobalLog.Print("KerberosClient::Authenticate() adding authSession:" + ValidationHelper.HashString(authSession) + " for:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState));
                sessions.Add(httpWebRequest.CurrentAuthenticationState, authSession);
            }

            bool handshakeComplete;
            string clientResponse = authSession.GetOutgoingBlob(incoming, out handshakeComplete);
            if (clientResponse==null) {
                return null;
            }

            return new Authorization(AuthType + " " + clientResponse, false, string.Empty);
        }

        public bool CanPreAuthenticate {
            get {
                return false;
            }
        }

        public Authorization PreAuthenticate(WebRequest webRequest, ICredentials Credentials) {
            return null;
        }

        public string AuthenticationType {
            get {
                return AuthType;
            }
        }

        //
        // called when getting the final blob on the 200 OK from the server
        //
        public bool Update(string challenge, WebRequest webRequest) {
            GlobalLog.Print("KerberosClient::Update(): " + challenge);

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "KerberosClient::Update() httpWebRequest==null", "");
            GlobalLog.Assert(httpWebRequest.ChallengedUri!=null, "KerberosClient::Update() httpWebRequest.ChallengedUri==null", "");

            //
            // try to retrieve the state of the ongoing handshake
            //
            NTAuthentication authSession = sessions[httpWebRequest.CurrentAuthenticationState] as NTAuthentication;
            GlobalLog.Print("KerberosClient::Update() key:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));

            if (authSession==null) {
                GlobalLog.Print("KerberosClient::Update() null session returning true");
                return true;
            }

            GlobalLog.Print("KerberosClient::Update() authSession.IsCompleted:" + authSession.IsCompleted.ToString());

            if (httpWebRequest.CurrentAuthenticationState.StatusCodeMatch==httpWebRequest.ResponseStatusCode) {
                GlobalLog.Print("KerberosClient::Update() still handshaking (based on status code) returning false");
                return false;
            }

            //
            // the whole point here is to remove the session, so do it right away, and then try
            // to close the Security Context (this will complete the authentication handshake
            // with server authentication for schemese that support it such as Kerberos)
            //
            GlobalLog.Print("KerberosClient::Update() removing authSession:" + ValidationHelper.HashString(authSession) + " from:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState));
            sessions.Remove(httpWebRequest.CurrentAuthenticationState);

            int index = challenge==null ? -1 : AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {
                return true;
            }

            int blobBegin = index + SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //
            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            GlobalLog.Print("KerberosClient::Update() closing security context using last incoming blob:[" + ValidationHelper.ToString(incoming) + "]");

            bool handshakeComplete;
            string clientResponse = authSession.GetOutgoingBlob(incoming, out handshakeComplete);

            GlobalLog.Print("KerberosClient::Update() GetOutgoingBlob() returns clientResponse:[" + ValidationHelper.ToString(clientResponse) + "] handshakeComplete:" + handshakeComplete.ToString());
            return true;
        }

        public void ClearSession(WebRequest webRequest) {
            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;
            sessions.Remove(httpWebRequest.CurrentAuthenticationState);
        }

        public bool CanUseDefaultCredentials {
            get {
                return true;
            }
        }

    }; // class KerberosClient


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_lazyasyncresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="_LazyAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Threading;
    //
    // LazyAsyncResult - Base class for all IAsyncResult classes
    // that want to take advantage of lazy allocated event handles
    //
    internal class LazyAsyncResult : IAsyncResult {
        //
        // class members
        //
        private object m_AsyncObject;               // Caller's async object.
        private object m_AsyncState;                // Caller's state object.
        private AsyncCallback m_AsyncCallback;      // Caller's callback method.
        private object m_Result;                    // Final IO result to be returned byt the End*() method.
        private int m_ErrorCode;                    // Win32 error code for Win32 IO async calls (that want to throw).
        private bool m_EndCalled;                   // true if the user called the End*() method.
        private bool m_CompletedSynchronously;      // true if the operation completed synchrnously.
        private int m_CleanedUp;                    // 0 if not cleaned up >0 otherwise.
        private int m_IntCompleted;                 // 0 if not completed >0 otherwise.
        private int m_IntInvokedCallback;           // 0 if the user's callback still needs to be invoked >0 otherwise.
        private object m_Event;                     // lazy allocated event to be returned in the IAsyncResult for the client to wait on

        internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack) {
            m_AsyncObject = myObject;
            m_AsyncState = myState;
            m_AsyncCallback = myCallBack;
            //m_EndCalled = false;
            //m_CompletedSynchronously = false;
            //m_CleanedUp = 0;
            //m_IntCompleted = 0;
            m_IntInvokedCallback = (myCallBack != null) ? 0 : 1;
            //m_ErrorCode = 0;

            GlobalLog.Print("LazyAsyncResult::.ctor() this:" + ValidationHelper.HashString(this));

        } // LazyAsyncResult()

        //
        // destructor
        //
        ~LazyAsyncResult() {
            //
            // call custom cleanup function on garbage collection
            //
            InternalCleanup();
        }

        //
        // Interface method to return the original async object:
        //
        public object AsyncObject {
            get {
                return m_AsyncObject;
            }
        } // AsyncObject

        //
        // Interface method to return the caller's state object.
        //
        public object AsyncState {
            get {
                return m_AsyncState;
            }
        } // AsyncState

        //
        // Interface property to return a WaitHandle that can be waited on for I/O completion.
        // This property implements lazy event creation.
        // the event object is only created when this property is accessed,
        // since we're internally only using callbacks, as long as the user is using
        // callbacks as well we will not create an event at all.
        //
        public WaitHandle AsyncWaitHandle {
            get {
                //
                // save a copy of the completion status
                //
                int savedIntCompleted = m_IntCompleted;

                if (m_Event == null) {
                    //
                    // lazy allocation of the event:
                    // if this property is never accessed this object is never created
                    //
                    Interlocked.CompareExchange(ref m_Event, new ManualResetEvent(savedIntCompleted != 0), null);
                }

                ManualResetEvent castedEvent = (ManualResetEvent)m_Event;

                if (savedIntCompleted == 0 && m_IntCompleted != 0) {
                    //
                    // if, while the event was created in the reset state,
                    // the IO operation completed, set the event here.
                    //
                    castedEvent.Set();
                }

                GlobalLog.Print("LazyAsyncResult::get_AsyncWaitHandle this:" + ValidationHelper.HashString(this) + " m_Event:" + ValidationHelper.HashString(m_Event));

                return castedEvent;
            }
        } // AsyncWaitHandle

        //
        // Interface property, returning synchronous completion status.
        //
        public bool CompletedSynchronously {
            get {
                return m_CompletedSynchronously;
            }
        } // CompletedSynchronously

        //
        // Interface property, returning completion status.
        //
        public bool IsCompleted {
            get {
                return m_IntCompleted != 0;
            }
        } // IsCompleted

        //
        // Internal property for setting the IO result.
        //
        internal object Result {
            get {
                return m_Result;
            }
            set {
                //
                // Ideally this should never be called, since setting
                // the result object really makes sense when the IO completes.
                //
                // we should always be using the method
                // InvokeCallback( bool asyncCompletion, object result )
                // which completes the IO by:
                //
                // 1) setting the result object
                // 2) calling the user's callback
                // 3) signaling the user's event if one was created
                //
                m_Result = value;
            }

        } // Result

        internal bool EndCalled {
            get {
                return m_EndCalled;
            }
            set {
                m_EndCalled = value;
            }
        } // EndCalled

        //
        // Internal property for setting the Win32 IO async error code.
        //
        internal int ErrorCode {
            get {
                return m_ErrorCode;
            }
            set {
                m_ErrorCode = value;
            }
        } // ErrorCode

        //
        // Internal method for completing the IO
        // and invoking the user's callback.
        //
        internal void InvokeCallback(bool completedSynchronously, object result) {
            Complete(completedSynchronously, result);
            InvokeCallback();

        } // InvokeCallback()

        //
        // Internal method for completing the IO
        // and invoking the user's callback.
        //
        internal void InvokeCallback(bool completedSynchronously) {
            Complete(completedSynchronously);
            InvokeCallback();

        } // InvokeCallback()

        //
        // Internal method for invoking the user's callback.
        //
        internal void InvokeCallback() {
            if (Interlocked.Increment(ref m_IntInvokedCallback)==1) {
                //
                // note that m_AsyncCallback can never be null here, since
                // m_IntInvokedCallback would have been set to 1 in the constructor.
                //
                GlobalLog.Print("LazyAsyncResult::InvokeCallback() invoking callback");
                m_AsyncCallback.Invoke(this);
            }

        } // InvokeCallback()

        //
        // Internal method for setting completion.
        // As a side effect, we'll signal the WaitHandle event and clean up.
        //
        private void Complete(bool completedSynchronously, object result) {
            m_Result = result;
            Complete(completedSynchronously);

        } // Complete()

        //
        // Internal method for setting completion.
        // As a side effect, we'll signal the WaitHandle event and clean up.
        //
        private void Complete(bool completedSynchronously) {
            m_CompletedSynchronously = completedSynchronously;
            Interlocked.Increment( ref m_IntCompleted );

            if (m_Event != null) {
                ((ManualResetEvent)m_Event).Set();
            }

            InternalCleanup();

        } // Complete()

        //
        // Custom cleanup routine that will be called upon completion
        // or on garbage collection.
        // Needs to be overridden if the object needs custom cleaned up.
        //
        internal virtual void Cleanup() {
            //
            // Override the empty cleanup if you need
            // custom actions
            //

        } // Cleanup()

        internal object InternalWaitForCompletion() {
            if (m_IntCompleted == 0) {
                //
                // Not done yet, so wait:
                // (this code takes advantage of lazy allocation of the event handle)
                //
                ManualResetEvent castedEvent = (ManualResetEvent)AsyncWaitHandle;

                GlobalLog.Print("LazyAsyncResult::InternalWaitForCompletion() Waiting for completion. this:" + ValidationHelper.HashString(this) + " m_Event:" + ValidationHelper.HashString(m_Event));

                castedEvent.WaitOne();
            }

            GlobalLog.Print("LazyAsyncResult::InternalWaitForCompletion() this:" + ValidationHelper.HashString(this) + " done");

            return m_Result;

        } // InternalWaitForCompletion()

        //
        // Custom cleanup routine that will be called upon completion
        // or on garbage collection.
        // Needs to be overridden if the object needs custom cleaned up.
        //
        private void InternalCleanup() {
            //
            // Override the empty cleanup if you need
            // custom actions
            //

            if (Interlocked.Increment(ref m_CleanedUp)==1) {
                Cleanup();
            }

        } // InternalCleanup()

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

    }; // class LazyAsyncResult



} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_listenerrequeststream.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ListenerRequestStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if COMNET_LISTENER

namespace System.Net {

    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Net.Sockets;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Security.Cryptography;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Threading;

    internal class ListenerRequestStream : Stream {

        //
        // constructor:
        //

        internal ListenerRequestStream(
            IntPtr appPoolHandle,
            long requestId,
            long contentLength,
            int bufferSize,
            IntPtr pBufferData,
            bool entityReadComplete ) {
            //
            // initialize private data
            //

            m_AppPoolHandle = appPoolHandle;
            m_RequestId = requestId;
            m_TotalLength = contentLength;
            m_ReadLength = bufferSize;
            m_MoreToRead = !entityReadComplete; // CODEWORK: should I really use this?

            //
            // initialize the private buffer
            //

            m_DataBufferOffset = 0;

            if (bufferSize > 0 && (long)pBufferData != 0) {
                m_BufferedDataExists = true;
                m_DataBuffer = new byte[ bufferSize ];
                Marshal.Copy( pBufferData, m_DataBuffer, 0, bufferSize );
            }
            else {
                m_BufferedDataExists = false;
                m_DataBuffer = null;
            }

            GlobalLog.Print("ListenerRequestStream initialized AppPoolHandle:" + Convert.ToString(m_AppPoolHandle) + " RequestId:" + Convert.ToString(m_RequestId) );
        }

        /*++

            Read property for this class. This class is always readable, so we
            returh true. This is a read only property.

            Input: Nothing.

            Returns: True.

         --*/

        public override bool CanRead {
            get {
                return true;
            }
        }

        /*++

            Seek property for this class. Since this stream is not
            seekable, we just return false. This is a read only property.

            Input: Nothing.

            Returns: false

         --*/

        public override bool CanSeek {
            get {
                return false;
            }
        }

        /*++

            Write property for this class. This stream is not writeable, so we
            return false. This is a read only property.

            Input: Nothing.

            Returns: False.

         --*/

        public override bool CanWrite {
            get {
                return false;
            }
        }


        /*++

            DataAvailable property for this class. This property check to see
            if at least one byte of data is currently available. This is a read
            only property.

            Input: Nothing.

            Returns: True if data is available, false otherwise.

         --*/

        public bool DataAvailable {
            get {
                // CODEWORK - not implemented yet.
                //

                return m_MoreToRead;
            }

        } // DataAvailable


        /*++
            Flush - Flush the stream

            Called when the user wants to flush the stream. This is meaningless to
            us, so we just ignore it.

            Input:

                Nothing.

            Returns:

                Nothing.



        --*/
        public override void
        Flush() {

        } // Flush()


        /*++

            Length property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Length {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }

        } // Length

        /*++

            Position property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Position {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }

            set {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }

        } // Position


        public override int Read(
            [In, Out] byte[] buffer,
            int offset,
            int count ) {

            GlobalLog.Print("ListenerRequestStream.ReadCore() offset: " + Convert.ToString(offset) + " count:" + Convert.ToString(count));            int DataCopiedFromBuffer = 0;
            int DataCopiedFromDriver = 0;

            //
            // see if we still have some data in the buffer
            //

            if (m_BufferedDataExists) {
                //
                // start sending data in the buffer
                //

                DataCopiedFromBuffer =
                Math.Min(
                        m_DataBuffer.Length - m_DataBufferOffset,
                        count );

                Buffer.BlockCopy(
                          m_DataBuffer,
                          m_DataBufferOffset,
                          buffer,
                          offset,
                          DataCopiedFromBuffer );

                //
                // update the offset for the buffered data for subsequent calls
                //

                m_DataBufferOffset += DataCopiedFromBuffer;
                m_BufferedDataExists = m_DataBuffer.Length > m_DataBufferOffset;

                //
                // update offset and count in the buffer for subsequent calls
                //

                offset += DataCopiedFromBuffer;
                count -= DataCopiedFromBuffer;
            }

            //
            // if all the data requested was handled by the buffered data we don't
            // need to call the driver for more, so we just return here
            //

            if (count <= 0 || !m_MoreToRead) {
                return DataCopiedFromBuffer;
            }

            //
            // otherwise pin the buffer and make an unmanaged call to the driver to
            // read more entity body
            //

            GCHandle PinnedBuffer;
            IntPtr AddrOfPinnedBuffer = IntPtr.Zero;

            PinnedBuffer = GCHandle.Alloc( buffer, GCHandleType.Pinned );
            AddrOfPinnedBuffer = PinnedBuffer.AddrOfPinnedObject();

            //
            // issue unmanaged blocking call
            //

            int result =
            ComNetOS.IsWinNt ?

            UlSysApi.UlReceiveEntityBody(
                                        m_AppPoolHandle,
                                        m_RequestId,
                                        UlConstants.UL_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                        AddrOfPinnedBuffer,
                                        count,
                                        ref DataCopiedFromDriver,
                                        IntPtr.Zero )

            :

            UlVxdApi.UlReceiveHttpRequestEntityBody(
                                                   m_AppPoolHandle,
                                                   m_RequestId,
                                                   0,
                                                   AddrOfPinnedBuffer,
                                                   count,
                                                   ref DataCopiedFromDriver,
                                                   IntPtr.Zero );

            PinnedBuffer.Free();

            if (result != NativeMethods.ERROR_SUCCESS && result != NativeMethods.ERROR_HANDLE_EOF) {
                //
                // Consider: move all Exception string to system.txt for localization
                //
                throw new InvalidOperationException( "UlReceiveEntityBody() failed, err#" + Convert.ToString( result ) );
            }

            return DataCopiedFromBuffer + DataCopiedFromDriver;

        } // Read()

        /*++
            Seek - Seek on the stream

            Called when the user wants to seek the stream. Since we don't support
            seek, we'll throw an exception.

            Input:

                offset      - offset to see
                origin      - where to start seeking

            Returns:

                Throws exception



        --*/
        public override long
        Seek(
            long offset,
            SeekOrigin origin ) {

            throw new NotSupportedException(SR.GetString(SR.net_noseek));

        } // Seek()

        /*++
            SetLength - Set the length on the stream

            Called when the user wants to set the stream length. Since we don't
            support seek, we'll throw an exception.

            Input:

                value       - length of stream to set

            Returns:

                Throws exception



        --*/
        public override void
        SetLength(
                 long value ) {

            throw new NotSupportedException(SR.GetString(SR.net_noseek));

        } // SetLength()

        /*++
            Close - Close the stream

            Called when the stream is closed.

            Input:

                Nothing.

            Returns:

                Nothing.



        --*/
        public override void
        Close() {

        } // Close()


        //
        // class members
        //

        private byte[] m_DataBuffer;
        private int m_DataBufferOffset;
        private bool m_BufferedDataExists;

        private IntPtr m_AppPoolHandle;
        private long m_RequestId;
        private long m_TotalLength;
        private long m_ReadLength;
        private bool m_MoreToRead;

    }; // class ListenerRequestStream


} // namespace System.Net

#endif // COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_listenerasyncresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ListenerAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if COMNET_LISTENER

namespace System.Net {

    using System.Threading;
    using System.Runtime.InteropServices;

    internal class ListenerAsyncResult : LazyAsyncResult {

        //
        // Constructor
        //
        internal ListenerAsyncResult(Object userState, AsyncCallback callback )
            : base( null, userState, callback ) {
            //
            // we will use this overlapped structure to issue async IO to ul
            // the event handle will be put in by the BeginXXX() method
            //

            m_BufferSize = UlConstants.InitialBufferSize;
            m_BytesReturned = 0;
            m_RequestId = 0;
            m_Retries = 0;
            m_UnmanagedBlob = Marshal.AllocHGlobal( Win32.OverlappedSize + m_BufferSize );
            m_Overlapped = m_UnmanagedBlob;
            m_Buffer = IntPtrHelper.Add(m_UnmanagedBlob, Win32.OverlappedSize);

            return;

        } // ListenerAsyncResult()



        //
        // Utility cleanup routine. Frees pinned and unmanged memory.
        //
        internal override void Cleanup() {
            if ((long)m_UnmanagedBlob != 0) {
                Marshal.FreeHGlobal(m_UnmanagedBlob);
                m_UnmanagedBlob = 0;
            }
            if ((long)m_Buffer != 0) {
                Marshal.FreeHGlobal(m_Buffer);
                m_UnmanagedBlob = 0;
            }
            base.Cleanup();

            return;

        } // Cleanup()

        //
        // class members
        //

        internal IntPtr m_Buffer;
        internal IntPtr m_Overlapped;
        internal IntPtr m_UnmanagedBlob;
        internal long m_RequestId;
        internal int m_BufferSize;
        internal int m_BytesReturned;
        internal int m_Retries;

    }; // class ListenerAsyncResult


} // namespace System.Net

#endif // COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_listenerresponsestream.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ListenerResponseStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if COMNET_LISTENER

namespace System.Net {

    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Net.Sockets;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Security.Cryptography;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Threading;

    internal class ListenerResponseStream : Stream {

        //
        // constructor:
        //

        internal ListenerResponseStream(
            IntPtr appPoolHandle,
            long requestId,
            long contentLength,
            bool sendChunked,
            bool keepAlive ) {
            //
            // validate
            //
            GlobalLog.Print("ListenerResponseStream initialized AppPoolHandle:" + Convert.ToString(m_AppPoolHandle) + " RequestId:" + Convert.ToString(m_RequestId));

            //
            // initialize private data
            //
            m_AppPoolHandle = appPoolHandle;
            m_RequestId = requestId;
            m_ContentLength = contentLength;
            m_SendChunked = sendChunked;
            m_KeepAlive = keepAlive;

        } // ListenerResponseStream()


        //
        // destructor:
        //
        ~ListenerResponseStream() {
            //
            // just call our explicit desctructor Close() and return
            //
            Close();
            return;
        }


        /*++

            Read property for this class. This class is never readable, so we
            returh false. This is a read only property.

            Input: Nothing.

            Returns: False.

         --*/

        public override bool CanRead {
            get {
                return false;
            }

        } // CanRead


        /*++

            Seek property for this class. Since this stream is not
            seekable, we just return false. This is a read only property.

            Input: Nothing.

            Returns: false

         --*/

        public override bool CanSeek {
            get {
                return false;
            }

        } // CanSeek


        /*++

            Write property for this class. This stream is writeable, so we
            return true. This is a read only property.

            Input: Nothing.

            Returns: True.

         --*/

        public override bool CanWrite {
            get {
                return true;
            }

        } // CanWrite


        /*++

            DataAvailable property for this class. This property check to see
            if at least one byte of data is currently available. This is a read
            only property. Since this stream is write-only, we return false.

            Input: Nothing.

            Returns: False.

         --*/

        public bool DataAvailable {
            get {
                return false;
            }

        } // DataAvailable


        /*++

            Flush - Flush the stream

            Called when the user wants to flush the stream. This is meaningless to
            us, so we just ignore it.

            Input: Nothing.

            Returns: Nothing.

        --*/

        public override void
        Flush() {

        } // Flush()


        /*++

            Length property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Length {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }

        } // Length


        /*++

            Position property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Position {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }

            set {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }

        } // Position


        //
        // write a chunk of data to ul
        //

        public override void Write(
             byte[] buffer,
             int offset,
             int count ) {

            GlobalLog.Print("ListenerResponseStream.WriteCore() offset: " + Convert.ToString(offset) + " count:" + Convert.ToString(count) );

            if (m_ContentLength != -1 && m_ContentLength < count) {
                //
                // user can't send more data than specified in the ContentLength
                //

                throw new ProtocolViolationException(SR.GetString(SR.net_entitytoobig));
            }

            int DataToWrite = count;

            GCHandle PinnedBuffer = new GCHandle();
            IntPtr AddrOfPinnedBuffer = IntPtr.Zero;

            if (m_SendChunked) {
                string ChunkHeader = "0x" + Convert.ToString( count, 16 );

                DataToWrite += ChunkHeader.Length + 4;

                AddrOfPinnedBuffer = Marshal.AllocHGlobal( DataToWrite );

                Marshal.Copy( ChunkHeader.ToCharArray(), 0, AddrOfPinnedBuffer, ChunkHeader.Length );
                Marshal.WriteInt16( AddrOfPinnedBuffer, ChunkHeader.Length, 0x0A0D);
                Marshal.Copy( (byte[])buffer, offset, IntPtrHelper.Add( AddrOfPinnedBuffer, ChunkHeader.Length + 2), count );
                Marshal.WriteInt16( AddrOfPinnedBuffer, DataToWrite - 2, 0x0A0D);
            }
            else {
                //
                // pin the buffer and make an unmanaged call to the driver to
                // write more entity body
                //

                PinnedBuffer = GCHandle.Alloc( buffer, GCHandleType.Pinned );
                AddrOfPinnedBuffer = PinnedBuffer.AddrOfPinnedObject();
            }


            //
            // set up a UL_DATA_CHUNK structure to pass down to UL with pointers
            // to data to be written
            //

            IntPtr AddrOfPinnedEntityChunks = Marshal.AllocHGlobal( 32 );

            //
            // AddrOfPinnedBuffer and count go into a pEntityChunks structure
            //

            Marshal.WriteInt64( AddrOfPinnedEntityChunks,  0, 0 );
            Marshal.WriteIntPtr( AddrOfPinnedEntityChunks, 8, AddrOfPinnedBuffer );
            Marshal.WriteInt32( AddrOfPinnedEntityChunks, 12, DataToWrite );
            Marshal.WriteInt64( AddrOfPinnedEntityChunks, 16, 0 );
            Marshal.WriteInt64( AddrOfPinnedEntityChunks, 24, 0 );

            GlobalLog.Print("Calling UlSendHttpResponseEntityBody: AddrOfPinnedEntityChunks:" + Convert.ToString(AddrOfPinnedEntityChunks)
                           + " AddrOfPinnedBuffer:" + Convert.ToString(AddrOfPinnedBuffer)
                           + " DataToWrite:" + Convert.ToString(DataToWrite) );

            //
            // issue unmanaged blocking call
            //

            int DataWritten = 0;

            int result =
            ComNetOS.IsWinNt ?

            UlSysApi.UlSendEntityBody(
                                     m_AppPoolHandle,
                                     m_RequestId,
                                     UlConstants.UL_SEND_RESPONSE_FLAG_MORE_DATA,
                                     1,
                                     AddrOfPinnedEntityChunks,
                                     ref DataWritten,
                                     IntPtr.Zero)

            :

            UlVxdApi.UlSendHttpResponseEntityBody(
                                                 m_AppPoolHandle,
                                                 m_RequestId,
                                                 0,
                                                 1,
                                                 AddrOfPinnedEntityChunks,
                                                 ref DataWritten,
                                                 IntPtr.Zero);

            if (m_SendChunked) {
                //
                // data was copied into an unmanaged buffer, free it
                //

                Marshal.FreeHGlobal( AddrOfPinnedBuffer );
            }
            else {
                //
                // data wasn't copied unpin the pinned buffer
                //

                PinnedBuffer.Free();
            }

            Marshal.FreeHGlobal( AddrOfPinnedEntityChunks );

            GlobalLog.Print("UlSendHttpResponseEntityBody() DataWritten:" + Convert.ToString( DataWritten ) + " DataToWrite:" + Convert.ToString( DataToWrite ) );

            if (result != NativeMethods.ERROR_SUCCESS) { //Win32.ERROR_CANCELLED || Win32.ERROR_BAD_COMMAND || NativeMethods.ERROR_INVALID_PARAMETER
                throw new ProtocolViolationException(SR.GetString(SR.net_connclosed) + Convert.ToString(result));
            }

            //
            // double check the number of bytes written
            //

            if (DataWritten != DataToWrite) {
                throw new InvalidOperationException( "sync UlSendHttpResponseEntityBody() failed to write all the data" +
                                              " count:" + Convert.ToString( count ) +
                                              " DataWritten:" + Convert.ToString( DataWritten ) +
                                              " DataToWrite:" + Convert.ToString( DataToWrite ) +
                                              " m_AppPoolHandle:" + Convert.ToString( m_AppPoolHandle ) +
                                              " m_RequestId:" + Convert.ToString( m_RequestId ) +
                                              " err#" + Convert.ToString( result ) );
            }

            if (result != NativeMethods.ERROR_SUCCESS && result != NativeMethods.ERROR_HANDLE_EOF) {
                //
                // Consider: move all Exception string to system.txt for localization
                //
                throw new InvalidOperationException( "sync UlSendHttpResponseEntityBody() failed, err#" + Convert.ToString( result ) );
            }

            if (m_ContentLength != -1) {
                //
                // keep track of the data transferred
                //

                m_ContentLength -= count;

                if (m_ContentLength == 0) {
                    //
                    // I should be able to call Close() at this point
                    //
                }
            }

            return; // DataToWrite;

        } // Write()


        private bool  m_Closed = false;
        public override void Close() {

            if (m_Closed) {
                return;
            }
            m_Closed = true;

            //
            // we need to flush ul in order to tell it that we have no more data
            // to send in the entity body, and if we're chunk-encoding we need to
            // send the trailer chunk
            //

            if (m_SendChunked == true) {
                //
                // send the trailer
                //

            }

            int DataWritten = 0;

            int result =
            ComNetOS.IsWinNt ?

            UlSysApi.UlSendEntityBody(
                                     m_AppPoolHandle,
                                     m_RequestId,
                                     0,
                                     0,
                                     IntPtr.Zero,
                                     ref DataWritten,
                                     IntPtr.Zero)

            :

            UlVxdApi.UlSendHttpResponseEntityBody(
                                                 m_AppPoolHandle,
                                                 m_RequestId,
                                                 0,
                                                 0,
                                                 IntPtr.Zero,
                                                 ref DataWritten,
                                                 IntPtr.Zero);

            GlobalLog.Print("UlSendHttpResponseEntityBody(0) DataWritten: " + Convert.ToString( DataWritten ) );

            //
            // ignore return value???
            //

            if (result != NativeMethods.ERROR_SUCCESS && result != NativeMethods.ERROR_HANDLE_EOF) {
                GlobalLog.Print("sync UlSendHttpResponseEntityBody(0) failed, err#" + Convert.ToString( result ) );

                // throw new InvalidOperationException( "UlSendHttpResponseEntityBody() failed, err#" + Convert.ToString( result ) );
            }

			return;
            
        } // Close()


        /*++

            Seek - Seek on the stream

            Called when the user wants to seek the stream. Since we don't support
            seek, we'll throw an exception.

            Input:

                offset      - offset to see
                origin      - where to start seeking

            Returns: Throws exception

        --*/

        public override long
        Seek(
            long offset,
            SeekOrigin origin ) {

            throw new NotSupportedException(SR.GetString(SR.net_noseek));

        } // Seek()


        /*++

            SetLength - Set the length on the stream

            Called when the user wants to set the stream length. Since we don't
            support seek, we'll throw an exception.

            Input:

                value       - length of stream to set

            Returns: Throws exception

        --*/

        public override void
        SetLength(
                 long value ) {
            throw new NotSupportedException(SR.GetString(SR.net_noseek));

        } // SetLength()


        //
        // class members
        //

        private long m_RequestId;
        private IntPtr m_AppPoolHandle;
        private long m_ContentLength;
        private bool m_SendChunked;
        private bool m_KeepAlive;

    }; // class ListenerResponseStream


} // namespace System.Net

#endif // COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_nativesspi.cs ===
//------------------------------------------------------------------------------
// <copyright file="_NativeSSPI.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Runtime.InteropServices;
    using System.Net.Sockets;

    //
    // used to define the interface for security to use.
    //
    internal interface SSPIInterface {

        SecurityPackageInfoClass[] SecurityPackages { get; set; }

        int
        EnumerateSecurityPackages(out int pkgnum,
                                  out IntPtr arrayptr);

        int
        FreeContextBuffer(IntPtr contextBuffer);

        int
        AcquireCredentialsHandle( string            principal,
                                  string            moduleName,
                                  int               usage,
                                  int               logonID,
                                  AuthIdentity      authdata,
                                  int               keyCallback,
                                  int               keyArgument,
                                  ref long          handle,
                                  ref long          timestamp);


        int
        AcquireCredentialsHandle( string            principal,
                                  string            moduleName,
                                  int               usage,
                                  int               logonID,
                                  int               keyCallback,
                                  int               keyArgument,
                                  ref long          handle,
                                  ref long          timestamp);

        int
        AcquireCredentialsHandle( string            principal,
                                  string            moduleName,
                                  int               usage,
                                  int               logonID,
                                  ref SChannelCred  authdata,
                                  int               keyCallback,
                                  int               keyArgument,
                                  ref long          handle,
                                  ref long          timestamp);

        int
        FreeCredentialsHandle(ref long handle);

        //
        // we have two interfaces to this method call.
        // we will use the first one when we want to pass in a null
        // for the "context" and "inputBuffer" parameters
        //
        int
        InitializeSecurityContext(
                                  ref long          credentialHandle,
                                  IntPtr            context,
                                  string            targetName,
                                  int               requirements,
                                  int               reservedI,
                                  int               endianness,
                                  IntPtr            inputBuffer,
                                  int               reservedII,
                                  ref long          newContext,
                                  ref SecurityBufferDescriptor outputBuffer,
                                  ref int           attributes,
                                  ref long          timestamp);

        int
        InitializeSecurityContext(
                                  ref long          credentialHandle,
                                  ref long          context,
                                  string            targetName,
                                  int               requirements,
                                  int               reservedI,
                                  int               endianness,
                                  ref SecurityBufferDescriptor inputBuffer,
                                  int               reservedII,
                                  ref long          newContext,
                                  ref SecurityBufferDescriptor outputBuffer,
                                  ref int           attributes,
                                  ref long          timestamp);


        int
        DeleteSecurityContext(ref long handle);

        int
        EncryptMessage(ref long             contextHandle,
                       int                  qualityOfProtection,
                       ref SecurityBufferDescriptor    input,
                       int                  sequenceNumber);

        int
        DecryptMessage(ref long             contextHandle,
                       int                  qualityOfProtection,
                       ref SecurityBufferDescriptor    input,
                       int                  sequenceNumber);


        int
        SealMessage(ref long            contextHandle,
                    int                 qualityOfProtection,
                    ref SecurityBufferDescriptor   input,
                    int                 sequenceNumber);

        int
        UnsealMessage(ref long          contextHandle,
                      ref SecurityBufferDescriptor input,
                      int               qualityOfProtection,
                      int               sequenceNumber);

        SecurityStatus
        QueryContextAttributes(ref long ContextHandle,
                               int ulAttribute,
                               ref IntPtr name);

        int
        QueryContextAttributes(ref long phContext,
                               int      attribute,
                               IntPtr      buffer);

        int
        QueryCredentialAttributes(ref long  phContext,
                                  int       attribute,
                                  IntPtr       buffer);

#if SERVER_SIDE_SSPI
        int
        RevertSecurityContext(ref long phContext);

        int
        ImpersonateSecurityContext(ref long phContext);

        int
        AcceptSecurityContext( ref long             credentialHandle,
                               int                  context,
                               int                  inputBuffer,
                               int                  requirements,
                               int                  endianness,
                               ref long             newContext,
                               ref SecurityBufferDescriptor    outputBuffer,
                               out int              attributes,
                               out long             timestamp);

        int
        AcceptSecurityContext( ref long             credentialHandle,
                               ref long             context,
                               ref SecurityBufferDescriptor    inputBuffer,
                               int                  requirements,
                               int                  endianness,
                               ref long             newContext,
                               ref SecurityBufferDescriptor    outputBuffer,
                               out int              attributes,
                               out long             timestamp);
#endif // SERVER_SIDE_SSPI
    } // SSPI Interface

    // ******************
    // for SSL connections, use Schannel on Win9x, NT we don't care,
    //  since its the same DLL
    // ******************

    internal class SSPISecureChannelType : SSPIInterface {

        private static SecurityPackageInfoClass[] m_SecurityPackages;

        public SecurityPackageInfoClass[] SecurityPackages {
            get {
                return m_SecurityPackages; }
            set {
                m_SecurityPackages = value;
            }
        }

        public int
        EnumerateSecurityPackages(out int pkgnum,
                                  out IntPtr arrayptr)
        {
            GlobalLog.Print("SSPISecureChannelType::EnumerateSecurityPackages()");
            if ( ComNetOS.IsWin9x ) {
                GlobalLog.Print("  calling UnsafeNclNativeMethods.NativeSSLWin9xSSPI.EnumerateSecurityPackagesA()");
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.EnumerateSecurityPackagesA(
                    out pkgnum,
                    out arrayptr
                    );
            } else {
                GlobalLog.Print("  calling UnsafeNclNativeMethods.NativeNTSSPI.EnumerateSecurityPackagesW()");
                return UnsafeNclNativeMethods.NativeNTSSPI.EnumerateSecurityPackagesW(
                    out pkgnum,
                    out arrayptr
                    );
            }
        }


        public int
        FreeContextBuffer(IntPtr contextBuffer)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.FreeContextBuffer(contextBuffer);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.FreeContextBuffer(contextBuffer);
            }
        }


        public int
        AcquireCredentialsHandle(string            principal,
                                 string            moduleName,
                                 int               usage,
                                 int               logonID,
                                 AuthIdentity      authdata,
                                 int               keyCallback,
                                 int               keyArgument,
                                 ref long          handle,
                                 ref long          timestamp)
        {

            GlobalLog.Print("ComNetOS.IsWin9x = " + ComNetOS.IsWin9x);
            GlobalLog.Print("module name = " + moduleName);
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.AcquireCredentialsHandleA(
                                  principal,
                                  moduleName,
                                  usage,
                                  logonID,
                                  ref authdata,
                                  keyCallback,
                                  keyArgument,
                                  ref handle,
                                  ref timestamp
                                  );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.AcquireCredentialsHandleW(
                                  principal,
                                  moduleName,
                                  usage,
                                  logonID,
                                  ref authdata,
                                  keyCallback,
                                  keyArgument,
                                  ref handle,
                                  ref timestamp
                                  );
            }
        }


        public int
        AcquireCredentialsHandle(string            principal,
                                 string            moduleName,
                                 int               usage,
                                 int               logonID,
                                 int               keyCallback,
                                 int               keyArgument,
                                 ref long          handle,
                                 ref long          timestamp)
        {

            GlobalLog.Print("ComNetOS.IsWin9x = " + ComNetOS.IsWin9x);
            GlobalLog.Print("module name = " + moduleName);
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.AcquireCredentialsHandleA(
                                  principal,
                                  moduleName,
                                  usage,
                                  logonID,
                                  IntPtr.Zero,
                                  keyCallback,
                                  keyArgument,
                                  ref handle,
                                  ref timestamp
                                  );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.AcquireCredentialsHandleW(
                                  principal,
                                  moduleName,
                                  usage,
                                  logonID,
                                  IntPtr.Zero,
                                  keyCallback,
                                  keyArgument,
                                  ref handle,
                                  ref timestamp
                                  );
            }
        }


        public int
        AcquireCredentialsHandle(string            principal,
                                 string            moduleName,
                                 int               usage,
                                 int               logonID,
                                 ref SChannelCred  authdata,
                                 int               keyCallback,
                                 int               keyArgument,
                                 ref long          handle,
                                 ref long          timestamp)
        {
            GlobalLog.Enter("SSPISecureChannelType::AcquireCredentialsHandle#3");
            GlobalLog.Print("calling UnsafeNclNativeMethods.Native"+(ComNetOS.IsWin9x ? "SSLWin9x" : "NT")+"SSPI.AcquireCredentialsHandle()");
            GlobalLog.Print("    principal   = \"" + principal + "\"");
            GlobalLog.Print("    moduleName  = \"" + moduleName + "\"");
            GlobalLog.Print("    usage       = 0x" + String.Format("{0:x}", usage));
            GlobalLog.Print("    logonID     = 0x" + String.Format("{0:x}", logonID));
            GlobalLog.Print("    authdata    = " + authdata);
            GlobalLog.Print("    keyCallback = " + keyCallback);
            GlobalLog.Print("    keyArgument = " + keyArgument);
            GlobalLog.Print("    handle      = {ref}");
            GlobalLog.Print("    timestamp   = {ref}");
            authdata.DebugDump();

            int result;

            if ( ComNetOS.IsWin9x ) {
                result = UnsafeNclNativeMethods.NativeSSLWin9xSSPI.AcquireCredentialsHandleA(
                                 principal,
                                 moduleName,
                                 usage,
                                 logonID,
                                 ref authdata,
                                 keyCallback,
                                 keyArgument,
                                 ref handle,
                                 ref timestamp
                                 );
            } else {
                result = UnsafeNclNativeMethods.NativeNTSSPI.AcquireCredentialsHandleW(
                                 principal,
                                 moduleName,
                                 usage,
                                 logonID,
                                 ref authdata,
                                 keyCallback,
                                 keyArgument,
                                 ref handle,
                                 ref timestamp
                                 );
            }
            GlobalLog.Leave("SSPISecureChannelType::AcquireCredentialsHandle#3", result);
            return result;
        }


        public int
        FreeCredentialsHandle(ref long handle)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.FreeCredentialsHandle(ref handle);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.FreeCredentialsHandle(ref handle);
            }
        }


        //
        // we have two interfaces to this method call.
        // we will use the first one when we want to pass in a null
        // for the "context" and "inputBuffer" parameters
        //

        public int
        InitializeSecurityContext(
                                  ref long          credentialHandle,
                                  IntPtr            context,
                                  string            targetName,
                                  int               requirements,
                                  int               reservedI,
                                  int               endianness,
                                  IntPtr            inputBuffer,
                                  int               reservedII,
                                  ref long          newContext,
                                  ref SecurityBufferDescriptor outputBuffer,
                                  ref int           attributes,
                                  ref long          timestamp)
        {
#if TRAVE
            GlobalLog.Enter("SSPISecureChannelType::InitializeSecurityContext#1()");
            GlobalLog.Print("calling UnsafeNclNativeMethods.Native"+(ComNetOS.IsWin9x ? "SSLWin9x" : "NT")+"SSPI.InitializeSecurityContext()");
            GlobalLog.Print("    credentialHandle = " + String.Format("0x{0:x}", credentialHandle));
            GlobalLog.Print("    context          = " + String.Format("0x{0:x}", context));
            GlobalLog.Print("    targetName       = \"" + targetName + "\"");
            GlobalLog.Print("    requirements     = " + String.Format("0x{0:x}", requirements) + " [" + SecureChannel.MapInputContextAttributes(requirements) + "]");
            GlobalLog.Print("    reservedI        = " + String.Format("0x{0:x}", reservedI));
            GlobalLog.Print("    endianness       = " + String.Format("0x{0:x}", endianness));
            GlobalLog.Print("    inputBuffer      = " + String.Format("0x{0:x}", inputBuffer));
            GlobalLog.Print("    reservedII       = " + String.Format("0x{0:x}", reservedII));
            GlobalLog.Print("    newContext       = {ref}");
            GlobalLog.Print("    outputBuffer     = {ref}");
            GlobalLog.Print("    attributes       = {ref}");
            GlobalLog.Print("    timestamp        = {ref}");
#endif

            int result;

            if ( ComNetOS.IsWin9x ) {
                result = UnsafeNclNativeMethods.NativeSSLWin9xSSPI.InitializeSecurityContextA(
                                              ref credentialHandle,
                                              context,
                                              targetName,
                                              requirements,
                                              reservedI,
                                              endianness,
                                              inputBuffer,
                                              reservedII,
                                              ref newContext,
                                              ref outputBuffer,
                                              ref attributes,
                                              ref timestamp
                                              );

            } else {
                result = UnsafeNclNativeMethods.NativeNTSSPI.InitializeSecurityContextW(
                                        ref credentialHandle,
                                        context,
                                        targetName,
                                        requirements,
                                        reservedI,
                                        endianness,
                                        inputBuffer,
                                        reservedII,
                                        ref newContext,
                                        ref outputBuffer,
                                        ref attributes,
                                        ref timestamp
                                        );
            }
#if TRAVE
            GlobalLog.Print("InitializeSecurityContext() returns " + SecureChannel.MapSecurityStatus((uint)result));
            if (result >= 0) {
                GlobalLog.Print("    newContext       = " + String.Format("0x{0:x}", newContext));
                GlobalLog.Print("    outputBuffer     = " + outputBuffer);
                GlobalLog.Print("    attributes       = " + String.Format("0x{0:x}", attributes) + " [" + SecureChannel.MapOutputContextAttributes(attributes) + "]");
                GlobalLog.Print("    timestamp        = " + String.Format("0x{0:x}", timestamp));
                outputBuffer.DebugDump();
            }
            GlobalLog.Leave("SSPISecureChannelType::InitializeSecurityContext#1()", String.Format("0x{0:x}", result));
#endif
            return result;
        }

        public int
        InitializeSecurityContext(
                                  ref long          credentialHandle,
                                  ref long          context,
                                  string            targetName,
                                  int               requirements,
                                  int               reservedI,
                                  int               endianness,
                                  ref SecurityBufferDescriptor inputBuffer,
                                  int               reservedII,
                                  ref long          newContext,
                                  ref SecurityBufferDescriptor outputBuffer,
                                  ref int           attributes,
                                  ref long          timestamp)
        {
#if TRAVE
            GlobalLog.Enter("SSPISecureChannelType::InitializeSecurityContext#2()");
            GlobalLog.Print("calling UnsafeNclNativeMethods.Native"+(ComNetOS.IsWin9x ? "SSLWin9x" : "NT")+"SSPI.InitializeSecurityContext()");
            GlobalLog.Print("    credentialHandle = " + String.Format("0x{0:x}", credentialHandle));
            GlobalLog.Print("    context          = " + String.Format("0x{0:x}", context));
            GlobalLog.Print("    targetName       = \"" + targetName + "\"");
            GlobalLog.Print("    requirements     = " + String.Format("0x{0:x}", requirements) + " [" + SecureChannel.MapInputContextAttributes(requirements) + "]");
            GlobalLog.Print("    reservedI        = " + String.Format("0x{0:x}", reservedI));
            GlobalLog.Print("    endianness       = " + String.Format("0x{0:x}", endianness));
            GlobalLog.Print("    inputBuffer      = " + inputBuffer);
            GlobalLog.Print("    reservedII       = " + String.Format("0x{0:x}", reservedII));
            GlobalLog.Print("    newContext       = {ref}");
            GlobalLog.Print("    outputBuffer     = {ref}");
            GlobalLog.Print("    attributes       = {ref}");
            GlobalLog.Print("    timestamp        = {ref}");
            inputBuffer.DebugDump();
#endif

            int result;

            if ( ComNetOS.IsWin9x ) {
                result = UnsafeNclNativeMethods.NativeSSLWin9xSSPI.InitializeSecurityContextA(
                                  ref credentialHandle,
                                  ref context,
                                  targetName,
                                  requirements,
                                  reservedI,
                                  endianness,
                                  ref inputBuffer,
                                  reservedII,
                                  ref newContext,
                                  ref outputBuffer,
                                  ref attributes,
                                  ref timestamp
                                  );
            } else {
                result = UnsafeNclNativeMethods.NativeNTSSPI.InitializeSecurityContextW(
                                  ref credentialHandle,
                                  ref context,
                                  targetName,
                                  requirements,
                                  reservedI,
                                  endianness,
                                  ref inputBuffer,
                                  reservedII,
                                  ref newContext,
                                  ref outputBuffer,
                                  ref attributes,
                                  ref timestamp
                                  );
            }
#if TRAVE
            GlobalLog.Print("InitializeSecurityContext() returns " + SecureChannel.MapSecurityStatus((uint)result));
            if (result >= 0) {
                GlobalLog.Print("    newContext       = " + String.Format("0x{0:x}", newContext));
                GlobalLog.Print("    outputBuffer     = " + outputBuffer);
                GlobalLog.Print("    attributes       = " + String.Format("0x{0:x}", attributes) + " [" + SecureChannel.MapOutputContextAttributes(attributes) + "]");
                GlobalLog.Print("    timestamp        = " + String.Format("0x{0:x}", timestamp));
                outputBuffer.DebugDump();
            }
            GlobalLog.Leave("SSPISecureChannelType::InitializeSecurityContext#2()", String.Format("0x{0:x}", result));
#endif
            return result;
        }



        public int
        DeleteSecurityContext(ref long handle)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.DeleteSecurityContext(ref handle);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.DeleteSecurityContext(ref handle);
            }
        }


        public int
        EncryptMessage(ref long             contextHandle,
                       int                  qualityOfProtection,
                       ref SecurityBufferDescriptor    input,
                       int                  sequenceNumber)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.EncryptMessage(
                           ref contextHandle,
                           qualityOfProtection,
                           ref input,
                           sequenceNumber
                           );

            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.EncryptMessage(
                           ref contextHandle,
                           qualityOfProtection,
                           ref input,
                           sequenceNumber
                           );
            }
        }


        public int
        DecryptMessage(ref long             contextHandle,
                       int                  qualityOfProtection,
                       ref SecurityBufferDescriptor    input,
                       int                  sequenceNumber)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.DecryptMessage(
                           ref contextHandle,
                           qualityOfProtection,
                           ref input,
                           sequenceNumber
                           );

            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.DecryptMessage(
                           ref contextHandle,
                           qualityOfProtection,
                           ref input,
                           sequenceNumber
                           );
            }
        }



        public int
        SealMessage(ref long            contextHandle,
                    int                 qualityOfProtection,
                    ref SecurityBufferDescriptor   input,
                    int                 sequenceNumber)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.SealMessage(
                    ref contextHandle,
                    qualityOfProtection,
                    ref input,
                    sequenceNumber
                    );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.SealMessage(
                    ref contextHandle,
                    qualityOfProtection,
                    ref input,
                    sequenceNumber
                    );
            }
        }


        public int
        UnsealMessage(ref long          contextHandle,
                      ref SecurityBufferDescriptor input,
                      int               qualityOfProtection,
                      int               sequenceNumber)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.UnsealMessage(
                                  ref contextHandle,
                                  ref input,
                                  qualityOfProtection,
                                  sequenceNumber
                                  );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.UnsealMessage(
                                  ref contextHandle,
                                  ref input,
                                  qualityOfProtection,
                                  sequenceNumber
                                  );
            }
        }


        public SecurityStatus
        QueryContextAttributes(ref long ContextHandle,
                               int ulAttribute,
                               ref IntPtr name)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.QueryContextAttributes(
                               ref ContextHandle,
                               ulAttribute,
                               ref name
                               );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.QueryContextAttributes(
                               ref ContextHandle,
                               ulAttribute,
                               ref name
                               );
            }
        }


        public int
        QueryContextAttributes(ref long phContext,
                               int      attribute,
                               IntPtr      buffer)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.QueryContextAttributes(
                               ref phContext,
                               attribute,
                               buffer
                               );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.QueryContextAttributes(
                               ref phContext,
                               attribute,
                               buffer
                               );
            }
        }


        public int
        QueryCredentialAttributes(ref long  phContext,
                                  int       attribute,
                                  IntPtr       buffer)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.QueryCredentialAttributes(
                                  ref phContext,
                                  attribute,
                                  buffer
                                  );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.QueryCredentialAttributes(
                                  ref phContext,
                                  attribute,
                                  buffer
                                  );
            }
        }

#if SERVER_SIDE_SSPI
        public int
        RevertSecurityContext(ref long phContext)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.RevertSecurityContext(ref phContext);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.RevertSecurityContext(ref phContext);
            }
        }

        public int
        ImpersonateSecurityContext(ref long phContext)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.ImpersonateSecurityContext(ref phContext);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.ImpersonateSecurityContext(ref phContext);
            }
        }

        public int
        AcceptSecurityContext( ref long             credentialHandle,
                               int                  context,
                               int                  inputBuffer,
                               int                  requirements,
                               int                  endianness,
                               ref long             newContext,
                               ref SecurityBufferDescriptor    outputBuffer,
                               out int              attributes,
                               out long             timestamp)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.AcceptSecurityContext(
                               ref credentialHandle,
                               context,
                               inputBuffer,
                               requirements,
                               endianness,
                               ref newContext,
                               ref outputBuffer,
                               out attributes,
                               out timestamp
                               );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.AcceptSecurityContext(
                               ref credentialHandle,
                               context,
                               inputBuffer,
                               requirements,
                               endianness,
                               ref newContext,
                               ref outputBuffer,
                               out attributes,
                               out timestamp
                               );
            }
        }


        public int
        AcceptSecurityContext( ref long             credentialHandle,
                               ref long             context,
                               ref SecurityBufferDescriptor    inputBuffer,
                               int                  requirements,
                               int                  endianness,
                               ref long             newContext,
                               ref SecurityBufferDescriptor    outputBuffer,
                               out int              attributes,
                               out long             timestamp)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeSSLWin9xSSPI.AcceptSecurityContext(
                               ref credentialHandle,
                               ref context,
                               ref inputBuffer,
                               requirements,
                               endianness,
                               ref newContext,
                               ref outputBuffer,
                               out attributes,
                               out timestamp
                               );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.AcceptSecurityContext(
                               ref credentialHandle,
                               ref context,
                               ref inputBuffer,
                               requirements,
                               endianness,
                               ref newContext,
                               ref outputBuffer,
                               out attributes,
                               out timestamp
                               );
            }
        }
#endif // SERVER_SIDE_SSPI
    }


    // *************
    // For Authenticiation like Kerberos or NTLM
    // *************

    internal class SSPIAuthType : SSPIInterface {

        private static SecurityPackageInfoClass[] m_SecurityPackages;

        public SecurityPackageInfoClass[] SecurityPackages {
            get {
                return m_SecurityPackages; }
            set {
                m_SecurityPackages = value;
            }
        }

        public int
        EnumerateSecurityPackages(out int pkgnum,
                                  out IntPtr arrayptr)
        {
            GlobalLog.Print("SSPIAuthType::EnumerateSecurityPackages()");
            if ( ComNetOS.IsWin9x ) {
                GlobalLog.Print("  calling UnsafeNclNativeMethods.NativeAuthWin9xSSPI.EnumerateSecurityPackagesA()");
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.EnumerateSecurityPackagesA(
                    out pkgnum,
                    out arrayptr
                    );
            } else {
                GlobalLog.Print("  calling UnsafeNclNativeMethods.NativeNTSSPI.EnumerateSecurityPackagesW()");
                return UnsafeNclNativeMethods.NativeNTSSPI.EnumerateSecurityPackagesW(
                    out pkgnum,
                    out arrayptr
                    );
            }
        }


        public int
        FreeContextBuffer(IntPtr contextBuffer)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.FreeContextBuffer(contextBuffer);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.FreeContextBuffer(contextBuffer);
            }
        }


        public int
        AcquireCredentialsHandle(string principal,
                                 string moduleName,
                                 int usage,
                                 int logonID,
                                 AuthIdentity authdata,
                                 int keyCallback,
                                 int keyArgument,
                                 ref long handle,
                                 ref long timestamp
                                 )
        {
            GlobalLog.Print("SSPIAuthType::AcquireCredentialsHandle#1("
                            + principal + ", "
                            + moduleName + ", "
                            + usage + ", "
                            + logonID + ", "
                            + authdata + ", "
                            + keyCallback + ", "
                            + keyArgument + ", "
                            + "ref handle" + ", "
                            + "ref timestamp" + ")"
                            );
            if (ComNetOS.IsWin9x) {
                GlobalLog.Print("calling AuthWin95SSPI");
                GlobalLog.Print("mod name = " + moduleName);

                int err = UnsafeNclNativeMethods.NativeAuthWin9xSSPI.AcquireCredentialsHandleA(
                                                principal,
                                                moduleName,
                                                usage,
                                                logonID,
                                                ref authdata,
                                                keyCallback,
                                                keyArgument,
                                                ref handle,
                                                ref timestamp
                                                );

                GlobalLog.Print("UnsafeNclNativeMethods.NativeAuthWin9xSSPI::AcquireCredentialsHandleA() returns 0x" + String.Format("{0:x}", err) + ", handle = 0x" + String.Format("{0:x}", handle));
                return err;
            } else {
                GlobalLog.Print("calling UnsafeNclNativeMethods.NativeNTSSPI::AcquireCredentialsHandleW()");

                int err = UnsafeNclNativeMethods.NativeNTSSPI.AcquireCredentialsHandleW(principal,
                                                                 moduleName,
                                                                 usage,
                                                                 logonID,
                                                                 ref authdata,
                                                                 keyCallback,
                                                                 keyArgument,
                                                                 ref handle,
                                                                 ref timestamp
                                                                 );
                GlobalLog.Print("UnsafeNclNativeMethods.NativeNTSSPI::AcquireCredentialsHandleW() returns 0x"
                                + String.Format("{0:x}", err)
                                + ", handle = 0x" + String.Format("{0:x}", handle)
                                + ", timestamp = 0x" + String.Format("{0:x}", timestamp)
                                );
                return err;
            }
        }


        public int
        AcquireCredentialsHandle(string principal,
                                 string moduleName,
                                 int usage,
                                 int logonID,
                                 int keyCallback,
                                 int keyArgument,
                                 ref long handle,
                                 ref long timestamp
                                 )
        {
            GlobalLog.Print("SSPIAuthType::AcquireCredentialsHandle#1("
                            + principal + ", "
                            + moduleName + ", "
                            + usage + ", "
                            + logonID + ", "
                            + keyCallback + ", "
                            + keyArgument + ", "
                            + "ref handle" + ", "
                            + "ref timestamp" + ")"
                            );
            if (ComNetOS.IsWin9x) {
                GlobalLog.Print("calling AuthWin95SSPI");
                GlobalLog.Print("mod name = " + moduleName);

                int err = UnsafeNclNativeMethods.NativeAuthWin9xSSPI.AcquireCredentialsHandleA(
                                                principal,
                                                moduleName,
                                                usage,
                                                logonID,
                                                IntPtr.Zero,
                                                keyCallback,
                                                keyArgument,
                                                ref handle,
                                                ref timestamp
                                                );

                GlobalLog.Print("UnsafeNclNativeMethods.NativeAuthWin9xSSPI::AcquireCredentialsHandleA() returns 0x" + String.Format("{0:x}", err) + ", handle = 0x" + String.Format("{0:x}", handle));
                return err;
            } else {
                GlobalLog.Print("calling UnsafeNclNativeMethods.NativeNTSSPI::AcquireCredentialsHandleW()");

                int err = UnsafeNclNativeMethods.NativeNTSSPI.AcquireCredentialsHandleW(principal,
                                                                 moduleName,
                                                                 usage,
                                                                 logonID,
                                                                 IntPtr.Zero,
                                                                 keyCallback,
                                                                 keyArgument,
                                                                 ref handle,
                                                                 ref timestamp
                                                                 );
                GlobalLog.Print("UnsafeNclNativeMethods.NativeNTSSPI::AcquireCredentialsHandleW() returns 0x"
                                + String.Format("{0:x}", err)
                                + ", handle = 0x" + String.Format("{0:x}", handle)
                                + ", timestamp = 0x" + String.Format("{0:x}", timestamp)
                                );
                return err;
            }
        }


        public int
        AcquireCredentialsHandle(string            principal,
                                 string            moduleName,
                                 int               usage,
                                 int               logonID,
                                 ref SChannelCred  authdata,
                                 int               keyCallback,
                                 int               keyArgument,
                                 ref long          handle,
                                 ref long          timestamp)
        {
            GlobalLog.Print("SSPIAuthType::AcquireCredentialsHandle#2()");
            GlobalLog.Print("module name = " + moduleName);

            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.AcquireCredentialsHandleA(
                                 principal,
                                 moduleName,
                                 usage,
                                 logonID,
                                 ref authdata,
                                 keyCallback,
                                 keyArgument,
                                 ref handle,
                                 ref timestamp
                                 );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.AcquireCredentialsHandleW(
                                 principal,
                                 moduleName,
                                 usage,
                                 logonID,
                                 ref authdata,
                                 keyCallback,
                                 keyArgument,
                                 ref handle,
                                 ref timestamp
                                 );
            }
        }

        public int
        FreeCredentialsHandle(ref long handle)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.FreeCredentialsHandle(ref handle);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.FreeCredentialsHandle(ref handle);
            }
        }


        //
        // we have two interfaces to this method call.
        // we will use the first one when we want to pass in a null
        // for the "context" and "inputBuffer" parameters
        //

        public int
        InitializeSecurityContext(
                                  ref long          credentialHandle,
                                  IntPtr            context,
                                  string            targetName,
                                  int               requirements,
                                  int               reservedI,
                                  int               endianness,
                                  IntPtr            inputBuffer,
                                  int               reservedII,
                                  ref long          newContext,
                                  ref SecurityBufferDescriptor outputBuffer,
                                  ref int           attributes,
                                  ref long          timestamp)
        {
            GlobalLog.Print("SSPIAuthType::InitializeSecurityContext#1()");
            GlobalLog.Print("calling UnsafeNclNativeMethods.NativeNTSSPI.InitializeSecurityContextW()");
            GlobalLog.Print("    credentialHandle = 0x" + String.Format("{0:x}", credentialHandle));
            GlobalLog.Print("    context          = 0x" + String.Format("{0:x}", context));
            GlobalLog.Print("    targetName       = " + targetName);
            GlobalLog.Print("    requirements     = 0x" + String.Format("{0:x}", requirements));
            GlobalLog.Print("    reservedI        = 0x" + String.Format("{0:x}", reservedI));
            GlobalLog.Print("    endianness       = " + endianness.ToString());
            GlobalLog.Print("    inputBuffer      = {ref} 0x" + String.Format("{0:x}", inputBuffer));
            GlobalLog.Print("    reservedII       = " + reservedII);
            GlobalLog.Print("    newContext       = {ref} 0x" + String.Format("{0:x}", newContext));
            GlobalLog.Print("    outputBuffer     = {ref}");
            GlobalLog.Print("    attributes       = {ref} " + attributes.ToString());
            GlobalLog.Print("    timestamp        = {ref} 0x" + String.Format("{0:x}", timestamp));

            if ( ComNetOS.IsWin9x ) {
                GlobalLog.Print("calling UnsafeNclNativeMethods.NativeSSLWin9xSSPI.InitializeSecurityContextA()");
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.InitializeSecurityContextA(
                                  ref credentialHandle,
                                  context,
                                  targetName,
                                  requirements,
                                  reservedI,
                                  endianness,
                                  inputBuffer,
                                  reservedII,
                                  ref newContext,
                                  ref outputBuffer,
                                  ref attributes,
                                  ref timestamp
                                  );

            } else {
                GlobalLog.Print("calling UnsafeNclNativeMethods.NativeNTSSPI.InitializeSecurityContextW()");
                return UnsafeNclNativeMethods.NativeNTSSPI.InitializeSecurityContextW(
                                  ref credentialHandle,
                                  context,
                                  targetName,
                                  requirements,
                                  reservedI,
                                  endianness,
                                  inputBuffer,
                                  reservedII,
                                  ref newContext,
                                  ref outputBuffer,
                                  ref attributes,
                                  ref timestamp
                                  );
            }
        }


        public int
        InitializeSecurityContext(ref long credentialHandle,
                                  ref long context,
                                  string targetName,
                                  int requirements,
                                  int reservedI,
                                  int endianness,
                                  ref SecurityBufferDescriptor inputBuffer,
                                  int reservedII,
                                  ref long newContext,
                                  ref SecurityBufferDescriptor outputBuffer,
                                  ref int attributes,
                                  ref long timestamp
                                  )
        {
            GlobalLog.Print("SSPIAuthType::InitializeSecurityContext#2()");
            if ( ComNetOS.IsWin9x ) {
                GlobalLog.Print("calling UnsafeNclNativeMethods.NativeSSLWin9xSSPI.InitializeSecurityContextA()");
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.InitializeSecurityContextA(
                                  ref credentialHandle,
                                  ref context,
                                  targetName,
                                  requirements,
                                  reservedI,
                                  endianness,
                                  ref inputBuffer,
                                  reservedII,
                                  ref newContext,
                                  ref outputBuffer,
                                  ref attributes,
                                  ref timestamp
                                  );
            } else {
                GlobalLog.Print("calling UnsafeNclNativeMethods.NativeNTSSPI.InitializeSecurityContextW()");
                GlobalLog.Print("    credentialHandle = 0x" + String.Format("{0:x}", credentialHandle));
                GlobalLog.Print("    context          = 0x" + String.Format("{0:x}", context));
                GlobalLog.Print("    targetName       = " + targetName);
                GlobalLog.Print("    requirements     = 0x" + String.Format("{0:x}", requirements));
                GlobalLog.Print("    reservedI        = 0x" + String.Format("{0:x}", reservedI));
                GlobalLog.Print("    endianness       = " + endianness);
                GlobalLog.Print("    inputBuffer      = {ref}");
                GlobalLog.Print("    reservedII       = " + reservedII);
                GlobalLog.Print("    newContext       = {ref}");
                GlobalLog.Print("    outputBuffer     = {ref}");
                GlobalLog.Print("    attributes       = {ref}");
                GlobalLog.Print("    timestamp        = {ref}");

                int error = UnsafeNclNativeMethods.NativeNTSSPI.InitializeSecurityContextW(
                                            ref credentialHandle,
                                            ref context,
                                            targetName,
                                            requirements,
                                            reservedI,
                                            endianness,
                                            ref inputBuffer,
                                            reservedII,
                                            ref newContext,
                                            ref outputBuffer,
                                            ref attributes,
                                            ref timestamp
                                            );

                GlobalLog.Print("UnsafeNclNativeMethods.NativeNTSSPI.InitializeSecurityContextW() returns 0x" + String.Format("{0:x}", error));
                return error;
            }
        }

        public int DeleteSecurityContext(ref long handle) {
            if (ComNetOS.IsWin9x) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.DeleteSecurityContext(ref handle);
            } else {
                GlobalLog.Print("SSPIAuthType::DeleteSecurityContext(0x" + String.Format("{0:x}", handle) + ")");
                return UnsafeNclNativeMethods.NativeNTSSPI.DeleteSecurityContext(ref handle);
            }
        }


        public int
        EncryptMessage(ref long             contextHandle,
                       int                  qualityOfProtection,
                       ref SecurityBufferDescriptor    input,
                       int                  sequenceNumber)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.EncryptMessage(
                           ref contextHandle,
                           qualityOfProtection,
                           ref input,
                           sequenceNumber
                           );

            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.EncryptMessage(
                           ref contextHandle,
                           qualityOfProtection,
                           ref input,
                           sequenceNumber
                           );
            }
        }


        public int
        DecryptMessage(ref long             contextHandle,
                       int                  qualityOfProtection,
                       ref SecurityBufferDescriptor    input,
                       int                  sequenceNumber)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.DecryptMessage(
                           ref contextHandle,
                           qualityOfProtection,
                           ref input,
                           sequenceNumber
                           );

            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.DecryptMessage(
                           ref contextHandle,
                           qualityOfProtection,
                           ref input,
                           sequenceNumber
                           );
            }
        }



        public int
        SealMessage(ref long            contextHandle,
                    int                 qualityOfProtection,
                    ref SecurityBufferDescriptor   input,
                    int                 sequenceNumber)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.SealMessage(
                    ref contextHandle,
                    qualityOfProtection,
                    ref input,
                    sequenceNumber
                    );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.SealMessage(
                    ref contextHandle,
                    qualityOfProtection,
                    ref input,
                    sequenceNumber
                    );
            }
        }


        public int
        UnsealMessage(ref long          contextHandle,
                      ref SecurityBufferDescriptor input,
                      int               qualityOfProtection,
                      int               sequenceNumber)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.UnsealMessage(
                                  ref contextHandle,
                                  ref input,
                                  qualityOfProtection,
                                  sequenceNumber
                                  );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.UnsealMessage(
                                  ref contextHandle,
                                  ref input,
                                  qualityOfProtection,
                                  sequenceNumber
                                  );
            }
        }


        public SecurityStatus
        QueryContextAttributes(ref long ContextHandle,
                               int ulAttribute,
                               ref IntPtr name)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.QueryContextAttributes(
                               ref ContextHandle,
                               ulAttribute,
                               ref name
                               );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.QueryContextAttributes(
                               ref ContextHandle,
                               ulAttribute,
                               ref name
                               );
            }
        }


        public int
        QueryContextAttributes(ref long phContext,
                               int      attribute,
                               IntPtr      buffer)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.QueryContextAttributes(
                               ref phContext,
                               attribute,
                               buffer
                               );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.QueryContextAttributes(
                               ref phContext,
                               attribute,
                               buffer
                               );
            }
        }


        public int
        QueryCredentialAttributes(ref long  phContext,
                                  int       attribute,
                                  IntPtr       buffer)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.QueryCredentialAttributes(
                                  ref phContext,
                                  attribute,
                                  buffer
                                  );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.QueryCredentialAttributes(
                                  ref phContext,
                                  attribute,
                                  buffer
                                  );
            }
        }

#if SERVER_SIDE_SSPI
        public int
        RevertSecurityContext(ref long phContext)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.RevertSecurityContext(ref phContext);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.RevertSecurityContext(ref phContext);
            }
        }

        public int
        ImpersonateSecurityContext(ref long phContext)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.ImpersonateSecurityContext(ref phContext);
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.ImpersonateSecurityContext(ref phContext);
            }
        }

        public int
        AcceptSecurityContext( ref long             credentialHandle,
                               int                  context,
                               int                  inputBuffer,
                               int                  requirements,
                               int                  endianness,
                               ref long             newContext,
                               ref SecurityBufferDescriptor    outputBuffer,
                               out int              attributes,
                               out long             timestamp)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.AcceptSecurityContext(
                               ref credentialHandle,
                               context,
                               inputBuffer,
                               requirements,
                               endianness,
                               ref newContext,
                               ref outputBuffer,
                               out attributes,
                               out timestamp
                               );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.AcceptSecurityContext(
                               ref credentialHandle,
                               context,
                               inputBuffer,
                               requirements,
                               endianness,
                               ref newContext,
                               ref outputBuffer,
                               out attributes,
                               out timestamp
                               );
            }
        }

        public int
        AcceptSecurityContext( ref long             credentialHandle,
                               ref long             context,
                               ref SecurityBufferDescriptor    inputBuffer,
                               int                  requirements,
                               int                  endianness,
                               ref long             newContext,
                               ref SecurityBufferDescriptor    outputBuffer,
                               out int              attributes,
                               out long             timestamp)
        {
            if ( ComNetOS.IsWin9x ) {
                return UnsafeNclNativeMethods.NativeAuthWin9xSSPI.AcceptSecurityContext(
                               ref credentialHandle,
                               ref context,
                               ref inputBuffer,
                               requirements,
                               endianness,
                               ref newContext,
                               ref outputBuffer,
                               out attributes,
                               out timestamp
                               );
            } else {
                return UnsafeNclNativeMethods.NativeNTSSPI.AcceptSecurityContext(
                               ref credentialHandle,
                               ref context,
                               ref inputBuffer,
                               requirements,
                               endianness,
                               ref newContext,
                               ref outputBuffer,
                               out attributes,
                               out timestamp
                               );
            }
        }
#endif // SERVER_SIDE_SSPI
    } // SSPIAuthType


    // need a global so we can pass the interfaces as variables,
    // is there a better way?
    internal class GlobalSSPI {
        public static SSPIInterface SSPIAuth = new SSPIAuthType();
        public static SSPIInterface SSPISecureChannel = new SSPISecureChannelType();
    }

} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_negotiateclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="_NegotiateClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Diagnostics;
    using System.Collections;
    using System.Net.Sockets;
    using System.Security.Permissions;
    using System.Globalization;
    
    internal class NegotiateClient : ISessionAuthenticationModule {

        internal const string AuthType = "Negotiate";
        internal static string Signature = AuthType.ToLower(CultureInfo.InvariantCulture);
        internal static int SignatureSize = Signature.Length;

        internal static Hashtable sessions = new Hashtable();

        // we can't work on non-NT2K platforms or non Win, so we shut off,
        // NOTE this exception IS caught internally.
        public NegotiateClient() {
            if (!ComNetOS.IsWin2K) {
                throw new NotSupportedException(SR.GetString(SR.Win2000Required));
            }
        }

        /*
         *  This is to support built-in auth modules under semitrusted environment
         *  Used to get access to UserName, Domain and Password properties of NetworkCredentials
         *  Declarative Assert is much faster and we don;t call dangerous methods inside this one.
         */
        [EnvironmentPermission(SecurityAction.Assert,Unrestricted=true)]
        [SecurityPermissionAttribute( SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]

        public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("NegotiateClient::Authenticate(): " + challenge);

            GlobalLog.Assert(credentials!=null, "NegotiateClient::Authenticate() credentials==null", "");
            if (credentials == null) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "NegotiateClient::Authenticate() httpWebRequest==null", "");
            if (httpWebRequest==null || httpWebRequest.ChallengedUri==null) {
                //
                // there has been no challenge:
                // 1) the request never went on the wire
                // 2) somebody other than us is calling into AuthenticationManager
                //
                return null;
            }

            int index = AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {
                return null;
            }

            int blobBegin = index + SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //

            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            NTAuthentication authSession = sessions[httpWebRequest.CurrentAuthenticationState] as NTAuthentication;
            GlobalLog.Print("NegotiateClient::Authenticate() key:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));

            if (authSession==null) {
                NetworkCredential NC = credentials.GetCredential(httpWebRequest.ChallengedUri, Signature);
                GlobalLog.Print("NegotiateClient::Authenticate() GetCredential() returns:" + ValidationHelper.ToString(NC));

                if (NC==null) {
                    return null;
                }
                string username = NC.UserName;
                if (username==null || (username.Length==0 && !(NC is SystemNetworkCredential))) {
                    return null;
                }
                //
                // here we cover a hole in the SSPI layer. longer credentials
                // might corrupt the process and cause a reboot.
                //
                if (username.Length + NC.Password.Length + NC.Domain.Length>NtlmClient.MaxNtlmCredentialSize) {
                    //
                    // rather then throwing an exception here we return null so other packages can be used.
                    // this is questionable, hence:
                    // Consider: make this throw a NotSupportedException so it is discoverable
                    //
                    return null;
                }

                if (httpWebRequest.ChallengedSpn==null) {
                    string host = httpWebRequest.ChallengedUri.Host;
                    if (httpWebRequest.ChallengedUri.HostNameType!=UriHostNameType.IPv6 && httpWebRequest.ChallengedUri.HostNameType!=UriHostNameType.IPv4 && host.IndexOf('.')==-1) {
                        // only do the DNS lookup for short names, no form of IP addess
                        (new DnsPermission(PermissionState.Unrestricted)).Assert();
                        try {
                            host = Dns.GetHostByName(host).HostName;
                            GlobalLog.Print("NegotiateClient::Authenticate() Dns returned host:" + ValidationHelper.ToString(host));
                        }
                        catch (Exception exception) {
                            GlobalLog.Print("NegotiateClient::Authenticate() GetHostByName(host) failed:" + ValidationHelper.ToString(exception));
                        }
                        finally {
                            DnsPermission.RevertAssert();
                        }
                    }
                    // CONSIDER V.NEXT
                    // for now avoid appending the non default port to the
                    // SPN, sometime in the future we'll have to do this.
                    // httpWebRequest.ChallengedSpn = httpWebRequest.ChallengedUri.IsDefaultPort ? host : host + ":" + httpWebRequest.ChallengedUri.Port;
                    httpWebRequest.ChallengedSpn = host;
                }
                GlobalLog.Print("NegotiateClient::Authenticate() ChallengedSpn:" + ValidationHelper.ToString(httpWebRequest.ChallengedSpn));

                authSession =
                    new NTAuthentication(
                        AuthType,
                        NC,
                        "HTTP/" + httpWebRequest.ChallengedSpn,
                        httpWebRequest.DelegationFix);

                GlobalLog.Print("NegotiateClient::Authenticate() adding authSession:" + ValidationHelper.HashString(authSession) + " for:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState));
                sessions.Add(httpWebRequest.CurrentAuthenticationState, authSession);
            }

            bool handshakeComplete;
            string clientResponse = authSession.GetOutgoingBlob(incoming, out handshakeComplete);
            if (clientResponse==null) {
                return null;
            }

            if (httpWebRequest.UnsafeAuthenticatedConnectionSharing) {
                httpWebRequest.LockConnection = true;
            }

            return AuthenticationManager.GetGroupAuthorization(this, AuthType + " " + clientResponse, false, authSession, httpWebRequest.UnsafeAuthenticatedConnectionSharing);
        }

        public bool CanPreAuthenticate {
            get {
                return false;
            }
        }

        public Authorization PreAuthenticate(WebRequest webRequest, ICredentials Credentials) {
            return null;
        }

        public string AuthenticationType {
            get {
                return AuthType;
            }
        }

        //
        // called when getting the final blob on the 200 OK from the server
        //
        public bool Update(string challenge, WebRequest webRequest) {
            GlobalLog.Print("NegotiateClient::Update(): " + challenge);

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "NegotiateClient::Update() httpWebRequest==null", "");
            GlobalLog.Assert(httpWebRequest.ChallengedUri!=null, "NegotiateClient::Update() httpWebRequest.ChallengedUri==null", "");

            //
            // try to retrieve the state of the ongoing handshake
            //

            NTAuthentication authSession = sessions[httpWebRequest.CurrentAuthenticationState] as NTAuthentication;
            GlobalLog.Print("NegotiateClient::Update() key:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));

            if (authSession==null) {
                GlobalLog.Print("NegotiateClient::Update() null session returning true");
                return true;
            }

            GlobalLog.Print("NegotiateClient::Update() authSession.IsCompleted:" + authSession.IsCompleted.ToString());

            if (!authSession.IsCompleted && httpWebRequest.CurrentAuthenticationState.StatusCodeMatch==httpWebRequest.ResponseStatusCode) {
                GlobalLog.Print("NegotiateClient::Update() still handshaking (based on status code) returning false");
                return false;
            }

            //
            // the whole point here is to remove the session, so do it right away, and then try
            // to close the Security Context (this will complete the authentication handshake
            // with server authentication for schemese that support it such as Kerberos)
            //
            GlobalLog.Print("NegotiateClient::Update() removing authSession:" + ValidationHelper.HashString(authSession) + " from:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState));
            sessions.Remove(httpWebRequest.CurrentAuthenticationState);

            //
            // now clean-up the ConnectionGroup after authentication is done.
            //
            if (!httpWebRequest.UnsafeAuthenticatedConnectionSharing) {
                GlobalLog.Print("NegotiateClient::Update() releasing ConnectionGroup:" + httpWebRequest.GetConnectionGroupLine());
                httpWebRequest.ServicePoint.ReleaseConnectionGroup(httpWebRequest.GetConnectionGroupLine());        
            }

            int index = challenge==null ? -1 : AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {                
                return true;
            }

            int blobBegin = index + SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //
            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            GlobalLog.Print("NegotiateClient::Update() closing security context using last incoming blob:[" + ValidationHelper.ToString(incoming) + "]");

            bool handshakeComplete;
            string clientResponse = authSession.GetOutgoingBlob(incoming, out handshakeComplete);

            GlobalLog.Print("NegotiateClient::Update() GetOutgoingBlob() returns clientResponse:[" + ValidationHelper.ToString(clientResponse) + "] handshakeComplete:" + handshakeComplete.ToString());            
            GlobalLog.Print("NegotiateClient::Update() session removed and ConnectionGorup released returning true");
            return true;
        }

        public void ClearSession(WebRequest webRequest) {
            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;
            sessions.Remove(httpWebRequest.CurrentAuthenticationState);
        }

        public bool CanUseDefaultCredentials {
            get {
                return true;
            }
        }

    }; // class NegotiateClient


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_nestedmultipleasyncresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="_NestedMultipleAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    //
    // The NestedAsyncResult - used to wrap async requests
    //      this is used to hold another async result made
    //      through a call to another Begin call within.
    //
    internal class NestedMultipleAsyncResult : LazyAsyncResult {
        //
        // this is usually for operations on streams/buffers,
        // we save information passed in on the Begin call:
        // since some calls might need several completions, we
        // need to save state on the user's IO request
        //
        internal BufferOffsetSize[] Buffers;
        internal int Size;

        //
        // Constructor:
        //
        internal NestedMultipleAsyncResult(Object asyncObject, Object asyncState, AsyncCallback asyncCallback)
        : base( asyncObject, asyncState, asyncCallback ) {
        }
        internal NestedMultipleAsyncResult(Object asyncObject, Object asyncState, AsyncCallback asyncCallback, BufferOffsetSize[] buffers)
        : base( asyncObject, asyncState, asyncCallback ) {
            Buffers = buffers;
            Size = 0;
            for (int i = 0; i < Buffers.Length; i++) {
                Size += Buffers[i].Size;
            }
        }

        //
        // BytesTransferred:
        // bytes actually transferred from the buffer, used to keep track of the status of the IO
        //
        private int m_BytesTransferred;
        internal int BytesTransferred {
            get {
                return m_BytesTransferred;
            }
            set {
                m_BytesTransferred = value;
            }
        }

        //
        // ReadByteBuffer:
        // the StreamChunkBytes object in this async operation which contains our state info for the read
        //
        private StreamChunkBytes m_ReadByteBuffer;
        internal StreamChunkBytes ReadByteBuffer {
            get {
                return m_ReadByteBuffer;
            }
            set {
                m_ReadByteBuffer = value;
            }
        }

        //
        // NestedAsyncResult:
        // used to store return of nested call, so that we can abstract and use our own async result
        //
        private IAsyncResult m_NestedAsyncResult;
        internal IAsyncResult NestedAsyncResult {
            get {
                return m_NestedAsyncResult;
            }
            set {
                m_NestedAsyncResult = value;
            }
        }

        //
        // CallCallbackWithReturn:
        // called in async to call our nested callback, and signal by setting Complete to true, also sets return value
        //
        internal void CallCallbackWithReturn(int returnValue) {
            //
            // It finished, now call callback, noting return value
            //
            m_BytesTransferred = returnValue;
            InvokeCallback();
            return;
        }

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

    }; // class NestedMultipleAsyncResult


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_nestedsingleasyncresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="_NestedSingleAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    //
    // The NestedAsyncResult - used to wrap async requests
    //      this is used to hold another async result made
    //      through a call to another Begin call within.
    //
    internal class NestedSingleAsyncResult : LazyAsyncResult {
        //
        // this is usually for operations on streams/buffers,
        // we save information passed in on the Begin call:
        // since some calls might need several completions, we
        // need to save state on the user's IO request
        //
        internal byte[] Buffer;
        internal int Offset;
        internal int Size;

        //
        // Constructor:
        //
        internal NestedSingleAsyncResult(Object asyncObject, Object asyncState, AsyncCallback asyncCallback)
        : base( asyncObject, asyncState, asyncCallback ) {
        }
        internal NestedSingleAsyncResult(Object asyncObject, Object asyncState, AsyncCallback asyncCallback, byte[] buffer, int offset, int size)
        : base( asyncObject, asyncState, asyncCallback ) {
            Buffer = buffer;
            Offset = offset;
            Size = size;
        }

        //
        // BytesTransferred:
        // bytes actually transferred from the buffer, used to keep track of the status of the IO
        //
        private int m_BytesTransferred;
        internal int BytesTransferred {
            get {
                return m_BytesTransferred;
            }
            set {
                m_BytesTransferred = value;
            }
        }

        //
        // ReadByteBuffer:
        // the StreamChunkBytes object in this async operation which contains our state info for the read
        //
        private StreamChunkBytes m_ReadByteBuffer;
        internal StreamChunkBytes ReadByteBuffer {
            get {
                return m_ReadByteBuffer;
            }
            set {
                m_ReadByteBuffer = value;
            }
        }

        //
        // Nested:
        // true if we've nested an async call of off this one
        //
        private bool m_Nested;
        internal bool Nested {
            get {
                return m_Nested;
            }
            set {
                m_Nested = value;
            }
        }

        //
        // NestedAsyncResult:
        // used to store return of nested call, so that we can abstract and use our own async result
        //
        private IAsyncResult m_NestedAsyncResult;
        internal IAsyncResult NestedAsyncResult {
            get {
                return m_NestedAsyncResult;
            }
            set {
                m_NestedAsyncResult = value;
            }
        }

        //
        // CallCallbackWithReturn:
        // called in async to call our nested callback, and signal by setting Complete to true, also sets return value
        //
        internal void CallCallbackWithReturn(int returnValue) {
            //
            // It finished, now call callback, noting return value
            //
            m_BytesTransferred = returnValue;
            InvokeCallback();
            return;
        }

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

    }; // class NestedAsyncResult


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_netres.cs ===
//------------------------------------------------------------------------------
// <copyright file="_NetRes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Diagnostics;

    internal class NetRes {

        /*++
            Constructor

            This is the constructor, marked private because this class shouldn't
            be instantiated.

        --*/
        private NetRes() {
        }

        /*++

            GetWebStatusString - Get a WebExceptionStatus-specific resource string


            This method takes an input string and a WebExceptionStatus. We use the input
            string as a key to find a status message and the webStatus to produce
            a status-specific message, then we combine the two.

            Input:

                Res             - Id for resource string.
                Status          - The WebExceptionStatus to be formatted.

            Returns:

                string for localized message.

        --*/
        public static string GetWebStatusString(string Res, WebExceptionStatus Status) {
            string Msg;
            string StatusEnumName;
            string StatusMsg;

            // First, convert the WebExceptionStatus to its label.

            StatusEnumName = ((Enum)Status).ToString();

            // Now combine the label with the base enum key and look up the
            // status msg.

            StatusMsg = SR.GetString("net_webstatus_" + StatusEnumName);

            // Get the base status.

            Msg = SR.GetString(Res);

            // Format the status specific message into the base status and return
            // that

            return String.Format(Msg, StatusMsg);
        }


        /*++

            GetWebStatusCodeString - Get a StatusCode-specific resource string

            This method is used to map a HTTP status code to a specific user
            readable error code.

            Input:

                statusCode      - Id for resource string.
                Status          - The WebExceptionStatus to be formatted.

            Returns:

                string for localized message.

        --*/
        public static string GetWebStatusCodeString(HttpStatusCode statusCode, string statusDescription) {
            string webStatusCode = "(" + ((int)statusCode).ToString() + ")";
            string statusMessage = null;
            //
            // Now combine the label with the base enum key and look up the status msg.
            //
            try {
                //
                // convert the HttpStatusCode to its label and look it up.
                //
                statusMessage = SR.GetString("net_httpstatuscode_" + statusCode.ToString(), null);
            }
            catch {
            }

            if (statusMessage!=null && statusMessage.Length>0) {
                webStatusCode += " " + statusMessage;
            }
            else {
                //
                // Otherwise try to map the base status.
                //
                if (statusDescription!=null && statusDescription.Length>0) {
                    webStatusCode += " " + statusDescription;
                }
            }

            return webStatusCode;
        }

    }; // class NetRes


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_loggingobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="_LoggingObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

//
//  We have function based stack and thread based logging of basic behavior.  We
//  also now have the ability to run a "watch thread" which does basic hang detection
//  and error-event based logging.   The logging code buffers the callstack/picture
//  of all COMNET threads, and upon error from an assert or a hang, it will open a file
//  and dump the snapsnot.  Future work will allow this to be configed by registry and
//  to use Runtime based logging.  We'd also like to have different levels of logging.
//

namespace System.Net {

    using System.Collections;
    using System.IO;
    using System.Threading;
    using System.Diagnostics;
    using System.Security.Permissions;
    using Microsoft.Win32;

    //
    // BaseLoggingObject - used to disable logging,
    //  this is just a base class that does nothing.
    //

    internal class BaseLoggingObject {

        internal BaseLoggingObject() {
        }

        internal virtual void EnterFunc(string funcname) {
        }

        internal virtual void LeaveFunc(string funcname) {
        }

        internal virtual void DumpArrayToConsole() {
        }

        internal virtual void PrintLine(string msg) {
        }

        internal virtual void DumpArray(bool shouldClose) {
        }

        internal virtual void DumpArrayToFile(bool shouldClose) {
        }

        internal virtual void Flush() {
        }

        internal virtual void Flush(bool close) {
        }

        internal virtual void LoggingMonitorTick() {
        }

        internal virtual void Dump(byte[] buffer) {
        }

        internal virtual void Dump(byte[] buffer, int length) {
        }

        internal virtual void Dump(byte[] buffer, int offset, int length) {
        }
    } // class BaseLoggingObject

#if TRAVE

    internal class IntegerSwitch : BooleanSwitch {

        public IntegerSwitch(string switchName, string switchDescription) : base(switchName, switchDescription) {
        }

        public int Value {
            get {
                return base.SwitchSetting;
            }
        }
    }

    internal class TraveHelper {

        private static readonly string Hexizer = "0x{0:x}";

        internal static string ToHex(object value) {
            return String.Format(Hexizer, value);
        }
    }

    /// <include file='doc\_LoggingObject.uex' path='docs/doc[@for="LoggingObject"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    internal class LoggingObject : BaseLoggingObject {
        public ArrayList _Logarray;
        private Hashtable _ThreadNesting;
        private int _AddCount;
        private StreamWriter _Stream;
        private int _IamAlive;
        private int _LastIamAlive;
        private bool m_Finalized = false;
        private double _MillisecondsPerTicks;
        private int _StartTickCountMilliseconds;
        private long _StartTickCountMicroseconds;

        internal LoggingObject() : base() {
            _Logarray      = new ArrayList();
            _ThreadNesting = new Hashtable();
            _AddCount      = 0;
            _IamAlive      = 0;
            _LastIamAlive  = -1;


            if (GlobalLog.s_UsePerfCounter) {
                long ticksPerSecond;
                SafeNativeMethods.QueryPerformanceFrequency(out ticksPerSecond);
                _MillisecondsPerTicks = 1000.0/(double)ticksPerSecond;
                SafeNativeMethods.QueryPerformanceCounter(out _StartTickCountMicroseconds);
            } else
            {
                _StartTickCountMilliseconds = Environment.TickCount;
            }
        }

        //
        // LoggingMonitorTick - this function is run from the monitor thread,
        //  and used to check to see if there any hangs, ie no logging
        //  activitity
        //

        internal override void LoggingMonitorTick() {
            if ( _LastIamAlive == _IamAlive ) {
                Console.WriteLine("================== FIRE ======================");
                PrintLine("================= Error TIMEOUT - HANG DETECTED =================");
                DumpArray(true);
            }
            _LastIamAlive = _IamAlive;
        }

        internal override void EnterFunc(string funcname) {
            if (m_Finalized) {
                return;
            }
            IncNestingCount();
            PrintLine(funcname);
        }

        internal override void LeaveFunc(string funcname) {
            if (m_Finalized) {
                return;
            }
            PrintLine(funcname);
            DecNestingCount();
        }

        internal override void DumpArrayToConsole() {
            for (int i=0; i < _Logarray.Count; i++) {
                Console.WriteLine((string) _Logarray[i]);
            }
        }

        internal override void PrintLine(string msg) {
            if (m_Finalized) {
                return;
            }
            string spc = "";

            _IamAlive++;

            spc = GetNestingString();

            string tickString = "";

            if (GlobalLog.s_UsePerfCounter) {
                long counter;
                SafeNativeMethods.QueryPerformanceCounter(out counter);
                if (_StartTickCountMicroseconds>counter) { // counter reset, restart from 0
                    _StartTickCountMicroseconds = counter;
                }
                counter -= _StartTickCountMicroseconds;
                if (GlobalLog.s_UseTimeSpan) {
                    tickString = new TimeSpan(counter/100).ToString();
                    // note: TimeSpan().ToString() doesn't return the uSec part
                    // if its 0. .ToString() returns [H*]HH:MM:SS:uuuuuuu, hence 16
                    if (tickString.Length < 16) {
                        tickString += ".0000000";
                    }
                }
                else {
                    tickString = ((double)counter*_MillisecondsPerTicks).ToString("f3");
                }
            }
            else {
                int counter = Environment.TickCount;
                if (_StartTickCountMilliseconds > counter) {
                    _StartTickCountMilliseconds = counter;
                }
                counter -= _StartTickCountMilliseconds;
                if (GlobalLog.s_UseTimeSpan) {
                    tickString = new TimeSpan(counter*10000).ToString();
                    // note: TimeSpan().ToString() doesn't return the uSec part
                    // if its 0. .ToString() returns [H*]HH:MM:SS:uuuuuuu, hence 16
                    if (tickString.Length < 16) {
                        tickString += ".0000000";
                    }
                }
                else {
                    tickString = (counter).ToString();
                }
            }

            int threadId = 0;

            if (GlobalLog.s_UseThreadId) {
                try {
                    threadId = (int)Thread.GetData(GlobalLog.s_ThreadIdSlot);
                }
                catch {
                }
                if (threadId == 0) {
                    threadId = UnsafeNclNativeMethods.GetCurrentThreadId();
                    Thread.SetData(GlobalLog.s_ThreadIdSlot, threadId);
                }
            }
            if (threadId == 0) {
                threadId = Thread.CurrentThread.GetHashCode();
            }

            string str = String.Format("[{0:x8}]", threadId) + " (" +tickString+  ") " + spc + msg;

            Monitor.Enter(this);

            _AddCount++;
            _Logarray.Add(str);

            int MaxLines = GlobalLog.s_DumpToConsole ? 0 : GlobalLog.MaxLinesBeforeSave;

            if (_AddCount > MaxLines) {

                _AddCount = 0;

                if ( ! GlobalLog.SaveOnlyOnError || GlobalLog.s_DumpToConsole ) {
                    DumpArray(false);
                }

                _Logarray = new ArrayList();
            }

            Monitor.Exit(this);
        }

        internal override void DumpArray(bool shouldClose) {
            if ( GlobalLog.s_DumpToConsole ) {
                DumpArrayToConsole();
            } else {
                DumpArrayToFile(shouldClose);
            }
        }

        internal override void Dump(byte[] buffer, int offset, int length) {
            if (!GlobalLog.s_DumpWebData) {
                return;
            }
            if (buffer == null) {
                PrintLine("(null)");
                return;
            }
            if (offset > buffer.Length) {
                PrintLine("(offset out of range)");
                return;
            }
            if (length > GlobalLog.s_MaxDumpSize) {
                PrintLine("(printing " + GlobalLog.s_MaxDumpSize.ToString() + " out of " + length.ToString() + ")");
                length = GlobalLog.s_MaxDumpSize;
            }
            if ((length < 0) || (length > buffer.Length - offset)) {
                length = buffer.Length - offset;
            }
            do {
                int n = Math.Min(length, 16);
                string disp = String.Format("{0:X8} : ", offset);
                for (int i = 0; i < n; ++i) {
                    disp += String.Format("{0:X2}", buffer[offset + i]) + ((i == 7) ? '-' : ' ');
                }
                for (int i = n; i < 16; ++i) {
                    disp += "   ";
                }
                disp += ": ";
                for (int i = 0; i < n; ++i) {
                    disp += ((buffer[offset + i] < 0x20) || (buffer[offset + i] > 0x7e))
                                ? '.'
                                : (char)(buffer[offset + i]);
                }
                PrintLine(disp);
                offset += n;
                length -= n;
            } while (length > 0);
        }

        //SECURITY: This is dev-debugging class and we need IO permissions
        //to use it under trust-restricted environment as well.
        [FileIOPermission(SecurityAction.Assert, Unrestricted=true)]
        internal override void DumpArrayToFile(bool shouldClose) {

            Monitor.Enter(this);

            string mainLogFile = "system.net.log";

            while(true) {
                try {
                    if ( _Stream == null ) {
                        _Stream = new StreamWriter(mainLogFile);
                    }

                    for (int i=0; i < _Logarray.Count; i++) {
                        _Stream.Write((string) _Logarray[i]);
                        _Stream.Write("\r\n");
                    }

                    _Stream.Flush();
                } catch {
                    if ( mainLogFile == "system.net.log") {
                        mainLogFile = "system.net2.log";
                        continue;
                    } else {
                        // fall through and fail silently with a Null stream
                        _Stream = StreamWriter.Null;
                    }
                }

                break;
            }

            if ( shouldClose )  {
                _Stream.Close();
                _Stream = null;
            }

            Monitor.Exit(this);
        }

        internal override void Flush() {
            Flush(false);
        }

        internal override void Flush(bool close) {
            lock(this) {
                if (!GlobalLog.s_DumpToConsole) {
                    DumpArrayToFile(close);
                    _AddCount = 0;
                }
            }
        }

        [System.Diagnostics.Conditional("TRAVE")]
        private void IncNestingCount() {
            Object obj = _ThreadNesting[Thread.CurrentThread.GetHashCode()];
            string indent = " ";

            if (obj == null) {
                _ThreadNesting[Thread.CurrentThread.GetHashCode()] = indent;
            }
            else {
                indent = (String) obj;
            }

            indent = indent + " ";

            //if ( indent.Length > 200 ) {
            //    Debug.Assert(false,
            //                 "nested too deep",
            //                 "nesting too deep");
            //}

            _ThreadNesting[Thread.CurrentThread.GetHashCode()] = (object) indent;
        }

        [System.Diagnostics.Conditional("TRAVE")]
        private void DecNestingCount() {
            Object obj = _ThreadNesting[Thread.CurrentThread.GetHashCode()];
            string indent;

            if (obj == null) {
                return;
            }

            indent = (string) obj;

            try {
                indent = indent.Substring(1);
            } catch (Exception) {
                indent = "< ";
            }

            _ThreadNesting[Thread.CurrentThread.GetHashCode()] = indent;
        }

        private string GetNestingString() {
            Object obj = _ThreadNesting[Thread.CurrentThread.GetHashCode()];
            string nesting = "  ";

            if (obj == null) {
                _ThreadNesting[Thread.CurrentThread.GetHashCode()] = nesting;
            } else {
                nesting = (string) obj;
            }

            return (string) nesting;
        }

        ~LoggingObject() {
            if(!m_Finalized) {
                m_Finalized = true;
                Monitor.Enter(this);
                DumpArray(true);
                Monitor.Exit(this);
            }
        }


    } // class LoggingObject
#endif // TRAVE

    /// <include file='doc\_LoggingObject.uex' path='docs/doc[@for="GlobalLog"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>

    internal class GlobalLog {

        //
        // Logging Initalization - I need to disable Logging code, and limit
        //  the effect it has when it is dissabled, so I use a bool here.
        //
        //  This can only be set when the logging code is built and enabled.
        //  By specifing the "COOLC_DEFINES=/D:TRAVE" in the build environment,
        //  this code will be built and then checks against an enviroment variable
        //  and a BooleanSwitch to see if any of the two have enabled logging.
        //

        private static BaseLoggingObject Logobject = GlobalLog.LoggingInitialize();
#if TRAVE
        internal static LocalDataStoreSlot s_ThreadIdSlot;
        internal static bool s_UseThreadId;
        internal static bool s_UseTimeSpan;
        internal static bool s_DumpWebData;
        internal static bool s_UsePerfCounter;
        internal static bool s_DumpToConsole;
        internal static int s_MaxDumpSize;

        //
        // Logging Config Variables -  below are list of consts that can be used to config
        //  the logging,
        //

        // Max number of lines written into a buffer, before a save is invoked
        // s_DumpToConsole disables.
        public const int MaxLinesBeforeSave = 0;


        // Only writes to a file when an error occurs, otherwise saves the last MaxLinesBeforeSave
        //  to memory.  s_DumpToConsole disables this.
        public const bool SaveOnlyOnError = false;

#endif
        private static BaseLoggingObject LoggingInitialize() {

#if DEBUG
            InitConnectionMonitor();
#endif
#if TRAVE

            s_ThreadIdSlot = Thread.AllocateDataSlot();
            s_UseThreadId = GetSwitchValue("SystemNetLog_UseThreadId", "System.Net log display system thread id", false);
            s_UseTimeSpan = GetSwitchValue("SystemNetLog_UseTimeSpan", "System.Net log display ticks as TimeSpan", false);
            s_DumpWebData = GetSwitchValue("SystemNetLog_DumpWebData", "System.Net log display HTTP send/receive data", false);
            s_MaxDumpSize = GetSwitchValue("SystemNetLog_MaxDumpSize", "System.Net log max size of display data", 256);
            s_UsePerfCounter = GetSwitchValue("SystemNetLog_UsePerfCounter", "System.Net log use QueryPerformanceCounter() to get ticks ", false);
            s_DumpToConsole = GetSwitchValue("SystemNetLog_DumpToConsole", "System.Net log to console", false);

            if (GetSwitchValue("SystemNetLogging", "System.Net logging module", false)) {
                return new LoggingObject();
            }
#endif
            // otherwise disable
            return new BaseLoggingObject();
        }
#if TRAVE
        private static int GetSwitchValue(string switchName, string switchDescription, int defaultValue) {

            IntegerSwitch theSwitch = new IntegerSwitch(switchName, switchDescription);

            if (theSwitch.Enabled) {
                return theSwitch.Value;
            }
            new EnvironmentPermission(PermissionState.Unrestricted).Assert();
            try {
                string environmentVar = Environment.GetEnvironmentVariable(switchName);
                if (environmentVar!=null) {
                    return Int32.Parse(environmentVar.Trim());
                }
            } finally {
                EnvironmentPermission.RevertAssert();
            }
            return defaultValue;
        }

        private static bool GetSwitchValue(string switchName, string switchDescription, bool defaultValue) {

            BooleanSwitch theSwitch = new BooleanSwitch(switchName, switchDescription);

            if (theSwitch.Enabled) {
                return true;
            }
            new EnvironmentPermission(PermissionState.Unrestricted).Assert();
            try {
                string environmentVar = Environment.GetEnvironmentVariable(switchName);
                if ((environmentVar != null) && (environmentVar.Trim() == "1")) {
                    return true;
                }
            } finally {
                EnvironmentPermission.RevertAssert();
            }
            return defaultValue;
        }
#endif // TRAVE

#if DEBUG

        // Enables auto-hang detection, which will "snap" a log on hang
        public static bool EnableMonitorThread = false;

        // Default value for hang timer
        public const int DefaultTickValue = 1000*60; // 60 secs
#endif // DEBUG

        [System.Diagnostics.Conditional("TRAVE")]
        public static void AddToArray(string msg) {
#if TRAVE
            GlobalLog.Logobject.PrintLine(msg);
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Ignore(object msg) {
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Print(string msg) {
#if TRAVE
            GlobalLog.Logobject.PrintLine(msg);
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void PrintHex(string msg, object value) {
#if TRAVE
            GlobalLog.Logobject.PrintLine(msg+TraveHelper.ToHex(value));
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Enter(string func) {
#if TRAVE
            GlobalLog.Logobject.EnterFunc(func + "(*none*)");
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Enter(string func, string parms) {
#if TRAVE
            GlobalLog.Logobject.EnterFunc(func + "(" + parms + ")");
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void Assert(
                bool ShouldNotFireAssert,
                string ErrorMsg,
                string Msg2
                )
        {
#if TRAVE
            if ( ! ShouldNotFireAssert )
            {
                GlobalLog.Print("Assert: " + ErrorMsg);
                GlobalLog.Print("*******");

                GlobalLog.Logobject.DumpArray(false);

                Debug.Assert(ShouldNotFireAssert,
                             ErrorMsg,
                             Msg2);
            }
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void LeaveException(string func, Exception exception) {
#if TRAVE
            GlobalLog.Logobject.LeaveFunc(func + " exception " + ((exception!=null) ? exception.Message : String.Empty));
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Leave(string func) {
#if TRAVE
            GlobalLog.Logobject.LeaveFunc(func + " returns ");
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Leave(string func, string result) {
#if TRAVE
            GlobalLog.Logobject.LeaveFunc(func + " returns " + result);
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Leave(string func, int returnval) {
#if TRAVE
            GlobalLog.Logobject.LeaveFunc(func + " returns " + returnval.ToString());
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Leave(string func, bool returnval) {
#if TRAVE
            GlobalLog.Logobject.LeaveFunc(func + " returns " + returnval.ToString());
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void DumpArray() {
#if TRAVE
            GlobalLog.Logobject.DumpArray(true);
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Dump(byte[] buffer) {
#if TRAVE
            Logobject.Dump(buffer, 0, buffer!=null ? buffer.Length : -1);
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Dump(byte[] buffer, int length) {
#if TRAVE
            Logobject.Dump(buffer, 0, length);
#endif
        }

        [System.Diagnostics.Conditional("TRAVE")]
        public static void Dump(byte[] buffer, int offset, int length) {
#if TRAVE
            Logobject.Dump(buffer, offset, length);
#endif
        }

#if DEBUG
        private class HttpWebRequestComparer : IComparer {
            public int Compare(
                   object x1,
                   object y1
                   ) {

                HttpWebRequest x = (HttpWebRequest) x1;
                HttpWebRequest y = (HttpWebRequest) y1;

                if (x.GetHashCode() == y.GetHashCode()) {
                    return 0;
                } else if (x.GetHashCode() < y.GetHashCode()) {
                    return -1;
                } else if (x.GetHashCode() > y.GetHashCode()) {
                    return 1;
                }

                return 0;
            }
        }

		private class ConnectionMonitorEntry {
            public HttpWebRequest m_Request;
            public int m_Flags;
            public DateTime m_TimeAdded;
            public Connection m_Connection;

            public ConnectionMonitorEntry(HttpWebRequest request, Connection connection, int flags) {
                m_Request = request;
                m_Connection = connection;
                m_Flags = flags;
                m_TimeAdded = DateTime.Now;
            }
        }

		private static ManualResetEvent s_ShutdownEvent;
        private static SortedList s_RequestList;

        internal const int WaitingForReadDoneFlag = 0x1;
#endif

#if DEBUG
        private static void ConnectionMonitor() {
#if TRAVE
            Console.WriteLine("connection monitor thread started");
#endif
            while(! s_ShutdownEvent.WaitOne(DefaultTickValue, false)) {
#if TRAVE
                Console.WriteLine("================== TICK ======================");
#endif
                if (GlobalLog.EnableMonitorThread) {
#if TRAVE
                    GlobalLog.Logobject.LoggingMonitorTick();
#endif
                }

                int hungCount = 0;
                lock (s_RequestList) {
                    DateTime dateNow = DateTime.Now;
                    DateTime dateExpired = dateNow.AddSeconds(-120);
                    foreach (ConnectionMonitorEntry monitorEntry in s_RequestList.GetValueList() ) {
                        if (monitorEntry != null &&
                            (dateExpired > monitorEntry.m_TimeAdded))
                        {
                            hungCount++;
#if TRAVE
                            Console.WriteLine("delay:" + (dateNow - monitorEntry.m_TimeAdded).TotalSeconds +
                                " req#" + monitorEntry.m_Request.GetHashCode() +
                                " cnt#" + monitorEntry.m_Connection.GetHashCode() +
                                " flags:" + monitorEntry.m_Flags +
                                " STQueued:" + monitorEntry.m_Connection.m_StartDelegateQueued);
#endif
                            monitorEntry.m_Connection.Debug(monitorEntry.m_Request.GetHashCode());
                        }
                    }
                }
                GlobalLog.Assert(
                        hungCount == 0,
                        "Warning: Hang Detected on Connection(s) of greater than: " + DefaultTickValue + " ms and " + hungCount + " request(s) did hang",
                        "Please Dump System.Net.GlobalLog.s_RequestList for pending requests, make sure your streams are calling .Close(), and that your destination server is up" );

            }

#if TRAVE
            Console.WriteLine("connection monitor thread shutdown");
#endif
        }
#endif // DEBUG

#if DEBUG
        internal static void AppDomainUnloadEvent(object sender, EventArgs e) {
            s_ShutdownEvent.Set();
        }
#endif

#if DEBUG
        [System.Diagnostics.Conditional("DEBUG")]
        private static void InitConnectionMonitor() {
            s_RequestList = new SortedList(new HttpWebRequestComparer(), 10);
            s_ShutdownEvent = new ManualResetEvent(false);
            AppDomain.CurrentDomain.DomainUnload += new EventHandler(AppDomainUnloadEvent);
            AppDomain.CurrentDomain.ProcessExit += new EventHandler(AppDomainUnloadEvent);
            Thread threadMonitor = new Thread(new ThreadStart(ConnectionMonitor));
            threadMonitor.IsBackground = true;
            threadMonitor.Start();
        }
#endif

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void DebugAddRequest(HttpWebRequest request, Connection connection, int flags) {
#if DEBUG
            lock(s_RequestList) {
                GlobalLog.Assert(
                    ! s_RequestList.ContainsKey(request),
                    "s_RequestList.ContainsKey(request)",
                    "a HttpWebRequest should not be submitted twice" );

                ConnectionMonitorEntry requestEntry =
                    new ConnectionMonitorEntry(request, connection, flags);

                try {
                    s_RequestList.Add(request, requestEntry);
                } catch {
                }
            }
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void DebugRemoveRequest(HttpWebRequest request) {
#if DEBUG
            lock(s_RequestList) {
                GlobalLog.Assert(
                    s_RequestList.ContainsKey(request),
                    "!s_RequestList.ContainsKey(request)",
                    "a HttpWebRequest should not be removed twice" );

                try {
                    s_RequestList.Remove(request);
                } catch {
                }
            }
#endif
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal static void DebugUpdateRequest(HttpWebRequest request, Connection connection, int flags) {
#if DEBUG
            lock(s_RequestList) {

                if(!s_RequestList.ContainsKey(request)) {
                    return;
                }

                ConnectionMonitorEntry requestEntry =
                    new ConnectionMonitorEntry(request, connection, flags);

                try {
                    s_RequestList.Remove(request);
                    s_RequestList.Add(request, requestEntry);
                } catch {
                }
            }
#endif
        }

    } // class GlobalLog


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_networkingperfcounters.cs ===
//------------------------------------------------------------------------------
// <copyright file="_NetworkingPerfCounters.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Net.Sockets;
    using System.Diagnostics;
    using System.Security.Permissions;

    //
    // This implementation uses the PerformanceCounter object defined in
    // System.Diagnostics, too bad it doesn't work 'cause the runtime defines
    // the counter and doesn't expose the API
    //
    internal class NetworkingPerfCounters {

        private static PerformanceCounter
#if COMNET_HTTPPERFCOUNTER
            GlobalHttpWebRequestCreated,
            GlobalHttpWebRequestCollected,
            HttpWebRequestCreated,
            HttpWebRequestCollected,
#endif // COMNET_HTTPPERFCOUNTER
            GlobalConnectionsEstablished,
            GlobalBytesReceived,
            GlobalBytesSent,
            GlobalDatagramsReceived,
            GlobalDatagramsSent,
            ConnectionsEstablished,
            BytesReceived,
            BytesSent,
            DatagramsReceived,
            DatagramsSent;

#if COMNET_HTTPPERFCOUNTER
        private const string HttpWebRequestCreatedName = "HttpWebRequest Created";
        private const string HttpWebRequestCollectedName = "HttpWebRequest Collected";
#endif // COMNET_HTTPPERFCOUNTER

        private const string CategoryName = ".NET CLR Networking";
        private const string ConnectionsEstablishedName = "Connections Established";
        private const string BytesReceivedName = "Bytes Received";
        private const string BytesSentName = "Bytes Sent";
        private const string DatagramsReceivedName = "Datagrams Received";
        private const string DatagramsSentName = "Datagrams Sent";
        private const string Global = "_Global_";

        private static bool initializationSuccesfull = Initialize();
        private static bool Initialize() {
            //
            // on Win9x you have no PerfCounters
            // on NT4 PerfCounters are not writable
            //
            if (ComNetOS.IsWin9x || ComNetOS.IsWinNt4) {
                return false;
            }

            //
            // this is an internal class, we need to update performance counters
            // on behalf of the user to log perf data on network activity
            //
            // Consider V.Next: Change to declarative form (10x faster) but 
            // PerformanceCounterPermission must be moved out of System.dll
            PerformanceCounterPermission perfCounterPermission = new PerformanceCounterPermission(PermissionState.Unrestricted);
            perfCounterPermission.Assert();

            bool successStatus = false;

            try {                
                //
                // create the counters, this will check for the right permissions (false)
                // means the counter is not readonly (it's read/write) and cache them while
                // we're under the Assert(), which will be reverted in the finally below.
                //
                GlobalConnectionsEstablished = new PerformanceCounter(CategoryName, ConnectionsEstablishedName, Global, false);

                //
                // if I created the first counter succesfully, then I'll return
                // true. otherwise I'll return false, since none of the counters will
                // be created, hence non of them should be updated.
                //
                successStatus = true;
                
                GlobalBytesReceived = new PerformanceCounter(CategoryName, BytesReceivedName, Global, false);
                GlobalBytesSent = new PerformanceCounter(CategoryName, BytesSentName, Global, false);
                GlobalDatagramsReceived = new PerformanceCounter(CategoryName, DatagramsReceivedName, Global, false);
                GlobalDatagramsSent = new PerformanceCounter(CategoryName, DatagramsSentName, Global, false);
                ConnectionsEstablished = new PerformanceCounter(CategoryName, ConnectionsEstablishedName, false);
                BytesReceived = new PerformanceCounter(CategoryName, BytesReceivedName, false);
                BytesSent = new PerformanceCounter(CategoryName, BytesSentName, false);
                DatagramsReceived = new PerformanceCounter(CategoryName, DatagramsReceivedName, false);
                DatagramsSent = new PerformanceCounter(CategoryName, DatagramsSentName, false);
#if COMNET_HTTPPERFCOUNTER
// jruiz: If you need to use this counters, you will have to change the files
// _NetworkingPerfCounters.ini
// _NetworkingPerfCounters.h
                GlobalHttpWebRequestCreated = new PerformanceCounter(CategoryName, HttpWebRequestCreatedName, false);
                GlobalHttpWebRequestCollected = new PerformanceCounter(CategoryName, HttpWebRequestCollectedName, Global, false);
                HttpWebRequestCreated = new PerformanceCounter(CategoryName, HttpWebRequestCreatedName, false);
                HttpWebRequestCollected = new PerformanceCounter(CategoryName, HttpWebRequestCollectedName, Global, false);
#endif // COMNET_HTTPPERFCOUNTER
            }
            catch (Exception exception) {
                GlobalLog.Print("NetworkingPerfCounters::NetworkingPerfCounters() instantiation failure:" + exception.Message);
            }
            finally {
                PerformanceCounterPermission.RevertAssert();
            }

            //
            // we will return false if none of the counters was created. true
            // if at least the first one was, ignoring subsequent failures.
            // we don't expect the counters to fail individually, if the first
            // one fails we'd expect all of them to fails, if the first one
            // succeeds, wed' expect all of them to succeed.
            //
            return successStatus;
        }

        public static void IncrementConnectionsEstablished() {
            if (initializationSuccesfull) {
                if (ConnectionsEstablished != null) {
                    ConnectionsEstablished.Increment();                
                }                
                if (GlobalConnectionsEstablished != null) {
                    GlobalConnectionsEstablished.Increment();
                }                    
                GlobalLog.Print("NetworkingPerfCounters::IncrementConnectionsEstablished()");
            }
        }

#if COMNET_HTTPPERFCOUNTER
        public static void IncrementHttpWebRequestCreated() {
            if (initializationSuccesfull) {
                if (HttpWebRequestCreated != null) {
                    HttpWebRequestCreated.Increment();                
                }                
                if (GlobalHttpWebRequestCreated != null) {
                    GlobalHttpWebRequestCreated.Increment();
                }                    
                GlobalLog.Print("NetworkingPerfCounters::IncrementHttpWebRequestCreated()");
            }
        }
        public static void IncrementHttpWebRequestCollected() {
            if (initializationSuccesfull) {
                if (HttpWebRequestCollected != null) {
                    HttpWebRequestCollected.Increment();                
                }                
                if (GlobalHttpWebRequestCollected != null) {
                    GlobalHttpWebRequestCollected.Increment();
                }                    
                GlobalLog.Print("NetworkingPerfCounters::IncrementHttpWebRequestCollected()");
            }
        }
#endif // COMNET_HTTPPERFCOUNTER

        public static void AddBytesReceived(int increment) {
            if (initializationSuccesfull) {
                if (BytesReceived != null) {
                    BytesReceived.IncrementBy(increment);
                }                    
                if (GlobalBytesReceived != null) {
                    GlobalBytesReceived.IncrementBy(increment);
                }                    
                GlobalLog.Print("NetworkingPerfCounters::AddBytesReceived(" + increment.ToString() + ")");
            }    
        }

        public static void AddBytesSent(int increment) {
            if (initializationSuccesfull) {
                if (BytesSent != null) {
                    BytesSent.IncrementBy(increment);
                }                    
                if (GlobalBytesSent != null) {
                    GlobalBytesSent.IncrementBy(increment);
                }                    
                GlobalLog.Print("NetworkingPerfCounters::AddBytesSent(" + increment.ToString() + ")");
            }    
        }

        public static void IncrementDatagramsReceived() {
            if (initializationSuccesfull) {
                if (DatagramsReceived != null) {
                    DatagramsReceived.Increment();
                }                    
                if (GlobalDatagramsReceived != null) {
                    GlobalDatagramsReceived.Increment();
                }                    
                GlobalLog.Print("NetworkingPerfCounters::IncrementDatagramsReceived()");
            }    
        }

        public static void IncrementDatagramsSent() {
            if (initializationSuccesfull) {
                if (DatagramsSent != null) {
                    DatagramsSent.Increment();
                }                    
                if (GlobalDatagramsSent != null) {
                    GlobalDatagramsSent.Increment();
                }                    
                GlobalLog.Print("NetworkingPerfCounters::IncrementDatagramsSent()");
            }    
        }

    }; // class NetworkingPerfCounters


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_scattergatherbuffers.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ScatterGatherBuffers.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System;
    using System.Collections;

    internal class ScatterGatherBuffers {

        private MemoryChunk headChunk; // = null;
        private MemoryChunk currentChunk; // = null;  

        private int nextChunkLength = 1024; // this could be customized at construction time
        private int totalLength; // = 0;
        private int chunkCount; // = 0;

        public ScatterGatherBuffers() {
        }

        public BufferOffsetSize[] GetBuffers() {
            if (Empty) {
                return null;
            }
            GlobalLog.Print("ScatterGatherBuffers#" + ValidationHelper.HashString(this) + "::ToArray() chunkCount:" + chunkCount.ToString());
            BufferOffsetSize[] array = new BufferOffsetSize[chunkCount];
            int index = 0;
            MemoryChunk thisMemoryChunk = headChunk;
            while (thisMemoryChunk!=null) {
                GlobalLog.Print("ScatterGatherBuffers#" + ValidationHelper.HashString(this) + "::ToArray() index:" + index.ToString() + " size:" + thisMemoryChunk.FreeOffset);
                //
                // buffer itself is referenced by the BufferOffsetSize struct, data is not copied
                //
                array[index] = new BufferOffsetSize(thisMemoryChunk.Buffer, 0, thisMemoryChunk.FreeOffset, false);
                index++;
                thisMemoryChunk = thisMemoryChunk.Next;
            }
            return array;
        }

        private bool Empty {
            get {
                return headChunk==null || chunkCount==0;
            }
        }

        public int Length {
            get {
                return totalLength;
            }
        }

        public void Write(byte[] buffer, int offset, int count) {
            GlobalLog.Print("ScatterGatherBuffers#" + ValidationHelper.HashString(this) + "::Add() count:" + count.ToString());
            while (count > 0) {
                //
                // compute available space in current allocated buffer (0 if there's no buffer)
                //
                int available = Empty ? 0 : currentChunk.Buffer.Length - currentChunk.FreeOffset;
                GlobalLog.Assert(available>=0, "ScatterGatherBuffers::Add() available<0", "");
                //
                // if the current chunk is is full, allocate a new one
                //
                if (available==0) {
                    // ask for at least count bytes so that we need at most one allocation
                    MemoryChunk newChunk = AllocateMemoryChunk(count);
                    if (currentChunk!=null) {
                        currentChunk.Next = newChunk;
                    }
                    //
                    // move ahead in the linked list (or at the beginning if this is the fist buffer)
                    //
                    currentChunk = newChunk;
                }
                int copyCount = count < available ? count : available;

                Buffer.BlockCopy(
                    buffer,                     // src
                    offset,                     // src index
                    currentChunk.Buffer,        // dest
                    currentChunk.FreeOffset,    // dest index
                    copyCount );                // total size to copy

                //
                // update offsets and counts
                //
                offset += copyCount;
                count -= copyCount;
                totalLength += copyCount;
                currentChunk.FreeOffset += copyCount;
            }
            GlobalLog.Print("ScatterGatherBuffers#" + ValidationHelper.HashString(this) + "::Add() totalLength:" + totalLength.ToString());
        }

        private MemoryChunk AllocateMemoryChunk(int newSize) {
            if (newSize > nextChunkLength) {
                nextChunkLength = newSize;
            }
            MemoryChunk newChunk = new MemoryChunk(nextChunkLength);
            if (Empty) {
                headChunk = newChunk;
            }
            //
            // next time allocate twice as much. check fot possible overflows
            //
            nextChunkLength *= 2;
            //
            // update number of chunks in the linked list
            //
            chunkCount++;
            GlobalLog.Print("ScatterGatherBuffers#" + ValidationHelper.HashString(this) + "::AllocateMemoryChunk() chunkCount:" + chunkCount.ToString() + " nextChunkLength:" + nextChunkLength.ToString());
            return newChunk;
        }

        private class MemoryChunk {
            public byte[] Buffer;
            public int FreeOffset; // = 0
            public MemoryChunk Next; // = null
            public MemoryChunk(int bufferSize) {
                Buffer = new byte[bufferSize];
            }
        }

    } // class ScatterGatherBuffers



} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_ntauthentication.cs ===
//------------------------------------------------------------------------------
// <copyright file="_NTAuthentication.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Text;
    using System.Threading;
    using System.Globalization;
    
    internal enum SecureSessionType {
        ClientSession,
        ServerSession
    }

    // C:\fx\src\Net>qgrep ISC_REQ_ \fx\public\tools\inc\sspi.h
    // #define ISC_REQ_DELEGATE                0x00000001
    // #define ISC_REQ_MUTUAL_AUTH             0x00000002
    // #define ISC_REQ_REPLAY_DETECT           0x00000004
    // #define ISC_REQ_SEQUENCE_DETECT         0x00000008
    // #define ISC_REQ_CONFIDENTIALITY         0x00000010
    // #define ISC_REQ_USE_SESSION_KEY         0x00000020
    // #define ISC_REQ_PROMPT_FOR_CREDS        0x00000040
    // #define ISC_REQ_USE_SUPPLIED_CREDS      0x00000080
    // #define ISC_REQ_ALLOCATE_MEMORY         0x00000100
    // #define ISC_REQ_USE_DCE_STYLE           0x00000200
    // #define ISC_REQ_DATAGRAM                0x00000400
    // #define ISC_REQ_CONNECTION              0x00000800
    // #define ISC_REQ_CALL_LEVEL              0x00001000
    // #define ISC_REQ_FRAGMENT_SUPPLIED       0x00002000
    // #define ISC_REQ_EXTENDED_ERROR          0x00004000
    // #define ISC_REQ_STREAM                  0x00008000
    // #define ISC_REQ_INTEGRITY               0x00010000
    // #define ISC_REQ_IDENTIFY                0x00020000
    // #define ISC_REQ_NULL_SESSION            0x00040000
    // #define ISC_REQ_MANUAL_CRED_VALIDATION  0x00080000
    // #define ISC_REQ_RESERVED1               0x00100000
    // #define ISC_REQ_FRAGMENT_TO_FIT         0x00200000

    internal enum ContextFlags {
        //
        // The server in the transport application can
        // build new security contexts impersonating the
        // client that will be accepted by other servers
        // as the client's contexts.
        //
        Delegate        = 0x00000001,

        //
        // The communicating parties must authenticate
        // their identities to each other. Without MutualAuth,
        // the client authenticates its identity to the server.
        // With MutualAuth, the server also must authenticate
        // its identity to the client.
        //
        MutualAuth      = 0x00000002,

        //
        // The security package detects replayed packets and
        // notifies the caller if a packet has been replayed.
        // The use of this flag implies all of the conditions
        // specified by the Integrity flag.
        //
        ReplayDetect    = 0x00000004,

        //
        // The context must be allowed to detect out-of-order
        // delivery of packets later through the message support
        // functions. Use of this flag implies all of the
        // conditions specified by the Integrity flag.
        //
        SequenceDetect  = 0x00000008,

        //
        // The context must protect data while in transit.
        // Confidentiality is supported for NTLM with Microsoft
        // Windows NT version 4.0, SP4 and later and with the
        // Kerberos protocol in Microsoft Windows 2000 and later.
        //
        Confidentiality = 0x00000010,

        UseSessionKey   = 0x00000020,

        AllocateMemory  = 0x00000100,

        //
        // Connection semantics must be used.
        //
        Connection      = 0x00000800,

        //
        // Buffer integrity can be verified but no sequencing
        //
        ClientIntegrity = 0x00010000,

        //
        // or reply detection is enabled.
        //
        ServerIntegrity = 0x00020000,
    }

    internal class NTAuthentication {

        // contains an array of properties, that describe different auth schemes
        static private SecurityPackageInfoClass[] m_SupportedSecurityPackages =
             SSPIWrapper.GetSupportedSecurityPackages(GlobalSSPI.SSPIAuth);

        static private int s_UniqueGroupId = 1;

#if SERVER_SIDE_SSPI
        private SecureSessionType m_SecureSessionType;
#endif
        private CredentialsHandle m_CredentialsHandle;
        private SecurityContext m_SecurityContext;
        private Endianness m_Endianness;
        private string m_RemotePeerId;
        // CONSIDER V.NEXT
        // remove thi bogus variable. the right idea here is to have a bool that returns
        // true iff we have a SecurityContext!=null with a Handle!=-1, change name!
        private bool m_Authenticated;
        private int m_TokenSize;
        private int m_Capabilities;
        private int m_ContextFlags;
        private string m_UniqueUserId;

        internal string UniqueUserId {
            get {
                return m_UniqueUserId;
            }
        }
        private bool m_IsCompleted;
        internal bool IsCompleted {
            get {
                return m_IsCompleted;
            }
            set {
                m_IsCompleted = value;
            }
        }

        //
        // NTAuthentication::NTAuthentication()
        // Created:   12-01-1999: L.M.
        // Parameters:
        //     package - security package to use (kerberos/ntlm/negotiate)
        //     networkCredential - credentials we're using for authentication
        //     remotePeerId - for a server session:
        //                       ignored (except when delegating, in which case this has the same rules as the client session.)
        //                    for a client session:
        //                        for kerberos: specifies the expected account under which the server
        //                                 is supposed to be running (KDC).  If the server runs under a
        //                                 different account an exception is thrown during the blob
        //                                 exchange. (this allows mutual authentication.)
        //                                 One can specify a fully qualified account name (domain\userName)
        //                                 or just a username, in which case the domain is assumed
        //                                 to be the same as the client.
        //                    for ntlm: ignored
        //
        // Description: Initializes SSPI
        //
        public NTAuthentication(string package, NetworkCredential networkCredential, string remotePeerId, DelegationFix delegationFix) {
            GlobalLog.Print("NTAuthentication::.ctor() package:" + package);

#if SERVER_SIDE_SSPI
            m_SecureSessionType = SecureSessionType.ClientSession;
#endif
            m_RemotePeerId = remotePeerId; // only needed for Kerberos, it's the KDC
            m_Endianness = Endianness.Network;
            m_SecurityContext = new SecurityContext(GlobalSSPI.SSPIAuth);

            bool found = false;

            GlobalLog.Print("NTAuthentication::.ctor() searching for name: " + package);

            if (m_SupportedSecurityPackages != null) {
                for (int i = 0; i < m_SupportedSecurityPackages.Length; i++) {
                    GlobalLog.Print("NTAuthentication::.ctor() supported name: " + m_SupportedSecurityPackages[i].Name);
                    if (string.Compare(m_SupportedSecurityPackages[i].Name, package, true, CultureInfo.InvariantCulture) == 0) {
                        GlobalLog.Print("NTAuthentication::.ctor(): found SecurityPackage(" + package + ")");
                        m_TokenSize = m_SupportedSecurityPackages[i].MaxToken;
                        m_Capabilities = m_SupportedSecurityPackages[i].Capabilities;
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                GlobalLog.Print("NTAuthentication::.ctor(): initialization failed: SecurityPackage(" + package + ") NOT FOUND");
                throw new WebException(SR.GetString(SR.net_securitypackagesupport), WebExceptionStatus.SecureChannelFailure);
            }

            // 
            //  In order to prevent a race condition where one request could
            //  steal a connection from another request, before a handshake is
            //  complete, we create a new Group for each authentication request.
            //

            if (package == NtlmClient.AuthType || package == NegotiateClient.AuthType) {
                m_UniqueUserId = (Interlocked.Increment(ref s_UniqueGroupId)).ToString();
            }

            //
            // check if we're using DefaultCredentials
            //
            if (networkCredential is SystemNetworkCredential) {
                //
                // we're using DefaultCredentials
                //
                GlobalLog.Print("NTAuthentication::.ctor(): using DefaultCredentials");

                m_UniqueUserId += "/S"; // save off for unique connection marking

                // DELEGATION:
                // The fix is implemented in cooperation with HttpWebRequest class
                // Remove from both places and change the constructor of NTAuthentication class
                // once the Common Language Runtime will start propagating the Thread token with their stack
                // compression stuff.
                //

                GlobalLog.Assert(delegationFix != null, "DelegationFix ==NULL -> request Credentials has been changed after the request submission!", "");

                if (delegationFix != null) {
                    delegationFix.SetToken();
                }
                GlobalLog.Print("DELEGATION for peer-> '" + m_RemotePeerId + "', SetToken = " + delegationFix.Token.ToString());
                try {
                    m_CredentialsHandle =
                        SSPIWrapper.AcquireCredentialsHandle(
                            GlobalSSPI.SSPIAuth,
                            package,
                            CredentialUse.Outgoing );
                }
                finally {
                    if (delegationFix != null) {
                        delegationFix.RevertToken();
                    }
                    GlobalLog.Print("DELEGATION for peer-> '" + m_RemotePeerId + "', UNSetToken = " + delegationFix.Token.ToString());
                }

                return;
            }

            //
            // we're not using DefaultCredentials, we need a
            // AuthIdentity struct to contain credentials
            // SECREVIEW:
            // we'll save username/domain in temp strings, to avoid decrypting multiple times.
            // password is only used once
            //
            string username = networkCredential.UserName;
            string domain = networkCredential.Domain;

            m_UniqueUserId += domain + "/" + username + "/U"; // save off for unique connection marking
            AuthIdentity authIdentity = new AuthIdentity(username, networkCredential.Password, domain);

            GlobalLog.Print("NTAuthentication::.ctor(): using authIdentity:" + authIdentity.ToString());

            m_CredentialsHandle = SSPIWrapper.AcquireCredentialsHandle(
                                                GlobalSSPI.SSPIAuth,
                                                package,
                                                CredentialUse.Outgoing,
                                                authIdentity
                                                );
        }

        //
        // NTAuth::ContinueNeeded
        // Created:   12-01-1999: L.M.
        // Description:
        // Returns true if we need to continue the authentication handshake
        //
        public bool ContinueNeeded {
            get { return !m_Authenticated;}
        }

#if SERVER_SIDE_SSPI
        //
        // NTAuth::RemoteUser
        // Created:   12-01-1999: L.M.
        // Description:
        // Returns the ID of the remote peer
        //
        public string RemoteUser {
            get {
                if ((SecureSessionType.ClientSession == m_SecureSessionType)
                    && (!MutualAuthSupported))
                    return null; // mutual auth not supported
                return m_RemotePeerId;
            }
        }

        //
        // NTAuth::DelegationSupported
        // Created:   12-01-1999: L.M.
        // Description:
        // returns true if the current context supports delegation
        //
        public bool DelegationSupported {
            get {
                if (!m_Authenticated) {
                    throw new Win32Exception((int)SecurityStatus.InvalidHandle);
                }
                return (m_ContextFlags & (int)ContextFlags.Delegate) != 0;
            }
        }

        //
        // NTAuth::MutualAuthSupported
        // Created:   12-01-1999: L.M.
        // Description:
        // returns true if the current context supports mutual authentication
        //
        public bool MutualAuthSupported {
            get {
                if (!m_Authenticated) {
                    throw new Win32Exception((int)SecurityStatus.InvalidHandle);
                }
                return (m_ContextFlags & (int)ContextFlags.MutualAuth) != 0;
            }
        }

        //
        // NTAuth::ReplayDetectionSupported
        // Created:   12-01-1999: L.M.
        // Description:
        // returns true if the current context supports replay detection
        //
        public bool ReplayDetectionSupported {
            get {
                if (!m_Authenticated) {
                    throw new Win32Exception((int)SecurityStatus.InvalidHandle);
                }
                return (m_ContextFlags & (int)ContextFlags.ReplayDetect) != 0;
            }
        }

        //
        // NTAuth::OutOfOrderDetectionSupported
        // Created:   12-01-1999: L.M.
        // Description:
        // returns true if the current context supports out of order message detection
        //
        public bool OutOfOrderDetectionSupported {
            get {
                if (!m_Authenticated) {
                    throw new Win32Exception((int)SecurityStatus.InvalidHandle);
                }
                return (m_ContextFlags & (int)ContextFlags.SequenceDetect) != 0;
            }
        }

        //
        // NTAuth::ConfidentialitySupported
        // Created:   12-01-1999: L.M.
        // Description:
        // returns true if the current context supports confidentiality
        //
        public bool ConfidentialitySupported {
            get {
                if (!m_Authenticated) {
                    throw new Win32Exception((int)SecurityStatus.InvalidHandle);
                }
                return (m_ContextFlags & (int)ContextFlags.Confidentiality) != 0;
            }
        }

        //
        // NTAuth::IntegritySupported
        // Created:   12-01-1999: L.M.
        // Description:
        // returns true if the current context supports integrity
        //
        public bool IntegritySupported {
            get {
                if (!m_Authenticated) {
                    throw new Win32Exception((int)SecurityStatus.InvalidHandle);
                }
                if (SecureSessionType.ClientSession == m_SecureSessionType) {
                    return (m_ContextFlags & (int)ContextFlags.ClientIntegrity) != 0;
                }
                if (SecureSessionType.ServerSession == m_SecureSessionType) {
                    return (m_ContextFlags & (int)ContextFlags.ServerIntegrity) != 0;
                }
                return true;
            }
        }

        //
        // NTAuth::ImpersonateClient()
        // Created:   12-01-1999: L.M.
        // Description:
        // Impersonates the client on the server
        //
        public void ImpersonateClient() {
            SecurityStatus status = (SecurityStatus)SSPIWrapper.ImpersonateSecurityContext(GlobalSSPI.SSPIAuth, m_SecurityContext.Handle);
            if (SecurityStatus.OK != status) {
                throw new Win32Exception((int)status);
            }
        }

        //
        // NTAuth::RevertToSelf()
        // Created:   12-01-1999: L.M.
        // Description:
        // reverts the server back to itself
        //
        public void RevertToSelf() {
            SecurityStatus status = (SecurityStatus)SSPIWrapper.RevertSecurityContext(GlobalSSPI.SSPIAuth, m_SecurityContext.Handle);
            if (status != SecurityStatus.OK) {
                throw new Win32Exception((int)status);
            }
        }
#endif // SERVER_SIDE_SSPI

        //
        // NTAuth::GetOutgoingBlob()
        // Created:   12-01-1999: L.M.
        // Description:
        // Accepts a base64 encoded incoming security blob and returns
        // a base 64 encoded outgoing security blob
        //
        public string GetOutgoingBlob(string incomingBlob, out bool handshakeComplete) {
            GlobalLog.Enter("NTAuthentication::GetOutgoingBlob", incomingBlob);
            byte[] decodedIncomingBlob = null;
            if (incomingBlob != null && incomingBlob.Length > 0) {
                decodedIncomingBlob = Convert.FromBase64String(incomingBlob);
            }
            byte[] decodedOutgoingBlob = GetOutgoingBlob(decodedIncomingBlob, out handshakeComplete);
            string outgoingBlob = null;
            if (decodedOutgoingBlob != null && decodedOutgoingBlob.Length > 0) {
                outgoingBlob = Convert.ToBase64String(decodedOutgoingBlob);
            }
            GlobalLog.Leave("NTAuthentication::GetOutgoingBlob", outgoingBlob);
            return outgoingBlob;
        }

        //
        // NTAuth::GetOutgoingBlob()
        // Created:   12-01-1999: L.M.
        // Description:
        // Accepts an incoming binary security blob  and returns
        // an outgoing binary security blob
        //
        private byte[] GetOutgoingBlob(byte[] incomingBlob, out bool handshakeComplete) {
            GlobalLog.Enter("NTAuthentication::GetOutgoingBlob", ((incomingBlob == null) ? "0" : incomingBlob.Length.ToString()) + " bytes");

            // default to true in case of failure
            handshakeComplete = true;

            if (m_SecurityContext.Handle!=-1 && incomingBlob==null) {
                // we tried auth previously, now we got a null blob, we're done. this happens
                // with Kerberos & valid credentials on the domain but no ACLs on the resource
                // the handle for m_SecurityContext will be collected at GC time.
                GlobalLog.Print("NTAuthentication#" + ValidationHelper.HashString(this) + "::GetOutgoingBlob() null blob AND m_SecurityContext#" + ValidationHelper.HashString(m_SecurityContext) + "::Handle:[0x" + m_SecurityContext.Handle.ToString("x8") + "]");
                m_SecurityContext.Close();
                IsCompleted = true;
                return null;
            }

            int requestedFlags =
                (int)ContextFlags.Delegate |
                (int)ContextFlags.MutualAuth |
                (int)ContextFlags.ReplayDetect |
                (int)ContextFlags.SequenceDetect |
                (int)ContextFlags.Confidentiality |
                (int)ContextFlags.Connection;

            SecurityBufferClass inSecurityBuffer = null;
            if (incomingBlob != null) {
                GlobalLog.Print("in blob = ");
                GlobalLog.Dump(incomingBlob);
                inSecurityBuffer = new SecurityBufferClass(incomingBlob,BufferType.Token);
            }

            SecurityBufferClass outSecurityBuffer = new SecurityBufferClass(m_TokenSize, BufferType.Token);

            int status;

#if SERVER_SIDE_SSPI
            if (m_SecureSessionType == SecureSessionType.ClientSession) {
#endif
                //
                // client session
                //
                requestedFlags |= (int)ContextFlags.ClientIntegrity;

                status = SSPIWrapper.InitializeSecurityContext(
                                        GlobalSSPI.SSPIAuth,
                                        m_CredentialsHandle.Handle,
                                        m_SecurityContext.Handle,
                                        m_RemotePeerId,
                                        requestedFlags,
                                        m_Endianness,
                                        inSecurityBuffer,
                                        ref m_SecurityContext.Handle,
                                        outSecurityBuffer,
                                        ref m_ContextFlags,
                                        ref m_SecurityContext.TimeStamp
                                        );

                GlobalLog.Print("SSPIWrapper.InitializeSecurityContext() returns 0x" + string.Format("{0:x}", status));
#if SERVER_SIDE_SSPI
            }
            else {
                //
                // server session
                //
                requestedFlags |= (int)ContextFlags.ServerIntegrity;

                status = SSPIWrapper.AcceptSecurityContext(
                                        GlobalSSPI.SSPIAuth,
                                        m_CredentialsHandle.Handle,
                                        m_SecurityContext.Handle,
                                        requestedFlags,
                                        m_Endianness,
                                        inSecurityBuffer,
                                        ref m_SecurityContext.Handle,
                                        outSecurityBuffer,
                                        out m_ContextFlags,
                                        out m_SecurityContext.TimeStamp
                                        );

                GlobalLog.Print("SSPIWrapper.AcceptSecurityContext() returns 0x" + string.Format("{0:x}", status));
            }
#endif // SERVER_SIDE_SSPI

            int errorCode = status & unchecked((int)0x80000000);
            if (errorCode != 0) {
                throw new Win32Exception(status);
            }

            //
            // the return value from SSPI will tell us correctly if the
            // handshake is over or not: http://msdn.microsoft.com/library/psdk/secspi/sspiref_67p0.htm
            // we also have to consider the case in which SSPI formed a new context, in this case we're done as well.
            //
            if (status!=(int)SecurityStatus.OK && m_SecurityContext.Handle!=-1) {
                // we need to continue
                GlobalLog.Print("NTAuthentication#" + ValidationHelper.HashString(this) + "::GetOutgoingBlob() need continue status:[0x" + status.ToString("x8") + "] m_SecurityContext#" + ValidationHelper.HashString(m_SecurityContext) + "::Handle:[0x" + m_SecurityContext.Handle.ToString("x8") + "]");
                handshakeComplete = false;
            }
            else {
                // we're done, cleanup
                GlobalLog.Assert(status ==(int)SecurityStatus.OK, "NTAuthentication#" + ValidationHelper.HashString(this) + "::GetOutgoingBlob() status:[0x" + status.ToString("x8") + "] m_SecurityContext#" + ValidationHelper.HashString(m_SecurityContext) + "::Handle:[0x" + m_SecurityContext.Handle.ToString("x8") + "]", "[STATUS != OK]");
                m_SecurityContext.Close();
                IsCompleted = true;
            }

#if TRAVE
            if (handshakeComplete) {
                //
                // Kevin Damour says:
                // You should not query the securitycontext until you have actually formed one (
                // with a success return form ISC).  It is only a partially formed context and 
                // no info is available to user applications (at least for digest).
                //
                SecurityPackageInfoClass securityPackageInfo = (SecurityPackageInfoClass)SSPIWrapper.QueryContextAttributes(GlobalSSPI.SSPIAuth, m_SecurityContext,ContextAttribute.PackageInfo);
                GlobalLog.Print("SecurityPackageInfoClass: using:[" + ((securityPackageInfo==null)?"null":securityPackageInfo.ToString()) + "]");
            }
#endif // #if TRAVE

            GlobalLog.Print("out token = " + m_TokenSize.ToString());
            GlobalLog.Dump(outSecurityBuffer.token);

            GlobalLog.Leave("NTAuthentication::GetOutgoingBlob", "handshakeComplete:" + handshakeComplete.ToString());

            return outSecurityBuffer.token;
        }

#if XP_WDIGEST

        //
        // for Digest, the server will send us the blob immediately, so we need to make sure we
        // call InitializeSecurityContext() a first time with a null input buffer, otherwise
        // the next call will fail. do so here:
        // WDigest.dll requires us to pass in 3 security buffers here
        // 1) BufferType: SECBUFFER_TOKEN, Content: server's challenge (incoming)
        // 2) BufferType: SECBUFFER_PKG_PARAMS, Content: request's HTTP Method
        // 3) BufferType: SECBUFFER_PKG_PARAMS, Content: the HEntity (this would be the MD5 footprint of the request entity
        //                                                             body, we can pass in NULL as this is not required)
        //
        public string GetOutgoingDigestBlob(string incomingBlob, string requestMethod, out bool handshakeComplete) {
            GlobalLog.Enter("NTAuthentication::GetOutgoingDigestBlob", incomingBlob);
            //
            // first time call with null incoming buffer to initialize.
            // we should get back a 0x90312 and a null outgoingBlob. 
            //
            byte[] decodedOutgoingBlob = GetOutgoingBlob(null, out handshakeComplete);
            GlobalLog.Assert(!handshakeComplete, "NTAuthentication::GetOutgoingDigestBlob() handshakeComplete==true", "");
            GlobalLog.Assert(decodedOutgoingBlob==null, "NTAuthentication::GetOutgoingDigestBlob() decodedOutgoingBlob!=null", "");
            //
            // second time call with 3 incoming buffers to select HTTP client.
            // we should get back a SecurityStatus.OK and a non null outgoingBlob.
            //
            byte[] decodedIncomingBlob = Encoding.Default.GetBytes(incomingBlob);
            byte[] decodedRequestMethod = Encoding.Default.GetBytes(requestMethod);

            int requestedFlags =
                (int)ContextFlags.Delegate |
                (int)ContextFlags.MutualAuth |
                (int)ContextFlags.ReplayDetect |
                (int)ContextFlags.SequenceDetect |
                // (int)ContextFlags.Confidentiality | // this would only work if the server provided a qop="auth-conf" directive
                // (int)ContextFlags.ClientIntegrity | // this would only work if the server provided a qop="auth-int" directive
                (int)ContextFlags.Connection ;

            SecurityBufferClass[] inSecurityBuffers = new SecurityBufferClass[] {
                new SecurityBufferClass(decodedIncomingBlob, BufferType.Token),
                new SecurityBufferClass(decodedRequestMethod, BufferType.Parameters),
                new SecurityBufferClass(null, BufferType.Parameters),
            };

            SecurityBufferClass[] outSecurityBuffers = new SecurityBufferClass[] {
                new SecurityBufferClass(m_TokenSize, BufferType.Token),
            };

            SecurityContext newSecurityContext = new SecurityContext(GlobalSSPI.SSPIAuth);

            //
            // this call is still returning an error. fix together with Kevin Damour
            //
            int status =
                SSPIWrapper.InitializeSecurityContext(
                    GlobalSSPI.SSPIAuth,
                    m_CredentialsHandle.Handle,
                    m_SecurityContext.Handle,
                    m_RemotePeerId, // this must match the Uri in the HTTP status line for the current request
                    requestedFlags,
                    m_Endianness,
                    inSecurityBuffers,
                    ref newSecurityContext.Handle,
                    outSecurityBuffers,
                    ref m_ContextFlags,
                    ref newSecurityContext.TimeStamp );

            GlobalLog.Print("NTAuthentication::GetOutgoingDigestBlob() SSPIWrapper.InitializeSecurityContext() returns 0x" + string.Format("{0:x}", status));

            int errorCode = status & unchecked((int)0x80000000);
            if (errorCode != 0) {
                throw new Win32Exception(status);
            }

            //
            // the return value from SSPI will tell us correctly if the
            // handshake is over or not: http://msdn.microsoft.com/library/psdk/secspi/sspiref_67p0.htm
            // we also have to consider the case in which SSPI formed a new context, in this case we're done as well.
            //
            IsCompleted = (status == (int)SecurityStatus.OK) || (m_SecurityContext.Handle!=-1 && m_SecurityContext.Handle!=newSecurityContext.Handle);
            if (IsCompleted) {
                // ... if we're done, clean the handle up or the call to UpdateHandle() might leak it.
                SSPIWrapper.DeleteSecurityContext(m_SecurityContext.m_SecModule, m_SecurityContext.Handle);
            }
            handshakeComplete = IsCompleted;
            m_Authenticated = m_SecurityContext.Handle != -1;
            m_SecurityContext.UpdateHandle(newSecurityContext);

#if TRAVE
            if (handshakeComplete) {
                //
                // Kevin Damour says:
                // You should not query the securitycontext until you have actually formed one (
                // with a success return form ISC).  It is only a partially formed context and 
                // no info is available to user applications (at least for digest).
                //
                SecurityPackageInfoClass securityPackageInfo = (SecurityPackageInfoClass)SSPIWrapper.QueryContextAttributes(GlobalSSPI.SSPIAuth, m_SecurityContext,ContextAttribute.PackageInfo);
                GlobalLog.Print("SecurityPackageInfoClass: using:[" + ((securityPackageInfo==null)?"null":securityPackageInfo.ToString()) + "]");
            }
#endif // #if TRAVE

            GlobalLog.Assert(outSecurityBuffers.Length==1, "NTAuthentication::GetOutgoingDigestBlob() outSecurityBuffers.Length==" + outSecurityBuffers.Length.ToString(), "");

            GlobalLog.Print("out token = " + m_TokenSize.ToString() + " size = " + outSecurityBuffers[0].size.ToString());
            GlobalLog.Dump(outSecurityBuffers[0].token);

            GlobalLog.Print("NTAuthentication::GetOutgoingDigestBlob() handshakeComplete:" + handshakeComplete.ToString());

            decodedOutgoingBlob = outSecurityBuffers[0].token;

            string outgoingBlob = null;
            if (decodedOutgoingBlob != null && decodedOutgoingBlob.Length > 0) {
                // CONSIDER V.NEXT
                // review Encoding.Default.GetString usage here because it might
                // end up creating non ANSI characters in the string
                outgoingBlob = Encoding.Default.GetString(decodedOutgoingBlob, 0, outSecurityBuffers[0].size);
            }

            GlobalLog.Leave("NTAuthentication::GetOutgoingDigestBlob", outgoingBlob);

            return outgoingBlob;
        }
#endif // #if XP_WDIGEST

/*
        public static string GetRemoteId(SecurityContext m_SecurityContext) {
            return (string)SSPIWrapper.QueryContextAttributes(GlobalSSPI.SSPIAuth, m_SecurityContext, ContextAttribute.Names);
        }
*/        

    } // class NTAuthentication

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    internal struct AuthIdentity{
        //
        // based on the following win32 definition:
        //
        /*
        typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
          unsigned short __RPC_FAR *User;
          unsigned long UserLength;
          unsigned short __RPC_FAR *Domain;
          unsigned long DomainLength;
          unsigned short __RPC_FAR *Password;
          unsigned long PasswordLength;
          unsigned long Flags;
        } SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;
        */
        public string UserName;
        public int UserNameLength;
        public string Domain;
        public int DomainLength;
        public string Password;
        public int PasswordLength;
        public int Flags;

        public AuthIdentity(string userName, string password, string domain) {
            UserName = userName;
            UserNameLength = userName==null ? 0 : userName.Length;
            Password = password;
            PasswordLength = password==null ? 0 : password.Length;
            Domain = domain;
            DomainLength = domain==null ? 0 : domain.Length;
            // Flags are 2 for Unicode and 1 for ANSI. We always use 2.
            Flags = 2;
        }

        public override string ToString() {
            return ValidationHelper.ToString(Domain) + "\\" + ValidationHelper.ToString(UserName) + ":" + ValidationHelper.ToString(Password);
        }

        public static readonly int Size = Marshal.SizeOf(typeof(AuthIdentity));
    }


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_proxyregblob.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ProxyRegBlob.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net {
    using System;
    using System.Globalization;
    using Microsoft.Win32;
    using System.Security.Permissions;
    using System.Text;
    using System.Collections;
    using System.Net.Sockets;

    //
    // Allows us to grob through the registry and read the
    //  IE binary format, note that this should be replaced,
    //  by code that calls Wininet directly, but it can be
    //  expensive to load wininet, in order to do this.
    //

    internal class ProxyRegBlob {

        private byte [] m_RegistryBytes;
        private int m_ByteOffset;
        private const int m_IntReadSize = 4;
        
        public const int IE50ProxyFlag = 0x00000002;
        public const int IE50StrucSize = 60;

        public ProxyRegBlob() {
            m_ByteOffset = 0;
        }

        [RegistryPermission(SecurityAction.Assert, Read="HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections")]
        // returns true - onsuccessful read of proxy registry settings
        public bool ReadRegSettings() {
            RegistryKey key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections");
            if (null != key) {
                m_RegistryBytes = (byte []) key.GetValue("DefaultConnectionSettings");                
                key.Close();
                if ( m_RegistryBytes == null ) {
                    return false;
                } else {
                    return true;
                }
            }

            return false;
        }

        //
        // Reads a string from the byte buffer, cached
        //  inside this object, and then updates the 
        //  offset, NOTE: Must be in the correct offset
        //  before reading, or will error
        //
        public String ReadString() {
            int stringSize;
            string stringOut = null;

            stringSize = ReadInt32();
            if(stringSize > 0)
            {            
                // prevent reading too much
                int  actualSize = m_RegistryBytes.Length - m_ByteOffset;
                if(stringSize >= actualSize)
                    stringSize = actualSize;

                stringOut = Encoding.UTF8.GetString(m_RegistryBytes, m_ByteOffset, stringSize);
            }

            m_ByteOffset += stringSize;
            return stringOut;
        }


        //
        // Reads a DWORD into a Int32, used to read
        //  a int from the byte buffer.
        //
        public Int32 ReadInt32()
        {
            int intValue = 0;
            int readSize = m_IntReadSize;
            int actualSize = m_RegistryBytes.Length - m_ByteOffset;

            // copy bytes and increment offset
            if(readSize <= actualSize)
            {
                intValue += m_RegistryBytes[m_ByteOffset];
                intValue += (16*m_RegistryBytes[m_ByteOffset+1]);
                intValue += (16*16*m_RegistryBytes[m_ByteOffset+2]);
                intValue += (16*16*16*m_RegistryBytes[m_ByteOffset+3]);
        
                m_ByteOffset += readSize;
            }

            // tell caller what we actually read
            return intValue;
        }

        //
        // Parses out a string from IE and turns it into a URI 
        //
        private static Uri ParseProxyUri(string proxyString, bool validate) {
            if (validate) { 
                if (proxyString.Length == 0) {
                    return null;
                }

                if (proxyString.IndexOf('=') != -1) {
                    return null;
                }
            }

            if (proxyString.IndexOf("://") == -1) {
                proxyString = "http://" + proxyString;
            }

            return new Uri(proxyString);
        }

        //
        // Builds a hashtable containing the protocol and proxy URI to use for it.
        //
        private static Hashtable ParseProtocolProxies(string proxyListString) {           
            if (proxyListString.Length == 0) {
                return null;
            }

            // parse something like "http=http://http-proxy;https=http://https-proxy;ftp=http://ftp-proxy"
            char [] splitChars = new char[] { ';', '=' };
            String [] proxyListStrings = proxyListString.Split(splitChars);
            bool protocolPass = true;
            string protocolString = null;

            Hashtable proxyListHashTable = new Hashtable(CaseInsensitiveString.StaticInstance, CaseInsensitiveString.StaticInstance);   

            foreach (string elementString in proxyListStrings) {
                string elementString2 = elementString.Trim().ToLower(CultureInfo.InvariantCulture); 
                if (protocolPass) {
                    protocolString = elementString2;
                } else { 
                    proxyListHashTable[protocolString] = ParseProxyUri(elementString2,false);                    
                }

                protocolPass = ! protocolPass;
            }

            if (proxyListHashTable.Count == 0) {
                return null;
            } 
            
            return proxyListHashTable;
        }    

        //
        // Converts a simple IE regular expresion string into one
        //  that is compatible with Regex escape sequences.
        //
        private static string BypassStringEscape(string bypassString) {
            StringBuilder escapedBypass = new StringBuilder();
            // (\, *, +, ?, |, {, [, (,), ^, $, ., #, and whitespace) are reserved
            foreach (char c in bypassString){
                if (c == '\\' || c == '.' || c=='?') {
                    escapedBypass.Append('\\');
                } else if (c == '*') {
                    escapedBypass.Append('.');
                }
                escapedBypass.Append(c);
            }
            escapedBypass.Append('$');
            return escapedBypass.ToString();
        }


        //
        // Parses out a string of bypass list entries and coverts it to Regex's that can be used 
        //   to match against.
        //
        private static string [] ParseBypassList(string bypassListString, out bool bypassOnLocal) {

            char [] splitChars = new char[] { ';' };
            String [] bypassListStrings = bypassListString.Split(splitChars);

            bypassOnLocal = false;

            if (bypassListStrings.Length == 0) {
                return null;
            }

            ArrayList stringArrayList = new ArrayList();
                      
            foreach (string bypassString in bypassListStrings) {
                string bypassString2 = bypassString;
                if ( bypassString2 != null) {
                    bypassString2 = bypassString2.Trim(); 
                    if (bypassString2.ToLower(CultureInfo.InvariantCulture) == "<local>") {
                        bypassOnLocal = true; 
                    } else if (bypassString2.Length > 0) {                                            
                        bypassString2 = BypassStringEscape(bypassString2);
                        stringArrayList.Add(bypassString2);
                    }
                }
            }

            if (stringArrayList.Count == 0) {
                return null;
            }

            return (string []) stringArrayList.ToArray(typeof(string));
        }


        //
        // Uses this object, by instancing, and retrieves
        //  the proxy settings from IE = converts to URI
        //
        static internal WebProxy GetIEProxy() 
        {
            bool isLocalOverride = false;
            ProxyRegBlob proxyIE5Settings = new ProxyRegBlob();
            Hashtable proxyHashTable = null;
            string [] bypassList = null;
            Uri proxyUri = null;

            if ( !ComNetOS.IsAspNetServer &&
                  proxyIE5Settings.ReadRegSettings() && 
                  proxyIE5Settings.ReadInt32() >= ProxyRegBlob.IE50StrucSize ) 
            {        

                // read the rest of the items out

                proxyIE5Settings.ReadInt32(); // current settings version

                int proxyFlags = proxyIE5Settings.ReadInt32(); // flags
                string proxyUriString = proxyIE5Settings.ReadString(); // proxy name
                string proxyBypassString = proxyIE5Settings.ReadString(); // proxy bypass
                
                // If we need the additional things, keep reading sequentially                   
                //proxyIE5Settings.ReadString(); // autoconfig url
                //proxyIE5Settings.ReadInt32(); // autodetect flags
                //proxyIE5Settings.ReadString(); // last known good auto-prxy url
                // otherwise...
                
                //
                // Once we verify that the flag for proxy is enabled, 
                // Parse UriString that is stored, may be in the form, 
                //  of "http=http://http-proxy;ftp="ftp=http://..." must
                //  handle this case along with just a URI.
                // 

                if ((ProxyRegBlob.IE50ProxyFlag & proxyFlags) == ProxyRegBlob.IE50ProxyFlag)
                {                    
                    try {   
                        proxyUri = ParseProxyUri(proxyUriString, true);
                        if ( proxyUri == null ) {
                            proxyHashTable = ParseProtocolProxies(proxyUriString);
                        }
                        
                        if ((proxyUri != null || proxyHashTable != null) && proxyBypassString != null ) {
                            bypassList = ParseBypassList(proxyBypassString, out isLocalOverride);                        
                        }   

                        // success if we reach here
                    } catch (Exception) {
                    }
                }
            }

            WebProxy webProxy = null;

            if (proxyHashTable != null) {
                webProxy = new WebProxy((Uri) proxyHashTable["http"], isLocalOverride, bypassList);
            } else {
                webProxy = new WebProxy(proxyUri, isLocalOverride, bypassList);
            }
                      
            return webProxy;
        }

    }; // ProxyRegBlob

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_ntlmclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="_NtlmClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Collections;
    using System.Security.Permissions;
    using System.Globalization;
    
    internal class NtlmClient : ISessionAuthenticationModule {

        internal const string AuthType = "NTLM";
        internal static string Signature = AuthType.ToLower(CultureInfo.InvariantCulture);
        internal static int SignatureSize = Signature.Length;

        internal static Hashtable sessions = new Hashtable();

        //
        // RAID#95841
        // SSPI crashes without checking max length, so we need to check the sizes ourselves before
        // we call into SSPI. values are UNLEN, PWLEN and DNLEN taken from sdk\inc\lmcons.h
        // the fix in SSPI will make it to SP4 on win2k.
        //
        internal const int MaxNtlmCredentialSize = 256 + 256 + 15; // UNLEN + PWLEN + DNLEN

        /*
         *  This is to support built-in auth modules under semitrusted environment
         *  Used to get access to UserName, Domain and Password properties of NetworkCredentials
         *  Declarative Assert is much faster and we don;t call dangerous methods inside this one.
         */
        [EnvironmentPermission(SecurityAction.Assert,Unrestricted=true)]
        [SecurityPermissionAttribute( SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]

        public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials) {
            GlobalLog.Print("NtlmClient::Authenticate(): " + challenge);

            GlobalLog.Assert(credentials!=null, "NtlmClient::Authenticate() credentials==null", "");
            if (credentials == null) {
                return null;
            }

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "NtlmClient::Authenticate() httpWebRequest==null", "");
            if (httpWebRequest==null || httpWebRequest.ChallengedUri==null) {
                //
                // there has been no challenge:
                // 1) the request never went on the wire
                // 2) somebody other than us is calling into AuthenticationManager
                //
                return null;
            }

            int index = AuthenticationManager.FindSubstringNotInQuotes(challenge.ToLower(CultureInfo.InvariantCulture), Signature);
            if (index < 0) {
                return null;
            }

            int blobBegin = index + SignatureSize;
            string incoming = null;

            //
            // there may be multiple challenges. If the next character after the
            // package name is not a comma then it is challenge data
            //
            if (challenge.Length > blobBegin && challenge[blobBegin] != ',') {
                ++blobBegin;
            } else {
                index = -1;
            }
            if (index >= 0 && challenge.Length > blobBegin) {
                incoming = challenge.Substring(blobBegin);
            }

            NTAuthentication authSession = sessions[httpWebRequest.CurrentAuthenticationState] as NTAuthentication;
            GlobalLog.Print("NtlmClient::Authenticate() key:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));

            if (authSession==null) {
                NetworkCredential NC = credentials.GetCredential(httpWebRequest.ChallengedUri, Signature);
                GlobalLog.Print("NtlmClient::Authenticate() GetCredential() returns:" + ValidationHelper.ToString(NC));

                if (NC==null) {
                    return null;
                }
                string username = NC.UserName;
                if (username==null || (username.Length==0 && !(NC is SystemNetworkCredential))) {
                    return null;
                }
                //
                // here we cover a hole in the SSPI layer. longer credentials
                // might corrupt the process and cause a reboot.
                //
                if (username.Length + NC.Password.Length + NC.Domain.Length>NtlmClient.MaxNtlmCredentialSize) {
                    //
                    // rather then throwing an exception here we return null so other packages can be used.
                    // this is questionable, hence:
                    // Consider: make this throw a NotSupportedException so it is discoverable
                    //
                    return null;
                }                

                authSession =
                    new NTAuthentication(
                        AuthType,
                        NC,
                        null,
                        httpWebRequest.DelegationFix);

                GlobalLog.Print("NtlmClient::Authenticate() adding authSession:" + ValidationHelper.HashString(authSession) + " for:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState));
                sessions.Add(httpWebRequest.CurrentAuthenticationState, authSession);
            }

            bool handshakeComplete;
            string clientResponse = authSession.GetOutgoingBlob(incoming, out handshakeComplete);
            if (clientResponse==null) {
                return null;
            }

            if (httpWebRequest.UnsafeAuthenticatedConnectionSharing) {
                httpWebRequest.LockConnection = true;
            }

            return AuthenticationManager.GetGroupAuthorization(this, AuthType + " " + clientResponse, false, authSession, httpWebRequest.UnsafeAuthenticatedConnectionSharing);
        }

        public bool CanPreAuthenticate {
            get {
                return false;
            }
        }

        public Authorization PreAuthenticate(WebRequest webRequest, ICredentials Credentials) {
            return null;
        }

        public string AuthenticationType {
            get {
                return AuthType;
            }
        }

        //
        // called when getting the final blob on the 200 OK from the server
        //
        public bool Update(string challenge, WebRequest webRequest) {
            GlobalLog.Print("NtlmClient::Update(): " + challenge);

            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            GlobalLog.Assert(httpWebRequest!=null, "NtlmClient::Update() httpWebRequest==null", "");
            GlobalLog.Assert(httpWebRequest.ChallengedUri!=null, "NtlmClient::Update() httpWebRequest.ChallengedUri==null", "");

            //
            // try to retrieve the state of the ongoing handshake
            //
            NTAuthentication authSession = sessions[httpWebRequest.CurrentAuthenticationState] as NTAuthentication;
            GlobalLog.Print("NtlmClient::Update() key:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState) + " retrieved authSession:" + ValidationHelper.HashString(authSession));            

            if (authSession==null) {
                GlobalLog.Print("NtlmClient::Update() null session returning true");
                return true;
            }

            GlobalLog.Print("NtlmClient::Update() authSession.IsCompleted:" + authSession.IsCompleted.ToString());

            if (!authSession.IsCompleted && httpWebRequest.CurrentAuthenticationState.StatusCodeMatch==httpWebRequest.ResponseStatusCode) {
                GlobalLog.Print("NtlmClient::Update() still handshaking (based on status code) returning false");
                return false;
            }

            //
            // the whole point here is to remove the session, so do it right away.
            //
            GlobalLog.Print("NtlmClient::Update() removing authSession:" + ValidationHelper.HashString(authSession) + " from:" + ValidationHelper.HashString(httpWebRequest.CurrentAuthenticationState));
            sessions.Remove(httpWebRequest.CurrentAuthenticationState);
            //
            // now clean-up the ConnectionGroup after authentication is done.
            //
            if (!httpWebRequest.UnsafeAuthenticatedConnectionSharing) {
                GlobalLog.Print("NtlmClient::Update() releasing ConnectionGroup:" + httpWebRequest.GetConnectionGroupLine());
                httpWebRequest.ServicePoint.ReleaseConnectionGroup(httpWebRequest.GetConnectionGroupLine());
            }

            GlobalLog.Print("NtlmClient::Update() session removed and ConnectionGorup released returning true");
            return true;
        }

        public void ClearSession(WebRequest webRequest) {
            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;
            sessions.Remove(httpWebRequest.CurrentAuthenticationState);
        }

        public bool CanUseDefaultCredentials {
            get {
                return true;
            }
        }

    }; // class NtlmClient


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_ossock.cs ===
//------------------------------------------------------------------------------
// <copyright file="_OSSOCK.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.Net.Sockets;
    using System.Runtime.InteropServices;

    //
    // Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
    //
    [StructLayout(LayoutKind.Sequential)]
    internal struct IPMulticastRequest {

        public int MulticastAddress; // IP multicast address of group
        public int InterfaceAddress; // local IP address of interface

        public static readonly int Size = Marshal.SizeOf(typeof(IPMulticastRequest));
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct Linger {

        public short OnOff; // option on/off
        public short Time; // linger time

        public static readonly int Size = Marshal.SizeOf(typeof(Linger));
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct WSABuffer {

        public int Length; // Length of Buffer
        public IntPtr Pointer;// Pointer to Buffer

    } // struct WSABuffer

    [StructLayout(LayoutKind.Sequential)]
    internal struct WSAData {
        public short wVersion;
        public short wHighVersion;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst=257)]
        public string szDescription;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst=129)]
        public string szSystemStatus;
        public short iMaxSockets;
        public short iMaxUdpDg;
        public int lpVendorInfo;
    }

#if COMNET_QOS

    [StructLayout(LayoutKind.Sequential)]
    internal struct WSAProtcolInfo {
        public int dwServiceFlags1;
        public int dwServiceFlags2;
        public int dwServiceFlags3;
        public int dwServiceFlags4;
        public int dwProviderFlags;
        public Guid ProviderId;
        public int dwCatalogEntryId;

        // WSAPROTOCOLCHAIN ProtocolChain;
        public int ProtocolChainLen;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=7)]
        public int[] ProtocolChainEntries;

        public int iVersion;
        public int iAddressFamily;
        public int iMaxSockAddr;
        public int iMinSockAddr;
        public int iSocketType;
        public int iProtocol;
        public int iProtocolMaxOffset;
        public int iNetworkByteOrder;
        public int iSecurityScheme;
        public int dwMessageSize;
        public int dwProviderReserved;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst=256)]
        public string szProtoco;
    }

#endif // #if COMNET_QOS

    //
    // IPv6 Support: Declare data structures and types needed for
    //               getaddrinfo calls.
    //
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi)]
    internal struct AddressInfo {
        internal int    ai_flags;
        internal int    ai_family;     // We typically only want IP addresses
        internal int    ai_socktype;
        internal int    ai_protocol;
        internal int    ai_addrlen;
        internal string ai_canonname;  // Ptr to the cannonical name - check for NULL
        internal IntPtr ai_addr;       // Ptr to the sockaddr structure
        internal IntPtr ai_next;       // Ptr to the next AddressInfo structure
    }

    [Flags]
    internal enum AddressInfoHints
    {
        AI_PASSIVE     = 0x01, /* Socket address will be used in bind() call */
        AI_CANONNAME   = 0x02, /* Return canonical name in first ai_canonname */ 
        AI_NUMERICHOST = 0x04, /* Nodename must be a numeric address string */
    }

    [Flags]
    internal enum NameInfoFlags
    {
        NI_NOFQDN      = 0x01, /* Only return nodename portion for local hosts */
        NI_NUMERICHOST = 0x02, /* Return numeric form of the host's address */
        NI_NAMEREQD    = 0x04, /* Error if the host's name not in DNS */
        NI_NUMERICSERV = 0x08, /* Return numeric form of the service (port #) */
        NI_DGRAM       = 0x10, /* Service is a datagram service */
    }

    //
    // IPv6 Changes: Argument structure for IPV6_ADD_MEMBERSHIP and
    //               IPV6_DROP_MEMBERSHIP.
    //
    [StructLayout(LayoutKind.Sequential)]
    internal struct IPv6MulticastRequest {

        [MarshalAs(UnmanagedType.ByValArray,SizeConst=16)]
        public byte[] MulticastAddress; // IP address of group
        public int    InterfaceIndex;   // local interface index

        public static readonly int Size = Marshal.SizeOf(typeof(IPv6MulticastRequest));
    }

    [StructLayout(LayoutKind.Sequential,CharSet=CharSet.Auto)]
    internal struct WSAPROTOCOLCHAIN {
        internal int    ChainLen;       /* the length of the chain,     */
                                        /* length = 0 means layered protocol, */
                                        /* length = 1 means base protocol, */
                                        /* length > 1 means protocol chain */
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=7)]
        internal uint[] ChainEntries;   /* a list of dwCatalogEntryIds */
    };

    //
    // IPv6 Changes: Need protocol information for determining whether IPv6 is
    //               available on the local machine.
    //
    [StructLayout(LayoutKind.Sequential,CharSet=CharSet.Auto)]
    internal struct WSAPROTOCOL_INFO {
      internal uint                dwServiceFlags1;
      internal uint                dwServiceFlags2;
      internal uint                dwServiceFlags3;
      internal uint                dwServiceFlags4;
      internal uint                dwProviderFlags;
      internal Guid                ProviderId;
      internal uint                dwCatalogEntryId;
      internal WSAPROTOCOLCHAIN    ProtocolChain;
      internal int                 iVersion;
      internal int                 iAddressFamily;
      internal int                 iMaxSockAddr;
      internal int                 iMinSockAddr;
      internal int                 iSocketType;
      internal int                 iProtocol;
      internal int                 iProtocolMaxOffset;
      internal int                 iNetworkByteOrder;
      internal int                 iSecurityScheme;
      internal uint                dwMessageSize;
      internal uint                dwProviderReserved;
      [MarshalAs(UnmanagedType.ByValTStr,SizeConst=256)]
      internal string              szProtocol;
    };

    //
    // End IPv6 Changes
    //

    //
    // used as last parameter to WSASocket call
    //
    [Flags]
    internal enum SocketConstructorFlags {
        WSA_FLAG_OVERLAPPED         = 0x01,
        WSA_FLAG_MULTIPOINT_C_ROOT  = 0x02,
        WSA_FLAG_MULTIPOINT_C_LEAF  = 0x04,
        WSA_FLAG_MULTIPOINT_D_ROOT  = 0x08,
        WSA_FLAG_MULTIPOINT_D_LEAF  = 0x10,
    }


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_sspiwrapper.cs ===
//------------------------------------------------------------------------------
// <copyright file="_SSPIWrapper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Net.Sockets;
    using System.Security.Permissions;

    internal class SSPIWrapper {

        // private static SecurityPackageInfoClass[] m_SecurityPackages;

        private static SecurityPackageInfoClass[] EnumerateSecurityPackages(SSPIInterface SecModule) {
            GlobalLog.Enter("EnumerateSecurityPackages");

            int moduleCount = 0;
            IntPtr arrayBase = IntPtr.Zero;

            int errorCode =
                SecModule.EnumerateSecurityPackages(
                    out moduleCount,
                    out arrayBase );

            GlobalLog.Print("SSPIWrapper::arrayBase: " + ((long)arrayBase).ToString());

            if (errorCode != 0) {
                throw new Win32Exception(errorCode);
            }

            SecurityPackageInfoClass[] securityPackages = new SecurityPackageInfoClass[moduleCount];

            int i;
            IntPtr unmanagedPointer = arrayBase;

            for (i = 0; i < moduleCount; i++) {
                GlobalLog.Print("SSPIWrapper::unmanagedPointer: " + ((long)unmanagedPointer).ToString());
                securityPackages[i] = new SecurityPackageInfoClass(SecModule, unmanagedPointer);
                unmanagedPointer = IntPtrHelper.Add(unmanagedPointer, SecurityPackageInfo.Size);
            }

            SecModule.FreeContextBuffer(arrayBase);

            GlobalLog.Leave("EnumerateSecurityPackages");
            return securityPackages;
        }

        internal static SecurityPackageInfoClass[] GetSupportedSecurityPackages(
             SSPIInterface SecModule)
        {
            if (SecModule.SecurityPackages == null) {
                SecModule.SecurityPackages = EnumerateSecurityPackages(SecModule);
            }
            return SecModule.SecurityPackages;
        }

        public static CredentialsHandle
        AcquireCredentialsHandle(SSPIInterface SecModule,
                                 string package,
                                 CredentialUse intent
                                 )
        {
            GlobalLog.Print("SSPIWrapper::AcquireCredentialsHandle#1(): using " + package);

            CredentialsHandle credentialsHandle = new CredentialsHandle(SecModule);
            int errorCode = SecModule.AcquireCredentialsHandle(null,
                                                               package,
                                                               (int)intent,
                                                               0,
                                                               0,
                                                               0,
                                                               ref credentialsHandle.Handle,
                                                               ref credentialsHandle.TimeStamp
                                                               );

            if (errorCode != 0) {
#if TRAVE
                GlobalLog.Print("SSPIWrapper::AcquireCredentialsHandle#1(): error " + SecureChannel.MapSecurityStatus((uint)errorCode));
#endif
                throw new Win32Exception(errorCode);
            }
            return credentialsHandle;
        }

        public static CredentialsHandle
        AcquireCredentialsHandle(SSPIInterface SecModule,
                                 string package,
                                 CredentialUse intent,
                                 AuthIdentity authdata
                                 )
        {
            GlobalLog.Print("SSPIWrapper::AcquireCredentialsHandle#2(): using " + package);

            CredentialsHandle credentialsHandle = new CredentialsHandle(SecModule);
            int errorCode = SecModule.AcquireCredentialsHandle(null,
                                                               package,
                                                               (int)intent,
                                                               0,
                                                               authdata,
                                                               0,
                                                               0,
                                                               ref credentialsHandle.Handle,
                                                               ref credentialsHandle.TimeStamp
                                                               );

            if (errorCode != 0) {
#if TRAVE
                GlobalLog.Print("SSPIWrapper::AcquireCredentialsHandle#2(): error " + SecureChannel.MapSecurityStatus((uint)errorCode));
#endif
                throw new Win32Exception(errorCode);
            }
            return credentialsHandle;
        }

        public static CredentialsHandle
        AcquireCredentialsHandle(SSPIInterface SecModule,
                                 string package,
                                 CredentialUse intent,
                                 SChannelCred scc
                                 )
        {
            GlobalLog.Print("SSPIWrapper::AcquireCredentialsHandle#3(): using " + package);

            CredentialsHandle credentialsHandle = new CredentialsHandle(SecModule);
            GCHandle pinnedCertificateArray = new GCHandle();

            if (scc.certContextArray != IntPtr.Zero)
            {

                //
                // We hide the fact that this array must be marshalled
                //  and Pinned, we convert the single value into a pined array
                //  for the Unmanaged call
                //

                IntPtr [] certContextArray = new IntPtr[1] { scc.certContextArray } ;

                pinnedCertificateArray = GCHandle.Alloc( certContextArray, GCHandleType.Pinned );

                //
                // Its now pinned, so get a ptr to its base
                //  this is needed because the Common Language Runtime doesn't support this natively
                //

                scc.certContextArray = pinnedCertificateArray.AddrOfPinnedObject();
            }

            int errorCode = SecModule.AcquireCredentialsHandle(
                                        null,
                                        package,
                                        (int)intent,
                                        0,
                                        ref scc,
                                        0,
                                        0,
                                        ref credentialsHandle.Handle,
                                        ref credentialsHandle.TimeStamp
                                        );

            if (pinnedCertificateArray.IsAllocated) {
                pinnedCertificateArray.Free();
            }

            if (errorCode != 0) {
#if TRAVE
                GlobalLog.Print("SSPIWrapper::AcquireCredentialsHandle#3(): error " + SecureChannel.MapSecurityStatus((uint)errorCode));
#endif
                throw new Win32Exception(errorCode);
            }
            GlobalLog.Print("SSPIWrapper::AcquireCredentialsHandle#3(): cred handle = 0x" + String.Format("{0:x}", credentialsHandle.Handle));
            return credentialsHandle;
        }


        public static int FreeCredentialsHandle(SSPIInterface SecModule, long handle) {
            return SecModule.FreeCredentialsHandle(ref handle);
        }

        internal static int
        InitializeSecurityContext(SSPIInterface SecModule,
                                  long credential,
                                  long context,
                                  string targetName,
                                  int requirements,
                                  Endianness datarep,
                                  SecurityBufferClass inputBuffer,
                                  ref long newContext,
                                  SecurityBufferClass outputBuffer,
                                  ref int attributes,
                                  ref long timestamp
                                  )
        {
            GlobalLog.Enter("InitializeSecurityContext#1");
            GlobalLog.Print("SSPIWrapper::InitializeSecurityContext#1()");
            SecurityBufferClass[] inputBufferArray = null;
            SecurityBufferClass[] outputBufferArray = null;

            if (inputBuffer != null) {
                inputBufferArray = new SecurityBufferClass[1];
                inputBufferArray[0] = inputBuffer;
            }
            if (outputBuffer != null) {
                outputBufferArray = new SecurityBufferClass[1];
                outputBufferArray[0] = outputBuffer;
            }

            int errorCode = InitializeSecurityContext(SecModule,
                                                      credential,
                                                      context,
                                                      targetName,
                                                      requirements,
                                                      datarep,
                                                      inputBufferArray,
                                                      ref newContext,
                                                      outputBufferArray,
                                                      ref attributes,
                                                      ref timestamp
                                                      );

            outputBuffer.type = outputBufferArray[0].type;
            outputBuffer.size = outputBufferArray[0].size;
            outputBuffer.token = outputBufferArray[0].token;
            GlobalLog.Print("SSPIWrapper::InitializeSecurityContext#1(): returning " + String.Format("0x{0:x}", errorCode));
            GlobalLog.Leave("InitializeSecurityContext#1");
            return errorCode;
        }

        internal static int
        InitializeSecurityContext(SSPIInterface SecModule,
                                  long credential,
                                  long context,
                                  string targetName,
                                  int requirements,
                                  Endianness datarep,
                                  SecurityBufferClass[] inputBuffers,
                                  ref long newContext,
                                  SecurityBufferClass[] outputBuffers,
                                  ref int attributes,
                                  ref long timestamp
                                  )
        {
            GlobalLog.Enter("InitializeSecurityContext#2");
            GlobalLog.Print("SSPIWrapper::InitializeSecurityContext#2()");
            GCHandle[] handleOut = null;
            GCHandle[] handleIn = null;

            if (outputBuffers != null) {
                handleOut = PinBuffers(outputBuffers);
            }

            int errorCode = 0;

            SecurityBufferDescriptor outSecurityBufferDescriptor = new SecurityBufferDescriptor(outputBuffers);

            if (inputBuffers == null) {
                GlobalLog.Print("SSPIWrapper::InitializeSecurityContext#2(): inputBuffers == null");
                errorCode = SecModule.InitializeSecurityContext(
                                ref credential,
                                IntPtr.Zero,
                                targetName,
                                requirements,
                                0,
                                (int)datarep,
                                IntPtr.Zero,
                                0,
                                ref newContext,
                                ref outSecurityBufferDescriptor,
                                ref attributes,
                                ref timestamp
                                );
            }
            else {

                handleIn = PinBuffers(inputBuffers);

                SecurityBufferDescriptor inSecurityBufferDescriptor = new SecurityBufferDescriptor(inputBuffers);

                errorCode = SecModule.InitializeSecurityContext(
                                ref credential,
                                ref context,
                                targetName,
                                requirements,
                                0,
                                (int) datarep,
                                ref inSecurityBufferDescriptor,
                                0,
                                ref newContext,
                                ref outSecurityBufferDescriptor,
                                ref attributes,
                                ref timestamp
                                );

                inSecurityBufferDescriptor.FreeAllBuffers(0);
            }

            if ((errorCode == 0) || (errorCode == (int)SecurityStatus.ContinueNeeded)) {

                SecurityBufferClass[] result = outSecurityBufferDescriptor.marshall();

                for (int k = 0; k < outputBuffers.Length; k++) {
                    outputBuffers[k] = result[k];
                }
            }
            outSecurityBufferDescriptor.FreeAllBuffers(requirements);
            if (handleOut != null) {
                FreeGCHandles(handleOut);
            }
            if (handleIn != null) {
                FreeGCHandles(handleIn);
            }
            GlobalLog.Leave("InitializeSecurityContext#2");
            return errorCode;
        }

#if SERVER_SIDE_SSPI
        internal static int AcceptSecurityContext(
            SSPIInterface SecModule,
            long credential,
            long context,
            int requirements,
            Endianness datarep,
            SecurityBufferClass inputBuffer,
            ref long newContext,
            SecurityBufferClass outputBuffer,
            out int attributes,
            out long timestamp
            )
        {
            GlobalLog.Enter("AcceptSecurityContext#1");

            SecurityBufferClass[] inputBufferArray = null;
            SecurityBufferClass[] outputBufferArray = null;

            if (inputBuffer != null) {
                inputBufferArray = new SecurityBufferClass[1];
                inputBufferArray[0] = inputBuffer;
            }
            if (outputBuffer != null) {
                outputBufferArray = new SecurityBufferClass[1];
                outputBufferArray[0] = outputBuffer;
            }

            int errorCode =
                AcceptSecurityContext(
                    SecModule,
                    credential,
                    context,
                    requirements,
                    datarep,
                    inputBufferArray,
                    ref newContext,
                    outputBufferArray,
                    out attributes,
                    out timestamp );

            outputBuffer.type = outputBufferArray[0].type;
            outputBuffer.size = outputBufferArray[0].size;
            outputBuffer.token = outputBufferArray[0].token;

            GlobalLog.Leave("AcceptSecurityContext#1");
            return errorCode;
        }

        private static int AcceptSecurityContext(
            SSPIInterface SecModule,
            long credential,
            long context,
            int requirements,
            Endianness datarep,
            SecurityBufferClass[] inputBuffers,
            ref long newContext,
            SecurityBufferClass[] outputBuffers,
            out int attributes,
            out long timestamp
            )
        {
            GlobalLog.Enter("AcceptSecurityContext#2");

            GCHandle[] handleIn = null;
            GCHandle[] handleOut = null;

            if (inputBuffers != null) {
                handleIn = PinBuffers(inputBuffers);
            }
            if (outputBuffers != null) {
                handleOut = PinBuffers(outputBuffers);
            }

            int errorCode = 0;

            SecurityBufferDescriptor outSecurityBufferDescriptor = new SecurityBufferDescriptor(outputBuffers);

            if (inputBuffers == null) {
                errorCode =
                    SecModule.AcceptSecurityContext(
                        ref credential,
                        0,
                        0,
                        requirements,
                        (int)datarep,
                        ref newContext,
                        ref outSecurityBufferDescriptor,
                        out attributes,
                        out timestamp );
            }
            else {
                SecurityBufferDescriptor inSecurityBufferDescriptor = new SecurityBufferDescriptor(inputBuffers);

                errorCode = SecModule.AcceptSecurityContext(
                    ref credential,
                    ref context,
                    ref inSecurityBufferDescriptor,
                    requirements,
                    (int)datarep,
                    ref newContext,
                    ref outSecurityBufferDescriptor,
                    out attributes,
                    out timestamp );
            }

            SecurityBufferClass[] result = outSecurityBufferDescriptor.marshall();

            outSecurityBufferDescriptor.FreeAllBuffers(requirements);
            FreeGCHandles(handleIn);
            FreeGCHandles(handleOut);
            GlobalLog.Leave("AcceptSecurityContext#2");
            return errorCode;
        }

        public static int ImpersonateSecurityContext(SSPIInterface SecModule, long context) {
            return SecModule.ImpersonateSecurityContext(ref context);
        }

        public static int RevertSecurityContext(SSPIInterface SecModule, long context) {
            return SecModule.RevertSecurityContext(ref context);
        }
#endif // SERVER_SIDE_SSPI

        public static int SealMessage(
            SSPIInterface SecModule,
            ref long context,
            int QOP,
            SecurityBufferClass[] input,
            int sequenceNumber ) {

            GCHandle[] handleIn = PinBuffers(input);
            SecurityBufferDescriptor sdcInOut = new SecurityBufferDescriptor(input);
            int errorCode = SecModule.SealMessage(ref context, QOP, ref sdcInOut, sequenceNumber);

            SecurityBufferClass[] result = sdcInOut.marshall();

            for (int k = 0; k < input.Length; k++) {
                input[k] = result[k];
            }
            sdcInOut.FreeAllBuffers(0);
            FreeGCHandles(handleIn);
            return errorCode;
        }

        public static int UnsealMessage(
            SSPIInterface SecModule,
            ref long context,
            int QOP,
            SecurityBufferClass[] input,
            int sequenceNumber ) {

            GCHandle[] handleIn = PinBuffers(input);
            SecurityBufferDescriptor sdcInOut = new SecurityBufferDescriptor(input);
            int errorCode = SecModule.UnsealMessage(ref context, ref sdcInOut, QOP, sequenceNumber);
            SecurityBufferClass[] result = sdcInOut.marshall();

            for (int k = 0; k < input.Length; k++) {
                input[k] = result[k];
            }
            sdcInOut.FreeAllBuffers(0);
            FreeGCHandles(handleIn);
            return errorCode;
        }

        public static int DeleteSecurityContext(SSPIInterface SecModule, long context) {
            return SecModule.DeleteSecurityContext(ref context);
        }

        public static byte[] QueryContextAttributes(
            SSPIInterface SecModule,
            SecurityContext securityContext,
            ContextAttribute contextAttribute,
            int bytesRequired )
        {
            GlobalLog.Enter("QueryContextAttributes#1");

            byte[] attributeBuffer = new byte[bytesRequired];

            GCHandle pinnedBuffer = GCHandle.Alloc(attributeBuffer, GCHandleType.Pinned);
            IntPtr addrOfPinnedBuffer = pinnedBuffer.AddrOfPinnedObject();

            int errorCode =
                SecModule.QueryContextAttributes(
                    ref securityContext.Handle,
                    (int)contextAttribute,
                    addrOfPinnedBuffer);

            pinnedBuffer.Free();

            GlobalLog.Leave("QueryContextAttributes#1");
            return attributeBuffer;
        }

        public static object QueryContextAttributes(
            SSPIInterface SecModule,
            SecurityContext securityContext,
            ContextAttribute contextAttribute )
        {
            GlobalLog.Enter("QueryContextAttributes#2");

            int nativeBlockSize;

            switch (contextAttribute) {
                case ContextAttribute.StreamSizes:
                    nativeBlockSize = 20;
                    break;
                case ContextAttribute.Names:
                    nativeBlockSize = IntPtr.Size;
                    break;
                case ContextAttribute.PackageInfo:
                    nativeBlockSize = IntPtr.Size;
                    break;
                case ContextAttribute.RemoteCertificate:
                    nativeBlockSize = IntPtr.Size;
                    break;
                case ContextAttribute.LocalCertificate:
                    nativeBlockSize = IntPtr.Size;
                    break;
                case ContextAttribute.IssuerListInfoEx:
                    nativeBlockSize = Marshal.SizeOf(typeof(IssuerListInfoEx));
                    break;
                default:
                    nativeBlockSize = IntPtr.Size;
                    GlobalLog.Assert(false,
                         "contextAttribute unexpected value", "");
                    break;

            }

            IntPtr nativeBlock = Marshal.AllocHGlobal((IntPtr)nativeBlockSize);

            int errorCode =
                SecModule.QueryContextAttributes(
                    ref securityContext.Handle,
                    (int)contextAttribute,
                    nativeBlock);

            object attribute = null;

            if (errorCode == 0) {
                switch (contextAttribute) {
                    case ContextAttribute.StreamSizes:
                        attribute = new StreamSizes(nativeBlock);
                        break;

                    case ContextAttribute.Names:

                        IntPtr unmanagedString = Marshal.ReadIntPtr(nativeBlock);

                        if ( ComNetOS.IsWin9x ) {
                            attribute = Marshal.PtrToStringAnsi(unmanagedString);
                        } else {
                            attribute = Marshal.PtrToStringUni(unmanagedString);
                        }
                        //SecModule.FreeContextBuffer(unmanagedString);
                        break;

                    case ContextAttribute.PackageInfo:

                        IntPtr unmanagedBlock = Marshal.ReadIntPtr(nativeBlock);

                        attribute = new SecurityPackageInfoClass(SecModule, unmanagedBlock);
                        //SecModule.FreeContextBuffer(unmanagedBlock);

                        break;

                    case ContextAttribute.LocalCertificate:
                        goto case ContextAttribute.RemoteCertificate;

                    case ContextAttribute.RemoteCertificate:
                        IntPtr contextHandle = Marshal.ReadIntPtr(nativeBlock);
                        if (contextHandle == ((IntPtr)0)) {
                            Debug.Assert(false,
                                         "contextHandle == 0",
                                         "QueryContextAttributes: marshalled certificate context is null on success"
                                         );
                            
                        } else { 
                            attribute = new CertificateContextHandle(contextHandle);
                        }
                        break;

                    case ContextAttribute.IssuerListInfoEx:
                        IssuerListInfoEx issuerList = new IssuerListInfoEx();

                        issuerList.issuerArray = Marshal.ReadIntPtr(nativeBlock, 0);
                        issuerList.issuerCount = Marshal.ReadInt32(nativeBlock, 4);

                        attribute = issuerList;
                        break;

                    default:
                        // will return null
                        break;
                }
            }
            else {
                //Win32Exception win32Exception = new Win32Exception(errorCode);
                //Console.WriteLine(win32Exception.Message);
            }

            Marshal.FreeHGlobal(nativeBlock);

            GlobalLog.Leave("QueryContextAttributes#2");
            return attribute;
        }

        public static string ErrorDescription(int errorCode) {
            switch (errorCode) {
                case (int)SecurityStatus.InvalidHandle:
                    return "Invalid handle";

                case (int)SecurityStatus.InvalidToken:
                    return "Invalid token";

                case (int)SecurityStatus.ContinueNeeded:
                    return "Continue needed";

                case (int)SecurityStatus.IncompleteMessage:
                    return "Message incomplete";

                case (int)SecurityStatus.WrongPrincipal:
                    return "Wrong principal";

                case (int)SecurityStatus.TargetUnknown:
                    return "Target unknown";

                case (int)SecurityStatus.PackageNotFound:
                    return "Package not found";

                case (int)SecurityStatus.BufferNotEnough:
                    return "Buffer not enough";

                case (int)SecurityStatus.MessageAltered:
                    return "Message altered";

                case (int)SecurityStatus.UntrustedRoot:
                    return "Untrusted root";

                default:
                    return null;
            }
        }

        internal static GCHandle[] PinBuffers(SecurityBufferClass[] securityBuffers) {
            GCHandle[] gchandles = new GCHandle[securityBuffers.Length];
            for (int k = 0; k < securityBuffers.Length; k++) {
                if ((securityBuffers[k] != null) && (securityBuffers[k].token != null)) {
                    gchandles[k] = GCHandle.Alloc(securityBuffers[k].token, GCHandleType.Pinned);
                }
            }
            return gchandles;
        }

        internal static void FreeGCHandles(GCHandle[] gcHandles) {
            if (gcHandles == null) {
                return;
            }
            for (int k = 0; k < gcHandles.Length; k++) {
                if (gcHandles[k].IsAllocated) {
                    gcHandles[k].Free();
                }
            }
        }

    } // class SSPIWrapper


    internal class StreamSizes {

        public int header;
        public int trailer;
        public int maximumMessage;
        public int buffers;
        public int blockSize;

        internal StreamSizes(IntPtr unmanagedAddress) {
            header = Marshal.ReadInt32(unmanagedAddress);
            trailer = Marshal.ReadInt32(unmanagedAddress, 4);
            maximumMessage = Marshal.ReadInt32(unmanagedAddress, 8);
            buffers = Marshal.ReadInt32(unmanagedAddress, 12);
            blockSize = Marshal.ReadInt32(unmanagedAddress, 16);
        }
    }


    [StructLayout(LayoutKind.Sequential)]
    internal struct SecurityPackageInfo {
/*
typedef struct _SecPkgInfo {
    ULONG fCapabilities;  // capability of bit mask
    USHORT wVersion;      // version of driver
    USHORT wRPCID;        // identifier for RPC run time
    ULONG cbMaxToken;     // size of authentication token
    SEC_CHAR * Name;      // text name
    SEC_CHAR * Comment;   // comment
} SecPkgInfo, * PSecPkgInfo;
*/

        public int Capabilities;
        public short Version;
        public short RPCID;
        public int MaxToken;
        public IntPtr Name;
        public IntPtr Comment;

        public static readonly int Size = Marshal.SizeOf(typeof(SecurityPackageInfo));
    }

    
    internal class SecurityPackageInfoClass {

        internal int Capabilities = 0;
        internal short Version = 0;
        internal short RPCID = 0;
        internal int MaxToken = 0;
        internal string Name = null;
        internal string Comment = null;

        
        /*
         *  This is to support SSL under semi trusted enviornment.
         *  Note that it is only for SSL with no client cert
         */
        [ReflectionPermission(SecurityAction.Assert,Flags = ReflectionPermissionFlag.TypeInformation)]

        internal SecurityPackageInfoClass(SSPIInterface SecModule, IntPtr unmanagedAddress) {
            if (unmanagedAddress == IntPtr.Zero) {
                return;
            }

            Capabilities = Marshal.ReadInt32(unmanagedAddress, (int)Marshal.OffsetOf(typeof(SecurityPackageInfo),"Capabilities"));
            Version = Marshal.ReadInt16(unmanagedAddress, (int)Marshal.OffsetOf(typeof(SecurityPackageInfo),"Version"));
            RPCID = Marshal.ReadInt16(unmanagedAddress, (int)Marshal.OffsetOf(typeof(SecurityPackageInfo),"RPCID"));
            MaxToken = Marshal.ReadInt32(unmanagedAddress, (int)Marshal.OffsetOf(typeof(SecurityPackageInfo),"MaxToken"));

            IntPtr unmanagedString;

            unmanagedString = Marshal.ReadIntPtr(unmanagedAddress, (int)Marshal.OffsetOf(typeof(SecurityPackageInfo),"Name"));
            if (unmanagedString != IntPtr.Zero)
            {
                if ( ComNetOS.IsWin9x ) {
                    Name = Marshal.PtrToStringAnsi(unmanagedString);
                } else {
                    Name = Marshal.PtrToStringUni(unmanagedString);
                }
                GlobalLog.Print("Name: " + Name);
                //SecModule.FreeContextBuffer(unmanagedString);
            }

            unmanagedString = Marshal.ReadIntPtr(unmanagedAddress, (int)Marshal.OffsetOf(typeof(SecurityPackageInfo),"Comment"));
            if (unmanagedString != IntPtr.Zero)
            {
                if ( ComNetOS.IsWin9x ) {
                    Comment = Marshal.PtrToStringAnsi(unmanagedString);
                } else {
                    Comment = Marshal.PtrToStringUni(unmanagedString);
                }
                GlobalLog.Print("Comment: " + Comment);
                //SecModule.FreeContextBuffer(unmanagedString);
            }

            GlobalLog.Print("SecurityPackageInfoClass.ctor(): " + ToString());

            return;
        }

        public override string ToString()
        {
            return  "Capabilities:" + String.Format("0x{0:x}", Capabilities)
                + " Version:" + Version.ToString()
                + " RPCID:" + RPCID.ToString()
                + " MaxToken:" + MaxToken.ToString()
                + " Name:" + ((Name==null)?"(null)":Name)
                + " Comment:" + ((Comment==null)?"(null)":Comment
                );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_tlsstream.cs ===
//------------------------------------------------------------------------------
// <copyright file="_TLSstream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {
    using System.IO;
    using System.Text;
    using System.Net.Sockets;
    using System.Threading;
    using System.Security.Cryptography.X509Certificates;
    using System.ComponentModel;
    using System.Collections;

    internal class TlsStream : NetworkStream, IDisposable {

        private String          m_DestinationHost;
        private SecureChannel   m_SecureChannel;
        private byte[]          m_ArrivingData;
        private int             m_ExistingAmount = 0;
        private X509CertificateCollection m_ClientCertificates;
        private Exception       m_Exception;
        private int             m_NestCounter;
        private byte[]          m_AsyncResponseBuffer;

        private SecureChannel SecureChannel {
            get {
                return m_SecureChannel;
            }
        }

        //
        // we will only define a constructor that takes the ownsSocket parameter,
        // even if internally we will always use it with true. we just want to
        // make it clear that the stream we create owns the Socket
        //
        public TlsStream(String destinationHost, Socket socket, bool ownsSocket, X509CertificateCollection clientCertificates) : base(socket, ownsSocket) {
            GlobalLog.Enter("TlsStream::TlsStream", "host="+destinationHost+", #certs="+((clientCertificates == null) ? "none" : clientCertificates.Count.ToString()));

            m_DestinationHost = destinationHost;
            m_ClientCertificates = clientCertificates; // null if not used
            m_NestCounter = 0;

            //
            // The Handshake is done synchronously as part of the constructor,
            //   or later on alerts/challenges/etc
            //

            InnerException = Handshake(null);
            GlobalLog.Leave("TlsStream::TlsStream");
        }

        /*++

            Read property for this class. A TlsStream is readable so we return
            true. This is a read only property.

            Input: Nothing.

            Returns: True.

         --*/

        public override bool CanRead {
            get {
                return true;
            }
        }

        /*++

            Seek property for this class. Since this stream is not
            seekable, we just return false. This is a read only property.

            Input: Nothing.

            Returns: false

         --*/

        public override bool CanSeek {
            get {
                return false;
            }
        }

        /*++

            Write property for this class.  A TlsStream is writable so we
            return true. This is a read only property.

            Input: Nothing.

            Returns: True.

         --*/

        public override bool CanWrite {
            get {
                return true;
            }
        }

        /*++

            Length property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Length {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }
        }

        /*++

            Position property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Position {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }
            set {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }
        }

        /*++
            Flush - Flush the stream

            Called when the user wants to flush the stream. This is meaningless to
            us, so we just ignore it.

            Input:

                Nothing.

            Returns:

                Nothing.

        --*/
        public override void Flush() {
        }

        /*++
            SetLength - Set the length on the stream

            Called when the user wants to set the stream length. Since we don't
            support seek, we'll throw an exception.

            Input:

                value       - length of stream to set

            Returns:

                Throws exception


        --*/

        public override void SetLength(long value) {
            throw new NotSupportedException(SR.GetString(SR.net_noseek));
        }

        /*++

            Seek property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

         --*/

        public override long Seek(long offset, SeekOrigin Origin) {
            throw new NotSupportedException(SR.GetString(SR.net_noseek));
        }

        /*++

            Close method for this class. Closes the TlsStream

            Input: Nothing.

            Returns: Nothing.

         --*/
        public override void Close() {
            GlobalLog.Print("TlsStream::Close()");
            ((IDisposable)this).Dispose();
        }

        int m_ShutDown = 0;
        protected override void Dispose(bool disposing) {
            GlobalLog.Print("TlsStream::Dispose()");
            if ( Interlocked.Exchange( ref m_ShutDown,  1) == 1 ) {
                return;
            }

            if (disposing) {
                m_DestinationHost = null;
                m_SecureChannel = null;
                m_ArrivingData = null;
                m_ClientCertificates = null;

                // This might leak memory but we do clenup through garbage-collection
                if (m_Exception==null) {
                    m_Exception = new WebException(
                                    NetRes.GetWebStatusString("net_requestaborted", WebExceptionStatus.ConnectionClosed),
                                    WebExceptionStatus.ConnectionClosed);
                }
            }
            //
            // only resource we need to free is the network stream, since this
            // is based on the client socket, closing the stream will cause us
            // to flush the data to the network, close the stream and (in the
            // NetoworkStream code) might close the socket as well if we own it.
            //
            base.Dispose(disposing);
        }

        void IDisposable.Dispose() {
            Dispose(true);
            // We don't suppress garbage-collection here since need to cleanup m_Exception member lately
        }

        public override bool DataAvailable {
            get {
                return m_ExistingAmount>0;
            }
        }


        //
        // Read, all flavours: synchronous and asynchrnous
        //
        public override int Read(byte[] buffer, int offset, int size) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::Read() SecureChannel#" + ValidationHelper.HashString(SecureChannel) + " offset:" + offset.ToString() + " size:" + size.ToString());
            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            // on earlier error throw an exception
            if (InnerException != null) {
                throw InnerException;
            }
            if (m_ExistingAmount==0) {

                // cannot handle nested Read, Read calls without corrsponding EndRead
                //GlobalLog.Assert(Interlocked.Increment( ref m_NestCounter ) == 1,
                //    "TlsStream::Read m_NestCounter!=1, nesting not allowed of Read",
                //    m_NestCounter.ToString());

                if (Interlocked.Increment( ref m_NestCounter ) != 1) {
                    throw new ArgumentException("TlsStream");
                }

                try {
                    NextRecord(null, 0);
                }
                catch(Exception exception) {
                    InnerException = new IOException(SR.GetString(SR.net_io_readfailure), exception);
                    Interlocked.Decrement(ref m_NestCounter);
                    throw InnerException;
                }

                Interlocked.Decrement( ref m_NestCounter );
            }
            return TransferData(buffer, offset, size);
        }

        public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback asyncCallback, object asyncState) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::BeginRead() SecureChannel#" + ValidationHelper.HashString(SecureChannel) + " offset:" + offset.ToString() + " size:" + size.ToString());
            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            // on earlier error throw an exception
            if (InnerException != null) {
                throw InnerException;
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            // cannot handle nested BeginRead, BeginRead calls without corrsponding EndRead
            //GlobalLog.Assert(Interlocked.Increment( ref m_NestCounter ) == 1,
            //    "TlsStream::BeginRead m_NestCounter!=1, nesting not allowed of BeginRead",
            //    m_NestCounter.ToString());

            if (Interlocked.Increment( ref m_NestCounter ) != 1) {
                throw new ArgumentException("TlsStream");
            }

            NestedSingleAsyncResult asyncResult = new NestedSingleAsyncResult (this, asyncState, asyncCallback, buffer, offset, size);

            // check if there is already data present
            if (m_ExistingAmount>0) {
                GlobalLog.Print("BeginReceive: data already present in buffer!");

                // In this case no I/O is performed-- data is copied
                // from internal buffer to the user space

                asyncResult.InvokeCallback(true);
            }
            else {
                // otherwise we have to read data from the network and decrypt
                // to preserve asynchronous mode, the I/O operation will be
                // qued as a work item for the runtime thread pool

                GlobalLog.Print("BeginReceive: must issue read from network");

                SecureChannel chkSecureChannel = SecureChannel;
                if (chkSecureChannel == null) {
                    //this object was disposed from other thread
                    throw new ObjectDisposedException(this.GetType().FullName); 
                }
                int bufferLength = chkSecureChannel.HeaderSize;
                m_AsyncResponseBuffer = new byte[bufferLength];
                try {
                    asyncResult.NestedAsyncResult = base.BeginRead(
                                                        m_AsyncResponseBuffer,
                                                        0,
                                                        bufferLength,
                                                        new AsyncCallback(AsyncReceiveComplete),
                                                        asyncResult
                                                        );
                } catch (Exception exception) {
                    GlobalLog.Print("TlsStream#"+ValidationHelper.HashString(this)+"::BeginRead() exception: "+exception);
                    InnerException = new IOException(SR.GetString(SR.net_io_readfailure), exception);
                    throw;
                }
                if (asyncResult.NestedAsyncResult == null) {
                    GlobalLog.Print("TlsStream#"+ValidationHelper.HashString(this)+"::BeginRead(): base.BeginRead() returns null");
                }
            }
            return asyncResult;
        }

        private void AsyncReceiveComplete(IAsyncResult result) {
            GlobalLog.Enter("TlsStream#"+ValidationHelper.HashString(this)+"::AsyncReceiveComplete");
            try {
                int bytesRead = base.EndRead(result);
                GlobalLog.Print("TlsStream#"+ValidationHelper.HashString(this)+"::AsyncReceiveComplete: received "+bytesRead+" bytes");
                GlobalLog.Dump(m_AsyncResponseBuffer, bytesRead);
                NextRecord(m_AsyncResponseBuffer, bytesRead);
            } catch (Exception exception) {
                InnerException = new IOException(SR.GetString(SR.net_io_readfailure), exception);
            }
            ((NestedSingleAsyncResult)result.AsyncState).InvokeCallback(false);
            GlobalLog.Leave("TlsStream#"+ValidationHelper.HashString(this)+"::AsyncReceiveComplete");
        }

        public override int EndRead(IAsyncResult asyncResult) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::EndRead() IAsyncResult#" + ValidationHelper.HashString(asyncResult));
            // on earlier error throw an exception
            if (InnerException != null) {
                throw InnerException;
            }
            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            Interlocked.Decrement(ref m_NestCounter);

            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            NestedSingleAsyncResult castedAsyncResult = asyncResult as NestedSingleAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndRead"));
            }

            castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            if (m_ArrivingData==null) {
                return 0;
            }

            int tranferredData = TransferData(castedAsyncResult.Buffer, castedAsyncResult.Offset, castedAsyncResult.Size);

            return tranferredData;
        }


        //
        // Write, all flavours: synchrnous and asynchrnous
        //
        public override void Write(byte[] buffer, int offset, int size) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::Write() SecureChannel#" + ValidationHelper.HashString(SecureChannel) + " offset:" + offset.ToString() + " size:" + size.ToString());
            InnerWrite(false /*async*/, buffer, offset, size, null, null);
		}

        //
        // BeginWrite -
        //
        // Write the bytes to the write - while encrypting
        //
        // copy plain text data to a temporary buffer
        // encrypt the data
        // once the data is encrypted clear the plain text for security
        //

        public override IAsyncResult BeginWrite( byte[] buffer, int offset, int size, AsyncCallback asyncCallback, object asyncState) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::BeginWrite() SecureChannel#" + ValidationHelper.HashString(SecureChannel) + " offset:" + offset.ToString() + " size:" + size.ToString());
            return InnerWrite(true /*async*/, buffer, offset, size, asyncCallback, asyncState);
        }

        private IAsyncResult InnerWrite(bool async, byte[] buffer, int offset, int size, AsyncCallback asyncCallback, object asyncState) {
            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            // on earlier error throw an exception
            if (InnerException != null) {
                throw InnerException;
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }


            //
            // Lock the Write: this is inefficent, but we need to prevent
            //  writing data while the Stream is doing a handshake with the server.
            //  writing other data during the handshake would cause the server to
            //  fail and close the connection.
            //

            lock (this) {

                //
                // encrypt the data
                //

                byte[] ciphertext = null;

                GlobalLog.Print("Encrypt[" + Encoding.ASCII.GetString(buffer, 0, Math.Min(buffer.Length,512)) + "]");

                SecureChannel chkSecureChannel = SecureChannel;
                if (chkSecureChannel==null) {
                    InnerException = new IOException(SR.GetString(SR.net_io_writefailure));
                    throw InnerException;

                }

                if (size > chkSecureChannel.MaxDataSize) {
                    BufferOffsetSize [] buffers = new BufferOffsetSize[1];
                    buffers[0] = new BufferOffsetSize(buffer, offset, size, false);
                    if (async) {
                        return BeginMultipleWrite(buffers, asyncCallback, asyncState);
                    } else {
                        MultipleWrite(buffers);
                        return null;
                    }
                }

                int errorCode = chkSecureChannel.Encrypt(buffer, offset, size, ref ciphertext);

                if (errorCode != (int)SecurityStatus.OK) {
                    ProtocolToken message = new ProtocolToken(null, errorCode);
                    InnerException = message.GetException();
                    throw InnerException;
                }

                try {
                    if (async) {
                        IAsyncResult asyncResult =
                            base.BeginWrite(
                                ciphertext,
                                0,
                                ciphertext.Length,
                                asyncCallback,
                                asyncState);

                        return asyncResult;
                    } else {
                        base.Write(ciphertext, 0, ciphertext.Length);
                        return null;
                    }
                }
                catch (Exception exception) {
                    //
                    // some sort of error occured Writing to the Trasport,
                    // set the Exception as InnerException and throw
                    //
                    InnerException = new IOException(SR.GetString(SR.net_io_writefailure), exception);
                    throw InnerException;
                }
            }
        }


        public override void EndWrite(IAsyncResult asyncResult) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::EndWrite() IAsyncResult#" + ValidationHelper.HashString(asyncResult));

            // on earlier error throw an exception
            if (InnerException != null) {
                throw InnerException;
            }
            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }

            if (asyncResult is OverlappedAsyncResult &&
                ((OverlappedAsyncResult)asyncResult).UsingMultipleSend) {
                EndMultipleWrite(asyncResult);
                return;
            }

            try {
                base.EndWrite(asyncResult);
            }
            catch (Exception exception) {
                //
                // The Async IO completed with a failure.
                //
                InnerException = new IOException(SR.GetString(SR.net_io_writefailure), exception);
                throw InnerException;
            }
        }


        internal override void MultipleWrite(BufferOffsetSize[] buffers) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::BeginMultipleWrite() SecureChannel#" + ValidationHelper.HashString(SecureChannel) + " buffers.Length:" + buffers.Length.ToString());
            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            // on earlier error throw an exception
            if (InnerException != null) {
                throw InnerException;
            }
            //
            // parameter validation
            //
            if (buffers == null) {
                throw new ArgumentNullException("buffers");
            }

            //
            // Lock the Write: this is inefficent, but we need to prevent
            //  writing data while the Stream is doing a handshake with the server.
            //  writing other data during the handshake would cause the server to
            //  fail and close the connection.
            //

            lock (this) {

                //
                // encrypt the data
                //

                // do we need to lock this during the write as well?
                BufferOffsetSize [] encryptedBuffers = EncryptBuffers(buffers);
                try {
                    //
                    // call BeginMultipleWrite on the NetworkStream.
                    //
                    base.MultipleWrite(encryptedBuffers);
                }
                catch (Exception exception) {
                    //
                    // some sort of error occured on the socket call,
                    // set the SocketException as InnerException and throw
                    //

                    InnerException = new IOException(SR.GetString(SR.net_io_writefailure), exception);
                    throw InnerException;
                }
            }
        }

        internal override IAsyncResult BeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::BeginMultipleWrite() SecureChannel#" + ValidationHelper.HashString(SecureChannel) + " buffers.Length:" + buffers.Length.ToString());
            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            // on earlier error throw an exception
            if (InnerException != null) {
                throw InnerException;
            }
            //
            // parameter validation
            //
            if (buffers == null) {
                throw new ArgumentNullException("buffers");
            }

            //
            // Lock the Write: this is inefficent, but we need to prevent
            //  writing data while the Stream is doing a handshake with the server.
            //  writing other data during the handshake would cause the server to 
            //  fail and close the connection. 
            //

            lock (this) {

                //
                // encrypt the data
                //

                // do we need to lock this during the write as well?
                BufferOffsetSize [] encryptedBuffers = EncryptBuffers(buffers);

                try {
                    //
                    // call BeginMultipleWrite on the NetworkStream.
                    //
                    IAsyncResult asyncResult =
                         base.BeginMultipleWrite(
                            encryptedBuffers,
                            callback,
                            state);

                    return asyncResult;
                }
                catch (Exception exception) {
                    //
                    // some sort of error occured on the socket call,
                    // set the SocketException as InnerException and throw
                    //

                    InnerException = new IOException(SR.GetString(SR.net_io_writefailure), exception);
                    throw InnerException;
                }
            }
        }

        internal override void EndMultipleWrite(IAsyncResult asyncResult) {
            GlobalLog.Print("TlsStream#" + ValidationHelper.HashString(this) + "::EndMultipleWrite() IAsyncResult#" + ValidationHelper.HashString(asyncResult));

            // on earlier error throw an exception
            if (InnerException != null) {
                throw InnerException;
            }

            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            //
            // parameter validation
            //
            GlobalLog.Assert(asyncResult!=null, "TlsStream:EndMultipleWrite(): asyncResult==null", "");

            try {
                base.EndMultipleWrite(asyncResult);
            }
            catch (Exception exception) {
                //
                // The Async IO completed with a failure.
                //
                InnerException = new IOException(SR.GetString(SR.net_io_writefailure), exception);
                throw InnerException;
            }
        }


        //
        // these methods are not overridden
        //


        //
        // Status - returns Success if we're looking good,
        //  and there was no exception thrown in Handshake
        //

        public WebExceptionStatus Status {
            get {
                if ( m_Exception == null ) {
                    return WebExceptionStatus.Success;
                }
                else {
                    return WebExceptionStatus.SecureChannelFailure;
                }
            }
        }

        public X509Certificate Certificate {
            get {
                SecureChannel chkSecureChannel = SecureChannel;
                return chkSecureChannel!=null ? chkSecureChannel.ServerCertificate : null;
            }
        }

        public X509Certificate ClientCertificate {
            get {
                SecureChannel chkSecureChannel = SecureChannel;
                return chkSecureChannel!=null ? chkSecureChannel.ClientCertificate : null;
            }
        }

        public Exception InnerException {
            get {
                return m_Exception;
            }
            set {
                if (value != null) {
                    m_Exception = value;
                    this.Close();
                }
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Performs encryption of an array of buffers,
        ///         proceeds buffer by buffer, if the individual 
        ///         buffer size exceeds a SSL limit of 64K,
        ///         the buffers are then split into smaller ones. 
        ///       Returns a new array of encrypted buffers.
        ///    </para>
        /// </devdoc>
        private BufferOffsetSize [] EncryptBuffers(BufferOffsetSize[] buffers) {
            // do we need lock this write as well?
            ArrayList encryptedBufferList = new ArrayList(buffers.Length);            
            for (int i = 0; i < buffers.Length; i++) {
                SecureChannel chkSecureChannel = SecureChannel;
                if (chkSecureChannel==null) {
                    InnerException = new IOException(SR.GetString(SR.net_io_writefailure));
                    throw InnerException;
                }

                int offset = buffers[i].Offset;
                int totalLeft = buffers[i].Size;
                do {
                    byte [] tempOutput = null;                    
                    int size = Math.Min(totalLeft, chkSecureChannel.MaxDataSize);                    
                                
                    totalLeft -= size;

                    int errorCode = chkSecureChannel.Encrypt(buffers[i].Buffer, offset, size, ref tempOutput);

                    if (errorCode != (int)SecurityStatus.OK) {
                        ProtocolToken message = new ProtocolToken(null, errorCode);
                        InnerException = message.GetException();
                        throw InnerException;
                    }

                    encryptedBufferList.Add(new BufferOffsetSize(tempOutput, false));

                    offset += size;
                } while (totalLeft > 0);
            }
            return (BufferOffsetSize []) encryptedBufferList.ToArray(typeof(BufferOffsetSize));
        }


        internal bool VerifyServerCertificate(ICertificateDecider decider) {
            SecureChannel chkSecureChannel = SecureChannel;
            return chkSecureChannel!=null ? chkSecureChannel.VerifyServerCertificate(decider) : false;
        }

        private int TransferData(byte[] buffer, int offset, int size) {
            int bytesToCopy = Math.Min(size, m_ExistingAmount);

            if (bytesToCopy != 0) {

                // verify that there is data present
                if (m_ArrivingData==null) {
                    return 0;
                }

                int beginIndex = m_ArrivingData.Length - m_ExistingAmount;
                Buffer.BlockCopy(m_ArrivingData, beginIndex, buffer, offset, bytesToCopy);

                // wipe off the portion of decrypted data transferred
                Array.Clear(m_ArrivingData, beginIndex, bytesToCopy);

                m_ExistingAmount -= bytesToCopy;
            }

            return bytesToCopy;
        }


        //
        // Handshake - the Handshake is perhaps the most important part of the SSL process,
        //  this is a Handshake protocol between server & client, where we send a
        //  a HELLO message / server responds, we respond back, and after a few round trips,
        //  we have an SSL connection with the server.  But this process may be repeated,
        //  if a higher level of security is required for by the server, therefore,
        //  this function may be called several times in the life of the connection.
        //
        //  returns an Exception on error, containing the error code of the failure
        //

        private Exception Handshake(ProtocolToken message) {

            //
            // With some SSPI APIs, the SSPI wrapper may throw
            //  uncaught Win32Exceptions, so we need to add
            //  this try - catch here.
            //

            try {

                int round = 0;
                byte[] incoming = null;

                // will be null == message on connection creation/otherwise should be
                //  renegotation

                if (message == null) {

                    GlobalLog.Assert(
                        (SecureChannel == null),
                        "had assembed a null SecureChannel at this point",
                        "SecureChannel != null" );

                    m_SecureChannel = new SecureChannel(m_DestinationHost, m_ClientCertificates);
                }
                else {
                    incoming = message.Payload;
                }

                do {
                    GlobalLog.Print("Handshake::Round #" + round);

                    //
                    // this code runs in the constructor, hence there's no
                    // way SecureChannel can become null
                    //
                    message = SecureChannel.NextMessage(incoming);

#if TRAVE
                    GlobalLog.Print("Handshake::generating TLS message(Status:"+SecureChannel.MapSecurityStatus((uint)message.Status)+" Done:"+message.Done.ToString()+")");
#endif

                    if (message.Failed) {
                        break;
                    }

                    if (message.Payload!=null) {
                        GlobalLog.Print("Handshake::Outgoing message size: " + message.Payload.Length);
                        GlobalLog.Dump(message.Payload);
                        base.Write(message.Payload, 0, message.Payload.Length);
                    }
                    else {
                        GlobalLog.Print("Handshake::No message necessary.");
                    }

                    if (message.Done) {
                        break;
                    }

                    //
                    // ReadFullRecord attempts to parse read data
                    //   from the byte stream, this can be dangerous as its not
                    //   always sure about protocols, at this point
                    //

                    incoming = ReadFullRecord(null, 0);

                    if (incoming == null) {
                        //
                        // Handshake failed
                        //
                        GlobalLog.Print("Handshake::ReadFullRecord is null, Handshake failed");

                        GlobalLog.Assert(
                            (! message.Done ),
                            "attempted bad return / must always fail",
                            "message.Done" );

                        return message.GetException();
                    }

                    GlobalLog.Print("Handshake::Incoming message size: " + incoming.Length);
                    round++;

                } while (!message.Done);

                if (message.Done) {
                    SecureChannel.ProcessHandshakeSuccess();
                    GlobalLog.Print("Handshake::Handshake completed successfully.");
                }
                else {
                    // SEC_I_CONTINUE_NEEDED
#if TRAVE
                    GlobalLog.Print("Handshake::FAILED Handshake, last error: " + SecureChannel.MapSecurityStatus((uint)message.Status));
#endif
                }
                return message.GetException();
            }
            catch (Exception exception) {
                return exception;
            }
        }

        //
        // NextRecord - called typically in Callback
        //  to indicate that we need more bytes from the wire
        //  to be decrypted.  It is called either by a worker
        //  thread or by the Read directly, it reads one chunk
        //  of data, and attempts to decrypt.  As soon as it has
        //  the chunk of unencrypted data, it returns it in
        //  m_ArrivingData and m_ExistingAmount contains,
        //  the amount data that was decrypted.
        //
        // ASSUMES: we have an empty buffer of unencrypted bytes
        // RETURNS: upon error, by either leaving this buffer empty (0),
        //   with an Exception set on this object, or on success,
        //   by updating the global state (m_ArrivingData)
        //   with unencrypted bytes
        //
        // WARNING: Can Throw!
        //
        private void NextRecord(byte[] buffer, int length) {

            byte[] packet = null;

            GlobalLog.Assert(
                (m_ExistingAmount == 0),
                "m_ExistingAmount != 0",
                "Has assumed internal SSL buffer would be empty" );

            //
            // This LOOP below will keep going until (EITHER):
            //   1) we have ONE succesful chunk of unencrypted data
            //   2) we have an error either from a renegotiate handhake (OR) Read (OR) Decrypt
            //

            do {

                packet = ReadFullRecord(buffer, length);

                if (packet==null) {
                    return;
                }

                lock (this) {
                    SecureChannel chkSecureChannel = SecureChannel;
                    if (chkSecureChannel==null) {
                        return;
                    }

                    int errorCode = chkSecureChannel.Decrypt(packet, ref m_ArrivingData);

                    if (errorCode == (int)SecurityStatus.OK) {

                        // SUCCESS - we have our decrypted Bytes

                        GlobalLog.Print("TlsStream::NextRecord called (success) Decrypt["
                            + (m_ArrivingData != null
                                ? (Encoding.ASCII.GetString(m_ArrivingData, 0, Math.Min(m_ArrivingData.Length,512)))
                                : "null")
                                 + "]" );
                        break;
                    }
                    else {

                        // ERROR - examine what kind

                        ProtocolToken message = new ProtocolToken(packet, errorCode);

                        GlobalLog.Print("TlsStream:: Decrypt errorCode = " + errorCode.ToString());

                        if (message.Renegotiate) {

                            // HANDSHAKE - do a handshake between us and server

                            InnerException = Handshake(message);
                            if (InnerException != null ) {
                                return; // failure
                            }

                            // CONTINUE - Read On! we pick up from where
                            //  we were before the handshake and try to get
                            //  one block of unencrypted bytes, the earlier block
                            //  of data was control information for the handshake.
                            
                            //  We need to read in the new header.
                            if (ForceRead(buffer,0,length) < length) {
                                InnerException = new IOException(SR.GetString(SR.net_io_readfailure));
                                return; //failure
                            }
                        }
                        else if (message.CloseConnection) {

                            // CLOSE - server ordered us to shut down

                            Close(); // close down the socket
                            return;
                        }
                        else {

                            // EXCEPTION - throw later on

                            InnerException = message.GetException();
                            return;
                        }
                    }
                }

                // continue here in the case where we had a handshake, and needed
                //  to reget new Data

            } while (true);

            // m_ExistingAmount was 0 on entry!

            if (m_ArrivingData==null) {
                return;
            }

            m_ExistingAmount = m_ArrivingData.Length;

            return;
        }

        //
        // formally a RecordLayer class,
        //   cut was made here, now the same object
        //

        private const int m_ChangeCipherSpec = 20;
        private const int m_Alert            = 21;
        private const int m_HandShake        = 22;
        private const int m_AppData          = 23;

        //
        // ReadFullRecord - reads a block of bytes,
        //  attemps to ascertain, how much to read, by
        //  assuming block encoding of the byte stream.
        //
        // This can be dangerous as these things
        //   tend to change from protocol to protocol
        //
        // WARNING: Can throw!
        //
        public byte[] ReadFullRecord(byte[] buffer, int length) {
            // after shutdown/Close throw an exception
            if (m_ShutDown > 0) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            SecureChannel chkSecureChannel = SecureChannel;
            if (chkSecureChannel==null) {
                return null;
            }
            int headerSize = chkSecureChannel.HeaderSize;
            byte[] header = new byte[headerSize];
            int read = length;

            if (buffer != null) {
                GlobalLog.Assert(length <= headerSize, "length > headerSize", "");
                Buffer.BlockCopy(buffer, 0, header, 0, Math.Min(length, headerSize));
            }
            if (length < headerSize) {
                GlobalLog.Print("RecordLayer::ReadFullRecord Reading "+headerSize+" byte header from the stream");
                read += ForceRead(header, length, headerSize - length);
            }
            GlobalLog.Dump(header);
            if (read != headerSize) {
                GlobalLog.Print("RecordLayer::ReadFullRecord returning null");
                return null;
            }

            // if we can't verify, just return what we can find

            if ( ! verifyRecordFormat(header) ) {
                return header;
            }

            // WARNING this line, I find worrisome, because it
            //  can differ on new protocols
            int payloadSize = (0x100*header[3]) + header[4];

            byte[] record = new byte[payloadSize+headerSize];
            Buffer.BlockCopy(header, 0, record, 0, headerSize);

            int received = ForceRead(record, headerSize, payloadSize);

            GlobalLog.Dump(record);

            if (received<payloadSize) {
                GlobalLog.Print("RecordLayer::ReadFullRecord returning null");
                return null;
            }

            return record;
        }

        // Examine the record header and make sure that the
        // TLS/SSL protocol version is 3.0 or higher
        // Generate false, if it cannot be handled by us

        private static bool verifyRecordFormat(byte[] header) {

            // The problem here is detecting SSL 2.0 packets.
            // Since the first byte in TLS versions is the
            // content type we depend on this

            int contentType = header[0];

            if (contentType != m_ChangeCipherSpec &&
                contentType != m_Alert            &&
                contentType != m_HandShake        &&
                contentType != m_AppData)
            {
                return false;
            }

            return true;
        }

        //
        // ForceRead - read a specific block of bytes out of the socket stream
        //  used to maintain protocol block sizes
        //
        //  WARNING: can throw!
        //
        private int ForceRead(byte[] space, int offset, int amount) {

            int totalRead = 0;

            while (totalRead<amount) {
                int incoming = base.Read(space, offset+totalRead, amount-totalRead);
                if (incoming<=0) {
                    //
                    // obviously we didn't read enough data from the NetworkStream
                    // let's just return how much data we managed to read and let
                    // the caller figure out what he wants to do.
                    //
                    break;
                }
                totalRead += incoming;
            }

            GlobalLog.Print("RecordLayer::forceRead returning " + totalRead.ToString());

            return totalRead;
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void Debug() {
            Console.WriteLine("m_DestinationHost:" + m_DestinationHost);
            Console.WriteLine("m_SecureChannel:" + m_SecureChannel);
            Console.WriteLine("m_ArrivingData:" + m_ArrivingData);
            Console.WriteLine("m_ExistingAmount:" + m_ExistingAmount);
            Console.WriteLine("m_ClientCertificates:" + m_ClientCertificates);
            Console.WriteLine("m_Exception:" + ((m_Exception == null) ? "(null)" : m_Exception.ToString()));
            Console.WriteLine("m_NestCounter:" + m_NestCounter);

            if (m_StreamSocket != null) {
                m_StreamSocket.Debug();
            }
        }


    }; // class TlsStream


    //
    // ProtocolToken - used to process and handle the return codes
    //   from the SSPI wrapper
    //

    internal class ProtocolToken {

        public int Status;
        public byte[] Payload;

        public bool Failed {
            get {
                return ((Status != (int)SecurityStatus.OK) && (Status != (int)SecurityStatus.ContinueNeeded));
            }
        }

        public bool Done {
            get {
                return (Status == (int)SecurityStatus.OK);
            }
        }

        public bool Renegotiate {
            get {
                return (Status == (int)SecurityStatus.Renegotiate);
            }
        }

        public bool CloseConnection {
            get {
                return (Status == (int)SecurityStatus.ContextExpired);
            }
        }


        public ProtocolToken(byte[] data, int errorCode) {
            Status = errorCode;
            Payload = data;
        }

        public Win32Exception GetException() {

            // if it's not done, then there's got to be
            //  an error, even if it's a Handshake message up,
            //  and we only have a Warning message.

            if ( this.Done ) {
                return null; // means success
            }

            return new Win32Exception ( Status ) ;
        }


    }; // class ProtocolToken


} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_securechannel.cs ===
//------------------------------------------------------------------------------
// <copyright file="_SecureChannel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    using System.Diagnostics;
    using System.Net.Sockets;
    using System.Runtime.InteropServices;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Threading;
    using System.Security.Permissions;
    using System.Globalization;

    //
    // SecureChannel - a wrapper on SSPI based functionality,
    //  provides an additional abstraction layer over SSPI
    //  for the TLS Stream to utilize.
    //

    internal class SecureChannel {

        private CredentialsHandle   m_CredentialsHandle;
        private SecurityContext     m_SecurityContext;
        private int                 m_Attributes;
        private string              m_Destination;
        private string                m_HostName;

        private CertificateContextHandle m_ServerContext;
        private X509Certificate     m_ServerCertificate;
        private X509Certificate     m_SelectedClientCertificate;

        private X509CertificateCollection m_ClientCertificates;

        private int                 m_HeaderSize = 5;
        private int                 m_TrailerSize = 16;
        private int                 m_MaxDataSize = 16354;
        private int                 m_ChainRevocationCheck = 0x20000000;
        private uint                 m_IgnoreUnmatchedCN = 0x00001000;

        private const string        m_SecurityPackage = "Microsoft Unified Security Protocol Provider";

        private static IntPtr       s_MyCertStore;

        private static int          m_RequiredFlags =
            (int)ContextFlags.ReplayDetect |
            (int)ContextFlags.SequenceDetect |
            (int)ContextFlags.Confidentiality;


        //from: CERT_FIND_ISSUER_STR_A  (CERT_COMPARE_NAME_STR_A << CERT_COMPARE_SHIFT | CERT_INFO_ISSUER_FLAG)
        private const int           CertFindIssuer = (7 << 16 | 4);
        //from: CERT_FIND_SHA1_HASH (CERT_COMPARE_SHA1_HASH << CERT_COMPARE_SHIFT)
        private const int           CertFindHash = (1 << 16);

        //from: CERT_CHAIN_FIND_BY_ISSUER       1
        private const int           CertChainFindByIssuer = 1;

        //
        // static class initializer & constructors
        //

        static SecureChannel() {
            GlobalLog.Enter("static SecureChannel ctor");
            SecurityPackageInfoClass[] supportedSecurityPackages = SSPIWrapper.GetSupportedSecurityPackages(GlobalSSPI.SSPISecureChannel);
            if (supportedSecurityPackages != null) {
                for (int i = 0; i < supportedSecurityPackages.Length; i++) {
                    if (String.Compare(supportedSecurityPackages[i].Name, m_SecurityPackage, true, CultureInfo.InvariantCulture) == 0) {
                        GlobalLog.Print( "SecureChannel::initialize(): found SecurityPackage(" + m_SecurityPackage + ")");
                        GlobalLog.Leave("SecureChannel");
                        return;
                    }
                }
            }
            GlobalLog.Print( "SecureChannel::initialize(): initialization failed: SecurityPackage(" + m_SecurityPackage + ") NOT FOUND");
            GlobalLog.Leave("SecureChannel");
        }

        public SecureChannel(string hostname, X509CertificateCollection clientCertificates) {
            GlobalLog.Enter("SecureChannel", "hostname="+hostname+", #clientCertificates="+((clientCertificates == null) ? "0" : clientCertificates.Count.ToString()));

            m_SecurityContext = new SecurityContext(GlobalSSPI.SSPISecureChannel);
            m_ClientCertificates = clientCertificates;
            m_HostName = hostname;

            if (ComNetOS.IsWin9x && m_ClientCertificates.Count > 0) {
                m_Destination = hostname+"+"+m_ClientCertificates.GetHashCode();
            } else {
                m_Destination = hostname;
            }

            //
            // create a secure channel
            //

            GlobalLog.Print("SecureChannel.ctor(" + hostname + ") calling AcquireCredentials");

            AcquireCredentials(true);

            GlobalLog.Leave("SecureChannel");
        }

        public static void AppDomainUnloadEvent(object sender, EventArgs e) {
            GlobalLog.Enter("AppDomainUnloadEvent");
            if ( s_MyCertStore != IntPtr.Zero ) {
                lock(typeof(SecureChannel)) {
                    if ( s_MyCertStore != IntPtr.Zero ) {
                        UnsafeNclNativeMethods.NativePKI.CertCloseStore(s_MyCertStore, 0);
                        s_MyCertStore = IntPtr.Zero;
                    }
                }
            }
            GlobalLog.Leave("AppDomainUnloadEvent");
        }

        //
        // SecureChannel properties
        //   ServerCertificate - returned Server Certificate
        //   ClientCertificate - selected certificated used in Client Authentication, otherwise null
        //   HeaderSize - Header & trailer sizes used in the TLS stream
        //   TrailerSize -
        //

        public X509Certificate ServerCertificate {
            get {
                if (m_ServerCertificate == null) {
                    ExtractServerCertificate();
                }
                return m_ServerCertificate;
            }
        }

        public X509Certificate ClientCertificate {
            get {

                /***
                //
                // This is better, cause it comes right from SSPI/
                //  but we already know this information locally,
                //  which is faster.
                //

                IntPtr clientContext = ExtractCertificate(ContextAttribute.LocalCertificate);

                if (clientContext != IntPtr.Zero) {
                    return new X509Certificate(clientContext);
                }
                return null;
                ***/

                return m_SelectedClientCertificate;
            }
        }

        public int HeaderSize {
            get {
                return m_HeaderSize;
            }
        }

        public int TrailerSize {
            get {
                return m_TrailerSize;
            }
        }

        public int MaxDataSize {
            get {
                return m_MaxDataSize;
            }
        }

        /*++
            AcquireCredentials - Attempts to find Client Credential
            Information, that can be sent to the server.  In our case,
            this is only Client Certificates, that we have Credential Info.

            Here is how we work:
                case 1: No Certs
                    we always call AcquireCredentials with an empty pointer
                case 2: Before our Connection with the Server
                    if we have only one Certificate to send, we attach it
                    and call AcquireCredentials
                    otherwise we wait for our handshake with the server
                case 3: After our Connection with the Server (ie during handshake)
                    the server has requested that we send it a Certificate
                    we then Enumerate a list of Server Root certs, and
                    match against our list of Certificates, the first match is
                    sent to the server.
                case 4: An error getting Certificate information,
                    we fall back to the behavior of having no certs, case 1

            Input:
                beforeServerConnection - true, if we haven't made contact with the server

        --*/
        private void AcquireCredentials(bool beforeServerConnection) {
            GlobalLog.Enter("AcquireCredentials", "beforeServerConnection="+beforeServerConnection);

            //
            // Acquire possible Client Certificate information and set it on the handle
            //

            SChannelCred secureCredential;

            IntPtr certEnumerator = IntPtr.Zero;
            IntPtr certContext = IntPtr.Zero;
            CertChainFindByIssuer certFindByIssuer = null;

            do {

                certContext = IntPtr.Zero;

                GlobalLog.Print("AcquireCredentials: m_ClientCertificates.Count = " + m_ClientCertificates.Count);

                if (m_ClientCertificates.Count > 0) {

                    //
                    // Open the "MY" certificate store, which is where Internet Explorer
                    // stores its client certificates, we only need to do this
                    // once per app domain, and then Close this handle at AppDomain unload
                    //

                    if (s_MyCertStore == IntPtr.Zero) {
                        lock(typeof(SecureChannel)) {
                            if (s_MyCertStore == IntPtr.Zero) {
                                s_MyCertStore = UnsafeNclNativeMethods.NativePKI.CertOpenSystemStore(IntPtr.Zero, "MY");
                                AppDomain.CurrentDomain.DomainUnload += new EventHandler(AppDomainUnloadEvent);
                            }
                        }
                    }
                    if (!beforeServerConnection && (s_MyCertStore != IntPtr.Zero)) {
                        certContext = EnumerateServerIssuerCertificates(ref certEnumerator, ref certFindByIssuer);
                    }
                }

                secureCredential = GenerateCertificateStructure(certContext);

                GlobalLog.Print("calling AcquireCredentialsHandle w/ " + secureCredential.cCreds + " creds");

                m_CredentialsHandle = SSPIWrapper.AcquireCredentialsHandle(
                                                    GlobalSSPI.SSPISecureChannel,
                                                    m_SecurityPackage,
                                                    CredentialUse.Outgoing,
                                                    secureCredential
                                                    );

                //
                // the Certificate Context is always copied by Schannel.AcquireCredentialsHandle
                //  so in all cases we need to clean it up, EXCEPT, when we loop
                //  doing an enumerate, since then the enumeration code will cleanup
                //

                if ( m_CredentialsHandle != null ) {
                    CleanupCertificateContext(secureCredential, certEnumerator);
                    break; // STOP HERE !
                } else if ( beforeServerConnection || certContext == IntPtr.Zero ) {
                    CleanupCertificateContext(secureCredential, certEnumerator);
                    break; // STOP HERE !
                }

            } while (true ) ;
            GlobalLog.Leave("AcquireCredentials");
        }

        /*++
            GetClientCertificateContext - Searchs the Certificate Store
             for a matching Certificate from what our first Certificate is.
             That is we read our managed certifcate collection, and map
             the first object to an unmanaged pointer of a matching
             certificate in the store.

            Returns:
                unmanaged pointer to Certificate Context

        --*/
        /*  // ** This is faster in the single cert case, but no longer needed **
        private IntPtr GetClientCertificateContext()
        {
            GlobalLog.Assert(m_ClientCertificates.Count > 0,
                         "m_ClientCertificates.Count <= 0", "");

            GlobalLog.Assert(s_MyCertStore != IntPtr.Zero,
                         "s_MyCertStore == IntPtr.Zero", "");

            IntPtr certContext = IntPtr.Zero;

            X509Certificate clientCertificate = (X509Certificate) m_ClientCertificates[0];

            // set selected cert
            m_SelectedClientCertificate = clientCertificate;

            byte [] clientCertificateHash = clientCertificate.GetCertHash();
            GCHandle gcHandle = GCHandle.Alloc(clientCertificateHash, GCHandleType.Pinned );

            CryptoBlob cryptoBlob = new CryptoBlob();
            cryptoBlob.dataSize = clientCertificateHash.Length;
            cryptoBlob.dataBlob = gcHandle.AddrOfPinnedObject();

            //
            // Find client certificate. Note that this just searchs for a
            // certificate that contains the same Certificate hash somewhere
            //

            certContext = UnsafeNclNativeMethods.NativePKI.CertFindCertificateInStore(
                                                      s_MyCertStore,
                                                      CertificateEncoding.X509AsnEncoding,
                                                      0,
                                                      SecureChannel.CertFindHash, // flags
                                                      ref cryptoBlob,
                                                      IntPtr.Zero);

            gcHandle.Free();

            return certContext;
        }
        **/

        /*++
            EnumerateServerIssuerCertificates -
              This is a more powerful version of GetClientCertificateContext().
              Now using server supplied root certificate authorities,
              we try to a local matching Chain of Client Certificates.
              We then match the end of the Chain against our own managed
              Certificates, and try to find something that can send.

              This function can be recalled until no more matching certificates
              are found in the store.

            Input:
                ref certEnumerator - certChain pointer, null first time called
                ref certFindByIssuer - built structure, that is cached from call to call

            Returns:
                unmanaged pointer to Certificate Context

        --*/
        private IntPtr EnumerateServerIssuerCertificates(
            ref IntPtr certEnumerator,
            ref CertChainFindByIssuer certFindByIssuer
            )
        {
            GlobalLog.Enter("EnumerateServerIssuerCertificates", "certEnumerator="+certEnumerator);
            GlobalLog.Assert(m_ClientCertificates.Count > 0,
                         "m_ClientCertificates.Count <= 0", "");

            GlobalLog.Assert(s_MyCertStore != IntPtr.Zero,
                         "s_MyCertStore == IntPtr.Zero", "");

            if (certEnumerator == IntPtr.Zero) {

                //
                // Read list of trusted issuers from schannel.
                //

                IssuerListInfoEx issuerList =
                    (IssuerListInfoEx)SSPIWrapper.QueryContextAttributes(
                        GlobalSSPI.SSPISecureChannel,
                        m_SecurityContext,
                        ContextAttribute.IssuerListInfoEx
                        );

                if (issuerList == null) {
                    GlobalLog.Print("issuerList == null");
                    GlobalLog.Leave("EnumerateServerIssuerCertificates", "IntPtr.Zero");
                    return IntPtr.Zero;
                }

                certEnumerator   = IntPtr.Zero;
                certFindByIssuer = new CertChainFindByIssuer(0);

                certFindByIssuer.issuerCount  = issuerList.issuerCount;
                certFindByIssuer.issuerArray  = issuerList.issuerArray;
            }

            //
            // Enumerate the client certificates.
            //

            while (true) {

                //
                // Find a certificate chain, that matches with our server certificates
                //

                GlobalLog.Print("calling UnsafeNclNativeMethods.NativePKI.CertFindChainInStore()");
                GlobalLog.Print("    hCertStore         = " + String.Format("0x{0:x}", s_MyCertStore));
                GlobalLog.Print("    dwCertEncodingType = " + CertificateEncoding.X509AsnEncoding);
                GlobalLog.Print("    dwFindFlags        = " + "0x0");
                GlobalLog.Print("    dwFindType         = " + String.Format("0x{0:x}", SecureChannel.CertChainFindByIssuer));
                GlobalLog.Print("    pvFindPara         = " + String.Format("0x{0:x}", certFindByIssuer));
                GlobalLog.Print("    pPrevChainContext  = " + String.Format("0x{0:x}", certEnumerator));

                IntPtr chainContext = UnsafeNclNativeMethods.NativePKI.CertFindChainInStore(
                                                     s_MyCertStore,
                                                     CertificateEncoding.X509AsnEncoding,
                                                     0,
                                                     SecureChannel.CertChainFindByIssuer, // flags
                                                     certFindByIssuer,
                                                     certEnumerator
                                                     );

                if (chainContext == IntPtr.Zero) {
                    GlobalLog.Print("no more chains in store");
                    break;
                }

                // on our next pass, use the context we found previously
                certEnumerator = chainContext;

                //
                // Get pointer to leaf certificate context.
                // do this in managed code:
                //  : pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;
                //

                IntPtr rgpChain = Marshal.ReadIntPtr(chainContext, 16);
                IntPtr rgpChain0 = Marshal.ReadIntPtr(rgpChain, 0);
                IntPtr rgpElement = Marshal.ReadIntPtr(rgpChain0, 16);
                IntPtr rgpElement0 = Marshal.ReadIntPtr(rgpElement, 0);
                IntPtr certContext = Marshal.ReadIntPtr(rgpElement0, 4);

                X509Certificate possibleCertificate = new X509Certificate(certContext);

                foreach (X509Certificate clientCertificate in m_ClientCertificates) {
                    if (possibleCertificate.GetCertHashString() == clientCertificate.GetCertHashString()) {
                        // set selected cert
                        m_SelectedClientCertificate = clientCertificate;
                        GlobalLog.Print("selected client certificate = " + clientCertificate);
                        GlobalLog.Leave("EnumerateServerIssuerCertificates", certContext.ToString());
                        return certContext;
                    }
                }

                // no match, try to find another Certificate that will match our list
            }

            GlobalLog.Leave("EnumerateServerIssuerCertificates", "IntPtr.Zero");
            return IntPtr.Zero;
        }

        /*++

            GenerateCertificateStructure -
               Generates a SChannelCred with the correctly filled in
               fields.  This will be marshalled to unmanaged call to
               AcquireCredentialHandle.

            Input:
                certContext - pointer to client cert that can be passed

        --*/
        private SChannelCred GenerateCertificateStructure(IntPtr certContext)
        {
            GlobalLog.Enter("GenerateCertificateStructure", "certContext="+certContext);

            SChannelCred secureCredential = new SChannelCred();

            // init our default values for the Certificate Credential

            secureCredential.version = (int)SChannelCred.CurrentVersion;
            secureCredential.dwFlags = (int)SChannelCred.Flags.ValidateManual | (int)SChannelCred.Flags.NoDefaultCred;

                                     //(PctClient |Ssl2Client|Ssl3Client|TlsClient |UniClient),
            const int ProtocolClientMask = 0x00000002|0x00000008|0x00000020|0x00000080|unchecked((int)0x80000000);
            secureCredential.grbitEnabledProtocols = (int)ServicePointManager.SecurityProtocol & ProtocolClientMask;

            secureCredential.cCreds = 0;
            secureCredential.certContextArray = IntPtr.Zero;

            if ( certContext != IntPtr.Zero ) {

#if TRAVE
                X509Certificate X509cert = new X509Certificate(certContext);
                GlobalLog.Print("Cert: "+ X509cert.ToString(true));
#endif

                secureCredential.cCreds = 1;
                secureCredential.certContextArray = certContext;
            }

            GlobalLog.Leave("GenerateCertificateStructure", secureCredential.ToString());
            return secureCredential;
        }

        /*++

            CleanupCertificateContext -
                Takes care of deleteing a Context Handle when we're done with it.

            Input:
                secureCredential - handle is deleted from here if needed

        --*/
        private void CleanupCertificateContext(SChannelCred secureCredential, IntPtr certChainEnumerator)
        {
            GlobalLog.Enter("CleanupCertificateContext");
            if ( secureCredential.certContextArray != IntPtr.Zero ) {
                if ( certChainEnumerator == IntPtr.Zero ) {
                    GlobalLog.PrintHex("freeing cert context ", secureCredential.certContextArray);
                    UnsafeNclNativeMethods.NativePKI.CertFreeCertificateContext(secureCredential.certContextArray);
                } else {
                    GlobalLog.PrintHex("freeing cert chain ", certChainEnumerator);
                    UnsafeNclNativeMethods.NativePKI.CertFreeCertificateChain(certChainEnumerator);
                }
                secureCredential.certContextArray = IntPtr.Zero;
            }
            GlobalLog.Leave("CleanupCertificateContext");
        }

        public ProtocolToken NextMessage(byte[] incoming) {
            GlobalLog.Enter("NextMessage");

            byte[] nextmsg = null;
            int errorCode = GenerateToken(incoming, ref nextmsg);

            if (errorCode == (int)SecurityStatus.CredentialsNeeded) {
                AcquireCredentials(false);
                errorCode = GenerateToken(incoming, ref nextmsg);
            }
#if TRAVE
            GlobalLog.Print("NextMessage: errorCode = " + MapSecurityStatus((uint)errorCode));
#endif
            ProtocolToken token = new ProtocolToken(nextmsg, errorCode);

            GlobalLog.Leave("NextMessage", token.ToString());

            return token;
        }

        /*++
            GenerateToken - Called after each sucessive state
            in the Client - Server handshake.  This function
            generates a set of bytes that will be sent next to
            the server.  The server responds, each response,
            is pass then into this function, again, and the cycle
            repeats until successful connection, or failure.

            Input:
                input  - bytes from the wire
                output - ref to byte [], what we will send to the
                    server in response
            Return:
                errorCode - an SSPI error code

        --*/
        protected int GenerateToken(byte[] input, ref byte[] output) {
            GlobalLog.Enter("GenerateToken");

            SecurityContext prevContext = m_SecurityContext;

            SecurityBufferClass incomingSecurity = null;

            if (m_SecurityContext.Handle != -1) {
                incomingSecurity = new SecurityBufferClass(input, BufferType.Token);
            }

            SecurityBufferClass outgoingSecurity = new SecurityBufferClass(null, BufferType.Token);

            int initSecurityFlags = m_RequiredFlags;

            initSecurityFlags |= (int)ContextFlags.AllocateMemory;

            GlobalLog.Print("SecureChannel::GenerateToken(" + m_Destination + "," + initSecurityFlags.ToString() + ")");

            int errorCode = SSPIWrapper.InitializeSecurityContext(
                                            GlobalSSPI.SSPISecureChannel,
                                            m_CredentialsHandle.Handle,
                                            prevContext.Handle,
                                            m_Destination,
                                            initSecurityFlags,
                                            Endianness.Native,
                                            incomingSecurity,
                                            ref m_SecurityContext.Handle,
                                            outgoingSecurity,
                                            ref m_Attributes,
                                            ref m_SecurityContext.TimeStamp
                                            );

            output = outgoingSecurity.token;

#if TRAVE
            GlobalLog.Print("SecureChannel::GenerateToken returning " + MapSecurityStatus((uint)errorCode));
#endif
            GlobalLog.Leave("GenerateToken");
            return errorCode;
        }

        /*++

            ProcessHandshakeSuccess -
               Called on successful completion of Handshake -
               used to set header/trailer sizes for encryption use

        --*/
        public void ProcessHandshakeSuccess() {
            GlobalLog.Enter("ProcessHandshakeSuccess");

            StreamSizes streamSizes =
                (StreamSizes)
                SSPIWrapper.QueryContextAttributes(
                          GlobalSSPI.SSPISecureChannel,
                          m_SecurityContext,
                          ContextAttribute.StreamSizes
                          );

            if (streamSizes != null) {
                m_HeaderSize = streamSizes.header;
                m_TrailerSize = streamSizes.trailer;
                m_MaxDataSize = streamSizes.maximumMessage - (streamSizes.header+streamSizes.trailer);
            }
            GlobalLog.Leave("ProcessHandshakeSuccess");
        }

        /*++
            Encrypt - Encrypts our bytes before we send them over the wire

            PERF: make more efficient, this does an extra copy when the offset
            is non-zero.

            Input:
                buffer - bytes for sending
                offset -
                size   -
                output - Encrypted bytes

        --*/

        public int Encrypt(byte[] buffer, int offset, int size, ref byte[] output) {
            GlobalLog.Enter("Encrypt");
            GlobalLog.Print("SecureChannel.Encrypt() - offset:" + offset.ToString() + "size-" + size.ToString() +"buffersize:" + buffer.Length.ToString() );
            GlobalLog.Print("SecureChannel.SealMessage[" + Encoding.ASCII.GetString(buffer, 0, Math.Min(buffer.Length,512)) + "]");

            byte[] header = new byte[m_HeaderSize];
            byte[] trailer = new byte[m_TrailerSize];

            // in VNext, we should try to avoid this second copy here, but for now
            // its the simpliest way of avoiding SealMessage from outputing into our buffer.
            byte[] writeBuffer = new byte[buffer.Length];
            buffer.CopyTo(writeBuffer, 0);

            // encryption using SCHANNEL requires three buffers: header, payload, trailer

            SecurityBufferClass[] securityBuffer = new SecurityBufferClass[3];

            securityBuffer[0] = new SecurityBufferClass(header, BufferType.Token);
            securityBuffer[1] = new SecurityBufferClass(writeBuffer, offset, size, BufferType.Data);
            securityBuffer[2] = new SecurityBufferClass(trailer, BufferType.Token);

            int errorCode = SSPIWrapper.SealMessage(GlobalSSPI.SSPISecureChannel, ref m_SecurityContext.Handle, 0, securityBuffer, 0);

            if (errorCode != 0) {
                GlobalLog.Print("SealMessage Return Error = " + errorCode.ToString());
                GlobalLog.Leave("Encrypt");
                return errorCode;
            }
            else {

                // merge all arrays in a single new one and return it

                int firstTwoLength = securityBuffer[0].size + securityBuffer[1].size;
                int resultLength = firstTwoLength + securityBuffer[2].size;
                byte[] result = new byte[resultLength];

                //
                //  *join(join(securityBuffer[0].token, securityBuffer[1].token), securityBuffer[2].token)*
                //  Combine the header/data/trailer together into one buffer
                //

                Buffer.BlockCopy(securityBuffer[0].token, 0, result, 0, securityBuffer[0].size);
                Buffer.BlockCopy(securityBuffer[1].token, 0, result, securityBuffer[0].size, securityBuffer[1].size);
                Buffer.BlockCopy(securityBuffer[2].token, 0, result, firstTwoLength, securityBuffer[2].size);

                output = result;

                GlobalLog.Leave("Encrypt");
                return errorCode;

            }
        }

        /*++
            Decrypt - Decrypts the encrypted bytes from wire,
                may return an error that needs to be processed

            Input:
                payload - bytes from the wire to decrypt
                output - ref to byte [] that are decrypted to clear text

        --*/
        public int  Decrypt(byte[] payload, ref byte[] output ) {
            GlobalLog.Enter("Decrypt");

            byte[] header = new byte[m_HeaderSize];
            byte[] trailer = new byte[m_TrailerSize];

            // decryption using SCHANNEL requires four buffers

            SecurityBufferClass[] decspc = new SecurityBufferClass[4];

            decspc[0] = new SecurityBufferClass(payload, BufferType.Data);
            decspc[1] = new SecurityBufferClass(null, BufferType.Empty);
            decspc[2] = new SecurityBufferClass(null, BufferType.Empty);
            decspc[3] = new SecurityBufferClass(null, BufferType.Empty);

            int errorCode = SSPIWrapper.UnsealMessage(GlobalSSPI.SSPISecureChannel, ref m_SecurityContext.Handle, 0, decspc, 0);

            //
            // Return Data should still be valid on error,
            //  although we'll most likely won't need to process it
            //

            int msglen = decspc[1].size;
            byte[] result = null;

            if  (msglen > 0) {
                result = new byte[msglen];
                Buffer.BlockCopy(payload, m_HeaderSize, result, 0, msglen);

                GlobalLog.Print("Decrypt.UnsealMessage()" + result.Length.ToString());
                GlobalLog.Print("Decrypt.UnsealMessage[" + Encoding.ASCII.GetString(result, 0, result.Length) + "]");
            }

            output = result;

            GlobalLog.Leave("Decrypt");
            return errorCode;
        }

        /*++

            VerifyServerCertificate - Validates the fields of a Server Certificate
            and insures, whether the Certificate's fields make sense,
            before we accept the validity of the connection.

            checkCRL checks the certificate revocation list for validity.

        --*/
        internal bool VerifyServerCertificate(ICertificateDecider decider) {
            GlobalLog.Enter("VerifyServerCertificate");
            if (m_ServerContext == null) {
                ExtractServerCertificate();
                if (m_ServerContext == null) {
                    GlobalLog.Leave("VerifyServerCertificate");
                    return false;
                }
            }

            IntPtr chainContext = BuildCertificateChain(m_ServerContext.Handle);

            GlobalLog.PrintHex("chainContext = ", chainContext);
            if (chainContext == IntPtr.Zero) {
                //
                // Could not build chain?
                // Verification fails automatically
                //
                GlobalLog.Leave("VerifyServerCertificate");
                return false;
            }

            bool accepted = true;
            uint status = 0;
            ChainPolicyParameter cpp = new ChainPolicyParameter();
            ExtraPolicyParameter epp = new ExtraPolicyParameter();
            GCHandle epphandle = new GCHandle();

            cpp.cbSize = 12;
            cpp.dwFlags = 0;
            bool checkCertName = ServicePointManager.CheckCertificateName;

            if (checkCertName){
                epp.cbSize = 16;
                epp.pwszServerName = Marshal.StringToHGlobalUni(m_HostName);
                epphandle = GCHandle.Alloc(epp,GCHandleType.Pinned);
                cpp.pvExtraPolicyPara = epphandle.AddrOfPinnedObject();
            }

            while (accepted) {
                status = VerifyChainPolicy(chainContext, cpp);

                uint ignoreErrorMask = (uint)MapErrorCode(status);

                accepted = decider.Accept(m_ServerCertificate, (int) status);

                if (status == 0) {  // No more problems with the certificate?
                    break;          // Then break out of the callback loop
                }

                if (ignoreErrorMask == 0) {
                    accepted = false;
                    break;                       // Unrecognized error encountered
                }
                else {
                    cpp.dwFlags |= ignoreErrorMask;
                    if ((CertificateProblem)status == CertificateProblem.CertCN_NO_MATCH && checkCertName) {
                        epp.fdwChecks = m_IgnoreUnmatchedCN;
                        Marshal.StructureToPtr(epp, cpp.pvExtraPolicyPara, true);
                    }
                }
            }

            if (epp.pwszServerName != IntPtr.Zero)
                Marshal.FreeHGlobal(epp.pwszServerName);
            if (epphandle.IsAllocated)
                epphandle.Free();

            GlobalLog.PrintHex("freeing chainContext ", chainContext);
            UnsafeNclNativeMethods.NativePKI.CertFreeCertificateChain(chainContext);
            GlobalLog.Leave("VerifyServerCertificate");
            return accepted;
        }

        /*++

            BuildCertificateChain - Builds up a chain of certificate
            for use in Certificate Validation.

        --*/
        private IntPtr BuildCertificateChain(IntPtr serverContext) {
            GlobalLog.Enter("BuildCertificateChain");

            IntPtr chainContext = IntPtr.Zero;

            CertEnhKeyUse enhancedUse = new CertEnhKeyUse();
            enhancedUse.cUsageIdentifier = 0;
            enhancedUse.rgpszUsageIdentifier = 0;

            CertUsageMatch match = new CertUsageMatch();

            match.Usage = enhancedUse;
            match.dwType = (uint) CertUsage.MatchTypeAnd;

            ChainParameters CP = new ChainParameters();

            CP.cbSize = 16;
            CP.requestedUsage = match;

            int dwFlags = 0;

            if (ServicePointManager.CheckCertificateRevocationList)
                dwFlags |= m_ChainRevocationCheck;  //check if chain was revoked

            Debug.Assert(m_ServerContext != null,
                         "m_ServerContext == null",
                         "m_ServerContext expected to have non-zero value"
                         );

            CertificateContext cc = new CertificateContext(m_ServerContext.Handle);
            IntPtr hCertStore = cc.CertStore;

            cc.DebugDump();
            GlobalLog.Print("calling UnsafeNclNativeMethods.NativePKI.CertGetCertificateChain()");
            GlobalLog.Print("    hChainEngine     = 0x0");
            GlobalLog.Print("    pCertContext     = " + String.Format("0x{0:x}", serverContext));
            GlobalLog.Print("    pTime            = 0x0");
            GlobalLog.Print("    hAdditionalStore = " + String.Format("0x{0:x}", hCertStore));
            GlobalLog.Print("    pChainPara       = " + CP);
            GlobalLog.Print("    dwFlags          = " + String.Format("0x{0:x}", dwFlags));
            GlobalLog.Print("    pvReserved       = 0x0");
            GlobalLog.Print("    ppChainContext   = {ref}");

            int errorCode = UnsafeNclNativeMethods.NativePKI.CertGetCertificateChain(
                                                                IntPtr.Zero,
                                                                serverContext,
                                                                IntPtr.Zero,
                                                                hCertStore,
                                                                ref CP, // chain parameters
                                                                dwFlags,
                                                                IntPtr.Zero,
                                                                ref chainContext
                                                                );
#if TRAVE
            GlobalLog.Print("CertGetCertificateChain() returns " + MapSecurityStatus((uint)errorCode));
#endif
            GlobalLog.Leave("BuildCertificateChain", String.Format("0x{0:x}", chainContext));
            return chainContext;
        }

        private uint VerifyChainPolicy(IntPtr chainContext, ChainPolicyParameter cpp) {
            GlobalLog.Enter("VerifyChainPolicy", "chainContext="+String.Format("0x{0:x}", chainContext)+", options="+String.Format("0x{0:x}", cpp.dwFlags));

            ChainPolicyStatus status = new ChainPolicyStatus();
             int errorCode = UnsafeNclNativeMethods.NativePKI.CertVerifyCertificateChainPolicy(
                                                                ChainPolicyType.SSL,
                                                                chainContext,
                                                                ref cpp,
                                                                ref status
                                                                );

            GlobalLog.Print("CertVerifyCertificateChainPolicy returned: " + errorCode);
#if TRAVE
            GlobalLog.Print("error code: " + status.dwError+String.Format(" [0x{0:x8}", status.dwError)+" "+MapSecurityStatus(status.dwError)+"]");
#endif
            GlobalLog.Leave("VerifyChainPolicy", status.dwError.ToString());
            return status.dwError;
        }

        private static IgnoreCertProblem MapErrorCode(uint errorCode) {
            switch ((CertificateProblem) errorCode) {

                case CertificateProblem.CertINVALIDNAME :
                case CertificateProblem.CertCN_NO_MATCH :
                    return IgnoreCertProblem.invalid_name;

                case CertificateProblem.CertINVALIDPOLICY :
                case CertificateProblem.CertPURPOSE :
                    return IgnoreCertProblem.invalid_policy;

                case CertificateProblem.CertEXPIRED :
                    return IgnoreCertProblem.not_time_valid | IgnoreCertProblem.ctl_not_time_valid;

                case CertificateProblem.CertVALIDITYPERIODNESTING :
                    return IgnoreCertProblem.not_time_nested;

                case CertificateProblem.CertCHAINING :
                case CertificateProblem.CertUNTRUSTEDCA :
                case CertificateProblem.CertUNTRUSTEDROOT :
                    return IgnoreCertProblem.allow_unknown_ca;

                case CertificateProblem.CertREVOKED :
                case CertificateProblem.CertREVOCATION_FAILURE :
                case CertificateProblem.CryptNOREVOCATIONCHECK:
                case CertificateProblem.CryptREVOCATIONOFFLINE:
                    return IgnoreCertProblem.all_rev_unknown;

                case CertificateProblem.CertROLE:
                case CertificateProblem.TrustBASICCONSTRAINTS:
                    return IgnoreCertProblem.invalid_basic_constraints;

                case CertificateProblem.CertWRONG_USAGE :
                    return IgnoreCertProblem.wrong_usage;

                default:
                    return 0;
            }
        }

        private CertificateContextHandle ExtractCertificate(ContextAttribute contextAttribute) {
            GlobalLog.Enter("ExtractCertificate", "contextAttribute="+contextAttribute);

            object result = SSPIWrapper.QueryContextAttributes(
                                                    GlobalSSPI.SSPISecureChannel,
                                                    m_SecurityContext,
                                                    contextAttribute
                                                    );

            //
            // note, if we don't do this check and instead try to simply cast
            // the QueryContextAttribtes() result to an IntPtr, we may get an
            // unexpected exception. Hence, this test
            //

            if (result == null) {
                GlobalLog.Leave("ExtractCertificate", "null");
                return null;
            }
            GlobalLog.Leave("ExtractCertificate", String.Format("0x{0:x}", ((CertificateContextHandle)result).Handle));
            return (CertificateContextHandle)result;
        }

        /*
         *  This is to support SSL server certificate  processing under semitrusted env
         *  Note it has no effect on permissions required for client certificate processing.
         */
        [SecurityPermissionAttribute( SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]

        private void ExtractServerCertificate() {
            GlobalLog.Enter("ExtractServerCertificate");

            //GlobalLog.PrintHex("before ExtractCertificate() m_ServerContext = ", m_ServerContext.Handle);
            m_ServerContext = ExtractCertificate(ContextAttribute.RemoteCertificate);
            //GlobalLog.PrintHex("after ExtractCertificate() m_ServerContext = ", m_ServerContext.Handle);

            if (m_ServerContext != null) {
                m_ServerCertificate = new X509Certificate(m_ServerContext.Handle);
                GlobalLog.Print("certificate = " + m_ServerCertificate);
            }
            GlobalLog.Leave("ExtractServerCertificate");
        }


        /*
            From wincrypt.h

        typedef void *HCERTSTORE;

        //+-------------------------------------------------------------------------
        //  Certificate context.
        //
        //  A certificate context contains both the encoded and decoded representation
        //  of a certificate. A certificate context returned by a cert store function
        //  must be freed by calling the CertFreeCertificateContext function. The
        //  CertDuplicateCertificateContext function can be called to make a duplicate
        //  copy (which also must be freed by calling CertFreeCertificateContext).
        //--------------------------------------------------------------------------
        typedef struct _CERT_CONTEXT {
            DWORD                   dwCertEncodingType;
            BYTE                    *pbCertEncoded;
            DWORD                   cbCertEncoded;
            PCERT_INFO              pCertInfo;
            HCERTSTORE              hCertStore;
        } CERT_CONTEXT, *PCERT_CONTEXT;
        typedef const CERT_CONTEXT *PCCERT_CONTEXT;

        */

        internal class CertificateContext {

        // fields

            private uint m_dwCertEncodingType;
            private IntPtr m_pbCertEncoded;
            private uint m_cbCertEncoded;
            private IntPtr m_pCertInfo;
            private IntPtr m_hCertStore;

        // ctors

            internal CertificateContext(IntPtr context) {
                GlobalLog.Enter("CertificateContext::CertificateContext", String.Format("0x{0:x}", context));
                CopyUnmanagedObject(context);
                GlobalLog.Leave("CertificateContext::CertificateContext");
            }

        // properties

            internal IntPtr CertStore {
                get {
                    return m_hCertStore;
                }
            }

        // methods

            private void CopyUnmanagedObject(IntPtr unmanagedAddress) {

                int offset = 0;

                m_dwCertEncodingType = (uint)Marshal.ReadInt32(unmanagedAddress, offset);
                offset += Marshal.SizeOf(typeof(UInt32));
                m_pbCertEncoded = Marshal.ReadIntPtr(unmanagedAddress, offset);
                offset += Marshal.SizeOf(typeof(IntPtr));
                m_cbCertEncoded = (uint)Marshal.ReadInt32(unmanagedAddress, offset);
                offset += Marshal.SizeOf(typeof(UInt32));
                m_pCertInfo = Marshal.ReadIntPtr(unmanagedAddress, offset);
                offset += Marshal.SizeOf(typeof(IntPtr));
                m_hCertStore = Marshal.ReadIntPtr(unmanagedAddress, offset);
            }

            [Conditional("TRAVE")]
            internal void DebugDump() {
                GlobalLog.Print("CertificateContext #"+GetHashCode());
                GlobalLog.PrintHex("    dwCertEncodingType = ", m_dwCertEncodingType);
                GlobalLog.PrintHex("    pbCertEncoded      = ", m_pbCertEncoded);
                GlobalLog.PrintHex("    cbCertEncoded      = ", m_cbCertEncoded);
                GlobalLog.PrintHex("    pCertInfo          = ", m_pCertInfo);
                GlobalLog.PrintHex("    hCertStore         = ", m_hCertStore);
            }
        }

#if TRAVE
        internal static string MapSecurityStatus(uint statusCode) {
            switch (statusCode) {
            case 0: return "0";
            case 0x80090001: return "NTE_BAD_UID";
            case 0x80090002: return "NTE_BAD_HASH";
            case 0x80090003: return "NTE_BAD_KEY";
            case 0x80090004: return "NTE_BAD_LEN";
            case 0x80090005: return "NTE_BAD_DATA";
            case 0x80090006: return "NTE_BAD_SIGNATURE";
            case 0x80090007: return "NTE_BAD_VER";
            case 0x80090008: return "NTE_BAD_ALGID";
            case 0x80090009: return "NTE_BAD_FLAGS";
            case 0x8009000A: return "NTE_BAD_TYPE";
            case 0x8009000B: return "NTE_BAD_KEY_STATE";
            case 0x8009000C: return "NTE_BAD_HASH_STATE";
            case 0x8009000D: return "NTE_NO_KEY";
            case 0x8009000E: return "NTE_NO_MEMORY";
            case 0x8009000F: return "NTE_EXISTS";
            case 0x80090010: return "NTE_PERM";
            case 0x80090011: return "NTE_NOT_FOUND";
            case 0x80090012: return "NTE_DOUBLE_ENCRYPT";
            case 0x80090013: return "NTE_BAD_PROVIDER";
            case 0x80090014: return "NTE_BAD_PROV_TYPE";
            case 0x80090015: return "NTE_BAD_PUBLIC_KEY";
            case 0x80090016: return "NTE_BAD_KEYSET";
            case 0x80090017: return "NTE_PROV_TYPE_NOT_DEF";
            case 0x80090018: return "NTE_PROV_TYPE_ENTRY_BAD";
            case 0x80090019: return "NTE_KEYSET_NOT_DEF";
            case 0x8009001A: return "NTE_KEYSET_ENTRY_BAD";
            case 0x8009001B: return "NTE_PROV_TYPE_NO_MATCH";
            case 0x8009001C: return "NTE_SIGNATURE_FILE_BAD";
            case 0x8009001D: return "NTE_PROVIDER_DLL_FAIL";
            case 0x8009001E: return "NTE_PROV_DLL_NOT_FOUND";
            case 0x8009001F: return "NTE_BAD_KEYSET_PARAM";
            case 0x80090020: return "NTE_FAIL";
            case 0x80090021: return "NTE_SYS_ERR";
            case 0x80090022: return "NTE_SILENT_CONTEXT";
            case 0x80090023: return "NTE_TOKEN_KEYSET_STORAGE_FULL";
            case 0x80090024: return "NTE_TEMPORARY_PROFILE";
            case 0x80090025: return "NTE_FIXEDPARAMETER";
            case 0x80090300: return "SEC_E_INSUFFICIENT_MEMORY";
            case 0x80090301: return "SEC_E_INVALID_HANDLE";
            case 0x80090302: return "SEC_E_UNSUPPORTED_FUNCTION";
            case 0x80090303: return "SEC_E_TARGET_UNKNOWN";
            case 0x80090304: return "SEC_E_INTERNAL_ERROR";
            case 0x80090305: return "SEC_E_SECPKG_NOT_FOUND";
            case 0x80090306: return "SEC_E_NOT_OWNER";
            case 0x80090307: return "SEC_E_CANNOT_INSTALL";
            case 0x80090308: return "SEC_E_INVALID_TOKEN";
            case 0x80090309: return "SEC_E_CANNOT_PACK";
            case 0x8009030A: return "SEC_E_QOP_NOT_SUPPORTED";
            case 0x8009030B: return "SEC_E_NO_IMPERSONATION";
            case 0x8009030C: return "SEC_E_LOGON_DENIED";
            case 0x8009030D: return "SEC_E_UNKNOWN_CREDENTIALS";
            case 0x8009030E: return "SEC_E_NO_CREDENTIALS";
            case 0x8009030F: return "SEC_E_MESSAGE_ALTERED";
            case 0x80090310: return "SEC_E_OUT_OF_SEQUENCE";
            case 0x80090311: return "SEC_E_NO_AUTHENTICATING_AUTHORITY";
            case 0x00090312: return "SEC_I_CONTINUE_NEEDED";
            case 0x00090313: return "SEC_I_COMPLETE_NEEDED";
            case 0x00090314: return "SEC_I_COMPLETE_AND_CONTINUE";
            case 0x00090315: return "SEC_I_LOCAL_LOGON";
            case 0x80090316: return "SEC_E_BAD_PKGID";
            case 0x80090317: return "SEC_E_CONTEXT_EXPIRED";
            case 0x80090318: return "SEC_E_INCOMPLETE_MESSAGE";
            case 0x80090320: return "SEC_E_INCOMPLETE_CREDENTIALS";
            case 0x80090321: return "SEC_E_BUFFER_TOO_SMALL";
            case 0x00090320: return "SEC_I_INCOMPLETE_CREDENTIALS";
            case 0x00090321: return "SEC_I_RENEGOTIATE";
            case 0x80090322: return "SEC_E_WRONG_PRINCIPAL";
            case 0x00090323: return "SEC_I_NO_LSA_CONTEXT";
            case 0x80090324: return "SEC_E_TIME_SKEW";
            case 0x80090325: return "SEC_E_UNTRUSTED_ROOT";
            case 0x80090326: return "SEC_E_ILLEGAL_MESSAGE";
            case 0x80090327: return "SEC_E_CERT_UNKNOWN";
            case 0x80090328: return "SEC_E_CERT_EXPIRED";
            case 0x80090329: return "SEC_E_ENCRYPT_FAILURE";
            case 0x80090330: return "SEC_E_DECRYPT_FAILURE";
            case 0x80090331: return "SEC_E_ALGORITHM_MISMATCH";
            case 0x80090332: return "SEC_E_SECURITY_QOS_FAILED";
            case 0x80090333: return "SEC_E_UNFINISHED_CONTEXT_DELETED";
            case 0x80090334: return "SEC_E_NO_TGT_REPLY";
            case 0x80090335: return "SEC_E_NO_IP_ADDRESSES";
            case 0x80090336: return "SEC_E_WRONG_CREDENTIAL_HANDLE";
            case 0x80090337: return "SEC_E_CRYPTO_SYSTEM_INVALID";
            case 0x80090338: return "SEC_E_MAX_REFERRALS_EXCEEDED";
            case 0x80090339: return "SEC_E_MUST_BE_KDC";
            case 0x8009033A: return "SEC_E_STRONG_CRYPTO_NOT_SUPPORTED";
            case 0x8009033B: return "SEC_E_TOO_MANY_PRINCIPALS";
            case 0x8009033C: return "SEC_E_NO_PA_DATA";
            case 0x8009033D: return "SEC_E_PKINIT_NAME_MISMATCH";
            case 0x8009033E: return "SEC_E_SMARTCARD_LOGON_REQUIRED";
            case 0x8009033F: return "SEC_E_SHUTDOWN_IN_PROGRESS";
            case 0x80090340: return "SEC_E_KDC_INVALID_REQUEST";
            case 0x80090341: return "SEC_E_KDC_UNABLE_TO_REFER";
            case 0x80090342: return "SEC_E_KDC_UNKNOWN_ETYPE";
            case 0x80090343: return "SEC_E_UNSUPPORTED_PREAUTH";
            case 0x00090344: return "SEC_I_CONTEXT_EXPIRED";
            case 0x80090345: return "SEC_E_DELEGATION_REQUIRED";
            case 0x80090346: return "SEC_E_BAD_BINDINGS";
            case 0x80090347: return "SEC_E_MULTIPLE_ACCOUNTS";
            case 0x80090348: return "SEC_E_NO_KERB_KEY";
            case 0x80091001: return "CRYPT_E_MSG_ERROR";
            case 0x80091002: return "CRYPT_E_UNKNOWN_ALGO";
            case 0x80091003: return "CRYPT_E_OID_FORMAT";
            case 0x80091004: return "CRYPT_E_INVALID_MSG_TYPE";
            case 0x80091005: return "CRYPT_E_UNEXPECTED_ENCODING";
            case 0x80091006: return "CRYPT_E_AUTH_ATTR_MISSING";
            case 0x80091007: return "CRYPT_E_HASH_VALUE";
            case 0x80091008: return "CRYPT_E_INVALID_INDEX";
            case 0x80091009: return "CRYPT_E_ALREADY_DECRYPTED";
            case 0x8009100A: return "CRYPT_E_NOT_DECRYPTED";
            case 0x8009100B: return "CRYPT_E_RECIPIENT_NOT_FOUND";
            case 0x8009100C: return "CRYPT_E_CONTROL_TYPE";
            case 0x8009100D: return "CRYPT_E_ISSUER_SERIALNUMBER";
            case 0x8009100E: return "CRYPT_E_SIGNER_NOT_FOUND";
            case 0x8009100F: return "CRYPT_E_ATTRIBUTES_MISSING";
            case 0x80091010: return "CRYPT_E_STREAM_MSG_NOT_READY";
            case 0x80091011: return "CRYPT_E_STREAM_INSUFFICIENT_DATA";
            case 0x00091012: return "CRYPT_I_NEW_PROTECTION_REQUIRED";
            case 0x80092001: return "CRYPT_E_BAD_LEN";
            case 0x80092002: return "CRYPT_E_BAD_ENCODE";
            case 0x80092003: return "CRYPT_E_FILE_ERROR";
            case 0x80092004: return "CRYPT_E_NOT_FOUND";
            case 0x80092005: return "CRYPT_E_EXISTS";
            case 0x80092006: return "CRYPT_E_NO_PROVIDER";
            case 0x80092007: return "CRYPT_E_SELF_SIGNED";
            case 0x80092008: return "CRYPT_E_DELETED_PREV";
            case 0x80092009: return "CRYPT_E_NO_MATCH";
            case 0x8009200A: return "CRYPT_E_UNEXPECTED_MSG_TYPE";
            case 0x8009200B: return "CRYPT_E_NO_KEY_PROPERTY";
            case 0x8009200C: return "CRYPT_E_NO_DECRYPT_CERT";
            case 0x8009200D: return "CRYPT_E_BAD_MSG";
            case 0x8009200E: return "CRYPT_E_NO_SIGNER";
            case 0x8009200F: return "CRYPT_E_PENDING_CLOSE";
            case 0x80092010: return "CRYPT_E_REVOKED";
            case 0x80092011: return "CRYPT_E_NO_REVOCATION_DLL";
            case 0x80092012: return "CRYPT_E_NO_REVOCATION_CHECK";
            case 0x80092013: return "CRYPT_E_REVOCATION_OFFLINE";
            case 0x80092014: return "CRYPT_E_NOT_IN_REVOCATION_DATABASE";
            case 0x80092020: return "CRYPT_E_INVALID_NUMERIC_STRING";
            case 0x80092021: return "CRYPT_E_INVALID_PRINTABLE_STRING";
            case 0x80092022: return "CRYPT_E_INVALID_IA5_STRING";
            case 0x80092023: return "CRYPT_E_INVALID_X500_STRING";
            case 0x80092024: return "CRYPT_E_NOT_CHAR_STRING";
            case 0x80092025: return "CRYPT_E_FILERESIZED";
            case 0x80092026: return "CRYPT_E_SECURITY_SETTINGS";
            case 0x80092027: return "CRYPT_E_NO_VERIFY_USAGE_DLL";
            case 0x80092028: return "CRYPT_E_NO_VERIFY_USAGE_CHECK";
            case 0x80092029: return "CRYPT_E_VERIFY_USAGE_OFFLINE";
            case 0x8009202A: return "CRYPT_E_NOT_IN_CTL";
            case 0x8009202B: return "CRYPT_E_NO_TRUSTED_SIGNER";
            case 0x8009202C: return "CRYPT_E_MISSING_PUBKEY_PARA";
            case 0x80093000: return "CRYPT_E_OSS_ERROR";
            case 0x80093001: return "OSS_MORE_BUF";
            case 0x80093002: return "OSS_NEGATIVE_UINTEGER";
            case 0x80093003: return "OSS_PDU_RANGE";
            case 0x80093004: return "OSS_MORE_INPUT";
            case 0x80093005: return "OSS_DATA_ERROR";
            case 0x80093006: return "OSS_BAD_ARG";
            case 0x80093007: return "OSS_BAD_VERSION";
            case 0x80093008: return "OSS_OUT_MEMORY";
            case 0x80093009: return "OSS_PDU_MISMATCH";
            case 0x8009300A: return "OSS_LIMITED";
            case 0x8009300B: return "OSS_BAD_PTR";
            case 0x8009300C: return "OSS_BAD_TIME";
            case 0x8009300D: return "OSS_INDEFINITE_NOT_SUPPORTED";
            case 0x8009300E: return "OSS_MEM_ERROR";
            case 0x8009300F: return "OSS_BAD_TABLE";
            case 0x80093010: return "OSS_TOO_LONG";
            case 0x80093011: return "OSS_CONSTRAINT_VIOLATED";
            case 0x80093012: return "OSS_FATAL_ERROR";
            case 0x80093013: return "OSS_ACCESS_SERIALIZATION_ERROR";
            case 0x80093014: return "OSS_NULL_TBL";
            case 0x80093015: return "OSS_NULL_FCN";
            case 0x80093016: return "OSS_BAD_ENCRULES";
            case 0x80093017: return "OSS_UNAVAIL_ENCRULES";
            case 0x80093018: return "OSS_CANT_OPEN_TRACE_WINDOW";
            case 0x80093019: return "OSS_UNIMPLEMENTED";
            case 0x8009301A: return "OSS_OID_DLL_NOT_LINKED";
            case 0x8009301B: return "OSS_CANT_OPEN_TRACE_FILE";
            case 0x8009301C: return "OSS_TRACE_FILE_ALREADY_OPEN";
            case 0x8009301D: return "OSS_TABLE_MISMATCH";
            case 0x8009301E: return "OSS_TYPE_NOT_SUPPORTED";
            case 0x8009301F: return "OSS_REAL_DLL_NOT_LINKED";
            case 0x80093020: return "OSS_REAL_CODE_NOT_LINKED";
            case 0x80093021: return "OSS_OUT_OF_RANGE";
            case 0x80093022: return "OSS_COPIER_DLL_NOT_LINKED";
            case 0x80093023: return "OSS_CONSTRAINT_DLL_NOT_LINKED";
            case 0x80093024: return "OSS_COMPARATOR_DLL_NOT_LINKED";
            case 0x80093025: return "OSS_COMPARATOR_CODE_NOT_LINKED";
            case 0x80093026: return "OSS_MEM_MGR_DLL_NOT_LINKED";
            case 0x80093027: return "OSS_PDV_DLL_NOT_LINKED";
            case 0x80093028: return "OSS_PDV_CODE_NOT_LINKED";
            case 0x80093029: return "OSS_API_DLL_NOT_LINKED";
            case 0x8009302A: return "OSS_BERDER_DLL_NOT_LINKED";
            case 0x8009302B: return "OSS_PER_DLL_NOT_LINKED";
            case 0x8009302C: return "OSS_OPEN_TYPE_ERROR";
            case 0x8009302D: return "OSS_MUTEX_NOT_CREATED";
            case 0x8009302E: return "OSS_CANT_CLOSE_TRACE_FILE";
            case 0x80093100: return "CRYPT_E_ASN1_ERROR";
            case 0x80093101: return "CRYPT_E_ASN1_INTERNAL";
            case 0x80093102: return "CRYPT_E_ASN1_EOD";
            case 0x80093103: return "CRYPT_E_ASN1_CORRUPT";
            case 0x80093104: return "CRYPT_E_ASN1_LARGE";
            case 0x80093105: return "CRYPT_E_ASN1_CONSTRAINT";
            case 0x80093106: return "CRYPT_E_ASN1_MEMORY";
            case 0x80093107: return "CRYPT_E_ASN1_OVERFLOW";
            case 0x80093108: return "CRYPT_E_ASN1_BADPDU";
            case 0x80093109: return "CRYPT_E_ASN1_BADARGS";
            case 0x8009310A: return "CRYPT_E_ASN1_BADREAL";
            case 0x8009310B: return "CRYPT_E_ASN1_BADTAG";
            case 0x8009310C: return "CRYPT_E_ASN1_CHOICE";
            case 0x8009310D: return "CRYPT_E_ASN1_RULE";
            case 0x8009310E: return "CRYPT_E_ASN1_UTF8";
            case 0x80093133: return "CRYPT_E_ASN1_PDU_TYPE";
            case 0x80093134: return "CRYPT_E_ASN1_NYI";
            case 0x80093201: return "CRYPT_E_ASN1_EXTENDED";
            case 0x80093202: return "CRYPT_E_ASN1_NOEOD";
            case 0x80094001: return "CERTSRV_E_BAD_REQUESTSUBJECT";
            case 0x80094002: return "CERTSRV_E_NO_REQUEST";
            case 0x80094003: return "CERTSRV_E_BAD_REQUESTSTATUS";
            case 0x80094004: return "CERTSRV_E_PROPERTY_EMPTY";
            case 0x80094005: return "CERTSRV_E_INVALID_CA_CERTIFICATE";
            case 0x80094006: return "CERTSRV_E_SERVER_SUSPENDED";
            case 0x80094007: return "CERTSRV_E_ENCODING_LENGTH";
            case 0x80094008: return "CERTSRV_E_ROLECONFLICT";
            case 0x80094009: return "CERTSRV_E_RESTRICTEDOFFICER";
            case 0x8009400A: return "CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED";
            case 0x8009400B: return "CERTSRV_E_NO_VALID_KRA";
            case 0x8009400C: return "CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL";
            case 0x80094800: return "CERTSRV_E_UNSUPPORTED_CERT_TYPE";
            case 0x80094801: return "CERTSRV_E_NO_CERT_TYPE";
            case 0x80094802: return "CERTSRV_E_TEMPLATE_CONFLICT";
            case 0x80096001: return "TRUST_E_SYSTEM_ERROR";
            case 0x80096002: return "TRUST_E_NO_SIGNER_CERT";
            case 0x80096003: return "TRUST_E_COUNTER_SIGNER";
            case 0x80096004: return "TRUST_E_CERT_SIGNATURE";
            case 0x80096005: return "TRUST_E_TIME_STAMP";
            case 0x80096010: return "TRUST_E_BAD_DIGEST";
            case 0x80096019: return "TRUST_E_BASIC_CONSTRAINTS";
            case 0x8009601E: return "TRUST_E_FINANCIAL_CRITERIA";
            case 0x80097001: return "MSSIPOTF_E_OUTOFMEMRANGE";
            case 0x80097002: return "MSSIPOTF_E_CANTGETOBJECT";
            case 0x80097003: return "MSSIPOTF_E_NOHEADTABLE";
            case 0x80097004: return "MSSIPOTF_E_BAD_MAGICNUMBER";
            case 0x80097005: return "MSSIPOTF_E_BAD_OFFSET_TABLE";
            case 0x80097006: return "MSSIPOTF_E_TABLE_TAGORDER";
            case 0x80097007: return "MSSIPOTF_E_TABLE_LONGWORD";
            case 0x80097008: return "MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT";
            case 0x80097009: return "MSSIPOTF_E_TABLES_OVERLAP";
            case 0x8009700A: return "MSSIPOTF_E_TABLE_PADBYTES";
            case 0x8009700B: return "MSSIPOTF_E_FILETOOSMALL";
            case 0x8009700C: return "MSSIPOTF_E_TABLE_CHECKSUM";
            case 0x8009700D: return "MSSIPOTF_E_FILE_CHECKSUM";
            case 0x80097010: return "MSSIPOTF_E_FAILED_POLICY";
            case 0x80097011: return "MSSIPOTF_E_FAILED_HINTS_CHECK";
            case 0x80097012: return "MSSIPOTF_E_NOT_OPENTYPE";
            case 0x80097013: return "MSSIPOTF_E_FILE";
            case 0x80097014: return "MSSIPOTF_E_CRYPT";
            case 0x80097015: return "MSSIPOTF_E_BADVERSION";
            case 0x80097016: return "MSSIPOTF_E_DSIG_STRUCTURE";
            case 0x80097017: return "MSSIPOTF_E_PCONST_CHECK";
            case 0x80097018: return "MSSIPOTF_E_STRUCTURE";
            case 0x800B0001: return "TRUST_E_PROVIDER_UNKNOWN";
            case 0x800B0002: return "TRUST_E_ACTION_UNKNOWN";
            case 0x800B0003: return "TRUST_E_SUBJECT_FORM_UNKNOWN";
            case 0x800B0004: return "TRUST_E_SUBJECT_NOT_TRUSTED";
            case 0x800B0005: return "DIGSIG_E_ENCODE";
            case 0x800B0006: return "DIGSIG_E_DECODE";
            case 0x800B0007: return "DIGSIG_E_EXTENSIBILITY";
            case 0x800B0008: return "DIGSIG_E_CRYPTO";
            case 0x800B0009: return "PERSIST_E_SIZEDEFINITE";
            case 0x800B000A: return "PERSIST_E_SIZEINDEFINITE";
            case 0x800B000B: return "PERSIST_E_NOTSELFSIZING";
            case 0x800B0100: return "TRUST_E_NOSIGNATURE";
            case 0x800B0101: return "CERT_E_EXPIRED";
            case 0x800B0102: return "CERT_E_VALIDITYPERIODNESTING";
            case 0x800B0103: return "CERT_E_ROLE";
            case 0x800B0104: return "CERT_E_PATHLENCONST";
            case 0x800B0105: return "CERT_E_CRITICAL";
            case 0x800B0106: return "CERT_E_PURPOSE";
            case 0x800B0107: return "CERT_E_ISSUERCHAINING";
            case 0x800B0108: return "CERT_E_MALFORMED";
            case 0x800B0109: return "CERT_E_UNTRUSTEDROOT";
            case 0x800B010A: return "CERT_E_CHAINING";
            case 0x800B010B: return "TRUST_E_FAIL";
            case 0x800B010C: return "CERT_E_REVOKED";
            case 0x800B010D: return "CERT_E_UNTRUSTEDTESTROOT";
            case 0x800B010E: return "CERT_E_REVOCATION_FAILURE";
            case 0x800B010F: return "CERT_E_CN_NO_MATCH";
            case 0x800B0110: return "CERT_E_WRONG_USAGE";
            case 0x800B0111: return "TRUST_E_EXPLICIT_DISTRUST";
            case 0x800B0112: return "CERT_E_UNTRUSTEDCA";
            case 0x800B0113: return "CERT_E_INVALID_POLICY";
            case 0x800B0114: return "CERT_E_INVALID_NAME";
            }
            return String.Format("0x{0:x} [{1}]", statusCode, statusCode);
        }

        static readonly string[] InputContextAttributes = {
            "ISC_REQ_DELEGATE",                 // 0x00000001
            "ISC_REQ_MUTUAL_AUTH",              // 0x00000002
            "ISC_REQ_REPLAY_DETECT",            // 0x00000004
            "ISC_REQ_SEQUENCE_DETECT",          // 0x00000008
            "ISC_REQ_CONFIDENTIALITY",          // 0x00000010
            "ISC_REQ_USE_SESSION_KEY",          // 0x00000020
            "ISC_REQ_PROMPT_FOR_CREDS",         // 0x00000040
            "ISC_REQ_USE_SUPPLIED_CREDS",       // 0x00000080
            "ISC_REQ_ALLOCATE_MEMORY",          // 0x00000100
            "ISC_REQ_USE_DCE_STYLE",            // 0x00000200
            "ISC_REQ_DATAGRAM",                 // 0x00000400
            "ISC_REQ_CONNECTION",               // 0x00000800
            "ISC_REQ_CALL_LEVEL",               // 0x00001000
            "ISC_REQ_FRAGMENT_SUPPLIED",        // 0x00002000
            "ISC_REQ_EXTENDED_ERROR",           // 0x00004000
            "ISC_REQ_STREAM",                   // 0x00008000
            "ISC_REQ_INTEGRITY",                // 0x00010000
            "ISC_REQ_IDENTIFY",                 // 0x00020000
            "ISC_REQ_NULL_SESSION",             // 0x00040000
            "ISC_REQ_MANUAL_CRED_VALIDATION",   // 0x00080000
            "ISC_REQ_RESERVED1",                // 0x00100000
            "ISC_REQ_FRAGMENT_TO_FIT",          // 0x00200000
            "?",                                // 0x00400000
            "?",                                // 0x00800000
            "?",                                // 0x01000000
            "?",                                // 0x02000000
            "?",                                // 0x04000000
            "?",                                // 0x08000000
            "?",                                // 0x10000000
            "?",                                // 0x20000000
            "?",                                // 0x40000000
            "?"                                 // 0x80000000
        };

        static readonly string[] OutputContextAttributes = {
            "ISC_RET_DELEGATE",                 // 0x00000001
            "ISC_RET_MUTUAL_AUTH",              // 0x00000002
            "ISC_RET_REPLAY_DETECT",            // 0x00000004
            "ISC_RET_SEQUENCE_DETECT",          // 0x00000008
            "ISC_RET_CONFIDENTIALITY",          // 0x00000010
            "ISC_RET_USE_SESSION_KEY",          // 0x00000020
            "ISC_RET_USED_COLLECTED_CREDS",     // 0x00000040
            "ISC_RET_USED_SUPPLIED_CREDS",      // 0x00000080
            "ISC_RET_ALLOCATED_MEMORY",         // 0x00000100
            "ISC_RET_USED_DCE_STYLE",           // 0x00000200
            "ISC_RET_DATAGRAM",                 // 0x00000400
            "ISC_RET_CONNECTION",               // 0x00000800
            "ISC_RET_INTERMEDIATE_RETURN",      // 0x00001000
            "ISC_RET_CALL_LEVEL",               // 0x00002000
            "ISC_RET_EXTENDED_ERROR",           // 0x00004000
            "ISC_RET_STREAM",                   // 0x00008000
            "ISC_RET_INTEGRITY",                // 0x00010000
            "ISC_RET_IDENTIFY",                 // 0x00020000
            "ISC_RET_NULL_SESSION",             // 0x00040000
            "ISC_RET_MANUAL_CRED_VALIDATION",   // 0x00080000
            "ISC_RET_RESERVED1",                // 0x00100000
            "ISC_RET_FRAGMENT_ONLY",            // 0x00200000
            "?",                                // 0x00400000
            "?",                                // 0x00800000
            "?",                                // 0x01000000
            "?",                                // 0x02000000
            "?",                                // 0x04000000
            "?",                                // 0x08000000
            "?",                                // 0x10000000
            "?",                                // 0x20000000
            "?",                                // 0x40000000
            "?"                                 // 0x80000000
        };

        internal static string MapInputContextAttributes(int attributes) {
            return ContextAttributeMapper(attributes, InputContextAttributes);
        }

        internal static string MapOutputContextAttributes(int attributes) {
            return ContextAttributeMapper(attributes, OutputContextAttributes);
        }

        internal static string ContextAttributeMapper(int attributes, string[] attributeNames) {

            int bit = 1;
            int index = 0;
            string result = "";
            bool haveResult = false;

            while (attributes != 0) {
                if ((attributes & bit) != 0) {
                    if (haveResult) {
                        result += " ";
                    }
                    haveResult = true;
                    result += attributeNames[index];
                }
                attributes &= ~bit;
                bit <<= 1;
                ++index;
            }
            return result;
        }
#endif // TRAVE
    } // SecureChannel
} // namespace System.Net
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_ulsysapi.cs ===
//------------------------------------------------------------------------------
// <copyright file="_UlSysApi.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if COMNET_LISTENER

namespace System.Net {

    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Net.Sockets;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Security.Cryptography;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Threading;

    internal class UlSysApi {
        //
        // this static method will call InitializeSecurityDescriptor()
        // when the first object is created
        //
        internal static int UlCreateRootConfigGroup(string uriPrefix ) {
            //
            // ul stuff
            //
            const int UlEnabledStateActive = 0;
            const int UlEnabledStateInactive = 1;
            const int UlControlChannelStateInformation = 0;
            const int UlConfigGroupStateInformation = 0;
            const int UlConfigGroupSecurityInformation = 6;

            const int sizeofUL_CONFIG_GROUP_STRUCT = 8;

            //
            // security stuff
            //

            const int STANDARD_RIGHTS_REQUIRED = (0x000F0000);
            const int SYNCHRONIZE = (0x00100000);
            const int FILE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x000001FF);
            const int SECURITY_DESCRIPTOR_REVISION = (1);
            const int ACL_REVISION = (2);

            const int SECURITY_LOCAL_SYSTEM_RID = (0x00000012);
            const int DOMAIN_ALIAS_RID_ADMINS = (0x00000220);
            const int SECURITY_BUILTIN_DOMAIN_RID = (0x00000020);
            const int SECURITY_WORLD_RID = (0x00000000);

            const int sizeofSECURITY_ATTRIBUTES = 12; // sizeof(SECURITY_ATTRIBUTES);
            const int sizeofSECURITY_DESCRIPTOR = 20; // sizeof(SECURITY_DESCRIPTOR);

            const int sizeofACCESS_ALLOWED_ACE = 12; // sizeof(ACCESS_ALLOWED_ACE);
            const int sizeofSID_IDENTIFIER_AUTHORITY = 6; // sizeof(SID_IDENTIFIER_AUTHORITY)
            const int sizeofACL = 8; // sizeof(ACL);


            IntPtr controlChannel = IntPtr.Zero;
            IntPtr appPool = IntPtr.Zero;

            long configId = 0;

            int result = 0;
            bool status = false;

            //
            // Setup locals so we know how to cleanup on exit.
            //

            IntPtr g_pSystemSid = IntPtr.Zero;
            IntPtr g_pAdminSid = IntPtr.Zero;
            IntPtr pWorldAuthority = IntPtr.Zero;

            IntPtr pNtAuthority = IntPtr.Zero;
            IntPtr pDacl = IntPtr.Zero;
            IntPtr pConfigStruct = IntPtr.Zero;
            IntPtr pSecurityDescriptor = IntPtr.Zero;
            IntPtr pSecurityAttributes = IntPtr.Zero;

            pNtAuthority = Marshal.AllocHGlobal( sizeofSID_IDENTIFIER_AUTHORITY );
            pSecurityDescriptor = Marshal.AllocHGlobal( sizeofSECURITY_DESCRIPTOR );
            pSecurityAttributes = Marshal.AllocHGlobal( sizeofSECURITY_ATTRIBUTES );
            pConfigStruct = Marshal.AllocHGlobal( sizeofUL_CONFIG_GROUP_STRUCT );

            if ((long)pNtAuthority == 0 ||
                (long)pSecurityDescriptor == 0 ||
                (long)pSecurityAttributes == 0 ||
                (long)pConfigStruct == 0) {
                result = NativeMethods.ERROR_NOT_ENOUGH_MEMORY;
                GlobalLog.Print( "Marshal.AllocHGlobal() failed" );
                goto cleanup;
            }


            //
            // null the memory
            //

            for (int i=0;i< sizeofSID_IDENTIFIER_AUTHORITY ;i++)Marshal.WriteByte( pNtAuthority ,i,(byte)0);
            for (int i=0;i< sizeofSECURITY_DESCRIPTOR ;i++)Marshal.WriteByte( pSecurityDescriptor ,i,(byte)0);
            for (int i=0;i< sizeofSECURITY_ATTRIBUTES ;i++)Marshal.WriteByte( pSecurityAttributes ,i,(byte)0);
            for (int i=0;i< sizeofUL_CONFIG_GROUP_STRUCT ;i++)Marshal.WriteByte( pConfigStruct ,i,(byte)0);


            //
            // Allocate the DACL containing one access-allowed ACE for each
            // SID requested.
            //

            Marshal.WriteByte( pNtAuthority, 0, 0 );
            Marshal.WriteByte( pNtAuthority, 1, 0 );
            Marshal.WriteByte( pNtAuthority, 2, 0 );
            Marshal.WriteByte( pNtAuthority, 3, 0 );
            Marshal.WriteByte( pNtAuthority, 4, 0 );
            Marshal.WriteByte( pNtAuthority, 5, 5 );

            status =
            AllocateAndInitializeSid(
                                    pNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    ref g_pSystemSid );

            if (!status || (long)g_pSystemSid==0) {
                result = Marshal.GetLastWin32Error();
         