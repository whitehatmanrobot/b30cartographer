V_VT(&vVals) = VT_ARRAY | VT_I4;

		    for (count = 0; pstl && count < sab.cElements; count++)
		    {
			    ppi = (PPROBEINFO) pstl->pshf;
			    dval = ppi->Length > ((PBYTE) &ppi->OEM_Defined - (PBYTE) ppi) ? ppi->OEM_Defined : 0;
			    SafeArrayPutElement(V_ARRAY(&vVals), (long *) &count, &dval);
			    pstl = pstl->next;
		    }
		    pInst->SetVariant(L"Type28_OEMDefined", vVals);
	    }
    }

	sab.cElements = smbios.GetStructCount(29);
	if (sab.cElements > 0)
	{
	    variant_t vVals;

	    pstl = smbios.GetStructList(29);

	    if (V_ARRAY(&vVals) = SafeArrayCreate(VT_I4, 1, &sab))
	    {
	        PPROBEINFO ppi;

		    V_VT(&vVals) = VT_ARRAY | VT_I4;

		    for (count = 0; pstl && count < sab.cElements; count++)
		    {
			    ppi = (PPROBEINFO) pstl->pshf;
			    dval = ppi->Length > ((PBYTE) &ppi->OEM_Defined - (PBYTE) ppi) ? ppi->OEM_Defined : 0;
			    SafeArrayPutElement(V_ARRAY(&vVals), (long *) &count, &dval);
			    pstl = pstl->next;
		    }
		    pInst->SetVariant(L"Type29_OEMDefined", vVals);
	    }
    }

	return WBEM_S_NO_ERROR;
}
#endif // SMB_OEMBUCKET
//==============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbstruc.h ===
//=================================================================

//

// SmbStruc.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _SMBSTRUC_H_
#define _SMBSTRUC_H_

// This is file for struct types and their fields.
#include "smbios.h"

#define MIF_STRING_LENGTH	64

typedef struct _STLIST
{
	PSHF	pshf;
	ULONG	size;
	struct _STLIST *next;

} STLIST, *PSTLIST;


typedef struct _STTREE
{
	struct _STTREE *left;
	struct _STTREE *right;
	PSTLIST stlist;
	ULONG	li;

} STTREE, *PSTTREE;

typedef struct _HTREE
{
	struct _HTREE *left;
	struct _HTREE *right;
	PSHF pshf;

} HTREE, *PHTREE;



// SMBIOS data and accessor class
class CSMBios
{
	public:
	    CSMBios( );
		~CSMBios( );

		BOOL	Init( BOOL bRefresh = FALSE );
    // 0xFF means don't look for a certain type.
    //PSHF GetFirstStruct(BYTE cType = 0xFF);
    //PSHF GetNextStruct(BYTE cType = 0xFF);
		PSHF	GetNthStruct( BYTE cType, DWORD Nth );
	    PSHF	SeekViaHandle (WORD handle );
		PSTLIST	GetStructList( BYTE type );
		ULONG	GetStructCount( BYTE type );
	    int		GetStringAtOffset( PSHF pStruct, LPWSTR szString, DWORD dwOffset );
	    DWORD	GetMinorVersion( ) { return LOWORD( m_Version ); }
	    DWORD	GetMajorVersion( ) { return HIWORD( m_Version ); }
	    DWORD	GetVersion( ) { return m_Version;}
	    HRESULT	GetWbemResult( ) { return m_WbemResult; }
		PVOID	Register( VOID );
		LONG	Unregister( VOID );

	private:
		static PVOID	m_pMem;
//    static PSHF    m_pshfCurrent;
		static PSHF		m_pTable;
		static PVOID	m_pSTTree;
		static PVOID	m_pHTree;
	    static ULONG	m_Size;
	    static ULONG	m_Version;
		static ULONG	m_stcount;
        static BOOL     m_bValid;
		HRESULT	m_WbemResult;

	private:
		DWORD	GetTotalStructCount();
		BOOL	BuildStructureTree();
		BOOL	BuildHandleTree();
		PSHF	FirstStructure();
		PSHF	NextStructure( PSHF pshf );
		BOOL	InitData( LPCTSTR szFileName );
	    BOOL	InitData( GUID *pSMBiosGuid );
	    //void	SetVersion();

	    //BOOL IsRightType(BYTE cType);
	    //BOOL IsRightHandle(WORD wHandle);
	    //void MoveNext();
	    void	FreeData( );
		void	CreateInfoFile( );

};


class StructTree
{
	public:
		StructTree( PVOID pMem );
		~StructTree( );

		void Initialize( void );
		PSTTREE InsertStruct( PSHF pshf );
		PSTLIST ListNext( PSTLIST list ) { return list->next; }
		PSTTREE FindAttachNode( BYTE type );

	protected:
		PSTTREE StartTree( PSHF pshf );
		PSTTREE TreeAdd( PSTTREE tree, PSHF pshf );
		PSTLIST StartList( PSHF pshf );
		PSTLIST ListAdd( PSTLIST list, PSHF pshf );

		PSTTREE	m_tree;
		PBYTE	m_allocator;

};


class HandleTree
{
	public:
		HandleTree( PVOID pMem );
		~HandleTree( );

		void Initialize( void );
		PHTREE InsertStruct( PSHF pshf );
		PHTREE FindAttachNode( WORD handle );

	protected:
		PHTREE StartTree( PSHF pshf );
		PHTREE TreeAdd( PHTREE tree, PSHF pshf );

		PHTREE	m_tree;
		PBYTE	m_allocator;

};

#endif	// _SMBSTRUC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbstruc.cpp ===
//=================================================================

//

// SmbStruc.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#pragma warning( disable : 4200 )

#include "wmium.h"
#include "smbstruc.h"
#include "wbemcli.h"
#include "wmiapi.h"

// Leave this here until we're sure the tree corruption is gone.
#if 0
// Functions to help find memory corruption.
LPVOID mallocEx(DWORD dwSize)
{
    return
        VirtualAlloc(
            NULL,
            dwSize,
            MEM_COMMIT,
            PAGE_READWRITE);
}

void freeEx(LPVOID pMem)
{
    VirtualFree(
        pMem,
        0,
        MEM_RELEASE);
}

void MakeMemReadOnly(LPVOID pMem, DWORD dwSize, BOOL bReadOnly)
{
    DWORD dwOldProtect;

    VirtualProtect(
        pMem,
        dwSize,
        bReadOnly ? PAGE_READONLY : PAGE_READWRITE,
        &dwOldProtect);
}

void MBTrace(LPCTSTR szFormat, ...)
{
	va_list ap;

	TCHAR szMessage[512];

	va_start(ap, szFormat);
	_vstprintf(szMessage, szFormat, ap);
	va_end(ap);

	MessageBox(NULL, szMessage, _T("TRACE"), MB_OK | MB_SERVICE_NOTIFICATION);
}
#endif

//==============================================================================
// SMBios structure base class definition

#define SMBIOS_FILENAME _T("\\system\\smbios.dat")
#define EPS_FILENAME _T("\\system\\smbios.eps")


GUID guidSMBios =
   {0x8f680850, 0xa584, 0x11d1, 0xbf, 0x38, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10};

LONG	g_lRef = 0;

CCritSec smbcs;


PVOID	CSMBios::m_pMem    = NULL;
PSHF	CSMBios::m_pTable  = NULL;
PVOID	CSMBios::m_pSTTree = NULL;
PVOID	CSMBios::m_pHTree  = NULL;
ULONG	CSMBios::m_Size    = 0;
ULONG	CSMBios::m_Version = 0;
ULONG	CSMBios::m_stcount = 0;
BOOL    CSMBios::m_bValid = FALSE;

// This class loads up the SMBIOS data so it's cached.
class CBIOSInit
{
public:
    CBIOSInit();
    ~CBIOSInit();
};

CBIOSInit::CBIOSInit()
{
    CSMBios bios;

    // We can't do this here because of the resource manager.  We'll
    // now let the first call to CSMBios::Init take care of this.
    // Load up the cache.
    //bios.Init();

    // Make sure the cache doesn't go away.
    bios.Register();
}

CBIOSInit::~CBIOSInit()
{
    CSMBios bios;

    bios.Unregister();
}

// Add a refcount to the cache with a global.  Strangely enough we can't
// load the cache here because of the resource manager.
static CBIOSInit s_biosInit;

CSMBios::CSMBios( )
{
	m_WbemResult = WBEM_S_NO_ERROR;
}


CSMBios::~CSMBios( )
{
	//FreeData();
}

PVOID CSMBios::Register( void )
{
	InterlockedIncrement( &g_lRef );

	return (PVOID) this;
}


LONG CSMBios::Unregister( void )
{
	LONG lRef = -1;

	lRef = InterlockedDecrement( &g_lRef );
	if ( lRef == 0 )
	{
		FreeData( );
	}

	return lRef;
}

BOOL CSMBios::Init( BOOL bRefresh )
{
	BOOL rc = TRUE;

	if (!m_bValid)
	{
		BOOL bOutOfMemory = FALSE;

        smbcs.Enter( );

        // someone waiting while we were allocating?
        if (!m_bValid)
		{

            // NT5
#ifdef NTONLY
		    if (IsWinNT5())
			{
		        rc = InitData( &guidSMBios );
			}
			else
#endif
			{
				TCHAR	szSMBiosFile[MAX_PATH];

#ifdef WIN9XONLY
				{
					// Run dos app to collect SMBIOS table
					CreateInfoFile( );
				}
#endif
				GetWindowsDirectory(szSMBiosFile, MAX_PATH);
				lstrcat(szSMBiosFile, SMBIOS_FILENAME);

				rc = InitData( szSMBiosFile );
			}

			if (rc && (m_stcount = GetTotalStructCount()) > 0)
            {
				rc = BuildStructureTree() && BuildHandleTree();

			    if (!rc)
			    {
				    bOutOfMemory = TRUE;
                    FreeData();
			    }
                else
                    m_bValid = TRUE;
            }
		}

        smbcs.Leave( );

        if (bOutOfMemory)
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

	return rc;
}

// Get Data from a file
BOOL CSMBios::InitData(LPCTSTR szFileName)
{
	BOOL    bRet = FALSE;
	DWORD   dwSize,
            dwRead = 0;
    HANDLE  hFile;

	hFile =
        CreateFile(
            szFileName,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);

	// Get rid of previous data.
    FreeData( );

    m_WbemResult = WBEM_E_NOT_FOUND;
	// read dat file if it's there and it is larger than the stub size (4 bytes)
    if (hFile != INVALID_HANDLE_VALUE && ((dwSize = GetFileSize(hFile, NULL)) > sizeof(DWORD)))
	{
		m_pMem = malloc(dwSize);
        if (m_pMem)
		{
	        if (ReadFile(hFile, m_pMem, dwSize, &dwRead, NULL) &&
                dwSize == dwRead)
		    {
                m_Size = dwRead;

                // Point at the memory we read in.
                m_pTable = (PSHF) m_pMem;

			    TCHAR szEpsFile[MAX_PATH];
			    HANDLE hEpsFile;
			    DWORD EpsSize, dwRead;
			    BYTE EpsData[sizeof(SMB_EPS)];

			    // assume minimum version of 2.0
			    m_Version = 0x00020000;

			    GetWindowsDirectory( szEpsFile, MAX_PATH );
			    lstrcat( szEpsFile, EPS_FILENAME );
			    hEpsFile =
                    CreateFile( szEpsFile,
			            GENERIC_READ,
			            0,
			            NULL,
			            OPEN_EXISTING,
			            0,
			            NULL);
			    if (hEpsFile != INVALID_HANDLE_VALUE)
			    {
    	            EpsSize = min( GetFileSize( hEpsFile, NULL ), sizeof( SMB_EPS ) );
				    if ( ReadFile( hEpsFile, EpsData, EpsSize, &dwRead, NULL ) )
				    {
					    if ( dwRead >= sizeof( SMB_EPS ) && EpsData[1] == 'S' )
					    {
						    m_Version = MAKELONG( ( (SMB_EPS *)(EpsData) )->version_minor,
						                                ( (SMB_EPS *)(EpsData) )->version_major );
                        }
					    else if ( dwRead >= sizeof( DMI_EPS ) && EpsData[1] == 'D' )
					    {
						    m_Version = MAKELONG( ( (DMI_EPS *)(EpsData) )->bcd_revision & 0x0f,
						                                ( (DMI_EPS *)(EpsData) )->bcd_revision >> 4 );
					    }
				    }
				    CloseHandle( hEpsFile );
		        }

		        bRet = TRUE;
            }
		}
        else
        {
			m_WbemResult  = WBEM_E_OUT_OF_MEMORY;
        }
	}

    if (hFile)
        CloseHandle(hFile);

    if (!bRet && m_pMem)
        // If everything didn't succeed, reset the instance.
        FreeData();

	if (m_WbemResult == WBEM_E_OUT_OF_MEMORY)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    return bRet;
}

#define DEFAULT_MEM_SIZE    4096
#define EPS_DATA_LENGTH		8

typedef	ULONG (WINAPI *WMIOPENBLOCK)(IN GUID *, IN ULONG, OUT WMIHANDLE);
typedef ULONG (WINAPI *WMICLOSEBLOCK)(IN WMIHANDLE);
typedef ULONG (WINAPI *WMIQUERYALLDATA)(IN WMIHANDLE, IN OUT ULONG *, OUT PVOID);

// Get Data from WMI
BOOL CSMBios::InitData(GUID *pSMBiosGuid)
{
	BOOL        bRet = FALSE;
	WMIHANDLE   dbh = NULL;
	CWmiApi		*pWmi = NULL ;

	if (!pSMBiosGuid)
        return FALSE;

    // Get rid of previous data.
    FreeData();

    // Reset our error flag.
    m_WbemResult = WBEM_S_NO_ERROR;

	pWmi = (CWmiApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWmiApi, NULL);
    if (pWmi && pWmi->WmiOpenBlock(pSMBiosGuid, 0, &dbh) == ERROR_SUCCESS)
	{
        DWORD           dwSize = DEFAULT_MEM_SIZE;
        PWNODE_ALL_DATA pwad = (PWNODE_ALL_DATA) malloc(dwSize);
        DWORD           dwErr;

        if (pwad)
		{
            memset(pwad, 0, dwSize);

            // Make sure our obj points at the memory we allocated.
            m_pMem = pwad;

            if ((dwErr = pWmi->WmiQueryAllData(dbh, &dwSize, (PVOID) pwad)) ==
                ERROR_INSUFFICIENT_BUFFER)
            {
                // Was the size we passed too small?  If so, try it again.
                free(pwad);
                pwad = (PWNODE_ALL_DATA) malloc(dwSize);
                m_pMem = pwad;

                if (pwad)
                {
                    memset(pwad, 0, dwSize);

                    if ((dwErr = pWmi->WmiQueryAllData(dbh, &dwSize, (PVOID) pwad))
                        != ERROR_SUCCESS)
                        m_WbemResult = WBEM_E_NOT_FOUND;
                }
                else
                    m_WbemResult = WBEM_E_OUT_OF_MEMORY;
            }
            else if (dwErr != ERROR_SUCCESS)
                m_WbemResult = WBEM_E_NOT_FOUND;

            if (m_WbemResult == WBEM_S_NO_ERROR)
            {
                // Check for table data after the eps data items (of EPS_DATA_LENGTH long)
		        // The table top pointer is set and if valid, the size is > 0
                if (pwad->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE)
                {
                    m_pTable = (PSHF) ((PBYTE) pwad + pwad->DataBlockOffset +
                                EPS_DATA_LENGTH);

                    if (pwad->FixedInstanceSize > EPS_DATA_LENGTH)
                        m_Size = pwad->FixedInstanceSize - EPS_DATA_LENGTH;
		            else
           	            m_Size = 0;
	            }
                else
	            {
                    m_pTable =
                        (PSHF) ((PBYTE) pwad + EPS_DATA_LENGTH +
                            pwad->OffsetInstanceDataAndLength[0].OffsetInstanceData);

                    if (pwad->OffsetInstanceDataAndLength[0].LengthInstanceData >
                        EPS_DATA_LENGTH)
                    {
				        m_Size =
                            pwad->OffsetInstanceDataAndLength[0].LengthInstanceData
                                - EPS_DATA_LENGTH;
                    }
                    else
                    {
                        m_Size = 0;
                    }
                }

                // Determine Version.  Some EPS data is returned in the first X bytes
		        if ( m_Size > 0 )
		        {
			        PBYTE eps_data = (PBYTE) m_pTable - EPS_DATA_LENGTH;

                    // read the bcd revision field if PnP calling method was used.
                    // Also, W2K seems to sometimes mess up and not set this flag.
                    // So, if we see that eps_data[1] (major version) is 0, we know
                    // we had better use the PnP method instead.

                    if (eps_data[0] || !eps_data[1])
			        {
				        m_Version = MAKELONG(eps_data[3] & 0x0f, eps_data[3] >> 4);
                    }
			        else	// read the smbios major and minor version fields
			        {
				        m_Version = MAKELONG(eps_data[2], eps_data[1]);
                    }

                    bRet = TRUE;	// valid table data is found

                    // Some BIOSes are naughty and report 0 as the version.
                    // Assume this means 2.0.
                    if (!m_Version)
                        m_Version = MAKELONG(0, 2);
                }
            }
		}
        else
        {
			m_WbemResult = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        LogMessage(L"No smbios data");
    }

    if (pWmi)
    {
        // dbh will only be non-null if we got something for pWmi.
        if (dbh)
            pWmi->WmiCloseBlock(dbh);

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWmiApi, pWmi);
    }

    // Free up the memory if something went wrong along the way.
    if (!bRet && m_pMem)
	{
        FreeData();
    }

	if (m_WbemResult == WBEM_E_OUT_OF_MEMORY)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

	return bRet;
}


void CSMBios::FreeData( )
{
    smbcs.Enter();

    m_bValid = FALSE;

    if ( m_pSTTree )
	{
		//freeEx( m_pSTTree );
		free( m_pSTTree );
		m_pSTTree = NULL;
	}
	if ( m_pHTree )
	{
		//freeEx( m_pHTree );
		free( m_pHTree );
		m_pHTree = NULL;
	}
	if ( m_pMem )
    {
        free( m_pMem );
        m_pMem = NULL;
        m_pTable = NULL;
    }

    smbcs.Leave();
}

#define MAX_KNOWN_SMBIOS_STRUCT 36

const BOOL g_bStructHasStrings[MAX_KNOWN_SMBIOS_STRUCT + 1] =
{
    TRUE,  // 0 - BIOS Information
    TRUE,  // 1 - System Information
    TRUE,  // 2 - Base board Information
    TRUE,  // 3 - System enclosure or chassis
    TRUE,  // 4 - Processor Information
    FALSE, // 5 - Memory Controller Information
    TRUE,  // 6 - Memory Module Information
    TRUE,  // 7 - Cache Information
    TRUE,  // 8 - Port Connector Information
    TRUE,  // 9 - System Slots
    TRUE,  // 10 - On board Devices information
    TRUE,  // 11 - OEM Strings
    TRUE,  // 12 - System Configuration Options
    TRUE,  // 13 - BIOS Language Information
    TRUE,  // 14 - Group Associations
    FALSE, // 15 - System Event Log
    FALSE, // 16 - Physical Memory Area
    TRUE,  // 17 - Memory Device
    FALSE, // 18 - Memory Error Information
    FALSE, // 19 - Memory Array Mapped Address
    FALSE, // 20 - Memory Device Mapped Address
    FALSE, // 21 - Built-in Pointing Device
    TRUE,  // 22 - Portable Battery
    FALSE, // 23 - System Reset
    FALSE, // 24 - Hardware Security
    FALSE, // 25 - System Power Controls
    TRUE,  // 26 - Voltage Probe
    FALSE, // 27 - Cooling Device
    TRUE,  // 28 - Temperature Probe
    TRUE,  // 29 - Electrical Current Probe
    TRUE,  // 30 - Out of Band Remote Access
    FALSE, // 31 - Boot Integrity Services
    FALSE, // 32 - System Boot Information
    FALSE, // 33 - 64bit Memory Error Information
    TRUE,  // 34 - Management Device
    TRUE,  // 35 - Management Device Component
    FALSE  // 36 - Management Device Threshold Data

};

PSHF CSMBios::NextStructure( PSHF pshf )
{
	PBYTE dp;
	ULONG i;
    LONG limit;

	limit = m_Size - ( (PBYTE) pshf - (PBYTE) m_pTable );
	if ( limit > 0 )
	{
		limit--;
	}
    else
    {
        // If we are already past the limit, no point in proceeding
        return NULL;
    }

	dp = (PBYTE) pshf;
	i = pshf->Length;

    // HACK: We found an SMBIOS 2.0 board that doesn't terminate
    // its stringless structures with a double null.  So, see if the
    // current struct is stringless, and then check to see if the 1st
    // byte past the length of the current struct is non-null.  If it
    // is non-null we're sitting on the next structure so return it.
    if (i && pshf->Type <= MAX_KNOWN_SMBIOS_STRUCT &&
        !g_bStructHasStrings[pshf->Type] && dp[i])
        return (PSHF) (dp + i);

	pshf = NULL;
    while ( i < limit )
	{
		if ( !( dp[i] || dp[i+1] ) )
		{
			i += 2;
			pshf = (PSHF) ( dp + i );
			break;
		}
		else
		{
			i++;
		}
	}

	return ( i < limit ) ? pshf : NULL;
}

PSHF CSMBios::FirstStructure( void )
{
    return m_pTable;
}

int CSMBios::GetStringAtOffset(PSHF pshf, LPWSTR szString, DWORD dwOffset)
{
	int     iLen = 0;
	PBYTE   pstart = (PBYTE) pshf + pshf->Length,
            pTotalEnd = (PBYTE) m_pTable + m_Size;
    DWORD   dwString;
    LPWSTR  szOut = szString;

	// hunt for the start of the requested string
    for (dwString = 1; pstart < pTotalEnd && *pstart && dwOffset > dwString;
        dwString++, pstart++)
    {
        while (pstart < pTotalEnd && *pstart)
            pstart++;
    }

	// Null offset means string isn't present
	if ( dwOffset > 0 )
	{
		iLen = MIF_STRING_LENGTH;
	    // Can't use lstrcpy because it's not always null terminated!
	    while (pstart < pTotalEnd && *pstart > 0x0F && iLen)
		{
	        // This should work fine for unicode.
            *szOut++ = *pstart++;
			iLen--;
		}
	}

    // Throw on a 0 at the end.
    *szOut++ = 0;

	return lstrlenW(szString);
}

ULONG CSMBios::GetStructCount( BYTE type )
{
	StructTree	sttree( m_pSTTree );
	PSTTREE tree;

	tree = sttree.FindAttachNode( type );
	if ( tree )
	{
		return tree->li;
	}

	return 0;
}


PSTLIST CSMBios::GetStructList( BYTE type )
{
	StructTree	sttree( m_pSTTree );
	PSTTREE tree;

	tree = sttree.FindAttachNode( type );
	if ( tree )
	{
		return tree->stlist;
	}

    LogMessage(L"SMBios Structure not found");

	return NULL;
}


PSHF CSMBios::GetNthStruct( BYTE type, DWORD Nth )
{
	StructTree	sttree( m_pSTTree );
	PSTTREE tree;
	PSTLIST pstl;
	PSHF pshf = NULL;

	tree = sttree.FindAttachNode( type );
	if ( tree )
	{
		pstl = tree->stlist;
		while ( Nth-- && pstl )
		{
			pstl = pstl->next;
		}
		if ( pstl )
		{
			pshf = pstl->pshf;
		}
	}

    return pshf;
}

PSHF CSMBios::SeekViaHandle( WORD handle )
{
	HandleTree	htree( m_pHTree );
	PHTREE tree;

	tree = htree.FindAttachNode( handle );
	if ( tree )
	{
		return tree->pshf;
	}

	return NULL;
}

#ifdef WIN9XONLY
// Win95 only!
void CSMBios::CreateInfoFile()
{
	TCHAR		szExePath[MAX_PATH];
	CRegistry	reg;
	CHString	strWBEMPath;
	STARTUPINFO	startup;
	PROCESS_INFORMATION
				procinfo;

	// Bail if we couldn't find the path.
	if (reg.OpenLocalMachineKeyAndReadValue(
		L"SOFTWARE\\Microsoft\\WBEM",
		L"Installation Directory",
		strWBEMPath) != ERROR_SUCCESS)
		return;

	// smbdpmi.exe to the path we just got from the registry.
	_tmakepath(
		szExePath,
		NULL,
		TOBSTRT(strWBEMPath),
		_T("smbdpmi.pif"),
		NULL);

	// Grab a copy of the startup info so we don't have
	// to fill one out.
	GetStartupInfo( &startup );

	// Set these so we don't see the console flash.
	startup.dwFlags     = STARTF_USESHOWWINDOW;
	startup.wShowWindow = SW_HIDE;

	BOOL bRet =
		CreateProcess(
			NULL,
			szExePath,
			NULL,
			NULL,
			FALSE,
			0,
			NULL,
			TOBSTRT(strWBEMPath),
			&startup,
			&procinfo);


	if ( bRet )
	{
		// Wait for 5 seconds.  Should never take this long, but
		// just in case.
		WaitForSingleObject(procinfo.hProcess, 5000);

		// Get rid of the handles we were given.
		CloseHandle(procinfo.hProcess);
		CloseHandle(procinfo.hThread);
	}
}
#endif


DWORD CSMBios::GetTotalStructCount()
{
    DWORD dwCount = 0;

    for (PSHF pshf = FirstStructure(); pshf != NULL;
        pshf = NextStructure(pshf))
	{
		dwCount++;
    }

    return dwCount;
}

BOOL CSMBios::BuildStructureTree( void )
{
	PSHF pshf;

	//m_pSTTree = mallocEx( ( sizeof( STTREE ) * m_stcount ) + ( sizeof( STLIST ) * m_stcount ) );
	m_pSTTree = malloc( ( sizeof( STTREE ) * m_stcount ) + ( sizeof( STLIST ) * m_stcount ) );

	if ( m_pSTTree )
	{
		StructTree sttree( m_pSTTree );

		sttree.Initialize( );

		pshf = FirstStructure( );
		while ( pshf )
		{
			sttree.InsertStruct( pshf );
			pshf = NextStructure( pshf );
		}

        //MakeMemReadOnly(
        //    m_pSTTree,
        //    ( sizeof( STTREE ) * m_stcount ) + ( sizeof( STLIST ) * m_stcount ),
        //    TRUE);
	}

	return m_pSTTree ? TRUE : FALSE;
}


BOOL CSMBios::BuildHandleTree( void )
{
	PSHF pshf;

	//m_pHTree = mallocEx( sizeof( HTREE ) * m_stcount );
	m_pHTree = malloc( sizeof( HTREE ) * m_stcount );

	if ( m_pHTree )
	{
		HandleTree htree( m_pHTree );

		htree.Initialize( );

		pshf = FirstStructure( );
		while ( pshf )
		{
			htree.InsertStruct( pshf );
			pshf = NextStructure( pshf );
		}

        //MakeMemReadOnly(
        //    m_pHTree,
        //    (sizeof( HTREE ) * m_stcount),
        //    TRUE);
	}

	return m_pHTree ? TRUE : FALSE;
}


//==============================================================================
//	SMBIOS structure tree operation class
//
//	Allocation of memory is external
//==============================================================================
StructTree::StructTree( PVOID pMem )
{
	m_tree = (PSTTREE) pMem;
	m_allocator = NULL;
}


StructTree::~StructTree( )
{
}


void StructTree::Initialize( void )
{
	m_tree->left   = NULL;
	m_tree->right  = NULL;
	m_tree->stlist = NULL;
	m_tree->li     = 0;
	m_allocator = (PBYTE) m_tree;
}


PSTTREE StructTree::InsertStruct( PSHF pshf )
{
	PSTTREE tree;

	if ( m_tree->stlist == NULL )
	{
		tree = StartTree( pshf );
	}
	else
	{
		tree = TreeAdd( m_tree, pshf );
	}

	return tree;
}


PSTTREE StructTree::StartTree( PSHF pshf )
{
	PSTTREE tree = (PSTTREE) m_allocator;

	m_allocator += sizeof( STTREE );
	tree->stlist = StartList( pshf );
	tree->left   = NULL;
	tree->right  = NULL;
	tree->li     = 1;

	return tree;
}


PSTTREE StructTree::TreeAdd( PSTTREE tree, PSHF pshf )
{
	PSTTREE next = tree;

	while ( next )
	{
		tree = next;

		if ( tree->stlist->pshf->Type < pshf->Type )
		{
			next = tree->right;
			if ( next == NULL )
			{
				tree->right = StartTree( pshf );
				tree = tree->right;
			}
		}
		else if ( tree->stlist->pshf->Type > pshf->Type )
		{
			next = tree->left;
			if ( next == NULL )
			{
				tree->left = StartTree( pshf );
				tree = tree->left;
			}
		}
		else
		{
			ListAdd( tree->stlist, pshf );
			tree->li++;
			next = NULL;
		}
	}

	return tree;
}


PSTTREE StructTree::FindAttachNode( BYTE type )
{
	PSTTREE		next, tree;
	BOOL		found = FALSE;

	next = m_tree;
	tree = m_tree;

	while ( next )
	{
		tree = next;

		if ( tree->stlist->pshf->Type < type )
		{
			next = tree->right;
		}
		else if ( tree->stlist->pshf->Type > type )
		{
			next = tree->left;
		}
		else
		{
			next = NULL;
			found = TRUE;
		}
	}

	return found ? tree : NULL;
}


PSTLIST StructTree::StartList( PSHF pshf )
{
	PSTLIST stlist;

	stlist = (PSTLIST) m_allocator;
	m_allocator += sizeof( STLIST );

	stlist->pshf = pshf;
	stlist->next = NULL;

	return stlist;
}


PSTLIST StructTree::ListAdd( PSTLIST list, PSHF pshf )
{
	PSTLIST added;

	while ( list->next )
	{
		list = list->next;
	}
	added = (PSTLIST) m_allocator;
	m_allocator += sizeof( STLIST );

	list->next = added;
	added->pshf = pshf;
	added->next = NULL;

	return added;
}


//==============================================================================
//	SMBIOS handle tree operation class
//
//	Allocation of memory is external
//==============================================================================
HandleTree::HandleTree( PVOID pMem )
{
	m_tree = (PHTREE) pMem;
	m_allocator = NULL;
}

HandleTree::~HandleTree( )
{
}


void HandleTree::Initialize( void )
{
	m_tree->left   = NULL;
	m_tree->right  = NULL;
	m_tree->pshf   = NULL;
	m_allocator = (PBYTE) m_tree;
}


PHTREE HandleTree::InsertStruct( PSHF pshf )
{
	PHTREE tree;

	if ( m_tree->pshf == NULL )
	{
		tree = StartTree( pshf );
	}
	else
	{
		tree = TreeAdd( m_tree, pshf );
	}

	return tree;
}


PHTREE HandleTree::StartTree( PSHF pshf )
{
	PHTREE tree = (PHTREE) m_allocator;

	m_allocator += sizeof( HTREE );
	tree->pshf  = pshf;
	tree->left  = NULL;
	tree->right = NULL;

	return tree;
}


PHTREE HandleTree::TreeAdd( PHTREE tree, PSHF pshf )
{
	PHTREE next = tree;

	while ( next )
	{
		tree = next;

		if ( tree->pshf->Handle < pshf->Handle )
		{
			next = tree->right;
			if ( next == NULL )
			{
				tree->right = StartTree( pshf );
				tree = tree->right;
			}
		}
		else if ( tree->pshf->Handle > pshf->Handle )
		{
			next = tree->left;
			if ( next == NULL )
			{
				tree->left = StartTree( pshf );
				tree = tree->left;
			}
		}
		else
		{
			tree->pshf = pshf;
			next = NULL;
		}
	}

	return tree;
}


PHTREE HandleTree::FindAttachNode( WORD handle )
{
	PHTREE		next, tree;
	BOOL		found = FALSE;

	next = m_tree;
	tree = m_tree;

	while ( next )
	{
		tree = next;

		if ( tree->pshf->Handle < handle )
		{
			next = tree->right;
		}
		else if ( tree->pshf->Handle > handle )
		{
			next = tree->left;
		}
		else
		{
			next  = NULL;
			found = TRUE;
		}
	}

	return found ? tree : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbassoc.h ===
//=================================================================

//

// SmbAssoc.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#define  PROPSET_NAME_ASSOCPROCMEMORY L"Win32_AssociatedProcessorMemory"

class CWin32AssocProcMemory : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32AssocProcMemory(LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32AssocProcMemory( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};



#define  PROPSET_NAME_MEMORYDEVICELOCATION L"Win32_MemoryDeviceLocation"

class CWin32MemoryDeviceLocation : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryDeviceLocation( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32MemoryDeviceLocation( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};



#define  PROPSET_NAME_MEMORYARRAYLOCATION L"Win32_MemoryArrayLocation"

class CWin32MemoryArrayLocation : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryArrayLocation( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32MemoryArrayLocation( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};


#define  PROPSET_NAME_PHYSICALMEMORYLOCATION L"Win32_PhysicalMemoryLocation"

class CWin32PhysicalMemoryLocation : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PhysicalMemoryLocation( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32PhysicalMemoryLocation( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};


#define  PROPSET_NAME_MEMDEVICEARRAY L"Win32_MemoryDeviceArray"

class CWin32MemoryDeviceArray : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryDeviceArray( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32MemoryDeviceArray( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, long lFlags = 0L ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbtocim.cpp ===
//==============================================================================

// SMBIOS --> CIM array mappings

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "smbtocim.h"

typedef struct tagCIM_MAP_PAIRS
{
	UINT	smb_val;
	UINT	cim_val;

} CIM_MAP_PAIRS, *PCIM_MAP_PAIRS;


typedef struct tagCIM_MAP_ARRAY
{
	PCIM_MAP_PAIRS	array;
	UINT			length;

} CIM_MAP_ARRAY, *PCIM_MAP_ARRAY;



CIM_MAP_PAIRS g_SlotTypeMapPairs[] =
{
	{ 0x01, 00 },		// Other
	{ 0x02, 00 },		// Unknown
	{ 0x03, 44 },		// ISA
	{ 0x04,	01 },		// MCA
	{ 0x05,	45 },		// EISA
	{ 0x06, 43 },		// PCI
	{ 0x07, 47 },		// PC Card (PCMCIA)
	{ 0x08, 46 },		// VL-VESA
	{ 0x09, 01 },		// Proprietary
	{ 0x0A, 76 },		// Processor Card Slot
	{ 0x0B, 77 },		// Proprietary Memory Card Slot
	{ 0x0C, 78 },		// I/O Riser Card Slot
	{ 0x0D, 65 },		// NuBus
	{ 0x0E, 79 },		// PCI - 66MHz Capable
	{ 0x0F, 73 },		// AGP
	{ 0x10, 80 },		// AGP 2X
	{ 0x11, 81 },		// AGP 4X
	{ 0xA0, 82 },		// PC-98/C20
	{ 0xA1, 83 },		// PC-98/C24
	{ 0xA2, 84 },	 	// PC-98/E
	{ 0xA3, 85 },		// PC-98/Local Bus
	{ 0xA4, 86 },		// PC-98/Card
};


CIM_MAP_PAIRS g_ConnectorTypeMapPairs[] =
{
	{ 0x00, 00 },		// None
	{ 0x01, 66 },		// Centronics
	{ 0x02, 67 },		// Mini Centronics
	{ 0x03, 01 },		// Proprietary
	{ 0x04, 23 },		// DB-25 pin male
	{ 0x05, 23 },		// DB-25 pin female
	{ 0x06, 22 },		// DB-15  pin male
	{ 0x07, 22 },		// DB-15 pin female
	{ 0x08, 21 },		// DB-9 pin male
	{ 0x09, 21 },		// DB-9  pin female
	{ 0x0A, 38 },		// RJ-11
	{ 0x0B, 39 },		// RJ-45
	{ 0x0C, 06 },		// 50 Pin MiniSCSI
	{ 0x0D, 59 },		// Mini-DIN
	{ 0x0E, 60 },		// Micro-DIN
	{ 0x0F, 61 },		// PS/2
	{ 0x10, 62 },		// Infrared
	{ 0x11, 63 },		// HP-HIL
	{ 0x12, 64 },		// Access Bus (USB)
	{ 0x13, 13 },		// SSA SCSI
	{ 0x14, 59 },		// Circular DIN-8 male
	{ 0x15, 59 },		// Circular DIN-8 female
	{ 0x16, 16 },		// On Board IDE
	{ 0x17, 89 },		// On Board Floppy
	{ 0x18, 90 },		// 9 Pin Dual Inline (pin 10 cut)
	{ 0x19, 91 },		// 25 Pin Dual Inline (pin 26 cut)
	{ 0x1A, 92 },		// 50 Pin Dual Inline
	{ 0x1B, 93 },		// 68 Pin  Dual Inline
	{ 0x1C, 94 },		// On Board Sound Input from CD-ROM
	{ 0x1D, 68 },		// Mini-Centronics Type-14
	{ 0x1E, 70 },		// Mini-Centronics Type-26
	{ 0x1F, 88 },		// Mini-jack (headphones)
	{ 0x20, 37 },		// BNC
	{ 0x21, 54 },		// 1394
	{ 0xA0, 83 },		// PC-98
	{ 0xA1, 84 },		// PC-98Hireso
	{ 0xA2, 85 },		// PC-H98
	{ 0xA3, 86 },		// PC-98Note
	{ 0xA4, 87 },		// PC-98Full
};

CIM_MAP_PAIRS g_ConnectorGenderMapPairs[] =
{
	{ 0x00, 00 },		// None
	{ 0x01, 00 },		// Centronics
	{ 0x02, 00 },		// Mini Centronics
	{ 0x03, 00 },		// Proprietary
	{ 0x04, 02 },		// DB-25 pin male
	{ 0x05, 03 },		// DB-25 pin female
	{ 0x06, 02 },		// DB-15  pin male
	{ 0x07, 03 },		// DB-15 pin female
	{ 0x08, 02 },		// DB-9 pin male
	{ 0x09, 03 },		// DB-9  pin female
	{ 0x0A, 00 },		// RJ-11
	{ 0x0B, 00 },		// RJ-45
	{ 0x0C, 00 },		// 50 Pin MiniSCSI
	{ 0x0D, 00 },		// Mini-DIN
	{ 0x0E, 00 },		// Micro-DIN
	{ 0x0F, 00 },		// PS/2
	{ 0x10, 00 },		// Infrared
	{ 0x11, 00 },		// HP-HIL
	{ 0x12, 00 },		// Access Bus (USB)
	{ 0x13, 00 },		// SSA SCSI
	{ 0x14, 02 },		// Circular DIN-8 male
	{ 0x15, 03 },		// Circular DIN-8 female
	{ 0x16, 00 },		// On Board IDE
	{ 0x17, 00 },		// On Board Floppy
	{ 0x18, 00 },		// 9 Pin Dual Inline (pin 10 cut)
	{ 0x19, 00 },		// 25 Pin Dual Inline (pin 26 cut)
	{ 0x1A, 00 },		// 50 Pin Dual Inline
	{ 0x1B, 00 },		// 68 Pin  Dual Inline
	{ 0x1C, 00 },		// On Board Sound Input from CD-ROM
	{ 0x1D, 00 },		// Mini-Centronics Type-14
	{ 0x1E, 00 },		// Mini-Centronics Type-26
	{ 0x1F, 00 },		// Mini-jack (headphones)
	{ 0x20, 00 },		// BNC
	{ 0x21, 00 },		// 1394
	{ 0xA0, 00 },		// PC-98
	{ 0xA1, 00 },		// PC-98Hireso
	{ 0xA2, 00 },		// PC-H98
	{ 0xA3, 00 },		// PC-98Note
	{ 0xA4, 00 },		// PC-98Full
};


CIM_MAP_PAIRS g_FormFactorTypeMapPairs[] =
{
	{ 0x01,	 1 },		// Other
	{ 0x02,	 0 },		// Unknown
	{ 0x03,	 7 },		// SIMM
	{ 0x04,	 2 },		// SIP
	{ 0x05,	 0 },		// Chip
	{ 0x06,	 3 },		// DIP
	{ 0x07,	 4 },		// ZIP
	{ 0x08,	 6 },		// Proprietary Card
	{ 0x09,	 8 },		// DIMM
	{ 0x0A,	 9 },		// TSOP
	{ 0x0B,	 0 },		// Row of chips
	{ 0x0C,	11 },		// RIMM
	{ 0x0D,	12 },		// SODIMM
};


CIM_MAP_PAIRS g_MemoryTypeMapPairs[] =
{
	{ 0x01,  1 },		// Other
	{ 0x02,  0 },		// Unknown
	{ 0x03,  2 },		// DRAM
	{ 0x04,  6 },		// EDRAM
	{ 0x05,  7 },		// VRAM
	{ 0x06,  8 },		// SRAM
	{ 0x07,  9 },		// RAM
	{ 0x08, 10 },		// ROM
	{ 0x09, 11 },		// FLASH
	{ 0x0A, 12 },		// EEPROM
	{ 0x0B, 13 },		// FEPROM
	{ 0x0C, 14 },		// EPROM
	{ 0x0D, 15 },		// CDRAM
	{ 0x0E, 16 },		// 3DRAM
	{ 0x0F, 17 },		// SDRAM
	{ 0x10, 18 },		// SGRAM
};

CIM_MAP_ARRAY g_CimMapArrayList[] =
{
	{ g_SlotTypeMapPairs,        sizeof( g_SlotTypeMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
	{ g_ConnectorTypeMapPairs,   sizeof( g_ConnectorTypeMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
	{ g_ConnectorGenderMapPairs, sizeof( g_ConnectorGenderMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
	{ g_FormFactorTypeMapPairs,  sizeof( g_FormFactorTypeMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
	{ g_MemoryTypeMapPairs,      sizeof( g_MemoryTypeMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
};


UINT GetCimVal( CIMMAPPERS a_arrayid, UINT a_smb_val )
{
	CIM_MAP_PAIRS *t_cimmaparray = g_CimMapArrayList[ a_arrayid ].array ;

	for ( int t_i = 0; t_i < g_CimMapArrayList[ a_arrayid ].length; t_i++ )
	{
		if ( t_cimmaparray->smb_val == a_smb_val )
		{
			return t_cimmaparray->cim_val ;
		}
		t_cimmaparray++ ;
	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbtocim.h ===
//==============================================================================

// SMBIOS --> CIM array mappings

// 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _SMBTOCIM_
#define _SMBTOCIM_

// add mapper ids here
typedef enum
{
	SlotType = 0,
	ConnectorType,
	ConnectorGender,
	FormFactor,
	MemoryType

} CIMMAPPERS;


UINT GetCimVal( CIMMAPPERS arrayid, UINT smb_val );

#endif	// _SMBTOCIM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\snddevice.cpp ===
//=================================================================

//

// SndDevice.cpp

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "DllWrapperBase.h"
#include "WinmmApi.h"
#include "snddevice.h"

// Property set declaration
//=========================
CWin32SndDevice	win32SoundDevice(PROPSET_NAME_SOUNDDEVICE, IDS_CimWin32Namespace );


CWin32SndDevice::CWin32SndDevice (LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

CWin32SndDevice::~CWin32SndDevice ()
{

}

HRESULT CWin32SndDevice::GetObject(CInstance *pInst, long lFlags/* = 0L*/)
{
	HRESULT hResult = WBEM_E_NOT_FOUND;

#ifdef WIN9XONLY
		// works for '98 as well
	hResult = GetObject95(pInst, lFlags);
#endif

#ifdef NTONLY
	if (IsWinNT5())
		hResult = GetObjectNT5(pInst, lFlags);
	else
		hResult = GetObjectNT4(pInst, lFlags);
#endif

	return hResult;
}

#ifdef WIN9XONLY
HRESULT CWin32SndDevice::GetObject95 (CInstance *pInst, long lFlags/* = 0L*/)
{
	HRESULT hResult = WBEM_E_NOT_FOUND;

	// enumerate through the wave devices looking for a match with the Device ID.
	CRegistry	Registry;
	CHString	strEnumKey;
	CHString	strDeviceID;
	CHString	strCompareKey;
	CHString	strCompleteKey;

	// how many sound devices are there?
	CHString strWaveKey = L"SYSTEM\\CurrentControlSet\\control\\MediaResources\\wave";

	if (ERROR_SUCCESS == Registry.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE, strWaveKey, KEY_READ))
	{
		while (Registry.GetCurrentSubKeyName(strEnumKey) == ERROR_SUCCESS)
		{
			// get device id for the key
			if (Registry.GetCurrentSubKeyValue(L"DeviceID", strDeviceID) == ERROR_SUCCESS)
		   	{
				strCompleteKey = strWaveKey;
				strCompleteKey += L"\\";
				strCompleteKey += strEnumKey;

				pInst->GetCHString(L"DeviceID", strCompareKey);

				if (0 == strCompareKey.CompareNoCase(strDeviceID))
				{
					hResult = LoadProperties95(pInst, strCompleteKey);
				}
			}
			Registry.NextSubKey();
		}
		Registry.Close();
	}

	return hResult;
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::GetObjectNT4 (CInstance *pInst, long lFlags/* = 0L*/)
{
	HRESULT Result = WBEM_E_FAILED;

	CWinmmApi *pWinmmApi = (CWinmmApi *)CResourceManager::sm_TheResourceManager.GetResource (g_guidWinmmApi, NULL);
	if (pWinmmApi)
	{
		Result = LoadPropertiesNT4(*pWinmmApi , pInst);

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidWinmmApi , pWinmmApi);
	}

	return Result;
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::GetObjectNT5(CInstance *pInst, long lFlags)
{
	HRESULT Result = WBEM_E_FAILED;

	CWinmmApi *pWinmmApi = (CWinmmApi *)CResourceManager::sm_TheResourceManager.GetResource (g_guidWinmmApi, NULL);
	if (pWinmmApi)
	{
		Result = LoadPropertiesNT5(*pWinmmApi , pInst);

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidWinmmApi , pWinmmApi);
	}

	return Result;
}
#endif

HRESULT CWin32SndDevice::EnumerateInstances(MethodContext *pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hResult = WBEM_E_FAILED;

#ifdef WIN9XONLY
		// works for '98 as well
	hResult = EnumerateInstances95(pMethodContext, lFlags);
#endif

#ifdef NTONLY

	CWinmmApi *pWinmmApi = (CWinmmApi *)CResourceManager::sm_TheResourceManager.GetResource (g_guidWinmmApi, NULL);
	if (pWinmmApi)
	{
		if (IsWinNT5())
			hResult = EnumerateInstancesNT5(*pWinmmApi , pMethodContext);
		else
			hResult = EnumerateInstancesNT4(*pWinmmApi , pMethodContext);

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidWinmmApi , pWinmmApi);
	}

#endif

	return hResult;
}

#ifdef WIN9XONLY
typedef std::map<CHString, BOOL> STRING2BOOL;

HRESULT CWin32SndDevice::EnumerateInstances95(MethodContext *pMethodContext, long lFlags)
{
	HRESULT     hResult = WBEM_S_NO_ERROR;
	CRegistry   reg;
	CHString    strEnumKey;
	CHString    strDeviceID;

	CHString    strWaveKey = L"SYSTEM\\CurrentControlSet\\control\\MediaResources\\wave";

	if (ERROR_SUCCESS == reg.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
		strWaveKey, KEY_READ))
	{
		// smart ptr
		CInstancePtr pInst;
        STRING2BOOL  mapDeviceID;

		for ( ;
            reg.GetCurrentSubKeyName(strEnumKey) == ERROR_SUCCESS;
            reg.NextSubKey())
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			if (NULL != pInst)
			{
				// get device id for the key
				if (reg.GetCurrentSubKeyValue(L"DeviceID", strDeviceID) ==
					ERROR_SUCCESS)
				{
                    // If it's already in the map, skip it.
                    if (mapDeviceID.find(strDeviceID) != mapDeviceID.end())
                        continue;

                    CHString strCompleteKey;

					pInst->SetCHString(L"DeviceID", strDeviceID);

		   			strCompleteKey = strWaveKey;
		   			strCompleteKey += L"\\";
		   			strCompleteKey += strEnumKey;
    				hResult = LoadProperties95(pInst, strCompleteKey);

					pInst->Commit();

                    // Make sure we don't get this same device again.
                    mapDeviceID[strDeviceID] = 0;
				}
			}
			else
			{
				hResult = WBEM_E_FAILED;
			}
		}
	}

	return hResult;
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::EnumerateInstancesNT4(CWinmmApi &WinmmApi , MethodContext *pMethodContext, long lFlags)
{
	HRESULT		hResult = WBEM_S_NO_ERROR;

	int nCount = WinmmApi.WinMMwaveOutGetNumDevs();

	for (int i = 0; i < nCount && SUCCEEDED(hResult); i++)
	{
		CHString		str;

		// smart ptr
		CInstancePtr	pInst(CreateNewInstance(pMethodContext), false);

		if (NULL != pInst)
		{
			str.Format(L"%d", i);

			pInst->SetCharSplat(L"DeviceID", str);

			if (SUCCEEDED(hResult = LoadPropertiesNT4(WinmmApi , pInst)))
			{
				hResult = pInst->Commit();
			}
		}
		else
		{
			hResult = WBEM_E_FAILED;
		}
	}

	return hResult;
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::EnumerateInstancesNT5(CWinmmApi &WinmmApi , MethodContext *pMethodContext, long lFlags)
{
	HRESULT             hResult = WBEM_S_NO_ERROR;
	CDeviceCollection   devCollection;
	CConfigManager      configMngr;
	REFPTR_POSITION     pos;

	if (!configMngr.GetDeviceListFilterByClass(devCollection, L"Media"))
	{
		return hResult;
	}

	devCollection.BeginEnum(pos);

	if (!devCollection.GetSize())
	{
		return hResult;
	}

	// smart ptr
	CConfigMgrDevicePtr pDevice;

	// Go through all the Media devices.
	for (	pDevice.Attach(devCollection.GetNext(pos));
			SUCCEEDED(hResult) && (NULL != pDevice);
			pDevice.Attach(devCollection.GetNext(pos)))
	{
		CHString    strDriverKey,
					strFullKey,
					strDeviceID;
		CRegistry   reg;

		// Find out if this device is a WAV device.
		pDevice->GetDriver(strDriverKey);

		strFullKey.Format(
			L"System\\CurrentControlSet\\Control\\Class\\%s\\Drivers\\Wave",
			(LPCWSTR) strDriverKey);

		if (reg.Open(HKEY_LOCAL_MACHINE, strFullKey, KEY_READ) == ERROR_SUCCESS)
		{
			// smart ptr
			CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

			if (NULL != pInst)
			{
				pDevice->GetDeviceID(strDeviceID);

				pInst->SetCHString(L"DeviceID", strDeviceID);

				if (SUCCEEDED(hResult = LoadPropertiesNT5(WinmmApi , pInst)))
				{
					hResult = pInst->Commit();
				}
			}
			else
				hResult = WBEM_E_FAILED;
		}
	}

	return hResult;
}
#endif

#ifdef WIN9XONLY
HRESULT CWin32SndDevice::LoadProperties95(CInstance *pInst, CHString &strEnumKey)
{
	HRESULT				hResult = WBEM_S_NO_ERROR;
	CHString			strDeviceID;
	CRegistry			Registry;
	CHString			strActive;
	CHString			strCaption;
	CHString			strDescription;
	CConfigManager		configMngr;

	pInst->GetCHString(L"DeviceID", strDeviceID);

	// open registry to strEnumKey
	if (ERROR_SUCCESS == Registry.Open(HKEY_LOCAL_MACHINE, strEnumKey, KEY_READ))
	{
		// Availability
		if (Registry.GetCurrentKeyValue(L"Active", strActive) == ERROR_SUCCESS)
		{
			if (0 == strActive.CompareNoCase(L"1"))
			{
				pInst->SetDWORD(L"Availability", 3);	// active
			}
			else
			{
				pInst->SetDWORD(L"Availability", 9);	// off duty
			}
		}

		// caption, name, productname
		if (Registry.GetCurrentKeyValue(L"Description", strCaption) == ERROR_SUCCESS)
		{
			pInst->SetCHString(L"Caption", strCaption);
			pInst->SetCHString(L"Name", strCaption);
			pInst->SetCHString(L"ProductName", strCaption);
		}

		// description
		if (ERROR_SUCCESS == Registry.GetCurrentKeyValue(L"FriendlyName", strDescription))
		{
			pInst->SetCHString(L"Description", strDescription);
		}
		else
		{
			pInst->SetCHString(L"Description", strCaption);
		}

		// smart ptr
		CConfigMgrDevicePtr pDevice;

		configMngr.LocateDevice(strDeviceID, &pDevice);

        // It's OK if the above call fails since SetCommonCfgMgrProperties
        // will still set some properties for us.
	    SetCommonCfgMgrProperties(pDevice, pInst);
	}

	return hResult;
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::LoadPropertiesNT4(CWinmmApi &WinmmApi , CInstance *pInst)
{
	// LoadPropertiesNT5 was designed to work for both.
	return LoadPropertiesNT5(WinmmApi , pInst);
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::LoadPropertiesNT5(CWinmmApi &WinmmApi , CInstance *pInst)
{
	CHString			strDeviceID,
						strDesc;
	CConfigManager		configMngr;

	pInst->GetCHString(L"DeviceID", strDeviceID);

	if (strDeviceID.IsEmpty())
	{
		return WBEM_E_NOT_FOUND;
	}

	// smart ptr
	CConfigMgrDevicePtr pDevice;

	if (configMngr.LocateDevice(strDeviceID, &pDevice))
	{
		pDevice->GetDeviceDesc(strDesc);
	}
	else
	{
		// If we can't find it in the device manager, maybe we just got it
		// from the wave APIs.
		WAVEOUTCAPS caps;
		int			iWhich = _wtoi(strDeviceID);

		// Make sure this string only has numbers.
		for (int i = 0; i < strDeviceID.GetLength(); i++)
		{
			if (!_istdigit(strDeviceID[ i ]))
			{
				return WBEM_E_NOT_FOUND;
			}
		}

		if (WinmmApi.WinmmwaveOutGetDevCaps(iWhich, &caps, sizeof(caps)) != MMSYSERR_NOERROR)
		{
			return WBEM_E_NOT_FOUND;
		}
		strDesc = caps.szPname;
	}

    // We want to make this call even if pDevice is NULL.
    SetCommonCfgMgrProperties(pDevice, pInst);

	// Now we have a valid name, so put it in the instance.
	pInst->SetCHString(L"Caption", strDesc);
	pInst->SetCHString(L"Name", strDesc);
	pInst->SetCHString(L"ProductName", strDesc);
	pInst->SetCHString(L"Description", strDesc);

	return WBEM_S_NO_ERROR;
}
#endif

void CWin32SndDevice::SetCommonCfgMgrProperties(
    CConfigMgrDevice *pDevice,
    CInstance *pInstance)
{
    // 2 means we don't know if the device is enabled or not.
    DWORD       dwStatusInfo = 2;
    CHString    strInfo = L"Unknown";

    if (pDevice)
    {
        CHString strTemp;

        SetConfigMgrProperties(pDevice, pInstance);

	    if (pDevice->GetStatus(strInfo))
	    {
	        if (strInfo == L"OK")
		    {
                // Means the device is enabled.
                dwStatusInfo = 3;
            }
	    }

        if (pDevice->GetMfg(strTemp))
            pInstance->SetCharSplat(L"Manufacturer", strTemp);
    }

    pInstance->SetCHString(L"Status", strInfo);


    // Other common properties

    pInstance->SetDWORD(L"StatusInfo", dwStatusInfo);

	// CreationClassName
	SetCreationClassName(pInstance);

	// PowerManagementSupported
	pInstance->Setbool(IDS_PowerManagementSupported, FALSE);

	// SystemCreationClassName
	pInstance->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");

	// SystemName
	pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\smbiosprov.h ===
//=================================================================

//

// SmbiosProv.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

// Property set identification
//============================
#define PROPSET_NAME_SYSTEMPRODUCT		L"Win32_ComputerSystemProduct"
#define PROPSET_NAME_BASEBOARD			L"Win32_BaseBoard"
#define PROPSET_NAME_SYSTEMENCLOSURE	L"Win32_SystemEnclosure"
#define	PROPSET_NAME_CACHEMEMORY		L"Win32_CacheMemory" 
#define	PROPSET_NAME_PORTCONNECTOR		L"Win32_PortConnector" 
#define	PROPSET_NAME_SYSTEMSLOT			L"Win32_SystemSlot" 
//#define	PROPSET_NAME_BIOSLANG			L"Win32_BiosLanguage" 
#define PROPSET_NAME_PHYSMEMARRAY		L"Win32_PhysicalMemoryArray"
#define PROPSET_NAME_PHYSICALMEMORY		L"Win32_PhysicalMemory"
#define PROPSET_NAME_MEMERROR32			L"Win32_MemoryError32"
#define PROPSET_NAME_PORTABLEBATTERY	L"Win32_PortableBattery"
#define PROPSET_NAME_CURRENTPROBE		L"Win32_CurrentProbe"
#define PROPSET_NAME_TEMPPROBE			L"Win32_TemperatureProbe"
#define PROPSET_NAME_VOLTPROBE			L"Win32_VoltageProbe"
#define PROPSET_NAME_FAN				L"Win32_Fan"
#define PROPSET_NAME_HEATPIPE			L"Win32_HeatPipe"
#define PROPSET_NAME_REFRIG				L"Win32_Refrigeration"
#define PROPSET_NAME_MEMORYDEVICE		L"Win32_MemoryDevice"
#define PROPSET_NAME_MEMORYARRAY		L"Win32_MemoryArray"
#define PROPSET_NAME_ONBOARDDEVICE		L"Win32_OnBoardDevice"
#define PROPSET_NAME_OEMBUCKET			L"Win32_OEMBucket"



class CWin32SystemProduct : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32SystemProduct( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32SystemProduct( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PSYSTEMINFO psi );

};

class CWin32BaseBoard : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32BaseBoard( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32BaseBoard( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PBOARDINFO pbi );

};

class CWin32SystemEnclosure : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32SystemEnclosure( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32SystemEnclosure( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PENCLOSURE pe );
};



class CWin32CacheMemory : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32CacheMemory( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32CacheMemory( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PCACHEINFO pci );
        //HRESULT LoadPropertyValues( CInstance* pInstance ) ;

};

class CWin32SystemSlot : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32SystemSlot( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32SystemSlot() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PSYSTEMSLOTS pss );
        //HRESULT LoadPropertyValues( CInstance* pInstance ) ;
};

class CWin32OnBoardDevice : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32OnBoardDevice( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32OnBoardDevice( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PSHF pshf, UINT instanceNum );
};


class CWin32PortConnector : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PortConnector( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32PortConnector( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PPORTCONNECTORINFO ppci );
};

//class CWin32BIOSLanguage : public Provider
//{
//
//    public:
//
//        // Constructor/destructor
//        //=======================
//
//        CWin32BIOSLanguage( LPCWSTR strName, LPCWSTR pszNamespace );
//       ~CWin32BIOSLanguage( );
//
//        // Functions provide properties with current values
//        //=================================================
//
//        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
//        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
//
//        // Utility
//        //========
//
//        DWORD			m_dwPlatformId;
//
//        // Utility function(s)
//        //====================
//
//		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PBIOSLANGINFO pbli );
//};


class CWin32PhysicalMemory : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PhysicalMemory( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32PhysicalMemory( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		//HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PMEMDEVICE pmd );
		HRESULT LoadPropertyValues_MD( CInstance* pInstance, CSMBios &smbios, PMEMDEVICE pmd );
		HRESULT LoadPropertyValues_MI( CInstance* pInstance, CSMBios &smbios, PMEMMODULEINFO pmmi );
};


class CWin32PhysMemoryArray : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PhysMemoryArray( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32PhysMemoryArray( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility
        //========

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues_PMA( CInstance* pInstance, CSMBios &smbios, PPHYSMEMARRAY ppma );
		HRESULT LoadPropertyValues_MCI( CInstance* pInstance, CSMBios &smbios, PMEMCONTROLINFO pmci );
};

class CWin32PortableBattery : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PortableBattery( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32PortableBattery( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility
        //========

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PPORTABLEBATTERY ppb );
};

class CCimNumericSensor : public Provider
{

    public:

        // Constructor/destructor
        //=======================

		CCimNumericSensor( LPCWSTR strName, LPCWSTR pszNamespace, UINT StructType, LPCWSTR strTag );
        //CCimSensor( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CCimNumericSensor( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:		

        // Utility function(s)
        //====================
		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PPROBEINFO ppi );

		UINT	m_StructType;
		CHString m_TagName;
	
};


class CWin32MemoryArray : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryArray( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32MemoryArray( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PMEMARRAYMAPADDR pmama );
};

class CWin32MemoryDevice : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryDevice( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32MemoryDevice( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PMEMDEVICEMAPADDR pmdma );
};

class CCimCoolingDevice : public Provider
{

    public:

        // Constructor/destructor
        //=======================

		CCimCoolingDevice( LPCWSTR strName, LPCWSTR pszNamespace, UINT StructType, LPCWSTR strTag );
       ~CCimCoolingDevice( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:		

        // Utility function(s)
        //====================
		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PCOOLINGDEVICE pcd );

		UINT	m_StructType;
		CHString m_TagName;
	
};


class CWin32OEMBucket : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32OEMBucket( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32OEMBucket( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\snddevice.h ===
//=================================================================

//

// SndDevice.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __SNDDEVICE_H_
#define __SNDDEVICE_H_

#define PROPSET_NAME_SOUNDDEVICE	L"Win32_SoundDevice"

class CWin32SndDevice : public Provider
{
public:

	// constructor/destructor
	CWin32SndDevice ( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
	virtual ~CWin32SndDevice () ;

    //=================================================
    // Functions provide properties with current values
    //=================================================
	virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;

#ifdef WIN9XONLY
	virtual HRESULT GetObject95( CInstance *a_pInst, long a_lFlags = 0L ) ;
	virtual HRESULT EnumerateInstances95( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
	virtual HRESULT LoadProperties95( CInstance *a_pInst, CHString &a_chsEnumKey ) ;
#endif

#ifdef NTONLY
	virtual HRESULT GetObjectNT4( CInstance *a_pInst, long a_lFlags = 0L ) ;
	virtual HRESULT GetObjectNT5( CInstance *a_pInst, long a_lFlags = 0L ) ;
	virtual HRESULT EnumerateInstancesNT4( CWinmmApi &a_WinmmApi , MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
	virtual HRESULT EnumerateInstancesNT5( CWinmmApi &a_WinmmApi , MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
	virtual HRESULT LoadPropertiesNT4( CWinmmApi &a_WinmmApi , CInstance *a_pInst ) ;
	virtual HRESULT LoadPropertiesNT5( CWinmmApi &a_WinmmApi , CInstance *a_pInst ) ;
#endif

	virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;

    void SetCommonCfgMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance);

};	// end class CWin32SndDevice

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include ..\..\..\..\common\makefile.cmn
SOURCES_USED=..\..\..\..\common\makefile.cmn

TARGETNAME=cimwin32

TARGETPATH=obj
TARGETTYPE=DYNLINK

INCLUDES=$(INCLUDES); \
	$(COMMON_NEWTHROW_INC); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(CIMWIN32_LIB_INC); \
	$(WMIIDL_INC); \
	$(CRT_INC_PATH); \
	$(FRAMEDYN_PRIVATE); \
	$(NET_INC_PATH); \
	$(BASE_INC_PATH); \
        $(MDHELPPROX_INC_PATH); \

# PRESOURCES must have precomp.h as the first #include in the file.
# There cannot be any #defines before the #include.
PRESOURCES=$(PRESOURCES) \
	..\1394.cpp \
	..\AutochkSetting.cpp \
	..\Battery.cpp \
	..\bios.cpp \
	..\BootConfig.cpp \
	..\bservice.cpp \
	..\bus.cpp \
	..\cadapters.cpp \
	..\CIMDataFile.cpp \
	..\CIMLogicalDevice_CIMDataFile.cpp \
	..\cNetConn.cpp \
	..\CodecFile.cpp \
	..\COMObjSecRegKey.cpp \
	..\ComputerSystem.cpp \
	..\cpuid.cpp \
        ..\DelayLoadHandler.cpp \
	..\dependentservice.cpp \
	..\desktop.cpp \
	..\DesktopMonitor.cpp \
	..\devbattery.cpp \
	..\devbus.cpp \
	..\DeviceMemory.cpp \
	..\devid.cpp \
	..\DhcpcsvcApi.cpp \
	..\dhcpinfo.cpp \
	..\Directory.cpp \
	..\DirectoryContainsFile.cpp \
	..\diskdrive.cpp \
	..\displaycfg.cpp \
	..\displayctrlcfg.cpp \
	..\DriverForDevice.cpp \
	..\elementsetting.cpp \
	..\Environment.cpp \
	..\FileFile.cpp \
	..\Floppy.cpp \
	..\FloppyController.cpp \
	..\group.cpp \
	..\GroupUser.cpp \
	..\IDE.cpp \
	..\IRQ.cpp \
	..\Implement_LogicalFile.cpp \
	..\InfraRed.cpp \
	..\Keyboard.cpp \
	..\loaddepends.cpp \
	..\loadmember.cpp \
	..\loadorder.cpp \
	..\logdiskpartition.cpp \
	..\LogicalDisk.cpp \
	..\LogicalMemory.cpp \
	..\LogicalProgramGroup.cpp \
	..\LogicalProgramGroupItem.cpp \
	..\LogicalShareAccess.cpp \
	..\LogicalShareAudit.cpp \
	..\loginprofile.cpp \
	..\motherboard.cpp \
	..\MSINFO_cdrom.cpp \
	..\multimonitor.cpp \
	..\netadapter.cpp \
	..\netadaptercfg.cpp \
	..\netclient.cpp \
	..\netcom.cpp \
	..\NetConn.cpp \
	..\ntlastboottime.cpp \
	..\os.cpp \
	..\PageFile.cpp \
	..\PageFileSetting.cpp \
	..\Parallelport.cpp \
	..\pcmcia.cpp \
	..\pointer.cpp \
	..\port.cpp \
	..\Power.cpp \
	..\PowerManagement.cpp \
	..\Printer.cpp \
	..\Printerdriver2.cpp \
	..\Printerport.cpp \
	..\PrnUtil.cpp \
	..\PrnInterface.cpp \
	..\printercfg.cpp \
	..\printercontroller.cpp \
	..\printerdriver.cpp \
	..\printershare.cpp \
	..\printjob.cpp \
	..\processor.cpp \
	..\programgroup.cpp \
	..\protocolbinding.cpp \
	..\Qfe.cpp \
	..\recovery.cpp \
	..\schedjob.cpp \
	..\serialportcfg.cpp \
	..\service.cpp \
	..\share.cpp \
	..\ShareToDir.cpp \
	..\ShortcutFile.cpp \
	..\ShortcutHelper.cpp \
	..\SmbAssoc.cpp \
	..\SmbiosProv.cpp \
	..\smbstruc.cpp \
	..\SmbToCim.cpp \
	..\snddevice.cpp \
	..\startupcommand.cpp \
	..\systemaccount.cpp \
	..\systemdriver.cpp \
	..\SystemName.cpp \
	..\threadprov.cpp \
	..\timezone.cpp \
	..\usb.cpp \
	..\user.cpp \
	..\videocontroller.cpp \
	..\videocontrollerresolution.cpp \
	..\videosettings.cpp \
	..\VXD.cpp \
	..\wavedevcfg.cpp \
	..\WbemNTthread.cpp \
	..\WBEMToolH.cpp \
	..\WDMBase.cpp \
	..\Win32_1394ControllerDevice.cpp \
	..\Win32_ClassicCOMApplicationClasses.cpp \
	..\Win32_ClassicCOMClass.cpp \
	..\Win32_ClassicCOMClassSetting.cpp \
	..\Win32_ClassicCOMClassSettings.cpp \
	..\Win32_ClientApplicationSetting.cpp \
	..\Win32_COMApplicationSettings.cpp \
	..\Win32_COMClassAutoEmulator.cpp \
	..\Win32_COMClassEmulator.cpp \
	..\Win32_ComponentCategory.cpp \
	..\Win32_DCOMApplication.cpp \
	..\Win32_DCOMApplicationAccessAllowedSetting.cpp \
	..\Win32_DCOMApplicationLaunchAllowedSetting.cpp \
	..\Win32_DCOMApplicationSetting.cpp \
	..\Win32_ImplementedCategory.cpp \
	..\Win32IDEControllerDevice.cpp \
	..\Win32LogicalDiskRootWin32Directory.cpp \
	..\win32logicalsharesecuritysetting.cpp \
	..\Win32ProgramGroupContents.cpp \
	..\Win32ProgramGroupItemDataFile.cpp \
	..\Win32ProgramGroupWin32Directory.cpp \
	..\Win32SCSIControllerDevice.cpp \
	..\Win32SecuritySettingofLogicalShare.cpp \
	..\Win32SubDirectory.cpp \
	..\WIN32SystemDriverPNPEntity.cpp \
	..\Win32SystemUsers.cpp \
	..\Win32USBControllerDevice.cpp \
	..\modem.cpp \
	..\protocol.cpp \
        ..\SystemConfigChange.cpp    \
	..\DMA.cpp \
	..\PNPEntity.cpp \
	..\devres.cpp \
	..\usebinding.cpp \
	..\useassoc.cpp \
	..\win32allocatedresource.cpp \


#	..\DllWrapperBase.cpp \
#	..\WinMsgEvent.cpp \
#	..\ntdevtosvcsearch.cpp \
#	..\nt4svctoresmap.cpp \
#	..\usbhub.cpp \
#	..\iodesc.cpp \
#	..\irqdesc.cpp \
#	..\devdesc.cpp \
#	..\chwres.cpp \
#	..\FactoryRouter.cpp \
#	..\Cim32NetApi.cpp \
#	..\configmgrapi.cpp \
#	..\resourcedesc.cpp \
#	..\strings.cpp \
#	..\DllUtils.cpp \
#	..\cfgmgrdevice.cpp \
#	..\refptrlite.cpp \
#   	..\DmaDesc.cpp \
#	..\DllWrapperBase.cpp \
#	..\EventProvider.cpp \
#	..\Ntdomain.cpp \
#       ..\VolumeChange.cpp \
#	..\ShutdownEvent.cpp \
#	..\wbemnetapi32.cpp \
#	..\NetApi32Api.cpp \
#	..\SvrApiApi.cpp \
#	..\AdvApi32Api.cpp \
#	..\ImpersonateConnectedUser.cpp \
#	..\implogonuser.cpp \
#	..\perfdata.cpp \
#	..\secureshare.cpp \
#	..\securityApi.cpp \
#	..\userhive.cpp \
#       ..\UserEnvApi.cpp \
#	..\wbempsapi.cpp \
#	..\WmiApi.cpp \
#	..\Ws2_32Api.cpp \
#	..\Wsock32Api.cpp \
#	..\sid.cpp \



# NTSOURCES must have exactly the following items
# before #include "precomp.h"
#
# #include <nt.h>
# #include <ntrtl.h>
# #include <nturtl.h>
# #include <ntobapi.h>
#
# #define _WINNT_	// have what is needed from above

NTSOURCES=$(NTSOURCES) \
	..\KUserdata.cpp \
	..\nvram.cpp \
	..\ntdriverio.cpp \
	..\PageFileUsage.cpp \
	..\regcfg.cpp \
	..\CProcess.cpp \
	..\ProcessDLL.cpp \
	..\TapiApi.cpp \
	..\diskpartition.cpp \
	..\file.cpp	\
        ..\logonsession.cpp \
	..\win32loggedonuser.cpp \
	..\win32sessionprocess.cpp \
        ..\Win32MappedLogicalDisk.cpp \


#	..\NtDllApi.cpp \
#	..\WinmmApi.cpp \
#	..\WinSpoolApi.cpp \

# MISCSOURCES are the files that don't fit in either NTSOURCES or PRESOURCES
MISCSOURCES=$(MISCSOURCES) \
	..\cimwin32.rc \
	..\MainDLL.cpp \


#       ..\InitResource.cpp \
#	..\ResourceManager.cpp \
#	..\TimerQueue.cpp \
#	..\TimeOutRule.cpp \
#	..\confgmgr.cpp \
#	..\TimedDllResource.cpp

TARGETLIBS= \
	$(COMMON_NEWTHROW_LIB) \
!ifdef USE_FRAMEDYD
	$(SDK_LIB_PATH)\framedyd.lib \
!else
	$(SDK_LIB_PATH)\framedyn.lib \
!endif
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(CIMWIN32_LIB)	\
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\winspool.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\version.lib \
        $(SDK_LIB_PATH)\mpr.lib \
        $(SDK_LIB_PATH)\traffic.lib \
        $(SDK_LIB_PATH)\setupapi.lib \
        $(SDK_LIB_PATH)\iphlpapi.lib \


C_DEFINES=$(C_DEFINES) /D_WINDLL /D_WIN32_DCOM
USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1
DLLENTRY=_DllMainCRTStartup

DELAYLOAD=mpr.DLL;version.DLL;winspool.drv;traffic.dll;iphlpapi.dll
DLOAD_ERROR_HANDLER=DliHook

!ifdef USE_FRAMEDYD
DEBUG_CRTS=1
!endif

DLLDEF=$(O)\cimwin32.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\startupcommand.cpp ===
//=================================================================

//

// StartupCommand.CPP -- CodecFile property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//				 03/03/99    a-peterc		Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include <shlguid.h>
#include <shlobj.h>
#include <ProvExce.h>
#include "StartupCommand.h"
#include "userhive.h"

#include <profilestringimpl.h>

// Property set declaration
//=========================

CWin32StartupCommand startupCommand(
	L"Win32_StartupCommand",
	IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32StartupCommand::CWin32StartupCommand
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32StartupCommand::CWin32StartupCommand(
	LPCWSTR a_szName,
	LPCWSTR a_szNamespace) : Provider( a_szName, a_szNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32StartupCommand::~CWin32StartupCommand
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32StartupCommand::~CWin32StartupCommand()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32StartupCommand::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32StartupCommand::EnumerateInstances(
	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/)
{
	return EnumStartupOptions( a_pMethodContext, NULL ) ;
}

class CIconInfo
{
public:
	TCHAR	szPath[ MAX_PATH * 2 ] ;
	TCHAR	szTarget[ MAX_PATH * 2 ] ;
	TCHAR	szArgs[ MAX_PATH * 2 ] ;
	HRESULT	hResult;
};

DWORD GetIconInfoProc( CIconInfo *a_pInfo )
{
	HRESULT t_hResult;
	IShellLink	    *t_psl = NULL ;
	IPersistFile    *t_ppf = NULL ;

	try
	{
		// We have to use COINIT_APARTMENTTHREADED.
		if (SUCCEEDED( t_hResult = CoInitialize( NULL ) ) )
		{
			// Get a pointer to the IShellLink interface.
			if ( SUCCEEDED( t_hResult = CoCreateInstance(
															CLSID_ShellLink,
															NULL,
															CLSCTX_INPROC_SERVER,
															IID_IShellLink,
															(VOID **) &t_psl ) ) )
			{
				// Get a pointer to the IPersistFile interface.
				if ( SUCCEEDED( t_hResult = t_psl->QueryInterface(
					IID_IPersistFile,
					(VOID **) &t_ppf ) ) )
				{
					_bstr_t t_bstr = a_pInfo->szPath ;

					if ( SUCCEEDED( t_hResult = t_ppf->Load( t_bstr, STGM_READ ) ) )
					{
						WIN32_FIND_DATA t_fd ;

						t_hResult = t_psl->GetPath(
													a_pInfo->szTarget,
													sizeof( a_pInfo->szTarget ),
													&t_fd,
													SLGP_SHORTPATH ) ;

						t_hResult = t_psl->GetArguments( a_pInfo->szArgs, sizeof( a_pInfo->szArgs) ) ;
					}
				}
			}
		}

		a_pInfo->hResult = t_hResult ;

	}
	catch( ... )
	{
		if ( t_psl )
		{
			t_psl->Release( ) ;
		}
		if ( t_ppf )
		{
			t_ppf->Release( ) ;
		}
		CoUninitialize( ) ;

		throw ;
	}

	if ( t_psl )
	{
		t_psl->Release( ) ;
		t_psl = NULL ;
	}

	if ( t_ppf )
	{
		t_ppf->Release( ) ;
		t_ppf = NULL ;
	}

	CoUninitialize( ) ;

	return 0;
}

// This uses a thread because we need to be in apartment model to use the
// shortcut interfaces.
HRESULT GetIconInfo( CIconInfo &a_info )
{
	DWORD	t_dwID;
	SmartCloseHandle	t_hThread;

	if ( t_hThread = CreateThread (
									NULL,
									0,
									(LPTHREAD_START_ROUTINE) GetIconInfoProc,
									&a_info,
									0,
									&t_dwID ) )
	{

		a_info.hResult = WBEM_S_NO_ERROR ;

		WaitForSingleObject( t_hThread, INFINITE ) ;
	}
	else
	{
		a_info.hResult = WBEM_E_FAILED ;
	}

	return a_info.hResult;
}

HRESULT CWin32StartupCommand::EnumStartupFolderItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor,
	LPCWSTR			a_szKeyName,
	LPCWSTR			a_szUserName )
{
	HKEY		t_hkey ;
	CHString	t_strKey,
				t_strValueName,
				t_strFolder,
				t_strWhere,
                t_strLookingForPath ;
	CRegistry	t_reg ;
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	DWORD		t_dwRet;
	HANDLE		t_hFind			= NULL ;

		// If szUserName == NULL, we're looking at the common keys group.

		// Setup stuff if we're doing a GetObject.
		if ( a_pinstLookingFor )
		{
			GetLocalInstancePath( a_pinstLookingFor, t_strLookingForPath ) ;

			// Until we prove otherwise, we haven't found one.
			t_hResult = WBEM_E_NOT_FOUND ;
		}

		// Setup the registry vars depending on whether we're looking for
		// Common Startup or User Startup items.
		if ( !a_szUserName )
		{
			t_hkey = HKEY_LOCAL_MACHINE ;

			t_strKey =
				_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\")
				_T("Explorer\\Shell Folders" ) ;

			t_strValueName = _T("Common Startup") ;
		}
		else
		{
			t_hkey = HKEY_USERS ;

			t_strKey = a_szKeyName ;
			t_strKey +=
				_T("\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\")
				_T("Explorer\\Shell Folders") ;

			t_strValueName = _T("Startup") ;
		}

		if ( ( t_dwRet = t_reg.Open( t_hkey, t_strKey, KEY_READ ) ) != ERROR_SUCCESS ||
			 ( t_dwRet = t_reg.GetCurrentKeyValue( t_strValueName, t_strFolder ) ) !=
				ERROR_SUCCESS )
		{
			t_hResult = WinErrorToWBEMhResult( t_dwRet ) ;
		}
		else
		{
			// We opened the key.  Now try to enum the folder contents.
			TCHAR		t_szFolderSpec[ MAX_PATH * 2 ],
						t_szNameOnly[ MAX_PATH * 2 ];
			HRESULT		t_hresInternal = WBEM_S_NO_ERROR ;

			// Add '*.*' to the end of the directory.  Use _tmakepath
			// so we don't have to look for '\\' on the end.
			_tmakepath( t_szFolderSpec, NULL, TOBSTRT( t_strFolder ), _T("*.*"), NULL ) ;

			WIN32_FIND_DATA	t_fd;

			t_hFind = FindFirstFile( t_szFolderSpec, &t_fd ) ;

			BOOL t_bDone = t_hFind == INVALID_HANDLE_VALUE ;

			while ( !t_bDone )
			{
				BOOL bNewInstance = FALSE;
				// Directories can't be startup items.
				if ( ( t_fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
				{
					CIconInfo t_info;
					CInstancePtr t_pWorkingInst;

					// establish the working instance
					if ( !a_pinstLookingFor )
					{
						t_pWorkingInst.Attach ( CreateNewInstance( a_pMethodContext ) );
						bNewInstance = TRUE;
					}
					else
					{
						t_pWorkingInst = a_pinstLookingFor ;
					}

					// Split off the extension from the name so it looks better.
					_tsplitpath( t_fd.cFileName, NULL, NULL, t_szNameOnly, NULL ) ;

					t_pWorkingInst->SetCharSplat( L"Name", t_szNameOnly ) ;
					t_pWorkingInst->SetCharSplat( L"Description", t_szNameOnly ) ;
					t_pWorkingInst->SetCharSplat( L"Caption", t_szNameOnly ) ;
					t_pWorkingInst->SetCharSplat( L"Location", t_strValueName ) ;
					
                    if(a_szUserName)
                    {
                        t_pWorkingInst->SetCharSplat( L"User", a_szUserName ) ;
                    }
                    else
                    {
                        CHString chstrAllUsersName;
                        if(GetAllUsersName(chstrAllUsersName))
                        {
                            t_pWorkingInst->SetCharSplat( L"User", chstrAllUsersName ) ;
                        }
                        else
                        {
                            t_pWorkingInst->SetCharSplat( L"User", L"All Users" ) ;
                        }
                    }

					_tmakepath( t_info.szPath, NULL, TOBSTRT( t_strFolder ), t_fd.cFileName, NULL ) ;

					if ( SUCCEEDED( GetIconInfo( t_info ) ) )
					{
						TCHAR t_szCommand[ MAX_PATH * 4 ] ;

						wsprintf( t_szCommand, _T("%s %s"), t_info.szTarget, t_info.szArgs ) ;
						t_pWorkingInst->SetCharSplat( L"Command", t_szCommand ) ;
					}
					else
						t_pWorkingInst->SetCharSplat( L"Command", t_fd.cFileName ) ;

					if ( bNewInstance )
					{
						t_hResult = t_pWorkingInst->Commit() ;

						if (FAILED(t_hResult))
						{
							break;
						}
					}
					else
					{
						CHString t_strPathAfter ;

						GetLocalInstancePath( t_pWorkingInst, t_strPathAfter ) ;

						// If we found the one we're looking for, get out.
						if (!_wcsicmp( t_strPathAfter, t_strLookingForPath ) )
						{
							t_hResult = WBEM_S_NO_ERROR ;
							break ;
						}
					}
				}

				t_bDone = !FindNextFile( t_hFind, &t_fd ) ;
			}

			// We're done with the find now.
			FindClose( t_hFind ) ;
			t_hFind = NULL ;
		}

		return t_hResult;
}

HRESULT CWin32StartupCommand::EnumRunKeyItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor,
	LPCWSTR			a_szKeyName,
	LPCWSTR			a_szUserName )
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	LPCWSTR     t_szKeys[] =
				{
					L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
					L"Software\\Microsoft\\Windows\\CurrentVersion\\RunServices",
				} ;
	HKEY		t_hkey;
	int         t_nRunKeys;
	BOOL        t_bDone = FALSE;
	CHString	t_strKey,
				t_strWherePrefix,
				t_strWhere,
				t_strLookingForPath,
				t_strUser = a_szUserName ? a_szUserName : L"All Users" ;
	CRegistry	t_reg ;

	WCHAR		*t_szValueName	= NULL ;
	BYTE		*t_szValue		= NULL ;

	// If szUserName == NULL, we're looking at the common keys group.

	// Setup stuff if we're doing a GetObject.
	if ( a_pinstLookingFor )
	{
		GetLocalInstancePath( a_pinstLookingFor, t_strLookingForPath ) ;

		// Until we prove otherwise, we haven't found one.
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	// Setup the registry vars depending on whether we're looking for
	// Common Startup or User Startup items.
	if ( !a_szUserName )
	{
		t_hkey = HKEY_LOCAL_MACHINE ;
		t_strWherePrefix = _T("HKLM\\") ;
	}
	else
	{
		t_hkey = HKEY_USERS ;
		t_strWherePrefix = _T("HKU\\") ;
	}

	// If we're 9x and doing All Users, look at both the main key
	// and the services key.
#ifdef WIN9XONLY
	if ( !a_szUserName )
	{
		t_nRunKeys = 2;
	}
	else
#endif
	{
		t_nRunKeys = 1;
	}

	for ( int t_i = 0; t_i < t_nRunKeys && !t_bDone; t_i++ )
	{
		CRegistry   t_reg;
		DWORD       t_dwRet;
		CHString	t_strKey;

		if ( a_szKeyName )
		{
			t_strKey.Format( L"%s\\%s", a_szKeyName, t_szKeys[ t_i ] ) ;
		}
		else
		{
			t_strKey = t_szKeys[ t_i ] ;
		}

		if ( ( t_dwRet = t_reg.Open( t_hkey, t_strKey, KEY_READ ) ) != ERROR_SUCCESS )
		{
			t_hResult = WinErrorToWBEMhResult( t_dwRet ) ;
			break ;
		}

		// Make the where string.
		t_strWhere = t_strWherePrefix + t_strKey ;

		DWORD	t_nKeys = t_reg.GetValueCount( ),
				t_dwKey;

		for ( t_dwKey = 0; t_dwKey < t_nKeys; t_dwKey++ )
		{
			BOOL bNewInstance = FALSE;
			if ( t_reg.EnumerateAndGetValues( t_dwKey, t_szValueName, t_szValue ) !=
				ERROR_SUCCESS )
			{
				continue ;
			}

			CInstancePtr t_pWorkingInst;

			// establish the working instance
			if ( !a_pinstLookingFor )
			{
				t_pWorkingInst.Attach (  CreateNewInstance( a_pMethodContext ) );
				bNewInstance = TRUE;
			}
			else
			{
				t_pWorkingInst = a_pinstLookingFor ;
			}

			t_pWorkingInst->SetCharSplat( L"Name", t_szValueName ) ;
			t_pWorkingInst->SetCharSplat( L"Description", t_szValueName ) ;
			t_pWorkingInst->SetCharSplat( L"Caption", t_szValueName ) ;
			t_pWorkingInst->SetCharSplat( L"Command", (LPCWSTR) t_szValue ) ;
			t_pWorkingInst->SetCharSplat( L"Location", t_strWhere ) ;
			t_pWorkingInst->SetCharSplat( L"User", t_strUser ) ;

			// Get rid of szValue and szValue.
			delete [] t_szValueName ;
			t_szValueName = NULL ;

			delete [] t_szValue ;
			t_szValue = NULL ;

			if ( bNewInstance )
			{
				t_hResult = t_pWorkingInst->Commit();
			
				if ( FAILED( t_hResult ) )
				{
					t_bDone = TRUE ;
					break ;
				}
			}
			else
			{
				CHString t_strPathAfter ;

				GetLocalInstancePath( t_pWorkingInst, t_strPathAfter ) ;

				// If we found the one we're looking for, get out.
				if ( !_wcsicmp( t_strPathAfter, t_strLookingForPath ) )
				{
					t_hResult = WBEM_S_NO_ERROR ;
					t_bDone = TRUE ;
					break ;
				}
			}
		}
	}

	return t_hResult;
}

HRESULT CWin32StartupCommand::EnumRunValueItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor,
	LPCWSTR			a_szKeyName,
	LPCWSTR			a_szUserName )
{
    LPCWSTR     t_szValueNames[] =
                {
                    L"Run",
                    L"Load",
				} ;
	DWORD       t_dwRet;
	CHString	t_strKey,
                t_strWherePrefix,
                t_strLookingForPath;
	CRegistry	t_reg;
	HRESULT		t_hResult = a_pinstLookingFor ? WBEM_E_NOT_FOUND : WBEM_S_NO_ERROR;

	// If szUserName == NULL, we're looking at the common keys group.

	// Win9x doesn't support these keys, and neither does HKLM, so get out now.
#ifdef NTONLY
	if ( !a_szUserName )
#endif
	{
		return t_hResult ;
	}

	// Setup stuff if we're doing a GetObject.
	if ( a_pinstLookingFor )
	{
        GetLocalInstancePath( a_pinstLookingFor, t_strLookingForPath ) ;
	}
	// Setup the registry vars depending on whether we're looking for
    // Common Startup or User Startup items.
	t_strWherePrefix = L"*HKU\\" ;

	t_strKey	= a_szKeyName;
	t_strKey	+= L"\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\Windows" ;

	if ( ( t_dwRet = t_reg.Open( HKEY_USERS, t_strKey, KEY_READ ) ) != ERROR_SUCCESS )
	{
		t_hResult = WinErrorToWBEMhResult( t_dwRet ) ;
	}
	else
	{
		// Make the where string.
		CHString t_strWhere = t_strWherePrefix + t_strKey;

		for ( int t_i = 0; t_i < sizeof( t_szValueNames ) / sizeof( t_szValueNames[ 0 ] ) ; t_i++ )
		{
			CHString t_strValue;

			if ( t_reg.GetCurrentKeyValue( t_szValueNames[ t_i ], t_strValue ) != ERROR_SUCCESS )
			{
				continue;
			}

			t_hResult =
				// Splits up a command-seperated value string, fills out instances,
				// etc.
				EnumCommandSeperatedValuesHelper(
					a_pMethodContext,
					a_pinstLookingFor,
                    t_strLookingForPath,
					t_szValueNames[ t_i ],
					t_strWhere,
					a_szUserName,
					t_strValue ) ;

			// If we found the one we're looking for, get out.
			if ( a_pinstLookingFor && t_hResult == WBEM_S_NO_ERROR )
			{
				break;
			}
		}
	}

	return t_hResult;
}

HRESULT	CWin32StartupCommand::EnumCommandSeperatedValuesHelper(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor,
    LPCWSTR         a_szLookingForPath,
	LPCWSTR			a_szValueName,
	LPCWSTR			a_szLocation,
	LPCWSTR			a_szUserName,
	LPCWSTR			a_szValue )
{
	HRESULT		t_hResult = a_pinstLookingFor ? WBEM_E_NOT_FOUND : WBEM_S_NO_ERROR ;
	LPWSTR		t_pszCurrent ;
	int			t_iItem = 0 ;

	LPWSTR		t_szTemp		= NULL ;
	
	t_szTemp = _wcsdup( a_szValue ) ;

	if ( !t_szTemp )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	for (	t_pszCurrent = wcstok( t_szTemp, L"," );
			t_pszCurrent;
			t_pszCurrent = wcstok( NULL, L"," ), t_iItem++ )
	{
		CHString	t_strName,
					t_strCommand = t_pszCurrent ;

		CInstancePtr t_pWorkingInst;
		BOOL bNewInstance = FALSE;

		// establish the working instance
		if ( !a_pinstLookingFor )
		{			
			t_pWorkingInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;
			bNewInstance = TRUE;
		}
		else
		{
			t_pWorkingInst = a_pinstLookingFor ;
		}


		t_strName.Format( L"%s[%d]", a_szValueName, t_iItem ) ;

		// Make sure we don't have leading spaces on the command.
		t_strCommand.TrimLeft( ) ;

		t_pWorkingInst->SetCharSplat( L"Name", t_strName ) ;
		t_pWorkingInst->SetCharSplat( L"Description", t_strName ) ;
		t_pWorkingInst->SetCharSplat( L"Caption", t_strName ) ;
		t_pWorkingInst->SetCharSplat( L"Command", t_strCommand ) ;
		t_pWorkingInst->SetCharSplat( L"Location", a_szLocation ) ;
		t_pWorkingInst->SetCharSplat( L"User", a_szUserName ) ;

		if ( bNewInstance )
		{
			t_hResult = t_pWorkingInst ->Commit();

			if ( FAILED( t_hResult ) )
			{
				break ;
			}
		}
		else
		{
			CHString t_strPathAfter;

			GetLocalInstancePath( t_pWorkingInst, t_strPathAfter ) ;

			// If we found the one we're looking for, get out.
			if (!_wcsicmp( t_strPathAfter, a_szLookingForPath ) )
			{
				t_hResult = WBEM_S_NO_ERROR ;
				break ;
			}
		}
	}

	// Get rid of our temporary string buffer.
	free( t_szTemp ) ;
	t_szTemp = NULL ;

	return t_hResult;
}

#ifdef WIN9XONLY
HRESULT CWin32StartupCommand::EnumIniValueItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor)
{
	// This type is only for Win9x and All Users
	return a_pinstLookingFor ? WBEM_E_NOT_FOUND : WBEM_S_NO_ERROR  ;
}
#endif


#ifdef NTONLY
HRESULT CWin32StartupCommand::EnumIniValueItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor)
{
	HRESULT		t_hResult = a_pinstLookingFor ? WBEM_E_NOT_FOUND : WBEM_S_NO_ERROR ;
    LPCTSTR     t_szValueNames[] =
                {
                    _T("Run"),
                    _T("Load"),
                };
    CHString    t_strLookingForPath;

	// Setup stuff if we're doing a GetObject.
	if ( a_pinstLookingFor )
	{
        GetLocalInstancePath( a_pinstLookingFor, t_strLookingForPath ) ;
	}

	for ( int t_i = 0; t_i < sizeof( t_szValueNames ) / sizeof( t_szValueNames [ 0 ] ) ; t_i++ )
	{
        TCHAR t_szValue[ MAX_PATH * 2 ] ;

		WMIRegistry_ProfileString(
									_T("Windows"),
									t_szValueNames[ t_i ],
									_T(""),
									t_szValue,
									sizeof( t_szValue ) / sizeof(TCHAR) ) ;

        t_hResult =
			// Splits up a command-seperated value string, fills out instances,
			// etc.
			EnumCommandSeperatedValuesHelper(
												a_pMethodContext,
												a_pinstLookingFor,
												t_strLookingForPath,
												t_szValueNames[ t_i ],
												_T("win.ini"),
												_T("All Users"),
												t_szValue ) ;

		// If we found the one we're looking for, get out.
		if ( a_pinstLookingFor && t_hResult == WBEM_S_NO_ERROR )
		{
			break ;
		}
	}
	return t_hResult ;
}
#endif

BOOL CWin32StartupCommand::UserNameToUserKey(
	LPCWSTR a_szUserName,
	CHString &a_strKeyName )
{
	BOOL t_bRet = TRUE ;

	if ( !_wcsicmp( a_szUserName, L".DEFAULT" ) )
	{
		a_strKeyName = a_szUserName ;
	}
	else if ( !_wcsicmp( a_szUserName, L"All Users" ) )
	{
		a_strKeyName = _T("") ;
	}
	else

#ifdef NTONLY
	{
		CUserHive t_hive;

		// If we couldn't open the hive, go to the next one.
		if ( t_hive.Load( a_szUserName, a_strKeyName.GetBuffer( MAX_PATH ) ) !=	ERROR_SUCCESS )
		{
			t_bRet = FALSE;
		}
        else
        {
            t_hive.Unload(a_strKeyName);
        }
		a_strKeyName.ReleaseBuffer( ) ;
	}
#endif

#ifdef WIN9XONLY
	{
		a_strKeyName = a_szUserName ;
	}
#endif

	return t_bRet;
}

BOOL CWin32StartupCommand::UserKeyToUserName(
	LPCWSTR a_szKeyName,
	CHString &a_strUserName )
{
	BOOL t_bRet = TRUE ;

	if ( !_wcsicmp( a_szKeyName, L".DEFAULT" ) )
	{
		a_strUserName = a_szKeyName ;
	}
	else

#ifdef NTONLY
	{
		CUserHive t_hive ;
		try
		{
			// If we couldn't open the hive, go to the next one.
			if ( t_hive.LoadProfile( a_szKeyName, a_strUserName ) != ERROR_SUCCESS  && 
                            a_strUserName.GetLength() > 0 )
			{
				t_bRet = FALSE ;
			}
			else
			{
				// We've got to do the unloading because the destructor doesn't.
				//t_hive.Unload( a_szKeyName ) ;
			}
		}
		catch( ... )
		{
			t_hive.Unload( a_szKeyName ) ;
			throw ;
		}

		t_hive.Unload( a_szKeyName ) ;
	}
#endif

#ifdef WIN9XONLY
	{
		a_strUserName = a_szKeyName ;
	}
#endif

	return t_bRet;
}

HRESULT CWin32StartupCommand::EnumStartupOptions(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor)
{
	CHStringList	t_list ;
	CRegistry		t_regHKCU ;
	HRESULT			t_hResult = WBEM_S_NO_ERROR ;

	// Get the list of user names for HKEY_CURRENT_USER.
	if ( FAILED( t_hResult = GetHKUserNames( t_list ) ) )
	{
		return t_hResult;
	}

	for ( CHStringList_Iterator t_i = t_list.begin( ) ; t_i != t_list.end( ) ; ++t_i )
	{
		CHString	&t_strKeyName = *t_i,
					t_strUserName;

		if ( !UserKeyToUserName( t_strKeyName, t_strUserName ) )
			continue;

		EnumStartupFolderItems(
						a_pMethodContext,
						a_pinstLookingFor,
						t_strKeyName,
						t_strUserName ) ;

		EnumRunKeyItems(
						a_pMethodContext,
						a_pinstLookingFor,
						t_strKeyName,
						t_strUserName ) ;

		EnumRunValueItems(
						a_pMethodContext,
						a_pinstLookingFor,
						t_strKeyName,
						t_strUserName ) ;


        // Ini items are only global, which is why we're not calling the .ini
        // enum function here.
	}

	// Now do all the global startup items.
	EnumStartupFolderItems(
						a_pMethodContext,
						a_pinstLookingFor,
						NULL,
						NULL ) ;
	EnumRunKeyItems(
						a_pMethodContext,
						a_pinstLookingFor,
						NULL,
						NULL ) ;
	// These never exist.
    //EnumRunValueItems(
	//					a_pMethodContext,
	//					a_pinstLookingFor,
	//					NULL,
	//					NULL ) ;
	EnumIniValueItems(
						a_pMethodContext,
						a_pinstLookingFor ) ;

	return t_hResult;
}

HRESULT CWin32StartupCommand::GetObject( CInstance *a_pInst, long a_lFlags )
{
	CHString	t_strWhere,
				t_strUserName,
				t_strKey ;
	HRESULT		t_hResult = WBEM_E_NOT_FOUND ;

    a_pInst->GetCHString( L"Location", t_strWhere ) ;
	a_pInst->GetCHString( L"User", t_strUserName ) ;

	if ( UserNameToUserKey( t_strUserName, t_strKey ) )
	{
		// Make sure this has been upcased so that we're case insenstive when
        // looking for "HKLM\\", etc.
        t_strWhere.MakeUpper();

        // Startup group
		if ( !_wcsicmp( t_strWhere, L"Startup" ) )
		{
			t_hResult =
				EnumStartupFolderItems(
										NULL,
										a_pInst,
										t_strKey,
										t_strUserName ) ;
		}
		// Common startup group
		else if ( !_wcsicmp( t_strWhere, L"Common Startup" ) )
		{
			t_hResult =
				EnumStartupFolderItems(
					NULL,
					a_pInst,
					NULL,
					NULL ) ;
		}
		// User run keys
		else if ( t_strWhere.Find( L"HKU\\" ) == 0 )
		{
			t_hResult =
				EnumRunKeyItems(
					NULL,
					a_pInst,
					t_strKey,
					t_strUserName ) ;
		}
		// Global run keys
		else if ( t_strWhere.Find( L"HKLM\\" ) == 0 )
		{
			t_hResult =
				EnumRunKeyItems(
					NULL,
					a_pInst,
					NULL,
					NULL ) ;
		}
		// User run value
		else if ( t_strWhere.Find( L"*HKU\\" ) == 0 )
		{
			t_hResult =
				EnumRunValueItems(
					NULL,
					a_pInst,
					t_strKey,
					t_strUserName ) ;
		}
		// Global win.ini strings.
		else if ( t_strWhere.Find( L"win.ini" ) == 0 )
		{
			t_hResult =
				EnumIniValueItems(
					NULL,
					a_pInst ) ;
		}
	}

	return t_hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\startupcommand.h ===
//=================================================================

//

// StartupCommand.h -- CWin32StartupCommand property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//
//=================================================================
#ifndef _STARTUPCOMMAND_H
#define _STARTUPCOMMAND_H

class CWin32StartupCommand : public Provider
{
	protected:

		HRESULT EnumStartupFolderItems(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor,
			LPCWSTR a_szKeyName,
			LPCWSTR a_szUserName);

		HRESULT EnumRunKeyItems(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor,
			LPCWSTR	a_szKeyName,
			LPCWSTR	a_szUserName ) ;

		HRESULT EnumRunValueItems(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor,
			LPCWSTR a_szKeyName,
			LPCWSTR a_szUserName ) ;

		HRESULT EnumIniValueItems(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor ) ;

		HRESULT EnumStartupOptions(
			MethodContext *a_pMethodContext,
			CInstance *a_pinstLookingFor ) ;

		HRESULT	EnumCommandSeperatedValuesHelper(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor,
			LPCWSTR a_szLookingForPath,
			LPCWSTR	a_szValueName,
			LPCWSTR	a_szLocation,
			LPCWSTR	a_szUserName,
			LPCWSTR	a_szValue ) ;

		static BOOL UserKeyToUserName( LPCWSTR a_szKeyName, CHString &a_strUserName ) ;
		static BOOL UserNameToUserKey( LPCWSTR szUserName,	CHString &a_strKeyName ) ;
	
	public:

		// Constructor/destructor
		//=======================
		CWin32StartupCommand( LPCWSTR a_szName, LPCWSTR a_szNamespace ) ;
		~CWin32StartupCommand();

		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0 ) ;
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0 ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\systemaccount.h ===
//=================================================================

//

// systemaccount.h -- Group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain Groups
//				 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//											clean up			
//
//=================================================================

// Property set identification
//============================

#define	PROPSET_NAME_SYSTEMACCOUNT L"Win32_SystemAccount"

class CWin32SystemAccount : public Provider
{
	   private:

        // Utility function(s)
        //====================

		BOOL GetSysAccountNameAndDomain( 
										PSID_IDENTIFIER_AUTHORITY a_pAuthority,
										CSid &a_accountsid,
										BYTE a_saCount = 0,
										DWORD a_dwSubAuthority1 = 0,
										DWORD a_dwSubAuthority2 = 0 ) ;

		HRESULT CommitSystemAccount( CSid &a_accountsid, MethodContext *a_pMethodContext ) ;
		void FillInstance( CSid& a_accountsid, CInstance *a_pInst ) ;
	
	#ifdef NTONLY
        BOOL RefreshInstanceNT( CInstance *a_pInst ) ;
        HRESULT AddDynamicInstancesNT( MethodContext *a_pMethodContext ) ;
	#endif

    public:

        // Constructor/destructor
        //=======================

        CWin32SystemAccount( const CHString &a_strName, LPCWSTR a_pszNamespace ) ;
       ~CWin32SystemAccount() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst , long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ); 
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\systemconfigchange.cpp ===
//=================================================================

//

// SystemConfigChange.cpp -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <dbt.h>
#include "SystemConfigChange.h"

//=================================================================
//
// CFactoryRouter
//
// provides for registration and instance creation  
//
//
//=================================================================

// Implements a SystemConfigChangeProvider
IUnknown * CSystemConfigChangeFactory::CreateInstance (

REFIID a_riid ,
LPVOID FAR *a_ppvObject
)
{
	return static_cast<IWbemProviderInit *>(new CSystemConfigChangeEvent) ;
}

//=================================================================
//
// CSystemConfigChangeEvent
//
// provides for eventing of power management events  
//
//
//=================================================================
//

// CEventProvider::Initialize needs the class name. Caller frees
BSTR CSystemConfigChangeEvent::GetClassName()
{
	return SysAllocString(SYSTEM_CONFIG_EVENT); 
}

// CEventProvider signals us to begin providing for events
void CSystemConfigChangeEvent::ProvideEvents()
{
	// Tell CWinMsgEvent what windows messages we're interested in
	if (!m_bRegistered)
	{
		m_bRegistered = TRUE ;
		CWinMsgEvent::RegisterForMessage( WM_DEVICECHANGE ) ;
	}
}


// CWinMsgEvent signals that a message event has arrived
void CSystemConfigChangeEvent::WinMsgEvent(
			
IN	HWND a_hWnd,
IN	UINT a_message,
IN	WPARAM a_wParam,
IN	LPARAM	a_lParam,
OUT E_ReturnAction &a_eRetAction,
OUT LRESULT &a_lResult
)
{
    switch ( a_wParam )
    {
        case DBT_DEVNODES_CHANGED:
        {
            HandleEvent(1);
            break;
        }

        case DBT_DEVICEARRIVAL:
        {
            DEV_BROADCAST_HDR *pHdr = (DEV_BROADCAST_HDR *)a_lParam;

            if (pHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE || 
                pHdr->dbch_devicetype == DBT_DEVTYP_PORT)
            {
                HandleEvent(2);
            }
            break;
        }

        case DBT_DEVICEREMOVECOMPLETE:
        {
            DEV_BROADCAST_HDR *pHdr = (DEV_BROADCAST_HDR *)a_lParam;

            if (pHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE || 
                pHdr->dbch_devicetype == DBT_DEVTYP_PORT)
            {
                HandleEvent(3);
            }
            break;
        }

        case DBT_CONFIGCHANGED:
        {
            HandleEvent(4);
            break;
        }

        default:
        {
            break;
        }
    }
}

// Turn the message into a wmi event
void CSystemConfigChangeEvent::HandleEvent( long lValue )
{
	IWbemObjectSinkPtr t_pHandler(CEventProvider::GetHandler(), false);
	IWbemClassObjectPtr t_pClass(CEventProvider::GetClass(), false); 

	if( t_pClass != NULL && t_pHandler != NULL )
	{
        variant_t vValue(lValue);

    	IWbemClassObjectPtr t_pInst;

		if( SUCCEEDED( t_pClass->SpawnInstance( 0L, &t_pInst ) ) )
        {
            if (SUCCEEDED( t_pInst->Put( L"EventType", 0, &vValue, 0 ) ) )
		    {
                // We can't use t_pInst here, cuz the operator(cast) for this smartptr
                // will FREE the pointer before passing it in, under the assumption
                // that Indicate is going to POPULATE this pointer.
                IWbemClassObject *p2 = t_pInst;
			    t_pHandler->Indicate ( 1, &p2 ) ;
		    }
        }
	}
}

//
void CSystemConfigChangeEvent::OnFinalRelease()
{
	if (m_bRegistered)
	{
		CWinMsgEvent::UnRegisterMessage( WM_DEVICECHANGE ) ;
	}

    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\systemconfigchange.h ===
//=================================================================

//

// SystemConfigChange.h -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "FactoryRouter.h"
#include "EventProvider.h"
#include "WinMsgEvent.h"

#define SYSTEM_CONFIG_EVENT L"Win32_SystemConfigurationChangeEvent"

//
class CSystemConfigChangeFactory :	public CFactoryRouter 
{
	private:
	protected:
	public:

		CSystemConfigChangeFactory( REFGUID a_rClsId, LPCWSTR a_pClassName )
			: CFactoryRouter( a_rClsId, a_pClassName ) {} ;

		~CSystemConfigChangeFactory() {};

		// implementation of abstract CProviderClassFactory
		virtual IUnknown * CreateInstance (

			REFIID a_riid ,
			LPVOID FAR *a_ppvObject
			) ;	
};

//
class CSystemConfigChangeEvent : 
	public CEventProvider, 
	public CWinMsgEvent
{
	private:
        void HandleEvent( long lValue );
		BOOL m_bRegistered;
	
	protected:
	public:

		CSystemConfigChangeEvent() : m_bRegistered ( FALSE ) {};
		~CSystemConfigChangeEvent() {};

		// implementation of abstract CWinMsgEvent
		virtual void WinMsgEvent(
			
			IN	HWND a_hWnd,
			IN	UINT a_message,
			IN	WPARAM a_wParam,
			IN	LPARAM	a_lParam,
			OUT E_ReturnAction &a_eRetAction,
			OUT LRESULT &a_lResult
			) ;

		// implementation of abstract CWmiEventProvider
		virtual void ProvideEvents() ;

		// implementation of class name retrieval for CEventProvider
		virtual void OnFinalRelease() ;

		// implementation of class name retrieval for CWmiProviderInit
		virtual BSTR GetClassName() ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\systemdriver.h ===
//=================================================================

//

// SystemDriver.h -- Service property set provider (Windows NT only)

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//				 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//											clean up	
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_SYSTEM_DRIVER L"Win32_SystemDriver"
#define PROPSET_NAME_PARAMETERCLASS		"__PARAMETERS"

// Get/set function protos
//========================

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

typedef WINADVAPI BOOL ( WINAPI *PROC_QueryServiceStatusEx ) (

    SC_HANDLE           hService,
    SC_STATUS_TYPE      InfoLevel,
    LPBYTE              lpBuffer,
    DWORD               cbBufSize,
    LPDWORD             pcbBytesNeeded
) ;

class CWin32SystemDriver : public Win32_BaseService 
{
	private:

        CHPtrArray m_ptrProperties;

		// Utility function(s)
		//====================

		HRESULT RefreshInstance (

			CInstance *pInstance,
            DWORD dwProperties
		) ;

		HRESULT AddDynamicInstances (

			MethodContext *pMethodContext, 
			DWORD dwProperties
		) ;


        HRESULT AddDynamicInstancesWin95(	

            MethodContext *a_pMethodContext,
			DWORD dwProperties
        ) ;

		HRESULT LoadPropertyValuesNT (

			SC_HANDLE hDBHandle, 
			LPCTSTR szServiceName, 
			CInstance *pInstance, 
			DWORD dwProperties,
			CAdvApi32Api *a_pAdvApi32
		) ;

		void LoadPropertyValuesWin95 (

			LPCTSTR szServiceName, 
			CInstance *pInstance, 
			CRegistry &COne, 
			DWORD dwType)
		;
	public:

		// Constructor/destructor
		//=======================

		CWin32SystemDriver( const CHString &a_name, LPCWSTR a_pszNamespace ) ;
		~CWin32SystemDriver() ;

		// Functions provide properties with current values
		//=================================================

		HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
            CFrameworkQuery& pQuery
		);

		HRESULT EnumerateInstances (

			MethodContext *pMethodContext, 
			long lFlags = 0L
		);

		HRESULT ExecQuery (

			MethodContext *pMethodContext, 
			CFrameworkQuery& pQuery, 
			long lFlags /*= 0L*/ 
		);

		HRESULT PutInstance ( 

			const CInstance &a_Instance, 
			long lFlags /*= 0L*/ 
		) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\systemname.cpp ===
//=================================================================

//

// SystemName.cpp

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include <lockwrap.h>
#include "resource.h"

#include "SystemName.h"

#include "KUserdata.h"
#include "WMI_FilePrivateProfile.h"

CHString CSystemName::s_sKeyName;
CHString CSystemName::s_sLocalKeyName;

CSystemName::CSystemName()
{
    CLockWrapper SystemName(g_csSystemName);

    if (s_sKeyName.IsEmpty())
    {
	    TCHAR szDir[_MAX_PATH];
	    TCHAR szDevice[_MAX_PATH] ;

	    CRegistry RegInfo ;

	    s_sKeyName = GetKeyName();

	    if ( ! GetWindowsDirectory ( szDir, sizeof ( szDir ) / sizeof(TCHAR)) )
	    {
		    szDir[0] = '\0';
	    }

    #ifdef NTONLY
	    {
    	    WCHAR szFileName[_MAX_PATH] ;

		    wcscpy ( szFileName , szDir ) ;
		    wcscat ( szFileName , L"\\REPAIR\\SETUP.LOG" ) ;

		    WMI_FILE_GetPrivateProfileStringW (
                    L"Paths" ,
                    L"TargetDevice" ,
                    L"" ,
                    szDevice ,
                    sizeof ( szDevice ) / sizeof(WCHAR) ,
                    szFileName
                    ) ;
	    }
    #endif
    #ifdef WIN9XONLY
	    {
		    szDevice[0] = '\0' ;
	    }
    #endif

	    s_sKeyName += '|' ;
	    s_sKeyName += szDir ;
	    s_sKeyName += '|' ;
	    s_sKeyName += szDevice ;
    }
}

CSystemName::~CSystemName()
{
}

bool CSystemName::ObjectIsUs(const CInstance *pInstance)
{
   CHString sName ;

   // Get the values from the object
   pInstance->GetCHString(IDS_Name, sName);

   // Do the comparison
   return (s_sKeyName.CompareNoCase(sName) == 0);
}

void CSystemName::SetKeys(CInstance *pInstance)
{
	pInstance->SetCHString(IDS_Name, s_sKeyName);
}

/*****************************************************************************
 *
 *  FUNCTION    : GetKeyName
 *
 *  DESCRIPTION : Gets the Name property (not the machine name!)
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : CHString for the name
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
CHString CSystemName::GetKeyName(void)
{
	CHString chsName;
	CRegistry RegInfo;

#ifdef NTONLY
	{
		KUserdata ku;
		ULONG uProductType = 0xffffffff;

		if ( ku.ProductTypeIsValid() )
			uProductType = ku.NtProductType();

		// Start with the product name
		if( IsWinNT5() )
		{
			if( ERROR_SUCCESS == RegInfo.Open ( HKEY_LOCAL_MACHINE ,
									_T("SOFTWARE\\Microsoft\\Windows NT\\Currentversion") ,
									KEY_READ) )
			{
				RegInfo.GetCurrentKeyValue( _T("ProductName") , chsName );
			}

			if(chsName.IsEmpty())
			{
				if (IsWinNT51())
				{
					chsName = _T("Microsoft Windows XP");
				}
				else
				{
					chsName = _T("Microsoft Windows 2000");
				}
			}
		}
		else
			chsName = _T("Microsoft Windows NT");


		/* now for the product type */
		// Blade Server
		if ( IsWinNT5() && VER_SUITE_BLADE & ku.SuiteMask() )
		{
			chsName += _T(" Blade Server");
		}
		// NT5 Datacenter Server
		else if( IsWinNT5() &&
			(VER_SUITE_DATACENTER & ku.SuiteMask()) &&
			(VER_NT_SERVER == uProductType ||
			 VER_NT_DOMAIN_CONTROLLER == uProductType ) )
		{
			chsName += _T(" Datacenter Server");
		}
		// Enterprise or Advanced Server
		else if( (VER_SUITE_ENTERPRISE & ku.SuiteMask()) &&
				 (VER_NT_SERVER == uProductType ||
				  VER_NT_DOMAIN_CONTROLLER == uProductType ))
		{
			if( IsWinNT5() )
				chsName += _T(" Advanced Server");
			else
				chsName += _T(" Enterprise Server");
		}
		// Server edition
		else if( (VER_NT_SERVER == uProductType ||
				  VER_NT_DOMAIN_CONTROLLER == uProductType ) )
		{
			chsName += _T(" Server");
		}
		// NT5 Professional or NT4 Workstation
		else if(VER_NT_WORKSTATION == uProductType)
		{
			if( IsWinNT5() )
			{
				if (VER_SUITE_PERSONAL & ku.SuiteMask())
				{
					chsName += _T(" Home Edition");
				}
				else
				{
					chsName += _T(" Professional");
				}
			}
			else
			{
				chsName += _T(" Workstation");
			}
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( ( RegInfo.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion" , KEY_READ) != ERROR_SUCCESS ) ||
          ( ERROR_SUCCESS != RegInfo.GetCurrentKeyValue ( L"ProductName", chsName ) ) )
		{
			chsName = L"Microsoft Windows";
        }
    }
#endif

	return chsName;
}
/*****************************************************************************
 *
 *  FUNCTION    : GetLocalizedName
 *
 *  DESCRIPTION : Gets the Name property (not the machine name!) localized
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : CHString for the name
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
CHString CSystemName::GetLocalizedName(void)
{
    CLockWrapper SystemName(g_csSystemName);
    if (s_sLocalKeyName.IsEmpty())
    {

#ifdef NTONLY
		KUserdata	t_ku ;
		ULONG		t_uProductType = 0xffffffff ;
		UINT		t_nID ;

		if ( t_ku.ProductTypeIsValid() )
		{
			t_uProductType = t_ku.NtProductType();
		}

		//windows powered
		if ( IsWinNT5() && VER_SUITE_BLADE & t_ku.SuiteMask() )
		{
			t_nID = IDR_Blade_StockName ;
		}

		// W2k Datacenter Server
		else if( IsWinNT5() && ( VER_SUITE_DATACENTER & t_ku.SuiteMask() ) &&
							( VER_NT_SERVER == t_uProductType ||
							  VER_NT_DOMAIN_CONTROLLER == t_uProductType ) )
		{
			if (IsWinNT51())
			{
				t_nID = IDR_W2kPlus1_Datacenter ;
			}
			else
			{
				t_nID = IDR_W2k_Datacenter ;
			}
		}

		// Enterprise or Advanced Server
		else if( ( VER_SUITE_ENTERPRISE & t_ku.SuiteMask() ) &&
					( VER_NT_SERVER == t_uProductType ||
					  VER_NT_DOMAIN_CONTROLLER == t_uProductType ) )
		{
			if( IsWinNT5() )
			{
				if (IsWinNT51())
				{
					t_nID = IDR_W2kPlus1_AdvancedServer ;
				}
				else
				{
					t_nID = IDR_W2k_AdvancedServer ;
				}
			}
			else
			{
				t_nID = IDR_NT_EnterpriseServer ;
			}
		}

		// Server edition
		else if( ( VER_NT_SERVER == t_uProductType ||
				   VER_NT_DOMAIN_CONTROLLER == t_uProductType ) )
		{
			if( IsWinNT5() )
			{
				if (IsWinNT51())
				{
					t_nID = IDR_W2kPlus1_Server ;
				}
				else
				{
					t_nID = IDR_W2k_Server ;
				}				    
			}
			else
			{
				t_nID = IDR_NT_Server ;
			}
		}

		// NT5 Professional or NT4 Workstation
		else if( VER_NT_WORKSTATION == t_uProductType )
		{
			if( IsWinNT5() )
			{
				if (IsWinNT51())
				{
					if (VER_SUITE_PERSONAL & t_ku.SuiteMask())
					{
						t_nID = IDR_W2kPlus1_Personal ; 
					}
					else
					{
						t_nID = IDR_W2kPlus1_Professional ; 
					}
				}
				else
				{
					t_nID = IDR_W2k_Professional ;
				}				    
			}
			else
			{
				t_nID = IDR_NT_Workstation ;
			}
		}

		// Stock name ( should not be here )
		else
		{
			if( IsWinNT5() )
			{
				if (IsWinNT51())
				{
					t_nID = IDR_W2kPlus1_StockName ;
				}
				else
				{
					t_nID = IDR_W2k_StockName ;
				}				    
			}
			else
			{
				t_nID = IDR_NT_StockName ;
			}
		}

		LoadStringW( s_sLocalKeyName, t_nID );
#endif
#ifdef WIN9XONLY
	s_sLocalKeyName.LoadStringW( IDR_9x_StockName );
#endif
    }

	return s_sLocalKeyName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\systemaccount.cpp ===
//=================================================================

//

// SystemAccount.CPP -- System account property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain Groups
//				 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================

#include "precomp.h"
#include "sid.h"
#include <ProvExce.h>
#include "SystemAccount.h"

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32SystemAccount	Win32GroupAccount( PROPSET_NAME_SYSTEMACCOUNT, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::CWin32SystemAccount
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SystemAccount::CWin32SystemAccount( const CHString &a_strName, LPCWSTR a_pszNamespace /*=NULL*/ )
:	Provider( a_strName, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::~CWin32SystemAccount
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SystemAccount::~CWin32SystemAccount()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SystemAccount::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SystemAccount::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	BOOL t_fReturn = FALSE;

	// Find the instance depending on platform id.
	#ifdef NTONLY
		t_fReturn = RefreshInstanceNT( a_pInst ) ;
	#endif

	return t_fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND ;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SystemAccount::EnumerateInstances
//
//	Inputs:		MethodContext*	a_pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SystemAccount::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;

	// Get the proper OS dependent instance
	#ifdef NTONLY
		t_hResult = AddDynamicInstancesNT( a_pMethodContext ) ;
	#endif

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32SystemAccount::AddDynamicInstancesNT( MethodContext *a_pMethodContext )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;

	SID_IDENTIFIER_AUTHORITY	t_worldsidAuthority		= SECURITY_WORLD_SID_AUTHORITY,
								t_localsidAuthority		= SECURITY_LOCAL_SID_AUTHORITY,
								t_creatorsidAuthority	= SECURITY_CREATOR_SID_AUTHORITY,
								t_ntsidAuthority		= SECURITY_NT_AUTHORITY ;
	CSid t_accountsid;

	// This function returns what amounts to a hardcoded list of Sid Accounts meaningful
	// for security and that's about it

	// Start with the Universal Sids

	if ( GetSysAccountNameAndDomain( &t_worldsidAuthority, t_accountsid, 1, SECURITY_WORLD_RID ) )
	{
		t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_localsidAuthority, t_accountsid, 1, SECURITY_LOCAL_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_creatorsidAuthority, t_accountsid, 1, SECURITY_CREATOR_OWNER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_creatorsidAuthority, t_accountsid, 1, SECURITY_CREATOR_GROUP_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_creatorsidAuthority, t_accountsid, 1, SECURITY_CREATOR_OWNER_SERVER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_creatorsidAuthority, t_accountsid, 1, SECURITY_CREATOR_GROUP_SERVER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	// Now we handle the NT AUTHORITY Accounts

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_DIALUP_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_NETWORK_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_BATCH_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_INTERACTIVE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_SERVICE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_ANONYMOUS_LOGON_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_PROXY_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

// this creates a duplicate instance of BATCH. If you cahnge the sidAuthority to any of the other
// possible choices, it creates dupes of other instances.   I say we don't need it.  BWS.
//	if ( SUCCEEDED( t_hResult ) )
//	{
//		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_CREATOR_GROUP_SERVER_RID ) )
//		{
//			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
//		}
//	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_LOCAL_SYSTEM_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}
    
    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_ENTERPRISE_CONTROLLERS_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_PRINCIPAL_SELF_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_AUTHENTICATED_USER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_RESTRICTED_CODE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_TERMINAL_SERVER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_REMOTE_LOGON_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_LOGON_IDS_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_LOCAL_SERVICE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_NETWORK_SERVICE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_BUILTIN_DOMAIN_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}
    

    return t_hResult;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::GetSysAccountNameAndDomain
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32SystemAccount::GetSysAccountNameAndDomain(
													 PSID_IDENTIFIER_AUTHORITY a_pAuthority,
													 CSid& a_accountsid,
													 BYTE  a_saCount /*=0*/,
													 DWORD a_dwSubAuthority1 /*=0*/,
													 DWORD a_dwSubAuthority2 /*=0*/  )
{
	BOOL t_fReturn = FALSE;
	PSID t_psid = NULL;

	if ( AllocateAndInitializeSid(	a_pAuthority,
									a_saCount,
									a_dwSubAuthority1,
									a_dwSubAuthority2,
									0,
									0,
									0,
									0,
									0,
									0,
									&t_psid ) )
	{
	    try
	    {
			CSid t_sid( t_psid ) ;

            // a-kevhu said this line is redundant duplication
//			CSid t_sid2( TOBSTRT( t_sid.GetAccountName() ), NULL ) ;

			// The SID may be valid in this case, however the Lookup may have failed
			if ( t_sid.IsValid() && t_sid.IsOK() )
			{
				a_accountsid = t_sid;
				t_fReturn = TRUE;
			}

	    }
	    catch( ... )
	    {
		    if( t_psid )
		    {
			    FreeSid( t_psid ) ;
		    }
		    throw ;
	    }

		// Cleanup the sid
		FreeSid( t_psid ) ;
	}

	return t_fReturn;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::CommitSystemAccount
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemAccount::CommitSystemAccount( CSid &a_accountsid, MethodContext *a_pMethodContext )
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	CInstancePtr t_pInst(CreateNewInstance( a_pMethodContext ), false);

	FillInstance( a_accountsid, t_pInst ) ;

	t_hResult = t_pInst->Commit(  ) ;

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::FillInstance
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32SystemAccount::FillInstance( CSid &a_accountsid, CInstance *a_pInst )
{
	CHString t_strDesc;
	CHString t_strDomain = a_accountsid.GetDomainName() ;
    CHString chstrNT_AUTHORITY;
    CHString chstrBuiltIn;

    if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) && GetLocalizedBuiltInString(chstrBuiltIn))
    {
		// Replace NT AUTHORITY with a human readable string
		//if ( 0 == t_strDomain.CompareNoCase( L"NT AUTHORITY" ) )
		if ( 0 == t_strDomain.CompareNoCase(chstrNT_AUTHORITY) ||
			 t_strDomain.IsEmpty())
		{
			t_strDomain = GetLocalComputerName() ;
		}
		else if( t_strDomain.CompareNoCase(chstrBuiltIn) == 0)
		{
			t_strDomain = GetLocalComputerName() ;
		}
	}

	if ( t_strDomain.IsEmpty() )
	{
		t_strDesc = a_accountsid.GetAccountName() ;
	}
	else
	{
		t_strDesc = t_strDomain + _T('\\') + a_accountsid.GetAccountName() ;
	}

	a_pInst->SetCHString(	IDS_Name, a_accountsid.GetAccountName() ) ;
	a_pInst->SetCHString(	IDS_Domain, t_strDomain ) ;
	a_pInst->SetCHString(	L"SID", a_accountsid.GetSidString() ) ;
	a_pInst->SetByte(		L"SIDType", a_accountsid.GetAccountType() ) ;
	a_pInst->SetCHString(	L"Caption", t_strDesc ) ;
	a_pInst->SetCHString(	L"Description", t_strDesc ) ;
	a_pInst->SetCharSplat(	L"Status", _T("OK") ) ;
    a_pInst->Setbool(IDS_LocalAccount, true);

}

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceNT
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32SystemAccount::RefreshInstanceNT( CInstance *a_pInst )
{
	BOOL		t_fReturn = FALSE;

	CHString	t_strDomain,
				t_strAccountDomain,
				t_strName,
				t_strComputerName;

	a_pInst->GetCHString( IDS_Name, t_strName ) ;
	a_pInst->GetCHString( IDS_Domain, t_strDomain ) ;

	t_strComputerName = GetLocalComputerName() ;

    CHString chstrNT_AUTHORITY;
    CHString chstrBuiltIn;

    if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) && GetLocalizedBuiltInString(chstrBuiltIn))
    {
		// Supplied domain name must be either "Empty" or the computer name
		if ( t_strDomain.IsEmpty() || t_strDomain.CompareNoCase( t_strComputerName ) == 0 )
		{
			CSid t_sidAccount( t_strName, NULL ) ;

			if ( t_sidAccount.IsValid() && t_sidAccount.IsOK() )
			{
				// This will give us the value returned by the Lookup as opposed to what
				// was passed in.

				t_strAccountDomain = t_sidAccount.GetDomainName() ;

				// The only valid retrieved domain names we support are: "" and "NT AUTHORITY"
				//if ( t_strAccountDomain.IsEmpty() || t_strAccountDomain.CompareNoCase( _T("NT AUTHORITY") ) == 0 )
				if ( t_strAccountDomain.IsEmpty() || 
					t_strAccountDomain.CompareNoCase( chstrNT_AUTHORITY ) == 0 ||
					t_strAccountDomain.CompareNoCase(chstrBuiltIn) == 0)
				{
					// NT AUTHORITY means the local computer name.
					//if ( t_strAccountDomain.CompareNoCase( _T("NT AUTHORITY") ) == 0 )
					//if ( t_strAccountDomain.CompareNoCase( t_strAuthorityDomain ) == 0 )
					{
						t_strAccountDomain = GetLocalComputerName() ;
					}

					// The retrieved Account Domain and the supplied account domain must be the same, or the
					// values really don't quite match the instance
					if ( t_strDomain.CompareNoCase( t_strAccountDomain ) == 0 )
					{
						FillInstance( t_sidAccount, a_pInst ) ;
						t_fReturn = TRUE;
					}

				}	// IF valid account domain

			}	// IF account ok

		}	// IF valid domain
    } 

    return t_fReturn ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\systemname.h ===
//=================================================================

//

// SystemName.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _SYSTEMNAME_H_
#define _SYSTEMNAME_H_

class CSystemName
{
public:
   CSystemName();
   ~CSystemName();

   void SetKeys(CInstance *pInstance);
   bool ObjectIsUs(const CInstance *pInstance);
   
   CHString GetLongKeyName(void) { return s_sKeyName; }
   CHString GetLocalizedName(void);

protected:

   CHString GetKeyName(void);

   static CHString s_sKeyName;
   static CHString s_sLocalKeyName;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\systemdriver.cpp ===
//=================================================================

//

// SystemDriver.CPP -- SystemDriver property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//				 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include <frqueryex.h>

#include "bservice.h"
#include "SystemDriver.h"
#include "computersystem.h"

#define BIT_ALL_PROPERTIES          0xffffffff
#define BIT_Name                    0x00000001
#define BIT_State                   0x00000002
#define BIT_Started                 0x00000004
#define BIT_AcceptStop              0x00000008
#define BIT_AcceptPause             0x00000010
//#define BIT_ProcessId               0x00000020 // Does not apply to drivers
#define BIT_ExitCode                0x00000040
#define BIT_ServiceSpecificExitCode 0x00000080
//#define BIT_CheckPoint              0x00000100 // Does not apply to drivers
//#define BIT_WaitHint                0x00000200 // Does not apply to drivers
#define BIT_Status                  0x00000400
#define BIT_Caption                 0x00000800
#define BIT_DisplayName             0x00001000
#define BIT_Description             0x00002000
#define BIT_TagId                   0x00004000
#define BIT_ServiceType             0x00008000
#define BIT_DesktopInteract         0x00010000
#define BIT_StartMode               0x00020000
#define BIT_ErrorControl            0x00040000
#define BIT_PathName                0x00080000
#define BIT_StartName               0x00100000
#define BIT_CreationClassName       0x00200000
#define BIT_SystemCreationClassName 0x00400000
#define BIT_SystemName              0x00800000

// Property set declaration
//=========================

CWin32SystemDriver MySystemDriver(PROPSET_NAME_SYSTEM_DRIVER, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::CWin32SystemDriver
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SystemDriver :: CWin32SystemDriver (
	const CHString &a_name,
	LPCWSTR a_pszNamespace

) : Win32_BaseService( a_name, a_pszNamespace )
{
    m_ptrProperties.SetSize(24);

    m_ptrProperties[0] = ((LPVOID) IDS_Name);
    m_ptrProperties[1] = ((LPVOID) IDS_State);
    m_ptrProperties[2] = ((LPVOID) IDS_Started);
    m_ptrProperties[3] = ((LPVOID) IDS_AcceptStop);
    m_ptrProperties[4] = ((LPVOID) IDS_AcceptPause);
    m_ptrProperties[5] = ((LPVOID) IDS_ProcessId);
    m_ptrProperties[6] = ((LPVOID) IDS_ExitCode);
    m_ptrProperties[7] = ((LPVOID) IDS_ServiceSpecificExitCode);
    m_ptrProperties[8] = ((LPVOID) IDS_CheckPoint);
    m_ptrProperties[9] = ((LPVOID) IDS_WaitHint);
    m_ptrProperties[10] = ((LPVOID) IDS_Status);
    m_ptrProperties[11] = ((LPVOID) IDS_Caption);
    m_ptrProperties[12] = ((LPVOID) IDS_DisplayName);
    m_ptrProperties[13] = ((LPVOID) IDS_Description);
    m_ptrProperties[14] = ((LPVOID) IDS_TagId);
    m_ptrProperties[15] = ((LPVOID) IDS_ServiceType);
    m_ptrProperties[16] = ((LPVOID) IDS_DesktopInteract);
    m_ptrProperties[17] = ((LPVOID) IDS_StartMode);
    m_ptrProperties[18] = ((LPVOID) IDS_ErrorControl);
    m_ptrProperties[19] = ((LPVOID) IDS_PathName);
    m_ptrProperties[20] = ((LPVOID) IDS_StartName);
    m_ptrProperties[21] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[22] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[23] = ((LPVOID) IDS_SystemName);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::~CWin32SystemDriver
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

CWin32SystemDriver :: ~CWin32SystemDriver ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver :: ExecQuery (
	MethodContext *a_pMethodContext,
	CFrameworkQuery &a_pQuery,
	long a_lFlags /*= 0L*/
)
{
    HRESULT t_hResult ;

#ifdef NTONLY
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&a_pQuery);

    DWORD dwProperties = BIT_ALL_PROPERTIES;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    t_hResult = AddDynamicInstances( a_pMethodContext, dwProperties ) ;
#endif
#ifdef WIN9XONLY
            t_hResult = WBEM_E_PROVIDER_NOT_CAPABLE ;
#endif

    return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver :: GetObject (
	CInstance *a_pInst,
	long a_lFlags,
    CFrameworkQuery &a_pQuery
)
{
	// OS specific compiled call
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&a_pQuery);

    DWORD dwProperties = BIT_ALL_PROPERTIES;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

	HRESULT hRes = RefreshInstance( a_pInst, dwProperties ) ;
	if ( hRes == WBEM_E_ACCESS_DENIED )
	{
		hRes = WBEM_S_NO_ERROR ;
	}

	return hRes ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long lFlags /*= 0L*/
)
{
	// OS specific compiled call
#ifdef NTONLY
	return AddDynamicInstances( a_pMethodContext, BIT_ALL_PROPERTIES ) ;
#endif

#ifdef WIN9XONLY
	return AddDynamicInstancesWin95( a_pMethodContext, BIT_ALL_PROPERTIES ) ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::RefreshInstanceNT
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32SystemDriver::RefreshInstance( CInstance *a_pInst, DWORD dwProperties )
{
	HRESULT t_hResult = WBEM_E_FAILED;

	SmartCloseServiceHandle t_hDBHandle;
	CAdvApi32Api *t_pAdvApi32 = NULL ;

	// Check to see if this is us...

	try
	{
		CHString t_sName;
		if( !a_pInst->GetCHString( IDS_Name, t_sName ) || t_sName.IsEmpty() )
		{
			return WBEM_E_NOT_FOUND ;
		}

		// Get an scman handle
		if( t_hDBHandle = OpenSCManager( NULL, NULL, GENERIC_READ ) )
		{
			// Create copy of name & pass to LoadPropertyValues
			//=================================================

			PROC_QueryServiceStatusEx t_QueryServiceStatusEx = NULL ;

			if ( IsWinNT5 () )
			{
				t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidAdvApi32Api, NULL ) ;
			}

			t_hResult = LoadPropertyValuesNT (

				t_hDBHandle,
				(LPCTSTR) t_sName,
				a_pInst,
				dwProperties ,
				t_pAdvApi32
			 ) ;
		}
	}
	catch( ... )
	{
		if( t_pAdvApi32 )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidAdvApi32Api, t_pAdvApi32 ) ;
		}
		throw ;
	}

	if( t_pAdvApi32 != NULL )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidAdvApi32Api, t_pAdvApi32 ) ;
		t_pAdvApi32 = NULL;
	}

	return t_hResult;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32SystemDriver::AddDynamicInstances (

	MethodContext *a_pMethodContext,
	DWORD dwProperties
)
{

    HRESULT t_hResult	= WBEM_E_FAILED ;
	SmartCloseServiceHandle	t_hDBHandle;
	ENUM_SERVICE_STATUS	*t_pServiceList = NULL ;
	CAdvApi32Api		*t_pAdvApi32 = NULL ;

	try
	{
		// Get handle to the services database
		//====================================

		t_hDBHandle = OpenSCManager( NULL, NULL, GENERIC_READ ) ;

		if( t_hDBHandle == NULL )
		{
			return t_hResult;
		}

		// Make call once to get buffer size (should return
		// FALSE but fill in buffer size)
		//=================================================

		DWORD t_i, t_hEnumHandle = 0, t_dwByteCount = 0, t_dwEntryCount ;

		BOOL t_EnumStatus = EnumServicesStatus (

			t_hDBHandle,
			SERVICE_DRIVER ,
			SERVICE_ACTIVE | SERVICE_INACTIVE,
			t_pServiceList,
			t_dwByteCount,
			&t_dwByteCount,
			&t_dwEntryCount,
			&t_hEnumHandle
		) ;

		if ( t_EnumStatus == FALSE && GetLastError() == ERROR_MORE_DATA )
		{
			// Allocate the required buffer
			//=============================

			t_pServiceList = reinterpret_cast<LPENUM_SERVICE_STATUS> (new char[ t_dwByteCount ] ) ;
			if( t_pServiceList != NULL )
			{
                try
                {
				    memset( t_pServiceList, 0, t_dwByteCount ) ;

				    t_EnumStatus = EnumServicesStatus (

					    t_hDBHandle,
					    SERVICE_DRIVER, SERVICE_ACTIVE | SERVICE_INACTIVE,
					    t_pServiceList,
					    t_dwByteCount,
					    &t_dwByteCount,
					    &t_dwEntryCount,
					    &t_hEnumHandle
				    ) ;

				    if ( t_EnumStatus == TRUE )
				    {

					    t_hResult = WBEM_S_NO_ERROR;

					    if ( IsWinNT5 () )
					    {
						    t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidAdvApi32Api, NULL ) ;
					    }

					    // smart ptr
					    CInstancePtr t_pInst ;

					    // Create instance for each returned Driver
					    //==========================================

					    for( t_i = 0 ; t_i < t_dwEntryCount; t_i++ )
					    {
						    t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

							// Load and save
							t_hResult = LoadPropertyValuesNT (

								t_hDBHandle,
								t_pServiceList[ t_i ].lpServiceName,
								t_pInst,
								dwProperties ,
								t_pAdvApi32
							 ) ;

							if ( t_hResult == WBEM_S_NO_ERROR ||
								 t_hResult == WBEM_E_ACCESS_DENIED ) // can enumerate the driver but can't open it
							{
								t_hResult = t_pInst->Commit() ;
							}

							t_hResult = WBEM_S_NO_ERROR ;
					    }
				    }
                }
                catch ( ... )
                {
    				delete [] reinterpret_cast<char *> ( t_pServiceList ) ;
					t_pServiceList = NULL ;
                    throw;
                }

				delete [] reinterpret_cast<char *> ( t_pServiceList ) ;
				t_pServiceList = NULL ;
			}
		}
	}
	catch( ... )
	{
		if( t_pServiceList )
		{
			delete [] reinterpret_cast<char *> ( t_pServiceList ) ;
		}
		if( t_pAdvApi32 )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidAdvApi32Api, t_pAdvApi32 ) ;
		}

		throw ;
	}

	if( t_pAdvApi32 != NULL )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidAdvApi32Api, t_pAdvApi32 ) ;
		t_pAdvApi32 = NULL ;
	}

	return t_hResult;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::LoadPropertyValuesNT
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32SystemDriver :: LoadPropertyValuesNT (

	SC_HANDLE	a_hDBHandle,
	LPCTSTR		a_szServiceName,
	CInstance	*a_pInst,
	DWORD dwProperties,
	CAdvApi32Api *a_pAdvApi32
)
{
    char	t_ConfigBuffer[1024] ;
    LPQUERY_SERVICE_CONFIG t_pConfigInfo = (LPQUERY_SERVICE_CONFIG) t_ConfigBuffer ;
    DWORD	t_dwByteCount ;
    bool	t_bStarted;

    HRESULT t_hResult = WBEM_S_NO_ERROR ; // Since we have the name, we can populate the key.
	SmartCloseServiceHandle t_hSvcHandle;

	// Redundant for getobject, but hey...

	a_pInst->SetCHString( IDS_Name, a_szServiceName ) ;
	a_pInst->SetCHString( IDS_CreationClassName, PROPSET_NAME_SYSTEM_DRIVER ) ;
	a_pInst->SetCHString( IDS_SystemCreationClassName, PROPSET_NAME_COMPSYS ) ;
	a_pInst->SetCHString( IDS_SystemName, (LPCTSTR)GetLocalComputerName() ) ;

	// Open the Driver
	//=================

	// Check to see if we HAVE to open the service.  If we are running as a
	// query and they didn't request some of these properties, let's not waste the time.

    BOOL t_bStatusInfo = dwProperties &
        (BIT_State | BIT_Started | BIT_AcceptStop | BIT_AcceptPause | BIT_Status |
         BIT_ExitCode | BIT_ServiceSpecificExitCode );


    BOOL t_bConfigInfo = dwProperties &
        (BIT_TagId | BIT_ServiceType | BIT_DesktopInteract | BIT_StartMode |
         BIT_ErrorControl | BIT_PathName | BIT_DisplayName | BIT_Caption |
         BIT_Description | BIT_StartName);

	t_hSvcHandle = OpenService (

		a_hDBHandle,
		a_szServiceName,
		SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_INTERROGATE
	) ;

	DWORD t_dwLastError = GetLastError();

	if ( ( t_hSvcHandle == NULL ) && ( ERROR_SERVICE_DOES_NOT_EXIST == t_dwLastError || ERROR_INVALID_NAME == t_dwLastError) )
	{
		return WBEM_E_NOT_FOUND;
	}

	// is it a System driver?
	memset( t_ConfigBuffer, 0, sizeof( t_ConfigBuffer ) ) ;

	if( QueryServiceConfig( t_hSvcHandle, t_pConfigInfo, sizeof( t_ConfigBuffer ), &t_dwByteCount ) == TRUE )
	{
		a_pInst->SetDWORD( IDS_TagId, t_pConfigInfo->dwTagId ) ;

		switch ( t_pConfigInfo->dwServiceType & (~SERVICE_INTERACTIVE_PROCESS) )
		{
			case SERVICE_WIN32_OWN_PROCESS:
			case SERVICE_WIN32_SHARE_PROCESS:
			{
				return WBEM_E_NOT_FOUND;  // Not a driver
			}
			break ;
		}
	}

	{
		// If all they wanted was the name, skip all this.
		if ( t_bStatusInfo || t_bConfigInfo )
		{
			// Get current service status
			//===========================

			if ( t_bStatusInfo)
			{
				DWORD t_CurrentState ;
				DWORD t_ControlsAccepted ;
				DWORD t_Win32ExitCode = 0 ;
				DWORD t_ServiceSpecific = 0 ;

				BOOL t_Status = FALSE ;
				if ( IsWinNT5() && a_pAdvApi32 != NULL )
				{
					SERVICE_STATUS_PROCESS t_StatusInfo ;

					DWORD t_ExpectedSize = 0 ;
					if(a_pAdvApi32->QueryServiceStatusEx(	t_hSvcHandle,
																	SC_STATUS_PROCESS_INFO,
																	( UCHAR * ) &t_StatusInfo,
																	sizeof ( t_StatusInfo ),
																	&t_ExpectedSize , &t_Status ) )
					{
						if ( t_Status == TRUE )
						{
							t_CurrentState		= t_StatusInfo.dwCurrentState ;
							t_ControlsAccepted	= t_StatusInfo.dwControlsAccepted ;
							t_Win32ExitCode		= t_StatusInfo.dwWin32ExitCode ;
							t_ServiceSpecific	= t_StatusInfo.dwServiceSpecificExitCode ;
						}
					}
				}

				if(!t_Status)
				{
					SERVICE_STATUS t_StatusInfo ;
					t_Status = QueryServiceStatus( t_hSvcHandle, &t_StatusInfo ) ;

					if( t_Status == TRUE )
					{
						t_CurrentState		= t_StatusInfo.dwCurrentState ;
						t_ControlsAccepted	= t_StatusInfo.dwControlsAccepted ;
						t_Win32ExitCode		= t_StatusInfo.dwWin32ExitCode ;
						t_ServiceSpecific	= t_StatusInfo.dwServiceSpecificExitCode ;
					}
				}

				if ( t_Status )
				{
					switch ( t_CurrentState )
					{
						case SERVICE_STOPPED:
						{
							a_pInst->SetCharSplat( IDS_State , L"Stopped" ) ;
							t_bStarted = false ;
						}
						break ;

						case SERVICE_START_PENDING:
						{
							a_pInst->SetCharSplat( IDS_State, L"Start Pending"  ) ;
							t_bStarted = true ;
						}
						break ;

						case SERVICE_STOP_PENDING:
						{
							a_pInst->SetCharSplat( IDS_State , L"Stop Pending"  ) ;
							t_bStarted = true ;
						}
						break ;

						case SERVICE_RUNNING:
						{
							a_pInst->SetCharSplat( IDS_State, L"Running" ) ;
							t_bStarted = true;
						}
						break ;

						case SERVICE_CONTINUE_PENDING:
						{
							a_pInst->SetCharSplat( IDS_State, L"Continue Pending" ) ;
							t_bStarted = true ;
						}
						break ;

						case SERVICE_PAUSE_PENDING:
						{
							a_pInst->SetCharSplat( IDS_State, L"Pause Pending" ) ;
							t_bStarted = true;
						}
						break ;

						case SERVICE_PAUSED:
						{
							a_pInst->SetCharSplat( IDS_State, L"Paused" ) ;
							t_bStarted = true ;
						}
						break ;

						default:
						{
							a_pInst->SetCharSplat( IDS_State, L"Unknown" ) ;
							t_bStarted = true ;
						}
						break ;
					}

					a_pInst->Setbool( IDS_Started, t_bStarted ) ;
					a_pInst->Setbool( IDS_AcceptStop, t_ControlsAccepted & SERVICE_ACCEPT_STOP ) ;
					a_pInst->Setbool( IDS_AcceptPause, t_ControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE ) ;

					a_pInst->SetDWORD ( IDS_ExitCode, t_Win32ExitCode ) ;
					a_pInst->SetDWORD ( IDS_ServiceSpecificExitCode, t_ServiceSpecific ) ;

				}
				else
				{
					a_pInst->SetCharSplat( IDS_State, L"Unknown" ) ;
				}

                if (dwProperties & BIT_Status)
                {
				    if( t_hSvcHandle )
				    {
					    SERVICE_STATUS t_StatusInfo ;
					    if ((!t_bStarted) || ( ControlService( t_hSvcHandle, SERVICE_CONTROL_INTERROGATE, &t_StatusInfo) != 0) )
					    {
						    a_pInst->SetCharSplat( IDS_Status, L"OK" ) ;
					    }
					    else
					    {
						    a_pInst->SetCharSplat( IDS_Status, L"Degraded" ) ;
					    }
				    }
				    else
				    {
					    a_pInst->SetCharSplat(IDS_Status, _T("Unknown"));
				    }
                }
			}

			if ( t_bConfigInfo )
			{
			  // Get the rest of the config info
			  //================================

			  // These may get overwritten below if we can find something better
				a_pInst->SetCHString( IDS_Caption, a_szServiceName ) ;
				a_pInst->SetCHString( IDS_DisplayName, a_szServiceName ) ;
				a_pInst->SetCHString( IDS_Description, a_szServiceName ) ;

				memset( t_ConfigBuffer, 0, sizeof( t_ConfigBuffer ) ) ;
				if( QueryServiceConfig( t_hSvcHandle, t_pConfigInfo, sizeof( t_ConfigBuffer ), &t_dwByteCount ) == TRUE )
				{
					a_pInst->SetDWORD( IDS_TagId, t_pConfigInfo->dwTagId ) ;

					switch ( t_pConfigInfo->dwServiceType & (~SERVICE_INTERACTIVE_PROCESS) )
					{
						case SERVICE_WIN32_OWN_PROCESS:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, _T("Own Process") ) ;
							t_hResult = WBEM_E_NOT_FOUND ;  // Not a driver
						}
						break ;

						case SERVICE_WIN32_SHARE_PROCESS:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, L"Share Process" ) ;
							t_hResult = WBEM_E_NOT_FOUND ;  // Not a driver
						}
						break ;

						case SERVICE_KERNEL_DRIVER:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, L"Kernel Driver" ) ;
						}
						break ;

						case SERVICE_FILE_SYSTEM_DRIVER:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, L"File System Driver" ) ;
						}
						break ;

						default:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, L"Unknown" ) ;
						}
						break ;
					}

					switch ( t_pConfigInfo->dwStartType )
					{
						case SERVICE_BOOT_START:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Boot" ) ;
						}
						break ;

						case SERVICE_SYSTEM_START:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"System" ) ;
						}
						break ;

						case SERVICE_AUTO_START:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Auto" ) ;
						}
						break ;

						case SERVICE_DEMAND_START:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Manual" ) ;
						}
						break ;

						case SERVICE_DISABLED:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Disabled" ) ;
						}
						break ;

						default:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Unknown" ) ;
						}
						break ;
					}

					a_pInst->Setbool( IDS_DesktopInteract, t_pConfigInfo->dwServiceType & SERVICE_INTERACTIVE_PROCESS ) ;

					switch ( t_pConfigInfo->dwErrorControl )
					{
						case SERVICE_ERROR_IGNORE:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Ignore" ) ;
						}
						break ;

						case SERVICE_ERROR_NORMAL:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Normal" ) ;
						}
						break ;

						case SERVICE_ERROR_SEVERE:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Severe" ) ;
						}
						break ;

						case SERVICE_ERROR_CRITICAL:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Critical" ) ;
						}
						break ;

						default:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Unknown" ) ;
						}
						break ;
					}

					if( t_pConfigInfo->lpBinaryPathName && t_pConfigInfo->lpBinaryPathName[ 0 ] )
					{
						// NT sometimes stores strange strings for the path.  This
						// code attempts to turn them back into real paths.
						CHString t_sPathName( t_pConfigInfo->lpBinaryPathName ) ;

						if ( t_sPathName.Left( 9 ).CompareNoCase( L"System32\\" ) == 0 )
						{
							CHString t_sSystemDir ;
        					GetSystemDirectory( t_sSystemDir.GetBuffer(MAX_PATH), MAX_PATH ) ;
							t_sSystemDir.ReleaseBuffer( ) ;

							t_sPathName = t_sSystemDir + L'\\' + t_sPathName.Mid( 9 ) ;
						}

						if ( t_sPathName.Left(21).CompareNoCase( L"\\SystemRoot\\System32\\" ) == 0 )
						{
							CHString t_sSystemDir;
        					GetSystemDirectory( t_sSystemDir.GetBuffer(MAX_PATH), MAX_PATH ) ;
							t_sSystemDir.ReleaseBuffer( ) ;

							t_sPathName = t_sSystemDir + L'\\' + t_sPathName.Mid( 21 ) ;
						}

						a_pInst->SetCHString( IDS_PathName, t_sPathName  ) ;
					}
					else
					{
						// Let's make a guess about where we think the file might live (This is how
						// device manager in nt5 does this).
						CHString t_sPathName;

    					GetSystemDirectory( t_sPathName.GetBuffer( MAX_PATH ), MAX_PATH ) ;
	    				t_sPathName.ReleaseBuffer( ) ;

						t_sPathName += L"\\drivers\\" ;
						t_sPathName += a_szServiceName;
						t_sPathName += L".sys" ;

						// Now, if the file doesn't really exist there, let's not pretend it does.
						if ( GetFileAttributes( t_sPathName ) != 0xffffffff )
						{
    						a_pInst->SetCHString( IDS_PathName, t_sPathName ) ;
						}
					}

					if( t_pConfigInfo->lpServiceStartName && t_pConfigInfo->lpServiceStartName[ 0 ] )
					{
						a_pInst->SetCHString( IDS_StartName, t_pConfigInfo->lpServiceStartName ) ;
					}
					else
					{
						a_pInst->SetCHString( IDS_StartName, _T("") ) ;
					}

					// The display name would make a better description and caption if we can get it

					if( t_pConfigInfo->lpDisplayName && t_pConfigInfo->lpDisplayName[ 0 ] )
					{
						a_pInst->SetCHString( IDS_DisplayName, t_pConfigInfo->lpDisplayName  ) ;
						a_pInst->SetCHString( IDS_Caption, t_pConfigInfo->lpDisplayName  ) ;
						a_pInst->SetCHString( IDS_Description, t_pConfigInfo->lpDisplayName  ) ;
					}
				}
				else
				{
					a_pInst->SetCHString( IDS_ServiceType, _T("Unknown") ) ;
					a_pInst->SetCHString( IDS_StartMode, _T("Unknown") ) ;
					a_pInst->SetCHString( IDS_ErrorControl, _T("Unknown") ) ;
				}
			}
		}
		if( !t_hSvcHandle )
		{
			if( ERROR_ACCESS_DENIED == t_dwLastError )
			{
				// could enumerate the service but could not open it
				t_hResult = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				// Service not started, etc...
				t_hResult = WBEM_NO_ERROR ;
			}
		}
	}

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::RefreshInstanceWin95
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32SystemDriver::RefreshInstance( CInstance *a_pInst, DWORD dwProperties )
{
	CRegistry	t_RegInfo ;
	CHString	t_sCreationClassName,
				t_sName,
				t_sSystemCreationClassName,
				t_sSystemName ;
	HRESULT		t_hResult = WBEM_E_NOT_FOUND ;
	DWORD		t_dwType ;

   // Check to see if this is us
	a_pInst->GetCHString(IDS_Name, t_sName ) ;

	CHString t_sKey( L"System\\CurrentControlSet\\Services\\" + t_sName ) ;

	if ( t_RegInfo.Open( HKEY_LOCAL_MACHINE, t_sKey, KEY_READ ) == ERROR_SUCCESS )
	{
        DWORD t_dwSize = 4;
		if ( t_RegInfo.GetCurrentBinaryKeyValue( L"Type", (LPBYTE) &t_dwType, &t_dwSize ) == ERROR_SUCCESS )
		{
			if ( ( t_dwType == SERVICE_FILE_SYSTEM_DRIVER ) || ( t_dwType == SERVICE_KERNEL_DRIVER ) )
			{
				t_hResult = WBEM_S_NO_ERROR ;
				LoadPropertyValuesWin95( TOBSTRT( t_sName ), a_pInst, t_RegInfo, t_dwType ) ;
			}
		}
	}
	return t_hResult ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::AddDynamicInstancesWin95
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32SystemDriver::AddDynamicInstancesWin95(	MethodContext *a_pMethodContext,
														DWORD dwProperties )
{
	CRegistry	t_RegInfo,
				t_COne ;
	DWORD		t_dwType ;
	bool			t_bAnother,
				t_bDone = false ;
	HRESULT		t_hResult = WBEM_E_FAILED ;
	CInstancePtr t_pInst;

	CHString t_sKey ;
	if( t_RegInfo.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services", KEY_READ ) == ERROR_SUCCESS )
	{
		t_hResult = WBEM_S_NO_ERROR;

		for (	t_bAnother = ( t_RegInfo.GetCurrentSubKeyCount() > 0 );
				t_bAnother && !t_bDone && SUCCEEDED( t_hResult );
				t_bAnother = ( t_RegInfo.NextSubKey() == ERROR_SUCCESS ) )
		{
			t_RegInfo.GetCurrentSubKeyName( t_sKey ) ;

			if ( t_COne.Open( t_RegInfo.GethKey(), t_sKey, KEY_READ ) == ERROR_SUCCESS )
			{
                DWORD t_dwSize = 4;
				if ( t_COne.GetCurrentBinaryKeyValue( L"Type", (LPBYTE) &t_dwType, &t_dwSize) == ERROR_SUCCESS )
				{
					if ( ( t_dwType == SERVICE_FILE_SYSTEM_DRIVER ) || ( t_dwType == SERVICE_KERNEL_DRIVER ) )
					{
                        t_pInst.Attach(CreateNewInstance( a_pMethodContext ));
						LoadPropertyValuesWin95( TOBSTRT( t_sKey ), t_pInst, t_COne, t_dwType ) ;

						t_hResult = t_pInst->Commit(  ) ;
					}
				}
			}
		}
	}

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::LoadPropertyValuesWin95
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
void CWin32SystemDriver::LoadPropertyValuesWin95 (

	LPCTSTR	a_szKey,
	CInstance *a_pInst,
	CRegistry &a_COne,
	DWORD a_dwType
)
{
	CHString	t_sTemp ;
	DWORD		t_dwTemp ;

	a_pInst->SetCHString( IDS_Name, a_szKey ) ;
	a_pInst->SetCHString( IDS_CreationClassName, PROPSET_NAME_SYSTEM_DRIVER ) ;
	a_pInst->SetCHString( IDS_SystemCreationClassName, PROPSET_NAME_COMPSYS ) ;
	a_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;

//   a_pInst->SetCharSplat( "State",  ) ;
//   a_pInst->Setbool( "Started",  ) ;
//   a_pInst->Setbool( "AcceptStop", (StatusInfo.dwControlsAccepted) & SERVICE_ACCEPT_STOP ) ;
//   a_pInst->Setbool( "AcceptPause", (StatusInfo.dwControlsAccepted) & SERVICE_ACCEPT_PAUSE_CONTINUE ) ;

   // These may get overwritten below if we can find something better

	a_pInst->SetCHString( IDS_Caption, a_szKey ) ;
	a_pInst->SetCHString( IDS_DisplayName, a_szKey ) ;
	a_pInst->SetCHString( IDS_Description, a_szKey ) ;

	switch ( a_dwType & (~SERVICE_INTERACTIVE_PROCESS) )
	{
		case SERVICE_WIN32_OWN_PROCESS:
		{
			a_pInst->SetCHString( IDS_ServiceType, L"Own Process" ) ;
		}
		break ;

		case SERVICE_WIN32_SHARE_PROCESS:
		{
			a_pInst->SetCharSplat( IDS_ServiceType, L"Share Process" ) ;
		}
		break ;

		case SERVICE_KERNEL_DRIVER:
		{
			a_pInst->SetCharSplat( IDS_ServiceType, L"Kernel Driver" ) ;
		}
		break ;

		case SERVICE_FILE_SYSTEM_DRIVER:
		{
			a_pInst->SetCharSplat( IDS_ServiceType, L"File System Driver" ) ;
		}
		break ;

		default:
		{
			a_pInst->SetCharSplat( IDS_ServiceType, L"Unknown" ) ;
		}
		break ;
	}

	a_pInst->Setbool( IDS_DesktopInteract, a_dwType & SERVICE_INTERACTIVE_PROCESS ) ;

    DWORD t_dwSize = 4;
	if (a_COne.GetCurrentBinaryKeyValue( L"Start", (LPBYTE) &t_dwTemp, &t_dwSize ) == ERROR_SUCCESS )
	{
		switch ( t_dwTemp )
		{
			case SERVICE_BOOT_START:
			{
				a_pInst->SetCharSplat( IDS_StartMode, L"Boot" ) ;
			}
			break ;

			case SERVICE_SYSTEM_START:
			{
				a_pInst->SetCharSplat( IDS_StartMode, L"System" ) ;
			}
			break ;

			case SERVICE_AUTO_START:
			{
				a_pInst->SetCharSplat( IDS_StartMode, L"Auto" ) ;
			}
			break ;

			case SERVICE_DEMAND_START:
			{
				a_pInst->SetCharSplat( IDS_StartMode, L"Manual" ) ;
			}
			break ;

			case SERVICE_DISABLED:
			{
				a_pInst->SetCharSplat( IDS_StartMode, L"Disabled" ) ;
			}
			break ;

			default:
			{
				a_pInst->SetCharSplat( IDS_StartMode, L"Unknown" ) ;
			}
			break ;
		}
	}

    t_dwSize = 4;
	if ( a_COne.GetCurrentBinaryKeyValue( L"ErrorControl", (LPBYTE)&t_dwTemp, &t_dwSize) == ERROR_SUCCESS )
	{
		switch ( t_dwTemp )
		{
			case SERVICE_ERROR_IGNORE:
			{
				a_pInst->SetCHString( IDS_ErrorControl, L"Ignore" ) ;
			}
			break ;

			case SERVICE_ERROR_NORMAL:
			{
				a_pInst->SetCharSplat( IDS_ErrorControl, L"Normal" ) ;
			}
			break ;

			case SERVICE_ERROR_SEVERE:
			{
				a_pInst->SetCharSplat( IDS_ErrorControl, L"Severe" ) ;
			}
			break ;

			case SERVICE_ERROR_CRITICAL:
			{
				a_pInst->SetCharSplat( IDS_ErrorControl, L"Critical" ) ;
			}
			break ;

			default:
			{
				a_pInst->SetCharSplat( IDS_ErrorControl, L"Unknown" ) ;
			}
			break ;
		}
	}

	if ( a_COne.GetCurrentKeyValue( L"ImagePath", t_sTemp ) == ERROR_SUCCESS )
	{
		a_pInst->SetCHString( IDS_PathName, t_sTemp ) ;
	}

	if (a_COne.GetCurrentKeyValue( L"ObjectName", t_sTemp ) == ERROR_SUCCESS )
	{
		a_pInst->SetCHString( IDS_StartName, t_sTemp ) ;
	}

	if (a_COne.GetCurrentKeyValue( L"Tag", t_dwTemp ) == ERROR_SUCCESS )
	{
		a_pInst->SetDWORD( IDS_TagId, t_dwTemp ) ;
	}
	else
	{
		a_pInst->SetDWORD( IDS_TagId, 0 ) ;
	}

	// The display name would make a better description and caption if we can get it

	if ( a_COne.GetCurrentKeyValue( L"DisplayName", t_sTemp ) == ERROR_SUCCESS )
	{
		a_pInst->SetCHString( IDS_DisplayName, t_sTemp ) ;
		a_pInst->SetCHString( IDS_Caption, t_sTemp ) ;
		a_pInst->SetCHString( IDS_Description, t_sTemp ) ;
	}
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PutInstance
 *
 *  DESCRIPTION : Allows caller to assign state to service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : BOOL indicating success/failure
 *
 *  COMMENTS    : We don't wait around for the service to start, pause or stop --
 *                the return code simply indicates that the command was success-
 *                fully received by the Service Control Manager.
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver::PutInstance (

	const CInstance &a_Instance,
	long lFlags /*= 0L*/
)
{
    DWORD dwFlags = lFlags & 3;

#ifdef WIN9XONLY
	HRESULT t_Result = WBEM_E_NOT_SUPPORTED ;
#endif

#ifdef NTONLY
	if ( ( dwFlags != WBEM_FLAG_CREATE_OR_UPDATE ) && ( dwFlags != WBEM_FLAG_UPDATE_ONLY ) )
	{
		return WBEM_E_UNSUPPORTED_PARAMETER ;
	}

    CInstancePtr t_Instance;

	CHString t_State ;
    CHString t_RelPath;

    a_Instance.GetCHString ( IDS___Relpath, t_RelPath);
	a_Instance.GetCHString ( IDS_State , t_State ) ;

    // Only need to make sure it exists
	HRESULT t_Result = CWbemProviderGlue :: GetInstanceKeysByPath ( t_RelPath, &t_Instance, a_Instance.GetMethodContext() ) ;
	if ( FAILED(t_Result) )
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			if ( dwFlags == WBEM_FLAG_CREATE_OR_UPDATE )
			{
				return WBEM_E_UNSUPPORTED_PARAMETER ;
			}
			else if ( ( dwFlags & WBEM_FLAG_UPDATE_ONLY ) == dwFlags )
			{
				return t_Result ;
			}
			else
			{
				return t_Result ;
			}
		}
		else
		{
			return t_Result ;
		}
	}

	t_Result = WBEM_E_NOT_SUPPORTED ;

	CInstance *t_OutParam = NULL ;
	if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_RUNNING ) == 0 )
	{
		t_Result = ExecStart ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_PAUSED ) == 0 )
	{
		t_Result = ExecPause ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_STOPPED ) == 0 )
	{
		t_Result = ExecStop ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else
	{
	}
#endif

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\tapedrive.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  tapedrive.h
//
//  Purpose: tapedrive property set provider 
//
//***************************************************************************

#ifndef _TAPEDRIVE_H
#define _TAPEDRIVE_H

// Property set identification
//============================

// Property set identification
//============================

#define PROPSET_NAME_TAPEDRIVE				L"Win32_TapeDrive"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFFFFFFFFFFi64
#define SPECIAL_PROPS_NONE_REQUIRED         0x0000000000000000i64
#define SPECIAL_PROPS_AVAILABILITY		0x0000000000000002i64
#define SPECIAL_PROPS_STATUS			0x0000000000000004i64
#define SPECIAL_PROPS_DEVICEID			0x0000000000000008i64
#define SPECIAL_PROPS_CREATIONNAME		0x0000000000000010i64
#define SPECIAL_PROPS_SYSTEMNAME		0x0000000000000020i64
#define SPECIAL_PROPS_DESCRIPTION		0x0000000000000040i64
#define SPECIAL_PROPS_CAPTION			0x0000000000000080i64
#define SPECIAL_PROPS_NAME			0x0000000000000100i64
#define SPECIAL_PROPS_MANUFACTURER		0x0000000000000200i64
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x0000000000000400i64
#define SPECIAL_PROPS_SCSITARGETID		0x0000000000000800i64
#define SPECIAL_PROPS_ID			0x0000000000002000i64
#define SPECIAL_PROPS_CAPABILITY		0x0000000000004000i64
#define SPECIAL_PROPS_MEDIATYPE			0x0000000000008000i64
#define SPECIAL_PROPS_VOLUMENAME		0x0000000000010000i64
#define SPECIAL_PROPS_MAXCOMPONENTLENGTH	0x0000000000020000i64
#define SPECIAL_PROPS_FILESYSTEMFLAGS		0x0000000000040000i64
#define SPECIAL_PROPS_SERIALNUMBER		0x0000000000080000i64
#define SPECIAL_PROPS_SIZE			0x0000000000100000i64
#define SPECIAL_PROPS_MEDIALOADED		0x0000000000200000i64
#define SPECIAL_PROPS_PNPDEVICEID		0x0000000000400000i64
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x0000000000800000i64
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x0000000001000000i64
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x0000000002000000i64
#define SPECIAL_PROPS_ECC			0x0000000004000000i64
#define SPECIAL_PROPS_COMPRESSION		0x0000000008000000i64
#define SPECIAL_PROPS_PADDING			0x0000000010000000i64
#define SPECIAL_PROPS_REPORTSETMARKS		0x0000000020000000i64
#define SPECIAL_PROPS_DEFAULTBLOCKSIZE		0x0000000040000000i64
#define SPECIAL_PROPS_MAXIMUMBLOCKSIZE		0x0000000080000000i64
#define SPECIAL_PROPS_MINIMUMBLOCKSIZE		0x0000000100000000i64
#define SPECIAL_PROPS_MAXPARTITIONCOUNT		0x0000000200000000i64
#define SPECIAL_PROPS_FEATURESLOW		0x0000000400000000i64
#define SPECIAL_PROPS_FEATUREHIGH		0x0000000800000000i64
#define SPECIAL_PROPS_ENDOFTAPEWARNINGZONESIZE	0x0000001000000000i64
#define SPECIAL_PROPS_STATUSINFO		0x0000002000000000i64

#define SPECIAL_CONFIGMANAGER		( SPECIAL_CONFIGPROPERTIES | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_ID | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_AVAILABILITY | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_STATUSINFO )

#define SPECIAL_MEDIA				( SPECIAL_PROPS_CAPABILITY | \
									SPECIAL_PROPS_MEDIATYPE )

#define SPECIAL_TAPEINFO			( SPECIAL_PROPS_ECC | \
									SPECIAL_PROPS_COMPRESSION | \
									SPECIAL_PROPS_PADDING | \
									SPECIAL_PROPS_REPORTSETMARKS | \
									SPECIAL_PROPS_DEFAULTBLOCKSIZE | \
									SPECIAL_PROPS_MAXIMUMBLOCKSIZE | \
									SPECIAL_PROPS_MINIMUMBLOCKSIZE | \
									SPECIAL_PROPS_MAXPARTITIONCOUNT | \
									SPECIAL_PROPS_FEATURESLOW | \
									SPECIAL_PROPS_FEATUREHIGH | \
									SPECIAL_PROPS_ENDOFTAPEWARNINGZONESIZE )

#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA | \
									SPECIAL_TAPEINFO )

#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000
	
class CWin32TapeDrive : public Provider
{
		// Utility
		//========
    private:
	
        UINT64 GetBitMask(CFrameworkQuery &a_Query);
		HRESULT LoadPropertyValues( CInstance *a_pInst, CConfigMgrDevice *a_pDevice ) ;
        BOOL IsTapeDrive( CConfigMgrDevice *a_Device );

#ifdef WIN9XONLY
		HRESULT LoadPropertyValues9X( CInstance *a_pInst, CConfigMgrDevice *a_pDevice ) ;
#elif NTONLY == 4
		HRESULT LoadPropertyValuesNT( CInstance *a_pInst, CConfigMgrDevice *a_pDevice ) ;
        void GetDosDeviceName(CConfigMgrDevice *a_pDevice, CHString &a_sDeviceName);
#endif
	
	protected:

	#if NTONLY >= 5
		CRITICAL_SECTION m_CriticalSection ;
	
        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			UINT64 a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

		HRESULT LoadPropertyValues ( 

			CInstance *a_Instance, 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const TCHAR *a_DosDeviceNameList ,
			UINT64 a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

		HRESULT LoadConfigManagerPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			UINT64 a_SpecifiedPropertied
		) ;

		HRESULT GetDeviceInformation ( 

			CInstance *a_Instance ,
			CConfigMgrDevice *a_Device , 
			CHString a_DeviceName , 
			CHString &a_DosDeviceName ,
			const TCHAR *a_DosDeviceNameList ,
			UINT64 a_SpecifiedPropertied
		) ;

		HRESULT LoadMediaPropertyValues (	

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const CHString &a_DosDeviceName , 
			UINT64 a_SpecifiedPropertied 
		) ;
	#endif

public:

        // Constructor/destructor
        //=======================

        CWin32TapeDrive ( LPCWSTR a_pszName, LPCWSTR a_pszNamespace ) ;
       ~CWin32TapeDrive () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( 

			CInstance *a_Instance, 
			long a_Flags,
            CFrameworkQuery &a_Query
		) ;

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

#if NTONLY >= 5
		HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;
#endif

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\tapedrive.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  tapedrive.cpp
//
//  Purpose: Tape Drive Managed Object implementation
//
//***************************************************************************

#include "precomp.h"
#include <ntddtape.h>           // for TAPE_GET_DRIVE_PARAMETERS
#include <ProvExce.h>

#include "tapedrive.h"

// Property set declaration
//=========================
#ifdef WIN9XONLY
#define CONFIG_MANAGER_CLASS_TAPEDRIVE L"Tape"
#else
#define CONFIG_MANAGER_CLASS_TAPEDRIVE L"TapeDrive"
#endif

CWin32TapeDrive MyCWin32TapeDriveSet( PROPSET_NAME_TAPEDRIVE, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::CWin32TapeDrive
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32TapeDrive::CWin32TapeDrive( LPCWSTR a_name, LPCWSTR a_pszNamespace )
: Provider( a_name, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::~CWin32TapeDrive
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32TapeDrive::~CWin32TapeDrive()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32TapeDrive::GetObject( CInstance *a_pInst, long a_lFlags, CFrameworkQuery &a_Query)
{
	HRESULT		t_hResult = WBEM_E_NOT_FOUND;
	CHString	t_sDeviceID;

	a_pInst->GetCHString( IDS_DeviceID, t_sDeviceID ) ;

    CConfigManager cfgmgr;
    CConfigMgrDevicePtr pDevice;

    if ( cfgmgr.LocateDevice ( t_sDeviceID , & pDevice ) )
    {
		// Ok, it knows about it.  Is it a PNPEntity device?
		if ( IsTapeDrive ( pDevice ) )
        {
    	    t_hResult = LoadPropertyValues( a_pInst, pDevice ) ;
        }
    }

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32TapeDrive::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
    HRESULT t_Result = WBEM_E_FAILED ;

    CConfigManager t_ConfigurationManager ;
    CDeviceCollection t_DeviceList ;

    if ( t_ConfigurationManager.GetDeviceListFilterByClass ( t_DeviceList , CONFIG_MANAGER_CLASS_TAPEDRIVE ) )
    {
        REFPTR_POSITION t_Position ;

        if ( t_DeviceList.BeginEnum( t_Position ) )
        {
			CConfigMgrDevicePtr t_Device;

			t_Result = WBEM_S_NO_ERROR ;

			// Walk the list
            for (t_Device.Attach( t_DeviceList.GetNext ( t_Position ) );
                 SUCCEEDED( t_Result ) && (t_Device != NULL);
                 t_Device.Attach( t_DeviceList.GetNext ( t_Position ) ))
			{
				// Now to find out if this is the tapedrive

				if ( IsTapeDrive ( t_Device ) )
				{
					CInstancePtr t_Instance (CreateNewInstance ( a_pMethodContext ), false) ;

                   if (SUCCEEDED(LoadPropertyValues( t_Instance, t_Device )))
					{
						t_Result = t_Instance->Commit (  ) ;
					}
				}
			}

			// Always call EndEnum().  For all Beginnings, there must be an End
			t_DeviceList.EndEnum () ;
        }
    }

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::LoadPropertyValues
 *
 *  DESCRIPTION : On a Win95 platform, moves the data from the registry
 *                into the instance.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of tape drives found
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32TapeDrive::LoadPropertyValues( CInstance *a_pInst, CConfigMgrDevice *a_pDevice )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString t_sTemp;

	SetConfigMgrProperties ( a_pDevice, a_pInst ) ;

	if ( a_pDevice->GetDeviceID ( t_sTemp ) )
	{
		a_pInst->SetCHString ( IDS_DeviceID , t_sTemp ) ;
		a_pInst->SetCHString ( IDS_PNPDeviceID , t_sTemp ) ;
	}

    t_sTemp.Empty();
	if ( a_pDevice->GetDeviceDesc ( t_sTemp ) )
	{
		a_pInst->SetCHString( IDS_Description, t_sTemp ) ;
    	a_pInst->SetCHString( IDS_Caption, t_sTemp ) ;
        a_pInst->SetCHString( IDS_Name, t_sTemp ) ;
    }

	if (a_pDevice->GetFriendlyName ( t_sTemp ) )
    {
    	a_pInst->SetCHString( IDS_Name, t_sTemp ) ;
    	a_pInst->SetCHString( IDS_Caption, t_sTemp ) ;
    }

	if ( a_pDevice->GetMfg ( t_sTemp ) )
    {
        a_pInst->SetCHString( IDS_Manufacturer, t_sTemp ) ;
    }

    SAFEARRAYBOUND t_ArrayBounds ;

    t_ArrayBounds.cElements = 2;
    t_ArrayBounds.lLbound = 0;

    variant_t t_CapabilityValue ;

    if ( V_ARRAY ( & t_CapabilityValue ) = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
    {
        V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;
        long t_Capability = 2 ;
        long t_Index = 0;
        SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ) , & t_Index , & t_Capability) ;

        t_Index = 1;
        t_Capability = 7 ;
        SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ) , & t_Index , & t_Capability ) ;

        a_pInst->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;
    }

	a_pInst->SetWBEMINT16(IDS_Availability, 3 ) ;
	a_pInst->SetWCHARSplat( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;
	a_pInst->SetCHString(  IDS_SystemName, GetLocalComputerName() )  ;
	a_pInst->SetWCHARSplat( IDS_MediaType, L"Tape Drive");	// it's in the mof!
    a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_OK ) ; 

    SetCreationClassName( a_pInst ) ;

#ifdef WIN9XONLY
    hr = LoadPropertyValues9X(a_pInst, a_pDevice);
#else
    hr = LoadPropertyValuesNT(a_pInst, a_pDevice);
#endif

    return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : LoadPropertyValues
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
BOOL CWin32TapeDrive::IsTapeDrive( CConfigMgrDevice *a_Device )
{
    BOOL t_Status = a_Device->IsClass(CONFIG_MANAGER_CLASS_TAPEDRIVE) ;

    return t_Status ;
}

/*****************************************************************************
 *
 *  FUNCTION    : LoadPropertyValuesNT
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32TapeDrive::LoadPropertyValuesNT(CInstance *a_pInstance, CConfigMgrDevice *a_pDevice)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;
    CHString t_sDeviceName;

    GetDosDeviceName(a_pDevice, t_sDeviceName);

    SmartCloseHandle t_hTape = CreateFile(	t_sDeviceName,
        GENERIC_READ,	//Should work with 0 here but doesn't !
        0,				//share mode - not used
        0,				//security - not used
        OPEN_EXISTING,	//required for tape devices
        0,				//attributes - not used
        NULL			//handle to copy attributes - not used
        );

    DWORD t_LastError = GetLastError () ;
    if ( ( t_hTape != INVALID_HANDLE_VALUE ) || ( t_LastError == ERROR_BUSY || t_LastError == ERROR_SHARING_VIOLATION ) ) //tape drive exists
    {
        //tape drive exists

        if ( t_hTape != INVALID_HANDLE_VALUE )
        {
            DWORD	t_dSize, t_dRet;
            TAPE_GET_DRIVE_PARAMETERS t_DriveParams ;

            // While the docs indicate that this is an OUT param, experience
            // shows that it is an IN param too.
            t_dSize = sizeof(TAPE_GET_DRIVE_PARAMETERS);

            //Get info on drive, using Win32 API function
            //===========================================
            t_dRet = GetTapeParameters( t_hTape,
                GET_TAPE_DRIVE_INFORMATION,
                &t_dSize,
                &t_DriveParams ) ;

            if ( t_dRet == NO_ERROR ) //retrieved parameters OK
            {
                a_pInstance->SetDWORD( IDS_ECC, (DWORD) t_DriveParams.ECC ) ;
                a_pInstance->SetDWORD( IDS_Compression, (DWORD) t_DriveParams.Compression ) ;
                a_pInstance->SetDWORD( IDS_Padding, (DWORD) t_DriveParams.DataPadding ) ;
                a_pInstance->SetDWORD( IDS_ReportSetMarks, (DWORD) t_DriveParams.ReportSetmarks ) ;
                a_pInstance->SetWBEMINT64( IDS_DefaultBlockSize, (ULONGLONG)t_DriveParams.DefaultBlockSize ) ;
                a_pInstance->SetWBEMINT64( IDS_MaximumBlockSize, (ULONGLONG)t_DriveParams.MaximumBlockSize ) ;
                a_pInstance->SetWBEMINT64( IDS_MinimumBlockSize, (ULONGLONG)t_DriveParams.MinimumBlockSize ) ;
                a_pInstance->SetDWORD( IDS_MaximumPartitionCount, t_DriveParams.MaximumPartitionCount ) ;
                a_pInstance->SetDWORD( IDS_FeaturesLow, t_DriveParams.FeaturesLow ) ;
                a_pInstance->SetDWORD( IDS_FeaturesHigh, t_DriveParams.FeaturesHigh ) ;
                a_pInstance->SetDWORD( IDS_EndOfTapeWarningZoneSize, t_DriveParams.EOTWarningZoneSize ) ;
            }
        }
    }
    else
    {
        t_hResult = WinErrorToWBEMhResult( GetLastError() ) ;
    }

    return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDosDeviceName
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
void CWin32TapeDrive::GetDosDeviceName(CConfigMgrDevice *a_pDevice, CHString &a_sDeviceName)
{
    a_sDeviceName.Empty();
    CHString t_sDriverName;

    if (a_pDevice->GetDriver(t_sDriverName))
    {
        DWORD dwDriveNum = 0xffffffff;

        if (swscanf(t_sDriverName, L"{6D807884-7D21-11CF-801C-08002BE10318}\\%d", &dwDriveNum) == 1)
        {
            a_sDeviceName.Format(L"\\\\.\\TAPE%ld", dwDriveNum);
        }
    }
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : LoadPropertyValues9X
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef WIN9XONLY
HRESULT CWin32TapeDrive::LoadPropertyValues9X(CInstance *a_pInstance, CConfigMgrDevice *a_pDevice)
{
    return WBEM_S_NO_ERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\tapiapi.cpp ===
//=================================================================

//

// TapiAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cominit.h>

#include <tapi.h>
#include "DllWrapperBase.h"
#include "TapiApi.h"
#include "DllWrapperCreatorReg.h"
#include <createmutexasprocess.h>

// {73E9A405-0FA4-11d3-910C-00105AA630BE}
static const GUID g_guidTapi32Api =
{ 0x73e9a405, 0xfa4, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrTapi32 [] = _T("Tapi32.Dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CTapi32Api, &g_guidTapi32Api, g_tstrTapi32> MyRegisteredTapi32Wrapper;

/******************************************************************************
 * Constructor
 *****************************************************************************/
CTapi32Api :: CTapi32Api (

	LPCTSTR a_tstrWrappedDllName

) : CDllWrapperBase ( a_tstrWrappedDllName ),
	m_pfnlineInitialize(NULL),
	m_pfnlineShutdown(NULL),
	m_pfnlineNegotiateAPIVersion(NULL) ,
	m_pfnlineGetDevCaps(NULL) ,
	m_pfnlineGetID(NULL),
	m_pfnlineOpen(NULL)
{
}

/******************************************************************************
 * Destructor
 *****************************************************************************/
CTapi32Api::~CTapi32Api()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CTapi32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef UNICODE
		m_pfnlineGetDevCaps = ( PFN_Tapi_lineGetDevCaps ) GetProcAddress ( "lineGetDevCapsW" ) ;
		m_pfnlineGetID = ( PFN_Tapi_lineGetID ) GetProcAddress ( "lineGetIDW" ) ;
		m_pfnlineOpen = ( PFN_Tapi_lineOpen ) GetProcAddress ( "lineOpenW" ) ;
#else
		// No 'A' on the end because 95 doesn't have lineGetDevCapsA.  But both 95 and 98
        // have lineGetDevCaps.
        m_pfnlineGetDevCaps = ( PFN_Tapi_lineGetDevCaps ) GetProcAddress ( "lineGetDevCaps" ) ;
		m_pfnlineGetID = ( PFN_Tapi_lineGetID ) GetProcAddress ( "lineGetIDA" ) ;
		m_pfnlineOpen = ( PFN_Tapi_lineOpen ) GetProcAddress ( "lineOpenA" ) ;
#endif

		m_pfnlineInitialize = ( PFN_Tapi_lineInitialize ) GetProcAddress ( "lineInitialize" ) ;
		m_pfnlineShutdown = ( PFN_Tapi_lineShutdown ) GetProcAddress ( "lineShutdown" ) ;
		m_pfnlineNegotiateAPIVersion = ( PFN_Tapi_lineNegotiateAPIVersion ) GetProcAddress ( "lineNegotiateAPIVersion" ) ;
    }

    // We require these function for all versions of this dll.

	if ( m_pfnlineInitialize == NULL ||
	    m_pfnlineShutdown == NULL ||
	    m_pfnlineNegotiateAPIVersion == NULL ||
		m_pfnlineGetDevCaps == NULL ||
		m_pfnlineGetID == NULL ||
		m_pfnlineOpen == NULL )
	{
        fRet = false;
	}

    return fRet;
}

/******************************************************************************
 * Member functions wrapping Tapi api functions. Add new functions here
 * as required.
 *****************************************************************************/

LONG CTapi32Api :: lineInitialize (

	LPHLINEAPP lphLineApp,
    HINSTANCE hInstance,
    LINECALLBACK lpfnCallback,
    LPCSTR lpszAppName,
    LPDWORD lpdwNumDevs
)
{
	return m_pfnlineInitialize (

		lphLineApp,
		hInstance,
		lpfnCallback,
		lpszAppName,
		lpdwNumDevs

	) ;
}

LONG CTapi32Api :: lineShutdown (

	HLINEAPP hLineApp
)
{
	return m_pfnlineShutdown (

		hLineApp

	) ;
}

LONG CTapi32Api :: lineNegotiateAPIVersion (

	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	DWORD dwAPILowVersion,
	DWORD dwAPIHighVersion,
	LPDWORD lpdwAPIVersion,
	LPLINEEXTENSIONID lpExtensionID
)
{
	return m_pfnlineNegotiateAPIVersion (

		hLineApp,
		dwDeviceID,
		dwAPILowVersion,
		dwAPIHighVersion,
		lpdwAPIVersion,
		lpExtensionID

	) ;
}

LONG CTapi32Api :: TapilineGetDevCaps (

    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    DWORD dwAPIVersion,
    DWORD dwExtVersion,
    LPLINEDEVCAPS lpLineDevCaps
)
{
	return m_pfnlineGetDevCaps (

		hLineApp,
		dwDeviceID,
		dwAPIVersion,
		dwExtVersion,
		lpLineDevCaps
	) ;
}

#ifdef UNICODE
LONG CTapi32Api :: TapilineGetID (

		HLINE hLine,
		DWORD dwAddressID,
		HCALL hCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass
)
#else
LONG CTapi32Api :: TapilineGetID (

		HLINE hLine,
		DWORD dwAddressID,
		HCALL hCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCSTR lpszDeviceClass
)
#endif
{
	return m_pfnlineGetID (

		hLine,
		dwAddressID,
		hCall,
		dwSelect,
		lpDeviceID,
		lpszDeviceClass
	) ;
}

LONG CTapi32Api :: TapilineOpen (

	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	LPHLINE lphLine,
	DWORD dwAPIVersion,
	DWORD dwExtVersion,
	DWORD_PTR dwCallbackInstance,
	DWORD dwPrivileges,
	DWORD dwMediaModes,
	LPLINECALLPARAMS const lpCallParams
)
{
	return m_pfnlineOpen (

		hLineApp,
		dwDeviceID,
		lphLine,
		dwAPIVersion,
		dwExtVersion,
		dwCallbackInstance,
		dwPrivileges,
		dwMediaModes,
		lpCallParams
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\threadprov.cpp ===
//=======================================================================

// ThreadProv.cpp

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//=======================================================================


#include "precomp.h"
#include "SystemName.h"
#include <winperf.h>

#include "ThreadProv.h"
#include "WBemNTThread.h"
#include <tchar.h>

/*
 * This function gets the Priority of a thread, given the priority of the ProcessClass & the PriorityValue of the thread.
 */
DWORD GetThreadPriority ( DWORD a_dwPriorityOfProcessClass , int a_PriorityValue ) ;
// Property set declaration
//=========================
WbemThreadProvider MyThreadSet(PROPSET_NAME_THREAD, IDS_CimWin32Namespace) ;

//=============================
// WBEM thread provider follows
//=============================
WbemThreadProvider::WbemThreadProvider( LPCWSTR a_name, LPCWSTR a_pszNamespace )
: Provider( a_name, a_pszNamespace )
{
	#ifdef NTONLY
			m_pTheadAccess = new WbemNTThread ;
	#endif
	#ifdef WIN9XONLY
			m_pTheadAccess = new CWin9xThread ;
	#endif

	if( !m_pTheadAccess )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}
}

WbemThreadProvider::~WbemThreadProvider()
{
    if( m_pTheadAccess )
	{
		delete m_pTheadAccess ;
	}
}

void WbemThreadProvider::Flush()
{
	// unload suppport DLLs and resources to keep the footprint down
	if( m_pTheadAccess )

	m_pTheadAccess->fUnLoadResourcesTry() ;	// should always work here

	Provider::Flush() ;
}

HRESULT WbemThreadProvider::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
	if( m_pTheadAccess )
	{
		if( m_pTheadAccess->AddRef() )
		{
			HRESULT t_hResult = m_pTheadAccess->eGetThreadObject( this, a_pInst ) ;

			m_pTheadAccess->Release() ;

			return t_hResult ;
		}
	}
	return WBEM_E_FAILED ;
}


HRESULT WbemThreadProvider::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	if( m_pTheadAccess )
	{
		if( m_pTheadAccess->AddRef() )
		{
			HRESULT t_hResult = m_pTheadAccess->eEnumerateThreadInstances( this , a_pMethodContext ) ;

			m_pTheadAccess->Release() ;

			return t_hResult ;
		}
	}
	return WBEM_E_FAILED ;
}


//=======================================
// Common thread extraction model follows
//=======================================
CThreadModel::CThreadModel() {}
CThreadModel::~CThreadModel() {}

WBEMSTATUS CThreadModel::eLoadCommonThreadProperties( WbemThreadProvider *a_pProv, CInstance *a_pInst )
{
//	CHString t_chsScratch ;

	if( !a_pInst )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	/* CIM_Thread properties follow */

	a_pProv->SetCreationClassName( a_pInst ) ;	// IDS_CreationClassName

	a_pInst->SetWCHARSplat( IDS_CSCreationClassName, L"Win32_ComputerSystem" ) ;
	a_pInst->SetCHString( IDS_CSName, a_pProv->GetLocalComputerName() ) ;

	// REVIEW: is IDS_ProcessCreationClassName the same as IDS_CreationClassName?
//	a_pInst->GetCHString( IDS_CreationClassName, t_chsScratch ) ;

	a_pInst->SetWCHARSplat( IDS_ProcessCreationClassName, L"Win32_Process" ) ;

	// REVIEW:
	// Provider.cpp shows "Win32_OperatingSystem" for NT but " " for Win95
	// We'll keep it the same here for now
	a_pInst->SetWCHARSplat(IDS_OSCreationClassName, L"Win32_OperatingSystem" ) ;

	// OSName

	CSystemName t_cSN ;

	a_pInst->SetCHString( IDS_OSName, t_cSN.GetLongKeyName() ) ;
	// Note: the following are supplied in the OS specific derived class

	/* Note:	These following two properties are keys.
				If called via GetObject() these	keys should be valid
				and and need not be filled in. Although a sanity check should be made.
				If called via EnumerateInstances() the keys will not be present
				and must be filled in.
	// ProcessHandle	( ProcessID )
	// Handle			( ThreadID )

	/* CIM_Thread properties */
	// Priority
	// ExecutionState
	// UserModeTime
	// KernelModeTime

	/* Win32_Thread properties */
	// ElapesedTime
	// PriorityBase
	// StartAddress
	// ThreadState
	// ThreadWaitreason

	return WBEM_NO_ERROR ;
}

//
ULONG CThreadModel::AddRef()
{
	ULONG t_uRefCount;

	BeginWrite() ;
    try
    {

	    if( 2 == ( t_uRefCount = CThreadBase::AddRef()) )			// 1st ref after initialization.
	    {
		    fLoadResources() ;	// Check to see if resources are here.
	    }
    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite() ;

	return t_uRefCount ;
}

//
HRESULT CThreadModel::hrCanUnloadNow()
{
	ULONG t_uRefCount = CThreadBase::AddRef() ;
						 CThreadBase::Release() ;

	return ( 2 == t_uRefCount ) ?  S_OK : S_FALSE ;
}

// Called by WbemThreadProvider::Flush() when idle for awhile.
// Attempt to unload support DLL's, instance independent memory blocks, etc
BOOL CThreadModel::fUnLoadResourcesTry()
{
	BOOL t_fRet = FALSE ;

	BeginWrite() ;

    try
    {
	    if( S_OK == hrCanUnloadNow() )
	    {
		    if( ERROR_SUCCESS == fUnLoadResources() )
		    {
			    t_fRet = TRUE ;
		    }
	    }
    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite() ;

	return t_fRet ;
}

//=============================================
// Win9x implementation of thread model follows
//=============================================
CWin9xThread::CWin9xThread(){}
CWin9xThread::~CWin9xThread(){}

//------------------------------------------------------------
// Support for resource allocation, initializations, DLL loads
//
//-----------------------------------------------------------
LONG CWin9xThread::fLoadResources()
{
	return ERROR_SUCCESS ;
}

//--------------------------------------------------
// Support for resource deallocation and DLL unloads
//
//--------------------------------------------------
LONG CWin9xThread::fUnLoadResources()
{
	return ERROR_SUCCESS ;
}

//---------------------------------------
// Populate Thread properties by instance
//
//---------------------------------------
WBEMSTATUS CWin9xThread::eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst )
{
 	WBEMSTATUS t_wStatus = WBEM_E_FAILED ;

	// Extract the process and thread handles
    // ======================================
	CHString t_chsHandle ;

	SmartCloseHandle t_hSnapshot;

	a_pInst->GetCHString( IDS_ProcessHandle, t_chsHandle ) ;
	DWORD t_dwProcessID = _wtol( t_chsHandle ) ;

	a_pInst->GetCHString( IDS_Handle, t_chsHandle ) ;
	DWORD t_dwThreadID = _wtol( t_chsHandle ) ;

	// Take a thread snapshot by process
	// =================================
	CKernel32Api *t_pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidKernel32Api, NULL ) ;

	if( t_pKernel32 != NULL )
	{
		t_hSnapshot = INVALID_HANDLE_VALUE;
        t_pKernel32->CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, t_dwProcessID, &t_hSnapshot ) ;

		if( INVALID_HANDLE_VALUE == t_hSnapshot )
		{
			return WBEM_E_FAILED ;
		}

		// Step through the threads
		// ========================
		BOOL t_fRetCode ;
		THREADENTRY32 t_oThreadEntry ;

		t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;

		t_fRetCode = false;
        t_pKernel32->Thread32First( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;

		while( t_fRetCode )
		{
			// Thread test
			if( ( 12 <= t_oThreadEntry.dwSize ) &&
				t_dwThreadID == t_oThreadEntry.th32ThreadID )
			{
				// Process test ( redundant
				if( ( 16 <= t_oThreadEntry.dwSize ) &&
					t_dwProcessID == t_oThreadEntry.th32OwnerProcessID )
				{
					// Not much here, but good to go.

	//Uncomment these after updating Instance files

					/* CIM_Thread properties */
	/*				a_pInst->SetNull( IDS_Priority ) ;
					a_pInst->SetNull( IDS_ExecutionState ) ;
					a_pInst->SetNull( IDS_UserModeTime ) ;
					a_pInst->SetNull( IDS_KernelModeTime ) ;
	*/
					/* Win32_Thread properties */
	//				a_pInst->SetNull( IDS_ElapsedTime ) ;
					a_pInst->SetDWORD( IDS_PriorityBase, t_oThreadEntry.tpBasePri ) ;
					a_pInst->SetDWORD( IDS_Priority, GetThreadPriority ( t_oThreadEntry.tpBasePri , t_oThreadEntry.tpDeltaPri ) ) ;
	//				a_pInst->SetNull( IDS_StartAddress ) ;
	//				a_pInst->SetNull( IDS_ThreadState ) ;
	//				a_pInst->SetNull( IDS_ThreadWaitreason ) ;

					// collect the common static properties
					return eLoadCommonThreadProperties( a_pProvider, a_pInst ) ;
				}
			}

			// next
			t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;
			t_pKernel32->Thread32Next( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;
		}

		// not found
		t_wStatus = ( ERROR_NO_MORE_FILES == GetLastError() ) ? WBEM_E_NOT_FOUND : WBEM_E_FAILED ;

		CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidKernel32Api, t_pKernel32 ) ;

		t_pKernel32 = NULL ;
	}

	return t_wStatus;
}

//
WBEMSTATUS CWin9xThread::eEnumerateThreadInstances( WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext )
{
	WBEMSTATUS			t_wStatus = WBEM_E_FAILED ;
	SmartCloseHandle	t_hSnapshot ;

	// Take a process snapshot
	// =======================
	CKernel32Api *t_pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidKernel32Api, NULL ) ;

	if( t_pKernel32 != NULL )
	{
		t_hSnapshot = INVALID_HANDLE_VALUE;
        t_pKernel32->CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0, &t_hSnapshot ) ;

		if( INVALID_HANDLE_VALUE == t_hSnapshot )
		{
			return WBEM_E_FAILED ;
		}

		// Step through the process
		// ========================
		BOOL			t_fRetCode ;
		PROCESSENTRY32	t_oProcessEntry ;

		t_oProcessEntry.dwSize = sizeof( PROCESSENTRY32 ) ;

		t_fRetCode = false;
        t_pKernel32->Process32First( t_hSnapshot, &t_oProcessEntry, &t_fRetCode ) ;

		while( t_fRetCode )
		{
			// Process test ( redundant
			if( 16 <= t_oProcessEntry.dwSize )
			{
				if(	WBEM_NO_ERROR != ( t_wStatus =
					eEnumerateThreadByProcess( a_pMethodContext, a_pProvider,
											   t_oProcessEntry.th32ProcessID ) ) )
				{
					return t_wStatus ;
				}
			}

			// next
			t_oProcessEntry.dwSize = sizeof( PROCESSENTRY32 ) ;

			t_pKernel32->Process32Next( t_hSnapshot, &t_oProcessEntry, &t_fRetCode ) ;
		}

		// not found
		t_wStatus = ( ERROR_NO_MORE_FILES == GetLastError() ) ? WBEM_NO_ERROR : WBEM_E_FAILED ;

		CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidKernel32Api, t_pKernel32 ) ;

		t_pKernel32 = NULL ;
	}
	return t_wStatus ;
}

//--------------------------------------
// Populate Thread properties by Process
//
//--------------------------------------
WBEMSTATUS CWin9xThread::eEnumerateThreadByProcess( MethodContext *a_pMethodContext,
												    WbemThreadProvider *a_pProvider,
												    DWORD a_dwProcessID )
{
 	CHString	t_chsHandle ;
	WBEMSTATUS	t_wStatus  = WBEM_NO_ERROR ;
	SmartCloseHandle t_hSnapshot;

	// Take a thread snapshot by process
	// =================================
	CKernel32Api *t_pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidKernel32Api, NULL ) ;

	if( NULL == t_pKernel32 )
	{
		return WBEM_E_FAILED ;
	}

    t_hSnapshot = INVALID_HANDLE_VALUE;
	t_pKernel32->CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, a_dwProcessID, &t_hSnapshot ) ;

	if( INVALID_HANDLE_VALUE == t_hSnapshot )
	{
		return WBEM_E_FAILED ;
	}

	// Step through the threads
	// ========================
	BOOL t_fRetCode ;
	THREADENTRY32 t_oThreadEntry ;

	t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;

	t_fRetCode = false;
    t_pKernel32->Thread32First( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;

	// smart ptr
	CInstancePtr t_pInst ;

	while( t_fRetCode )
	{
		// Process test
		if( ( 16 <= t_oThreadEntry.dwSize ) &&
			a_dwProcessID == t_oThreadEntry.th32OwnerProcessID )
		{
			// Create an instance
			t_pInst.Attach( a_pProvider->CreateNewInstance( a_pMethodContext ) ) ;

			// ProcesID
			t_chsHandle.Format( L"%lu", t_oThreadEntry.th32OwnerProcessID  ) ;
			t_pInst->SetCHString( IDS_ProcessHandle, t_chsHandle ) ;

			// ThreadID
			t_chsHandle.Format( L"%lu", t_oThreadEntry.th32ThreadID ) ;
			t_pInst->SetCHString( IDS_Handle, t_chsHandle ) ;

			/* CIM_Thread properties */
/*			t_pInst->SetNull( IDS_Priority ) ;
			t_pInst->SetNull( IDS_ExecutionState ) ;
			t_pInst->SetNull( IDS_UserModeTime ) ;
			t_pInst->SetNull( IDS_KernelModeTime ) ;

*/			/* Win32_Thread properties */
//			t_pInst->SetNull( IDS_ElapsedTime ) ;
			t_pInst->SetDWORD( IDS_PriorityBase, t_oThreadEntry.tpBasePri ) ;
			t_pInst->SetDWORD( IDS_Priority, GetThreadPriority ( t_oThreadEntry.tpBasePri , t_oThreadEntry.tpDeltaPri ) ) ;
//			t_pInst->SetNull( IDS_StartAddress ) ;
//			t_pInst->SetNull( IDS_ThreadState ) ;
//			t_pInst->SetNull( IDS_ThreadWaitreason ) ;

			// collect the common static properties
			if( WBEM_NO_ERROR != ( t_wStatus = eLoadCommonThreadProperties( a_pProvider, t_pInst )) )
			{
				break ;
			}

			t_wStatus = (WBEMSTATUS)t_pInst->Commit() ;
		}

        if (SUCCEEDED(t_wStatus))
        {
			// next
			t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;
			t_pKernel32->Thread32Next( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;
        }
        else
        {
            break;
        }
	}

    if (SUCCEEDED(t_wStatus))
    {
    	t_wStatus = ( ERROR_NO_MORE_FILES == GetLastError() ) ? WBEM_NO_ERROR : WBEM_E_FAILED ;
    }

	CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, t_pKernel32 ) ;
	t_pKernel32 = NULL ;

	return t_wStatus ;
}

/*
 * From observations, THREADENTRY32.tpBasePri contains the "BasePriority" of a thread whose "PriorityValue" is THREAD_PRIORITY_NORMAL
 * (or the priority associated with the process class ) .
 * "BasePriority" of a thread is determined by the "PriorityClass" of the process & the "PriorityValue" of the thread. To make things
 * more interesting, the system may increase or lower the "DynamicPriority" of a thread wrt it's "BasePriority"
 * THREADENTRY32.tpDeltaPri contains the "PriorityValue" of the thread.
 */
DWORD GetThreadPriority ( DWORD a_dwPriorityOfProcessClass , int a_PriorityValue )
{
	DWORD t_dwThreadPriority ;

/*
 * If value is THREAD_PRIORITY_NORMAL , then priority is the same as that associated with the process class
 */
	if ( a_PriorityValue == THREAD_PRIORITY_NORMAL )
	{
		t_dwThreadPriority = a_dwPriorityOfProcessClass ;
	}
	else if ( a_PriorityValue == THREAD_PRIORITY_IDLE )
	{
		if ( a_dwPriorityOfProcessClass < 16 )
		{
			t_dwThreadPriority = 1 ;
		}
		else
		{
			t_dwThreadPriority = 16 ;
		}
	}
	else if ( a_PriorityValue == THREAD_PRIORITY_TIME_CRITICAL )
	{
		if ( a_dwPriorityOfProcessClass < 16 )
		{
			t_dwThreadPriority = 15 ;
		}
		else
		{
			t_dwThreadPriority = 31 ;
		}
	}
	else
	{
		t_dwThreadPriority = a_dwPriorityOfProcessClass + a_PriorityValue ;
	}

	return t_dwThreadPriority ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\threadprov.h ===
//=======================================================================

// ThreadProv.h

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//=======================================================================

#include "WBEMToolH.h"

#define  PROPSET_NAME_THREAD L"Win32_Thread"

class WbemThreadProvider;

class WbemNTThread ; //remove this after friend removal

// base model for thread access  
class CThreadModel : public CThreadBase /* reference and thread safety inheritance */
{	
	public:

        // Constructor/destructor
        //=======================
		CThreadModel() ;
		virtual ~CThreadModel() ;
	
		
		// resource control
		//=================
		ULONG		AddRef() ; 
		ULONG		Release() { return CThreadBase::Release() ; } ; 
		BOOL		fUnLoadResourcesTry() ;
		HRESULT		hrCanUnloadNow() ;
		
		// override these to control resource lifetime, use with AddRef() and Release().
		virtual LONG fLoadResources() { return ERROR_SUCCESS ; } ;
		virtual LONG fUnLoadResources() { return ERROR_SUCCESS ; } ;

		// operations
		//===========
		virtual WBEMSTATUS eLoadCommonThreadProperties( WbemThreadProvider *a_pProv, CInstance *a_pInst ) ;
				
		// Pure operations
		//================
		virtual WBEMSTATUS eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst ) = 0 ;
		virtual WBEMSTATUS eEnumerateThreadInstances(WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext ) = 0 ;
};	   

// 
class CWin9xThread : public CThreadModel
{
	public:

        // Constructor/destructor
        //=======================
        CWin9xThread() ;
        virtual ~CWin9xThread() ;

        // overrides
	    //==========
		virtual LONG fLoadResources() ;
		virtual LONG fUnLoadResources() ;
				
		// operations
		//=========== 

	WBEMSTATUS eEnumerateThreadByProcess(	MethodContext		*a_pMethodContext,
											WbemThreadProvider	*a_pProvider,
											DWORD				a_dwProcessID ) ;

			
		// Pure implementations
	    //================
	    virtual WBEMSTATUS eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst ) ;
		virtual WBEMSTATUS eEnumerateThreadInstances( WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext ) ;
};



class WbemThreadProvider: public Provider
{
	private:
		
		CThreadModel *m_pTheadAccess ;

		       // Utility
        //========
	protected:
		
		// override to unload support DLLs
		virtual void Flush(void) ;
	public:

		// Constructor/destructor
        //=======================
        WbemThreadProvider(LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~WbemThreadProvider() ;

        // Functions provide properties with current values
        //=================================================
	virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
	virtual HRESULT GetObject(CInstance *a_pInstance, long a_lFlags = 0L ) ;

	// Lets have a party
	friend CThreadModel;
	friend CWin9xThread;
	friend WbemNTThread;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\tapiapi.h ===
//=================================================================

//

// TapiApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_TapiAPI_H_
#define	_TapiAPI_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidTapi32Api;
extern const TCHAR g_tstrTapi32[];

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef LONG (WINAPI *PFN_Tapi_lineInitialize )
(
		LPHLINEAPP lphLineApp,
		HINSTANCE hInstance,
		LINECALLBACK lpfnCallback,
		LPCSTR lpszAppName,
		LPDWORD lpdwNumDevs
) ;

typedef LONG (WINAPI *PFN_Tapi_lineShutdown )
(
		HLINEAPP hLineApp
) ;

typedef LONG (WINAPI *PFN_Tapi_lineNegotiateAPIVersion )
(
		HLINEAPP hLineApp,
		DWORD dwDeviceID,
		DWORD dwAPILowVersion,
		DWORD dwAPIHighVersion,
		LPDWORD lpdwAPIVersion,
		LPLINEEXTENSIONID lpExtensionID
) ;

typedef LONG ( WINAPI *PFN_Tapi_lineGetDevCaps )
(
		HLINEAPP hLineApp,
		DWORD dwDeviceID,
		DWORD dwAPIVersion,
		DWORD dwExtVersion,
		LPLINEDEVCAPS lpLineDevCaps
);

#ifdef UNICODE
typedef LONG ( WINAPI *PFN_Tapi_lineGetID )
(

	HLINE hLine,
	DWORD dwAddressID,
	HCALL hCall,
	DWORD dwSelect,
	LPVARSTRING lpDeviceID,
	LPCWSTR lpszDeviceClass
) ;
#else
typedef LONG ( WINAPI *PFN_Tapi_lineGetID )
(
	HLINE hLine,
	DWORD dwAddressID,
	HCALL hCall,
	DWORD dwSelect,
	LPVARSTRING lpDeviceID,
	LPCSTR lpszDeviceClass
);
#endif

typedef LONG ( WINAPI *PFN_Tapi_lineOpen )
(
	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	LPHLINE lphLine,
	DWORD dwAPIVersion,
	DWORD dwExtVersion,
	DWORD_PTR dwCallbackInstance,
	DWORD dwPrivileges,
	DWORD dwMediaModes,
	LPLINECALLPARAMS const lpCallParams
) ;

/******************************************************************************
 * Wrapper class for Tapi load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CTapi32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Tapi functions.
    // Add new functions here as required.

	PFN_Tapi_lineInitialize m_pfnlineInitialize ;
	PFN_Tapi_lineShutdown m_pfnlineShutdown ;
	PFN_Tapi_lineNegotiateAPIVersion m_pfnlineNegotiateAPIVersion ;
	PFN_Tapi_lineGetDevCaps m_pfnlineGetDevCaps ;
	PFN_Tapi_lineGetID m_pfnlineGetID ;
	PFN_Tapi_lineOpen m_pfnlineOpen ;

public:

    // Constructor and destructor:
    CTapi32Api(LPCTSTR a_tstrWrappedDllName);
    ~CTapi32Api();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Tapi functions.
    // Add new functions here as required:

	LONG lineInitialize (

		LPHLINEAPP lphLineApp,
		HINSTANCE hInstance,
		LINECALLBACK lpfnCallback,
		LPCSTR lpszAppName,
		LPDWORD lpdwNumDevs
	) ;

	LONG lineShutdown (

		HLINEAPP hLineApp
	) ;

	LONG lineNegotiateAPIVersion (

		HLINEAPP hLineApp,
		DWORD dwDeviceID,
		DWORD dwAPILowVersion,
		DWORD dwAPIHighVersion,
		LPDWORD lpdwAPIVersion,
		LPLINEEXTENSIONID lpExtensionID
	) ;

	LONG TapilineGetDevCaps (

		HLINEAPP hLineApp,
		DWORD dwDeviceID,
		DWORD dwAPIVersion,
		DWORD dwExtVersion,
		LPLINEDEVCAPS lpLineDevCaps
	) ;

#ifdef UNICODE
	LONG TapilineGetID (

		HLINE hLine,
		DWORD dwAddressID,
		HCALL hCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass
    ) ;
#else
	LONG TapilineGetID (

		HLINE hLine,
		DWORD dwAddressID,
		HCALL hCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCSTR lpszDeviceClass
    );
#endif

	LONG TapilineOpen (

	    HLINEAPP hLineApp,
		DWORD dwDeviceID,
		LPHLINE lphLine,
		DWORD dwAPIVersion,
		DWORD dwExtVersion,
		DWORD_PTR dwCallbackInstance,
		DWORD dwPrivileges,
		DWORD dwMediaModes,
		LPLINECALLPARAMS const lpCallParams
    ) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\timezone.cpp ===
///////////////////////////////////////////////////////////////////////

//

// TimeZone.cpp -- Implementation of MO Provider for CD Rom

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  10/15/96     jennymc    Updated to meet current standards
//	03/02/99	 a-peterc	Added graceful exit on SEH and memory failures,
//							clean up
//
///////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <ProvExce.h>

#include "timezone.h"
#include <cregcls.h>

CWin32TimeZone MyTimeZone( PROPSET_NAME_TIMEZONE, IDS_CimWin32Namespace ) ;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32TimeZone::CWin32TimeZone
 Description: CONSTRUCTOR
 Arguments: None
 Returns:   Nothing
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
CWin32TimeZone::CWin32TimeZone( const CHString &a_name, LPCWSTR a_pszNamespace )
:Provider( a_name, a_pszNamespace )
{
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32TimeZone::~CWin32TimeZone
 Description: CONSTRUCTOR
 Arguments: None
 Returns:   Nothing
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
CWin32TimeZone::~CWin32TimeZone()
{
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32TimeZone::GetObject(void)
 Description: Refreshes the property set upon request
 			  This function is only required when you
			  need an update of the properties but the
			  properties are only set in the context of
			  the complete property set like this example
 Arguments: None
 Returns:   TRUE is success else FALSE
 Inputs:
 Outputs:
 Caveats:
     LONG       Bias;
    WCHAR      StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG       StandardBias;
    WCHAR      DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG       DaylightBias;

 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
HRESULT CWin32TimeZone::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
	HRESULT t_hResult ;
	CHString t_chsStandardIn, t_chsStandardOut ;

	a_pInst->GetCHString( IDS_StandardName, t_chsStandardIn ) ;

	if ( GetTimeZoneInfo( a_pInst ) )
	{
		// We got an instance, is it the one they asked for?
		a_pInst->GetCHString( IDS_StandardName, t_chsStandardOut ) ;

		if( t_chsStandardOut.CompareNoCase( t_chsStandardIn ) != 0 )
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
		else
		{
			t_hResult = WBEM_S_NO_ERROR ;
		}
	}
	else
	{
      // Couldn't get an instance
      t_hResult = WBEM_E_FAILED ;
   }

	return t_hResult ;

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: DWORD CWin32TimeZone::EnumerateInstances
 Description: Loops through the process list and add a new
              instance for each process
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
HRESULT CWin32TimeZone::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;

	CInstancePtr t_pInst(CreateNewInstance( a_pMethodContext ), false);
	if ( t_pInst != NULL )
	{
		if( GetTimeZoneInfo( t_pInst ) )
		{
			t_hResult = t_pInst->Commit(  ) ;
		}
	}
	else
	{
		t_hResult = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_hResult;
}

////////////////////////////////////////////////////////////////////////
BOOL CWin32TimeZone::GetTimeZoneInfo(CInstance *a_pInst )
{
    TIME_ZONE_INFORMATION t_tzone ;

	// 0xffffffff compare is per spec
	// ==============================
	if( 0xffffffff != GetTimeZoneInformation( &t_tzone ) )
	{
		// Start building a new instance
		//==============================
		a_pInst->SetWBEMINT16(	L"Bias",				( -1 * t_tzone.Bias ) ) ;
		a_pInst->SetWCHARSplat(	L"StandardName",		t_tzone.StandardName ) ;
		a_pInst->SetDWORD(		L"StandardYear",		t_tzone.StandardDate.wYear ) ;
		a_pInst->SetDWORD(		L"StandardMonth",		t_tzone.StandardDate.wMonth ) ;
		a_pInst->SetDWORD(		L"StandardDay",			t_tzone.StandardDate.wDay ) ;
		a_pInst->SetDWORD(		L"StandardHour",		t_tzone.StandardDate.wHour ) ;
		a_pInst->SetDWORD(		L"StandardMinute",		t_tzone.StandardDate.wMinute ) ;
		a_pInst->SetDWORD(		L"StandardSecond",		t_tzone.StandardDate.wSecond ) ;
		a_pInst->SetDWORD(		L"StandardMillisecond", t_tzone.StandardDate.wMilliseconds ) ;
		a_pInst->SetDWORD(		L"StandardBias",		t_tzone.StandardBias ) ;
		a_pInst->SetWCHARSplat(	L"DaylightName",		t_tzone.DaylightName ) ;
		a_pInst->SetDWORD(		L"DaylightYear",		t_tzone.DaylightDate.wYear ) ;
		a_pInst->SetDWORD(		L"DaylightMonth",		t_tzone.DaylightDate.wMonth ) ;
		a_pInst->SetDWORD(		L"DaylightDay",			t_tzone.DaylightDate.wDay ) ;
		a_pInst->SetDWORD(		L"DaylightHour",		t_tzone.DaylightDate.wHour ) ;
		a_pInst->SetDWORD(		L"DaylightMinute",		t_tzone.DaylightDate.wMinute ) ;
		a_pInst->SetDWORD(		L"DaylightSecond",		t_tzone.DaylightDate.wSecond ) ;
		a_pInst->SetDWORD(		L"DaylightMillisecond", t_tzone.DaylightDate.wMilliseconds ) ;
		a_pInst->SetDWORD(		L"DaylightBias",		t_tzone.DaylightBias ) ;
		a_pInst->SetByte(		L"StandardDayOfWeek",	t_tzone.StandardDate.wDayOfWeek ) ;
		a_pInst->SetByte(		L"DaylightDayOfWeek",	t_tzone.DaylightDate.wDayOfWeek ) ;

		CRegistry t_RegInfo ;
		CHString t_chsTmp ;
		CHString t_chsTimeZoneStandardName ;

#ifdef NTONLY
		CHString t_chsTimeZoneInfoRegistryKey ( L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\" ) ;
		t_chsTimeZoneStandardName = t_tzone.StandardName ;
#endif

#ifdef WIN9XONLY
		CHString t_chsTimeZoneInfoRegistryKey ( L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Time Zones\\" ) ;
		PWCHAR t_pwcTmp = wcsstr ( t_tzone.StandardName , L"Standard Time" ) ;
		if ( t_pwcTmp )
		{
			*t_pwcTmp = 0 ;
			t_chsTimeZoneStandardName = t_tzone.StandardName ;
			t_chsTimeZoneStandardName.TrimRight () ;
		}
#endif

		if ( !t_chsTimeZoneStandardName.IsEmpty () )
		{
			if (	t_RegInfo.Open (
										HKEY_LOCAL_MACHINE,
										t_chsTimeZoneInfoRegistryKey + t_chsTimeZoneStandardName,
										KEY_READ
									) == ERROR_SUCCESS  &&
					t_RegInfo.GetCurrentKeyValue ( L"Display", t_chsTmp ) == ERROR_SUCCESS &&
					!t_chsTmp.IsEmpty ()
				)
			{
				a_pInst->SetCHString ( L"Description", t_chsTmp ) ;
				a_pInst->SetCHString ( L"Caption", t_chsTmp ) ;
			}
		}
		return TRUE ;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\usb.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  USB.h
//
//  Purpose: USB Controller property set provider
//
//***************************************************************************

// Property set identification
//============================
#ifndef _USB_H
#define _USB_H



#define USB_ALL_PROPS                    0xFFFFFFFF
#define USB_KEY_ONLY                     0x00000010
#define USB_PROP_ConfigManagerErrorCode  0x00000001
#define USB_PROP_ConfigManagerUserConfig 0x00000002
#define USB_PROP_Status                  0x00000004
#define USB_PROP_PNPDeviceID             0x00000008
#define USB_PROP_DeviceID                0x00000010
#define USB_PROP_SystemCreationClassName 0x00000020
#define USB_PROP_SystemName              0x00000040
#define USB_PROP_Description             0x00000080
#define USB_PROP_Caption                 0x00000100
#define USB_PROP_Name                    0x00000200
#define USB_PROP_Manufacturer            0x00000400
#define USB_PROP_ProtocolSupported       0x00000800
#define USB_PROP_CreationClassName       0x00001000






#define	PROPSET_NAME_USB	L"Win32_USBController"

class CWin32USB : virtual public Provider
{
    private:
        CHPtrArray m_ptrProperties;

    protected:

        virtual bool IsOneOfMe
        (
            void *a_pv
        );

        virtual HRESULT LoadPropertyValues
        (
            void *a_pv
        );

        virtual bool ShouldBaseCommit
        (
            void *a_pvData
        );

        HRESULT Enumerate
        (
            MethodContext *a_pMethodContext, 
            long a_lFlags, 
            DWORD a_dwReqProps = USB_ALL_PROPS
        );

    public:

        // Constructor/destructor
        //=======================

        CWin32USB
        (
			const CHString &a_strName, 
			LPCWSTR a_pszNamespace
        );

        ~CWin32USB();

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject
        (
            CInstance *a_pInst, 
            long a_lFlags,
            CFrameworkQuery& pQuery
        );

        virtual HRESULT ExecQuery
        (
            MethodContext *a_pMethodContext, 
            CFrameworkQuery &a_pQuery, 
            long a_Flags = 0L 
        );

        virtual HRESULT EnumerateInstances
        (
            MethodContext *a_pMethodContext, 
            long a_lFlags = 0L
        );        
} ;

// This is the base; it should always commit in the base.
inline bool CWin32USB::ShouldBaseCommit
(
    void *a_pvData
)
{ 
    return true; 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\useassoc.cpp ===
//=================================================================

//

// useassoc.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <Assoc.h>

CAssociation MySystemToBootConfigGroup(
    L"Win32_SystemBootConfiguration",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_BootConfiguration",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToDesktops(
    L"Win32_SystemDesktop",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_Desktop",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToLogicalMemoryConfig(
    L"Win32_SystemLogicalMemoryConfiguration",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_LogicalMemoryConfiguration",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToProgramGroup(
    L"Win32_SystemProgramGroups",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_LogicalProgramGroup",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToTimeZone(
    L"Win32_SystemTimeZone",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_TimeZone",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToBiosSet(
    L"Win32_SystemBIOS",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_BIOS",
    IDS_GroupComponent,
    IDS_PartComponent
);

CAssociation MySystemToPartitionSet(
    L"Win32_SystemPartitions",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_DiskPartition",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToProcessSet(
    L"Win32_SystemProcesses",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_Process",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToSystemDriversSet(
    L"Win32_SystemSystemDriver",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_SystemDriver",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToServicesSet(
    L"Win32_SystemServices",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_Service",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToLoadOrderGroup(
    L"Win32_SystemLoadOrderGroups",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_LoadOrderGroup",
    IDS_GroupComponent,
    IDS_PartComponent
);

CAssociation MySystemToProcessor(
    L"Win32_ComputerSystemProcessor",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_Processor",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToSystemResourceSet(
    L"Win32_SystemResources",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"CIM_SystemResource",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToLogicalDeviceSet(
    L"Win32_SystemDevices",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"CIM_LogicalDevice",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToNetConnSet(
    L"Win32_SystemNetworkConnections",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_NetworkConnection",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

//========================
class CAssocSystemToOS : public CAssociation
{
    public:

        CAssocSystemToOS(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName

        );

        ~CAssocSystemToOS();

    protected:
        HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        );


};

CAssocSystemToOS::CAssocSystemToOS(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName
) : CAssociation (

    pwszClassName,
    pwszNamespaceName,

    pwszLeftClassName,
    pwszRightClassName,

    pwszLeftPropertyName,
    pwszRightPropertyName
    )
{
}

CAssocSystemToOS::~CAssocSystemToOS()
{
}

HRESULT CAssocSystemToOS::LoadPropertyValues(

    CInstance *pInstance,
    const CInstance *pLeft,
    const CInstance *pRight
)
{
    CAssociation::LoadPropertyValues(pInstance, pLeft, pRight);

    // This will work... until win32_os returns more than one instance.
    pInstance->Setbool(L"PrimaryOS", true);

    return WBEM_S_NO_ERROR;
}



CAssocSystemToOS MySystemToOperatingSystem(
    L"Win32_SystemOperatingSystem",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_OperatingSystem",
    IDS_GroupComponent,
    IDS_PartComponent
) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\timezone.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// TimeZone.h        	

//                                                                  

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
//  10/14/96     jennymc    Updated to meet current standards
//  10/27/97     davwoh     Moved to curly
//	03/02/99	 a-peterc	Added graceful exit on SEH and memory failures,
//							syntactic clean up
//                                                                   
///////////////////////////////////////////////////////////////////////

#define PROPSET_NAME_TIMEZONE L"Win32_TimeZone"

///////////////////////////////////////////////////////////////////////
// Declare Get and Put functions for individual properties
// here before they are used in template declarations
// Match the pointer types to the type that you pass
// as the first argument to the template, so if the property
// type is a DWORD then make the the function call have
// a DWORD pointer. It is done this way rather than through
// void pointers to help prevent memory overwrites that may
// happen with memcpy type of code
//
// Place "get" and "put" function prototypes here
// Example:
// BOOL GetFunction(void* myvalue);
// Then just use the name of your function as the get or put
// argument location in the property declaration
//==========================================================

// PROPERTY SET
//=============
class CWin32TimeZone : public Provider  
{
	private:
		BOOL GetTimeZoneInfo( CInstance *a_pInst ) ;

	public:
		// Constructor sets the name and description of the property set
		// and initializes the properties to their startup values
		//==============================================================
		CWin32TimeZone( const CHString &a_name, LPCWSTR a_pszNamespace ) ;  // constructor
		~CWin32TimeZone() ;  // destructor

		// These functions are REQUIRED for the property set
		//==================================================
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <Binding.h>

CBinding MySerialPortToConfig(
    L"Win32_SerialPortSetting",
    IDS_CimWin32Namespace,
    L"Win32_SerialPort",
    L"Win32_SerialPortConfiguration",
    IDS_Element,
    IDS_Setting,
    IDS_DeviceID,
    IDS_Name);

CBinding MyNetAdaptToNetAdaptConfig(
    L"Win32_NetworkAdapterSetting",
    IDS_CimWin32Namespace,
    L"Win32_NetworkAdapter",
    L"Win32_NetworkAdapterConfiguration",
    IDS_Element,
    IDS_Setting,
    IDS_Index,
    IDS_Index);

CBinding PageFileToPagefileSetting(
    L"Win32_PageFileElementSetting",
    IDS_CimWin32Namespace,
    L"Win32_PageFileUsage",
    L"Win32_PageFileSetting",
    IDS_Element,
    IDS_Setting,
    IDS_Name,
    IDS_Name);

CBinding MyPrinterSetting(
    L"Win32_PrinterSetting",
    IDS_CimWin32Namespace,
    L"Win32_Printer",
    L"Win32_PrinterConfiguration",
    IDS_Element,
    IDS_Setting,
    IDS_DeviceID,
    IDS_Name);

CBinding MyDiskToPartitionSet(
    L"Win32_DiskDriveToDiskPartition",
    IDS_CimWin32Namespace,
    L"Win32_DiskDrive",
    L"Win32_DiskPartition",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_Index,
    IDS_DiskIndex
);

CBinding assocPOTSModemToSerialPort(
    L"Win32_POTSModemToSerialPort",
    IDS_CimWin32Namespace,
    L"Win32_SerialPort",
    L"Win32_POTSModem",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_DeviceID,
    IDS_AttachedTo
);

CBinding OStoQFE(
    L"Win32_OperatingSystemQFE",
    IDS_CimWin32Namespace,
    L"Win32_OperatingSystem",
    L"Win32_QuickFixEngineering",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_CSName,
    IDS_CSName
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\usb.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  USB.cpp
//
//  Purpose: USB Controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include "LPVParams.h"
#include <FRQueryEx.h>
#include <ProvExce.h>

#include "USB.h"

// Property set declaration
//=========================

CWin32USB MyUSBController( PROPSET_NAME_USB, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USB::CWin32USB
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32USB::CWin32USB
(
	const CHString &a_strName,
	LPCWSTR a_pszNamespace
)
: Provider( a_strName, a_pszNamespace )
{
    m_ptrProperties.SetSize(13);
    m_ptrProperties[0]	= ( (LPVOID) IDS_ConfigManagerErrorCode );
    m_ptrProperties[1]	= ( (LPVOID) IDS_ConfigManagerUserConfig );
    m_ptrProperties[2]	= ( (LPVOID) IDS_Status);
    m_ptrProperties[3]	= ( (LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[4]	= ( (LPVOID) IDS_DeviceID);
    m_ptrProperties[5]	= ( (LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6]	= ( (LPVOID) IDS_SystemName);
    m_ptrProperties[7]	= ( (LPVOID) IDS_Description);
    m_ptrProperties[8]	= ( (LPVOID) IDS_Caption);
    m_ptrProperties[9]	= ( (LPVOID) IDS_Name);
    m_ptrProperties[10] = ( (LPVOID) IDS_Manufacturer);
    m_ptrProperties[11] = ( (LPVOID) IDS_ProtocolSupported );
    m_ptrProperties[12] = ( (LPVOID) IDS_CreationClassName );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USB::~CWin32USB
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 ****************************************************************************/

CWin32USB::~CWin32USB()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USB::GetObject
//
//  Inputs:     CInstance		*a_pInst - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USB::GetObject
(
    CInstance *a_pInst,
    long a_lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND ;
    CConfigManager t_cfgmgr ;

	// Let's see if config manager recognizes this device at all
	CHString t_sDeviceID ;
	a_pInst->GetCHString( IDS_DeviceID, t_sDeviceID ) ;

	CConfigMgrDevicePtr t_pDevice;
	if( t_cfgmgr.LocateDevice( t_sDeviceID, &t_pDevice ) )
	{
		// OK, it knows about it.  Is it a USBController?
		if( IsOneOfMe(t_pDevice ) )
		{
            CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx*>( &pQuery ) ;
            DWORD t_dwProperties ;

	        t_pQuery2->GetPropertyBitMask( m_ptrProperties, &t_dwProperties ) ;

			t_hResult = LoadPropertyValues( &CLPVParams( a_pInst,
														t_pDevice,
														t_dwProperties ) ) ;
		}
	}

	return t_hResult;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::ExecQuery
//
//  Inputs:     MethodContext *a_pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USB::ExecQuery
(
    MethodContext *a_pMethodContext,
    CFrameworkQuery &a_pQuery,
    long a_lFlags
)
{
    CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_pQuery ) ;
    DWORD t_dwProperties ;

	t_pQuery2->GetPropertyBitMask( m_ptrProperties, &t_dwProperties ) ;
    return Enumerate( a_pMethodContext, a_lFlags, t_dwProperties ) ;
}



////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USB::EnumerateInstances
//
//  Inputs:     MethodContext   *a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USB::EnumerateInstances
(
    MethodContext *a_pMethodContext,
    long a_lFlags /*= 0L*/
)
{
    return Enumerate( a_pMethodContext, a_lFlags ) ;
}



////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USB::Enumerate
//
//  Inputs:     MethodContext   *a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USB::Enumerate
(
    MethodContext *a_pMethodContext,
    long a_lFlags,
    DWORD a_dwReqProps
)
{
    HRESULT				t_hResult = WBEM_E_FAILED ;
    CConfigManager		t_cfgManager ;
    CDeviceCollection	t_deviceList ;
	CInstancePtr		t_pInst;
	CConfigMgrDevicePtr t_pDevice;

	// While it might be more performant to use FilterByGuid, it appears
	// that at least some95 boxes will report usb info if we do it this
	// way.
	if( t_cfgManager.GetDeviceListFilterByClass( t_deviceList, L"USB" ) )
	{
		REFPTR_POSITION t_pos;
		if( t_deviceList.BeginEnum( t_pos ) )
		{
			t_hResult = WBEM_S_NO_ERROR;

			// Walk the list
            for (t_pDevice.Attach(t_deviceList.GetNext( t_pos ));
                 SUCCEEDED( t_hResult ) && (t_pDevice != NULL);
                 t_pDevice.Attach(t_deviceList.GetNext( t_pos )))
			{
				// Now to find out if this is the usb controller
				if( IsOneOfMe( t_pDevice ) )
				{
                    t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
					if( SUCCEEDED( t_hResult = LoadPropertyValues( &CLPVParams(
																		t_pInst,
																		t_pDevice,
																		a_dwReqProps ) ) ) )
					{
						// Derived classes (like CW32USBCntrlDev) may
						// commit as result of call to
						// LoadPropertyValues, so check if we should
						// (only do so if we are of this class's type).
						if( ShouldBaseCommit( NULL ) )
						{
							t_hResult = t_pInst->Commit(  ) ;
						}
					}
				}
			}

			// Always call EndEnum().
			t_deviceList.EndEnum();
		}
	}

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USB::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : void *a_pv - Instance package to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32USB::LoadPropertyValues
(
    void *a_pv
)
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR;
    CHString	t_chstrDeviceID, t_chstrDesc, t_chstrTemp;

    /*************************************
    * Unpack and confirm our parameters...
    *************************************/
    CLPVParams			*t_pData		= ( CLPVParams * ) a_pv ;
    CInstance			*t_pInst		= ( CInstance * )( t_pData->m_pInstance ) ; // This instance released by caller
    CConfigMgrDevice	*t_pDevice		= ( CConfigMgrDevice * )( t_pData->m_pDevice ) ;
    DWORD				t_dwReqProps	= ( DWORD )( t_pData->m_dwReqProps ) ;

    if( t_pInst == NULL || t_pDevice == NULL )
    {
        return WBEM_E_PROVIDER_FAILURE;
    }


    /***********************
    * Set the key properties
    ***********************/

    t_pDevice->GetDeviceID( t_chstrDeviceID ) ;

    if( t_chstrDeviceID.GetLength() == 0 )
    {
        // We need the device id for the key property of this class.  If we can
        // not obtain it, we can't set the key, which is an unacceptable error.
        return WBEM_E_PROVIDER_FAILURE;
    }
    else
    {
        t_pInst->SetCHString( IDS_DeviceID, t_chstrDeviceID ) ;
    }


    /*****************************
    * Set USBController properties
    *****************************/

    if( t_dwReqProps & USB_PROP_Manufacturer )
    {
        if( t_pDevice->GetMfg( t_chstrTemp ) )
        {
            t_pInst->SetCHString( IDS_Manufacturer, t_chstrTemp ) ;
        }
    }


    /*****************************
    * Set CIMController properties
    *****************************/

    // Fixed value from enumerated list
    if( t_dwReqProps & USB_PROP_ProtocolSupported )
    {
        t_pInst->SetWBEMINT16( IDS_ProtocolSupported, 16 ) ;
    }


    /*********************************
    * Set CIM_LogicalDevice properties
    *********************************/

    if( t_dwReqProps & USB_PROP_PNPDeviceID )
    {
        t_pInst->SetCHString( IDS_PNPDeviceID, t_chstrDeviceID ) ;
    }

	if( t_dwReqProps & USB_PROP_SystemCreationClassName )
    {
        t_pInst->SetCHString( IDS_SystemCreationClassName,
                                  IDS_Win32ComputerSystem ) ;
    }
	if( t_dwReqProps & USB_PROP_CreationClassName )
    {
        SetCreationClassName(t_pInst);
    }
    if( t_dwReqProps & USB_PROP_SystemName )
    {
        t_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;
    }

    if( t_dwReqProps & (USB_PROP_Description | USB_PROP_Caption | USB_PROP_Name) )
    {
        if( t_pDevice->GetDeviceDesc( t_chstrDesc ) )
        {
            t_pInst->SetCHString( IDS_Description, t_chstrDesc ) ;
        }
    }

    if( t_dwReqProps & USB_PROP_ConfigManagerErrorCode ||
        t_dwReqProps & USB_PROP_Status )
    {
        DWORD t_dwStatus	= 0L;
        DWORD t_dwProblem	= 0L;

		if( t_pDevice->GetStatus( &t_dwStatus, &t_dwProblem ) )
        {
            if( t_dwReqProps & USB_PROP_ConfigManagerErrorCode )
            {
                t_pInst->SetDWORD( IDS_ConfigManagerErrorCode, t_dwProblem ) ;
            }

            if( t_dwReqProps & USB_PROP_Status )
            {
                CHString t_chsTmp;

				ConfigStatusToCimStatus ( t_dwStatus , t_chsTmp ) ;
                t_pInst->SetCHString(IDS_Status, t_chsTmp);
            }
        }
    }

    if( t_dwReqProps & USB_PROP_ConfigManagerUserConfig )
    {
        t_pInst->SetDWORD( IDS_ConfigManagerUserConfig,
                               t_pDevice->IsUsingForcedConfig() ) ;
    }

    // Use the friendly name for caption and name
    if( t_dwReqProps & USB_PROP_Caption || t_dwReqProps & USB_PROP_Name )
    {
        if( t_pDevice->GetFriendlyName( t_chstrTemp ) )
        {
            t_pInst->SetCHString( IDS_Caption, t_chstrTemp ) ;
            t_pInst->SetCHString( IDS_Name, t_chstrTemp ) ;
        }
        else
        {
            // If we can't get the name, settle for the description
            if( t_chstrDesc.GetLength() > 0 )
            {
                t_pInst->SetCHString( IDS_Caption, t_chstrDesc ) ;
                t_pInst->SetCHString( IDS_Name, t_chstrDesc ) ;
            }
        }
    }
    return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USB::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of USB device.
 *
 *  INPUTS      : void *a_pv - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid USB class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32USB::IsOneOfMe
(
    void *a_pv
)
{
    bool t_fRet = false;

    if( NULL != a_pv )
    {
        CConfigMgrDevice *t_pDevice = ( CConfigMgrDevice * ) a_pv ;

		// Ok, it knows about it. Is it a usb device?
        if( t_pDevice->IsClass( L"USB" ) )
        {
            // Now to find out if this is the usb controller
            CConfigMgrDevicePtr t_pParentDevice;

			if( t_pDevice->GetParent( &t_pParentDevice ) )
            {
				// If the class of the parent isn't 'USB', this is the
                // controller...
                if( !t_pParentDevice->IsClass( L"USB" ) )
                {
                    t_fRet = true ;
                }
            }
        }
    }
    return t_fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\user.cpp ===
//=================================================================

//

// User.CPP -- User property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain users
//
//=================================================================

#include "precomp.h"

#include "wbemnetapi32.h"
#include <comdef.h>
#include "sid.h"
#include <ProvExce.h>
#include "User.h"
#include <vector>
#include <stack>
#include <frqueryex.h>


//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32UserAccount	Win32UserAccount( PROPSET_NAME_USER, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::CWin32UserAccount
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32UserAccount::CWin32UserAccount( const CHString& strName, LPCWSTR pszNamespace /*=NULL*/ )
:	Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::~CWin32UserAccount
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32UserAccount::~CWin32UserAccount()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Directory::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef WIN9XONLY
HRESULT CWin32UserAccount::ExecQuery(
									 MethodContext *a_pMethodContext,
									 CFrameworkQuery &a_pQuery,
									 long a_lFlags /*= 0L*/ )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;

	EnumerateInstances( a_pMethodContext ) ;

	return t_hResult;
}
#endif

#ifdef NTONLY
HRESULT CWin32UserAccount::ExecQuery(
									 MethodContext *a_pMethodContext,
									 CFrameworkQuery &a_pQuery,
									 long a_lFlags /*= 0L*/ )
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR ;
    std::vector<_bstr_t> t_vectorDomains;
    std::vector<_bstr_t> t_vectorUsers;
    std::vector<_variant_t> t_vectorLocalAccount;
    DWORD t_dwReqDomains;
    DWORD t_dwReqUsers;
    CInstancePtr t_pInst;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&a_pQuery);
    bool fLocalAccountPropertySpecified = false;
    bool fLocalAccount = false;

    // Get the definitive values for Domain and Name
    // Where domain = 'a' gives domain=a, user=''
    // Where (domain = 'a' and user = 'b') or (domain = 'c' and user = 'd') gives domain=a,c user=b,d
    // Where domain='a' or user='b' gives domain='', user='' (nothing is definitive)
    // Where domain>'a' gives domain='', user='' (nothing is definitive)
    a_pQuery.GetValuesForProp( L"Domain", t_vectorDomains ) ;
    a_pQuery.GetValuesForProp( L"Name", t_vectorUsers ) ;
    pQuery2->GetValuesForProp( IDS_LocalAccount, t_vectorLocalAccount ) ;

    // See if only local accounts requested
    if(t_vectorLocalAccount.size() > 0)
    {
        fLocalAccountPropertySpecified = true;
        // use variant_t's bool extractor...
        fLocalAccount = t_vectorLocalAccount[0];
    }

    // Get the counts
    t_dwReqDomains = t_vectorDomains.size() ;
    t_dwReqUsers = t_vectorUsers.size() ;

    WCHAR t_wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1 ] ;
    DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;
    ZeroMemory( t_wstrLocalComputerName, sizeof( t_wstrLocalComputerName ) ) ;
	if(!::GetComputerNameW( t_wstrLocalComputerName, &t_dwNameSize ) )
	{
		return WBEM_E_FAILED;
	}

	// If the query didn't use a path or an operator on a path that I know
	// how to optimize, get them all and let cimom sort it out
	DWORD t_dwOurDomains;

	if ( t_dwReqDomains == 0 && t_dwReqUsers == 0 && fLocalAccount == false)
	{
	  EnumerateInstances( a_pMethodContext ) ;
	}
	else
	{
		CNetAPI32 t_NetAPI ;
		bool t_bFound;
		int t_x, t_y, t_z;

		if( t_NetAPI.Init() == ERROR_SUCCESS )
		{
			// Get all the domains related to this one (plus this one)
			std::vector<_bstr_t> t_vectorTrustList;
			t_NetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;
			t_dwOurDomains = t_vectorTrustList.size() ;

			// Walk all of our domains.  I do it this way instead of walking acsDomains for two reasons
			// 1) It disallows the enumeration of domains that aren't "ours"
			// 2) It deals with the possibility of duplicates (where domain='a' and domain='a' will have two entries in acsDomains)
            bool fDone = false;
			for ( t_x = 0; t_x < t_dwOurDomains && !fDone; t_x++ )
			{
				// If this 'if' is true, we have domains but no users
				if ( t_dwReqUsers == 0)
				{
					t_bFound = false;

					// See if this entry (from the 'for x' above) of 'our' domains is in the list of domains requested
					for ( t_y = 0; ( (t_y < t_dwReqDomains) || fLocalAccount ) && ( !t_bFound ) && (!fDone); t_y++ )
					{
						// Found one
						if ( (fLocalAccountPropertySpecified && fLocalAccount) ?
                                 _wcsicmp((WCHAR*) t_vectorTrustList[t_x], t_wstrLocalComputerName) == 0  :
                                 _wcsicmp((WCHAR*) t_vectorTrustList[t_x], t_vectorDomains[t_y]) == 0 )
						{
							t_bFound = true;
                            if(fLocalAccountPropertySpecified)
                            {
                                if(fLocalAccount)
                                {
                                    if(_wcsicmp(t_wstrLocalComputerName, t_vectorTrustList[t_x]) == 0)
                                    {
                                        t_hResult = GetDomainUsersNTW( t_NetAPI, (WCHAR*) t_vectorTrustList[t_x], a_pMethodContext ) ;
                                        fDone = true;
                                    }
                                }
                                else
                                {
                                    if(_wcsicmp(t_wstrLocalComputerName, t_vectorTrustList[t_x]) != 0)
                                    {
                                        t_hResult = GetDomainUsersNTW( t_NetAPI, (WCHAR*) t_vectorTrustList[t_x], a_pMethodContext ) ;
                                    }
                                }
                            }
                            else
                            {
							    t_hResult = GetDomainUsersNTW( t_NetAPI, (WCHAR*) t_vectorTrustList[t_x], a_pMethodContext ) ;
                            }
						}
					}

				// Users but no domains
				}
				else if ( t_dwReqDomains == 0 )
				{
				   // If they ask for a user with no domain, we must check for that user
				   // in all of 'our' domains.  Remember, we are walking domains in the 'for x' above.
				   for ( t_y = 0; t_y < t_dwReqUsers; t_y++ )
				   {
                        t_pInst.Attach(CreateNewInstance( a_pMethodContext ));

						// Do the setup
						t_pInst->SetWCHARSplat( IDS_Domain, (WCHAR*) t_vectorTrustList[t_x] ) ;

						_bstr_t t( t_vectorUsers[ t_y ] ) ;
						t_pInst->SetWCHARSplat( IDS_Name, t_vectorUsers[t_y] ) ;

						// See if we can find one
						if ( GetSingleUserNTW( t_NetAPI, t_pInst ) )
						{
							t_hResult = t_pInst->Commit(  ) ;
						}
					}

				// We got BOTH users AND domains.  In this case we need to look for each of the entries
				// in the users list in each of the domains in the domains list.  This can give us more
				// than they requested, but cimom will filter the excess.
				}
				else
				{
				   t_bFound = false;

				   for (t_y = 0; ( t_y < t_dwReqDomains ) && ( !t_bFound ); t_y++ )
				   {
					  // See if this entry (from the 'for x' above) of 'our' domains is in the list of domains requested
					  if ( _wcsicmp((WCHAR*) t_vectorTrustList[t_x], t_vectorDomains[t_y]) == 0 )
					  {
						 t_bFound = true;

						 // Now walk all the users they requested and return instances
						 for ( t_z = 0; t_z < t_dwReqUsers; t_z++ )
						 {
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ));
							t_pInst->SetWCHARSplat( IDS_Domain, (WCHAR*) t_vectorTrustList[t_x] ) ;
							t_pInst->SetWCHARSplat( IDS_Name, t_vectorUsers[t_z] ) ;

							if ( GetSingleUserNTW( t_NetAPI, t_pInst) )
							{
							   t_hResult = t_pInst->Commit(  ) ;
							}
						 }
					  }
				   }
				}
			}
		}
	}
	return t_hResult;
}
#endif
////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32UserAccount::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	BOOL t_fReturn = FALSE;

	// Find the instance depending on platform id.
	t_fReturn = RefreshInstance( a_pInst );

	return t_fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND ;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32UserAccount::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	// Get the proper OS dependent instance
	return AddDynamicInstances( a_pMethodContext );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : a_rInst to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY

HRESULT CWin32UserAccount::PutInstance(

const CInstance &a_rInst,
long			a_lFlags /*= 0L*/
)
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	USER_INFO_2 *t_pUserInfo2 = NULL;

	CHString	t_chsUserName ;
	CHString	t_chsDomainName ;

	// No user creation
	if ( a_lFlags & WBEM_FLAG_CREATE_ONLY )
	{
		return WBEM_E_UNSUPPORTED_PARAMETER;
	}

	CNetAPI32 t_NetAPI;

	if ( t_NetAPI.Init () == ERROR_SUCCESS )
	{
		a_rInst.GetCHString( IDS_Name , t_chsUserName ) ;
		a_rInst.GetCHString( IDS_Domain, t_chsDomainName ) ;

		NET_API_STATUS t_Status = t_NetAPI.NetUserGetInfo(	(LPCWSTR)t_chsDomainName,
															(LPCWSTR)t_chsUserName,
															2,
															(LPBYTE*) &t_pUserInfo2 ) ;
		try
		{
			bool t_bSetFlags = false ;

			if( NERR_Success == t_Status && t_pUserInfo2 )
			{
				// Disabled?
				if( !a_rInst.IsNull( IDS_Disabled ) )
				{
					bool t_bDisabled = false ;
					if( a_rInst.Getbool( IDS_Disabled, t_bDisabled ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_ACCOUNTDISABLE ? true : false ;

						if( t_bCurrentSetting != t_bDisabled )
						{
							t_bSetFlags = true ;

							if( t_bDisabled )
							{
								t_pUserInfo2->usri2_flags |= UF_ACCOUNTDISABLE ;
							}
							else
							{
								t_pUserInfo2->usri2_flags &= ~UF_ACCOUNTDISABLE ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Lockout?
				if( !a_rInst.IsNull( IDS_Lockout ) )
				{
					bool t_bLockout = false ;
					if( a_rInst.Getbool( IDS_Lockout, t_bLockout ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_LOCKOUT ? true : false ;

						if( t_bCurrentSetting != t_bLockout )
						{
							t_bSetFlags = true ;

							if( t_bLockout )
							{
								t_pUserInfo2->usri2_flags |= UF_LOCKOUT ;
							}
							else
							{
								t_pUserInfo2->usri2_flags &= ~UF_LOCKOUT ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Password changable?
				if( !a_rInst.IsNull( IDS_PasswordChangeable ) )
				{
					bool t_bPwChangable = false ;
					if( a_rInst.Getbool( IDS_PasswordChangeable, t_bPwChangable ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_PASSWD_CANT_CHANGE ? false : true ;

						if( t_bCurrentSetting != t_bPwChangable )
						{
							t_bSetFlags = true ;

							if( t_bPwChangable )
							{
								t_pUserInfo2->usri2_flags &= ~UF_PASSWD_CANT_CHANGE ;
							}
							else
							{
								t_pUserInfo2->usri2_flags |= UF_PASSWD_CANT_CHANGE ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Password expires?
				if( !a_rInst.IsNull( IDS_PasswordExpires ) )
				{
					bool t_bPwExpires = false ;
					if( a_rInst.Getbool( IDS_PasswordExpires, t_bPwExpires ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_DONT_EXPIRE_PASSWD ? false : true ;

						if( t_bCurrentSetting != t_bPwExpires )
						{
							t_bSetFlags = true ;

							if( t_bPwExpires )
							{
								t_pUserInfo2->usri2_flags &= ~UF_DONT_EXPIRE_PASSWD ;
							}
							else
							{
								t_pUserInfo2->usri2_flags |= UF_DONT_EXPIRE_PASSWD ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Password required?
				if( !a_rInst.IsNull( IDS_PasswordRequired ) )
				{
					bool t_bPwRequired = false ;
					if( a_rInst.Getbool( IDS_PasswordRequired, t_bPwRequired ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_PASSWD_NOTREQD ? false : true ;

						if( t_bCurrentSetting != t_bPwRequired )
						{
							t_bSetFlags = true ;

							if( t_bPwRequired )
							{
								t_pUserInfo2->usri2_flags &= ~UF_PASSWD_NOTREQD ;
							}
							else
							{
								t_pUserInfo2->usri2_flags |= UF_PASSWD_NOTREQD ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// flags update...
				if( t_bSetFlags )
				{
					DWORD t_ParmError = 0 ;
					USER_INFO_1008 t_UserInfo_1008 ;

					t_UserInfo_1008.usri1008_flags = t_pUserInfo2->usri2_flags ;

					t_Status = t_NetAPI.NetUserSetInfo(
												(LPCWSTR)t_chsDomainName,
												(LPCWSTR)t_chsUserName,
												1008,
												(LPBYTE) &t_UserInfo_1008,
												&t_ParmError
												) ;

					if( NERR_Success != t_Status )
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Full Name
				if( !a_rInst.IsNull( IDS_FullName ) )
				{
					CHString t_chsFullName ;

					if( a_rInst.GetCHString( IDS_FullName, t_chsFullName ) )
					{
						if( t_chsFullName != t_pUserInfo2->usri2_full_name )
						{
							DWORD t_ParmError = 0 ;
							USER_INFO_1011 t_UserInfo_1101 ;

							t_UserInfo_1101.usri1011_full_name = (LPWSTR)(LPCWSTR)t_chsFullName ;

							t_Status = t_NetAPI.NetUserSetInfo(
														(LPCWSTR)t_chsDomainName,
														(LPCWSTR)t_chsUserName,
														1011,
														(LPBYTE) &t_UserInfo_1101,
														&t_ParmError
														) ;

							if( NERR_Success != t_Status )
							{
								t_hResult = WBEM_E_FAILED ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}
			}
			else if( NERR_UserNotFound == t_Status ||
					 NERR_InvalidComputer == t_Status  )
			{
				t_hResult = WBEM_E_NOT_FOUND ;
			}
			else
			{
				t_hResult = WBEM_E_FAILED ;
			}
		}
		catch( ... )
		{
			t_NetAPI.NetApiBufferFree( t_pUserInfo2 ) ;
			throw ;
		}

		t_NetAPI.NetApiBufferFree( t_pUserInfo2 ) ;
		t_pUserInfo2 = NULL ;
	}

	return t_hResult;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY

HRESULT CWin32UserAccount::ExecMethod(

const CInstance &a_rInst,
const BSTR a_MethodName,
CInstance *a_pInParams,
CInstance *a_pOutParams,
long a_Flags )
{
	if ( !a_pOutParams )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Method recognized?
	if( !_wcsicmp ( a_MethodName, METHOD_NAME_RenameAccount ) )
	{
		return hRenameAccount( (CInstance*)&a_rInst, a_pInParams, a_pOutParams, a_Flags ) ;
	}

	return WBEM_E_INVALID_METHOD ;
}

#endif

/*******************************************************************
    NAME:       hRenameAccount

    SYNOPSIS:   Sets a new account name for this instance.
				A method is required here since we are changing the key
				on the instance.

    ENTRY:      const CInstance &a_rInst,
				CInstance *a_pInParams,
				CInstance *a_pOutParams,
				long a_Flags	:

	NOTES:		This is a non static, instance dependent method call

    HISTORY:
********************************************************************/
#ifdef NTONLY

HRESULT CWin32UserAccount::hRenameAccount(

CInstance *a_pInst,
CInstance *a_pInParams,
CInstance *a_pOutParams,
long a_Flags )
{
	E_MethodResult	t_eResult = e_InstanceNotFound ;
	CHString		t_chsUserName ;
	CHString		t_chsDomainName ;
	CHString		t_chsNewUserName ;

	if( !a_pOutParams )
	{
		return WBEM_E_FAILED ;
	}

	if( !a_pInParams )
	{
		a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, e_InternalError ) ;
		return S_OK ;
	}

	// nonstatic method requires an instance
	if( !a_pInst )
	{
		a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, e_NoInstance ) ;
		return S_OK ;
	}

	// keys
	if( !a_pInst->IsNull( IDS_Name ) && !a_pInst->IsNull( IDS_Domain ) )
	{
		// Name
		if( a_pInst->GetCHString( IDS_Name , t_chsUserName ) )
		{
			// Domain
			if( a_pInst->GetCHString( IDS_Domain, t_chsDomainName ) )
			{
				// New user name
				if( !a_pInParams->IsNull( IDS_Name ) &&
					a_pInParams->GetCHString( IDS_Name, t_chsNewUserName ) )
				{
					t_eResult = e_Success ;
				}
				else
				{
					t_eResult = e_InvalidParameter ;
				}
			}
		}
	}

	// proceed with the update...
	if( e_Success == t_eResult )
	{
		if( t_chsNewUserName != t_chsUserName )
		{
			CNetAPI32	t_NetAPI;

			if ( ERROR_SUCCESS == t_NetAPI.Init () )
			{
				DWORD t_ParmError = 0 ;
				USER_INFO_0 t_UserInfo_0 ;

				t_UserInfo_0.usri0_name  = (LPWSTR)(LPCWSTR)t_chsNewUserName ;

				NET_API_STATUS t_Status = t_NetAPI.NetUserSetInfo(
																	(LPCWSTR)t_chsDomainName,
																	(LPCWSTR)t_chsUserName,
																	0,
																	(LPBYTE) &t_UserInfo_0,
																	&t_ParmError ) ;
				switch( t_Status )
				{
					case NERR_Success:			t_eResult = e_Success ;			break ;
					case NERR_UserNotFound:		t_eResult = e_UserNotFound ;	break ;
					case NERR_InvalidComputer:	t_eResult = e_InvalidComputer ;	break ;
					case NERR_NotPrimary:		t_eResult = e_NotPrimary ;		break ;
					case NERR_LastAdmin:		t_eResult = e_LastAdmin ;		break ;
					case NERR_SpeGroupOp:		t_eResult = e_SpeGroupOp ;		break ;
					default:					t_eResult = e_ApiError;			break ;
				}
			}
		}
	}

	a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, t_eResult ) ;
	return S_OK ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known users (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32UserAccount::AddDynamicInstances( MethodContext *a_pMethodContext )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;
    CNetAPI32 t_NetAPI ;

    // Get NETAPI32.DLL entry points
    //==============================

	if( t_NetAPI.Init() == ERROR_SUCCESS )
	{
		// Get all the domains related to this one (plus this one)
		std::vector<_bstr_t> t_vectorTrustList ;
		t_NetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;

		// For each domain, get the users
		LONG t_lTrustListSize = t_vectorTrustList.size() ;
        BOOL fContinue = TRUE;
		for (int t_x = 0; t_x < t_lTrustListSize && fContinue; t_x++ )
		{
			//Just because we are denied on one domain doesn't mean we will be on others,
			//so ignore return value of GetDomainUsersNTW.
			fContinue = GetDomainUsersNTW( t_NetAPI, (WCHAR*) t_vectorTrustList[t_x], a_pMethodContext ) ;
		}
	}
    return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceNT
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32UserAccount::RefreshInstance( CInstance *a_pInst )
{
    HMODULE		t_hNetApi32 = NULL ;
    BOOL		t_bRetCode = FALSE ;
    CNetAPI32	t_NetAPI ;
    CHString	t_sDomain ;

    // Get NETAPI32.DLL entry points
    //==============================

    if( t_NetAPI.Init() == ERROR_SUCCESS )
	 {
		CHStringArray t_strarrayTrustedDomains ;

      // Get all the domains related to this one (plus this one)
      CHStringArray t_achsTrustList;
      t_NetAPI.GetTrustedDomainsNT( t_achsTrustList ) ;

      a_pInst->GetCHString( IDS_Domain, t_sDomain ) ;

      // If the domain we want is in the list we support, try to get the instance.
      for (int t_x = 0; t_x < t_achsTrustList.GetSize(); t_x++ )
	  {
         if ( t_achsTrustList[t_x].CompareNoCase( t_sDomain ) == 0 )
		 {
   		   t_bRetCode = GetSingleUserNTW( t_NetAPI, a_pInst ) ;
         }
      }
    }

    return t_bRetCode ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : LoadUserValuesNT
 *
 *  DESCRIPTION : Loads property values according to passed user name
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : zip
 *
 *  COMMENTS    : While it would make more sense to pass the structure containing
 *                the data, I can't.  Enum and GetObject end up with different
 *                structs.
 *
 *****************************************************************************/

#ifdef NTONLY
void CWin32UserAccount::LoadUserValuesNT(
										 CHString	a_strDomainName,
										 CHString	a_strUserName,
										 WCHAR		*a_pwszFullName,
										 WCHAR		*a_pwszDescription,
										 DWORD		a_dwFlags,
                                         WCHAR      *a_pwszComputerName,
										 CInstance	*a_pInst )
{
   // Assign NT properties -- string values are unassigned if
   // NULL or empty
   //========================================================

	// We've established it's a valid user, so we should be able to get the Sid.
   GetSIDInformation( a_strDomainName, a_strUserName, a_pwszComputerName, a_pInst );

   a_pInst->SetCHString( IDS_Caption, a_strDomainName + _T('\\') + a_strUserName );
   a_pInst->SetCHString( IDS_FullName, a_pwszFullName ) ;
   a_pInst->SetCHString( IDS_Description, a_pwszDescription ) ;

   a_pInst->Setbool( IDS_Disabled, a_dwFlags & UF_ACCOUNTDISABLE ) ;
   a_pInst->Setbool( IDS_PasswordRequired, !( a_dwFlags & UF_PASSWD_NOTREQD ) ) ;
   a_pInst->Setbool( IDS_PasswordChangeable, !( a_dwFlags & UF_PASSWD_CANT_CHANGE ) ) ;
   a_pInst->Setbool( IDS_Lockout, a_dwFlags & UF_LOCKOUT ) ;
   a_pInst->Setbool( IDS_PasswordExpires, !( a_dwFlags & UF_DONT_EXPIRE_PASSWD ) ) ;

   a_pInst->SetDWORD( IDS_AccountType, a_dwFlags & UF_ACCOUNT_TYPE_MASK ) ;

   if ( ( a_dwFlags & UF_ACCOUNTDISABLE) || ( a_dwFlags & UF_LOCKOUT ) )
   {
      a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_Degraded ) ;
   }
   else
   {
      a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_OK ) ;
   }

   return ;
}
#endif

#ifdef NTONLY
void CWin32UserAccount::LoadUserValuesNTW(LPCWSTR a_wstrDomainName,
                                          LPCWSTR a_wstrUserName,
                                          LPCWSTR a_wstrFullName,
                                          LPCWSTR a_wstrDescription,
                                          DWORD a_dwFlags,
                                          WCHAR *a_pwszComputerName,
                                          CInstance* a_pInst )
{
   // Assign NT properties -- string values are unassigned if
   // NULL or empty
   //========================================================
	// We've established it's a valid user, so we should be able to get the Sid.
	GetSIDInformationW( a_wstrDomainName, a_wstrUserName, a_pwszComputerName, a_pInst );

	_bstr_t t_bstrtCaption( a_wstrDomainName ) ;
	t_bstrtCaption += L"\\" ;
	t_bstrtCaption += a_wstrUserName ;

	a_pInst->SetWCHARSplat( IDS_Caption, (WCHAR*) t_bstrtCaption ) ;
	a_pInst->SetWCHARSplat( IDS_FullName, a_wstrFullName ) ;
	a_pInst->SetWCHARSplat( IDS_Description, a_wstrDescription ) ;

	a_pInst->Setbool( IDS_Disabled, a_dwFlags & UF_ACCOUNTDISABLE ) ;
	a_pInst->Setbool( IDS_PasswordRequired, !( a_dwFlags & UF_PASSWD_NOTREQD ) ) ;
	a_pInst->Setbool( IDS_PasswordChangeable, !( a_dwFlags & UF_PASSWD_CANT_CHANGE ) ) ;
	a_pInst->Setbool( IDS_Lockout, a_dwFlags & UF_LOCKOUT ) ;
	a_pInst->Setbool( IDS_PasswordExpires, !( a_dwFlags & UF_DONT_EXPIRE_PASSWD ) ) ;

	a_pInst->SetDWORD( IDS_AccountType, a_dwFlags & UF_ACCOUNT_TYPE_MASK ) ;

	if ( ( a_dwFlags & UF_ACCOUNTDISABLE ) || ( a_dwFlags & UF_LOCKOUT ) )
	{
		a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_Degraded ) ;
	}
	else
	{
		a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_OK ) ;
	}
	return ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::EnumerateUsersWin95
 *
 *  DESCRIPTION : Creates instance for all known local users (Win95)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : pdwInstanceCount -- receives count of all instances created
 *
 *  RETURNS     : yes
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

/*****************************************************************************
* TODO: Broken for TCHARs
*****************************************************************************/
#ifdef WIN9XONLY
HRESULT CWin32UserAccount::AddDynamicInstances( MethodContext *a_pMethodContext )
{
	TCHAR		*t_pChar ;
	DWORD		t_dwSize,
				t_dwIndex,
				t_dwRet ;
	CHString	t_strComputerName ;
	HRESULT		t_hResult	= WBEM_S_NO_ERROR ;
	CInstancePtr t_pInst;
	TCHAR		*t_szBuff	= NULL ;

    if(IsWin95())
    {
	    try
	    {
		    t_strComputerName = GetLocalComputerName() ;

		    t_dwSize = 1024 ;
		    t_szBuff = NULL ;
		    do
		    {
			    t_dwSize *= 2 ;
			    if ( t_szBuff != NULL )
			    {
				    delete [] t_szBuff ;
			    }

			    t_szBuff = new TCHAR [t_dwSize] ;

			    if (t_szBuff == NULL)
			    {
            		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			    }
			    else
			    {
				    t_dwRet = GetPrivateProfileSection( _T("Password Lists"), t_szBuff, t_dwSize/sizeof(TCHAR), _T("system.ini") ) ;
			    }

		    } while ( t_dwRet == t_dwSize - 2 ) ;

		    t_dwIndex = 0;
		    while ( ( t_dwIndex < t_dwRet ) && ( SUCCEEDED( t_hResult ) ) )
		    {

			    // Trim leading spaces
			    while ( t_szBuff[t_dwIndex] == _T(' ') )
			    {
				    t_dwIndex++;
			    }

			    // Skip comment lines
			    if ( t_szBuff[t_dwIndex] == _T(';') )
			    {
				    do
				    {
					    t_dwIndex++;
				    } while ( t_szBuff[ t_dwIndex ] != _T('\0') ) ;
			    }
			    else
			    {
				    t_pChar = &t_szBuff[ t_dwIndex ] ;
				    do
				    {
					    t_dwIndex++;
				    } while ( ( t_szBuff[ t_dwIndex ] != _T('=')) && ( t_szBuff[ t_dwIndex ] != _T('\0') ) ) ;

				    if ( t_szBuff[ t_dwIndex ] == _T('=') )
				    {
					    t_szBuff[ t_dwIndex ] = _T('\0') ;

                        t_pInst.Attach(CreateNewInstance( a_pMethodContext ));

						t_pInst->SetCharSplat( IDS_Name, t_pChar ) ;
						// t_pInst->SetCHString( IDS_Domain, strComputerName); #41415 -> Don't report inaccurately.  Better not at all.
						t_pInst->SetWCHARSplat( IDS_Domain, L""); // #47825 -> However, key properties can't be NULL.

						t_pInst->SetCharSplat( IDS_Status, IDS_STATUS_OK ) ;
						t_pInst->SetCHString( IDS_Caption, t_strComputerName + _T('\\') + t_pChar ) ;
						t_pInst->SetCHString( IDS_Description, t_strComputerName + _T('\\') + t_pChar ) ;
						t_hResult = t_pInst->Commit(  ) ;

					    t_dwIndex++;

					    while ( t_szBuff[ t_dwIndex ] != _T('\0') )
					    {
					       t_dwIndex++;
					    }
				    }
			    }
			    t_dwIndex++;
		    }

		    t_hResult = t_hResult ;

	    }
	    catch( ... )
	    {
		    if( t_szBuff )
		    {
			    delete [] t_szBuff ;
		    }

		    throw ;
	    }

		delete [] t_szBuff ;
		t_szBuff = NULL ;
    }
    else if(IsWin98())
    {
        CRegistry t_creg;
        if(t_creg.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
                                          L"Software\\Microsoft\\Windows\\CurrentVersion\\ProfileList\\",
                                          KEY_READ) == ERROR_SUCCESS)
        {
            CHString chstrSubKey;
            t_strComputerName = GetLocalComputerName() ;
            // Get the name of a subkey (a user)
            for(;SUCCEEDED(t_hResult);)
            {
                if(t_creg.GetCurrentSubKeyName(chstrSubKey) != ERROR_NO_MORE_ITEMS)
                {
                    t_pInst.Attach(CreateNewInstance(a_pMethodContext));

                    // Set the domain...
                    t_pInst->SetWCHARSplat(IDS_Domain, L"");
                    // Set the user...
                    t_pInst->SetCHString(IDS_Name, chstrSubKey);
                    // Set the rest...
                    t_pInst->SetCharSplat(IDS_Status, IDS_STATUS_OK);
					t_pInst->SetCHString(IDS_Caption, t_strComputerName + _T('\\') + chstrSubKey);
					t_pInst->SetCHString(IDS_Description, t_strComputerName + _T('\\') + chstrSubKey);
					t_hResult = t_pInst->Commit();
                }
                // Move to the next subkey:
                if(t_creg.NextSubKey() != ERROR_SUCCESS)
                {
                    break;
                }
            }
        }
        t_hResult = t_hResult;
    }
    return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceWin95
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL CWin32UserAccount::RefreshInstance( CInstance *a_pInst )
{
   TCHAR	t_szName[20];
   CHString t_sName;
   //CHString t_sDomain;
   BOOL		t_bRet = FALSE;
   CHString t_strComputerName;

   t_strComputerName = GetLocalComputerName() ;
   if(IsWin95())
   {
       if ( //(a_pInst->GetCHString( IDS_Domain, t_sDomain )) &&
           //(t_sDomain.IsEmpty()) &&
           (a_pInst->GetCHString( IDS_Name, t_sName ))
           )
       {

          DWORD t_dew = GetPrivateProfileString( _T("Password Lists"),
											     TOBSTRT( t_sName ),
											     ( LPCTSTR )"\xff",
											     t_szName,
											     sizeof( t_szName ) / sizeof(TCHAR),
											     ( LPCTSTR )"system.ini" ) ;

          if ( ( t_dew != 1 ) && ( t_szName[ 0 ] != '\xFF' ) )
          {
             a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_OK ) ;
             //a_pInst->SetCHString( IDS_Caption, t_sDomain + L'\\' + t_sName ) ;
             //a_pInst->SetCHString( IDS_Description, t_sDomain + L'\\' + t_sName ) ;
             a_pInst->SetCHString( IDS_Caption, t_strComputerName + L'\\' + t_sName ) ;
             a_pInst->SetCHString( IDS_Description, t_strComputerName + L'\\' + t_sName ) ;

             t_bRet = TRUE;
          }
       }
    }
    else if(IsWin98())
    {
        CRegistry t_creg;
        if(a_pInst->GetCHString( IDS_Name, t_sName ))
        {
            CHString t_chstrKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\ProfileList\\" + t_sName;
            if(t_creg.Open(HKEY_LOCAL_MACHINE,
                           t_chstrKey,
                           KEY_READ) == ERROR_SUCCESS)
            {

                a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_OK ) ;
                //a_pInst->SetCHString( IDS_Caption, t_sDomain + L'\\' + t_sName ) ;
                //a_pInst->SetCHString( IDS_Description, t_sDomain + L'\\' + t_sName ) ;
                a_pInst->SetCHString( IDS_Caption, t_strComputerName + L'\\' + t_sName ) ;
                a_pInst->SetCHString( IDS_Description, t_strComputerName + L'\\' + t_sName ) ;


                t_bRet = TRUE;
            }
        }
    }

   return t_bRet;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetDomainUsersNT
//
//	Obtains User Names for all users in the specified domain.  If no
//	domain is specified, then we assume the local machine.
//
//	Inputs:		CNetAPI32		netapi - network api functions.
//				LPCTSTR			pszDomain - Domain to retrieve users from.
//				MethodContext*	pMethodContext - Method Context
//
//	Outputs:	None.
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:	No special access is necessary here, although there are
//				a couple of methods we can implement, once we have the
//				name of the domain controller that we need to use to
//				get the user names from.  First, we can use NetQueryDisplay
//				Information() to get the names, but this may necessitate
//				hitting the DC a few times.  We can also use NetUserEnum
//				with a level of 0, which requires no special access, but
//				will use two queries, one to find out how many users and
//				another to get them all.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
//BOOL CWin32UserAccount::GetDomainUsersNT( CNetAPI32& netapi, LPCTSTR pszDomain, MethodContext* pMethodContext )
//{
//    BOOL		fReturn = FALSE,
//        fGotDC	= TRUE;
//    bool bCancelled = false;
//    LPWSTR		pwcsDCName = NULL;
//    CHString	strComputerName, strDomainName( pszDomain );
//
//    // When the computer name is the same as the domain name, that's the local accounts
//    strComputerName = GetLocalComputerName();
//    if (lstrcmp(strComputerName, pszDomain) != 0)
//    {
//        fGotDC = GetDomainControllerNameNT( netapi, pszDomain, &pwcsDCName );
//    }
//
//    if ( fGotDC )
//    {
//        NET_DISPLAY_USER *pUserData = NULL;
//        DWORD			dwNumReturnedEntries = 0,
//            dwIndex = 0;
//        NET_API_STATUS	stat;
//        CHString		strUserName;
//        CInstance *pInstance = NULL;
//
//        do {
//            // Accept 16384 entries back as a maximum, and up to 256k worth of data.
//
//            stat = netapi.NetQueryDisplayInformation( pwcsDCName, 1, dwIndex, 16384, 262144, &dwNumReturnedEntries, (PVOID*) &pUserData );
//
//            if ( ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat )
//            {
//                fReturn = TRUE;
//
//                // Walk through the returned entries
//                for ( DWORD	dwCtr = 0; (dwCtr < dwNumReturnedEntries) && (!bCancelled); dwCtr++ )
//                {
//                    // Create an instance for each
//                    pInstance = CreateNewInstance( pMethodContext );
//
//                    if ( NULL != pInstance )
//                    {
//                        // Save the data
//                        pInstance->SetCHString( IDS_Domain, strDomainName );
//                        //pInstance->SetCHString( IDS_Name, pUserData[dwCtr].usri1_name );
//                        pInstance->SetWCHARSplat( IDS_Name, (WCHAR*)_bstr_t(pUserData[dwCtr].usri1_name) );
//
//                        // NT5 works correctly
//                        if (IsWinNT5())
//                        {
//                            LoadUserValuesNT(strDomainName, pUserData[dwCtr].usri1_name, pUserData[dwCtr].usri1_full_name, pUserData[dwCtr].usri1_comment, pUserData[dwCtr].usri1_flags, pInstance);
//                            bCancelled = FAILED(Commit( pInstance ));
//                        }
//                        else
//                        {
//                            // Major yuck alert!  NetQueryDisplayInformation doesn't return the correct
//                            // values for the flags.  As a result, to get the correct information, we need to
//                            // make a SECOND call to get the data.
//                            if (GetSingleUserNT(netapi, pInstance)) {
//                                LoadUserValuesNT(strDomainName, pUserData[dwCtr].usri1_name, pUserData[dwCtr].usri1_full_name, pUserData[dwCtr].usri1_comment, pUserData[dwCtr].usri1_flags, pInstance);
//                                bCancelled = FAILED(Commit( pInstance ));
//                            } else {
//                                pInstance->elease();
//                            }
//                        }
//                    }
//
//                }
//
//                // The index for continuing the search is stored in the last entry
//                if ( dwNumReturnedEntries != 0 ) {
//                    dwIndex = pUserData[dwCtr-1].usri1_next_index;
//                }
//
//                netapi.NetApiBufferFree( pUserData );
//
//            }	// IF stat OK
//
//        } while ( (ERROR_MORE_DATA == stat) && (!bCancelled) );
//
//        // Clean up the domain controller name if we got one.
//        if ( NULL != pwcsDCName ) {
//            netapi.NetApiBufferFree( pwcsDCName );
//        }
//
//    }	// IF fGotDC
//
//    if (bCancelled)
//        fReturn = FALSE;
//
//    return fReturn;
//}
#endif

// Same function as above, but ALWAYS takes wstrDomain as a LPCWSTR (whether _UNICODE defined or not).
// Uses wides throughout the function body as well.
#ifdef NTONLY
BOOL CWin32UserAccount::GetDomainUsersNTW(
										  CNetAPI32 &a_netapi,
										  LPCWSTR a_wstrDomain,
										  MethodContext *a_pMethodContext )
{
    BOOL		t_fReturn		= FALSE;
	BOOL		t_fGotDC		= TRUE;
    bool        t_bCancelled	= false;
	CHString	t_chstrDCName;
	USER_INFO_2 *t_pUserData    = NULL;
	CInstancePtr t_pInst;

	WCHAR t_wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1 ] ;
    DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;

    ZeroMemory( t_wstrLocalComputerName, sizeof( t_wstrLocalComputerName ) ) ;

	try
	{
		if(!::GetComputerNameW( t_wstrLocalComputerName, &t_dwNameSize ) )
		{
			return FALSE;
		}

		// When the computer name is the same as the domain name, that's the local accounts
		if ( wcscmp( t_wstrLocalComputerName, a_wstrDomain ) != 0 )
		{
 			t_fGotDC = (a_netapi.GetDCName( a_wstrDomain, t_chstrDCName ) == ERROR_SUCCESS) ;
		}

		if ( t_fGotDC )
		{
			DWORD			t_dwNumReturnedEntries = 0,
							t_dwIndex = 0,
                            t_dwTotalEntries,
                            t_dwResumeHandle = 0;
			NET_API_STATUS	t_stat;

			do {
				// Accept up to 256K worth of data.
                t_stat =
                    // We used to use NetQueryDisplayInformation here, but it has a bug
                    // where it doesn't return the flags.
                    a_netapi.NetUserEnum(
                        t_chstrDCName,
                        2,
                        FILTER_NORMAL_ACCOUNT,
                        (LPBYTE*) &t_pUserData,
                        262144,
                        &t_dwNumReturnedEntries,
                        &t_dwTotalEntries,
                        &t_dwResumeHandle);

				if ( ERROR_SUCCESS == t_stat || ERROR_MORE_DATA == t_stat )
				{
					t_fReturn = TRUE;

					// Walk through the returned entries
					for ( DWORD	t_dwCtr = 0; ( t_dwCtr < t_dwNumReturnedEntries) &&
											 ( !t_bCancelled ); t_dwCtr++ )
					{
						// Create an instance for each
                        t_pInst.Attach(CreateNewInstance( a_pMethodContext ));

						// Save the data
						t_pInst->SetWCHARSplat( IDS_Domain, a_wstrDomain );

						t_pInst->SetWCHARSplat( IDS_Name, t_pUserData[t_dwCtr].usri2_name  );

                        if(_wcsicmp(t_wstrLocalComputerName, a_wstrDomain) == 0)
                        {
                            t_pInst->Setbool(IDS_LocalAccount, true);
                        }
                        else
                        {
                            t_pInst->Setbool(IDS_LocalAccount, false);
                        }


						LoadUserValuesNT(
                            a_wstrDomain,
							t_pUserData[ t_dwCtr ].usri2_name,
							t_pUserData[ t_dwCtr ].usri2_full_name,
							t_pUserData[ t_dwCtr ].usri2_comment,
							t_pUserData[ t_dwCtr ].usri2_flags,
                            _bstr_t((LPCWSTR)t_chstrDCName),
							t_pInst ) ;

					 	t_bCancelled = FAILED(t_pInst->Commit(  ) ) ;

 					}
				}	// IF stat OK

			} while ( (ERROR_MORE_DATA == t_stat) && ( !t_bCancelled ) ) ;


		}	// IF fGotDC

		if ( t_bCancelled )
		{
		   t_fReturn = FALSE;
		}

	}
	catch( ... )
	{
		if( t_pUserData )
		{
			a_netapi.NetApiBufferFree( t_pUserData ) ;
		}

		throw ;
	}

	// Clean up the domain controller name if we got one.
	if( t_pUserData )
	{
		a_netapi.NetApiBufferFree( t_pUserData ) ;
	}

	return t_fReturn ;

}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetSingleUserNT
//
//	Obtains the user name from the specified domain (which can be the
//	local workstation)
//
//	Inputs:		CNetAPI32		netapi - network api functions.
//				CInstance*		pInstance - Instance to get.
//
//	Outputs:	None.
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:	No special access is necessary here.  We just need to make sure
//				we are able to get the appropriate domain controller.
//
/////////////////////////////////////////////////////////////////////////////

/*
#ifdef NTONLY
BOOL CWin32UserAccount::GetSingleUserNT( CNetAPI32 &a_netapi, CInstance *a_pInst )
{
	BOOL		t_fReturn		= FALSE ,
				t_fGotDC		= TRUE ;
	LPWSTR		t_pwcsDCName	= NULL ;
	CHString	t_strDomainName ;
    WCHAR*      t_wstrUserName	= NULL;
	USER_INFO_2 *t_pUserInfo	= NULL;
	CHString	t_strComputerName ;

	try
	{
		a_pInst->GetCHString( IDS_Domain, t_strDomainName ) ;
		a_pInst->GetWCHAR( IDS_Name, &t_wstrUserName ) ;

		if( t_wstrUserName == NULL )
		{
			return FALSE;
		}

		t_strComputerName = GetLocalComputerName() ;

		if ( 0 != t_strDomainName.CompareNoCase( t_strComputerName ) )
		{
			t_fGotDC = GetDomainControllerNameNT( a_netapi, t_strDomainName, &t_pwcsDCName ) ;
		}

		if ( t_fGotDC )
		{
			bstr_t t_bstrUserName( t_wstrUserName ) ;

			if ( ERROR_SUCCESS == a_netapi.NetUserGetInfo(	t_pwcsDCName,
															t_bstrUserName,
															2,
															(LPBYTE*) &t_pUserInfo ) )
			{

				t_fReturn = TRUE;
				LoadUserValuesNT(	t_strDomainName,
									t_wstrUserName,
									t_pUserInfo->usri2_full_name,
									t_pUserInfo->usri2_comment,
									t_pUserInfo->usri2_flags,
									a_pInst ) ;

				a_netapi.NetApiBufferFree( t_pUserInfo ) ;
				t_pUserInfo = NULL ;

			}

			// Clean up the domain controller name if we got one.
			if ( NULL != t_pwcsDCName )
			{
				a_netapi.NetApiBufferFree( t_pwcsDCName ) ;
				t_pwcsDCName = NULL ;
			}

		}

		free( t_wstrUserName ) ;
		t_wstrUserName = NULL ;

		return t_fReturn;

	}
	catch( ... )
	{
		if( t_pUserInfo )
		{
			a_netapi.NetApiBufferFree( t_pUserInfo ) ;
		}

		if( t_pwcsDCName )
		{
			a_netapi.NetApiBufferFree( t_pwcsDCName ) ;
		}

		if( t_wstrUserName )
		{
			free( t_wstrUserName ) ;
		}

		throw ;
	}
}
#endif
*/

#ifdef NTONLY
BOOL CWin32UserAccount::GetSingleUserNTW( CNetAPI32& a_netapi, CInstance* a_pInst )
{
	BOOL	t_fReturn			= FALSE,
			t_fGotDC			= TRUE;
	CHString t_chstrDCName;
    WCHAR*	t_wstrDomainName	= NULL;
    WCHAR*	t_wstrUserName		= NULL;
	USER_INFO_2 *t_pUserInfo	= NULL;

    WCHAR t_wstrLocalComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;

	try
	{
		ZeroMemory( t_wstrLocalComputerName, sizeof( t_wstrLocalComputerName ) ) ;

		if(!::GetComputerNameW( t_wstrLocalComputerName, &t_dwNameSize ) )
		{
			return FALSE;
		}

		a_pInst->GetWCHAR( IDS_Domain, &t_wstrDomainName );

		if( t_wstrDomainName == NULL )
		{
			return FALSE;
		}

        if(_wcsicmp(t_wstrLocalComputerName, t_wstrDomainName) == 0)
        {
            a_pInst->Setbool(IDS_LocalAccount, true);
        }
        else
        {
            a_pInst->Setbool(IDS_LocalAccount, false);
        }

		a_pInst->GetWCHAR( IDS_Name, &t_wstrUserName ) ;

		if( t_wstrUserName == NULL )
		{
			free ( t_wstrDomainName ) ;
			t_wstrDomainName = NULL ;
			return FALSE;
		}

 		if ( 0 != _wcsicmp( t_wstrLocalComputerName, t_wstrDomainName ) )
		{
			t_fGotDC = (a_netapi.GetDCName( t_wstrDomainName, t_chstrDCName ) == ERROR_SUCCESS) ;
		}

		if ( t_fGotDC )
		{
			_bstr_t t_bstrtUserName( t_wstrUserName ) ;

			DWORD t_dwError = a_netapi.NetUserGetInfo(	t_chstrDCName,
														(WCHAR*) t_bstrtUserName,
														2,
														(LPBYTE*) &t_pUserInfo ) ;
			if ( ERROR_SUCCESS == t_dwError )
			{

				t_fReturn = TRUE;
				LoadUserValuesNTW(	t_wstrDomainName,
									t_wstrUserName,
									t_pUserInfo->usri2_full_name,
									t_pUserInfo->usri2_comment,
									t_pUserInfo->usri2_flags,
                                    _bstr_t((LPCWSTR)t_chstrDCName),
									a_pInst ) ;

//				a_netapi.NetApiBufferFree( t_pUserInfo ) ;
//				t_pUserInfo = NULL ;
			}

		}
	}
	catch( ... )
	{
        if( t_pUserInfo )
		{
			a_netapi.NetApiBufferFree( t_pUserInfo ) ;
		}

		if( t_wstrUserName )
		{
			free( t_wstrUserName ) ;
		}

		if( t_wstrDomainName )
		{
			free( t_wstrDomainName ) ;
		}

		throw ;
	}

    if( t_pUserInfo )
	{
		a_netapi.NetApiBufferFree( t_pUserInfo ) ;
	}

	free( t_wstrUserName ) ;
	t_wstrUserName = NULL ;

	free( t_wstrDomainName ) ;
	t_wstrDomainName = NULL ;

	return t_fReturn;

}
#endif


/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetSIDInformation
//
//	Obtains the SID Information for the user.
//
//	Inputs:		CHString&		strDomainName - Domain Name.
//				CHString&		strAccountName - Account Name
//				CHString&		strComputerName - Computer Name
//				CInstance*		pInstance - Instance to put values in.
//
//	Outputs:	None.
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:	Call for valid users to get SID data.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CWin32UserAccount::GetSIDInformation(
											const CHString &a_strDomainName,
											const CHString &a_strAccountName,
											const CHString &a_strComputerName,
											CInstance *a_pInst
											)
{
	BOOL t_fReturn = FALSE;


	LPCTSTR	t_pszDomain = (LPCTSTR) a_strDomainName;

  	// Make sure we got the SID and it's all okey dokey
	CSid t_sid( t_pszDomain, a_strAccountName, a_strComputerName ) ;

	if ( t_sid.IsValid() && t_sid.IsOK() )
	{
		a_pInst->SetCHString( IDS_SID, t_sid.GetSidString() ) ;
		a_pInst->SetByte( IDS_SIDType, t_sid.GetAccountType() ) ;

		t_fReturn = TRUE ;
	}

	return t_fReturn;

}
#endif

#ifdef NTONLY
BOOL CWin32UserAccount::GetSIDInformationW(
										   LPCWSTR a_wstrDomainName,
                                           LPCWSTR a_wstrAccountName,
                                           LPCWSTR a_wstrComputerName,
                                           CInstance *a_pInst )
{
	BOOL t_fReturn = FALSE;

	// Make sure we got the SID and it's all okey dokey
	CSid t_sid( a_wstrDomainName, a_wstrAccountName, a_wstrComputerName ) ;

	if ( t_sid.IsValid() && t_sid.IsOK() )
	{
		a_pInst->SetWCHARSplat( IDS_SID, t_sid.GetSidStringW() ) ;
		a_pInst->SetByte( IDS_SIDType, t_sid.GetAccountType() ) ;

		t_fReturn = TRUE ;
	}
	return t_fReturn;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\user.h ===
//=================================================================

//

// User.h -- User property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain users
//
//=================================================================

// Method name for changing the key in this WMI class
#define METHOD_NAME_RenameAccount	L"Rename"

// Method return property
#define METHOD_ARG_NAME_METHODRESULT L"ReturnValue"


// Property set identification
//============================
#define	PROPSET_NAME_USER	L"Win32_UserAccount"

class CWin32UserAccount : public Provider
{
   private:

        // Utility function(s)
        //====================

		BOOL	RefreshInstance( CInstance *a_pInst ) ;
		HRESULT AddDynamicInstances( MethodContext *a_pMethodContext ) ;

	#ifdef NTONLY      
        void LoadUserValuesNT(CHString a_strDomainName, 
                              CHString a_strUserName, 
                              WCHAR *a_pwszFullName, 
                              WCHAR *a_pwszDescription, 
                              DWORD a_dwFlags,
                              WCHAR *a_pwszComputerName, 
                              CInstance *a_pInstance );

        void LoadUserValuesNTW(LPCWSTR a_strDomainName, 
                               LPCWSTR a_strUserName, 
                               LPCWSTR a_pwszFullName, 
                               LPCWSTR a_pwszDescription, 
                               DWORD a_dwFlags,
                               WCHAR *a_pwszComputerName, 
                               CInstance *a_pInstance );

		BOOL GetSIDInformation(const CHString &a_strDomainName, 
                               const CHString &a_strAccountName, 
                               const CHString &a_strComputerName, 
                               CInstance *a_pInst );

        BOOL GetSIDInformationW(LPCWSTR a_wstrDomainName, 
                                LPCWSTR a_wstrAccountName, 
                                LPCWSTR a_wstrComputerName, 
                                CInstance *a_pInst ) ;

        BOOL GetDomainUsersNTW( CNetAPI32 &a_netapi, LPCWSTR a_pszDomain, MethodContext *a_pMethodContext );
		BOOL GetSingleUserNT( CNetAPI32 &a_netapi, CInstance *a_pInst );
        BOOL GetSingleUserNTW( CNetAPI32 &a_netapi, CInstance *a_pInst );
	#endif

	#ifdef WIN9XONLY
        HRESULT AddDynamicInstancesWin95( MethodContext *a_pMethodContext ) ;
	#endif

		HRESULT hRenameAccount( 

			CInstance *a_pInst,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long a_Flags ) ;

    
public:

        // Constructor/destructor
        //=======================

        CWin32UserAccount( const CHString& strName, LPCWSTR pszNamespace ) ;
       ~CWin32UserAccount() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
        virtual HRESULT ExecQuery( MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ ) ;

#ifdef NTONLY	
		virtual	HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);

		virtual	HRESULT ExecMethod(	const CInstance &a_Inst,
									const BSTR a_MethodName, 
									CInstance *a_InParams,
									CInstance *a_OutParams,
									long a_Flags = 0L ) ;

		// method errors -- maps to mof
		enum E_MethodResult	{
			e_Success,
			e_InstanceNotFound,
			e_NoInstance,
			e_InvalidParameter,
			e_UserNotFound,
			e_InvalidComputer,
			e_NotPrimary,
			e_LastAdmin,
			e_SpeGroupOp,
			e_ApiError,
			e_InternalError
		};		

#endif		
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\videocfg.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// VideoCfg.h -- Video property set description for WBEM MO          //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   //
// 09/08/95     a-skaja     Prototype                                //
// 09/27/96     jennymc     Updated to meet current standards        //
// 03/02/99    a-peterc		added graceful exit on SEH and memory failures,
//							clean up
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define	PROPSET_NAME_VIDEOCFG	L"Win32_VideoConfiguration"

class CWin32VideoConfiguration : public Provider
{
	// Utility function(s)
	//====================
   private:

		BOOL GetInstance( CInstance *a_pInst ) ;

	#ifdef NTONLY	    
	    BOOL AssignAdapterLocaleForNT( LPCTSTR a_szSubKey, CInstance *a_pInst ) ;
        BOOL AssignAdapterCompatibilityForNT( LPCTSTR a_szVideoInfo, CInstance*a_pInst ) ;
        BOOL OpenVideoResolutionKeyForNT( LPCTSTR a_szVideoInfo, CRegistry &a_PrimaryReg ) ;
        void AssignFirmwareSetValuesInNT ( CInstance *a_pInst ) ;
	#endif

	#ifdef WIN9XONLY
	   	BOOL AssignWin95DriverValues( CHString a_chsKey, CInstance *a_pInst ) ;
		void GetWin95RefreshRate( CInstance *a_pInst, LPCTSTR a_pszDriver ) ;
	#endif

        BOOL GetCommonVideoInfo( CInstance *a_pInst ) ;

    public:

        // Constructor/destructor
        //=======================

        CWin32VideoConfiguration( const CHString& a_strName, LPCWSTR a_pszNamespace ) ;
       ~CWin32VideoConfiguration() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
} ;

///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
#define WINNT_VIDEO_REGISTRY_KEY             L"HARDWARE\\DEVICEMAP\\VIDEO"
#define WINNT_OTHER_VIDEO_REGISTRY_KEY		 L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000"
#define WINNT_OTHER_OTHER_VIDEO_REGISTRY_KEY L"SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000"

#define ADAPTER_DESC L"DriverDesc"
#define MONITOR_TYPE L"DriverDesc"
#define MONITOR_MFG L"DriverDesc"
#define MFG L"Mfg"
#define VREFRESH_RATE                        L"DefaultSettings.VRefresh"
#define ADAPTER_COMPATIBILITY                L"Adapter Compatibility"
#define VIDEO_INFO_PATH                      L"\\Device\\Video0"
#define SERVICES                             L"\\SERVICES\\"
#define DEVICE                               L"\\DEVICE"
#define SYSTEM                               L"\\SYSTEM"
#define INTERLACED                           L"DefaultSettings.Interlaced"
#define INSTALLED_DISPLAY_DRIVERS            L"InstalledDisplayDrivers"
#define ADAPTER_RAM                          L"HardwareInformation.MemorySize"
#define ADAPTER_DESCRIPTION                  L"HardwareInformation.AdapterString"
#define ADAPTER_CHIPTYPE                     L"HardwareInformation.ChipType"
#define ADAPTER_DAC_TYPE                     L"HardwareInformation.DACType"
#define WINNT_HARDWARE_DESCRIPTION_REGISTRY_KEY L"HARDWARE\\Description\\System"
#define DISPLAY_CONTROLLER                   L"DisplayController"
#define INTERNAL                             L"INTERNAL"
#define INTEGRATED_CIRCUITRY                 L"Integrated circuitry/Internal"
#define ADD_ON_CARD                          L"Add-on card on "
#define MONITOR_PERIPHERAL                   L"\\MonitorPeripheral\\0"
#define ZERO                                 L"\\0"
#define IDENTIFIER                           L"Identifier"
#define SLASH                                L"\\"
#define	REFRESHRATE							L"RefreshRate"
#define INF_PATH        L"InfPath"
#define INF_SECTION     L"InfSection"
#define DRIVER_DATE     L"DriverDate"
///////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\videocfg.cpp ===
//

// VideoCfg.cpp -- video managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 09/23/95     a-skaja     Prototype for demo
// 09/27/96     jennymc     Updated to current standards
// 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//							clean up
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>
#include "ProvExce.h"
#include "multimonitor.h"
#include "videocfg.h"
#include "resource.h"


//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32VideoConfiguration	win32VideoCfg(PROPSET_NAME_VIDEOCFG, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoConfiguration::CWin32VideoConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32VideoConfiguration::CWin32VideoConfiguration(const CHString& a_strName,
												   LPCWSTR a_pszNamespace /*=NULL*/)
:	Provider(a_strName, a_pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoConfiguration::~CWin32VideoConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32VideoConfiguration::~CWin32VideoConfiguration()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32VideoConfiguration::GetObject
//
//	Inputs:		CInstance*		a_pInst - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32VideoConfiguration::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
	BOOL	t_fReturn = FALSE;
	CHString t_InName, t_OutName, t_InAdapter, t_OutAdapter;

	a_pInst->GetCHString(IDS_AdapterCompatibility, t_InAdapter);
	a_pInst->GetCHString(IDS_Name, t_InName);

	// Find the instance depending on platform id.
	t_fReturn = GetInstance(a_pInst);

	a_pInst->GetCHString(IDS_AdapterCompatibility, t_OutAdapter);
	a_pInst->GetCHString(IDS_Name, t_OutName);

	if (t_InAdapter.CompareNoCase(t_OutAdapter) != 0 ||
		t_OutName.CompareNoCase(t_InName) != 0)
	{
		t_fReturn = FALSE;
	}

	return t_fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32VideoConfiguration::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32VideoConfiguration::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT		t_hResult	= WBEM_S_NO_ERROR;
	CInstancePtr t_pInst(CreateNewInstance(a_pMethodContext), false);

	// Get the proper OS dependent instance
	if (GetInstance(t_pInst))
	{
		t_hResult = t_pInst->Commit();
	}

	return t_hResult;
}

//////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
BOOL CWin32VideoConfiguration::AssignWin95DriverValues(CHString a_chsDriver,
													   CInstance* a_pInst)
{
	BOOL		t_fRc = FALSE;
	CRegistry	t_Reg;
	CHString	t_chsTmp, t_chsKey;
	struct tm	t_tmDate;
	DWORD		t_dwTmp;

	t_chsKey = L"System\\CurrentControlSet\\Services\\Class\\" + a_chsDriver;

	if (t_Reg.Open(HKEY_LOCAL_MACHINE, t_chsKey, KEY_READ) == ERROR_SUCCESS)
	{
		if (t_Reg.GetCurrentKeyValue(L"DriverDate", t_chsTmp) == ERROR_SUCCESS)
		{
			memset(&t_tmDate, 0, sizeof(t_tmDate));
			swscanf(TOBSTRT(t_chsTmp), L"%d-%d-%d",
										&t_tmDate.tm_mon,
										&t_tmDate.tm_mday,
										&t_tmDate.tm_year);

			// per documentation - the struct tm.tm_year is year - 1900
			// no hint as to whether it's year 2k compliant.
			t_tmDate.tm_year = t_tmDate.tm_year - 1900;

			// and the month is zero based
			t_tmDate.tm_mon--;
			a_pInst->SetDateTime(IDS_DriverDate, (WBEMTime)t_tmDate);
		}

		if (t_Reg.GetCurrentKeyValue(INF_PATH, t_chsTmp) == ERROR_SUCCESS)
		{
		    a_pInst->SetCHString(IDS_InfFileName, t_chsTmp);
		}
		if (t_Reg.GetCurrentKeyValue(INF_SECTION, t_chsTmp) == ERROR_SUCCESS)
		{
		    a_pInst->SetCHString(IDS_InfSection, t_chsTmp);
		}

		t_chsTmp = t_chsKey + _T("\\Default");
		if (t_Reg.Open(HKEY_LOCAL_MACHINE, t_chsTmp, KEY_READ) == ERROR_SUCCESS)
		{
			if (t_Reg.GetCurrentKeyValue(L"drv", t_chsTmp) == ERROR_SUCCESS)
			{
			    a_pInst->SetCHString(IDS_InstalledDisplayDrivers, t_chsTmp);
			}
		}

		t_chsTmp = t_chsKey + _T("\\Info");
		if (t_Reg.Open(HKEY_LOCAL_MACHINE, t_chsTmp, KEY_READ) == ERROR_SUCCESS)
		{
			if (t_Reg.GetCurrentKeyValue(L"ChipType", t_chsTmp) == ERROR_SUCCESS)
			{
                CHString t_chsTmp2;
                if (t_Reg.GetCurrentKeyValue(L"Revision", t_chsTmp2) == ERROR_SUCCESS)
				{
                    t_chsTmp += _T(" Rev ") + t_chsTmp2;
                }
			    a_pInst->SetCHString(IDS_AdapterChipType, t_chsTmp);
			}

			if (t_Reg.GetCurrentKeyValue(L"DACType", t_chsTmp) == ERROR_SUCCESS)
			{
			    a_pInst->SetCHString(IDS_AdapterDACType, t_chsTmp);
			}

            DWORD dwSize = 4;
			if (t_Reg.GetCurrentBinaryKeyValue(L"VideoMemory",(BYTE*) &t_dwTmp, &dwSize) == ERROR_SUCCESS)
			{
			    a_pInst->SetDWORD(IDS_AdapterRAM, t_dwTmp);
			}
		}

		t_fRc = TRUE;
	}

	GetWin95RefreshRate(a_pInst, TOBSTRT(a_chsDriver));

	return t_fRc;
}
#endif

#ifdef WIN9XONLY
void CWin32VideoConfiguration::GetWin95RefreshRate(CInstance *a_pInst, LPCTSTR a_pszDriver)
{
	CRegistry	t_reg;
	CHString	t_strRefreshRate,
				t_strKey;
	HDC			t_hdc = NULL;

	try
	{
		t_hdc = GetDC(NULL);

		// Need DC to do this test.
		if (NULL != t_hdc)
		{
			DWORD	t_dwHorzRes = (DWORD) GetDeviceCaps (t_hdc, HORZRES);
			DWORD	t_dwVertRes = (DWORD) GetDeviceCaps (t_hdc, VERTRES);
			DWORD	t_dwBitsPerPixel = (DWORD) GetDeviceCaps (t_hdc, BITSPIXEL);

			// Build the keyname where we will be able to find refresh rate.
			// KeyName is under the driver\MODES\n\x,y key where n is BitsPerPixel
			// x is Horizontal Resolution and y is Vertical Resolution

			t_strKey.Format(L"System\\CurrentControlSet\\Services\\Class\\%S\\MODES\\%d\\%d,%d",
				a_pszDriver, t_dwBitsPerPixel, t_dwHorzRes, t_dwVertRes);

			// If under this key, we find a RefreshRate, this rate is the one we want.
			if (t_reg.Open(HKEY_LOCAL_MACHINE, t_strKey, KEY_READ) == ERROR_SUCCESS)
			{
				t_reg.GetCurrentKeyValue(REFRESHRATE, t_strRefreshRate);
			}
		}


		// If we don't have a refresh rate yet, check under the Driver\DEFAULT key.
		// This value can be 0 or -1, which mean Default and Optimal rates respectively.
		if (t_strRefreshRate.IsEmpty())
		{
			t_strKey.Format(
				L"System\\CurrentControlSet\\Services\\Class\\%S\\DEFAULT",
				a_pszDriver);

			if (t_reg.Open(HKEY_LOCAL_MACHINE, t_strKey, KEY_READ) == ERROR_SUCCESS)
			{
				t_reg.GetCurrentKeyValue(REFRESHRATE, t_strRefreshRate);
			}
		}

		// If we still don't have a value, IT AIN'T THERE!!!!!!
		if (!t_strRefreshRate.IsEmpty())
		{
			// -1 is a valid return
			DWORD t_dwRefreshRate = _wtol(t_strRefreshRate);

			a_pInst->SetDWORD(IDS_RefreshRate, t_dwRefreshRate);
		}
	}
	catch(...)
	{
        if (t_hdc)
		{
			ReleaseDC (NULL, t_hdc);
		}

		throw;
	}

	ReleaseDC (NULL, t_hdc);
	t_hdc = NULL;
}
#endif


//////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
BOOL CWin32VideoConfiguration::GetInstance(CInstance* a_pInst)
{
    CHString t_chsTmp, t_chsTmp2;
    CHPtrArray t_chsaList;

	CMultiMonitor		t_multiMonitor;
	CConfigMgrDevicePtr	t_pMonitor;
	CConfigMgrDevicePtr t_pDisplayAdapter;

	// For now, support a single monitor
	if (t_multiMonitor.GetMonitorDevice(0, &t_pMonitor))
	{
		// Set monitor properties
		if (t_pMonitor->GetDeviceDesc(t_chsTmp))
		{
			a_pInst->SetCHString(IDS_MonitorType, t_chsTmp);
		}

		if (t_pMonitor->GetMfg(t_chsTmp))
		{
			a_pInst->SetCHString(IDS_MonitorManufacturer, t_chsTmp);
		}

		// A monitor's parent is the display adapter it's plugged into (imagine that)
		if (t_pMonitor->GetParent(&t_pDisplayAdapter))
		{

			// Set DisplayAdapter properties
			if (t_pDisplayAdapter->GetDeviceDesc(t_chsTmp))
			{
				a_pInst->SetCHString(IDS_AdapterDescription, t_chsTmp);
			}

			if (t_pDisplayAdapter->GetMfg(t_chsTmp))
			{
				a_pInst->SetCHString(IDS_AdapterCompatibility, t_chsTmp);
			}

			// Retrieve the driver name and got there for EVEN MORE INFO!  WOOHOO!
			if (t_pMonitor->GetDriver(t_chsTmp))
			{
				AssignWin95DriverValues(t_chsTmp, a_pInst);
			}
		}

	}	// IF Got Monitor

	return(GetCommonVideoInfo(a_pInst));
}
#endif

//////////////////////////////////////////////////////////////////
BOOL CWin32VideoConfiguration::GetCommonVideoInfo(CInstance *a_pInst)
{
    HDC t_hdc = NULL;

	try
	{
		a_pInst->SetCharSplat(IDS_Name, L"Current Video Configuration");

        CHString sTemp2;
        LoadStringW(sTemp2, IDR_CurrentVideoConfiguration);

		a_pInst->SetCHString(IDS_Caption, sTemp2);
		a_pInst->SetCHString(IDS_Description, sTemp2);

		if (!(t_hdc = GetDC (NULL)))
		{
			return FALSE;
		}

		//  Get the common info
		//=============================
		a_pInst->SetDWORD(IDS_ScreenWidth, (DWORD) GetDeviceCaps (t_hdc, HORZSIZE));
		a_pInst->SetDWORD(IDS_ScreenHeight, (DWORD) GetDeviceCaps (t_hdc, VERTSIZE));
		a_pInst->SetDWORD(IDS_HorizontalResolution, (DWORD) GetDeviceCaps (t_hdc, HORZRES));
		a_pInst->SetDWORD(IDS_VerticalResolution, (DWORD) GetDeviceCaps (t_hdc, VERTRES));
		a_pInst->SetDWORD(IDS_PixelsPerXLogicalInch, (DWORD) GetDeviceCaps (t_hdc, LOGPIXELSX));
		a_pInst->SetDWORD(IDS_PixelsPerYLogicalInch, (DWORD) GetDeviceCaps (t_hdc, LOGPIXELSY));
		a_pInst->SetDWORD(IDS_BitsPerPixel, (DWORD) GetDeviceCaps (t_hdc, BITSPIXEL));
		a_pInst->SetDWORD(IDS_ColorPlanes, (DWORD) GetDeviceCaps (t_hdc, PLANES));
		a_pInst->SetDWORD(IDS_DeviceSpecificPens, (DWORD) GetDeviceCaps (t_hdc, NUMPENS));
		a_pInst->SetDWORD(IDS_ColorTableEntries, (DWORD) GetDeviceCaps (t_hdc, NUMCOLORS));
		a_pInst->SetDWORD(IDS_ActualColorResolution, (DWORD) GetDeviceCaps (t_hdc, COLORRES));

		if (GetDeviceCaps(t_hdc, RASTERCAPS) & RC_PALETTE)
		{
			a_pInst->SetDWORD(IDS_SystemPaletteEntries, (DWORD) GetDeviceCaps (t_hdc, SIZEPALETTE));
		}
		// if we didn't find refresh rate before - try this way...
	#ifdef NTONLY
			DWORD t_deWord = (DWORD) GetDeviceCaps(t_hdc, VREFRESH);
			BOOL t_Clear = a_pInst->IsNull (IDS_RefreshRate) ||
							(! a_pInst->GetDWORD(IDS_RefreshRate, t_deWord)) || (! t_deWord);
			if (t_Clear)
			{
				a_pInst->SetDWORD(IDS_RefreshRate,  (DWORD) GetDeviceCaps(t_hdc, VREFRESH));
			}
	#endif

	}
	catch(...)
	{
        if (t_hdc)
		{
			ReleaseDC (NULL, t_hdc);
		}

		throw;
	}

	ReleaseDC(NULL, t_hdc);

	return TRUE;
}

//////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32VideoConfiguration::AssignAdapterLocaleForNT(LPCTSTR a_szSubKey,  CInstance *a_pInst)
{
    CRegistry t_Reg;
    CHString t_TempBuffer;
    TCHAR t_szTempBuffer[_MAX_PATH+2];

    if (t_Reg.OpenLocalMachineKeyAndReadValue(a_szSubKey, IDENTIFIER, t_TempBuffer) != ERROR_SUCCESS)
	{
        return FALSE;
    }

	t_TempBuffer.MakeUpper();

    if (_tcsstr (t_TempBuffer, INTERNAL))
	{
        a_pInst->SetCHString(IDS_AdapterLocale, INTEGRATED_CIRCUITRY);
    }
	else {
        _stprintf(t_szTempBuffer, _T("%s%s"), ADD_ON_CARD, t_TempBuffer);
        a_pInst->SetCHString(IDS_AdapterLocale, t_szTempBuffer);
    }

    return TRUE;
}
#endif
//////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32VideoConfiguration::AssignAdapterCompatibilityForNT(LPCTSTR a_szVideoInfo, CInstance *a_pInst)
{
    TCHAR *t_pPtr;
    TCHAR t_szTemp[_MAX_PATH+2];

    t_pPtr = _tcsstr (a_szVideoInfo, SERVICES);

    if (t_pPtr)
	{
        t_pPtr += lstrlen (SERVICES);
        lstrcpy (t_szTemp, t_pPtr);

		t_pPtr = _tcsstr (t_szTemp, DEVICE);
        *t_pPtr = NULL;

        a_pInst->SetCHString(IDS_AdapterCompatibility, t_szTemp);

		return TRUE;
    }
    else
	{
		LogEnumValueError(_T(__FILE__), __LINE__, ADAPTER_COMPATIBILITY, WINNT_VIDEO_REGISTRY_KEY);
        return FALSE;
	}
}
#endif
////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32VideoConfiguration::OpenVideoResolutionKeyForNT(LPCTSTR a_szVideoInfo,
                                                        CRegistry &a_PrimaryReg)
{
    TCHAR *t_pPtr;
    TCHAR t_szTemp[_MAX_PATH+2];

    // point to the system section
    //============================
    t_pPtr = _tcsstr(a_szVideoInfo, SYSTEM);

    // If "system" existed, then use the balance
    // as a pointer into the registry
    //============================================
    if (!t_pPtr)
	{
        return FALSE;
	}

	// get past backslash
    //============================================
    ++t_pPtr;

    // Copy the balance of the string as a pointer
    // to the location in the registry for the
    // information for the miniport video driver
    //============================================
    lstrcpy(t_szTemp, (LPCTSTR) t_pPtr);

    // use path to locate the video resolution etc and TYPE
    //=====================================================
    if (a_PrimaryReg.Open(HKEY_LOCAL_MACHINE, t_szTemp, KEY_READ) != ERROR_SUCCESS)
	{
        LogOpenRegistryError(_T(__FILE__), __LINE__, t_szTemp);
		return FALSE;
	}

	// else...
    return TRUE;
}
#endif
////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32VideoConfiguration::GetInstance(CInstance* a_pInst)
{
    CRegistry t_PrimaryReg;
    CHString t_chsTmp, t_chsVideoInfo;
    TCHAR* t_pPtr;
    DWORD t_dwTmp;
    BOOL t_fComma = FALSE;
    WCHAR t_szTemp[_MAX_PATH];
    TCHAR t_szTmp[_MAX_PATH];

    //****************************************
    //  Get AdapterLocale, Monitor Type and
    //  Adapter Type
    //****************************************
    AssignFirmwareSetValuesInNT (a_pInst);

    //****************************************
    //  Now, open the key to get the NT stuff
    //****************************************
    if (t_PrimaryReg.OpenLocalMachineKeyAndReadValue(
            WINNT_VIDEO_REGISTRY_KEY,
            VIDEO_INFO_PATH,
            t_chsVideoInfo) != ERROR_SUCCESS)
	{
        return FALSE;
    }
	t_chsVideoInfo.MakeUpper();

    if (!AssignAdapterCompatibilityForNT(t_chsVideoInfo, a_pInst))
	{
        return FALSE;
	}

    if (!OpenVideoResolutionKeyForNT(t_chsVideoInfo, t_PrimaryReg))
	{
        return FALSE;
	}

	CHString t_strInstalledDisplayDrivers;

    if (t_PrimaryReg.GetCurrentKeyValue(INSTALLED_DISPLAY_DRIVERS, t_chsTmp) == ERROR_SUCCESS)
	{
        t_pPtr = _tcstok((LPTSTR) (LPCTSTR) t_chsTmp, _T("\n"));

		while(t_pPtr)
		{
            if (t_fComma)
			{
                t_strInstalledDisplayDrivers += _T(",");
            }

			t_strInstalledDisplayDrivers += t_pPtr;
            t_fComma = TRUE;
            t_pPtr = _tcstok(NULL, _T("\n"));
        }
    }

	if (!t_strInstalledDisplayDrivers.IsEmpty())
	{
		a_pInst->SetCHString(IDS_InstalledDisplayDrivers, t_strInstalledDisplayDrivers);
 	}

    DWORD dwSize;

    dwSize = 4;
    if (t_PrimaryReg.GetCurrentBinaryKeyValue(ADAPTER_RAM,(LPBYTE) &t_dwTmp, &dwSize) == ERROR_SUCCESS)
        a_pInst->SetDWORD(IDS_AdapterRAM, t_dwTmp);

    dwSize = sizeof(t_szTemp);
    if (t_PrimaryReg.GetCurrentBinaryKeyValue(ADAPTER_DESCRIPTION, (BYTE *) &t_szTemp, &dwSize) == ERROR_SUCCESS)
	{
        a_pInst->SetCHString(IDS_AdapterDescription, t_szTemp);
    }

    dwSize = sizeof(t_szTemp);
    if (t_PrimaryReg.GetCurrentBinaryKeyValue(ADAPTER_CHIPTYPE, (BYTE *) &t_szTemp, &dwSize) == ERROR_SUCCESS)
	{
        a_pInst->SetCHString(IDS_AdapterChipType, t_szTemp);
    }

    dwSize = sizeof(t_szTemp);
    if (t_PrimaryReg.GetCurrentBinaryKeyValue(ADAPTER_DAC_TYPE, (BYTE *) &t_szTemp, &dwSize) == ERROR_SUCCESS)
	{
		a_pInst->SetCHString(IDS_AdapterDACType, t_szTemp);
    }

    //****************************************
    //  Get the info from Current Config
    //****************************************
    _stprintf(t_szTmp,
        _T("System\\CurrentControlSet\\Services\\%s\\Device0"),
        t_strInstalledDisplayDrivers);

    if (t_PrimaryReg.Open(HKEY_CURRENT_CONFIG, t_szTmp, KEY_READ) == ERROR_SUCCESS)
	{
        dwSize = 4;
        if (t_PrimaryReg.GetCurrentBinaryKeyValue(INTERLACED,(BYTE*) &t_dwTmp, &dwSize)== ERROR_SUCCESS)
		{
            if (0 == t_dwTmp)
			{
                a_pInst->SetCHString(IDS_ScanMode, _T("Non Interlaced"));
            }
			else
			{
                a_pInst->SetCHString(IDS_ScanMode, _T("Interlaced"));
			}
        }

        dwSize = 4;
		if (t_PrimaryReg.GetCurrentBinaryKeyValue(VREFRESH_RATE, (BYTE *) &t_dwTmp, &dwSize) == ERROR_SUCCESS)
		{
            a_pInst->SetDWORD(IDS_RefreshRate, t_dwTmp);
        }
    }

	// try reading INF stuff out of currentControlSet, if that doesn't work, try 001.
	// (On NT five, CurrentControlSet doesn't seem very populated, real data shows up in ControlSet001)
	if (t_PrimaryReg.Open(HKEY_LOCAL_MACHINE, WINNT_OTHER_VIDEO_REGISTRY_KEY, KEY_READ) == ERROR_SUCCESS	||
		 t_PrimaryReg.Open(HKEY_LOCAL_MACHINE, WINNT_OTHER_OTHER_VIDEO_REGISTRY_KEY, KEY_READ) == ERROR_SUCCESS)
	{
		CHString t_tmp;

		if (t_PrimaryReg.GetCurrentKeyValue(INF_PATH, t_tmp) == ERROR_SUCCESS)
		{
		    a_pInst->SetCHString(IDS_InfFileName, t_tmp);
		}

		if (t_PrimaryReg.GetCurrentKeyValue(INF_SECTION, t_chsTmp) == ERROR_SUCCESS)
		{
		    a_pInst->SetCHString(IDS_InfSection, t_chsTmp);
		}

		t_PrimaryReg.Close();
	}

    //****************************************
    //  Get the common Video info
    //****************************************
    return GetCommonVideoInfo(a_pInst);
}
#endif

////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
void CWin32VideoConfiguration::AssignFirmwareSetValuesInNT (CInstance *a_pInst)
{
    CHString *t_pPtr, t_chsTmp;
    CHPtrArray t_chsaList;
    CRegistrySearch t_Search;
    CRegistry t_PrimaryReg;

	try
	{
		t_chsTmp=_T("");
		t_Search.SearchAndBuildList(WINNT_HARDWARE_DESCRIPTION_REGISTRY_KEY,
								   t_chsaList, DISPLAY_CONTROLLER, t_chsTmp,
								   KEY_FULL_MATCH_SEARCH);

		int t_nNum =  t_chsaList.GetSize();

		if (t_nNum > 0)
		{
			t_pPtr = (CHString *) t_chsaList.GetAt(0);

			if (t_pPtr)
			{
				if (t_PrimaryReg.Open(HKEY_LOCAL_MACHINE, *t_pPtr, KEY_READ) == ERROR_SUCCESS)
				{
					CRegistry t_Reg;
					TCHAR t_szSubKey[_MAX_PATH+2];

					AssignAdapterLocaleForNT(*t_pPtr, a_pInst);

					_stprintf(t_szSubKey, _T("%s%s"),*t_pPtr, ZERO);

                    if (t_Reg.OpenLocalMachineKeyAndReadValue(t_szSubKey, IDENTIFIER, t_chsTmp) == ERROR_SUCCESS)
					{
						a_pInst->SetCHString(IDS_AdapterType, t_chsTmp);
					}

					_stprintf(t_szSubKey, _T("%s%s"), *t_pPtr, MONITOR_PERIPHERAL);
                    if (t_Reg.OpenLocalMachineKeyAndReadValue(t_szSubKey, IDENTIFIER, t_chsTmp) == ERROR_SUCCESS)
					{
						a_pInst->SetCHString(IDS_MonitorType, t_chsTmp);
					}
				}
			}
		}
		else // That didn't work, so try using config. manager.
		{
			// This code lifted from displaycfg.cpp.
			// TODO: Win32_DisplayConfiguration and Win32_VideoConfiguration seem
			//       to be an awful lot alike.  Why do we have both?
    		CConfigManager      t_configMngr;
			CDeviceCollection   t_devCollection;

			if (t_configMngr.GetDeviceListFilterByClass(t_devCollection, _T("Display")))
			{
				REFPTR_POSITION t_pos;

				t_devCollection.BeginEnum(t_pos);

				CHString            t_strDriverName,
									t_strDesc;

				if (t_devCollection.GetSize())
				{
                    CConfigMgrDevicePtr t_pDevice;
					t_pDevice.Attach(t_devCollection.GetNext(t_pos));
					if (t_pDevice != NULL)
					{
						t_pDevice->GetDeviceDesc(t_strDesc);
						a_pInst->SetCHString(IDS_AdapterType, t_strDesc);

					}
				}
			}
		}

	}
	catch(...)
	{
		t_Search.FreeSearchList(CSTRING_PTR, t_chsaList);

		throw;
	}

	t_Search.FreeSearchList(CSTRING_PTR, t_chsaList);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\videocontroller.cpp ===
//=================================================================

//

// VideoController.CPP

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//				 03/02/99    a-peterc		  added graceful exit on SEH and memory failures
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "sid.h"
#include "implogonuser.h"
#include "VideoController.h"
#include <ProvExce.h>
#include "multimonitor.h"
#include "resource.h"

// Property set declaration
//=========================

CWin32VideoController startupCommand(
	L"Win32_VideoController",
	IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoController::CWin32VideoController
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32VideoController::CWin32VideoController(const CHString& szName,
	LPCWSTR szNamespace) : Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoController::~CWin32VideoController
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32VideoController::~CWin32VideoController()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoController::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32VideoController::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags /*= 0L*/)
{
	HRESULT       hResult = WBEM_S_NO_ERROR;
	CInstancePtr  pInst;
    CMultiMonitor monitor;

	for (int i = 0; i < monitor.GetNumAdapters() && SUCCEEDED(hResult); i++)
	{
		CHString strDeviceID,
				 strDeviceName;

        pInst.Attach(CreateNewInstance(pMethodContext));

		// Set the device ID.
		strDeviceID.Format(L"VideoController%d", i + 1);
		pInst->SetCharSplat(L"DeviceID", strDeviceID);

		SetProperties(pInst, &monitor, i);
		hResult = pInst->Commit();
	}

	return hResult;
}

#ifdef WIN9XONLY
void CWin32VideoController::GetFullFileName(CHString* pchsShortFileName)
{
	TCHAR szPath[_MAX_PATH];
	if(GetWindowsDirectory(szPath, _MAX_PATH) == 0)
	{
		return;
	}
	CHString pchsstrTemp;
	pchsstrTemp.Format(L"%S\\inf\\%s", szPath, pchsShortFileName->GetBuffer(_MAX_PATH));

	WIN32_FIND_DATA stWin32FindData;
	//search in windows\inf directory first, if not found then search in sub dirs of windows\inf
	SmartFindClose hFileHandle = FindFirstFile(TOBSTRT(pchsstrTemp), &stWin32FindData);
	if (hFileHandle != INVALID_HANDLE_VALUE)
	{
		pchsShortFileName->Format(L"%S", stWin32FindData.cFileName);
		return;
	}
	pchsstrTemp.Format(L"%S\\inf\\*.*", szPath);
	hFileHandle = FindFirstFile(TOBSTRT(pchsstrTemp), &stWin32FindData);
	if (hFileHandle != INVALID_HANDLE_VALUE)
	{
		if (stWin32FindData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
		{
			pchsstrTemp.Format(L"%S\\inf\\%S\\%s", szPath, stWin32FindData.cFileName, pchsShortFileName->GetBuffer(_MAX_PATH));
			SmartFindClose hSubFileHandle = FindFirstFile(TOBSTRT(pchsstrTemp), &stWin32FindData);
			if (hSubFileHandle != INVALID_HANDLE_VALUE)
			{
				pchsShortFileName->Format(L"%S", stWin32FindData.cFileName);
				return;
			}
		}
		while(FindNextFile(hFileHandle, &stWin32FindData))
		{
			if (stWin32FindData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
			{
				pchsstrTemp.Format(L"%S\\inf\\%S\\%s", szPath, stWin32FindData.cFileName, pchsShortFileName->GetBuffer(_MAX_PATH));
				SmartFindClose hSubFileHandle = FindFirstFile(TOBSTRT(pchsstrTemp), &stWin32FindData);
				if (hSubFileHandle != INVALID_HANDLE_VALUE)
				{
					pchsShortFileName->Format(L"%S", stWin32FindData.cFileName);
					return;
				}
			}
		}
	}
}
#endif

#ifdef NTONLY
void CWin32VideoController::SetServiceProperties(
    CInstance *pInst,
    LPCWSTR szService,
    LPCWSTR szSettingsKey)
{
 	CRegistry reg;
    CHString  strFileName,
              strVersion;
	DWORD     dwTemp;
    WCHAR     wszTemp[256];

    // Get the version by getting the service name and getting its
	// version information.
	if (!GetServiceFileName(szService, strFileName) ||
        strFileName.IsEmpty())
    {
        WCHAR szSystem[MAX_PATH * 2];

        GetSystemDirectoryW(szSystem, sizeof(szSystem) / sizeof(WCHAR));
        strFileName.Format(
            L"%s\\drivers\\%s.sys",
            szSystem,
            szService);
    }

	if (GetVersionFromFileName(strFileName, strVersion))
   	    pInst->SetCHString(IDS_DriverVersion, strVersion);

    CHString strDate = GetDateTimeViaFilenameFiletime(
                           TOBSTRT(strFileName),
                           FT_MODIFIED_DATE);

    if (!strDate.IsEmpty())
    {
        pInst->SetCharSplat(L"DriverDate", strDate);
    }

    DWORD dwRegSize;

	// Do the setttings property stuff.
	if (reg.Open(
		HKEY_LOCAL_MACHINE,
		szSettingsKey,
		KEY_READ) == ERROR_SUCCESS)
	{
    	CHString strDrivers;

		// This is a REG_MULTI_SZ, so replace all '\n' with ','.
		if (reg.GetCurrentKeyValue(
			L"InstalledDisplayDrivers",
			strDrivers) == ERROR_SUCCESS)
		{
			int iWhere,
				iLen = strDrivers.GetLength();

			// Replace all '\n' with ','.
			while ((iWhere = strDrivers.Find(L'\n')) != -1)
			{
				// If the last char is a '\n', make it a '\0'.
				strDrivers.SetAt(iWhere, iWhere == iLen - 1 ? 0 : L',');
			}
			GetFileExtensionIfNotAlreadyThere(&strDrivers);
		}

		if (!strDrivers.IsEmpty())
		{
			pInst->SetCHString(IDS_InstalledDisplayDrivers, strDrivers);
		}

        dwRegSize = 4;

		if (reg.GetCurrentBinaryKeyValue(
			L"HardwareInformation.MemorySize",
			(LPBYTE) &dwTemp, &dwRegSize) == ERROR_SUCCESS)
		{
			pInst->SetDWORD(IDS_AdapterRAM, dwTemp);
		}

		// Get the device description.  This might have already been done by
        // the cfg mgr properties, in which case we can skip the extra work.
		if (pInst->IsNull(IDS_Description))
        {
		    CHString    strDescription;
		    DWORD       dwType,
					    dwSize;

		    // First we have to find what type this field is.  On NT4 it's
		    // REG_SZ, on NT5 it's REG_BINARY.
		    if (RegQueryValueEx(
			    reg.GethKey(),
			    _T("Device Description"),
			    NULL,
			    &dwType,
			    NULL,
			    &dwSize) == ERROR_SUCCESS)
		    {
			    if (dwType == REG_SZ)
			    {
				    reg.GetCurrentKeyValue(
					    _T("Device Description"),
					    strDescription);
			    }
			    else if (dwType == REG_BINARY)
			    {
                    dwRegSize = sizeof(wszTemp);
				    reg.GetCurrentBinaryKeyValue(
					    _T("Device Description"),
					    (BYTE *) wszTemp, &dwRegSize);

				    strDescription = wszTemp;
			    }
		    }

		    if (strDescription.IsEmpty())
		    {
			    // If Device Description didn't work, try AdapterString.
                dwRegSize = sizeof(wszTemp);

			    if (reg.GetCurrentBinaryKeyValue(
				    _T("HardwareInformation.AdapterString"),
				    (BYTE *) wszTemp, &dwRegSize) == ERROR_SUCCESS)
			    {
				    strDescription = wszTemp;
			    }
		    }

            pInst->SetCHString(IDS_Description, strDescription);
		    pInst->SetCHString(IDS_Caption, strDescription);
		    pInst->SetCHString(IDS_Name, strDescription);
        }

        dwRegSize = sizeof(wszTemp);
		if (reg.GetCurrentBinaryKeyValue(
			_T("HardwareInformation.ChipType"),
			(BYTE *) wszTemp, &dwRegSize) == ERROR_SUCCESS)
		{
			pInst->SetCHString(_T("VideoProcessor"), wszTemp);
		}

        dwRegSize = sizeof(wszTemp);
		if (reg.GetCurrentBinaryKeyValue(
			_T("HardwareInformation.DACType"),
			(BYTE *) wszTemp, &dwRegSize) == ERROR_SUCCESS)
		{
			pInst->SetCHString(IDS_AdapterDACType, wszTemp);
		}
	}
}
#endif

#ifdef NTONLY
void CWin32VideoController::GetFileExtensionIfNotAlreadyThere(CHString* pchsInstalledDriverFiles)
{
	CHString strFindFile;
	CHString strInstalledAllDriverFiles, strTemp;
	CHString* pstrInstalledDriverFiles = pchsInstalledDriverFiles;
	int iWhere,
		iFirst = 0;

    while ((iWhere = pstrInstalledDriverFiles->Find(_T(','))) != -1)
	{
		strFindFile = pstrInstalledDriverFiles->Mid(iFirst, iWhere);
		*pstrInstalledDriverFiles = pstrInstalledDriverFiles->Mid(iWhere + 1);
		GetFileExtension(strFindFile, &strTemp);
		if(strTemp.IsEmpty())
			strInstalledAllDriverFiles = strInstalledAllDriverFiles + strFindFile + L",";
		else
			strInstalledAllDriverFiles = strInstalledAllDriverFiles + strTemp + L",";
	}
	strFindFile.Format(L"%s", pstrInstalledDriverFiles->GetBuffer(_MAX_PATH));
	GetFileExtension(strFindFile, &strTemp);
	if(strTemp.IsEmpty())
		strInstalledAllDriverFiles = strInstalledAllDriverFiles + strFindFile;
	else
		strInstalledAllDriverFiles = strInstalledAllDriverFiles + strTemp;
	pchsInstalledDriverFiles->Format(L"%s", strInstalledAllDriverFiles);
}
void CWin32VideoController::GetFileExtension(CHString& pchsFindfileExtension, CHString* pstrFindFile)
{
	int iWhere;
	while ((iWhere = pchsFindfileExtension.Find(_T('.'))) != -1)
	{
		return;
	}
	TCHAR szPath[_MAX_PATH];
	if(GetWindowsDirectory(szPath, _MAX_PATH) == 0)
	{
		pstrFindFile->Empty();
		return;
	}
	pstrFindFile->Format(L"%s\\system32\\drivers\\%s.*", szPath, pchsFindfileExtension);
	WIN32_FIND_DATA stWin32FindData;
	SmartFindClose hFileHandle(FindFirstFile(pstrFindFile->GetBuffer(_MAX_PATH), &stWin32FindData));
	if (hFileHandle != INVALID_HANDLE_VALUE)
	{
		pstrFindFile->Format(L"%s", stWin32FindData.cFileName);
		return;
	}
	pstrFindFile->Format(L"%s\\system32\\%s.*", szPath, pchsFindfileExtension);
	hFileHandle = FindFirstFile(pstrFindFile->GetBuffer(_MAX_PATH), &stWin32FindData);
	if (hFileHandle != INVALID_HANDLE_VALUE)
	{
		pstrFindFile->Format(L"%s", stWin32FindData.cFileName);
		return;
	}
	pstrFindFile->Empty();
}
#endif

#ifdef WIN9XONLY
void CWin32VideoController::GetWin95RefreshRate(CInstance *pInst, LPCWSTR szDriver)
{
	CRegistry	reg;
	CHString	strRefreshRate,
				strKey;
	DWORD		dwRefresh;
	// If we don't have a refresh rate yet, check under the Driver\DEFAULT key.
	// This value can be 0 or -1, which mean Default and Optimal rates respectively.
	if (pInst->IsNull(L"CurrentRefreshRate") ||
	    !pInst->GetDWORD(L"CurrentRefreshRate", dwRefresh))
	{
		strKey.Format(
            L"System\\CurrentControlSet\\Services\\Class\\%s\\DEFAULT",
            szDriver);

		reg.OpenLocalMachineKeyAndReadValue(strKey, L"RefreshRate", strRefreshRate);

		pInst->SetDWORD(L"CurrentRefreshRate", _wtol(strRefreshRate));
	}
}
#endif

#ifdef WIN9XONLY
BOOL CWin32VideoController::AssignDriverValues(LPCWSTR szDriver, CInstance *pInst)
{
	BOOL        bRet = FALSE;
	CRegistry   reg;
	CHString    strTemp,
                strKey;

	strKey = L"System\\CurrentControlSet\\Services\\Class\\" + CHString(szDriver);

    if (reg.Open(HKEY_LOCAL_MACHINE, strKey, KEY_READ) == ERROR_SUCCESS)
    {
		if (reg.GetCurrentKeyValue(L"DriverDate", strTemp) == ERROR_SUCCESS)
        {
        	struct tm tmDate;
			memset(&tmDate, 0, sizeof(tmDate));

			int iRes = 0;
			iRes = swscanf(
							strTemp,
							L"%d-%d-%d",
							&tmDate.tm_mon,
							&tmDate.tm_mday,
							&tmDate.tm_year
						  );

			if ( iRes == EOF )
			{
				iRes = swscanf(
								strTemp,
								L"%d//%d//%d",
								&tmDate.tm_mon,
								&tmDate.tm_mday,
								&tmDate.tm_year
							  );
			}

			if ( iRes == 3 )
			{
				// per documentation - the struct tm.tm_year is year - 1900
				// no hint as to whether it's year 2k compliant.
				tmDate.tm_year = tmDate.tm_year - 1900;

				// and the month is zero based
				tmDate.tm_mon--;
				pInst->SetDateTime(IDS_DriverDate, (WBEMTime) tmDate);
			}
		}

	    if (reg.GetCurrentKeyValue(L"Ver", strTemp) == ERROR_SUCCESS)
		{
			pInst->SetCHString(IDS_DriverVersion, strTemp);
		}

		if (reg.GetCurrentKeyValue(L"InfPath", strTemp) == ERROR_SUCCESS)
		{
			if (strTemp.Find(_T('~'))  != -1)
			{
				GetFullFileName(&strTemp);
			}
		    pInst->SetCHString(IDS_InfFileName, strTemp);
		}

		if (reg.GetCurrentKeyValue(L"InfSection", strTemp) == ERROR_SUCCESS)
		{
		    pInst->SetCHString(IDS_InfSection, strTemp);
		}

		strTemp = strKey + L"\\Default";
		if (reg.OpenLocalMachineKeyAndReadValue(strTemp, L"drv", strTemp) ==
            ERROR_SUCCESS)
		{
            pInst->SetCHString(IDS_InstalledDisplayDrivers, strTemp);
		}

		strTemp = strKey + L"\\Info";
		if (reg.Open(HKEY_LOCAL_MACHINE, strTemp, KEY_READ) == ERROR_SUCCESS)
        {
            DWORD dwTemp;

			if (reg.GetCurrentKeyValue(L"ChipType", strTemp) == ERROR_SUCCESS)
            {
                CHString strTemp2;
                if (reg.GetCurrentKeyValue(L"Revision", strTemp2) ==
                    ERROR_SUCCESS && !strTemp.IsEmpty())
				{
                    strTemp += L" Rev " + strTemp2;
				}
			    pInst->SetCHString(L"VideoProcessor", strTemp);
			}

			if (reg.GetCurrentKeyValue(L"DACType", strTemp) == ERROR_SUCCESS)
			{
			    pInst->SetCHString(IDS_AdapterDACType, strTemp);
			}

            DWORD dwSize = 4;
			if (reg.GetCurrentBinaryKeyValue(L"VideoMemory", (BYTE*) &dwTemp, &dwSize) ==
                ERROR_SUCCESS)
			{
			    pInst->SetDWORD(IDS_AdapterRAM, dwTemp);
			}
		}

		bRet = TRUE;
	}

	GetWin95RefreshRate(pInst, szDriver);

	return bRet;
}
#endif

#ifdef NTONLY
BOOL CWin32VideoController::AssignDriverValues(LPCWSTR szDriver, CInstance *pInst)
{
    CHString  strKey;
    BOOL      bRet;
    CRegistry reg;

    strKey.Format(
        _T("SYSTEM\\CurrentControlSet\\Control\\Class\\%s"),
		(LPCWSTR) szDriver);

    // Get the driver settings.
	if (reg.Open(
	    HKEY_LOCAL_MACHINE,
		strKey,
		KEY_READ) == ERROR_SUCCESS)
    {
	    CHString strTemp;

        if (reg.GetCurrentKeyValue(_T("InfPath"), strTemp) == ERROR_SUCCESS)
		    pInst->SetCHString(IDS_InfFileName, strTemp);

        if (reg.GetCurrentKeyValue(_T("InfSection"), strTemp) == ERROR_SUCCESS)
		    pInst->SetCHString(IDS_InfSection, strTemp);

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}
#endif

void CWin32VideoController::SetProperties(CInstance *pInst, CMultiMonitor *pMon, int iWhich)
{
	// Set the config mgr properties.
    CHString            strTemp,
                        strDriver,
	                    strDeviceName;
	CConfigMgrDevicePtr pDeviceAdapter;

	pMon->GetAdapterDevice(iWhich, &pDeviceAdapter);

#ifdef NTONLY
    // Do the NT service and settings properties.
    CHString strSettingsKey,
             strService;

    pMon->GetAdapterSettingsKey(iWhich, strSettingsKey);

#if NTONLY == 4
    pMon->GetAdapterServiceName(strService);
#endif

#endif // #ifdef NTONLY

	// If we have an cfg mgr device, set some cfg mgr properties.
    if (pDeviceAdapter)
    {
		if (pDeviceAdapter->GetDeviceDesc(strTemp))
		{
			pInst->SetCHString(IDS_Description, strTemp);
			pInst->SetCHString(IDS_Caption, strTemp);
			pInst->SetCHString(IDS_Name, strTemp);
		}

		if (pDeviceAdapter->GetMfg(strTemp))
		{
			pInst->SetCHString(IDS_AdapterCompatibility, strTemp);
		}

	    if (pDeviceAdapter->GetStatus(strTemp))
	    {
		    pInst->SetCHString(IDS_Status, strTemp);
	    }

        SetConfigMgrProperties(pDeviceAdapter, pInst);

		// If we get the driver we can get more values.
		if (pDeviceAdapter->GetDriver(strDriver))
		{
			AssignDriverValues(strDriver, pInst);
		}

#if NTONLY >= 5
        pDeviceAdapter->GetService(strService);
#endif

	}

	// Set some standard properties.
	pInst->SetCharSplat(L"SystemName", GetLocalComputerName());
    pInst->SetCharSplat(IDS_SystemCreationClassName,
        L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_CreationClassName, L"Win32_VideoController");
	pInst->Setbool(L"Monochrome", false);
	pInst->SetDWORD(L"VideoArchitecture", 5); // 5 == VGA
	pInst->SetDWORD(L"VideoMemoryType", 2); // 2 == Unknown

	// Set the properties that require a DC.

    // strDeviceName will be \\.\Display# on Win9x and W2K
    // and DISPLAY on NT4.
    pMon->GetAdapterDisplayName(iWhich, strDeviceName);

#ifdef WIN9XONLY
	SetDCProperties(pInst, TOBSTRT(strDeviceName), strDriver, iWhich);
#endif

#ifdef NTONLY
	SetDCProperties(pInst, TOBSTRT(strDeviceName), iWhich);

    // SetServiceProperties should be called after we set the cfg mgr
    // properties.
    if (!strService.IsEmpty())
        SetServiceProperties(pInst, strService, strSettingsKey);
#endif
}

HRESULT CWin32VideoController::GetObject(CInstance *pInst, long lFlags)
{
	HRESULT	 hResult = WBEM_E_NOT_FOUND;
	CHString strDeviceID;
    DWORD    dwWhich;

    pInst->GetCHString(L"DeviceID", strDeviceID);

    if (ValidateNumberedDeviceID(strDeviceID, L"VIDEOCONTROLLER", &dwWhich))
    {
        CMultiMonitor monitor;

        if (1 <= dwWhich && dwWhich <= monitor.GetNumAdapters())
        {
            SetProperties(pInst, &monitor, dwWhich - 1);

            hResult = WBEM_S_NO_ERROR;
        }
    }

	return hResult;
}

#ifndef DM_INTERLACED
#define DM_INTERLACED   2
#endif

#ifdef WIN9XONLY
void CWin32VideoController::SetDCProperties(CInstance *pInst,
											LPCTSTR szDeviceName,
											LPCWSTR szDriver,
											int iWhich)
#endif
#ifdef NTONLY
void CWin32VideoController::SetDCProperties(CInstance *pInst,
											LPCTSTR szDeviceName,
											int iWhich)
#endif
{
	HDC hdc =
		    CreateDC(
			    szDeviceName,
				NULL,
				NULL,
				NULL);

	// Bail if we couldn't get the DC.
	if (!hdc)
    {
		// Assume this is because the device is not in use.  Set Availability
        // to 8 (off line).
        pInst->SetDWORD(IDS_Availability, 8);

        return;
    }

    CSmartCreatedDC hdcWrap(hdc);

    pInst->SetDWORD(IDS_Availability, 3); // 3 == Running
	pInst->SetDWORD(L"CurrentBitsPerPixel", GetDeviceCaps(hdc, BITSPIXEL));
    pInst->SetDWORD(L"NumberOfColorPlanes", GetDeviceCaps(hdc, PLANES));
	pInst->SetDWORD(IDS_DeviceSpecificPens, GetDeviceCaps(hdc, NUMPENS));
	pInst->SetDWORD(L"CurrentHorizontalResolution",
        GetDeviceCaps(hdc, HORZRES));
    pInst->SetDWORD(L"CurrentVerticalResolution",
        GetDeviceCaps(hdc, VERTRES));

    // Only valid if 8 or less bpp.
	if (GetDeviceCaps(hdc, BITSPIXEL) <= 8)
		pInst->SetDWORD(IDS_ColorTableEntries, GetDeviceCaps(hdc, NUMCOLORS));

    pInst->SetWBEMINT64(L"CurrentNumberOfColors", (__int64) 1 <<
        (__int64) GetDeviceCaps(hdc, BITSPIXEL));

	// According to the MOF, these are 0 since we're not in character mode.
	pInst->SetDWORD(L"CurrentNumberOfRows", 0);
	pInst->SetDWORD(L"CurrentNumberOfColumns", 0);

#ifdef WIN9XONLY
	CHString    strKey,
				strRefreshRate;
	CRegistry   reg;

	if(!wcscmp(szDriver, L""))
	{
		strKey.Format(
			L"System\\CurrentControlSet\\Services\\Class\\Display\\%04d\\MODES\\%d\\%d,%d",
			iWhich,
			GetDeviceCaps(hdc, BITSPIXEL),
			GetDeviceCaps(hdc, HORZRES),
			GetDeviceCaps(hdc, VERTRES));
	}
	else
	{
		strKey.Format(
			L"System\\CurrentControlSet\\Services\\Class\\%s\\MODES\\%d\\%d,%d",
			szDriver,
			GetDeviceCaps(hdc, BITSPIXEL),
			GetDeviceCaps(hdc, HORZRES),
			GetDeviceCaps(hdc, VERTRES));
	}

	// If under this key, we find a RefreshRate, this rate is the one we want.
	if (reg.OpenLocalMachineKeyAndReadValue(strKey, L"RefreshRate",
		strRefreshRate) == ERROR_SUCCESS)
	{
		pInst->SetDWORD(L"CurrentRefreshRate", _wtoi(strRefreshRate));
	}
#endif

	if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
	{
		pInst->SetDWORD(IDS_SystemPaletteEntries,
            GetDeviceCaps(hdc, SIZEPALETTE));
        pInst->SetDWORD(IDS_ReservedSystemPaletteEntries,
		    GetDeviceCaps(hdc, NUMRESERVED));
	}

	TCHAR       szTemp[100];
	CHString    strTemp;

	_i64tot((__int64) 1 << (__int64) GetDeviceCaps(hdc, BITSPIXEL), szTemp, 10);

	FormatMessageW(strTemp,
		IDR_VidModeFormat,
		GetDeviceCaps(hdc, HORZRES),
		GetDeviceCaps(hdc, VERTRES),
		szTemp);

	pInst->SetCharSplat(L"VideoModeDescription", strTemp);


	// Get the dither type
    DEVMODE devmode;

	memset(&devmode, 0, sizeof(DEVMODE));

	devmode.dmSize = sizeof(DEVMODE);
	devmode.dmSpecVersion = DM_SPECVERSION;


    // Get some properties using EnumDisplaySettings.
    LPCTSTR szEnumDeviceName;

#ifdef WIN9XONLY
    szEnumDeviceName = IsWin98() ? szDeviceName : NULL;
#endif
#ifdef NTONLY
    szEnumDeviceName = IsWinNT5() ? szDeviceName : NULL;
#endif

    if (EnumDisplaySettings(
        szEnumDeviceName,
        ENUM_CURRENT_SETTINGS,
        &devmode))
	{
		if (devmode.dmFields & DM_DITHERTYPE)
			pInst->SetDWORD(IDS_DitherType, devmode.dmDitherType);

    	// Use these if we can because they're more accurate than the HDC
        // functions.
        pInst->SetDWORD(L"CurrentBitsPerPixel", devmode.dmBitsPerPel);
        pInst->SetWBEMINT64(L"CurrentNumberOfColors", (__int64) 1 <<
            (__int64) devmode.dmBitsPerPel);

#ifdef NTONLY
        pInst->SetDWORD(L"CurrentRefreshRate", devmode.dmDisplayFrequency);

        pInst->SetDWORD(L"CurrentScanMode",
            devmode.dmDisplayFlags & DM_INTERLACED ? 3 : 4);
#endif
	}
#ifdef NTONLY
    else
        pInst->SetDWORD(L"CurrentScanMode", 2);
#endif


#ifdef WIN9XONLY
    // Currently no good way to get this.
    pInst->SetDWORD(L"CurrentScanMode", 2); // 2 == Unknown
#endif


#ifdef NTONLY
    // Only works for NT.  Win9x only returns refresh rates as 0 and -1.
	// Find the min/max refresh rate using EnumDisplaySettings.
    DWORD   dwMinRefresh = 0xFFFFFFFF,
            dwMaxRefresh = 0;

    for (int iMode = 0; EnumDisplaySettings(szEnumDeviceName, iMode, &devmode);
        iMode++)
    {
        // Ignore '1' since it means 'default' instead of a real value.
        if (devmode.dmDisplayFrequency < dwMinRefresh &&
            devmode.dmDisplayFrequency > 1)
            dwMinRefresh = devmode.dmDisplayFrequency;

        if (devmode.dmDisplayFrequency > dwMaxRefresh)
            dwMaxRefresh = devmode.dmDisplayFrequency;
    }

    if (dwMinRefresh != 0xFFFFFFFF)
        pInst->SetDWORD(L"MinRefreshRate", dwMinRefresh);

    if (dwMinRefresh != 0)
        pInst->SetDWORD(L"MaxRefreshRate", dwMaxRefresh);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\videocontrollerresolution.cpp ===
//=================================================================

//

// VideoControllerResolution.CPP -- CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//				 03/02/99    a-peterc		  added graceful exit on SEH and memory failures
//
//=================================================================

#include "precomp.h"
#include "VideoControllerResolution.h"
#include <multimon.h>
#include <ProvExce.h>
#include "multimonitor.h"
#include "resource.h"

// Property set declaration
//=========================

CCIMVideoControllerResolution videoControllerResolution(
	L"CIM_VideoControllerResolution",
	IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CCIMVideoControllerResolution::CCIMVideoControllerResolution
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CCIMVideoControllerResolution::CCIMVideoControllerResolution(const CHString& szName,
	LPCWSTR szNamespace) : Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMVideoControllerResolution::~CCIMVideoControllerResolution
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CCIMVideoControllerResolution::~CCIMVideoControllerResolution()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMVideoControllerResolution::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CCIMVideoControllerResolution::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags /*= 0L*/)
{
    HRESULT         hres = WBEM_S_NO_ERROR;
    CMultiMonitor   monitor;
    CHStringList    listIDs;

    for (int i = 0; i < monitor.GetNumAdapters(); i++)
    {
        CHString strDeviceName;

        monitor.GetAdapterDisplayName(i, strDeviceName);

        EnumResolutions(
            pMethodContext,
            NULL,
            // If this OS doesn't support multi-monitor we'll have 'DISPLAY' as
            // the name, in which case we need to send NULL to the enum function.
            strDeviceName == L"DISPLAY" ? NULL : (LPCWSTR) strDeviceName,
            listIDs);
    }

    return hres;
}

BOOL CCIMVideoControllerResolution::IDInList(CHStringList &list, LPCWSTR szID)
{
	for (CHStringList_Iterator i = list.begin(); i != list.end(); ++i)
	{
		CHString &str = *i;

		if (!str.CompareNoCase(szID))
			return TRUE;
	}

	return FALSE;
}

HRESULT CCIMVideoControllerResolution::EnumResolutions(
    MethodContext *a_pMethodContext,
    CInstance *a_pInstanceLookingFor,
    LPCWSTR a_szDeviceName,
    CHStringList &a_listIDs )
{
    int         t_i = 0 ;
    DEVMODE     t_devmode ;
    CHString    t_strIDLookingFor ;
    HRESULT     t_hResult	= WBEM_S_NO_ERROR ;
	BOOL		t_bFound	= TRUE ;
	CInstancePtr t_pInst;

	if ( a_pInstanceLookingFor )
	{
		t_bFound = FALSE ;
		a_pInstanceLookingFor->GetCHString( L"SettingID", t_strIDLookingFor ) ;
	}

	while ( EnumDisplaySettings( TOBSTRT(a_szDeviceName), t_i, &t_devmode ) && SUCCEEDED( t_hResult ) )
	{
		CHString t_strID ;

		// Convert the devmode to a string ID.
		DevModeToSettingID( &t_devmode, t_strID ) ;

		// If we haven't already processed this one...
		if ( !IDInList( a_listIDs, t_strID ) )
		{
			// If we're doing a GetObject()...
			if ( a_pInstanceLookingFor )
			{
				// If this is the right setting id...
				if ( !t_strIDLookingFor.CompareNoCase( t_strID ) )
				{
					CHString t_strCaption ;

					// Convert the devmode to a caption.
					DevModeToCaption( &t_devmode, t_strCaption ) ;

					// Set the properties and get out.
					t_bFound = TRUE ;
					t_hResult = WBEM_S_NO_ERROR ;
					SetProperties( a_pInstanceLookingFor, &t_devmode ) ;
					a_pInstanceLookingFor->SetCharSplat( L"SettingID",	t_strID) ;
					a_pInstanceLookingFor->SetCharSplat( L"Description", t_strCaption) ;
					a_pInstanceLookingFor->SetCharSplat( L"Caption",		t_strCaption) ;
					break;
				}
			}
			// Must be doing an EnumerateInstances().
			else
			{
                t_pInst.Attach(CreateNewInstance( a_pMethodContext ));
				if ( t_pInst != NULL )
				{
					CHString t_strCaption ;

					// Convert the devmode to a caption.
					DevModeToCaption( &t_devmode, t_strCaption ) ;

					SetProperties(t_pInst, &t_devmode ) ;

					t_pInst->SetCharSplat( L"SettingID",		t_strID ) ;
					t_pInst->SetCharSplat( L"Description",	t_strCaption ) ;
					t_pInst->SetCharSplat( L"Caption",		t_strCaption ) ;

					t_hResult = t_pInst->Commit(  ) ;
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
					break;
				}
			}

			a_listIDs.push_back( t_strID ) ;
		}

		t_i++ ;
	}

	if ( !t_bFound )
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}

BOOL WINAPI IsModeInterlaced(DEVMODE *pMode)
{
    return pMode->dmDisplayFrequency > 1 && pMode->dmDisplayFrequency <= 50;
}

void CCIMVideoControllerResolution::DevModeToSettingID(
    DEVMODE *pMode,
    CHString &strSettingID)
{
    WCHAR szID[512];

    swprintf(
        szID,
        L"%d x %d x %I64d colors @ %d Hertz",
        pMode->dmPelsWidth,
        pMode->dmPelsHeight,
        (__int64) 1 << (__int64) pMode->dmBitsPerPel,
        pMode->dmDisplayFrequency);

    if (IsModeInterlaced(pMode))
        wcscat(szID, L" (Interlaced)");

    strSettingID = szID;
}

void CCIMVideoControllerResolution::DevModeToCaption(
    DEVMODE *pMode,
    CHString &strCaption)
{
    TCHAR szColors[512];

    _i64tot((__int64) 1 << (__int64) pMode->dmBitsPerPel, szColors, 10);

    FormatMessageW(strCaption,
        IsModeInterlaced(pMode) ?
            IDR_VidControllerResolutionFormatInterlaced :
            IDR_VidControllerResolutionFormat,
        pMode->dmPelsWidth,
        pMode->dmPelsHeight,
        szColors,
        pMode->dmDisplayFrequency);
}

void CCIMVideoControllerResolution::SetProperties(CInstance *pInstance, DEVMODE *pMode)
{
    pInstance->SetDWORD(L"HorizontalResolution", pMode->dmPelsWidth);
    pInstance->SetDWORD(L"VerticalResolution", pMode->dmPelsHeight);
    pInstance->SetDWORD(L"RefreshRate", pMode->dmDisplayFrequency);
    pInstance->SetDWORD(L"ScanMode", IsModeInterlaced(pMode) ? 5 : 4);
    pInstance->SetWBEMINT64(L"NumberOfColors", (__int64) 1 <<
        (__int64) pMode->dmBitsPerPel);
}

HRESULT CCIMVideoControllerResolution::GetObject(CInstance *pInstance, long lFlags)
{
    HRESULT         hres = WBEM_E_NOT_FOUND;
    CMultiMonitor   monitor;
    CHStringList    listIDs;

    for (int i = 0; i < monitor.GetNumAdapters(); i++)
    {
        CHString strDeviceName;

        monitor.GetAdapterDisplayName(i, strDeviceName);

        if (SUCCEEDED(hres =
            EnumResolutions(
                NULL,
                pInstance,
                // If this OS doesn't support multi-monitor we'll have 'DISPLAY' as
                // the name, in which case we need to send NULL to the enum function.
                strDeviceName == L"DISPLAY" ? NULL : (LPCWSTR) strDeviceName,
                listIDs)))
            break;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\videosettings.cpp ===
//=================================================================

//

// VideoSettings.CPP -- CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//				 03/02/99    a-peterc		  added graceful exit on SEH and memory failures
//
//=================================================================

#include "precomp.h"
#include "VideoControllerResolution.h"
#include "VideoSettings.h"
#include <multimon.h>
#include <ProvExce.h>
#include "multimonitor.h"

// Property set declaration
//=========================

CWin32VideoSettings videoSettings(
	L"Win32_VideoSettings",
	IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoSettings::CWin32VideoSettings
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32VideoSettings::CWin32VideoSettings(
    LPCWSTR szName,
	LPCWSTR szNamespace) :
    Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoSettings::~CWin32VideoSettings
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32VideoSettings::~CWin32VideoSettings()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoSettings::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32VideoSettings::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags /*= 0L*/)
{
    HRESULT         hResult = WBEM_S_NO_ERROR;
    CMultiMonitor   monitor;

    for (int i = 0; i < monitor.GetNumAdapters(); i++)
    {
        CHString strDeviceName;

        monitor.GetAdapterDisplayName(i, strDeviceName);

        EnumResolutions(
            pMethodContext,
            NULL,
            NULL,
            // If this OS doesn't support multi-monitor we'll have 'DISPLAY' as
            // the name, in which case we need to send NULL to the enum function.
            strDeviceName == L"DISPLAY" ? NULL : (LPCWSTR) strDeviceName,
            i);
    }

    return hResult;
}

typedef std::map<CHString, BOOL> STRING2BOOL;

HRESULT CWin32VideoSettings::EnumResolutions(
    MethodContext *pMethodContext,
    CInstance *pInstanceLookingFor,
    LPCWSTR szLookingForPath,
    LPCWSTR szDeviceName,
    int iAdapter)
{
    DEVMODE      devmode;
    HRESULT      hResult = pInstanceLookingFor ? WBEM_E_NOT_FOUND :
                                    WBEM_S_NO_ERROR;
	CInstancePtr pInst;
    STRING2BOOL  mapSettingID;

	// If doing a GetObject():
    // First see if this is the right adapter.  If not, get out.
    if (pInstanceLookingFor)
	{
        CHString strTemp;

        strTemp.Format(L"VIDEOCONTROLLER%d", iAdapter + 1);

		if (!wcsstr(szLookingForPath, strTemp))
            return WBEM_E_NOT_FOUND;
	}

	for (int i = 0;
         EnumDisplaySettings(TOBSTRT(szDeviceName), i, &devmode) &&
            (hResult == WBEM_S_NO_ERROR || hResult == WBEM_E_NOT_FOUND);
         i++)
	{
		CHString strID;

		// Convert the devmode to a string ID.
		CCIMVideoControllerResolution::DevModeToSettingID(&devmode, strID);

		// If we're doing a GetObject()...
		if (pInstanceLookingFor)
		{
			CHString    strCurrentPath,
                        strIDUpper;
            HRESULT     hresTemp;

            strIDUpper = strID;
            strIDUpper.MakeUpper();

            // If this ID has the setting ID we're looking for, try to
            // set the properties and verify the entire instance is correct.
            // This will help us throw out most of the entries
            // EnumDisplaySettings returns without having to SetProperties
            // on them all.
            if (wcsstr(szLookingForPath, strIDUpper))
            {
                hresTemp = SetProperties(pMethodContext, pInstanceLookingFor,
                                strID, iAdapter);

			    if (WBEM_S_NO_ERROR == hresTemp)
			    {
				    GetLocalInstancePath(pInstanceLookingFor, strCurrentPath);

				    // If this is the right setting id...
				    if (!strCurrentPath.CompareNoCase(szLookingForPath))
				    {
					    // We set the properties and found the right one, so get out.
					    hResult = WBEM_S_NO_ERROR;
					    break;
				    }
			    }
                else
                    hResult = hresTemp;
            }
		}
		// Must be doing an EnumerateInstances().
		else
		{
			// Have we seen this one yet?  We have to do this because some
            // dumb drivers will report the exact same resolution more than
            // once.
            if (mapSettingID.find(strID) == mapSettingID.end())
            {
                mapSettingID[strID] = true;

                pInst.Attach(CreateNewInstance(pMethodContext));

			    hResult = SetProperties(pMethodContext, pInst, strID, iAdapter);

			    if (WBEM_S_NO_ERROR == hResult)
				    hResult = pInst->Commit();
            }
		}
	}

	return hResult;
}

HRESULT CWin32VideoSettings::SetProperties(
    MethodContext *pMethodContext,
    CInstance *pInst,
    LPCWSTR szID,
    int iAdapter)
{
	HRESULT      hResult = WBEM_E_OUT_OF_MEMORY;
	CInstancePtr pinstVideoController,
				 pinstResolution;
	CHString     strTemp;

	CWbemProviderGlue::GetEmptyInstance(
		pMethodContext,
		L"Win32_VideoController",
		&pinstVideoController,
                GetNamespace());

	CWbemProviderGlue::GetEmptyInstance(
		pMethodContext,
		L"CIM_VideoControllerResolution",
		&pinstResolution,
                GetNamespace());

	if (pinstVideoController)
	{
		strTemp.Format(L"VideoController%d", iAdapter + 1);
		pinstVideoController->SetCHString(L"DeviceID", strTemp);

		GetLocalInstancePath(pinstVideoController, strTemp);
		pInst->SetCHString(L"Element", strTemp);

	    if (pinstResolution)
	    {
		    pinstResolution->SetCHString(L"SettingID", szID);

		    GetLocalInstancePath(pinstResolution, strTemp);
		    pInst->SetCHString (L"Setting", strTemp);

            hResult = WBEM_S_NO_ERROR;
	    }
    }

	return hResult;
}

HRESULT CWin32VideoSettings::GetObject(CInstance *pInstance, long lFlags)
{
    HRESULT         hResult = WBEM_E_NOT_FOUND;
    CMultiMonitor   monitor;
    CHStringList    listIDs;

    for (int i = 0; i < monitor.GetNumAdapters(); i++)
    {
        CHString    strDeviceName,
                    strLookingForPath;

        GetLocalInstancePath(pInstance, strLookingForPath);

        // Make search case insensitive.
        strLookingForPath.MakeUpper();

        monitor.GetAdapterDisplayName(i, strDeviceName);

        if (SUCCEEDED(hResult =
			EnumResolutions(
                pInstance->GetMethodContext(),
                pInstance,
                strLookingForPath,
                // If this OS doesn't support multi-monitor we'll have 'DISPLAY' as
                // the name, in which case we need to send NULL to the enum function.
                strDeviceName == L"DISPLAY" ? NULL : (LPCWSTR) strDeviceName,
                i)))
            break;
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\videosettings.h ===
//=================================================================

//

// VideoSettings.h -- CWin32VideoSettings property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/05/98    sotteson         Created
//
//=================================================================
#ifndef _VIDEOSETTINGS_H
#define _VIDEOSETTINGS_H

class CMultiMonitor;

class CWin32VideoSettings : public Provider
{
	protected:

		HRESULT SetProperties( MethodContext *a_pMethodContext, CInstance *a_pInstance, 
			LPCWSTR a_szID, int a_iAdapter ) ;

		HRESULT EnumResolutions(MethodContext *a_pMethodContext, 
			CInstance *a_pInstanceLookingFor, LPCWSTR a_szLookingForPath, 
			LPCWSTR a_szDeviceName, int a_iWhich ) ;
	public:

		// Constructor/destructor
		//=======================
		CWin32VideoSettings(LPCWSTR a_szName, LPCWSTR a_szNamespace ) ;
		~CWin32VideoSettings() ;

		virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, 
			long a_lFlags = 0 ) ;
		virtual HRESULT GetObject( CInstance *a_pInstance, long a_lFlags = 0 ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\videocontroller.h ===
//=================================================================

//

// VideoController.h -- CWin32VideoController property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/05/98    sotteson         Created
//
//=================================================================
#ifndef _VIDEOCONTROLLER_H
#define _VIDEOCONTROLLER_H

class CMultiMonitor;

class CWin32VideoController : public Provider
{
	protected:
	
		void SetProperties( CInstance *a_pInstance, CMultiMonitor *a_pMon, int a_iWhich ) ;
		BOOL AssignDriverValues( LPCWSTR a_szDriver, CInstance *pInstance ) ;

	#ifdef WIN9XONLY
		void GetWin95RefreshRate( CInstance *a_pInstance, LPCWSTR a_szDriver ) ;
		void GetFullFileName(CHString* pchsShortFileName);
		void SetDCProperties( CInstance *a_pInstance, LPCTSTR a_szDeviceName, LPCWSTR a_szDriver, int a_iWhich ) ;
	#endif
	
	#ifdef NTONLY
		void GetFileExtensionIfNotAlreadyThere(CHString* pchsInstalledDriverFiles);
		void GetFileExtension(CHString& pchsFindfileExtension, CHString* pstrFindFile);
		void SetDCProperties( CInstance *a_pInstance, LPCTSTR a_szDeviceName, int a_iWhich ) ;
	    void SetServiceProperties(
            CInstance *a_pInstance, 
            LPCWSTR a_szService,
            LPCWSTR a_szSettingsKey);
    #endif
	public:
	
		// Constructor/destructor
		//=======================
		CWin32VideoController( const CHString& a_szName, LPCWSTR a_szNamespacev) ;
		~CWin32VideoController();

		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0 ) ;
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0 ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\vxd.h ===
////////////////////////////////////////////////////////////////////

//

//  vxd.h

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//		Implementation of VXD
//      10/23/97    jennymc     updated to new framework
//		
////////////////////////////////////////////////////////////////////
#define PROPSET_NAME_VXD  L"Win32_DriverVXD"

#ifdef WIN9XONLY

#pragma pack(1)

typedef struct  {
    DWORD DDB_Next;                  // addr of next VxD in chain, or 0
    WORD DDB_SDK_Version;
    WORD DDB_Req_Device_Number;      // the VxD ID number
    BYTE DDB_Dev_Major_Version;
    BYTE DDB_Dev_Minor_Version;
    WORD DDB_Flags;
    BYTE DDB_Name[8];                // padded with spaces
    DWORD DDB_Init_Order;            // also order within list (SHELL last)
    DWORD DDB_Control_Proc;
    DWORD DDB_V86_API_Proc;
    DWORD DDB_PM_API_Proc;
    void (*DDB_V86_API_CSIP)();  // V86 mode seg:ofs callback addr
    void (*DDB_PM_API_CSIP)();   // prot mode sel:ofs callback addr
    DWORD DDB_Reference_Data;
    DWORD DDB_Service_Table_Ptr;
    DWORD DDB_Service_Table_Size;
    // Win95 keeps Win32 service table at offset 38h
    DWORD DDB_Win32_Service_Table_Ptr;
    } DDB ;
		
		                          // from ddk include/vmm.inc
        
#define WIN32_SERVICE   0x4000       // set by Register_Win32_Services
        
#pragma pack()      

#endif //WIN9XONLY



class CWin32DriverVXD : public Provider
{
		//=================================================
		// Utility
		//=================================================
    private:
#ifdef WIN9XONLY
        HRESULT AssignPropertyValues( DDB *a_pddb, BOOL a_fAssignKey, CInstance *a_pInstance ) ;
#endif //WIN9XONLY
	
	public:

        //=================================================
        // Constructor/destructor
        //=================================================

        CWin32DriverVXD(const CHString& a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32DriverVXD() ;

        //=================================================
        // Functions provide properties with current values
        //=================================================
		virtual HRESULT GetObject( CInstance *a_pInstance, long a_lFlags = 0L ) ;
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;

  
};

#ifdef WIN9XONLY

typedef void (*FUNCPTR)(void);
    
int WINAPI Get_First_VxD( DWORD *a_proot );
int WINAPI Get_Next_VxD( DDB *a_pddb, DWORD *a_pnext ) ;
int WINAPI Find_VxD( char *a_name, DWORD *a_pvxd ) ;
int WINAPI Find_VxD_ID( WORD a_id, DWORD *a_pvxd ) ;
FUNCPTR WINAPI Get_VxD_Proc_Address( DWORD a_func_num ) ;

#define SUCCESS                 0
#define ERROR_CANT_FIND_VMM     1
#define ERROR_CANT_MAP_LINEAR   2       // can't happen in Win32
#define ERROR_CANT_FIND_VXD     3
#define ERROR_END_OF_CHAIN      4
#define ERROR_NAME_UNKNOWN      5
#define ERROR_BUFFER_TOO_SHORT  6

#endif //WIN9XONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\videocontrollerresolution.h ===
//=================================================================

//

// VideoControllerResolution.h -- CWin32VideoControllerResolution property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/05/98    sotteson         Created
//
//=================================================================
#ifndef _VIDEOCONTROLLERRESOLUTION_H
#define _VIDEOCONTROLLERRESOLUTION_H

class CMultiMonitor;

class CCIMVideoControllerResolution : public Provider
{
public:
	// Constructor/destructor
	//=======================
	CCIMVideoControllerResolution(const CHString& szName, LPCWSTR szNamespace);
	~CCIMVideoControllerResolution();

	virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
		long lFlags = 0);
	virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0);

    static void DevModeToSettingID(DEVMODE *pMode, CHString &strSettingID);
    static void DevModeToCaption(DEVMODE *pMode, CHString &strCaption);

protected:
    void SetProperties(CInstance *pInstance, DEVMODE *pMode);
    HRESULT EnumResolutions(MethodContext *pMethodContext, 
        CInstance *pInstanceLookingFor, LPCWSTR szDeviceName, 
        CHStringList &listIDs);
    static BOOL IDInList(CHStringList &list, LPCWSTR szID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\vxd.cpp ===
////////////////////////////////////////////////////////////////////

//

//  vxd.CPP

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//		Implementation of VXD
//      10/23/97    jennymc     updated to new framework
//
//      03/02/99 - a-peterc - added graceful exit on SEH and memory failures
//
////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <io.h>
#include <stddef.h>
#include "vxd.h"
#include <locale.h>
#include <ProvExce.h>

#include "lockwrap.h"

CWin32DriverVXD MyCWin32VXDSet(PROPSET_NAME_VXD, IDS_CimWin32Namespace);

#ifdef WIN9XONLY

////////////////////////////////////////////////////////////////////////
DWORD BASE = 0xC0000000L;
#define START (BASE + 0x1000L)      // don't start at BASE: page fault!
#define STOP  (BASE + 0x400000L)

#define VMM_STR     "VMM     "      // 5 spaces after name

////////////////////////////////////////////////////////////////////////
void StripVXDName( DDB * pddb, char * szTempName )
{
	// L10N OK since we're parsing the VXD binary.
    char * pChar;

	strcpy( szTempName, (char *) pddb->DDB_Name);
	pChar = szTempName;

	while( isalnum( *pChar ) )
		pChar++;
	*pChar = NULL;
}

#endif //WIN9XONLY

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DriverVXD::CWin32DriverVXD
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
CWin32DriverVXD::CWin32DriverVXD(const CHString& name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}
/*****************************************************************************
 *
 *  FUNCTION    : CWin32DriverVXD::~CWin32DriverVXD
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
CWin32DriverVXD::~CWin32DriverVXD()
{
}
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32DriverVXD::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

	// =======================================
	// Process only if the platform is Win95+
	// =======================================
#ifdef WIN9XONLY
	{
    	DWORD t_vxd_lin;
        CHString t_Name;
		CHString t_name0, t_element0, t_version0, t_name1, t_element1, t_version1;
		WORD t_elementState0, t_os0, t_elementState1, t_os1;

        a_pInst->GetCHString( IDS_Name, t_Name ) ;

		// cache all hunnert an elebben keys
		a_pInst->GetCHString( IDS_Name, t_name0 ) ;
		a_pInst->GetCHString( IDS_Version, t_version0 ) ;
        a_pInst->GetCHString( L"SoftwareElementID", t_element0 ) ;
        a_pInst->GetWORD( L"SoftwareElementState", t_elementState0 ) ;
        a_pInst->GetWORD( L"TargetOperatingSystem", t_os0 ) ;

	    CLockWrapper t_lockVXD( g_csVXD ) ;

		if( SUCCESS == Find_VxD(TOBSTRT(t_Name), &t_vxd_lin))
		{
	        t_Result = AssignPropertyValues( (DDB *) t_vxd_lin, FALSE, a_pInst ) ;

			if ( WBEM_S_NO_ERROR == t_Result )
			{
				//check against chached doohickeys
				a_pInst->GetCHString( IDS_Name, t_name1 ) ;
				a_pInst->GetCHString( IDS_Version, t_version1 ) ;
				a_pInst->GetCHString( L"SoftwareElementID", t_element1 ) ;
				a_pInst->GetWORD( L"SoftwareElementState", t_elementState1 ) ;
				a_pInst->GetWORD( L"TargetOperatingSystem", t_os1 ) ;
				if (
						( t_os0 != t_os1 )								||
						( t_elementState0 != t_elementState1 )			||
						( t_name0.CompareNoCase(t_name1) != 0 )			||
						( t_version0.CompareNoCase(t_version1 ) != 0 )  ||
						( t_element0.CompareNoCase(t_element1 ) != 0 )
				   )
					t_Result = WBEM_E_NOT_FOUND;
				}
		}
        else
            t_Result = WBEM_E_NOT_FOUND;
	}
#endif

	return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DriverVXD::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32DriverVXD::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR;

	// =======================================
	// Process only if the platform is Win95+
	// =======================================
#ifdef WIN9XONLY
	CInstancePtr t_pInst;

    DWORD           t_vxd_lin,
					t_next;
	int             t_err;
	CLockWrapper    lt_ockVXD( g_csVXD );

    t_err = Get_First_VxD( &t_vxd_lin ) ;

	while (t_err == 0 && SUCCEEDED( t_hResult ) )
	{
        t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
		if ( t_pInst != NULL )
		{
			t_hResult = AssignPropertyValues( (DDB *) t_vxd_lin, TRUE, t_pInst ) ;

			if ( WBEM_S_NO_ERROR == t_hResult )
			{
				t_hResult = t_pInst->Commit(  ) ;
			}
		}
		else
		{
			t_hResult = WBEM_E_OUT_OF_MEMORY;
			break;
		}

		if ( 0 == (t_err = Get_Next_VxD((DDB *) t_vxd_lin, &t_next ) ) )
			t_vxd_lin = t_next;
	}
#endif

    return t_hResult;
}

#ifdef WIN9XONLY

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  CWin32DriverVXD::AssignPropertyValues(DDB *pddb)
 Description: Moves a single copy of a ddb to the cimom instance
 Arguments: Pointer to ddb
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
HRESULT CWin32DriverVXD::AssignPropertyValues(DDB *a_pddb, BOOL a_fAssignKey, CInstance *a_pInst )
{
	HRESULT t_Result = WBEM_S_NO_ERROR ;
	CHString t_TempString ;
	struct _tfinddatai64_t t_datData;
	CHString t_name;
	char t_szTempName[_MAX_PATH+2];

	if( a_fAssignKey )
	{
		StripVXDName( a_pddb, t_szTempName ) ;
		a_pInst->SetCHString(IDS_Name, t_szTempName ) ;
	}

	// get information from file
	if ( a_pInst->GetCHString(IDS_Name, t_name ) )
	{
		TCHAR t_szSystemDir[ _MAX_PATH + 1 ] ;
		CHString t_chsFilePath;

		a_pInst->SetCHString( IDS_Description, t_name ) ;
		a_pInst->SetCHString( IDS_Caption, t_name ) ;
		a_pInst->SetCHString( L"SoftwareElementID", t_name ) ;
		a_pInst->SetWORD( L"SoftwareElementState", 3 ) ;

		// well, we don't know whether it's Win95 or 98 specific
		// we set it to "other" and explain further elsewhere...
		a_pInst->SetWORD( L"TargetOperatingSystem", 1 ) ;

		a_pInst->SetCharSplat( L"OtherTargetOS",  _T("Win9X") );

		GetSystemDirectory( t_szSystemDir, _MAX_PATH ) ;
		t_chsFilePath = t_szSystemDir;
		t_chsFilePath += L"\\";	// separate file name with slash
		t_chsFilePath += t_name;
		t_chsFilePath += L".VXD";	// add the extension

		Smart_findclose t_handle = _tfindfirsti64((TCHAR*)TOBSTRT((LPCWSTR)t_chsFilePath), &t_datData ) ;

		if (-1 != t_handle )
		{
			if (-1 != t_datData.time_create )
			{
				a_pInst->SetDateTime( IDS_InstallDate, WBEMTime( t_datData.time_create ) ) ;
			}
		}
	}

	a_pInst->SetCharSplat( IDS_Status, _T("OK") ) ;

	t_TempString.Format( L"%u,%02u", a_pddb->DDB_Dev_Major_Version, a_pddb->DDB_Dev_Minor_Version ) ;
	a_pInst->SetCHString( IDS_Version, t_TempString ) ;

	t_TempString.Format( L"%8lx", a_pddb ) ;
	a_pInst->SetCHString( IDS_DeviceDescriptorBlock, t_TempString ) ;

	t_TempString.Format( L"%8lx", a_pddb->DDB_Control_Proc ) ;
	a_pInst->SetCHString( IDS_Control, t_TempString ) ;

	t_TempString.Format( L"%8lx", a_pddb->DDB_V86_API_Proc ) ;
	a_pInst->SetCHString( IDS_V86_API, t_TempString ) ;

	t_TempString.Format( L"%8lx", a_pddb->DDB_PM_API_Proc ) ;
	a_pInst->SetCHString( IDS_PM_API, t_TempString ) ;

	a_pInst->SetDWORD( IDS_ServiceTableSize,(DWORD) a_pddb->DDB_Service_Table_Size ) ;

	return t_Result ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:
 Description: look for first occurrence of string inside block of memory
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
static char *memstr(char *fp, char *str, DWORD len)
{
    // L10N OK because we're looking inside VXD binary.
 int c = str[0];
 char *fp2 = fp;
 DWORD len2 = len;
   _try {
        while (fp2 = (char *) memchr(fp2, c, len2))
        {
            if (strstr(fp2, str))
                return fp2;
            else
            {
                fp2++;  // skip past character
                len2 = len - (fp2 - fp);
            }
        }
    } _except (EXCEPTION_EXECUTE_HANDLER) { return NULL; }
    /* still here */
    return NULL;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int WINAPI Get_First_VxD(DWORD *proot)
{
#ifdef _X86_
    // L10N OK because we're looking inside VXD binary.
    static DWORD vmm_ddb_lin = 0;
    DDB *pddb;
    char *vmm_str;

    if (vmm_ddb_lin != 0)
    {
        *proot = vmm_ddb_lin;
        return SUCCESS;
    }

    // try to find string "VMM     " in first 4MB of VMM/VxD space
    if (vmm_str = memstr((char *) START, VMM_STR, STOP - START))
    {
        // back up to get linear address of possible VMM_DDB
        vmm_ddb_lin = (DWORD) (vmm_str - offsetof(DDB, DDB_Name));
        pddb = (DDB *) vmm_ddb_lin;

        // make sure it really is VMM_DDB -- need more checking?
        if ((strncmp((LPCSTR)pddb->DDB_Name, VMM_STR, 8) == 0) &&
            (pddb->DDB_Req_Device_Number == 1) &&
            (pddb->DDB_Init_Order == 0) &&  // VMM_Init_Order
            (pddb->DDB_Next > BASE) &&
            (pddb->DDB_Control_Proc > BASE))
        {
            // verify with (recursive) call to Get_VMM_DDB
            void (*Get_VMM_DDB)(void) = Get_VxD_Proc_Address(0x1013F);
            DWORD vmm_ddb;
            (*Get_VMM_DDB)();

            _asm mov vmm_ddb, eax

            if (vmm_ddb != vmm_ddb_lin)
                return ERROR_CANT_FIND_VMM;
            *proot = vmm_ddb_lin;
            return SUCCESS;
        }
    }

#endif  // _X86_

 return ERROR_CANT_FIND_VMM;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int WINAPI Get_Next_VxD(DDB *pddb, DWORD *pnext)
{
    DWORD next = pddb->DDB_Next;  // should verify with an Is_VxD() function?
    *pnext = next;
    return (next >= BASE) ? SUCCESS : ERROR_END_OF_CHAIN;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats: should this be case-insensitive?
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
static int find_vxd(char *name, WORD id, DWORD *pvxd)
{
    // L10N OK because we're looking inside VXD binary.
    DDB *pddb;
    DWORD vxd;
    int err;

    if ((err = Get_First_VxD(&vxd)) != 0)
        return err;
    for (;;)
    {
        pddb = (DDB *) vxd;
		char szTempName[_MAX_PATH+2];

		StripVXDName(pddb,szTempName);

        if( id && (pddb->DDB_Req_Device_Number == id)){
            *pvxd = vxd;
            return SUCCESS;
        }

        if ( name ){
			if(_stricmp(name,szTempName) == 0){
				*pvxd = vxd;
				return SUCCESS;
			}
        }

        if (Get_Next_VxD(pddb, &vxd) != SUCCESS)
            return ERROR_CANT_FIND_VXD;
    }
}
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int WINAPI Find_VxD(char *name, DWORD *pvxd)
{
 return find_vxd(name, 0, pvxd);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int WINAPI Find_VxD_ID(WORD id, DWORD *pvxd)
{
 return find_vxd((char *) 0,id,pvxd);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
FUNCPTR WINAPI Get_VxD_Proc_Address(DWORD func)
{
    WORD vxd_id = HIWORD(func) ;
    WORD func_num = LOWORD(func) ;
    DWORD vxd;
    FUNCPTR *srv_tab;
    DDB *ddb;
    if (Find_VxD_ID(vxd_id, &vxd) != SUCCESS)
        return 0;
    ddb = (DDB *) vxd;
    if (func_num > ddb->DDB_Service_Table_Size)
        return 0;
    srv_tab = (FUNCPTR *) ddb->DDB_Service_Table_Ptr;
    return srv_tab[func_num];
}

#endif //WIN9XONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\w2kenum.h ===
//=================================================================

//

// W2kEnum.h -- W2k enumeration support 

//

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/28/99            Created
//
//=================================================================
#ifndef _W2KENUM_H_
#define _W2KENUM_H_

class CW2kAdapterInstance
{
	public: 
		DWORD			dwIndex ;
		CHString		chsPrimaryKey ;
		CHString		chsCaption ;
		CHString		chsDescription ;	
		CHString		chsCompleteKey ;
		CHString		chsService ;
		CHString		chsNetCfgInstanceID ;
		CHString		chsRootdevice ;
		CHString		chsIpInterfaceKey ;
		
};

class CW2kAdapterEnum : public CHPtrArray
{
	private:
		BOOL GetW2kInstances() ;
		BOOL IsIpPresent( CRegistry &a_RegIpInterface ) ;

	public:        
		
		//=================================================
        // Constructors/destructor
        //=================================================
        CW2kAdapterEnum() ;
       ~CW2kAdapterEnum() ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wavedevcfg.h ===
/*******************************************************************

 *

 *    WavedevCfg.h

 *

*  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
 *
 *******************************************************************/

#ifndef __WAVEDEVCFG_H_
#define __WAVEDEVCFG_H_

class CWin32WaveDeviceCfg : public Provider
{
public:

	// constructor/destructor
	CWin32WaveDeviceCfg (const CHString& name, LPCWSTR pszNamespace);
	virtual ~CWin32WaveDeviceCfg ();

    //=================================================
    // Functions provide properties with current values
    //=================================================
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);

protected:
private:
};	// end class CWin32SndDeviceCfg

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wbemntthread.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// WbemThread.h.cpp -- 

//                                                                  

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// 
// Revisions:    08/01/98    a-dpawar   Created                                                                 
//				 03/02/99	 a-peterc	Added graceful exit on SEH and memory failures,
//										clean up
//
///////////////////////////////////////////////////////////////////////

#ifndef WBEMNTThreadHelper_H_
#define WBEMNTThreadHelper_H_

class WbemThreadProvider;
class CThreadModel ;

class WbemNTThread : public CThreadModel
{
	private:
	
		enum eCOUNTERTYPES
		{
			e_IDThread = 0,
			e_IDProcess,
			e_ElapsedTime,
			e_PriorityBase,
			e_PriorityCurrent,
			e_StartAddr,
			e_ThreadState,
			e_ThreadWaitReason,
			e_ThreadObjectID,
			e_UserTime,
			e_PrivilegedTime
		} ;

		struct 
		{
			BOOL bInitialised ;
			DWORD aCounterIDs[11];
			TCHAR aCounterNames[11][255] ;
		} m_stCounterIDInfo ;

		CCritSec m_csInitReadOnlyData ;		

		WBEMSTATUS eGetThreadInstance( 
										DWORD a_dwPID,
										DWORD a_dwTID, 
										CInstance *a_pInst ) ;

		WBEMSTATUS eEnumerateThreads( 
										WbemThreadProvider *a_pProvider,
										MethodContext *a_pMethodContext ) ;

		WBEMSTATUS eSetStaticData() ;

		WBEMSTATUS eGetObjectData(
									DWORD a_dwObjectID,
									PPERF_DATA_BLOCK &a_rPerfData,
									PPERF_OBJECT_TYPE &a_rPerfObj ) ;

		WBEMSTATUS eGetAllData(
									PPERF_OBJECT_TYPE a_PerfObj, 
									PPERF_INSTANCE_DEFINITION a_PerfInst,
									CInstance *a_pInst ) ;

		WBEMSTATUS eGetData(
									PPERF_OBJECT_TYPE a_PerfObj,
									PPERF_COUNTER_BLOCK a_CntrData,
									PPERF_COUNTER_DEFINITION a_PerfCntrDefn, 
									PBYTE a_pVal ) ;

		WBEMSTATUS eGetCntrDefn(
									PPERF_OBJECT_TYPE a_PerfObj,
									DWORD a_dwTIDCntrID,
									PPERF_COUNTER_DEFINITION &a_rCntrDefn ) ;


		//helper fns. to traverse the perf. blob

		PPERF_OBJECT_TYPE			FirstObject( PPERF_DATA_BLOCK a_PerfData ) ;
		PPERF_OBJECT_TYPE			NextObject( PPERF_OBJECT_TYPE a_PerfObj ) ;
		PPERF_INSTANCE_DEFINITION	FirstInstance( PPERF_OBJECT_TYPE a_PerfObj ) ;
		PPERF_INSTANCE_DEFINITION	NextInstance(PPERF_INSTANCE_DEFINITION a_PerfInst ) ;

	public:


		WbemNTThread() ;
		~WbemNTThread() ;


		// overrides
		//==========
		virtual LONG fLoadResources() ;
		virtual LONG fUnLoadResources() ;
				
		// operations
		//=========== 
			
		// Pure implementations
		//================
		virtual WBEMSTATUS eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst ) ;
		virtual WBEMSTATUS eEnumerateThreadInstances( WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext );
} ;

#endif //WBEMNTThreadHelper_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wavedevcfg.cpp ===
/*******************************************************************

 *

 *    WAVEdevCfg.cpp

 *

*  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
 *
 *******************************************************************/
#include "precomp.h"
#include "wavedevcfg.h"

CWin32WaveDeviceCfg::CWin32WaveDeviceCfg (const CHString& name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{

}

CWin32WaveDeviceCfg::~CWin32WaveDeviceCfg ()
{

}

HRESULT CWin32WaveDeviceCfg::GetObject (CInstance* pInstance, long lFlags/* = 0L*/)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	return(hr);
}

HRESULT CWin32WaveDeviceCfg::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\w2kenum.cpp ===
//=================================================================

//

// W2kEnum.cpp -- W2k enumeration support

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/28/99            Created
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>
#include "W2kEnum.h"

// max length of NTE REG_MULTI_SZ.
#define MAX_NTE_VALUE 132

/*	Note: As you read into this code and ask why all this registry routing is necessary for WMI
	understand that the model for the classes that use this under W2k is restrictive, flat and
	totally out of sync with the reality of Microsoft networking today. Adapters have interfaces,
	protocols are bound to adapters, some are virtual, and one class makes use of all these concepts
	attempting to represent this as an occurrence of an instance. This is becoming increasingly
	hard to maintain and changes are occurring faster and faster.

	The architecture is strictly bound and held over from a simpler time in	the networking world.
	A lot has changed in three years of Microsoft networking. Unfortunately	we can not change the
	architecture of the classes in WMI that represent networking. A view initiated in the Win95 days.
	We will do the best to hammer Microsoft networking into the small hole we have here. At some point
	we will be able to sit down and get this model right.

*/

CW2kAdapterEnum::CW2kAdapterEnum()
{
	try
	{
		GetW2kInstances() ;
	}
	catch ( ... )
	{
		CW2kAdapterInstance *t_pchsDel;

		for( int t_iar = 0; t_iar < GetSize(); t_iar++ )
		{
			if( t_pchsDel = (CW2kAdapterInstance*) GetAt( t_iar ) )
			{
				delete t_pchsDel ;
			}
		}

		throw;
	}
}
//
CW2kAdapterEnum::~CW2kAdapterEnum()
{
	CW2kAdapterInstance *t_pchsDel;

	for( int t_iar = 0; t_iar < GetSize(); t_iar++ )
	{
		if( t_pchsDel = (CW2kAdapterInstance*) GetAt( t_iar ) )
		{
			delete t_pchsDel ;
		}
	}
}

//
BOOL CW2kAdapterEnum::GetW2kInstances()
{
	BOOL			t_fRet = FALSE ;
	TCHAR			t_szKey[ MAX_PATH + 2 ] ;

	CW2kAdapterInstance	*t_pW2kInstance ;

	CRegistry			t_NetReg ;
	CRegistry			t_oRegLinkage ;
	CHString			t_csAdapterKey ;

	_stprintf( t_szKey, _T("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}") ) ;

	// open the master list of adapters
	if( ERROR_SUCCESS != t_NetReg.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_szKey, KEY_READ ) )
	{
		return FALSE ;
	}

	// Walk through each instance under this key.  These are all
	// adapters that show up in NT 5's Control Panel
	while( ERROR_SUCCESS == t_NetReg.GetCurrentSubKeyName( t_csAdapterKey ) )
	{
		// the key
		DWORD				t_dwIndex = _ttol( t_csAdapterKey ) ;

		CHString			t_chsCaption ;
		CHString			t_chsDescription ;
		CHString			t_chsNetCfgInstanceID ;

		CHString			t_chsCompleteKey ;
							t_chsCompleteKey = t_szKey ;
							t_chsCompleteKey += _T("\\" ) ;
							t_chsCompleteKey += t_csAdapterKey ;

		// Net instance identifier
		CRegistry	t_oRegAdapter ;
		if( ERROR_SUCCESS == t_oRegAdapter.Open( HKEY_LOCAL_MACHINE, t_chsCompleteKey, KEY_READ ) )
		{
			t_oRegAdapter.GetCurrentKeyValue( _T("NetCfgInstanceID"), t_chsNetCfgInstanceID ) ;

			// descriptions
			t_oRegAdapter.GetCurrentKeyValue( _T("DriverDesc"), t_chsCaption ) ;
			t_oRegAdapter.GetCurrentKeyValue( _T("Description"), t_chsDescription ) ;
		}

		// Get the service name
		CHString	t_chsServiceName ;
		CRegistry	t_RegNDI;
		CHString	t_chsNDIkey = t_chsCompleteKey + _T("\\Ndi" ) ;

		t_RegNDI.OpenLocalMachineKeyAndReadValue( t_chsNDIkey, _T("Service"), t_chsServiceName ) ;

		// linkage to the root device array
		CHStringArray	t_chsRootDeviceArray ;
		CHString		t_csLinkageKey = t_chsCompleteKey + _T("\\Linkage" ) ;

		if( ERROR_SUCCESS == t_oRegLinkage.Open( HKEY_LOCAL_MACHINE, t_csLinkageKey, KEY_READ ) )
		{
			CHStringArray t_chsRootDeviceArray ;

			if( ERROR_SUCCESS == t_oRegLinkage.GetCurrentKeyValue( _T("RootDevice"), t_chsRootDeviceArray ) )
			{
				// only one root device
				CHString t_chsRootDevice = t_chsRootDeviceArray.GetAt( 0 ) ;

				BOOL t_fIsRasIp = !t_chsRootDevice.CompareNoCase( L"NdisWanIp" ) ;

				// the RootDevice string is used to find the entry for the protocol
				// binding (TCP/IP)
				CHString t_csBindingKey ;
				t_csBindingKey = _T("SYSTEM\\CurrentControlSet\\Services\\tcpip\\Parameters\\Adapters\\" ) ;
				t_csBindingKey += t_chsRootDevice ;

				// IP interfaces
				CRegistry		t_RegBoundAdapter ;
				CRegistry		t_RegIpInterface ;
				CHString		t_chsIpInterfaceKey ;
				CHStringArray	t_chsaInterfaces ;
				DWORD			t_dwInterfaceCount = 0 ;

				if( ERROR_SUCCESS == t_RegBoundAdapter.Open( HKEY_LOCAL_MACHINE, t_csBindingKey, KEY_READ ) )
				{
					if( ERROR_SUCCESS == t_RegBoundAdapter.GetCurrentKeyValue( _T("IpConfig"), t_chsaInterfaces ) )
					{
						t_dwInterfaceCount = t_chsaInterfaces.GetSize() ;
					}
				}


				/* add this master adapter to the list
				*/

				// add an instance of one of these adapters
				if( !( t_pW2kInstance = new CW2kAdapterInstance ) )
				{
					throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
				}
				else
				{
					// add in the primary adapter
					t_pW2kInstance->dwIndex				= t_dwIndex ;
					t_pW2kInstance->chsPrimaryKey		= t_csAdapterKey ;
					t_pW2kInstance->chsCaption			= t_chsCaption ;
					t_pW2kInstance->chsDescription		= t_chsDescription ;
					t_pW2kInstance->chsCompleteKey		= t_chsCompleteKey ;
					t_pW2kInstance->chsService			= t_chsServiceName ;
					t_pW2kInstance->chsNetCfgInstanceID	= t_chsNetCfgInstanceID ;
					t_pW2kInstance->chsRootdevice		= t_chsRootDevice ;

					// indicate IpInterface for primary adapters not including RAS ( we'll handle RAS below )
					if( t_dwInterfaceCount && !t_fIsRasIp )
					{
						// Complete path to the nth bound adapter interface instance
						t_chsIpInterfaceKey = _T("SYSTEM\\CurrentControlSet\\Services\\" ) ;
						t_chsIpInterfaceKey += t_chsaInterfaces.GetAt( 0 ) ;

						t_pW2kInstance->chsIpInterfaceKey = t_chsIpInterfaceKey ;
					}

					Add( t_pW2kInstance ) ;
				}


				// Account for the RAS interfaces, which we add in addition to the primary interface.
				// Required to match the original implemenation under NT4 and the extentions to W2k.
				if( t_fIsRasIp )
				{
					// We use a bigger hammer to pound the large square peg of networking into
					// the small round hole of Win32_NetworkAdapterConfiguration and
					// it's associated class Win32_NetworkAdapter.

					DWORD t_dwInterfaceCount = t_chsaInterfaces.GetSize() ;

					// note all RAS interfaces that have a NTE context
					for( DWORD t_dw = 0; t_dw < t_dwInterfaceCount; t_dw++ )
					{
						// Complete path to the nth bound adapter interface instance
						t_chsIpInterfaceKey = _T("SYSTEM\\CurrentControlSet\\Services\\" ) ;
						t_chsIpInterfaceKey += t_chsaInterfaces.GetAt( t_dw ) ;

						// if a NTE context is present add in the interface
						if( ERROR_SUCCESS == t_RegIpInterface.Open( HKEY_LOCAL_MACHINE, t_chsIpInterfaceKey, KEY_READ ) )
						{

							BYTE  t_Buffer[ MAX_NTE_VALUE ] ;
							DWORD t_BufferLength = MAX_NTE_VALUE ;
							DWORD t_valueType ;

							// Does the stack know about this entry?
							if( ( ERROR_SUCCESS == RegQueryValueEx( t_RegIpInterface.GethKey(),
													_T("NTEContextList"),
													NULL,
													&t_valueType,
													&t_Buffer[0],
													&t_BufferLength ) ) &&
													(t_BufferLength > 2) ) // Wide NULL
							{
								// On the server side it is not sufficient to believe
								// ContextList is valid. RAS does not clean up after itself on this
								// end of the connection.
								// We'll test for the presence of an IP address which will confirm the
								// interface is active.
								if( IsIpPresent( t_RegIpInterface ) )
								{
									// add in the RAS interface
									if( !( t_pW2kInstance = new CW2kAdapterInstance ) )
									{
										throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
									}
									else
									{
										t_pW2kInstance->dwIndex				= (t_dwIndex << 16 ) | t_dw ;// allows for 65k of RAS interfaces
										t_pW2kInstance->chsPrimaryKey		= t_csAdapterKey ;
										t_pW2kInstance->chsCaption			= t_chsCaption ;
										t_pW2kInstance->chsDescription		= t_chsDescription ;
										t_pW2kInstance->chsCompleteKey		= t_chsCompleteKey ;
										t_pW2kInstance->chsService			= t_chsServiceName ;
										t_pW2kInstance->chsNetCfgInstanceID	= t_chsNetCfgInstanceID ;
										t_pW2kInstance->chsRootdevice		= t_chsRootDevice ;
										t_pW2kInstance->chsIpInterfaceKey	= t_chsIpInterfaceKey ;

										Add( t_pW2kInstance ) ;
									}
								}
							}
						}
					}
				}
			}
		}
		t_NetReg.NextSubKey() ;

		t_fRet = TRUE ;
	}
	return t_fRet ;
}

//
BOOL CW2kAdapterEnum::IsIpPresent( CRegistry &a_RegIpInterface )
{
	CHString		t_chsDhcpIpAddress ;
	CHStringArray	t_achsIpAddresses ;

	// test dhcp ip for validity
	a_RegIpInterface.GetCurrentKeyValue( _T("DhcpIpAddress"), t_chsDhcpIpAddress ) ;

	// not empty and not 0.0.0.0
	if( !t_chsDhcpIpAddress.IsEmpty() &&
		 t_chsDhcpIpAddress.CompareNoCase( L"0.0.0.0" ) )
	{
		return TRUE ;
	}

	// test 1st ip for validity
	a_RegIpInterface.GetCurrentKeyValue( _T("IpAddress"), t_achsIpAddresses ) ;

	if( t_achsIpAddresses.GetSize() )
	{
		CHString t_chsIpAddress = t_achsIpAddresses.GetAt( 0 ) ;

		// not empty and not 0.0.0.0
		if( !t_chsIpAddress.IsEmpty() &&
			 t_chsIpAddress.CompareNoCase( L"0.0.0.0" ) )
		{
			return TRUE ;
		}
	}

	return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wbemtoolh.h ===
//============================================================

//

// WBEMToolH.h - ToolHelp.DLL access class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#ifndef __WBEMTOOLHELP__
#define __WBEMTOOLHELP__

#include <tlhelp32.h>
#include "Kernel32Api.h"

typedef HANDLE (WINAPI *GETSNAPSHOT) (DWORD, DWORD) ;
typedef BOOL   (WINAPI *THREADWALK)  (HANDLE, LPTHREADENTRY32) ;
typedef BOOL   (WINAPI *PROCESSWALK) (HANDLE, LPPROCESSENTRY32) ;
typedef BOOL   (WINAPI *MODULEWALK)  (HANDLE, LPMODULEENTRY32) ;
typedef BOOL   (WINAPI *HEAPWALK)    (HANDLE, LPHEAPLIST32) ;


BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);


class CToolHelp
{
    public :

        CToolHelp();
       ~CToolHelp();
        
        LONG Init();

        HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID) ;
		BOOL   Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte) ;
        BOOL   Thread32Next(HANDLE hSnapshot,  LPTHREADENTRY32 lpte) ;
        BOOL   Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) ;
        BOOL   Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) ;
        BOOL   Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme) ;
        BOOL   Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme) ;
        BOOL   Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl) ;

        DWORD  dwCookie ;
        
    private :

        //HMODULE     hLibHandle ;
        CKernel32Api *m_pkernel32;

        GETSNAPSHOT pCreateToolhelp32Snapshot ;
	    THREADWALK  pThread32First ;
        THREADWALK  pThread32Next ;
        PROCESSWALK pProcess32First ;
        PROCESSWALK pProcess32Next ;
        MODULEWALK  pModule32First ;
        MODULEWALK  pModule32Next ;
        HEAPWALK    pHeap32ListFirst ;
} ;

#endif // File inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wbemtoolh.cpp ===
//============================================================

//

// WBEMToolH.cpp - implementation of ToolHelp.DLL access class

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
// 07/05/97     a-peterc    modified, added thread support
//									, added addref(), release() functionality
//============================================================

#include "precomp.h"
#include <winerror.h>

#include "WBEMToolH.h"

/*****************************************************************************
 *
 *  FUNCTION    : CToolHelp::CToolHelp
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CToolHelp::CToolHelp()
    : m_pkernel32(NULL)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CToolHelp::~CToolHelp
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CToolHelp::~CToolHelp()
{
    if(m_pkernel32 != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, m_pkernel32);
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CToolHelp::Init
 *
 *  DESCRIPTION : Loads ToolHelp.DLL, locates entry points
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : ERROR_SUCCESS or windows error code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CToolHelp::Init() {

    LONG lRetCode = ERROR_SUCCESS ;
    SmartCloseHandle hSnapshot;
    HEAPLIST32 HeapInfo ;

    m_pkernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
    if(m_pkernel32 == NULL)
    {
        // Couldn't get one or more entry points
        //======================================
        lRetCode = ERROR_PROC_NOT_FOUND;
    }

    if(lRetCode == ERROR_SUCCESS)
    {
        if(m_pkernel32->CreateToolhelp32Snapshot(TH32CS_SNAPHEAPLIST, 0, &hSnapshot))
        {
            if(hSnapshot == INVALID_HANDLE_VALUE)
            {
                lRetCode = ERROR_PROC_NOT_FOUND ;
            }
            else
            {
                HeapInfo.dwSize = sizeof(HeapInfo) ;
                BOOL bRet = FALSE;
                if(m_pkernel32->Heap32ListFirst(hSnapshot, &HeapInfo, &bRet))
                {
                    if(!bRet)
                    {
                        lRetCode = ERROR_PROC_NOT_FOUND ;
                    }
                    else
                    {
                        dwCookie = DWORD(DWORD_PTR(GetProcessHeap())) ^ HeapInfo.th32HeapID ;
                    }
                }
            }
        }
    }

    return lRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CToolHelp::CreateToolhelp32Snapshot
 *                CToolHelp::Thread32First
 *                CToolHelp::Thread32Next
 *                CToolHelp::Process32First
 *                CToolHelp::Process32Next
 *                CToolHelp::Module32First
 *                CToolHelp::Module32Next
 *
 *  DESCRIPTION : ToolHelp function wrappers
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : ToolHelp return codes
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HANDLE CToolHelp::CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID) {

    HANDLE h = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->CreateToolhelp32Snapshot(dwFlags, th32ProcessID, &h) ;
    }
    return h;
}

BOOL CToolHelp::Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Thread32First(hSnapshot, lpte, &f) ;
    }
    return f;
}

BOOL CToolHelp::Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Thread32Next(hSnapshot, lpte, &f) ;
    }
    return f;
}

BOOL CToolHelp::Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Process32First(hSnapshot, lppe, &f) ;
    }
    return f;
}

BOOL CToolHelp::Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Process32Next(hSnapshot, lppe, &f) ;
    }
    return f;
}

BOOL CToolHelp::Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Module32First(hSnapshot, lpme, &f) ;
    }
    return f;
}

BOOL CToolHelp::Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Module32Next(hSnapshot, lpme, &f) ;
    }
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wbemntthread.cpp ===
//=======================================================================

//

// WbemNTThread.CPP --Contains class to processs NT Thread performance

// data form registry

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/98    a-dpawar        Created
//				 03/02/99	 a-peterc	Added graceful exit on SEH and memory failures,
//							 clean up
//=======================================================================

#include "precomp.h"
#include "perfdata.h"
#include "ThreadProv.h"
#include "WbemNTThread.h"

#include <tchar.h>
#include <CreateMutexAsProcess.h>
#include <ProvExce.h>
#include <LockWrap.h>

WbemNTThread::WbemNTThread()
{
	ZeroMemory ( &m_stCounterIDInfo , sizeof ( m_stCounterIDInfo ) ) ;
}

WbemNTThread::~WbemNTThread()
{
	// Because of performance issues with HKEY_PERFORMANCE_DATA, we close in the
	// destructor so we don't force all the performance counter dlls to get
	// unloaded from memory, and also to prevent an apparent memory leak
	// caused by calling RegCloseKey( HKEY_PERFORMANCE_DATA ).  We use the
	// class since it has its own internal synchronization.  Also, since
	// we are forcing synchronization, we get rid of the chance of an apparent
	// deadlock caused by one thread loading the performance counter dlls
	// and another thread unloading the performance counter dlls

    // Per raid 48395, we aren't going to shut this at all.
#ifdef NTONLY
//	CPerformanceData perfdata ;

//	perfdata.Close() ;
#endif
}


//Dummy ove-rides for fns in base CThreadModel class
//------------------------------------------------------------
// Support for resource allocation, initializations, DLL loads
//
//-----------------------------------------------------------
LONG WbemNTThread::fLoadResources()
{
	return ERROR_SUCCESS ;
}

//--------------------------------------------------
// Support for resource deallocation and DLL unloads
//
//--------------------------------------------------
LONG WbemNTThread::fUnLoadResources()
{
	return ERROR_SUCCESS ;
}


/*****************************************************************************
 *
 *  FUNCTION    : WbemNTThread::eGetThreadObject
 *
 *
 *  DESCRIPTION : Fills all the thread properties for the reqd. thread
 *				  in the passed CInstance ptr.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : WBEM_NO_ERROR on success
 *
 *  COMMENTS    :
 *
 *****************************************************************************/



WBEMSTATUS WbemNTThread::eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst )
{
	WBEMSTATUS	t_eRetVal ;
	CHString	t_chsHandle;

	a_pInst->GetCHString( IDS_ProcessHandle, t_chsHandle ) ;
	DWORD t_dwProcessID = _wtol( t_chsHandle ) ;

	a_pInst->GetCHString( IDS_Handle, t_chsHandle ) ;
	DWORD t_dwThreadID = _wtol( t_chsHandle ) ;

	if ( SUCCEEDED ( eSetStaticData() ) )
	{
		//Get the thread specific properties
		t_eRetVal = eGetThreadInstance( t_dwProcessID, t_dwThreadID , a_pInst ) ;
	}
	else
	{
		t_eRetVal = WBEM_E_FAILED ;
	}

	if( SUCCEEDED( t_eRetVal ) )
	{
		// collect the common static properties
		return eLoadCommonThreadProperties( a_pProvider, a_pInst );
	}

	return t_eRetVal ;
}

/*****************************************************************************
 *
 *  FUNCTION    : WbemNTThread::eEnumerateThreadInstances
 *
 *
 *  DESCRIPTION : Creates CInstances & commits them for all threads in the system
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : WBEM_NO_ERROR on success
 *
 *  COMMENTS    :
 *
 *****************************************************************************/



WBEMSTATUS WbemNTThread::eEnumerateThreadInstances( WbemThreadProvider *a_pProvider,
													 MethodContext *a_pMethodContext )
{
	if ( SUCCEEDED ( eSetStaticData() ) )
	{
		return eEnumerateThreads( a_pProvider, a_pMethodContext ) ;
	}
	else
	{
		return WBEM_S_NO_ERROR ;
	}
}

/****************************************************************
 *                                                              *
 * Load the counter id's and names from the registry to the		*
 * class member struct stCounterIDInfo.							*
 *                                                              *
 ****************************************************************/

WBEMSTATUS WbemNTThread::eSetStaticData()
{
    HKEY	t_hKeyPerflib009 = NULL;	// handle to registry key
    DWORD	t_dwMaxValueLen	= 0;		// maximum size of key values
    DWORD	t_dwBuffer		= 0;        // bytes to allocate for buffers
    LPTSTR	t_lpCurrentString = NULL;	// pointer for enumerating data strings
    DWORD	t_dwCounter;				// current counter index
	LPTSTR	t_lpNameStrings = NULL;
	WBEMSTATUS t_eStatus = WBEM_E_FAILED ;
	try
	{
		// Open key containing counter and object names.
		CLockWrapper t_CSWrap ( m_csInitReadOnlyData ) ;

		if( m_stCounterIDInfo.bInitialised )
		{
			t_eStatus = WBEM_S_NO_ERROR ;
		}
		else
		{
			LONG t_lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
						_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"),
						0,
						KEY_READ,
						&t_hKeyPerflib009 ) ;
			// Get the size of the largest value in the key (Counter or Help).
			if ( t_lRet == ERROR_SUCCESS )
			{
				t_lRet = RegQueryInfoKey( t_hKeyPerflib009,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										&t_dwMaxValueLen,
										NULL,
										NULL);

				// Allocate memory for the counter and object names.
				if ( t_lRet == ERROR_SUCCESS )
				{
					t_dwBuffer = t_dwMaxValueLen + 1;
					t_lpNameStrings = new TCHAR[ t_dwBuffer ] ;

					if ( !t_lpNameStrings )
					{
						if ( t_hKeyPerflib009 )
						{
							RegCloseKey( t_hKeyPerflib009 ) ;
							t_hKeyPerflib009 = NULL ;
						}
        				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
					}

					t_lRet = RegQueryValueEx(	t_hKeyPerflib009,
												_T("Counter"),
												NULL,
												NULL,
												(LPBYTE) t_lpNameStrings,
												&t_dwBuffer ) ;

					// Load id's & names into an array, by index.
					if ( t_lRet == ERROR_SUCCESS )
					{
						DWORD t_dwCount = 0 ;
						for( t_lpCurrentString = t_lpNameStrings; *t_lpCurrentString && t_dwCount < 11 ;
							 t_lpCurrentString += ( _tcslen( t_lpCurrentString ) + 1 ) )
						{
							t_dwCounter = _ttol( t_lpCurrentString ) ;

							t_lpCurrentString += ( _tcslen( t_lpCurrentString ) + 1 ) ;


							if( !_tcscmp( t_lpCurrentString, _T("ID Thread") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_IDThread ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_IDThread ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}

							else if ( !_tcscmp( t_lpCurrentString, _T("ID Process") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_IDProcess ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_IDProcess ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}

							else if ( !_tcscmp( t_lpCurrentString, _T("Elapsed Time") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_ElapsedTime ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_ElapsedTime ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}

							else if ( !_tcscmp( t_lpCurrentString, _T("Priority Base") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_PriorityBase ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_PriorityBase ] , t_lpCurrentString ) ;
								t_dwCount++ ;
							}

							else if ( !_tcscmp( t_lpCurrentString, _T("Priority Current") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_PriorityCurrent ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_PriorityCurrent ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}

							else if ( !_tcscmp( t_lpCurrentString, _T("Start Address") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_StartAddr ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_StartAddr ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}

							else if ( !_tcscmp( t_lpCurrentString, _T("Thread State") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_ThreadState ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_ThreadState ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}

							else if ( !_tcscmp( t_lpCurrentString, _T("Thread Wait Reason") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_ThreadWaitReason ] = t_dwCounter ;
								_tcscpy(m_stCounterIDInfo.aCounterNames[ e_ThreadWaitReason ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}

							else if ( !_tcscmp( t_lpCurrentString, _T("Thread") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_ThreadObjectID ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_ThreadObjectID ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}
							else if ( !_tcscmp( t_lpCurrentString, _T("% User Time") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_UserTime ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_UserTime ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}
							else if ( !_tcscmp( t_lpCurrentString, _T("% Privileged Time") ) )
							{
								m_stCounterIDInfo.aCounterIDs[ e_PrivilegedTime ] = t_dwCounter ;
								_tcscpy( m_stCounterIDInfo.aCounterNames[ e_PrivilegedTime ], t_lpCurrentString ) ;
								t_dwCount++ ;
							}
						}

						m_stCounterIDInfo.bInitialised = TRUE ;
						t_eStatus = WBEM_S_NO_ERROR ;
					}

				}
			}
		}
	}
	catch( ... )
	{
		if( t_lpNameStrings )
		{
			delete[] t_lpNameStrings ;
			t_lpNameStrings = NULL ;
		}

		if ( t_hKeyPerflib009 )
		{
			RegCloseKey( t_hKeyPerflib009 ) ;
			t_hKeyPerflib009 = NULL ;
		}

		throw ;
	}

	if ( t_lpNameStrings )
	{
		delete[] t_lpNameStrings ;
		t_lpNameStrings = NULL ;
	}

	if ( t_hKeyPerflib009 )
	{
		RegCloseKey( t_hKeyPerflib009 ) ;
		t_hKeyPerflib009 = NULL ;
	}
	return t_eStatus ;
}

//
WBEMSTATUS WbemNTThread::eEnumerateThreads(WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext )
{
	PPERF_OBJECT_TYPE			t_PerfObj = 0;
	PPERF_INSTANCE_DEFINITION	t_PerfInst = 0;
	PPERF_DATA_BLOCK			t_PerfData = 0;

	DWORD t_dwObjectID = m_stCounterIDInfo.aCounterIDs[ e_ThreadObjectID ] ;

	WBEMSTATUS	t_eRetVal = WBEM_E_FAILED ;
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	CInstancePtr t_pNewInst;

	try
	{
		// Get the Performance Data blob.
		// ===============================
		if( ( t_eRetVal = eGetObjectData( t_dwObjectID, t_PerfData, t_PerfObj ) ) != WBEM_NO_ERROR )
		{
            return t_eRetVal ;
		}

		// Get the first instance.
		// =======================

		t_PerfInst = FirstInstance( t_PerfObj ) ;

		// Retrieve all instances.
		// =======================
		//NOTE: The last instance is in fact the "_Total" (Threads) instance, so we disregard that.
		for( int t_i = 0; t_i < t_PerfObj->NumInstances - 1 && SUCCEEDED( t_hResult ); t_i++ )
		{
            t_pNewInst.Attach(a_pProvider->CreateNewInstance( a_pMethodContext ));

			//Get all possible properties for this instance

			t_eRetVal = eGetAllData( t_PerfObj, t_PerfInst, t_pNewInst ) ; //pass Cinstance here

			if( SUCCEEDED( t_eRetVal ) )
			{
                //load the non-instance specific properties for this thread
				t_eRetVal = eLoadCommonThreadProperties( a_pProvider, t_pNewInst ) ;
			}

			if( SUCCEEDED( t_eRetVal ) )
			{
            	t_hResult = t_pNewInst->Commit(  ) ;
			}

			//Get Next Instance

			t_PerfInst = NextInstance( t_PerfInst ) ;
		}

	}
	catch( ... )
	{
		if( (PBYTE) t_PerfData )
		{
			delete[] (PBYTE) t_PerfData ;
		}

		throw ;
	}

	//return eRetVal ; //some might return failure...so ??

	if( (PBYTE) t_PerfData )
	{
		delete[] (PBYTE) t_PerfData ;
		t_PerfData = NULL ;
	}

	//return eRetVal ; // some data might fail
	return WBEM_NO_ERROR;
}



/****************************************************************
 *                                                              *
 * Gets the performance blob from the registry
 *for the given Object (always Thread in this case)				*
 * class member struct m_stCounterIDInfo.						*
 *                                                              *
 ****************************************************************/


WBEMSTATUS WbemNTThread::eGetObjectData(
										DWORD a_dwObjectID,
										PPERF_DATA_BLOCK &a_rPerfData,
										PPERF_OBJECT_TYPE &a_rPerfObj )
{
	DWORD	t_dwBufSize	= 0 ;
    DWORD	t_dwType	= 0 ;
    LPBYTE	t_pBuf		= 0 ;
	TCHAR	t_szObjectID[255] ;
	WBEMSTATUS t_dwRetCode = WBEM_E_OUT_OF_MEMORY ;
    long t_lStatus = 0L;
	a_rPerfData = NULL;

	try
	{
		_ltot( a_dwObjectID, t_szObjectID, 10 ) ;

		// This brace is used to create mutex in appropriate scope
		{

			CreateMutexAsProcess t_createMutexAsProcess( L"WbemPerformanceDataMutex" ) ;

			//got the mutex...now party-time !
			for (;;)
			{
				t_dwBufSize += 0x20000;   // 128K

				t_pBuf = new BYTE[ t_dwBufSize ] ;

				if( !t_pBuf )
				{
            		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
				}

				t_lStatus = RegQueryValueEx(
												 HKEY_PERFORMANCE_DATA,
												 t_szObjectID, //"232"
												 0,
												 &t_dwType,
												 t_pBuf,
												 &t_dwBufSize
												);

				if ( t_lStatus == ERROR_MORE_DATA )
				{
					delete[] t_pBuf ;
					t_pBuf = NULL ;
					continue;
				}

				if ( t_lStatus )
				{
					//some failure has occured
                    t_dwRetCode = (WBEMSTATUS) t_lStatus;
					break ;
				}

				//if we're here...we've got all the data
				t_dwRetCode = WBEM_NO_ERROR ;
				break ;

			}//for (;;)
		}

		//	RegCloseKey(HKEY_PERFORMANCE_DATA);  See Dtor code

		if( t_dwRetCode == WBEM_NO_ERROR )
		{
			//we've got a valid blob..

			a_rPerfData = (PPERF_DATA_BLOCK) t_pBuf ;

			//check if the we've got data
			if ( a_rPerfData->NumObjectTypes > 0 )
			{
				//Skip the first object data as this is a Process Object
				a_rPerfObj = FirstObject( a_rPerfData ) ;

				//This Will be a Thread Object
				a_rPerfObj = NextObject( a_rPerfObj ) ;
			}
			else
			{
				a_rPerfData = NULL ;
				delete[] t_pBuf ;
				t_pBuf = NULL ;

				t_dwRetCode = WBEM_E_FAILED ;
			}
		}

		return t_dwRetCode ;
	}
	catch( ... )
	{
		if( t_pBuf )
		{
			delete[] t_pBuf ;
		}
		a_rPerfData = NULL ;

		throw ;
	}
}

/****************************************************************
 *                                                              *
 * Gets the performance data indicated by the current instance
 * block & fills it in the CInstance							*
 *																*
 *                                                              *
 ****************************************************************/

WBEMSTATUS WbemNTThread::eGetAllData(
									 PPERF_OBJECT_TYPE a_PerfObj,
									 PPERF_INSTANCE_DEFINITION a_PerfInst ,
									 CInstance *a_pInst )
{
	PPERF_COUNTER_DEFINITION	t_PerfCntrDefn = 0 ;
	PPERF_COUNTER_BLOCK			t_CntrData = 0 ;
	DWORD						t_dwProcessId = 0 ;
	WBEMSTATUS					t_eRetVal = WBEM_E_FAILED ;
	WCHAR						t_wcBuf2[255] ;

	//Buffer to get data values
	//Currently the max data size is __int64 (8 bytes)
	BYTE t_Val[ 8 ] ;

	t_CntrData = (PPERF_COUNTER_BLOCK) ( (PBYTE) a_PerfInst + a_PerfInst->ByteLength ) ;

	t_PerfCntrDefn = (PPERF_COUNTER_DEFINITION) ( (PBYTE) a_PerfObj + a_PerfObj->HeaderLength ) ;

	//any better ideas 4this?
/*
	pInstance->SetCHString(IDS_Name, (wchar_t*)((PBYTE)PerfInst + PerfInst->NameOffset) ) ;
	pInstance->SetCHString(IDS_Caption, (wchar_t*)((PBYTE)PerfInst + PerfInst->NameOffset) ) ;
	pInstance->SetCHString(IDS_Description, (wchar_t*)((PBYTE)PerfInst + PerfInst->NameOffset) ) ;
*/

	//Get Values for all possible counters

	for( DWORD t_i = 0; t_i < a_PerfObj->NumCounters ; t_i++ )
	{
		//Get Data for this Counter Defn
		if( ( t_eRetVal = eGetData( a_PerfObj, t_CntrData, t_PerfCntrDefn, t_Val) ) == WBEM_NO_ERROR )
		{
				if( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_IDThread ] )
				{
					//NOTE: On a dual processor, we get 2 instances of system-idle threads with tid = pid =0
					//		For each such occurance,we use the index value in the instance data as the tid.
					if ( t_dwProcessId == 0 )
					{
                    	WCHAR t_wcBuf[255] ;
                    	ZeroMemory ( t_wcBuf, 255 * sizeof( WCHAR ) ) ;

						memcpy ( t_wcBuf, (PBYTE) a_PerfInst + a_PerfInst->NameOffset, a_PerfInst->NameLength ) ;
						a_pInst->SetWCHARSplat ( IDS_Handle, t_wcBuf ) ;
					}
					else
					{
						_ltow( *( (LPDWORD) t_Val ), t_wcBuf2, 10 ) ;
						a_pInst->SetWCHARSplat( IDS_Handle, t_wcBuf2 ) ;
					}

				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_IDProcess ] )
				{
					_ltow( *( (LPDWORD) t_Val ), t_wcBuf2, 10 ) ;
					a_pInst->SetWCHARSplat( IDS_ProcessHandle, t_wcBuf2 ) ;
					t_dwProcessId = *( ( LPDWORD ) t_Val ) ;
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_ElapsedTime ] )
				{
					a_pInst->SetWBEMINT64( IDS_ElapsedTime, *( (__int64*) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_PriorityBase ])
				{
					a_pInst->SetDWORD( IDS_PriorityBase, *( (LPDWORD) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_PriorityCurrent ] )
				{
					a_pInst->SetDWORD( IDS_Priority, *( (LPDWORD) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_StartAddr ] )
				{
					a_pInst->SetDWORD( IDS_StartAddress, *( (LPDWORD) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_ThreadState ] )
				{
					a_pInst->SetDWORD( IDS_ThreadState, *( (LPDWORD) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_ThreadWaitReason ] )
				{
					a_pInst->SetDWORD( IDS_ThreadWaitReason, *( (LPDWORD) t_Val ) );
				}
				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_UserTime ] )
				{
					a_pInst->SetWBEMINT64( IDS_UserModeTime, *( (__int64*) t_Val ) );
				}
				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_PrivilegedTime ] )
				{
					a_pInst->SetWBEMINT64( IDS_KernelModeTime, *( (__int64*) t_Val ) );
				}
		}
		else
		{

			//discontinue if error while seeking a desired counter

			for( int t_Count = 0 ; t_Count < 8 ; t_Count++ )
			{
				if( t_PerfCntrDefn->CounterType == m_stCounterIDInfo.aCounterIDs[ t_Count ] )
				{
					break ;
				}
			}
		}

		//Get Next Counter Defn
		t_PerfCntrDefn = (PPERF_COUNTER_DEFINITION) ( (PBYTE) t_PerfCntrDefn + t_PerfCntrDefn->ByteLength ) ;

	} //for

	return t_eRetVal ;
}



/****************************************************************
 *                                                              *
 * Gets the performance data indicated by the current instance
 * block & fills it in the passed in buffer						*
 *																*
 *                                                              *
 ****************************************************************/

 WBEMSTATUS WbemNTThread::eGetData(
									PPERF_OBJECT_TYPE a_PerfObj,
									PPERF_COUNTER_BLOCK a_CntrData,
									PPERF_COUNTER_DEFINITION a_PerfCntrDefn,
									PBYTE a_pVal )
{

    WBEMSTATUS	t_eRetVal = WBEM_E_FAILED ;
	__int64		t_PerfFreq,
				t_liDifference,
				t_PerfStartTime ;

	//Get the size in bytes of the data
	DWORD t_dwType = ( a_PerfCntrDefn->CounterType & 0x300 ) ;

	/////used for testing..
	DWORD t_SubType		= a_PerfCntrDefn->CounterType &  0x000f0000 ;
	DWORD t_dwx			= a_PerfCntrDefn->CounterType & 0x700 ;
  	DWORD t_TimerType	= a_PerfCntrDefn->CounterType &  0x00300000 ;
	int t_i				= ( t_TimerType == PERF_OBJECT_TIMER ) ;
	/////

	//Rt. now we check only for raw counters & elapsed counters & return error
	//for all other types

	switch( a_PerfCntrDefn->CounterType )
	{
		//case PERF_TYPE_NUMBER:
		case PERF_COUNTER_RAWCOUNT :

			if( t_dwType == PERF_SIZE_DWORD )
			{
				*( (LPDWORD) a_pVal ) = *( (LPDWORD) ( (PBYTE) a_CntrData + a_PerfCntrDefn->CounterOffset ) ) ;
				t_eRetVal = WBEM_NO_ERROR ;
			}

			break;
/*
 * On w2k, the counter for the startaddress is of this form
 */
		case PERF_COUNTER_RAWCOUNT_HEX :
			if( t_dwType == PERF_SIZE_DWORD )
			{
				*( (LPDWORD) a_pVal ) = *( (LPDWORD) ( (PBYTE) a_CntrData + a_PerfCntrDefn->CounterOffset ) ) ;
				t_eRetVal = WBEM_NO_ERROR ;
			}

			break;

		case PERF_ELAPSED_TIME :

			t_PerfFreq = *( (__int64 *) &( a_PerfObj->PerfFreq ) ) ;

			if( t_dwType == PERF_SIZE_LARGE )
			{
				t_PerfStartTime = *( (__int64 *) ( (PBYTE) a_CntrData + a_PerfCntrDefn->CounterOffset ) ) ;
				t_liDifference =  *( (__int64*) &a_PerfObj->PerfTime ) - t_PerfStartTime ;

				if( t_liDifference < ( (__int64) 0 ) )
				{
					*( (__int64*) a_pVal ) = (__int64) 0;
				}
				else
				{
					*( (__int64*) a_pVal ) = (t_liDifference / t_PerfFreq)*1000 ; //we're reporting elapsed time in milliseconds
				}

				t_eRetVal = WBEM_NO_ERROR ;
			}

			break;

/*
 * BobW-->The "%User Time" & "%Privileged Time" counters represent 100ns ticks.
 * We're not reporting the %age but the total time in ms so we don't need to take 2 samples as this counter type suggests.
 */
		case PERF_100NSEC_TIMER :
			if( t_dwType == PERF_SIZE_LARGE )
			{
				*( (__int64 *) a_pVal ) = *( (__int64 *) ( (PBYTE) a_CntrData + a_PerfCntrDefn->CounterOffset ) ) ;
				*( (__int64 *) a_pVal ) = (*( (__int64 *) a_pVal ) ) / 10000 ;
				t_eRetVal = WBEM_NO_ERROR ;
			}

			break;
	}

	return t_eRetVal ;

}



/****************************************************************
 *                                                              *
 * Gets the counter definition block indicated by the counter id*
 *																*
 *                                                              *
 ****************************************************************/

 WBEMSTATUS WbemNTThread::eGetCntrDefn(
										PPERF_OBJECT_TYPE a_PerfObj,
										DWORD a_dwCntrID,
										PPERF_COUNTER_DEFINITION &a_rCntrDefn )
{

	a_rCntrDefn = (PPERF_COUNTER_DEFINITION) ( (PBYTE) a_PerfObj + a_PerfObj->HeaderLength ) ;

	for( DWORD t_i = 0 ;t_i < a_PerfObj->NumCounters ; t_i++ )
	{
		//if found matching counter defn ...
		if( a_rCntrDefn->CounterNameTitleIndex == a_dwCntrID )
		{
			return WBEM_NO_ERROR ;
		}


		//get next counter defn.
		a_rCntrDefn = (PPERF_COUNTER_DEFINITION) ( (PBYTE) a_rCntrDefn + a_rCntrDefn->ByteLength ) ;
	}
	return WBEM_E_FAILED ;
}


WBEMSTATUS WbemNTThread::eGetThreadInstance(DWORD a_dwPID, DWORD a_dwTID, CInstance *a_pInst )
{
	WBEMSTATUS t_eRetVal = WBEM_E_FAILED ;

	DWORD t_dwPIDCntrID = m_stCounterIDInfo.aCounterIDs[ e_IDProcess ] ;
	DWORD t_dwTIDCntrID = m_stCounterIDInfo.aCounterIDs[ e_IDThread ] ;
	DWORD t_dwObjectID  = m_stCounterIDInfo.aCounterIDs[ e_ThreadObjectID ] ;

    PPERF_OBJECT_TYPE			t_PerfObj		= NULL ;
    PPERF_INSTANCE_DEFINITION	t_PerfInst		= 0 ;
    PPERF_COUNTER_DEFINITION	t_TIDCntrDefn	= 0,
								t_PIDCntrDefn	= 0 ;
    PPERF_COUNTER_BLOCK			t_CntrData		= 0 ;
    PPERF_DATA_BLOCK			t_PerfData		= 0 ;

	DWORD	t_dwPIDVal	= NULL,
			t_dwTIDVal	= NULL ;
	BOOL	t_bGotIt	= FALSE ;
	WCHAR	t_wcBuf[255] ;

	try
	{
		//Get Performance Blob for Threads
		if( ( t_eRetVal= eGetObjectData( t_dwObjectID, t_PerfData, t_PerfObj)) != WBEM_NO_ERROR )
		{
			return t_eRetVal ;
		}

		//Get "ID Process" Counter Defn
		t_eRetVal = eGetCntrDefn( t_PerfObj, t_dwPIDCntrID, t_PIDCntrDefn ) ;

		if( SUCCEEDED( t_eRetVal ) )
		{
			//Get "ID Thread" Counter Defn
			t_eRetVal = eGetCntrDefn( t_PerfObj, t_dwTIDCntrID, t_TIDCntrDefn ) ;
		}

		//check in all instances for matching PID & TID
		if( SUCCEEDED( t_eRetVal ) )
		{
			t_PerfInst = FirstInstance( t_PerfObj ) ;

			//NOTE: The last instance is in fact the "_Total" (Threads) instance, so we disregard that.
			for( int t_i = 0 ; t_i < t_PerfObj->NumInstances - 1; t_i++ )
			{
				t_CntrData = (PPERF_COUNTER_BLOCK) ( (PBYTE) t_PerfInst + t_PerfInst->ByteLength ) ;

				//check if PID matches
				if( ( t_eRetVal = eGetData( t_PerfObj, t_CntrData, t_PIDCntrDefn, (PBYTE) &t_dwPIDVal ) )
					== WBEM_NO_ERROR &&	t_dwPIDVal == a_dwPID )
				{
					//check if TID matches
					if( ( t_eRetVal = eGetData( t_PerfObj, t_CntrData, t_TIDCntrDefn, (PBYTE) &t_dwTIDVal ) )
						== WBEM_NO_ERROR )
					{
						//NOTE: On a dual processor, we get 2 instances of system-idle threads with tid = pid =0
						//		For each such occurance,we use the index value in the instance data as the tid.
						if ( a_dwPID == 0 )
						{
							ZeroMemory ( t_wcBuf, 255 * sizeof ( WCHAR ) ) ;
							memcpy ( t_wcBuf, (PBYTE) t_PerfInst + t_PerfInst->NameOffset, t_PerfInst->NameLength ) ;

							if ( a_dwTID == _wtoi ( t_wcBuf ) )
							{
								t_bGotIt = TRUE ;
								break ;
							}
						}
						else
						{
							if ( a_dwTID == t_dwTIDVal )
							{
								t_bGotIt = TRUE ;
								break ;
							}
						}
					}
				}

				t_PerfInst = (PPERF_INSTANCE_DEFINITION) ( (PBYTE) t_CntrData + t_CntrData->ByteLength ) ;

			} //check in all instances for matching PID & TID


			if( t_bGotIt )
			{
				//Get all the other properties for the matching Thread instance
				t_eRetVal = eGetAllData( t_PerfObj, t_PerfInst, a_pInst ) ; //pass Cinstance here
			}
			else
			{
				//failed to get matching instance
				if( SUCCEEDED( t_eRetVal ) )
				{
					t_eRetVal = WBEM_E_NOT_FOUND ;
				}
			}

		}  //if( (eRetVal == WBEM_NO_ERROR))

	}
	catch( ... )
	{
		if( t_PerfData )
		{
			delete[] (PBYTE) t_PerfData ;
		}

		throw ;
	}

	if( (PBYTE) t_PerfData )
	{
		delete[] (PBYTE) t_PerfData ;
		t_PerfData = NULL ;
	}

	return t_eRetVal ;
}



/*****************************************************************
 *                                                               *
 * Functions used to navigate through the performance data.      *
 *                                                               *
 *****************************************************************/

PPERF_OBJECT_TYPE WbemNTThread::FirstObject( PPERF_DATA_BLOCK a_PerfData )
{
    return ( (PPERF_OBJECT_TYPE)( (PBYTE) a_PerfData + a_PerfData->HeaderLength ) ) ;
}

PPERF_OBJECT_TYPE WbemNTThread::NextObject( PPERF_OBJECT_TYPE a_PerfObj )
{
    return ( (PPERF_OBJECT_TYPE) ( (PBYTE) a_PerfObj + a_PerfObj->TotalByteLength ) ) ;
}

PPERF_INSTANCE_DEFINITION WbemNTThread::FirstInstance( PPERF_OBJECT_TYPE a_PerfObj )
{
    return ( (PPERF_INSTANCE_DEFINITION) ( (PBYTE) a_PerfObj + a_PerfObj->DefinitionLength ) ) ;
}


PPERF_INSTANCE_DEFINITION WbemNTThread::NextInstance(PPERF_INSTANCE_DEFINITION a_PerfInst )
{
    PPERF_COUNTER_BLOCK t_PerfCntrBlk;

    t_PerfCntrBlk = (PPERF_COUNTER_BLOCK)( (PBYTE) a_PerfInst + a_PerfInst->ByteLength ) ;

    return ( (PPERF_INSTANCE_DEFINITION)( (PBYTE) t_PerfCntrBlk + t_PerfCntrBlk->ByteLength ) ) ;
}



/*
main()
{
	WbemNTThread t_my ;

	t_my.eSetStaticData() ;

	t_my.eGetThreadInstance( 784, 804, 48, 155, 232 ) ;

}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wdmbase.h ===
//=================================================================

//

// WDMBase.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08-Feb-1999	a-peterc        Created

//=================================================================

#include <wmium.h>


class CNodeAll;
class WdmInterface;

class CWdmInterface
{
    public:
	        
        //=================================================
        // Constructor/destructor
        //=================================================
		CWdmInterface();
		~CWdmInterface();
	
	   HRESULT hLoadBlock( CNodeAll& rNodeAll );
	  
	protected:
	private:
};

#define NAME_SIZE 256*2
#define SIZEOFWBEMDATETIME sizeof(WCHAR)*25
#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

class CNodeAll
{
    public:
	        
        //=================================================
        // Constructor/destructor
        //=================================================
      	CNodeAll( WCHAR * pwcsGuidString );
       ~CNodeAll();
	
		BOOL SetSize( DWORD dwSize );
		void FreeBlock();
		PWNODE_ALL_DATA pGetBlock();
		bool FirstInstance();
		bool NextInstance();
		GUID  GetGuid();

		bool GetInt8(__int8& int8);
		bool GetByte(BYTE & bByte);
		bool GetInt16(__int16 & int16);
		bool GetWord(WORD & wWord);
		bool GetInt32(__int32 & int32);
		bool GetDWORD(DWORD & dwWord);
		bool GetSInt64(WCHAR * pwcsBuffer);
		bool GetUInt64(WCHAR * pwcsBuffer);
		bool GetFloat(float & fFloat);
		bool GetDouble(DOUBLE & dDouble);
		bool GetBool(BYTE & bByte);
		bool GetString(CHString& rString);
		bool GetWbemTime(CHString& rString);
		bool GetInstanceName( CHString& rInstanceName );
		int  GetWMISize(long lType);

	protected:
	private:
		GUID	m_Guid;
		PWNODE_ALL_DATA m_pbDataBuffer;
		PWNODE_ALL_DATA m_pAllWnode;
		
		BYTE*	m_pbWorkingDataPtr;
		BYTE*	m_pbCurrentDataPtr;
		ULONG*	m_pMaxPtr;
		ULONG*	m_upNameOffsets;

		ULONG	m_uInstanceSize;
		int		m_nTotalInstances;
		int		m_nCurrentInstance;
		DWORD	m_dwAccumulativeSizeOfBlock;

		BOOL SetGuid(LPCWSTR pcsGuidString);
		void vReset();
		void vGetString(WCHAR * pwcsBuffer,WORD wCount);
	
		BOOL CurrentPtrOk(ULONG uHowMany);
		inline BOOL PtrOk(ULONG * pPtr,ULONG uHowMany);
		void AddPadding(DWORD dwBytesToPad);
		bool SetAllInstanceInfo();
		BOOL InitializeDataPtr();
		bool InitializeInstancePtr();
		bool GetNextNode();
		BOOL NaturallyAlignData( long lType, BOOL fRead );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32accountsid.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//
//	Win32AccountSID
//
//////////////////////////////////////////////////////
#ifndef __Win32ACCOUNTSID_H_
#define __Win32ACCOUNTSID_H_

#define  WIN32_ACCOUNT_SID_NAME L"Win32_AccountSID"

class Win32AccountSID : public Provider
{
private:
protected:
public:
	Win32AccountSID (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	~Win32AccountSID ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

};	// end class Win32LogicalFileSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wdmbase.cpp ===
//=================================================================

//

// WDMBase.cpp --

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08-Feb-1999	a-peterc        Created

//=================================================================

#include "precomp.h"

#include "WDMBase.h"
#include "wmiapi.h"



// Utilities

#define DEFAULT_MEM_SIZE 4096
//
//
CWdmInterface::CWdmInterface(){};
CWdmInterface::~CWdmInterface(){};

HRESULT CWdmInterface::hLoadBlock( CNodeAll& rNodeAll )
{
	HRESULT			hRes = WBEM_E_NOT_FOUND;
    WMIHANDLE		hCurrentWMIHandle = NULL;
	int				nRc;

    CWmiApi* pWmi = (CWmiApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWmiApi, NULL);
	__try
    {
        if(pWmi != NULL)
        {
            nRc = pWmi->WmiOpenBlock( &rNodeAll.GetGuid(), NULL, &hCurrentWMIHandle );

		    if( nRc != ERROR_SUCCESS )
			    __leave;

		    // make up to two passes at data retrieval
		    DWORD dwSize = DEFAULT_MEM_SIZE;
		    for( int i = 0; i < 2; i++ )
		    {
			    if( !rNodeAll.SetSize(dwSize) )
			    {
				    hRes = WBEM_E_OUT_OF_MEMORY;
				    __leave;
			    }

			    nRc = pWmi->WmiQueryAllData( hCurrentWMIHandle, &dwSize, rNodeAll.pGetBlock() );

			    if(ERROR_SUCCESS != nRc)
				    __leave;

			    if(dwSize <= DEFAULT_MEM_SIZE)
				    break;
		    }

		    if(!rNodeAll.pGetBlock()->WnodeHeader.BufferSize)
		    {
			    rNodeAll.FreeBlock();
			    __leave;
		    }

		    hRes = S_OK;
	    }
	}	// end __try


	__finally
    {
 		if(pWmi != NULL)
        {
			pWmi->WmiCloseBlock( hCurrentWMIHandle );
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWmiApi, pWmi);
            pWmi = NULL;
        }
    }

	return hRes;
}



//
CNodeAll::CNodeAll(  WCHAR * pwcsGuidString )
{
	m_pbDataBuffer = NULL;


	if( !SetGuid( pwcsGuidString ) )
		memset( &m_Guid, 0, sizeof(GUID) );

	vReset();
}

//
void CNodeAll::vReset()
{
	m_pAllWnode			= NULL;
	m_pbWorkingDataPtr	= NULL;
	m_pbCurrentDataPtr	= NULL;
	m_pMaxPtr			= NULL;
	m_dwAccumulativeSizeOfBlock = 0L;

	m_nCurrentInstance	= 0L;
	m_uInstanceSize		= 0L;
}

//
CNodeAll::~CNodeAll()
{
	FreeBlock();
}

GUID CNodeAll::GetGuid()
{
	return m_Guid;
}

/* ==========================================================================
 Function:  BOOL CNodeAll::SetGuid(TCHAR * pwcsGuidString)

 Description: Convert a string GUID to a CLSID

 Caveats:
 Raid:
 Notes:

 History:	a-peterc  08-Feb-1999     Created
 ========================================================================== */
BOOL CNodeAll::SetGuid(LPCWSTR pcsGuidString)
{
    CHString chsGuid(pcsGuidString);
    WCHAR wcsGuid[MAX_PATH+2];
	HRESULT hr;
    BOOL fRc = TRUE;

	swprintf(wcsGuid,L"{%s}", chsGuid );
    hr = CLSIDFromString(wcsGuid, &m_Guid);
    if (hr != S_OK){
	    hr = CLSIDFromString( chsGuid.GetBuffer(0), &m_Guid);
		if (hr != S_OK){
			fRc = FALSE;
		}
    }
    return fRc;
}

BOOL CNodeAll::SetSize( DWORD dwSize )
{
	FreeBlock();
	vReset();

	if( m_pbDataBuffer = (PWNODE_ALL_DATA)new BYTE[dwSize] )
	{
		memset(m_pbDataBuffer, 0, dwSize);
		return TRUE;
	}
	else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		return FALSE;
    }
}

PWNODE_ALL_DATA CNodeAll::pGetBlock()
{
	return m_pbDataBuffer;
}
//
void CNodeAll::FreeBlock()
{
	if(m_pbDataBuffer)	{
		delete m_pbDataBuffer;
		m_pbDataBuffer = NULL;
	}
}

//
bool CNodeAll::FirstInstance()
{
	if( !SetAllInstanceInfo() )
		return FALSE;

	if( !InitializeInstancePtr() )
		return FALSE;

	return TRUE;
}

//
bool CNodeAll::NextInstance()
{
	if( !GetNextNode() )
		return FALSE;

	if( !InitializeInstancePtr() )
		return FALSE;

    return TRUE;
}

//
bool CNodeAll::InitializeInstancePtr()
{
	m_nCurrentInstance++;
	m_dwAccumulativeSizeOfBlock = 0L;

	//================================================================
	//   Get pointer to the data offsets
	//================================================================

	if(m_pAllWnode->WnodeHeader.Flags &  WNODE_FLAG_FIXED_INSTANCE_SIZE)
	{
		//========================================================
	    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then
		// FixedInstanceSize specifies the size of each data block.
		//========================================================
		// traverse all instances of requested class
		//========================================================
        if( m_nCurrentInstance == 1 ){
            m_pbWorkingDataPtr = m_pbCurrentDataPtr;
        }
		else{
			// otherwise, we are going to calculate where it should go next
			m_pbWorkingDataPtr = (BYTE*) (ULONG *)OffsetToPtr(m_pbCurrentDataPtr, ( (m_nCurrentInstance -1) * m_pAllWnode->FixedInstanceSize ));
		}
	}
	else
	{
		//====================================================
		//
	    // If WMI_FLAG_FIXED_DATA_SIZE is not set then
		// OffsetInstanceData data is an array of ULONGS that
		// specifies the offsets to the data blocks for each
		// instance. In this case there is an array of
		// InstanceCount ULONGs followed by the data blocks.
		//
        // struct {
        //     ULONG OffsetInstanceData;
        //     ULONG LengthInstanceData;
        // } OffsetInstanceDataAndLength[]; /* [InstanceCount] */
		//====================================================
        ULONG uOffset;
		memcpy( &uOffset, m_pbCurrentDataPtr, sizeof(ULONG) );

		if( !uOffset )
		{
			return FALSE;
		}
        else
		{
		    m_pbCurrentDataPtr += sizeof( ULONG );

    		memcpy( &m_uInstanceSize, m_pbCurrentDataPtr, sizeof(ULONG) );
	    	m_pbCurrentDataPtr += sizeof( ULONG );
            m_pbWorkingDataPtr =(BYTE*) (ULONG *)OffsetToPtr(m_pAllWnode, uOffset);
        }
    }

    return TRUE;
}
//
BOOL CNodeAll::InitializeDataPtr()
{
    if ( !m_pAllWnode || !m_pAllWnode->WnodeHeader.BufferSize)
		return FALSE;

	//=====================================================
    //  Either the m_pAllWnode or m_pSingleNode is Null,
    //  which ever isn't, is the type we are working with
    //=====================================================
    if(m_pAllWnode){
		if( m_pAllWnode->WnodeHeader.Flags &  WNODE_FLAG_FIXED_INSTANCE_SIZE )
		{
			m_pbCurrentDataPtr =(BYTE*) (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->DataBlockOffset);
		}
		else{
            m_pbCurrentDataPtr =(BYTE*)(ULONG*) m_pAllWnode->OffsetInstanceDataAndLength;
		}
		m_pMaxPtr = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->WnodeHeader.BufferSize);
    }
/*    else{
        if( m_pSingleWnode ){
		    m_fFixedInstance = TRUE;
            m_pbCurrentDataPtr = (BYTE*)(ULONG *)OffsetToPtr(m_pSingleWnode, m_pSingleWnode->DataBlockOffset);
		    m_pMaxPtr = (ULONG *)OffsetToPtr(m_pSingleWnode, m_pHeaderWnode->WnodeHeader.BufferSize);
        }
    }
*/	if( (ULONG*)m_pbCurrentDataPtr > (ULONG*) m_pMaxPtr ){
		return FALSE;
	}
	if( (ULONG*) m_pbCurrentDataPtr < (ULONG*) m_pAllWnode ){
		return FALSE;
	}
	return TRUE;
}

//=============================================================
bool CNodeAll::GetNextNode()
{
    BOOL fRc = FALSE;

	if( !m_pAllWnode )
		return FALSE;

	if (m_pAllWnode->WnodeHeader.Linkage == 0){
        if( m_nCurrentInstance < m_nTotalInstances ){
			m_upNameOffsets++;
			fRc = TRUE;
        }
    }
    else{
        m_pAllWnode = (PWNODE_ALL_DATA)OffsetToPtr(m_pAllWnode, m_pAllWnode->WnodeHeader.Linkage);
        m_nCurrentInstance = 0;
		m_upNameOffsets = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->OffsetInstanceNameOffsets);
	   	fRc = TRUE;
	}

	if(fRc)
		fRc = InitializeDataPtr();

 	return fRc;
}

//=============================================================
// CIM_SINT8
bool CNodeAll::GetInt8(__int8& int8)
{
	if( !NaturallyAlignData( CIM_SINT8, TRUE ) )
		return FALSE;

	memcpy( &int8,m_pbWorkingDataPtr,sizeof(__int8));
	m_pbWorkingDataPtr += sizeof(__int8);
	return TRUE;
}

//=============================================================
// CIM_UINT8
bool CNodeAll::GetByte(BYTE & bByte)
{
	if( !NaturallyAlignData( CIM_UINT8, TRUE ) )
		return FALSE;

	memcpy( &bByte,m_pbWorkingDataPtr,sizeof(BYTE));
	m_pbWorkingDataPtr += sizeof(BYTE);
	return TRUE;
}

//=============================================================
// CIM_SINT16
bool CNodeAll::GetInt16(__int16 & int16)
{
    if( !NaturallyAlignData( CIM_SINT16, TRUE ) )
		return FALSE;

	memcpy( &int16,m_pbWorkingDataPtr,sizeof(__int16));
	m_pbWorkingDataPtr += sizeof(__int16);
	return TRUE;
}

//=============================================================
// CIM_UINT16
bool CNodeAll::GetWord(WORD & wWord)
{
    if( !NaturallyAlignData( CIM_UINT16, TRUE ) )
		return FALSE;

	memcpy( &wWord,m_pbWorkingDataPtr,sizeof(WORD));
	m_pbWorkingDataPtr += sizeof(WORD);
	return TRUE;
}

//=============================================================
// CIM_SINT32
bool CNodeAll::GetInt32(__int32 & int32)
{
	if( !NaturallyAlignData( CIM_SINT32, TRUE ) )
		return FALSE;

	memcpy( &int32,m_pbWorkingDataPtr,sizeof(__int32));
	m_pbWorkingDataPtr += sizeof(__int32);
	return TRUE;
}
//=============================================================
// CIM_UINT32
bool CNodeAll::GetDWORD(DWORD & dwWord)
{
    if( !NaturallyAlignData( CIM_UINT32, TRUE ) )
		return FALSE;

	memcpy( &dwWord,m_pbWorkingDataPtr,sizeof(DWORD));
	m_pbWorkingDataPtr += sizeof(DWORD);
	return TRUE;
}

//=============================================================
// CIM_SINT64
bool CNodeAll::GetSInt64(WCHAR * pwcsBuffer)
{
    if( !NaturallyAlignData( CIM_SINT64, TRUE ) )
		return FALSE;

	signed __int64 * pInt64;
	pInt64 = (__int64 *)m_pbWorkingDataPtr;
	swprintf(pwcsBuffer,L"%I64d",*pInt64);
	m_pbWorkingDataPtr += sizeof( signed __int64);
	return TRUE;
}
//=============================================================
// CIM_SINT64
bool CNodeAll::GetUInt64(WCHAR * pwcsBuffer)
{
    if( !NaturallyAlignData( CIM_SINT64, TRUE ) )
		return FALSE;

	unsigned __int64 * puInt64;
	puInt64 = (unsigned __int64 *)m_pbWorkingDataPtr;
	swprintf(pwcsBuffer,L"%I64u",*puInt64);
	m_pbWorkingDataPtr += sizeof(unsigned __int64);
	return TRUE;
}

//=============================================================
// CIM_REAL32
bool CNodeAll::GetFloat(float & fFloat)
{
    if( !NaturallyAlignData( CIM_REAL32, TRUE ) )
		return FALSE;

    memcpy( &fFloat,m_pbWorkingDataPtr,sizeof(float));
	m_pbWorkingDataPtr += sizeof(float);
	return TRUE;
}

//=============================================================
// CIM_REAL64
bool CNodeAll::GetDouble(DOUBLE & dDouble)
{
    if( !NaturallyAlignData( CIM_REAL64, TRUE ) )
		return FALSE;

    memcpy( &dDouble,m_pbWorkingDataPtr,sizeof(DOUBLE));
    m_pbWorkingDataPtr += sizeof(DOUBLE);
	return TRUE;
}

//=============================================================
// CIM_BOOLEAN
bool CNodeAll::GetBool(BYTE & bByte)
{
	return GetByte(bByte);
}

//=============================================================
// CIM_STRING
bool CNodeAll::GetString(CHString& rString)
{
    bool fBool = FALSE;
	WORD wCount = 0;

	// length of string
	GetWord(wCount);

	if( wCount > 0 )
	{
		if( CurrentPtrOk((ULONG)(wCount)) )
		{
			WCHAR * pBuffer = new WCHAR[wCount+4];
			if(pBuffer)
			{
                try
                {
				    memset(pBuffer,NULL,wCount+4);

				    vGetString(pBuffer, wCount);

				    rString = pBuffer;
                }
                catch ( ... )
                {
    				delete pBuffer;
                    throw ;
                }
				delete pBuffer;

				m_dwAccumulativeSizeOfBlock += wCount;
				fBool = TRUE;
			}
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

		}
	}
	else{
		rString = "";
	}

	return fBool;
}

//=============================================================
// CIM_STRING
void CNodeAll::vGetString(WCHAR * pwcsBuffer,WORD wCount)
{
    memset(pwcsBuffer,NULL,wCount);
	memcpy(pwcsBuffer,m_pbWorkingDataPtr, wCount);
	m_pbWorkingDataPtr += wCount;
}

//=============================================================
// CIM_DATETIME
bool CNodeAll::GetWbemTime(CHString& rString)
{
	if( !NaturallyAlignData( SIZEOFWBEMDATETIME, TRUE ) )
		return FALSE;

	WCHAR Buffer[SIZEOFWBEMDATETIME+2];
	memset( Buffer,NULL,SIZEOFWBEMDATETIME+2 );

	vGetString( Buffer, SIZEOFWBEMDATETIME );

	rString = Buffer;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////
bool CNodeAll::GetInstanceName( CHString& rInstanceName )
{
    bool fBool = FALSE;
    ULONG * upNameOffset = NULL;

	//=====================================================
	//  Either the m_pAllWnode or m_pSingleNode is Null,
	//  which ever isn't, is the type we are working with
	//=====================================================
	if( m_pAllWnode )
	{
		if( IsBadReadPtr( m_upNameOffsets, sizeof( ULONG *)) == 0 )
		{
			upNameOffset = ((ULONG *)OffsetToPtr(m_pAllWnode, *m_upNameOffsets));
		}
	}
	else{
		upNameOffset = m_upNameOffsets;
	}

	if( IsBadReadPtr( upNameOffset, sizeof( ULONG *)) == 0 )
	{
		if((ULONG *) (upNameOffset) < m_pMaxPtr )
		{
    		//================================================================
			//   Get pointer to the name offsets & point to next one
			//================================================================
			BYTE* pbData = (LPBYTE)upNameOffset;

			if( PtrOk((ULONG*)pbData,(ULONG)0) )
			{
				if( pbData )
				{
					SHORT NameLen = *(USHORT*)pbData;
					pbData += sizeof(USHORT);

					if( PtrOk((ULONG*)pbData,(ULONG)NameLen) )
					{
						WCHAR wName[NAME_SIZE+2];

						memset( wName, NULL, NAME_SIZE+2);
						memcpy( wName, pbData, min(NameLen, NAME_SIZE+2) );

						rInstanceName = wName;

						fBool = TRUE;
					}
				}
			}
		}
	}
    return fBool;
}

//////////////////////////////////////////////////////////////////////
int CNodeAll::GetWMISize(long lType)
{
	int nWMISize = 0;

    switch(lType){
		//	CIM_SINT8	= 16,
		//	CIM_UINT8	= 17,
		case VT_I1:
		case VT_UI1:
			nWMISize = sizeof(BYTE);
			break;

		//	CIM_SINT16	= 2,
		//	CIM_UINT16	= 18,
		case VT_I2:
		case CIM_CHAR16:
		case VT_UI2:
			nWMISize = sizeof(short);
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:
		case VT_UI4:
			nWMISize = sizeof(DWORD);
			break;

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		case VT_I8:
		case VT_UI8:
	        nWMISize = sizeof(__int64);
			break;

		//	CIM_REAL32	= 4,
		case VT_R4:
			nWMISize = sizeof(float);
			break;

	//	CIM_REAL64	= 5,
		case VT_R8:
			nWMISize = sizeof(double);
			break;

	//	CIM_BOOLEAN	= 11,
		case VT_BOOL:
	        nWMISize = sizeof(BYTE);
			break;

		case CIM_DATETIME:
			nWMISize = SIZEOFWBEMDATETIME;
			break;

		case CIM_STRING:
			nWMISize = 2;
			break;

		default:
			//	CIM_STRING	= 8,
			//	CIM_REFERENCE	= 102,
			//	CIM_OBJECT	= 13,
			//	CIM_FLAG_ARRAY	= 0x2000
 			nWMISize = 0;
	}

	return nWMISize;
}

//////////////////////////////////////////////////////////////////////
BOOL CNodeAll::NaturallyAlignData( long lType, BOOL fRead )
{
    BOOL fRc = FALSE;
	DWORD dwBytesToPad = 0;
	int nSize = GetWMISize( lType );

	if( m_dwAccumulativeSizeOfBlock != 0 ){

		DWORD dwMod;
		int nNewSize = nSize ? nSize : 1;

        if( nSize == SIZEOFWBEMDATETIME ){
			nNewSize = 2;
		}

		dwMod = (nNewSize != 0) ? m_dwAccumulativeSizeOfBlock % nNewSize : 0;

		if( dwMod > 0 ){
			dwBytesToPad = (DWORD)nNewSize - dwMod;
        }
	}
    if( fRead ){
   	    if( CurrentPtrOk((ULONG)(dwBytesToPad+nSize)) ){
            fRc = TRUE;
        }
        else{
            dwBytesToPad = 0;
        }
    }
	else{
		fRc = TRUE;
	}
    AddPadding(dwBytesToPad);
    m_dwAccumulativeSizeOfBlock += nSize + dwBytesToPad;

    return fRc;
}

//=============================================================
bool CNodeAll::SetAllInstanceInfo()
{
   bool bState = FALSE;
	if( m_pbDataBuffer ){
      	m_pAllWnode = (PWNODE_ALL_DATA)m_pbDataBuffer;
		m_upNameOffsets = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->OffsetInstanceNameOffsets);
	    m_nCurrentInstance = 1;
	    m_nTotalInstances = m_pAllWnode->InstanceCount;

		if( m_nTotalInstances > 0 ){
			if( InitializeDataPtr()){
				bState = TRUE;
			}
		}
		else{
			bState = FALSE;
		}
	}
    return bState;
}



//=============================================================
void CNodeAll::AddPadding(DWORD dwBytesToPad)
{
	m_pbWorkingDataPtr += dwBytesToPad;
}

//=============================================================
inline BOOL CNodeAll::PtrOk(ULONG * pPtr,ULONG uHowMany)
{
    ULONG * pNewPtr;
	pNewPtr = (ULONG *)OffsetToPtr(pPtr,uHowMany);
	if(pNewPtr <= m_pMaxPtr ){
		return TRUE;
	}
	return FALSE;
}
//=============================================================
BOOL CNodeAll::CurrentPtrOk(ULONG uHowMany)
{
    return(PtrOk((ULONG *)m_pbWorkingDataPtr,uHowMany));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32accountsid.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//	Win32AccountSid.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "sid.h"
#include "win32accountsid.h"

/*
    [Dynamic, description("The SID of an account.  Every account has "
        "a SID, but not every SID has an account")]
class Win32_AccountSID : CIM_ElementSetting
{
        [Description (
        ""
        ) , Read, Key]
    Win32_Account ref Element;

        [Description (
        ""
        ) , Read, Key]
    Win32_SID ref Setting;
};

*/

Win32AccountSID MyAccountSid( WIN32_ACCOUNT_SID_NAME, IDS_CimWin32Namespace );

Win32AccountSID::Win32AccountSID ( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/ )
: Provider (setName,pszNameSpace)
{
}

Win32AccountSID::~Win32AccountSID ()
{
}

HRESULT Win32AccountSID::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pInstance;

    // Collections
    TRefPointerCollection<CInstance>	accountList;

    // Perform queries
    //================

//    if (SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances(L"Win32_Account",
//        &accountList, pMethodContext, IDS_CimWin32Namespace)))

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"SELECT __RELPATH, SID FROM Win32_Account",
        &accountList, pMethodContext, GetNamespace())))
    {
        REFPTRCOLLECTION_POSITION	pos;

        CInstancePtr	pAccount;

        if ( accountList.BeginEnum( pos ) )
        {

            while (SUCCEEDED(hr)  && (pAccount.Attach(accountList.GetNext(pos)), pAccount != NULL))
            {
                //pAccount.Attach(accountList.GetNext(pos));
                //if(pAccount != NULL)
                {
                    CHString chsSid;
                    pAccount->GetCHString(IDS_SID, chsSid);

                    PSID pSid = StrToSID(chsSid);

                    CSid sid (pSid, NULL);

                    if (pSid != NULL)
                    {
                        FreeSid(pSid);
                    }

                    if (sid.IsValid())
                    {
                        pInstance.Attach(CreateNewInstance(pMethodContext));
					    if (NULL != pInstance)
					    {
	                        // set relpath to account
	                        CHString chsAccountPath;
	                        CHString chsFullAccountPath;
	                        pAccount->GetCHString(L"__RELPATH", chsAccountPath);
	                        chsFullAccountPath.Format(L"\\\\%s\\%s:%s", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, (LPCTSTR)chsAccountPath);
	                        pInstance->SetCHString(IDS_Element, chsFullAccountPath);

	                        // create a relpath for the sid
	                        CHString sidPath;
	                        sidPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, L"Win32_SID", IDS_SID, (LPCTSTR)chsSid);

	                        // and set the reference in the association
	                        pInstance->SetCHString(IDS_Setting, sidPath);
	                        // to that relpath.
	                        hr = pInstance->Commit();
					    }	// end if

                    }
                }	// WHILE GetNext
            } // pAccount not null

            accountList.EndEnum();

        }	// IF BeginEnum

    }
    return(hr);

}

HRESULT Win32AccountSID::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    // get the object for the Win32_Account Element
    CHString chsAccount;
    CInstancePtr pAccountInstance;
    pInstance->GetCHString(IDS_Element, chsAccount);
    MethodContext* pMethodContext = pInstance->GetMethodContext();

    hr = CWbemProviderGlue::GetInstanceByPath(chsAccount, &pAccountInstance, pMethodContext);
    if (SUCCEEDED(hr))
    {
        // we got the account.  Now, we can match it to the SID.
        // first, we have to generate a relpath with which to compare.
        CHString chsSid;
        CHString sidInstance;
        pAccountInstance->GetCHString(IDS_SID, chsSid);

        PSID pSid = NULL;
        try
        {
            pSid = StrToSID(chsSid);
        }
        catch(...)
        {
            if(pSid != NULL)
            {
                FreeSid(pSid);
                pSid = NULL;
            }
            throw;
        }

        CSid sid (pSid, NULL);
        if (pSid != NULL)
        {
            FreeSid(pSid);
            pSid = NULL;
        }


        if (sid.IsValid())
        {
            // create a relpath for the sid
            CHString sidPath;
            sidPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, L"Win32_SID", IDS_SID, (LPCTSTR)chsSid);

            // now, get the SID path from the instance
            pInstance->GetCHString(IDS_Setting, sidInstance);

            // compare it to our generated relpath
            if (0 != sidInstance.CompareNoCase(sidPath))
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32ace.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*******************************************************************
 *
 *    DESCRIPTION:	Win32ACE.H
 *
 *    AUTHOR:
 *
 *    HISTORY:    
 *
 *******************************************************************/

#ifndef __WIN32ACE_H_
#define __WIN32ACE_H_


#define  WIN32_ACE_NAME L"Win32_ACE" 

// provider provided for test provisions
class Win32Ace: public Provider
{
public:	
	Win32Ace(const CHString& setName, LPCTSTR pszNameSpace);
	~Win32Ace();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

	virtual HRESULT PutInstance(const CInstance& newInstance, long lFlags = 0L);
	virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

	HRESULT FillInstanceFromACE(CInstance* pInstance, CAccessEntry& ace);

protected:

	DWORD	m_dwPlatformID;

private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32allocatedresource.cpp ===
//=================================================================

//

// Win32AllocatedResource.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    2/23/99    davwoh  Created
//
// Comment: Relationship between Win32_PNPEntity and CIM_SystemResource
//
//=================================================================

#include "precomp.h"
#include <vector>
#include "PNPEntity.h"
#include "LPVParams.h"
#include <assertbreak.h>

#include "Win32AllocatedResource.h"

#define ALR_ALL_PROPERTIES 0xffffffff

// Property set declaration
//=========================
CW32PNPRes MyCW32PNPRes(PROPSET_NAME_WIN32SYSTEMDRIVER_PNPENTITY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32PNPRes::CW32PNPRes
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32PNPRes::CW32PNPRes(LPCWSTR setName, LPCWSTR pszNamespace)
: CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32PNPRes::~CW32PNPRes
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32PNPRes::~CW32PNPRes()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32PNPRes::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32PNPRes::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString    sResource,
        sDevice,
        sDeviceID,
        sClass;
    HRESULT     hRet = WBEM_E_NOT_FOUND;

    // Get the two paths
    pInstance->GetCHString(IDS_Antecedent, sResource);
    pInstance->GetCHString(IDS_Dependent, sDevice);

    // Parse the object path for the PNPEntity
    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;
    int nStatus = objpathParser.Parse( (LPWSTR)(LPCWSTR)sDevice,  &pParsedPath );

    // Did we successfully parse the PNPEntity path?
    if ( 0 == nStatus )
    {
        try
        {
            if ((pParsedPath->IsInstance()) &&                                         // Is the parsed object an instance?
                (_wcsicmp(pParsedPath->m_pClass, PROPSET_NAME_PNPEntity) == 0) &&      // Is this the class we expect (no, cimom didn't check)
                (pParsedPath->m_dwNumKeys == 1) &&                                     // Does it have exactly one key
                (pParsedPath->m_paKeys[0]) &&                                          // Is the keys pointer null (shouldn't happen)
                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                        // Check to see if the key name is not specified or
                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_DeviceID)) == 0) &&  // it is specified, and it's the right name
                                                                                       // (no, cimom doesn't do this for us).
                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&           // Check the variant type (no, cimom doesn't check this either)
                (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )                // And is there a value in it?
            {
                // Grab the pnpDevice
                sDeviceID = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
            }
        }
        catch ( ... )
        {
            objpathParser.Free( pParsedPath );
            pParsedPath = NULL;
            throw ;
        }

        // Clean up the Parsed Path
        objpathParser.Free( pParsedPath );

        CConfigManager	cfgManager;
        CConfigMgrDevicePtr pDevice(NULL);

        // Retrieve and validate the device
        if ((cfgManager.LocateDevice(sDeviceID, &pDevice)) && (CWin32PNPEntity::IsOneOfMe(pDevice)))
        {
            hRet = WBEM_E_NOT_FOUND;

            // Parse the object path for the resource
            // ==========================================
            int nStatus = objpathParser.Parse( (LPWSTR)(LPCWSTR)sResource,  &pParsedPath );

            if (nStatus == 0)
            {
                try
                {
                    // Get the class of the resource they did a getobject on (irq, dma, etc)
                    sClass = pParsedPath->m_pClass;

                    REFPTR_POSITION pos;

                    // Ok, at this point we've verified the device part.  Now
                    // we need to see if the resource they passed us really
                    // exists.
                    //------------------------------
                    if (sClass.CompareNoCase(L"Win32_IRQResource") == 0)
                    {
                        CIRQCollection irqList;

                        // Get the IRQs
                        pDevice->GetIRQResources(irqList);

                        if (irqList.BeginEnum(pos))
                        {
                            if ((pParsedPath->IsInstance()) &&
                                (pParsedPath->m_dwNumKeys == 1) &&
                                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == VT_I4) &&
                                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||
                                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_IRQNumber) == 0))
                                )
                            {
                                CIRQDescriptorPtr pIRQ(NULL);
                                DWORD dwIRQSeeking = V_I4(&pParsedPath->m_paKeys[0]->m_vValue);

                                // Walk the irq's
                                for (pIRQ.Attach(irqList.GetNext(pos));
                                pIRQ != NULL;
                                pIRQ.Attach(irqList.GetNext(pos)))
                                {
                                    if (pIRQ->GetInterrupt() == dwIRQSeeking)
                                    {
                                        hRet = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //------------------------------
                    else if (sClass.CompareNoCase(L"Win32_DMAChannel") == 0)
                    {
                        CDMACollection dmaList;

                        // Get the DMAs
                        pDevice->GetDMAResources(dmaList);

                        if (dmaList.BeginEnum(pos))
                        {
                            if ((pParsedPath->IsInstance()) &&
                                (pParsedPath->m_dwNumKeys == 1) &&
                                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == VT_I4) &&
                                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||
                                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_DMAChannel) == 0))
                                )
                            {
                                CDMADescriptorPtr pDMA(NULL);
                                DWORD dwDMASeeking = V_I4(&pParsedPath->m_paKeys[0]->m_vValue);

                                // Walk the dma's
                                for (pDMA.Attach(dmaList.GetNext(pos)) ;
                                pDMA != NULL;
                                pDMA.Attach(dmaList.GetNext(pos)))
                                {
                                    if (pDMA->GetChannel() == dwDMASeeking)
                                    {
                                        hRet = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //------------------------------
                    else if (sClass.CompareNoCase(L"Win32_DeviceMemoryAddress") == 0)
                    {

                        CDeviceMemoryCollection DevMemList;

                        // Get the DeviceMemory
                        pDevice->GetDeviceMemoryResources( DevMemList );

                        if ( DevMemList.BeginEnum(pos))
                        {
                            if ((pParsedPath->IsInstance()) &&
                                (pParsedPath->m_dwNumKeys == 1) &&
                                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&
                                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||
                                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_StartingAddress) == 0))
                                )
                            {
                                CDeviceMemoryDescriptorPtr pDeviceMemory(NULL);
                                unsigned __int64 i64StartingAddress = _wtoi64(V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue));

                                // Walk the Device Memory
                                for (pDeviceMemory.Attach(DevMemList.GetNext(pos));
                                pDeviceMemory != NULL;
                                pDeviceMemory.Attach(DevMemList.GetNext(pos)))
                                {
                                    if (pDeviceMemory->GetBaseAddress() == i64StartingAddress)
                                    {
                                        hRet = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //------------------------------
                    else if (sClass.CompareNoCase(L"Win32_PortResource") == 0)
                    {
                        CIOCollection ioList;

                        // Get the IRQs
                        pDevice->GetIOResources(ioList);

                        if ( ioList.BeginEnum(pos))
                        {
                            if ((pParsedPath->IsInstance()) &&
                                (pParsedPath->m_dwNumKeys == 1) &&
                                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&
                                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||
                                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_StartingAddress) == 0))
                                )
                            {
                                CIODescriptorPtr pIO(NULL);
                                unsigned __int64 i64StartingAddress = _wtoi64(V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue));

                                // Walk the dma's
                                for (pIO.Attach (ioList.GetNext(pos));
                                NULL != pIO;
                                pIO.Attach (ioList.GetNext(pos)))
                                {
                                    if (pIO->GetBaseAddress() == i64StartingAddress)
                                    {
                                        hRet = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        ASSERT_BREAK(0);  // Don't know what it is, so let the GetObject fail
                    }

                }
                catch ( ... )
                {
                    objpathParser.Free( pParsedPath );
                    pParsedPath = NULL;
                    throw ;
                }

                // Clean up the Parsed Path
                objpathParser.Free( pParsedPath );
            }

        }

    }

    // There are no properties to set, if the endpoints exist, we be done

    return hRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32PNPRes::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CW32PNPRes::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags )
{
    CHStringArray saDevices;
    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    pQuery.GetValuesForProp(IDS_Dependent, saDevices);

    if (saDevices.GetSize() > 0)
    {
        hr = WBEM_S_NO_ERROR;

        CObjectPathParser objpathParser;
        ParsedObjectPath *pParsedPath = NULL;

        CConfigManager	cfgManager;
        CConfigMgrDevice *pDevice = NULL;

        CHString sPNPId, sDevicePath, sPNPId2;

        for (int x=0; (x < saDevices.GetSize()) && SUCCEEDED(hr); x++)
        {

            // Parse the object path passed to us by CIMOM.
            int nStatus = objpathParser.Parse( bstr_t(saDevices[x]),  &pParsedPath );

            if ( 0 == nStatus )                                                 // Did the parse succeed?
            {
                if ((pParsedPath->IsInstance()) &&                              // Is the parsed object an instance?
                    (_wcsicmp(pParsedPath->m_pClass, L"Win32_PnPEntity") == 0) &&   // Is this the class we expect (no, cimom didn't check)
                    (pParsedPath->m_dwNumKeys == 1) &&                              // Does it have exactly one key
                    (pParsedPath->m_paKeys[0]) &&                                   // Is the keys pointer null (shouldn't happen)
                    ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                 // No key name specified or
                     (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_DeviceID) == 0)) &&  // the key name is the right value
                                                                                        // (no, cimom doesn't do this for us).
                    (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&    // Check the variant type (no, cimom doesn't check this either)
                    (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )         // And is there a value in it?
                {

                    // Find the device
                    sPNPId = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);

                    if ((cfgManager.LocateDevice(sPNPId, &pDevice)) && (CWin32PNPEntity::IsOneOfMe(pDevice)) )
                    {
                        // LoadPropertyValues always releases this
                        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                        // Now, create instances for all the resources on that device.
                        hr = LoadPropertyValues(&CLPVParams(pInstance, pDevice, ALR_ALL_PROPERTIES));
                    }
                }

                objpathParser.Free( pParsedPath );
            }
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32PNPRes::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances or ExecQuery function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32PNPRes::LoadPropertyValues(void* pv)
{
    REFPTR_POSITION pos;
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR buff[MAXI64TOA];

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance* pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);
    MethodContext *pMethodContext = pInstance->GetMethodContext();

    if(pInstance == NULL || pDevice == NULL || pMethodContext == NULL)
    {
        // This would imply a coding failure and should never happen
        ASSERT_BREAK(FALSE);
        return WBEM_E_FAILED;
    }

    CHString sResourcePath, sDevicePath, sPNPId;
    bool bValidResource;

    // Format the PNP Device path
    if ((pDevice->GetDeviceID(sPNPId)) && (!sPNPId.IsEmpty()))
    {

        // Format to suit
        CHString sPNPIdAdj;
        EscapeBackslashes(sPNPId, sPNPIdAdj);

        sDevicePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                   (LPCWSTR)GetLocalComputerName(),
                                   IDS_CimWin32Namespace,
                                   PROPSET_NAME_PNPEntity,
                                   IDS_DeviceID,
                                   (LPCWSTR)sPNPIdAdj);
    }

    // Now walk all the resources for this device
    CResourceCollection resourceList;
    pDevice->GetResourceList(resourceList);
	CResourceDescriptorPtr pResource;

    if ( resourceList.BeginEnum( pos ) )
    {
		for( pResource.Attach(resourceList.GetNext( pos ));
			 NULL != pResource && SUCCEEDED(hr);
             pResource.Attach(resourceList.GetNext( pos )) )
        {
            // Resources can be marked to be ignored.  Device manager ignores them, so we
            // do too.
            if (!pResource->IsIgnored())
            {
                DWORD dwResourceType = pResource->GetResourceType();

                switch (dwResourceType)
                {
                    case ResType_IRQ:
                    {
						IRQ_DES *pIRQ = (IRQ_DES *)pResource->GetResource();
                        if (pIRQ != NULL)
                        {
                            sResourcePath.Format(L"\\\\%s\\%s:%s.%s=%u", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                                L"Win32_IRQResource", IDS_IRQNumber, pIRQ->IRQD_Alloc_Num);
                            bValidResource = true;
                        }
                        break;
                    }

                    case ResType_DMA:
                    {

                        DMA_DES *pDMA = (DMA_DES *)pResource->GetResource();
                        if (pDMA != NULL)
                        {
                            sResourcePath.Format(L"\\\\%s\\%s:%s.%s=%u", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                                L"Win32_DMAChannel", IDS_DMAChannel, pDMA->DD_Alloc_Chan);
                            bValidResource = true;
                        }
                        break;
                    }

                    case ResType_Mem:
                    {
                        MEM_DES *pDeviceMemory = (MEM_DES *)pResource->GetResource();
                        if (pDeviceMemory != NULL)
                        {
                            _ui64tow(pDeviceMemory->MD_Alloc_Base, buff, 10);

                            sResourcePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace, L"Win32_DeviceMemoryAddress",
                                IDS_StartingAddress, buff);
                            bValidResource = true;
                        }
                        break;
                    }

                    case ResType_IO:
                    {
                        IOWBEM_DES *pIO = (IOWBEM_DES *)pResource->GetResource();
                        if (pIO != NULL)
                        {
                            sResourcePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                                L"Win32_PortResource", IDS_StartingAddress, _ui64tow(pIO->IOD_Alloc_Base, buff, 10));
                            bValidResource = true;
                        }
                        break;
                    }

                    // Don't know what to do with these yet, but they exist in NT5. Device
                    // manager doesn't seem to show anything for them, so we won't either.
                    case ResType_BusNumber:
                    case ResType_None:
                    {
                        bValidResource = false;
                        break;
                    }

                    default:
                    {
                        bValidResource = false;
                        LogErrorMessage2(L"Unrecognized resource type: %x", dwResourceType);
                        break;
                    }
                }
            }
            else
            {
                bValidResource = false;
            }

            if (bValidResource)
            {
                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                pInstance->SetCHString(IDS_Antecedent, sResourcePath);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }	//// For EnumResources
		resourceList.EndEnum();
    }	// IF BeginEnum()

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32ace.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*******************************************************************
 *
 *    DESCRIPTION: Win32Ace.cpp
 *
 *    AUTHOR:
 *
 *    HISTORY:
 *
 *******************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureregkey.h"
#include "securefile.h"
#include "win32ace.h"

/*
	THIS IS THE WIN32_ACE definition from the MOF

	[abstract,
	 description("Specifies an element of an access control")]
class Win32_ACE : Win32_MethodParameterClass
{
    Win32_Trustee Trustee;

        [Values("Access Allowed", "Access Denied", "Audit"]
    uint32 AceType;

        [description("Inheritance and such")]
    uint32 AceFlags;

        [description("Rights granted/denied/etc")]
    uint32 AccessMask;

    string GuidObjectType;

    string GuidInheritedObjectType;
};

*/

Win32Ace MyACE( WIN32_ACE_NAME, IDS_CimWin32Namespace );

Win32Ace::Win32Ace(const CHString& setName, LPCTSTR pszNameSpace)
: Provider(setName, pszNameSpace)
{
}

Win32Ace::~Win32Ace()
{
}

HRESULT Win32Ace::PutInstance(const CInstance& newInstance, long lFlags)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
	return(hr);

}

HRESULT Win32Ace::DeleteInstance(const CInstance& newInstance, long lFlags)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
	return(hr);

}

HRESULT Win32Ace::FillInstanceFromACE(CInstance* pInstance, CAccessEntry& ace)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	if (pInstance)
	{
		CInstance* pTrustee = NULL;
		// fill the Trustee
		if (SUCCEEDED( CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrustee, GetNamespace() ) ) )
		{
			// now, fill the instance with information for:
			//	SID -- Uint8 array
			//	Name -- simple string resolved from the SID
			//  Domain -- string also resolved from SID
			CSid sid;
			ace.GetSID(sid);

			// now set the embedded object
			IWbemClassObject* pClassObject;
			//IUnknown* pUnknown = NULL;

			pClassObject = pTrustee->GetClassObjectInterface();
			// create a variant of type VT_Unknown
			VARIANT vValue;
			//V_UNKNOWN(&vValue) = pUnknown;
            V_UNKNOWN(&vValue) = pClassObject;
			pInstance->SetVariant(IDS_Trustee, vValue);
			VariantClear(&vValue);
		}	// end if

		DWORD dwAceType = ace.GetACEType();
		DWORD dwAccessMask = ace.GetAccessMask();
		DWORD dwAceFlags = ace.GetACEFlags();

		// now set the remainder of the ACE information
		pInstance->SetDWORD(IDS_AceType, dwAceType);
		pInstance->SetDWORD(IDS_AccessMask, dwAccessMask);
		pInstance->SetDWORD(IDS_AceFlags, dwAceFlags);

		CHString chsInheritedObjGuid = L"";

		CHString chsObjectTypeGuid = L"";

		pInstance->SetCHString(IDS_InheritedObjectGUID, chsInheritedObjGuid);
		pInstance->SetCHString(IDS_ObjectTypeGUID, chsObjectTypeGuid);
	}	// end if
	return(hr);

}

HRESULT Win32Ace::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	return(hr);

}

HRESULT Win32Ace::GetObject ( CInstance* pInstance, long lFlags /* = 0L */ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32idecontrollerdevice.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32IDEControllerDevice.cpp
//
//  Purpose: Relationship between CIM_IDEController and CIM_LogicalDevice
//
//***************************************************************************

#include "precomp.h"
#include <vector>
#include "IDE.h"
#include "PNPEntity.h"
#include "LPVParams.h"
#include <FRQueryEx.h>

#include "WIN32IDEControllerDevice.h"

// Property set declaration
//=========================
CW32IDECntrlDev MyCW32IDECntrlDev(PROPSET_NAME_WIN32IDECONTROLLERDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::CW32IDECntrlDev
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32IDECntrlDev::CW32IDECntrlDev
(
    LPCWSTR setName,
    LPCWSTR pszNamespace
)
: CWin32IDE(setName, pszNamespace),
  CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::~CW32IDECntrlDev
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32IDECntrlDev::~CW32IDECntrlDev()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::GetObject
(
    CInstance *pInstance,
    long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if(pInstance != NULL)
    {
        CHString chstrAntecedent, chstrDependent;
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
        pInstance->GetCHString(IDS_Dependent, chstrDependent);

        // Obtain the antecedent's device id:
        CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
        chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
        CHString chstrAntecedentDevIDAdj;
        RemoveDoubleBackslashes(chstrAntecedentDevID,chstrAntecedentDevIDAdj);

        // Obtain the dependent's device id:
        CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
        chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
        CHString chstrDependentDevIDAdj;
        RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

        CConfigManager cfgmgr;

        // Now see if the dependent is visible to config manager...
        CConfigMgrDevicePtr pPNPDevice;
        if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, &pPNPDevice))
        {
            // It is visible to config manager.  Is it a PNPDevice?
            if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
            {
                // It is. Is one of its ancestors an IDEController?
				while (hr != WBEM_S_NO_ERROR)
				{
					CConfigMgrDevicePtr pParentDevice;

					if (pPNPDevice->GetParent(&pParentDevice))
					{
						if (CWin32IDE::IsOneOfMe(pParentDevice))
						{
							// It is. Is it's PNP ID the same as that which we were given?
							CHString chstrControllerPNPID;
							pParentDevice->GetDeviceID(chstrControllerPNPID);
							if(chstrAntecedentDevIDAdj.CompareNoCase(chstrControllerPNPID)==0)
							{
								hr = WBEM_S_NO_ERROR;
							}
							else
							{
    							// We ran out of IDE ancestors, so get out.
	    						break;
							}
						}
                        else
                        {
								// Set the current device to the parent so we can
								// continue up the tree.
								pPNPDevice = pParentDevice;
                        }
					}
					else
					{
						// We ran out of IDE ancestors, so get out.
						break;
					}
				}
            }
        }
    }
    return hr;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32IDECntrlDev::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CW32IDECntrlDev::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwReqProps;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwReqProps);

    std::vector<_bstr_t> vecDependents;
    pQuery.GetValuesForProp(IDS_Dependent, vecDependents);
    DWORD dwDependents = vecDependents.size();

    // Only will have one usbcontroller, so if the query asked for that
    // as the antecedent, do an enumeration.  If the query asked for a
    // specific device as the dependent, just get that one.
    if(dwDependents > 0)
    {
        for(LONG m = 0L; m < dwDependents; m++)
        {
            // Obtain the dependent's device id:
            CHString chstrDependent((LPCTSTR)vecDependents[m]);
            CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
            chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
            CHString chstrDependentDevIDAdj;
            RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

            CConfigManager cfgmgr;

            // Now see if the dependent is visible to config manager...
            CConfigMgrDevicePtr pPNPDevice;
            if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, &pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // It is. Is its parent an IDEController?
                    CConfigMgrDevicePtr pParentDevice;
                    bool bFound = false;

                    // or its parent?  Or its parent? Or...
                    while (pPNPDevice->GetParent(&pParentDevice))
                    {
                        if(CWin32IDE::IsOneOfMe(pParentDevice))
                        {
                            bFound = true;
                            break;
                        }
                        else
                        {
                            pPNPDevice = pParentDevice;
                        }
                    }

                    if (bFound)
                    {
                        // It is, so create the association.
                        CHString chstrControllerPNPID;
                        pParentDevice->GetDeviceID(chstrControllerPNPID);
                        CHString chstrControllerPNPIDAdj;
                        EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                        CHString chstrControllerPATH;
                        chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                                   (LPCWSTR)GetLocalComputerName(),
                                                   IDS_CimWin32Namespace,
                                                   PROPSET_NAME_IDE,
                                                   IDS_DeviceID,
                                                   (LPCWSTR)chstrControllerPNPIDAdj);

                        CHString chstrDevicePATH;
                        chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                               (LPCWSTR)GetLocalComputerName(),
                                               IDS_CimWin32Namespace,
                                               PROPSET_NAME_PNPEntity,
                                               IDS_DeviceID,
                                               (LPCWSTR)chstrDependentDevID);

                        hr = CreateAssociation(pMethodContext,
                                               chstrControllerPATH,
                                               chstrDevicePATH,
                                               dwReqProps);
                    }
                }
            }
        }
    }
    else
    {
        CWin32IDE::Enumerate(pMethodContext, lFlags, dwReqProps);
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::EnumerateInstances
 *
 *  DESCRIPTION : Enumerate is present here to prevent ambiguous upcasting to
 *                functions of the same name from both base classes.  The
 *                logic in LoadPropertyValues works when CWin32IDE's (the
 *                IDEController class) version of EnumerateInstances is called,
 *                so that is what we call here.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags
)
{
    return CWin32IDE::Enumerate(pMethodContext, lFlags);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::LoadPropertyValues
(
    void* pv
)
{
    // Algorithm:
    // 1) Get all instances of CIM_IDEController
    // 2) For each in #1, using cfg mgr, get its children, their children, etc.
    // 3) For each in #2, obtain DeviceID from cfg mgr, and look for instances
    //    of CIM_LogicalDevice with PNPDeviceIDs that match.
    // 4) For matches from #3, create association instances

    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrControllerPNPID;
    CHString chstrControllerPATH;
    MethodContext* pMethodContext = NULL;

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance* pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);
    if(pInstance == NULL || pDevice == NULL) return WBEM_E_FAILED;

    if((pMethodContext = pInstance->GetMethodContext()) != NULL)
    {
        VECPCHSTR vecIDEDevices;

        pDevice->GetDeviceID(chstrControllerPNPID);

        try
        {
            hr = GenerateIDEDeviceList(chstrControllerPNPID, vecIDEDevices);
            if(SUCCEEDED(hr) && vecIDEDevices.size() > 0L)
            {
                CHString chstrControllerPNPIDAdj;
                EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                           (LPCWSTR)GetLocalComputerName(),
                                           IDS_CimWin32Namespace,
                                           PROPSET_NAME_IDE,
                                           IDS_DeviceID,
                                           (LPCWSTR)chstrControllerPNPIDAdj);
                hr = ProcessIDEDeviceList(pMethodContext,
                                          chstrControllerPATH,
                                          vecIDEDevices,
                                          dwReqProps);
            }
        }
        catch ( ... )
        {
            CleanPCHSTRVec(vecIDEDevices);
            throw ;
        }

        CleanPCHSTRVec(vecIDEDevices);
    }

    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::GenerateIDEDeviceList
 *
 *  DESCRIPTION : This helper creates a list of devices hanging off the passed
 *                in device.
 *
 *  INPUTS      : vecIDEDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPNPID, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::GenerateIDEDeviceList
(
    const CHString& chstrControllerPNPID,
    VECPCHSTR& vec
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CConfigManager cfgManager;
    CConfigMgrDevicePtr pController;
    if(cfgManager.LocateDevice(chstrControllerPNPID, &pController))
    {
        if(pController != NULL)
        {
            hr = RecursiveFillDeviceBranch(pController, vec);
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::RecursiveFillDeviceBranch
 *
 *  DESCRIPTION : This helper obtains all down branch devices starting with,
 *                but not including, pDevice.
 *
 *  INPUTS      : pDevice, a device to populate the children of;
 *                vecIDEDevices, a list of devices to try to associate
 *                   to the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::RecursiveFillDeviceBranch
(
    CConfigMgrDevice* pDevice,
    VECPCHSTR& vecIDEDevices
)
{
    CConfigMgrDevicePtr pDeviceChild;
    CConfigMgrDevicePtr pDeviceSibling;
    CConfigMgrDevicePtr pDeviceSiblingNext;
    CHString* pchstrTemp = NULL;

    HRESULT hr = WBEM_S_NO_ERROR;
    if(pDevice != NULL)
    {
        if(pDevice->GetChild(&pDeviceChild) )
        {
            // Need this child's PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                if(chstrChildPNPDeviceID.GetLength() > 0)
                {
                    // Record this child...
                    pchstrTemp = (CHString*) new CHString(chstrChildPNPDeviceID);
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            vecIDEDevices.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            pchstrTemp = NULL;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }

                    // If we've hit another controller, add this one (done above), but don't go
                    // any deeper.
                    if (!CWin32IDE::IsOneOfMe(pDeviceChild))
                    {
                        // Now do its children...
                        hr = RecursiveFillDeviceBranch(pDeviceChild, vecIDEDevices);
                    }
                }
            }
            // Now call its brothers and sisters until none left (GetSibling
            // call will return FALSE):
            if(SUCCEEDED(hr))
            {
                if(pDeviceChild->GetSibling(&pDeviceSibling))
                {
                    BOOL fContinue = TRUE;
                    CHString chstrSiblingPNPDeviceID;
                    while(SUCCEEDED(hr) && fContinue)
                    {
                        // Record the sibling now...
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            if(chstrSiblingPNPDeviceID.GetLength() > 0)
                            {
                                pchstrTemp = NULL;
                                pchstrTemp = (CHString*) new CHString(chstrSiblingPNPDeviceID);
                                if(pchstrTemp != NULL)
                                {
                                    try
                                    {
                                        vecIDEDevices.push_back(pchstrTemp);
                                    }
                                    catch ( ... )
                                    {
                                        delete pchstrTemp;
                                        pchstrTemp = NULL;
                                        throw ;
                                    }
                                }
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                        }

                        // If we've hit another controller, add this one (done above), but don't go
                        // any deeper.
                        if (!CWin32IDE::IsOneOfMe(pDeviceSibling))
                        {
                            // Then do the sibling's children...
                            hr = RecursiveFillDeviceBranch(pDeviceSibling, vecIDEDevices);
                        }

                        // Then get the next sibling...
                        pDeviceSiblingNext = NULL;
                        fContinue = pDeviceSibling->GetSibling(&pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::ProcessIDEDeviceList
 *
 *  DESCRIPTION : This helper runs through the list, creating an association
 *                instance for each element in the list (vecIDEDevices) with
 *                the controller (chstrControllerPNPID).
 *
 *  INPUTS      : pMethodContext;
 *                vecIDEDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::ProcessIDEDeviceList
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    VECPCHSTR& vecIDEDevices,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    for(LONG m = 0L; m < vecIDEDevices.size() && SUCCEEDED(hr); m++)
    {
        // For each element of the vector, we need to see if there is an instance
        // of a win32_pnpentity that has the specified PNPDeviceID.
        CHString chstrDevicePATH, chstrDevPATHAdj;
        CConfigManager cfgmgr;

        // Let's see if config manager recognizes this device at all
        CConfigMgrDevicePtr pDevice;
        if(cfgmgr.LocateDevice(*vecIDEDevices[m], &pDevice))
        {
            // Ok, it knows about it.  Is it a PNPDevice device?
            if(CWin32PNPEntity::IsOneOfMe(pDevice))
            {
                // It would appear that it is.  Create the association...
                EscapeBackslashes(*vecIDEDevices[m], chstrDevPATHAdj);
                chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_PNPEntity,
                                       IDS_DeviceID,
                                       (LPCWSTR)chstrDevPATHAdj);

                hr = CreateAssociation(pMethodContext,
                                       chstrControllerPATH,
                                       chstrDevicePATH,
                                       dwReqProps);
            }
        }
    }
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::CreateAssociation
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : pMethodContext;
 *                IDEDevice, a device to associate with the controller
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper actually creates the association instance and
 *                commits it.
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::CreateAssociation
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    const CHString& chstrDevicePATH,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;
    if(pMethodContext != NULL)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            if(dwReqProps & IDECTL_PROP_Antecedent ||
               dwReqProps & IDECTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Antecedent, chstrControllerPATH);
            }
            if(dwReqProps & IDECTL_PROP_Dependent ||
               dwReqProps & IDECTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Dependent, chstrDevicePATH);
            }
            hr = pInstance->Commit();
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::FindInStringVector
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : chstrIDEDevicePNPID, device to look for
 *                vecIDEDevices, list of devices to look in
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG, number indicating 0 based offset into vecIDEDevices of
 *                the found device, or -1 if not found.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CW32IDECntrlDev::FindInStringVector
(
    const CHString& chstrIDEDevicePNPID,
    VECPCHSTR& vecIDEDevices
)
{
    LONG lPos = -1L;
    bool fFoundIt;
    for(LONG m = 0; m < vecIDEDevices.size(); m++)
    {
        if(chstrIDEDevicePNPID == *vecIDEDevices[m])
        {
            fFoundIt = true;
            break;
        }
    }
    if(fFoundIt) lPos = m;
    return lPos;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::CleanPCHSTRVec
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : vec, a vector of CHString pointers
 *
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper deletes members of a vector that are pointers.
 *
 *****************************************************************************/
void CW32IDECntrlDev::CleanPCHSTRVec
(
    VECPCHSTR& vec
)
{
    for(LONG m = 0L; m < vec.size(); m++)
    {
        delete vec[m];
    }
    vec.clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32allocatedresource.h ===
//=================================================================

//

// WIN32AllocatedResource.h 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    1/26/99    a-kevhu         Created
//
// Comment: Relationship between Win32_PNPEntity and CIM_SystemResource
// 
// MOF:
//[dynamic: ToInstance, provider("CIMWin32"), Locale(1033), UUID("{8502C50D-5FBB-11D2-AAC1-006008C78BC7}")]
//class Win32_AllocatedResource : CIM_AllocatedResource
//{
//        [Override("Antecedent"): ToSubClass, key] CIM_SystemResource ref Antecedent = NULL;
//        [Override("Dependent"): ToSubClass, key] CIM_LogicalDevice ref Dependent = NULL;
//};
//
//=================================================================

#ifndef _WIN32ALLOCATEDRESOURCE_H_
#define _WIN32ALLOCATEDRESOURCE_H_


// Property set identification
//============================
#define PROPSET_NAME_WIN32SYSTEMDRIVER_PNPENTITY  L"Win32_PNPAllocatedResource"


class CW32PNPRes;

class CW32PNPRes : public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================
        CW32PNPRes(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32PNPRes() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long a_Flags = 0L);
//        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L); 

    protected:

        // Functions inherrited from CWin32PNPEntity
        //====================================
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        CHPtrArray m_ptrProperties;
};

// This derived class commits here, not in the base.
inline bool CW32PNPRes::ShouldBaseCommit(void* pvData) { return false; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32loggedonuser.h ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
*******************************************************************/

// Property set identification
//============================

#pragma once

#define PROVIDER_NAME_WIN32LOGGEDONUSER L"Win32_LoggedOnUser"

#define PROP_ALL_REQUIRED          0xFFFFFFFF
#define PROP_NONE_REQUIRED         0x00000000
#define PROP_ANTECEDENT            0x00000001
#define PROP_DEPENDENT             0x00000002

// Property name externs -- defined in MSJ_GroupMembership.cpp
//=================================================

class CWin32LoggedOnUser ;


_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class CWin32LoggedOnUser : public Provider 
{
    public:
        // Constructor/destructor
        //=======================

        CWin32LoggedOnUser(
            LPCWSTR lpwszClassName, 
            LPCWSTR lpwszNameSpace);

        virtual ~CWin32LoggedOnUser();

#ifdef NTONLY

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(
            MethodContext*  pMethodContext, 
            long lFlags = 0L);

        virtual HRESULT GetObject(
            CInstance* pInstance, 
            long lFlags, 
            CFrameworkQuery& Query);
        


    private:
        HRESULT Enumerate(
            MethodContext *pMethodContext, 
            DWORD dwPropsRequired);

        HRESULT LoadPropertyValues(
            CInstance* pInstance, 
            CUser& user, 
            CSession& ses, 
            DWORD dwPropsRequired);

        bool AreAssociated(
            const CInstance *pUserInst, 
             const CInstance *pGroupInst);

        HRESULT ValidateEndPoints(
            MethodContext *pMethodContext, 
            const CInstance *pInstance, 
            CInstancePtr &pAntUserActInst, 
            CInstancePtr &pDepSesInst);

        HRESULT EnumerateSessionsForUser(
            CUserSessionCollection& usc,
            CUser& user, 
            MethodContext *pMethodContext, 
            DWORD dwPropsRequired);

        DWORD GetRequestedProps(
            CFrameworkQuery& Query);

#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicaldiskrootwin32directory.h ===
//=================================================================

//

// Win32LogicalDiskCIMLogicalFile 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/09/98    a-kevhu         Created
//
// Comment: Relationship between Win32_LogicalDisk and Win32_Directory
//
//=================================================================

// Property set identification
//============================

#ifndef _WIN32LOGICALDISKROOTWIN32DIRECTORY_H_
#define _WIN32LOGICALDISKROOTWIN32DIRECTORY_H_

#define  PROPSET_NAME_WIN32LOGICALDISKROOT_WIN32DIRECTORY L"Win32_LogicalDiskRootDirectory"





class Win32LogDiskWin32Dir;

class Win32LogDiskWin32Dir : public CFileFile 
{
    public:
        // Constructor/destructor
        //=======================
        Win32LogDiskWin32Dir(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~Win32LogDiskWin32Dir() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32idecontrollerdevice.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32IDEControllerDevice.h 
//
//  Purpose: Relationship between CIM_IDEController and CIM_LogicalDevice
//
//***************************************************************************

#ifndef _WIN32IDECONTROLLERDEVICE_H_
#define _WIN32IDECONTROLLERDEVICE_H_


#define IDECTL_PROP_ALL_PROPS                    0xFFFFFFFF
#define IDECTL_PROP_ALL_PROPS_KEY_ONLY           0x00000003
#define IDECTL_PROP_Antecedent                   0x00000001
#define IDECTL_PROP_Dependent                    0x00000002



// Property set identification
//============================
#define PROPSET_NAME_WIN32IDECONTROLLERDEVICE  L"Win32_IDEControllerDevice"


typedef std::vector<CHString*> VECPCHSTR;

class CW32IDECntrlDev;

class CW32IDECntrlDev : public CWin32IDE, public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================
        CW32IDECntrlDev(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32IDECntrlDev() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long a_Flags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L); 

    protected:

        // Functions inherrited from CWin32IDE
        //====================================
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        CHPtrArray m_ptrProperties;
        void CleanPCHSTRVec(VECPCHSTR& vec);
        HRESULT GenerateIDEDeviceList(const CHString& chstrControllerPNPID, 
                                      VECPCHSTR& vec);
        HRESULT RecursiveFillDeviceBranch(CConfigMgrDevice* pRootDevice, 
                                          VECPCHSTR& vecIDEDevices); 
        HRESULT ProcessIDEDeviceList(MethodContext* pMethodContext, 
                                     const CHString& chstrControllerRELPATH, 
                                     VECPCHSTR& vecIDEDevices,
                                     const DWORD dwReqProps);
        HRESULT CreateAssociation(MethodContext* pMethodContext,
                                  const CHString& chstrControllerPATH, 
                                  const CHString& chstrIDEDevice,
                                  const DWORD dwReqProps);
        LONG FindInStringVector(const CHString& chstrIDEDevicePNPID, 
                                VECPCHSTR& vecIDEDevices);


};

// This derived class commits here, not in the base.
inline bool CW32IDECntrlDev::ShouldBaseCommit(void* pvData) { return false; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicaldiskrootwin32directory.cpp ===
//=================================================================

//

// Win32LogicalDiskWin32Directory.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between win32_programgroup and contained cim_datafiles
//
//=================================================================

#include "precomp.h"

#include "FileFile.h"
#include "Win32LogicalDiskRootWin32Directory.h"
#include "implement_logicalfile.h"
#include "directory.h"

// Property set declaration
//=========================
Win32LogDiskWin32Dir MyWin32LogDiskWin32Dir(PROPSET_NAME_WIN32LOGICALDISKROOT_WIN32DIRECTORY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::Win32LogDiskWin32Dir
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32LogDiskWin32Dir::Win32LogDiskWin32Dir(LPCWSTR setName, LPCWSTR pszNamespace)
:CFileFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::~Win32LogDiskWin32Dir
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

Win32LogDiskWin32Dir::~Win32LogDiskWin32Dir()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32LogDiskWin32Dir::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrLogicalDisk;
    CHString chstrDir;
    HRESULT hr = WBEM_E_NOT_FOUND;
    CInstancePtr pinstLogicalDisk;
    CInstancePtr pinstDir;

    if(pInstance != NULL)
    {
        // Get the two paths
        pInstance->GetCHString(IDS_GroupComponent, chstrLogicalDisk);
        pInstance->GetCHString(IDS_PartComponent, chstrDir);

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrLogicalDisk, &pinstLogicalDisk, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDir, &pinstDir, pInstance->GetMethodContext())))
            {
                // Get the disk letter from the logical disk instance (antecedent):
                CHString chstrDiskLetterFromDisk;
                LONG lPos = chstrLogicalDisk.ReverseFind(_T(':'));
                chstrDiskLetterFromDisk = chstrLogicalDisk.Mid(lPos-1, 1);

                // Get the disk letter from the directory instance:
                CHString chstrDiskLetterFromDir;
                lPos = chstrDir.ReverseFind(_T(':'));
                chstrDiskLetterFromDir = chstrDir.Mid(lPos-1, 1);

                // If those two are the same, proceed:
                if(chstrDiskLetterFromDisk.CompareNoCase(chstrDiskLetterFromDir)==0)
                {
                    // Now confirm that we are looking at the root dir (this association
                    // only associates a disk with its root directory).
                    CHString chstrDirName = chstrDir.Mid(lPos+1);
                    chstrDirName = chstrDirName.Left(chstrDirName.GetLength() - 1);

                    if(chstrDirName == _T("\\\\"))
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            } //dir instancebypath
        } //logicaldisk instancebypath
    } // pinstance not null
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32LogDiskWin32Dir::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHStringArray achstrGroupComponent;
    DWORD dwGroupComponents;

    pQuery.GetValuesForProp(IDS_GroupComponent, achstrGroupComponent);
    dwGroupComponents = achstrGroupComponent.GetSize();
    if(dwGroupComponents == 1)
    {
        // Need to construct the path of the antecedent...
        CInstancePtr pInstance;
        if (SUCCEEDED(CWbemProviderGlue::GetInstanceKeysByPath(achstrGroupComponent[0], &pInstance, pMethodContext)))
        {
            CHString chstrLogicalDiskPATH;

//            chstrLogicalDiskPATH.Format(_T("\\\\%s\\%s:%s"), GetLocalComputerName(), IDS_CimWin32Namespace, achstrGroupComponent[0]);
            pInstance->GetCHString(IDS___Path, chstrLogicalDiskPATH);
            CHString chstrDiskLetter;
            LONG lPos = achstrGroupComponent[0].ReverseFind(_T(':'));
            chstrDiskLetter = achstrGroupComponent[0].Mid(lPos-1, 1);
            CHString chstrDirectoryPATH;
            chstrDirectoryPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s:\\\\\"",
                                              (LPCWSTR)GetLocalComputerName(),
                                              IDS_CimWin32Namespace,
                                              PROPSET_NAME_DIRECTORY,
                                              (LPCWSTR)chstrDiskLetter);
            hr = GetSingleSubItemAndCommit(chstrLogicalDiskPATH,
                                           chstrDirectoryPATH,
                                           pMethodContext);
        }
    }
    else
    {
        hr = EnumerateInstances(pMethodContext);
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32LogDiskWin32Dir::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LDisks;

//    if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(_T("Win32_LogicalDisk")),
//                                                    &LDisks,
//                                                    IDS_CimWin32Namespace,
//                                                    pMethodContext)))

    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(L"Select __Path, DeviceID From Win32_LogicalDisk",
                                                    &LDisks,
                                                    pMethodContext, GetNamespace())))
    {
        REFPTRCOLLECTION_POSITION pos;
        if(LDisks.BeginEnum(pos))
        {
            CInstancePtr pinstDisk;
            CHString chstrLogicalDisk;
            CHString chstrLogicalDiskPath;
            CHString chstrDiskLetter;
            CHString chstrDirectoryPATH;

            for (pinstDisk.Attach(LDisks.GetNext(pos)) ;
                (SUCCEEDED(hr)) && (pinstDisk != NULL) ;
                 pinstDisk.Attach(LDisks.GetNext(pos)) )
            {
                if(pinstDisk != NULL)
                {
                    // grab every directory hanging off of the root of that disk...
                    pinstDisk->GetCHString(L"__PATH", chstrLogicalDiskPath);
                    pinstDisk->GetCHString(IDS_DeviceID, chstrDiskLetter);
                    chstrDirectoryPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\\\\\"",
                                              (LPCWSTR)GetLocalComputerName(),
                                              IDS_CimWin32Namespace,
                                              PROPSET_NAME_DIRECTORY,
                                              (LPCWSTR)chstrDiskLetter);
                    hr = GetSingleSubItemAndCommit(chstrLogicalDiskPath,
                                                   chstrDirectoryPATH,
                                                   pMethodContext);
                }
            }
            LDisks.EndEnum();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32loggedonuser.cpp ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
******************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
//#include <ntlsa.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <frqueryex.h>

#include <Session.h>

#include "Win32LoggedOnUser.h"
#include "sid.h"

CWin32LoggedOnUser MyWin32_LogonSession(
    PROVIDER_NAME_WIN32LOGGEDONUSER, 
    IDS_CimWin32Namespace);


/*****************************************************************************
 *
 *  FUNCTION    :   CWin32LoggedOnUser::CWin32LoggedOnUser
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CWin32LoggedOnUser::CWin32LoggedOnUser(
    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace)
  :
    Provider(lpwszName, lpwszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CWin32LoggedOnUser::~CWin32LoggedOnUser
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CWin32LoggedOnUser::~CWin32LoggedOnUser ()
{
}



/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with 
*                   WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the 
*                   following flags are handled by (and filtered out by) 
*                   WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::EnumerateInstances(
    MethodContext* pMethodContext, 
    long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = Enumerate(
        pMethodContext, 
        PROP_ALL_REQUIRED);

    return hr;
}
#endif
/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    A valid HRESULT 
*
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::GetObject(
    CInstance* pInstance, 
    long lFlags,
    CFrameworkQuery& Query)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pAntUsrActInst, pDepSesInst;
    MethodContext *pMethodContext = pInstance->GetMethodContext();

    // The Antecedent property contains an object path that points to a user
    // account.  The Dependent property contains an object path that points 
    // to a session.  Let's do a GetObject on these two and make sure they 
    // point to valid users and sessions.

    hr = ValidateEndPoints(
        pMethodContext, 
        pInstance, 
        pAntUsrActInst, 
        pDepSesInst);

    if (SUCCEEDED(hr))
    {
        // Ok, the user and the session both exist.  Now, does this
        // session belong to this user?
        if (AreAssociated(
            pAntUsrActInst, 
            pDepSesInst))
        {
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::Enumerate
*
*  DESCRIPTION :    Internal helper function used to enumerate instances of
*                   this class.  All instances are enumerated, but only the
*                   properties specified are obtained.
*
*  INPUTS      :    A pointer to a the MethodContext for the call.
*                   A DWORD specifying which properties are requested.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::Enumerate(
    MethodContext *pMethodContext, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We will use the helper class CUserSessionCollection to get
    // a mapping of users and their associated sessions.
    CUserSessionCollection usc;

    USER_SESSION_ITERATOR usiter;
    SmartDelete<CUser> puser;

    puser = usc.GetFirstUser(usiter);
    while(puser != NULL)
    {
        hr = EnumerateSessionsForUser(
            usc,
            *puser,
            pMethodContext, 
            dwPropsRequired);

        puser = usc.GetNextUser(usiter);
    }

    return hr;
}
#endif

/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::EnumerateSessionsForUser
*
*  DESCRIPTION :    Called by Enumerate to enumerate the sessions of a given
*                   user. 
*
*  INPUTS      :    A mapping of users and their associated sessions,
*                   the user to enumerate sessions for, the methodcontext
*                   to communicate to winmgmt with, and a property bitmask of
*                   which properties to populate
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::EnumerateSessionsForUser(
    CUserSessionCollection& usc,
    CUser& user, 
    MethodContext *pMethodContext, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    USER_SESSION_ITERATOR usiter;
    SmartDelete<CSession> pses;

    pses = usc.GetFirstSessionOfUser(
        user,
        usiter);

    while(pses != NULL)
    {
        // Create a new instance based on the passed-in 
        // MethodContext.  Note that CreateNewInstance may 
        // throw, but will never return NULL.
        CInstancePtr pInstance(
            CreateNewInstance(
                pMethodContext), 
                false);

        hr = LoadPropertyValues(
            pInstance, 
            user, 
            *pses, 
            dwPropsRequired);

        if(SUCCEEDED(hr))
        {
            hr = pInstance->Commit();   
        }

        pses = usc.GetNextSessionOfUser(
            usiter);
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::LoadPropertyValues
*
*  DESCRIPTION :    Internal helper function used to fill in all unfilled
*                   property values.  At a minimum, it must fill in the key
*                   properties.
*
*  INPUTS      :    A pointer to a CInstance containing the instance we are
*                   attempting to locate and fill values for.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::LoadPropertyValues(
    CInstance* pInstance, 
    CUser& user, 
    CSession& ses, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chstrValue;

    WCHAR wstrBuff[MAXI64TOA];

    _i64tow(
        ses.GetLUIDint64(), 
        wstrBuff, 
        10);

    if (dwPropsRequired & PROP_ANTECEDENT)
    {
        // Need domain and name...
        CSid sidUser(user.GetPSID());
        SID_NAME_USE snu = sidUser.GetAccountType();
        if(snu == SidTypeWellKnownGroup)
        {
            chstrValue.Format(
                L"\\\\.\\%s:Win32_Account.Domain=\"%s\",Name=\"%s\"", 
                IDS_CimWin32Namespace, 
                (LPCWSTR)GetLocalComputerName(), 
                (LPCWSTR)(sidUser.GetAccountName()));
        }
        else
        {
            chstrValue.Format(
                L"\\\\.\\%s:Win32_Account.Domain=\"%s\",Name=\"%s\"", 
                IDS_CimWin32Namespace, 
                (LPCWSTR)(sidUser.GetDomainName()), 
                (LPCWSTR)(sidUser.GetAccountName()));    
        }

        pInstance->SetCHString(
            IDS_Antecedent, 
            chstrValue);
    }

    if (dwPropsRequired & PROP_DEPENDENT)
    {
        chstrValue.Format(
            L"\\\\.\\%s:Win32_LogonSession.LogonId=\"%s\"", 
            IDS_CimWin32Namespace, 
            (LPCWSTR)wstrBuff);

        pInstance->SetCHString(
            IDS_Dependent, 
            chstrValue);
    }

    return hr;
}
#endif



/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::ValidateEndPoints
*
*  DESCRIPTION :    Internal helper function used to determine whether the
*                   two object paths in the association currently point
*                   to valid users/sessions.
*
*
*  INPUTS      :    MethodContext to call back into winmgmt with, and
*                   the CInstance that is to be checked.
*
*  OUTPUTS     :    Pointers to CInstances that contain the actual objects
*                   from the endpoint classes.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::ValidateEndPoints(
    MethodContext *pMethodContext, 
    const CInstance *pInstance, 
    CInstancePtr &pAntUserActInst, 
    CInstancePtr &pDepSesInst)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrUserPath;

    // See if the User specified exists
    pInstance->GetCHString(
        IDS_Antecedent, 
        chstrUserPath);

    hr = CWbemProviderGlue::GetInstanceKeysByPath(
        chstrUserPath, 
        &pAntUserActInst, 
        pMethodContext);

    if (SUCCEEDED(hr))
    {
        // The users exists.  Now, see if the session exists.
        CHString chstrSesPath;
        pInstance->GetCHString(
            IDS_Dependent, 
            chstrSesPath);

        hr = CWbemProviderGlue::GetInstanceKeysByPath(
            chstrSesPath, 
            &pDepSesInst, 
            pMethodContext);
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::AreAssociated
*
*  DESCRIPTION :    Internal helper function used to determine whether a
*                   specific session is associated to the specified user.
*
*  INPUTS      :    LOCALGROUP_MEMBERS_INFO_2
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
bool CWin32LoggedOnUser::AreAssociated(
    const CInstance *pUserInst, 
    const CInstance *pSesInst)
{
    bool fRet = false;

    CHString chstrUserName;
    CHString chstrUserDomain;
    CHString chstrSesLogonId;

    pUserInst->GetCHString(IDS_Name, chstrUserName);
    pUserInst->GetCHString(IDS_Domain, chstrUserDomain);
    pSesInst->GetCHString(IDS_LogonId, chstrSesLogonId);
    __int64 i64LogonID = _wtoi64(chstrSesLogonId);

    CSid userSid(chstrUserName, NULL);

    if(userSid.IsOK() &&
       userSid.IsValid())
    {
        CUser user(userSid.GetPSid());

        // We will use the helper class CUserSessionCollection to get
        // a mapping of users and their associated sessions.
        CUserSessionCollection usc; 
        USER_SESSION_ITERATOR pos;
        SmartDelete<CSession> pses;

        pses = usc.GetFirstSessionOfUser(
            user,
            pos);

        while(pses != NULL &&
              !fRet)
        {
            // see if we find a session id match for this user...
            if(i64LogonID == pses->GetLUIDint64())
            {
                fRet = true;
            }
            
            pses = usc.GetNextSessionOfUser(
                pos);
        }
    }   

    return fRet;
}
#endif



/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::GetRequestedProps
*
*  DESCRIPTION :    Internal helper function used to determine which
*                   properties are required to satisfy the GetObject or
*                   ExecQuery request.
*
*  INPUTS      :    A pointer to a CFrameworkQuery from which we can determine
*                   the required properties.
*
*  RETURNS     :    A DWORD bitmask that maps those properties that are
*                   required. 
*
*****************************************************************************/
#ifdef NTONLY
DWORD CWin32LoggedOnUser::GetRequestedProps(CFrameworkQuery& Query)
{
    DWORD dwReqProps = 0;

    if (Query.IsPropertyRequired(IDS_Antecedent)) dwReqProps |= PROP_ANTECEDENT;
    if (Query.IsPropertyRequired(IDS_Dependent)) dwReqProps |= PROP_DEPENDENT;

    return dwReqProps;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicalfilesecuritysetting.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//	Win32logicalFileSecSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "win32logicalfilesecuritysetting.h"

#include "ImpLogonUser.h"

#include <accctrl.h>
#include "AccessRights.h"
#include "SecureShare.h"
#include "wbemnetapi32.h"

#include "SecUtils.h"

/*
	DEFENITION FROM THE MOF
    [description("security settings for a logical file")]
class Win32_LogicalFileSecuritySetting : Win32_SecuritySetting
{
    	[key]
    string Path;

        [implemented, description("Retrieves a structural representation of the object's "
         "security descriptor")]
    uint32 GetSecurityDescriptor([out] Win32_SecurityDescriptor);

        [implemented, description("Sets security descriptor to the specified structure")]
    uint32 SetSecurityDescriptor([in] Win32_SecurityDescriptor Descriptor)
};
*/



Win32LogicalFileSecuritySetting LogicalFileSecuritySetting( WIN32_LOGICAL_FILE_SECURITY_SETTING, IDS_CimWin32Namespace );

Win32LogicalFileSecuritySetting::Win32LogicalFileSecuritySetting ( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/ )
: CImplement_LogicalFile(setName, pszNameSpace)
{
}

Win32LogicalFileSecuritySetting::~Win32LogicalFileSecuritySetting ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32LogicalFileSecuritySetting::ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

	// Do we recognize the method?
	if (_wcsicmp(bstrMethodName, L"GetSecurityDescriptor") == 0)
	{
        hr = ExecGetSecurityDescriptor(pInstance, pInParams, pOutParams, lFlags);
   	}
   	else if (_wcsicmp(bstrMethodName, L"SetSecurityDescriptor") == 0)
   	{
   		// actually sets the security descriptor on the object by
		// taking the properties out of the Win32_SecurityDescriptor
		// and turning them into a CSecurityDescriptor object to apply
		// to the secure file.
   		hr = ExecSetSecurityDescriptor(pInstance, pInParams, pOutParams, lFlags);
   	}
	else
   	{
    	hr = WBEM_E_INVALID_METHOD;
	}
#endif
#ifdef WIN9XONLY
    hr = WBEM_E_INVALID_METHOD
#endif

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalFileSecuritySetting::ExecGetSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalFileSecuritySetting::ExecGetSecurityDescriptor (
	const CInstance& pInstance,
	CInstance* pInParams,
	CInstance* pOutParams,
	long lFlags
)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	// converts the security descriptor from the file into a
	// Win32_Security object.
	if (pOutParams)
	{
		CHString chsPath;
		CSid sidOwner;
		CSid sidGroup;
		CDACL dacl;
		CSACL sacl;
		CInstancePtr pTrusteeOwner;
		CInstancePtr pTrusteeGroup;
		CInstancePtr pSecurityDescriptor;

		if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_SecurityDescriptor", &pSecurityDescriptor, GetNamespace())))
		{
			SECURITY_DESCRIPTOR_CONTROL control;
			pInstance.GetCHString(IDS_Path, chsPath);

			// check to see that it is of the right type?
			// get the secure file based on the path
			CSecureFile secFile ;
			DWORD dwRetVal = secFile.SetFileName(chsPath, TRUE) ;
			if ( dwRetVal == ERROR_ACCESS_DENIED )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_ACCESS_DENIED) ;
				return WBEM_E_ACCESS_DENIED;
			}
			else if ( dwRetVal == ERROR_PRIVILEGE_NOT_HELD )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_PRIVILEGE_NOT_HELD ) ;
                SetSinglePrivilegeStatusObject(pInstance.GetMethodContext(), SE_SECURITY_NAME);
				return WBEM_E_ACCESS_DENIED;
			}

			secFile.GetControl(&control);

			pSecurityDescriptor->SetDWORD(IDS_ControlFlags, control);

			// get the secure file's owner to create the Owner Trustee
			secFile.GetOwner(sidOwner);

			if ( sidOwner.IsValid() && SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_Trustee", &pTrusteeOwner, GetNamespace())))
			{
				FillTrusteeFromSid(pTrusteeOwner, sidOwner);
				pSecurityDescriptor->SetEmbeddedObject(IDS_Owner, *pTrusteeOwner);
			}

			// get the secure file's group to create the Group Trustee
			secFile.GetGroup(sidGroup);
		  	if (sidGroup.IsValid() && SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_Trustee", &pTrusteeGroup, GetNamespace())))
			{
				FillTrusteeFromSid(pTrusteeGroup, sidGroup);
				pSecurityDescriptor->SetEmbeddedObject(IDS_Group, *pTrusteeGroup);
			}

			// get the secure file's DACL and prepare for a walk.
			secFile.GetDACL(dacl);
			FillInstanceDACL(pSecurityDescriptor, dacl);

			// get the secure file's SACL and prepare for a walk.
			secFile.GetSACL(sacl);
			FillInstanceSACL(pSecurityDescriptor, sacl);
			pOutParams->SetEmbeddedObject(METHOD_ARG_NAME_DESCRIPTOR, *pSecurityDescriptor) ;
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE, STATUS_SUCCESS ) ;


		}	// end if
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE) ;
		}


		return WBEM_NO_ERROR ;
	}	// end if
	else
	{
		return WBEM_E_INVALID_PARAMETER ;
	}	// end if
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalFileSecuritySetting::ExecSetSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalFileSecuritySetting::ExecSetSecurityDescriptor (
	const CInstance& pInstance,
	CInstance* pInParams,
	CInstance* pOutParams,
	long lFlags
)
{

	HRESULT hr = WBEM_S_NO_ERROR ;
	DWORD dwStatus = STATUS_SUCCESS ;

	if ( pInParams && pOutParams )
	{
		hr = CheckSetSecurityDescriptor (	pInstance ,
											pInParams ,
											pOutParams ,
											dwStatus
										) ;

		if ( SUCCEEDED ( hr ) )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}

HRESULT Win32LogicalFileSecuritySetting::CheckSetSecurityDescriptor (
											const CInstance& pInstance,
											CInstance* pInParams,
											CInstance* pOutParams,
											DWORD& dwStatus
										)
{

	// takes the Win32_SecurityDescriptor object that is passed in
	// converts it to a CSecurityDescriptor/CSecureFile object
	// and applies it the the CSecureFile
	bool bExists ;
	VARTYPE eType ;
	HRESULT hr = WBEM_S_NO_ERROR ;
	dwStatus = STATUS_SUCCESS ;
	CInstancePtr pAccess;

	if ( pInParams->GetStatus ( METHOD_ARG_NAME_DESCRIPTOR , bExists , eType ) )
	{
		if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		{
			if ( eType == VT_NULL )
			{
				dwStatus = STATUS_INVALID_PARAMETER ;
				hr = WBEM_E_INVALID_PARAMETER ;
			}
			else
			{
				if (!pInParams->GetEmbeddedObject(METHOD_ARG_NAME_DESCRIPTOR , &pAccess , pInParams->GetMethodContext()))
				{
					dwStatus = STATUS_INVALID_PARAMETER ;
					hr = WBEM_E_INVALID_PARAMETER ;
				}
			}
		}
		else
		{
			dwStatus = STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		dwStatus = STATUS_INVALID_PARAMETER ;
		hr = WBEM_E_INVALID_PARAMETER ;
	}

    CInstancePtr pOwner;
    bool bOwnerSpecified = false ;
	if(SUCCEEDED(hr))
    {
	    if ( pAccess->GetStatus ( IDS_Owner , bExists , eType ) )
	    {
		    if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		    {
			    if ( eType == VT_NULL )
			    {
				    bOwnerSpecified = false ;
			    }
			    else
			    {
				    if ( pAccess->GetEmbeddedObject ( IDS_Owner , &pOwner , pAccess->GetMethodContext () ) )
				    {
					    bOwnerSpecified = true ;
				    }
				    else
				    {
					    dwStatus = STATUS_INVALID_PARAMETER ;
					    hr = WBEM_E_INVALID_PARAMETER ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = STATUS_INVALID_PARAMETER ;
			    hr =  WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = STATUS_INVALID_PARAMETER ;
		    hr =  WBEM_E_INVALID_PARAMETER ;
	    }
    }


    CInstancePtr pGroup ;
    bool bGroupSpecified = false ;
	if(SUCCEEDED(hr))
    {
	    if ( pAccess->GetStatus ( IDS_Group , bExists , eType ) )
	    {
		    if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		    {
			    if ( eType == VT_NULL )
			    {
				    bGroupSpecified = false ;
			    }
			    else
			    {
				    if ( pAccess->GetEmbeddedObject ( IDS_Group , &pGroup , pAccess->GetMethodContext () ) )
				    {
					    bGroupSpecified = true ;
				    }
				    else
				    {
					    dwStatus = STATUS_INVALID_PARAMETER ;
					    hr = WBEM_E_INVALID_PARAMETER ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = STATUS_INVALID_PARAMETER ;
		    hr = WBEM_E_INVALID_PARAMETER ;
	    }
    }


    SECURITY_DESCRIPTOR_CONTROL control;
    bool t_fDaclAutoInherited = false;
    bool t_fSaclAutoInherited = false;

    if(SUCCEEDED(hr))
    {
	    // Get the control flags...

	    if ( pAccess->GetStatus ( IDS_ControlFlags , bExists , eType ) )
	    {
		    if ( bExists &&  eType == VT_I4 )
		    {

			    if (!pAccess->GetDWORD(IDS_ControlFlags, (DWORD&)control))
			    {
				    dwStatus = STATUS_INVALID_PARAMETER ;
				    hr = WBEM_E_INVALID_PARAMETER ;
			    }
#ifdef NTONLY
#if NTONLY >= 5
                else
                {
                    if(control & SE_DACL_AUTO_INHERITED) t_fDaclAutoInherited = true;
                    if(control & SE_DACL_PROTECTED) t_fDaclAutoInherited = false; // this test comes second since this setting is supposed to override the first

                    if(control & SE_SACL_AUTO_INHERITED) t_fSaclAutoInherited = true;
                    if(control & SE_SACL_PROTECTED) t_fSaclAutoInherited = false; // this test comes second since this setting is supposed to override the first
                }
#endif
#endif
		    }
		    else
		    {
			    dwStatus = STATUS_INVALID_PARAMETER ;
			    hr =  WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = STATUS_INVALID_PARAMETER ;
		    hr =  WBEM_E_INVALID_PARAMETER ;
	    }
    }



	// Get the owner sid...
    CSid* psidOwner = NULL;
    bool fOwnerDefaulted = false;
    if(SUCCEEDED(hr))
    {
	    if(bOwnerSpecified)
	    {
            try
            {
                psidOwner = new CSid;
            }
            catch(...)
            {
                if(psidOwner != NULL)
                {
                    delete psidOwner;
                    psidOwner = NULL;
                }
                throw;
            }
            if(psidOwner != NULL)
            {
                if(FillSIDFromTrustee(pOwner, *psidOwner) == STATUS_SUCCESS)
		        {
			        fOwnerDefaulted = (control & SE_OWNER_DEFAULTED) ? true : false ;
                    if(!psidOwner->IsValid())
		            {
			            delete psidOwner;
                        dwStatus = STATUS_INVALID_PARAMETER ;
			            hr = WBEM_E_INVALID_PARAMETER ;
		            }
                }
				else
				{
                    dwStatus = STATUS_INVALID_PARAMETER;
                    hr = WBEM_E_INVALID_PARAMETER;
				}
            }
            else
            {
                dwStatus = E_FAIL ;
		        hr = WBEM_E_PROVIDER_FAILURE ;
            }
	    }
    }


    // Get the group sid...
    CSid* psidGroup = NULL;
    bool fGroupDefaulted = false;
    if(SUCCEEDED(hr))
    {
	    if(bGroupSpecified)
	    {
		    try
            {
                psidGroup = new CSid;
            }
            catch(...)
            {
                if(psidGroup != NULL)
                {
                    delete psidGroup;
                    psidGroup = NULL;
                }
                throw;
            }
            if(psidGroup != NULL)
            {
                if( FillSIDFromTrustee(pGroup, *psidGroup)  == STATUS_SUCCESS )
		        {
			        fGroupDefaulted = ( control & SE_GROUP_DEFAULTED ) ? true : false ;
			        //sid validity checked here as FillSIDFromTrustee returns success if null sid
                    if(!psidGroup->IsValid())
			        {
                        delete psidGroup;
                        dwStatus = STATUS_INVALID_PARAMETER ;
			            hr = WBEM_E_INVALID_PARAMETER ;
		            }
                }
                else
				{
                    dwStatus = STATUS_INVALID_PARAMETER;
                    hr = WBEM_E_INVALID_PARAMETER;
				}
            }
            else
            {
                dwStatus = E_FAIL ;
		        hr = WBEM_E_PROVIDER_FAILURE ;
            }
	    }
    }


    // Get the dacl...
    CDACL* pdacl = NULL;
    bool fDaclDefaulted = false;
    if(SUCCEEDED(hr))
    {
	    // Only bother with a dacl if we are going to be setting it, which is controled by the control flags specified...
        if(control & SE_DACL_PRESENT)
        {
            DWORD dwACLSize =0;
            try
            {
                pdacl = new CDACL;
            }
            catch(...)
            {
                if(pdacl != NULL)
                {
                    delete pdacl;
                    pdacl = NULL;
                }
                throw;
            }
            if(pdacl != NULL)
            {
	            if( (dwStatus = FillDACLFromInstance(pAccess, *pdacl, pAccess->GetMethodContext () ) ) != STATUS_SUCCESS )
	            {
                   if(dwStatus == STATUS_NULL_DACL)
                    {
                        // No dacl was specified - e.g., we have a NULL dacl.  Since we mimic a NULL dacl as a dacl with
                        // an Everyone ACCESS_ALLOWED entry, create that here:
                        if(!pdacl->CreateNullDACL())
                        {
                            delete pdacl;
                            pdacl = NULL;
                            dwStatus = E_FAIL ;
		                    hr = WBEM_E_PROVIDER_FAILURE ;
                        }
                    }
                    else if(dwStatus == STATUS_EMPTY_DACL)
                    {
                        pdacl->Clear(); // "creates" the empty dacl
                    }
                    else
                    {
                        delete pdacl;
                        pdacl = NULL;
                        dwStatus = STATUS_INVALID_PARAMETER ;
                        hr = WBEM_E_INVALID_PARAMETER;
                    }
                }
                if(SUCCEEDED(hr))
                {
                    fDaclDefaulted = (control & SE_DACL_DEFAULTED) ? true : false ;
                }
            }
            else
            {
                dwStatus = E_FAIL;
                hr = WBEM_E_PROVIDER_FAILURE;
            }
        }
    }


    // Create the sacl...
    CSACL* psacl = NULL;
    bool fSaclDefaulted = false;
    //bool bSaclSpecified = false;

    if(SUCCEEDED(hr))
    {
        // Only bother with a sacl if we are going to be setting it, which is controled by the control flags specified...
        if(control & SE_SACL_PRESENT)
        {
	        DWORD dwSACLSize = 0;
            try
            {
                psacl = new CSACL;
            }
            catch(...)
            {
                if(psacl != NULL)
                {
                    delete psacl;
                    psacl = NULL;
                }
                throw;
            }
            if(psacl != NULL)
            {
	            if( (dwStatus = FillSACLFromInstance(pAccess, *psacl, pAccess->GetMethodContext () ) ) == STATUS_SUCCESS )
	            {
		            if(!psacl->CalculateSACLSize( &dwSACLSize ) )
		            {
			            dwStatus = E_FAIL ;
                        hr = WBEM_E_PROVIDER_FAILURE;
		            }

                    if(SUCCEEDED(hr))
                    {
                        bool fSaclDefaulted = ( control & SE_SACL_DEFAULTED ) ? true : false ;
		                if(dwSACLSize < sizeof(ACL))
		                {
			                // If we are here, we have no SACL, so delete and set to NULL our SACL pointer...
                            delete psacl;
                            psacl = NULL;
		                }
                        else
                        {
                            //bSaclSpecified = true;
                        }
                    }
	            }
                else // Not a problem if we have no SACL, but we do need to delete the one we allocated
                {
                    if(psacl != NULL) // test just in case FillSACLFromInstance somehow deleted it
                    {
                        delete psacl;
                        psacl = NULL;
                    }
                }
            }
            else
            {
                dwStatus = E_FAIL;
                hr = WBEM_E_PROVIDER_FAILURE;
            }
        }
    }

    // Only proceed if all is well...
    if(SUCCEEDED(hr))
    {
	    CHString chsPath;
	    pInstance.GetCHString(IDS_Path, chsPath);
	    CSecureFile secFile(chsPath,
                            psidOwner,
                            fOwnerDefaulted,
                            psidGroup,
                            fGroupDefaulted,
                            pdacl,
                            fDaclDefaulted,
                            t_fDaclAutoInherited,
                            psacl,
                            fSaclDefaulted,
                            t_fSaclAutoInherited);

	    SECURITY_INFORMATION securityinfo = 0 ;
	    if(bOwnerSpecified)
	    {
		    securityinfo |= OWNER_SECURITY_INFORMATION ;
	    }
	    if(bGroupSpecified)
	    {
		    securityinfo |= GROUP_SECURITY_INFORMATION ;
	    }
	    if(control & SE_DACL_PRESENT) // if the control flag indicates that no dacl is present, that really means the user doesn't want to do anything to the dacl, not that the dacl is a NULL DACL.
	    {
            securityinfo |= DACL_SECURITY_INFORMATION ;
#if NTONLY >= 5
            if(!t_fDaclAutoInherited)
            {
                securityinfo |= PROTECTED_DACL_SECURITY_INFORMATION;
            }
            else
            {
                securityinfo |= UNPROTECTED_DACL_SECURITY_INFORMATION;
            }
#endif
	    }

	    //if(bSaclSpecified)
        if(control & SE_SACL_PRESENT)  // even if psacl is null, if the user specified that one was present, we need to say it was there, since this is the only way the user can remove a sacl (otherwise the rest of the descriptor is set, and whatever state a sacl might have been in, it stays in.
	    {
            securityinfo |= SACL_SECURITY_INFORMATION ;
#if NTONLY >= 5
            if(!t_fSaclAutoInherited)
            {
                securityinfo |= PROTECTED_SACL_SECURITY_INFORMATION;
            }
            else
            {
                securityinfo |= UNPROTECTED_SACL_SECURITY_INFORMATION;
            }
#endif
	    }

	    // Finally do all the work that everything else has been preparation for...
        dwStatus = secFile.ApplySecurity( securityinfo ) ;


	    if(dwStatus == ERROR_SUCCESS )
	    {
		    dwStatus = STATUS_SUCCESS ;
	    }

        // DON'T DO THIS! HIDES WHAT HAPPENED FOR NO GOOD REASON!
        //else
	    //{
		//    dwStatus = GetWin32ErrorToStatusCode( dwStatus ) ;
	    //}
    }

	if(psidOwner != NULL)
	{
		delete psidOwner;
        psidOwner = NULL;
	}
	if(psidGroup != NULL)
	{
		delete psidGroup;
        psidGroup = NULL;
	}
    if(pdacl != NULL)
	{
		delete pdacl;
        pdacl = NULL;
	}
    if(psacl != NULL)
	{
		delete psacl;
        psacl = NULL;
	}

    return hr ;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalFileSecuritySetting::EnumerateInstances
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalFileSecuritySetting::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

	// let the callback do the real work


    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


//if (SUCCEEDED(hr = CWbemProviderGlue::ExecQueryAsync (L"CIM_LogicalFile", this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, NULL)))
	if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQueryAsynch(L"Select Name from CIM_LogicalFile" ,  this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, NULL)))
	{
	}

#endif
#ifdef  WIN9XONLY
    hr = WBEM_E_NOT_FOUND;
#endif

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


	return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32LogicalFileSecuritySetting::EnumerationCallback(CInstance* pFile, MethodContext* pMethodContext, void* pUserData)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// Start pumping out the instances
    CInstancePtr pInstance;
    pInstance.Attach(CreateNewInstance(pMethodContext));
	if (pInstance)
	{

		CHString chsPath;
		pFile->GetCHString(IDS_Name, chsPath);

	    // Do the puts, and that's it
		if (!chsPath.IsEmpty())
		{
			CSecureFile secFile;
            DWORD dwRet = secFile.SetFileName(chsPath, TRUE);
			if (ERROR_ACCESS_DENIED != dwRet)
			{
				if (dwRet == ERROR_PRIVILEGE_NOT_HELD)
                    SetSinglePrivilegeStatusObject(pInstance->GetMethodContext(), SE_SECURITY_NAME);

                SECURITY_DESCRIPTOR_CONTROL control;
				secFile.GetControl(&control);
				pInstance->SetDWORD(IDS_ControlFlags, control);
			}	// end if
			else
			{
				hr = WBEM_S_ACCESS_DENIED;
			}
		    pInstance->SetCHString(IDS_Path, chsPath);

            if(AmIAnOwner(chsPath, SE_FILE_OBJECT)) // secutils.cpp routine
            {
                pInstance->Setbool(IDS_OwnerPermissions, true);
            }
            else
            {
                pInstance->Setbool(IDS_OwnerPermissions, false);
            }

		}	// end if

        CHString chstrTemp;

        chstrTemp.Format(L"Security settings of %s", (LPCWSTR)chsPath);
        pInstance->SetCHString(IDS_Caption, chstrTemp);
        pInstance->SetCHString(IDS_Description, chstrTemp);

		if ( SUCCEEDED ( hr ) && hr != WBEM_S_ACCESS_DENIED )
		{
		    hr = pInstance->Commit();
		}	// end if

	}	// end if
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT WINAPI Win32LogicalFileSecuritySetting::StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData)
{
	Win32LogicalFileSecuritySetting* pThis;
	HRESULT hr;

	pThis = dynamic_cast<Win32LogicalFileSecuritySetting *>(pThat);
	ASSERT_BREAK(pThis != NULL);

	if (pThis)
	{
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
	}
	else
	{
    	hr = WBEM_E_FAILED;
	}
	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalFileSecuritySetting::GetObject
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalFileSecuritySetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery )
{
//	_bstr_t bstrtDrive;
//    _bstr_t bstrtPathName;
//    WCHAR wstrTemp[_MAX_PATH];
//    WCHAR* pwc = NULL;
//    WCHAR* pwcName = NULL;
    HRESULT hr;
	CHString chstrPathName;

//    ZeroMemory(wstrTemp,sizeof(wstrTemp));


    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif



#ifdef NTONLY

	if(pInstance != NULL)
	{
		pInstance->GetCHString(IDS_Path, chstrPathName);

        CHString chstrLFDrive;
        CHString chstrLFPath;
        CHString chstrLFName;
        CHString chstrLFExt;
        bool fRoot;

        RemoveDoubleBackslashes(chstrPathName, chstrPathName);

        CSecureFile secFile;
        DWORD dwRet = secFile.SetFileName(chstrPathName, TRUE);
		if(dwRet != ERROR_ACCESS_DENIED)
		{
		    if(dwRet == ERROR_PRIVILEGE_NOT_HELD) SetSinglePrivilegeStatusObject(pInstance->GetMethodContext(), SE_SECURITY_NAME);
			SECURITY_DESCRIPTOR_CONTROL control;
			secFile.GetControl(&control);
			//pInstance->SetDWORD(IDS_ControlFlags, control);


            // Break the directory into its constituent parts
            GetPathPieces(chstrPathName, chstrLFDrive, chstrLFPath, chstrLFName, chstrLFExt);

            // Find out if we are looking for the root directory
            if(chstrLFPath==L"\\" && chstrLFName==L"" && chstrLFExt==L"")
            {
                fRoot = true;
                // If we are looking for the root, our call to EnumDirs presumes that we specify
                // that we are looking for the root directory with "" as the path, not "\\".
                // Therefore...
                chstrLFPath = L"";
            }
            else
            {
                fRoot = false;
            }

            hr = EnumDirsNT(CNTEnumParm(pInstance->GetMethodContext(),
                            chstrLFDrive,   // drive letter and colon
                            chstrLFPath,    // use the given path
                            chstrLFName,    // filename
                            chstrLFExt,     // extension
                            false,          // no recursion desired
                            NULL,           // don't need the file system name
                            NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                            fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                            (void*)control));         // don't need to use the extra parameter to pass the Control Flags we got.

        }
		else
		{
			hr = WBEM_E_ACCESS_DENIED;
		}
	}	// end if(pInstance!=NULL)

#endif
#ifdef WIN9XONLY
    hr = WBEM_E_NOT_FOUND;
#endif

	if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return(hr);

}


HRESULT Win32LogicalFileSecuritySetting::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    // Even though we are derived from cimplement_logicalfile, because the key field for this class
    // is Path, while the key for the logicalfile classes is Name, and Path for them refers to the path
    // component of the fully qualified pathname, we need to do some of the work here, then call on
    // EnumDirsNT to do the bulk of the work.

    HRESULT hr = WBEM_S_NO_ERROR;
#ifdef NTONLY
    std::vector<_bstr_t> vectorPaths;
    std::vector<CDriveInfo*> vecpDI;
    bool bRoot = false;
    bool fGotDrives = false;
    bool fNeedFS = false;
    DWORD dwPaths;
    LONG lDriveIndex;
    pQuery.GetValuesForProp(IDS_Path, vectorPaths);
    dwPaths = vectorPaths.size();



    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif



    // Determine whether certain other expensive properties are required:
    DWORD dwReqProps = PROP_NO_SPECIAL;
    DetermineReqProps(pQuery, &dwReqProps);

    // Get listing of drives and related info (only if the file system is needed):
    if(dwReqProps & PROP_FILE_SYSTEM)
    {
        GetDrivesAndFS(vecpDI, true);
        fGotDrives = true;
        fNeedFS = true;
    }

    if(dwPaths > 0)
    {


        // In this case we were given one or more fully qualified pathnames.
        // So we just need to look for those files.
        WCHAR* pwch;
        WCHAR* pwstrFS;
        // For all the specific files, get the info
        for(long x=0; x < dwPaths; x++)
        {
            CSecureFile secFile;
            DWORD dwRet = secFile.SetFileName(vectorPaths[x], TRUE);
		    if(dwRet != ERROR_ACCESS_DENIED)
		    {
		        if(dwRet == ERROR_PRIVILEGE_NOT_HELD) SetSinglePrivilegeStatusObject(pMethodContext, SE_SECURITY_NAME);
			    SECURITY_DESCRIPTOR_CONTROL control;
			    secFile.GetControl(&control);

                pwstrFS = NULL;
                // if the name contained a wildcard character, return WBEM_E_INVALID_QUERY:
                if(wcspbrk((wchar_t*)vectorPaths[x],L"?*") != NULL)
                {
                    if(fGotDrives)
                    {
                        FreeVector(vecpDI);
                    }
                    return WBEM_E_INVALID_QUERY;
                }

                pwch = NULL;
                _bstr_t bstrtTemp = vectorPaths[x];
                pwch = wcsstr((wchar_t*)bstrtTemp,L":");
                if(pwch != NULL)
                {
                    WCHAR wstrDrive[_MAX_PATH] = L"";
                    WCHAR wstrDir[_MAX_PATH] = L"";
                    WCHAR wstrFile[_MAX_PATH] = L"";
                    WCHAR wstrExt[_MAX_PATH] = L"";

                    _wsplitpath(bstrtTemp,wstrDrive,wstrDir,wstrFile,wstrExt);

                    if(fGotDrives)
                    {
                        if(!GetIndexOfDrive(wstrDrive, vecpDI, &lDriveIndex))
                        {
                            FreeVector(vecpDI);
                            return WBEM_E_NOT_FOUND;
                        }
                        else
                        {
                            pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                        }
                    }

                    // Find out if we are looking for the root directory
                    if(wcscmp(wstrDir,L"\\")==0 && wcslen(wstrFile)==0 && wcslen(wstrExt)==0)
                    {
                        bRoot = true;
                        // If we are looking for the root, our call to EnumDirs presumes that we specify
                        // that we are looking for the root directory with "" as the path, not "\\".
                        // Therefore...
                        wcscpy(wstrDir, L"");
                    }
                    else
                    {
                        bRoot = false;
                    }

                    // We should have been given the exact name of a file, with an extension.
                    // Therefore, the wstrDir now contains the path, filename, and extension.
                    // Thus, we can pass it into EnumDirsNT as the path, and an empty string
                    // as the completetionstring parameter, and still have a whole pathname
                    // for FindFirst (in EnumDirs) to work with.

                    //CInstance *pInstance = CreateNewInstance(pMethodContext);
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        wstrDrive,
                                        wstrDir,
                                        wstrFile,
                                        wstrExt,
                                        false,                 // no recursion desired
                                        NULL,             // don't need FS name
                                        NULL,             // don't need any of implement_logicalfile's props
                                        bRoot,
                                        (void*)control)); // use the extra param to pass control flags
			        }
                }
            }
        }
    }
    else  // let CIMOM handle filtering; we'll hand back everything!
    {
        EnumerateInstances(pMethodContext);
    }

    if(fGotDrives)
    {
        FreeVector(vecpDI);
    }

#endif

#ifdef WIN9XONLY
    hr = WBEM_E_NOT_FOUND;
#endif


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif



    return(hr);
}



HRESULT Win32LogicalFileSecuritySetting::FindSpecificPathNT(CInstance *pInstance,
	const WCHAR* sDrive, const WCHAR* sDir)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	WIN32_FIND_DATAW
				stFindData,
				*pfdToLoadProp;
	SmartFindClose	hFind;
	WCHAR		szFSName[_MAX_PATH] = L"";
	BOOL		bIsRoot = !wcscmp(sDir, L"\\");
	_bstr_t	bstrFullPath,
				bstrRoot;

	bstrFullPath = sDrive;
	bstrFullPath += sDir;

	bstrRoot = sDrive;
	bstrRoot += L"\\";

	// if the directory contained a wildcard character, return WBEM_E_NOT_FOUND.
	if (wcspbrk(sDir,L"?*") != NULL)
		hr = WBEM_E_NOT_FOUND;

	if (SUCCEEDED(hr))
	{
		// FindFirstW doesn't work with root dirs (since they're not real dirs.)
		if (bIsRoot)
			pfdToLoadProp = NULL;
		else
		{
			pfdToLoadProp = &stFindData;
			ZeroMemory(&stFindData, sizeof(stFindData));

			hFind = FindFirstFileW((LPCWSTR) bstrFullPath, &stFindData);
			if (hFind == INVALID_HANDLE_VALUE)
				hr =  WBEM_E_NOT_FOUND;

		}
		if (SUCCEEDED(hr))
		{
			// If GetVolumeInformationW fails, only get out if we're trying
			// to get the root.
			if (!GetVolumeInformationW(bstrRoot, NULL, 0, NULL, NULL, NULL,
				szFSName, sizeof(szFSName)/sizeof(WCHAR)) && bIsRoot)
				hr = WBEM_E_NOT_FOUND;

			if (SUCCEEDED(hr))
			{
				if (bIsRoot)
			    {
	//		        LoadPropertyValuesNT(pInstance, sDrive, sDir, szFSName, NULL);
			    }
			    else
			    {
			        // sDir contains \\path\\morepath\\filename.exe at this point, instead
			        // of just \\path\\morepath\\, so need to hack of the last part.
			        WCHAR* wstrJustPath = NULL;
                    try
                    {
                        wstrJustPath = (WCHAR*) new WCHAR[wcslen(sDir) + 1];
			            WCHAR* pwc = NULL;
			            ZeroMemory(wstrJustPath,(wcslen(sDir) + 1)*sizeof(WCHAR));
			            wcscpy(wstrJustPath,sDir);
			            pwc = wcsrchr(wstrJustPath, L'\\');
			            if(pwc != NULL)
			            {
			                *(pwc+1) = L'\0';
			            }
		    //	        LoadPropertyValuesNT(pInstance, sDrive, wstrJustPath, szFSName, pfdToLoadProp)
                    }
                    catch(...)
                    {
                        if(wstrJustPath != NULL)
                        {
                            delete wstrJustPath;
                            wstrJustPath = NULL;
                        }
                        throw;
                    }

					delete wstrJustPath;
                    wstrJustPath = NULL;
			    }
			}	// end if
		}	// end if
	}	// end if
	return WBEM_S_NO_ERROR;
}

DWORD Win32LogicalFileSecuritySetting::GetWin32ErrorToStatusCode(DWORD dwWin32Error)
{
	DWORD dwStatus ;
	switch( dwWin32Error )
	{
	case ERROR_ACCESS_DENIED:
		dwStatus = STATUS_ACCESS_DENIED ;
		break ;
	default:
		dwStatus = STATUS_UNKNOWN_FAILURE ;
		break ;
	}

	return dwStatus ;
}




/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  Overridden here
 *                to return true always.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE can get security info, FALSE otherwise.
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL Win32LogicalFileSecuritySetting::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    return TRUE;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherrited from CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the Element and Setting
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
void Win32LogicalFileSecuritySetting::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    WCHAR szBuff[_MAX_PATH * 2] = L"";
    bool bRoot = false;

    pInstance->SetDWORD(IDS_ControlFlags, (DWORD)((DWORD_PTR)pvMoreData));

    if(pstFindData == NULL)
    {
        bRoot = true;
    }
    if(!bRoot)
    {
        wsprintfW(szBuff,L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
        pInstance->SetWCHARSplat(IDS_Path, szBuff);
    }
    else
    {
        wsprintfW(szBuff,L"%s\\",pszDrive);
        pInstance->SetWCHARSplat(IDS_Path, szBuff);
    }

    CHString chstrTemp;
    chstrTemp.Format(L"Security settings of %s", szBuff);
    pInstance->SetCHString(IDS_Caption, chstrTemp);
    pInstance->SetCHString(IDS_Description, chstrTemp);

    if(AmIAnOwner(CHString(szBuff), SE_FILE_OBJECT))
    {
        pInstance->Setbool(IDS_OwnerPermissions, true);
    }
    else
    {
        pInstance->Setbool(IDS_OwnerPermissions, false);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicalsharesecuritysetting.h ===
//=================================================================

//

// Win32LogicalShareSecuritySetting.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <aclapi.h>


#ifndef __LOGSHARESECSETTING_H_
#define __LOGSHARESECSETTING_H_

#define  WIN32_LOGICAL_SHARE_SECURITY_SETTING L"Win32_LogicalShareSecuritySetting"


#define LSSS_STATUS_SUCCESS								0
#define LSSS_STATUS_NOT_SUPPORTED						1
#define LSSS_STATUS_ACCESS_DENIED						2
#define LSSS_STATUS_UNKNOWN_FAILURE						8


#define LSSS_STATUS_DESCRIPTOR_NOT_AVAILABLE			9
#define LSSS_STATUS_INVALID_PARAMETER					21



#define METHOD_ARG_NAME_DESCRIPTOR					L"Descriptor"
#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"


typedef DWORD ( WINAPI *PFN_GETNAMEDSECURITYINFOW )(
				LPWSTR                 pObjectName,
                SE_OBJECT_TYPE         ObjectType,
                SECURITY_INFORMATION   SecurityInfo,
                PSID                 * ppsidOowner,
                PSID                 * ppsidGroup,
                PACL                 * ppDacl,
                PACL                 * ppSacl,
                PSECURITY_DESCRIPTOR * ppSecurityDescriptor );



class Win32LogicalShareSecuritySetting : public Provider
{
protected:
public:
	Win32LogicalShareSecuritySetting (LPCWSTR setName, LPCWSTR pszNameSpace =NULL);
	~Win32LogicalShareSecuritySetting ();

	HRESULT ExecMethod 
	(
		const CInstance& a_Instance, 
		const BSTR a_MethodName, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags = 0L
	);

	HRESULT ExecGetSecurityDescriptor 
	(
		const CInstance& pInstance, 
		CInstance* pInParams, 
		CInstance* pOutParams, 
		long lFlags
	);

	HRESULT ExecSetSecurityDescriptor 
	(
		const CInstance& pInstance, 
		CInstance* pInParams, 
		CInstance* pOutParams, 
		long lFlags
	);

HRESULT Win32LogicalShareSecuritySetting::CheckSetSecurityDescriptor (const CInstance& pInstance, CInstance* pInParams, CInstance* pOutParams, DWORD& dwStatus ) ;


	HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);
	HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

#ifdef NTONLY
	
	HRESULT EnumerationCallback(CInstance* pShare, MethodContext* pMethodContext, void* pUserData);
	static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData);
	//DWORD GetStatusCode(DWORD dwError) ;
	//DWORD GetWin32ErrorToStatusCode(DWORD dwWin32Error) ;
	bool GetArray(IWbemClassObject *piClassObject, const CHString& name,  VARIANT& strArray, VARTYPE eVariantType) const ;

#endif

};	// end class Win32LogicalShareSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32mappedlogicaldisk.cpp ===
//=================================================================

//

// MappedLogicalDisk.CPP -- Logical Disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    4/15/00    khughes        Created
//
//=================================================================


#include "precomp.h"
#include <map>
#include <vector>
#include <comdef.h>
#include "chstring.h"
#include "session.h"
#include <frqueryex.h>

#include "Win32MappedLogicalDisk.h"
#include <objbase.h>
#include <comdef.h>
#include <ntsecapi.h>

#include <vector>
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include <Sid.h>

#include <DskQuota.h>
#include <smartptr.h>
#include <ntioapi.h>
#include <CMDH.h>


// Property set declaration
//=========================
MappedLogicalDisk MyLogicalDiskSet ( PROPSET_NAME_MAPLOGDISK , IDS_CimWin32Namespace ) ;



/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::LogicalDisk
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
MappedLogicalDisk :: MappedLogicalDisk (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
    m_ptrProperties.SetSize(24);

    m_ptrProperties[0] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[1] = ((LPVOID) IDS_ProviderName);
    m_ptrProperties[2] = ((LPVOID) IDS_VolumeName);
    m_ptrProperties[3] = ((LPVOID) IDS_FileSystem);
    m_ptrProperties[4] = ((LPVOID) IDS_VolumeSerialNumber);
    m_ptrProperties[5] = ((LPVOID) IDS_Compressed);
    m_ptrProperties[6] = ((LPVOID) IDS_SupportsFileBasedCompression);
    m_ptrProperties[7] = ((LPVOID) IDS_MaximumComponentLength);
    m_ptrProperties[8] = ((LPVOID) IDS_SupportsDiskQuotas);
    m_ptrProperties[9] = ((LPVOID) IDS_QuotasIncomplete);
    m_ptrProperties[10] = ((LPVOID) IDS_QuotasRebuilding);
    m_ptrProperties[11] = ((LPVOID) IDS_QuotasDisabled);
    m_ptrProperties[12] = ((LPVOID) IDS_VolumeDirty);
    m_ptrProperties[13] = ((LPVOID) IDS_FreeSpace);
    m_ptrProperties[14] = ((LPVOID) IDS_Size);

    m_ptrProperties[15] = ((LPVOID) IDS_Name);
    m_ptrProperties[16] = ((LPVOID) IDS_Caption);
    m_ptrProperties[17] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[18] = ((LPVOID) IDS_SessionID);
    m_ptrProperties[19] = ((LPVOID) IDS_Description);
    m_ptrProperties[20] = ((LPVOID) IDS_DriveType);
    m_ptrProperties[21] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[22] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[23] = ((LPVOID) IDS_MediaType);
}

/*****************************************************************************
 *
 *  FUNCTION    : MappedLogicalDisk::~MappedLogicalDisk
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

MappedLogicalDisk :: ~MappedLogicalDisk ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : MappedLogicalDisk::ExecQuery
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
#if NTONLY == 5
HRESULT MappedLogicalDisk::ExecQuery(
	MethodContext *pMethodContext,
	CFrameworkQuery &pQuery,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwNumDeviceIDs = 0L;
    DWORD dwNumSessionIDs = 0L;

    // Use the extended query type

    std::vector<int> vectorValues;
    DWORD dwTypeSize = 0;

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);

    // Find out what properties they asked for
    DWORD dwReqProps = 0;
    pQuery2->GetPropertyBitMask(
        m_ptrProperties, 
        &dwReqProps);

    CHStringArray rgchstrDeviceIDs;
    pQuery.GetValuesForProp(
        IDS_DeviceID, 
        rgchstrDeviceIDs);

    CHStringArray rgchstrSessionIDs;
    pQuery.GetValuesForProp(
        IDS_SessionID, 
        rgchstrSessionIDs);

    dwNumDeviceIDs = rgchstrDeviceIDs.GetSize();
    dwNumSessionIDs = rgchstrSessionIDs.GetSize();

    // Get the set of sessions.
    CUserSessionCollection usc;


    // Case 1: One or more sessions specified, no drives specified.
    // Enumerate all drives for each session.
    if(dwNumSessionIDs > 0 && 
       dwNumDeviceIDs == 0)
    {
        HRESULT hrTmp = WBEM_S_NO_ERROR;
                
        for(long m = 0;
            m < dwNumSessionIDs && SUCCEEDED(hr);
            m++)
        {
            __int64 i64SessionID = _wtoi64(rgchstrSessionIDs[m]);
            SmartDelete<CSession> sesPtr;
            sesPtr = usc.FindSession(i64SessionID);
            
            if(sesPtr)
            {
                // Get all of its mapped drives...
                // GetImpProcPID() specifies the
                // processid who's view of drive
                // mappings we want to report on.
                hrTmp = GetAllMappedDrives(
                    pMethodContext,
                    i64SessionID,
                    sesPtr->GetImpProcPID(),
                    dwReqProps);
        
                (hrTmp == WBEM_E_NOT_FOUND) ? 
                    hr = WBEM_S_PARTIAL_RESULTS :
                    hr = hrTmp; 
            }  
        }
    }
    // Case 2: No sessions specified, one or more drives specified.
    // Get specified drives for all sessions.
    else if(dwNumSessionIDs == 0 && 
       dwNumDeviceIDs > 0)
    {
        HRESULT hrTmp = WBEM_S_NO_ERROR;
        SmartDelete<CSession> sesPtr;
        USER_SESSION_ITERATOR sesIter;

        sesPtr = usc.GetFirstSession(sesIter);
        while(sesPtr)
        {
            {   // <-- Keep this brace! Need hCurImpTok to revert
                // for each iteration of the while loop, but we
                // want to keep the same impersonation for all 
                // iterations of the for loop.

                __int64 i64SessionID = sesPtr->GetLUIDint64();

                for(long m = 0;
                    m < dwNumDeviceIDs && SUCCEEDED(hr);
                    m++)
                {
                    // GetImpProcPID() specifies the
                    // processid who's view of drive
                    // mappings we want to report on.
                    hrTmp = GetSingleMappedDrive(
                        pMethodContext,
                        i64SessionID,
                        sesPtr->GetImpProcPID(),
                        rgchstrDeviceIDs[m],
                        dwReqProps);
        
                    (hrTmp == WBEM_E_NOT_FOUND) ? 
                        hr = WBEM_S_PARTIAL_RESULTS :
                        hr = hrTmp;
                }
            }
            // Get the next session...
            sesPtr = usc.GetNextSession(sesIter);
        }
    }
    // Case 3: Sessions and drives specified.
    else if(dwNumSessionIDs > 0 &&
        dwNumDeviceIDs > 0)
    {
        HRESULT hrTmp = WBEM_S_NO_ERROR;
                
        for(long m = 0;
            m < dwNumSessionIDs && SUCCEEDED(hr);
            m++)
        {
            __int64 i64SessionID = _wtoi64(rgchstrSessionIDs[m]);
            SmartDelete<CSession> sesPtr;
            sesPtr = usc.FindSession(i64SessionID);
            
            if(sesPtr)
            {
                // Get the specified mapped drives...
                for(long m = 0;
                    m < dwNumDeviceIDs && SUCCEEDED(hr);
                    m++)
                {
                    // The drives were specified in
                    // the query as .DeviceID="x:", but
                    // we look for them as "x:\", so convert...
                    CHString chstrTmp = rgchstrDeviceIDs[m];
                    chstrTmp += L"\\";

                    // GetImpProcPID() specifies the
                    // processid who's view of drive
                    // mappings we want to report on.
                    hrTmp = GetSingleMappedDrive(
                        pMethodContext,
                        i64SessionID,
                        sesPtr->GetImpProcPID(),
                        chstrTmp,
                        dwReqProps);
        
                    (hrTmp == WBEM_E_NOT_FOUND) ? 
                        hr = WBEM_S_PARTIAL_RESULTS :
                        hr = hrTmp;
                }
            }
        }    
    }
    // Case 4: We will return all instances;, get
    // data for all drives at once, for every session...
    else
    {
        HRESULT hrTmp = WBEM_S_NO_ERROR;
        SmartDelete<CSession> sesPtr;
        USER_SESSION_ITERATOR sesIter;

        sesPtr = usc.GetFirstSession(sesIter);
        while(sesPtr && SUCCEEDED(hr))
        {
            __int64 i64SessionID = sesPtr->GetLUIDint64();

            // Get all of its mapped drives...
            // GetImpProcPID() specifies the
            // processid who's view of drive
            // mappings we want to report on.
            hrTmp = GetAllMappedDrives(
                pMethodContext,
                i64SessionID,
                sesPtr->GetImpProcPID(),
                dwReqProps);

            (hrTmp == WBEM_E_NOT_FOUND) ? 
                        hr = WBEM_S_PARTIAL_RESULTS :
                        hr = hrTmp;
            
            // Get the next session...
            sesPtr = usc.GetNextSession(sesIter);
        }
    }

    return hr;
}
#endif
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#if NTONLY == 5
HRESULT MappedLogicalDisk::GetObject(
	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery &pQuery)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chstrDeviceID;
    CHString chstrSessionID;
    DWORD dwReqProps = 0;

    // Find out what properties they asked for
    
    CFrameworkQueryEx *pQuery2 = 
        static_cast <CFrameworkQueryEx *>(&pQuery);
    pQuery2->GetPropertyBitMask(
        m_ptrProperties, 
        &dwReqProps);
	
    pInstance->GetCHString(
        IDS_DeviceID, 
        chstrDeviceID);

    pInstance->GetCHString(
        IDS_SessionID, 
        chstrSessionID);

    __int64 i64SessionID = _wtoi64(chstrSessionID);

    // Get the set of sessions.
    CUserSessionCollection usc;
    SmartDelete<CSession> sesPtr;

    sesPtr = usc.FindSession(i64SessionID);
    if(sesPtr)
    {
        MethodContext* pMethodContext = pInstance->GetMethodContext();
        SmartRevertTokenHANDLE hCurImpTok;

        // GetImpProcPID() specifies the
        // processid who's view of drive
        // mappings we want to report on.
        hr = GetSingleMappedDrive(
            pMethodContext,
            i64SessionID,
            sesPtr->GetImpProcPID(),
            chstrDeviceID,
            dwReqProps);
    }

    return hr ;
}
#endif
/*****************************************************************************
 *
 *  FUNCTION    : MappedLogicalDisk::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#if NTONLY == 5
HRESULT MappedLogicalDisk::EnumerateInstances(
	MethodContext* pMethodContext,
	long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Get the set of sessions.
    CUserSessionCollection usc;
    USER_SESSION_ITERATOR sesIter;
    SmartDelete<CSession> sesPtr;

    sesPtr = usc.GetFirstSession(sesIter);
    while(sesPtr)
    {
        __int64 i64SessionID = sesPtr->GetLUIDint64();

        // GetImpProcPID() specifies the
        // processid who's view of drive
        // mappings we want to report on.
        GetAllMappedDrives(
            pMethodContext,
            i64SessionID,
            sesPtr->GetImpProcPID(),
            0xFFFFFFFF);  // request all properties
        
        // Get next session...
        sesPtr = usc.GetNextSession(sesIter);
    }

    return hr;
}
#endif


#if NTONLY == 5
HRESULT MappedLogicalDisk::GetAllMappedDrives(
    MethodContext *pMethodContext,
    __int64 i64SessionID,
    DWORD dwPID,
    DWORD dwReqProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _variant_t v;
    bool fArrayIsGood = false;
    long lNumDrives = 0L;

    // Get the drive info...
    CMDH cmdh(dwPID);
    hr = cmdh.GetMDData(
        dwReqProps,
        &v);

    if(SUCCEEDED(hr))
    {
        fArrayIsGood = IsArrayValid(&v);    
    }

    if(SUCCEEDED(hr) && 
        fArrayIsGood)
    {
        // How many drives?  The array we are
        // working with has the different drives
        // in the first dimension (index 0) (think of 
        // that as columns in a table), and the 
        // properties of each drive in the second 
        // (index 1) dimension (think of that as rows
        // in a table).
        hr = ::SafeArrayGetUBound(
            V_ARRAY(&v),
            2,  // most significant dim contains drives
            &lNumDrives);
        
        if(SUCCEEDED(hr))
        {
            // If we have just one drive, the ubound
            // of the array will be 0 (the same as
            // the lbound).  True, we can't distinguish
            // this from no drives - that is why we
            // rely on the component to have set the 
            // variant to VT_EMPTY if we have no data.
            // That check was done in IsArrayValid.
            lNumDrives++;
        }            
    }

    if(SUCCEEDED(hr) &&
        fArrayIsGood &&
        lNumDrives > 0)
    {
        // Go through the drives extracting
        // the properties from the safearray,
        // placing them into a new CInstance,
        // and committing the instances...    
        for(long m = 0L;
            m < lNumDrives && SUCCEEDED(hr);
            m++)
        {
            hr = ProcessInstance(
                m,  // index of drive we are working with
                i64SessionID,
                V_ARRAY(&v),
                pMethodContext,
                dwReqProps);
        }
    }

    return hr;
}
#endif



#if NTONLY == 5
HRESULT MappedLogicalDisk::GetSingleMappedDrive(
    MethodContext *pMethodContext,
    __int64 i64SessionID,
    DWORD dwPID,
    CHString& chstrDeviceID,
    DWORD dwReqProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _variant_t v;
    bool fArrayIsGood = false;
    long lNumDrives = 0L;

    CMDH cmdh(dwPID);
    hr = cmdh.GetOneMDData(
        _bstr_t((LPCWSTR) chstrDeviceID),
        dwReqProps,
        &v);

    if(SUCCEEDED(hr))
    {
        fArrayIsGood = IsArrayValid(&v);    
    }

    if(SUCCEEDED(hr) && 
        fArrayIsGood)
    {
        // How many drives?  The array we are
        // working with has the different drives
        // in the first dimension (index 0) (think of 
        // that as columns in a table), and the 
        // properties of each drive in the second 
        // (index 1) dimension (think of that as rows
        // in a table).
        hr = ::SafeArrayGetUBound(
            V_ARRAY(&v),
            2,  // first dimension
            &lNumDrives);
        
        if(SUCCEEDED(hr))
        {
            // If we have just one drive, the ubound
            // of the array will be 0 (the same as
            // the lbound).  True, we can't distinguish
            // this from no drives - that is why we
            // rely on the component to have set the 
            // variant to VT_EMPTY if we have no data.
            // That check was done in IsArrayValid.
            //
            // In this case, if we have more than
            // one drive, we have an error, since
            // GetOneMDData should have only returned
            // a table with one column.
            if(lNumDrives == 0) fArrayIsGood = true;
        }            
    }

    if(SUCCEEDED(hr) &&
        fArrayIsGood)
    {
        // For the one drive we are examining, 
        // extract the properties from the 
        // safearray,place them into a new 
        // CInstance, and commit the instance...    
        hr = ProcessInstance(
            0,  // index of drive we are working with
            i64SessionID,
            V_ARRAY(&v),
            pMethodContext,
            dwReqProps);
    }

    if(!fArrayIsGood)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}
#endif



#if NTONLY == 5
bool MappedLogicalDisk::IsArrayValid(
    VARIANT* v)
{
    bool fArrayIsGood = false;
    long lNumProps = 0L;

    // Proceed if the array is not empty...
    if(V_VT(v) != VT_NULL &&
       V_VT(v) != VT_EMPTY &&
       V_VT(v) == (VT_ARRAY | VT_BSTR))
    {
        // Confirm that the array has
        // two dimensions...
        if(::SafeArrayGetDim(V_ARRAY(v)) == 2)
        {
            // Make sure the array has the
            // right number of properties
            // (second dimension - see comment
            // below).
            HRESULT hr = S_OK;
            hr = ::SafeArrayGetUBound(
                V_ARRAY(v),
                1,  // second dimension
                &lNumProps);
            if(SUCCEEDED(hr) &&
                lNumProps == PROP_COUNT - 1)
            {
                fArrayIsGood = true;
            }
        }
    }

    return fArrayIsGood;
}
#endif



#if NTONLY == 5
HRESULT MappedLogicalDisk::ProcessInstance(
    long lDriveIndex,
    __int64 i64SessionID,
    SAFEARRAY* psa,
    MethodContext* pMethodContext,
    DWORD dwReqProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BSTR bstrProp = NULL;

    long ix[2];
    ix[1] = lDriveIndex;

    CInstancePtr pInstance(
        CreateNewInstance(
            pMethodContext), 
            false);

    // Set fixed properties...
    pInstance->SetDWORD(
        IDS_DriveType, 
        DRIVE_REMOTE);

    pInstance->SetWCHARSplat(
        IDS_SystemCreationClassName, 
        L"Win32_ComputerSystem");

    pInstance->SetCHString(
        IDS_SystemName, 
        GetLocalComputerName());
        
    try
    {
        // Set DeviceID and those using its value...
        {
            ix[0] = PROP_DEVICEID;
            hr = ::SafeArrayGetElement(
                psa,
                ix,
                &bstrProp);

            if(SUCCEEDED(hr))
            {
                // Set device id and other properties
                // that use this value...
                CHString chstrTmp((LPCWSTR)bstrProp);
                ::SysFreeString(bstrProp);
				bstrProp = NULL;

                chstrTmp = chstrTmp.SpanExcluding(L"\\");

                pInstance->SetCHString(
                    IDS_Name, 
                    chstrTmp);

		        pInstance->SetCHString(
                    IDS_Caption, 
                    chstrTmp);

		        pInstance->SetCHString(
                    IDS_DeviceID, 
                    chstrTmp);
            }
        }

        // Set the session id...
        {
		    WCHAR wstrBuff[MAXI64TOA];

            _i64tow(
                i64SessionID, 
                wstrBuff, 
                10);

            pInstance->SetWCHARSplat(
                IDS_SessionID, 
                wstrBuff);
        }
    
        // Set the provider name, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_PROVIDER_NAME)
            {
                ix[0] = PROP_PROVIDER_NAME;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetCHString(
                        IDS_ProviderName, 
                        (LPCWSTR) bstrProp);

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }      

        // Set the volume name, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_VOLUME_NAME)
            {
                ix[0] = PROP_VOLUME_NAME;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetCHString(
                        IDS_VolumeName, 
                        (LPCWSTR) bstrProp);

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the file system, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_FILE_SYSTEM)
            {
                ix[0] = PROP_FILE_SYSTEM;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetCHString(
                        IDS_FileSystem, 
                        (LPCWSTR) bstrProp);

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the volume serial number, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_VOLUME_SERIAL_NUMBER)
            {
                ix[0] = PROP_VOLUME_SERIAL_NUMBER;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetCHString(
                        IDS_VolumeSerialNumber, 
                        (LPCWSTR) bstrProp);

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the compressed prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_COMPRESSED)
            {
                ix[0] = PROP_COMPRESSED;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_Compressed, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the sup file based comp prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_SUPPORTS_FILE_BASED_COMPRESSION)
            {
                ix[0] = PROP_SUPPORTS_FILE_BASED_COMPRESSION;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_SupportsFileBasedCompression, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the max comp length prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_MAXIMUM_COMPONENT_LENGTH)
            {
                ix[0] = PROP_MAXIMUM_COMPONENT_LENGTH;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetDWORD(
                        IDS_MaximumComponentLength, 
                        DWORD_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the supports disk quotas prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_SUPPORTS_DISK_QUOTAS)
            {
                ix[0] = PROP_SUPPORTS_DISK_QUOTAS;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_SupportsDiskQuotas, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the quotas incomplete prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_QUOTAS_INCOMPLETE)
            {
                ix[0] = PROP_QUOTAS_INCOMPLETE;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_QuotasIncomplete, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the quotas rebuilding prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_QUOTAS_REBUILDING)
            {
                ix[0] = PROP_QUOTAS_REBUILDING;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_QuotasRebuilding, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the quotas disabled prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_QUOTAS_DISABLED)
            {
                ix[0] = PROP_QUOTAS_DISABLED;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_QuotasDisabled, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the perform autocheck prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_PERFORM_AUTOCHECK)
            {
                ix[0] = PROP_PERFORM_AUTOCHECK;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_VolumeDirty, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the freespace prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_FREE_SPACE)
            {
                ix[0] = PROP_FREE_SPACE;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetWBEMINT64(
                        IDS_FreeSpace, 
                        _wtoi64(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the size prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_SIZE)
            {
                ix[0] = PROP_SIZE;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetWBEMINT64(
                        IDS_Size, 
                        _wtoi64(bstrProp));
                }
            }
        }
    }
    catch(...)
    {
        if(bstrProp != NULL)
        {
            ::SysFreeString(bstrProp);
            bstrProp = NULL;
        }
        throw;
    }

    if(bstrProp != NULL)
    {
        ::SysFreeString(bstrProp);
        bstrProp = NULL;
    }
    // Commit ourselves...
    if(SUCCEEDED(hr))
    {
        hr = pInstance->Commit();
    }    

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicalfilesecuritysetting.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//
//	Win32LogicalFileSecuritySetting
//
//////////////////////////////////////////////////////
#ifndef __LOGFILESECSETTING_H_
#define __LOGFILESECSETTING_H_

#undef  STATUS_SUCCESS								
#define STATUS_SUCCESS								0
#undef  STATUS_ACCESS_DENIED					
#define STATUS_ACCESS_DENIED						2

#define STATUS_UNKNOWN_FAILURE						8
#undef  STATUS_PRIVILEGE_NOT_HELD				
#define STATUS_PRIVILEGE_NOT_HELD					9

#undef  STATUS_INVALID_PARAMETER					
#define STATUS_INVALID_PARAMETER					21


#define METHOD_ARG_NAME_DESCRIPTOR					_T("Descriptor")
#define METHOD_ARG_NAME_RETURNVALUE					_T("ReturnValue")


#define  WIN32_LOGICAL_FILE_SECURITY_SETTING L"Win32_LogicalFileSecuritySetting"


#include "implement_logicalfile.h"


class Win32LogicalFileSecuritySetting : public CImplement_LogicalFile
{
    private:
    protected:



#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual void LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive,
                                          const WCHAR* pszPath,
                                          const WCHAR* pszFSName,
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

        virtual HRESULT ExecQuery(MethodContext* pMethodContext,
                                  CFrameworkQuery& pQuery,
                                  long lFlags = 0L);

        virtual HRESULT DeleteInstance(
            const CInstance& newInstance, 
            long lFlags = 0L) { return WBEM_E_PROVIDER_NOT_CAPABLE; }

    public:
	    Win32LogicalFileSecuritySetting (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	    ~Win32LogicalFileSecuritySetting ();

	    HRESULT ExecMethod
	    (
		    const CInstance& a_Instance,
		    const BSTR a_MethodName,
		    CInstance *a_InParams,
		    CInstance *a_OutParams,
		    long lFlags = 0L
	    );

	    HRESULT ExecGetSecurityDescriptor
	    (
		    const CInstance& pInstance,
		    CInstance* pInParams,
		    CInstance* pOutParams,
		    long lFlags
	    );

	    HRESULT ExecSetSecurityDescriptor
	    (
		    const CInstance& pInstance,
		    CInstance* pInParams,
		    CInstance* pOutParams,
		    long lFlags
	    );

	    HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);
	    HRESULT GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery );
	    HRESULT FindSpecificPathNT(CInstance *pInstance, const WCHAR* sDrive, const WCHAR* sDir);
	    HRESULT EnumerationCallback(CInstance* pFile, MethodContext* pMethodContext, void* pUserData);
	    static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData);
	
	    DWORD Win32LogicalFileSecuritySetting::GetWin32ErrorToStatusCode(DWORD dwWin32Error) ;
	    HRESULT Win32LogicalFileSecuritySetting::CheckSetSecurityDescriptor (	
											    const CInstance& pInstance,
											    CInstance* pInParams,
											    CInstance* pOutParams,
											    DWORD& dwStatus
										    ) ;
	
};	// end class Win32LogicalFileSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32mappedlogicaldisk.h ===
//=================================================================

//

// MappedLogicalDisk.h -- Logical disk property set provider

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// Revisions:    04/12/00    khughes        Created
//
//=================================================================

#pragma once





_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

#define bool_FROM_STR(x) ( (_wcsicmp(x,L"TRUE")==0) ? true : false )
#define DWORD_FROM_STR(x) ( wcstoul(x,NULL,10) )


#define  PROPSET_NAME_MAPLOGDISK  L"Win32_MappedLogicalDisk"

class MappedLogicalDisk : public Provider
{
public:

    // Constructor/destructor
    //=======================

    MappedLogicalDisk(
        LPCWSTR name, 
        LPCWSTR pszNamespace);

   ~MappedLogicalDisk() ;


#if NTONLY == 5
    // Functions provide properties with current values
    //=================================================

	virtual HRESULT GetObject(
        CInstance* pInstance, 
        long lFlags, 
        CFrameworkQuery &pQuery);

	virtual HRESULT EnumerateInstances(
        MethodContext*  pMethodContext, 
        long lFlags = 0L);

	virtual HRESULT ExecQuery(
        MethodContext *pMethodContext, 
        CFrameworkQuery& pQuery, 
        long lFlags /*= 0L*/ );





private:

    HRESULT GetAllMappedDrives(
        MethodContext* pMethodContext,
         __int64 i44SessionID,
        DWORD dwPID,
        DWORD dwReqProps);

    HRESULT GetSingleMappedDrive(
        MethodContext* pMethodContext,
        __int64 i44SessionID,
        DWORD dwPID,
        CHString& chstrDeviceID,
        DWORD dwReqProps);

    HRESULT ProcessInstance(
        long lDriveIndex,
        __int64 i64SessionID,
        SAFEARRAY* psa,
        MethodContext* pMethodContext,
        DWORD dwReqProps);

    bool IsArrayValid(
        VARIANT* v);

#endif
    CHPtrArray m_ptrProperties;


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicalsharesecuritysetting.cpp ===
//

//	Win32logicalFileSecSetting.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>

#include "sid.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "win32logicalsharesecuritysetting.h"

#include <windef.h>
#include <lmcons.h>
#include <lmshare.h>
#include "wbemnetapi32.h"
#include "secureshare.h"
#include "SecUtils.h"

/*
	DEFENITION FROM THE MOF
    [Dynamic, Provider ("secrcw32") , Description("security settings for a logical file")]
class Win32_LogicalShareSecuritySetting : Win32_SecuritySetting
{
    	[key]
    string Name;

        [implemented, description("Retrieves a structural representation of the object's "
         "security descriptor")]
    uint32 GetSecurityDescriptor([out] Win32_SecurityDescriptor Descriptor);

        [implemented, description("Sets security descriptor to the specified structure")]
    uint32 SetSecurityDescriptor([in] Win32_SecurityDescriptor Descriptor);
};
*/


Win32LogicalShareSecuritySetting LogicalShareSecuritySetting( WIN32_LOGICAL_SHARE_SECURITY_SETTING, IDS_CimWin32Namespace );

Win32LogicalShareSecuritySetting::Win32LogicalShareSecuritySetting(LPCWSTR setName, LPCWSTR pszNameSpace /*=NULL*/ )
: Provider (setName, pszNameSpace)
{
}

Win32LogicalShareSecuritySetting::~Win32LogicalShareSecuritySetting()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalShareSecuritySetting::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32LogicalShareSecuritySetting::ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/)
{
	//this is supposed to be called only on NT
#ifdef WIN9XONLY
	{
		return WBEM_E_INVALID_OPERATION ;
	}
#endif

#ifdef NTONLY
	HRESULT hr = WBEM_NO_ERROR;
	// Do we recognize the method?

	if (_wcsicmp(bstrMethodName, L"GetSecurityDescriptor") == 0)
	{
		hr = ExecGetSecurityDescriptor(pInstance, pInParams, pOutParams, lFlags);
   	}
   	else if (_wcsicmp(bstrMethodName, L"SetSecurityDescriptor") == 0)
   	{
   		// actually sets the security descriptor on the object by
		// taking the properties out of the Win32_SecurityDescriptor
		// and turning them into a CSecurityDescriptor object to apply
		// to the secure file.
   		hr = ExecSetSecurityDescriptor(pInstance, pInParams, pOutParams, lFlags);
   	}
	else
   	{
    	hr = WBEM_E_INVALID_METHOD;
	}

	return hr;
#endif
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalShareSecuritySetting::ExecGetSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::ExecGetSecurityDescriptor (
	const CInstance& pInstance,
	CInstance* pInParams,
	CInstance* pOutParams,
	long lFlags
)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	CAdvApi32Api *t_pAdvApi32 = NULL;
	SHARE_INFO_502 *pShareInfo502 = NULL ;
	PSECURITY_DESCRIPTOR pSD = NULL ;
	CNetAPI32 NetAPI ;

	try
	{
		// converts the security descriptor from the file into a
		// Win32_Security object.
		if (pOutParams)
		{
			CHString chsShareName;
			CSid sidOwner;
			CSid sidGroup;
			CDACL dacl;
			CSACL sacl;
			CInstancePtr pTrusteeOwner;
			CInstancePtr pTrusteeGroup;
			CInstancePtr pSecurityDescriptor;
			SECURITY_DESCRIPTOR_CONTROL control;

			t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
			DWORD dwStatusCode = LSSS_STATUS_UNKNOWN_FAILURE ;

			pInstance.GetCHString(IDS_Name, chsShareName);

			DWORD dwVer = GetPlatformMajorVersion() ;

			if( dwVer >= 4 )
			{
				PACL pDacl = NULL ;
				if ( t_pAdvApi32 != NULL )
				{
					 _bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;

					 t_pAdvApi32->GetNamedSecurityInfoW(
																bstrName ,
																SE_LMSHARE,
																DACL_SECURITY_INFORMATION,
																NULL,
																NULL,
																&pDacl,
																NULL,
																&pSD, &dwStatusCode
															) ;
				}
			}
			else
			{
				_bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;
				if( ( dwStatusCode = NetAPI.Init() ) == ERROR_SUCCESS )
				{
					dwStatusCode = NetAPI.NetShareGetInfo(	NULL,
											(LPTSTR) bstrName,
											502,
											(LPBYTE *) &pShareInfo502)  ;
				}
			}

			if( dwStatusCode == NERR_Success || dwStatusCode == ERROR_SUCCESS )
			{
			   //Sec. Desc. is not returned for IPC$ ,C$ ...shares for Admin purposes
				if( !pSD && ( !pShareInfo502 || pShareInfo502->shi502_security_descriptor == NULL ) )
				{
					pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , LSSS_STATUS_DESCRIPTOR_NOT_AVAILABLE ) ;
				}
				else
				{
					if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_SecurityDescriptor", &pSecurityDescriptor, GetNamespace())))
					{
						CSecureShare SecShare(pSD ? pSD : pShareInfo502->shi502_security_descriptor) ;
						SecShare.GetControl(&control);
						pSecurityDescriptor->SetDWORD(IDS_ControlFlags, control);

						// get the secure file's owner to create the Owner Trustee
						SecShare.GetOwner(sidOwner);

						if ( sidOwner.IsValid() && SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_Trustee", &pTrusteeOwner, GetNamespace())))
						{
							FillTrusteeFromSid(pTrusteeOwner, sidOwner);
							pSecurityDescriptor->SetEmbeddedObject(IDS_Owner, *pTrusteeOwner);
						}

						// get the secure file's group to create the Group Trustee
						SecShare.GetGroup(sidGroup);
		  				if ( sidGroup.IsValid() && SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_Trustee", &pTrusteeGroup, GetNamespace())))
						{
							FillTrusteeFromSid(pTrusteeGroup, sidGroup);
							pSecurityDescriptor->SetEmbeddedObject(IDS_Group, *pTrusteeGroup);
						}

						// get the secure file's DACL and prepare for a walk.
						SecShare.GetDACL(dacl);
						FillInstanceDACL(pSecurityDescriptor, dacl);

						// get the secure file's SACL and prepare for a walk.
						SecShare.GetSACL(sacl);
						FillInstanceSACL(pSecurityDescriptor, sacl);

						//			pOutParams = pSecurityDescriptor;
						pOutParams->SetEmbeddedObject(METHOD_ARG_NAME_DESCRIPTOR, *pSecurityDescriptor) ;

						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE, LSSS_STATUS_SUCCESS ) ;

						//remove this line
	//					ExecSetSecurityDescriptor (pInstance,pSecurityDescriptor,pOutParams,0) ;

					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , LSSS_STATUS_UNKNOWN_FAILURE) ;
					}

				}
		   }
		   else //NetAPI.NetShareGetInfo call failed
		   {
				//dwStatusCode = GetStatusCode(dwStatusCode) ;
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatusCode ) ;
		   }
		} //if (pOutParams)
		else
		{
			return WBEM_E_INVALID_PARAMETER ;

		}	// end if
	}
	catch ( ... )
	{
		if(t_pAdvApi32 != NULL)
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
			t_pAdvApi32 = NULL;
		}

		if ( pShareInfo502 )
		{
			NetAPI.NetApiBufferFree(pShareInfo502);
			pShareInfo502 = NULL ;
		}
		if ( pSD )
		{
			LocalFree ( pSD ) ;
			pSD = NULL ;
		}
		throw ;
		return WBEM_E_FAILED; // To get rid of 64-bit compilation warnings
	}

	if(t_pAdvApi32 != NULL)
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
		t_pAdvApi32 = NULL;
	}

	if ( pShareInfo502 )
	{
		NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
		pShareInfo502 = NULL ;
	}
	if ( pSD )
	{
		LocalFree ( pSD ) ;
		pSD = NULL ;
	}


	 return WBEM_NO_ERROR ;
}
#endif

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalShareSecuritySetting::ExecSetSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::ExecSetSecurityDescriptor (
	const CInstance& pInstance,
	CInstance* pInParams,
	CInstance* pOutParams,
	long lFlags
)
{

	HRESULT hr = WBEM_S_NO_ERROR ;
	DWORD dwStatus = LSSS_STATUS_SUCCESS ;

	if ( pInParams && pOutParams )
	{
		hr = CheckSetSecurityDescriptor (	pInstance ,
											pInParams ,
											pOutParams ,
											dwStatus
										) ;

		if ( SUCCEEDED ( hr ) )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}
#endif


#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::CheckSetSecurityDescriptor (
											const CInstance& pInstance,
											CInstance* pInParams,
											CInstance* pOutParams,
											DWORD& dwStatus
										)
{

	bool bExists ;
	VARTYPE eType ;
	HRESULT hr = WBEM_S_NO_ERROR ;
	dwStatus = LSSS_STATUS_SUCCESS ;

	SECURITY_DESCRIPTOR absoluteSD;
	PSECURITY_DESCRIPTOR pRelativeSD = NULL;
	InitializeSecurityDescriptor((PVOID)&absoluteSD, SECURITY_DESCRIPTOR_REVISION) ;
	CInstancePtr pAccess;

	if ( pInParams->GetStatus ( METHOD_ARG_NAME_DESCRIPTOR , bExists , eType ) )
	{
		if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		{
			if ( eType == VT_NULL )
			{
				dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				hr = WBEM_E_INVALID_PARAMETER ;
			}
			else
			{
				if ( pInParams->GetEmbeddedObject ( METHOD_ARG_NAME_DESCRIPTOR , &pAccess , pInParams->GetMethodContext () ) )
				{
				}
				else
				{
					dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
					hr = WBEM_E_INVALID_PARAMETER ;
				}
			}
		}
		else
		{
			dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
		hr = WBEM_E_INVALID_PARAMETER ;
	}


	CInstancePtr pOwner;
    bool bOwnerSpecified = false ;
    if(SUCCEEDED(hr))
	{
		if ( pAccess->GetStatus ( IDS_Owner , bExists , eType ) )
		{
			if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
			{
				if ( eType == VT_NULL )
				{
					bOwnerSpecified = false ;
				}
				else
				{
					if ( pAccess->GetEmbeddedObject ( IDS_Owner , &pOwner , pAccess->GetMethodContext () ) )
					{
						bOwnerSpecified = true ;
					}
					else
					{
						dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
						hr = WBEM_E_INVALID_PARAMETER ;
					}
				}
			}
			else
			{
				dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				hr = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_INVALID_PARAMETER ;
		}
	}

    CInstancePtr pGroup;
    bool bGroupSpecified = false ;
    if(SUCCEEDED(hr))
    {
	    if ( pAccess->GetStatus ( IDS_Group , bExists , eType ) )
	    {
		    if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		    {
			    if ( eType == VT_NULL )
			    {
				    bGroupSpecified = false ;
			    }
			    else
			    {
				    if ( pAccess->GetEmbeddedObject ( IDS_Owner , &pGroup , pAccess->GetMethodContext () ) )
				    {
					    bGroupSpecified = true ;
				    }
				    else
				    {
					    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
					    hr = WBEM_E_INVALID_PARAMETER ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
		    hr = WBEM_E_INVALID_PARAMETER ;
	    }
    }

    SECURITY_DESCRIPTOR_CONTROL control;
    if(SUCCEEDED(hr))
    {
	    // get the control flags
	    if ( pAccess->GetStatus ( IDS_ControlFlags , bExists , eType ) )
	    {
		    if ( bExists &&  eType == VT_I4 )
		    {

			    if ( pAccess->GetDWORD ( IDS_ControlFlags , (DWORD&)control ) )
			    {
			    }
			    else
			    {
				    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				    hr = WBEM_E_INVALID_PARAMETER ;
			    }
		    }
		    else
		    {
			    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
		    hr = WBEM_E_INVALID_PARAMETER ;
	    }
    }

/*	//The function can set only the control bits that relate to automatic inheritance of ACEs
	if(!SetSecurityDescriptorControl(&absoluteSD, ???,control) )
	{
		dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
		return hr ;
	}
*/

	// now, take the Win32_Trustee instance and get the SID out of it
	// convert it to a CSid, and apply to the SecureFile
	CSid sidOwner ;

    if(SUCCEEDED(hr))
    {
	    if(bOwnerSpecified )
	    {
		    if(  FillSIDFromTrustee(pOwner, sidOwner)  == LSSS_STATUS_SUCCESS )
		    {

			    BOOL bOwnerDefaulted = ( control & SE_OWNER_DEFAULTED ) ? true : false ;

			    //sid validity checked here as FillSIDFromTrustee returns success if null sid
			    if ( sidOwner.IsValid() )
			    {
				    if(!SetSecurityDescriptorOwner(&absoluteSD, sidOwner.GetPSid(), bOwnerDefaulted) )
				    {
					    //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                        dwStatus = GetLastError();
					    hr = WBEM_E_PROVIDER_FAILURE ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
    }

	CSid sidGroup ;

    if(SUCCEEDED(hr))
    {
	    if( bGroupSpecified )
	    {
		    if( FillSIDFromTrustee(pGroup, sidGroup)  == LSSS_STATUS_SUCCESS )
		    {

			    BOOL bGroupDefaulted = ( control & SE_GROUP_DEFAULTED ) ? true : false ;

			    //sid validity checked here as FillSIDFromTrustee returns success if null sid
			    if ( sidGroup.IsValid() )
			    {
				    if(!SetSecurityDescriptorGroup(&absoluteSD, sidGroup.GetPSid(), bGroupDefaulted) )
				    {
					    //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                        dwStatus = GetLastError();
					    hr = WBEM_E_PROVIDER_FAILURE ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
    }

	CDACL *pdacl = NULL;
	PACL pDACL = NULL ;
	DWORD dwACLSize =0 ;
	CSACL *psacl = NULL;
	PACL pSACL = NULL ;
	DWORD dwSACLSize = 0 ;
	SHARE_INFO_502 *pShareInfo502 = NULL ;
	PSECURITY_DESCRIPTOR  pOldSD = NULL ;
	CNetAPI32 NetAPI ;
	if(SUCCEEDED(hr))
    {
        try
	    {
		    // Only bother with a dacl if we are going to be setting it, which is controled by the control flags specified...
            if(control & SE_DACL_PRESENT)
            {
                pdacl = new CDACL;
                if(pdacl != NULL)
                {
                    if( (dwStatus = FillDACLFromInstance(pAccess, *pdacl, pAccess->GetMethodContext () ) ) != LSSS_STATUS_SUCCESS )
		            {
			            if(dwStatus == STATUS_NULL_DACL)
                        {
                            // No dacl was specified - e.g., we have a NULL dacl.  Since we mimic a NULL dacl as a dacl with
                            // an Everyone ACCESS_ALLOWED entry, create that here:
                            if(!pdacl->CreateNullDACL())
                            {
                                dwStatus = E_FAIL ;
		                        hr = WBEM_E_PROVIDER_FAILURE ;
                            }
                        }
                        else if(dwStatus == STATUS_EMPTY_DACL)
                        {
                            pdacl->Clear(); // "creates" the empty dacl
                        }
                        else
                        {
                            dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
                            hr = WBEM_E_INVALID_PARAMETER;
                        }
                    }

                    if(!pdacl->CalculateDACLSize( &dwACLSize ) )
			        {
				        dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				        hr = WBEM_E_INVALID_PARAMETER ;
			        }

			        if(SUCCEEDED(hr))
                    {
                        if(dwACLSize >= sizeof(ACL) )
			            {
				            pDACL = (PACL) malloc(dwACLSize) ;
				            InitializeAcl(pDACL,dwACLSize,ACL_REVISION ) ;

				            BOOL bDaclDefaulted = ( control & SE_DACL_DEFAULTED ) ? true : false ;
				            if(pdacl->FillDACL( pDACL ) == ERROR_SUCCESS)
				            {
					            if(!SetSecurityDescriptorDacl(&absoluteSD, TRUE, pDACL, bDaclDefaulted) )
					            {
						            //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                                    dwStatus = GetLastError();
                                    hr = WBEM_E_INVALID_PARAMETER;
					            }
				            }
				            else
				            {
					            dwStatus = LSSS_STATUS_INVALID_PARAMETER;
                                hr = WBEM_E_INVALID_PARAMETER;
				            }
		                }
                    }
                }
            }

            // Only bother with a sacl if we are going to be setting it, which is controled by the control flags specified...
            if(control & SE_SACL_PRESENT)
            {
                if(SUCCEEDED(hr))
                {
                    psacl = new CSACL;
                    if(psacl != NULL)
                    {
		                if( (dwStatus = FillSACLFromInstance(pAccess, *psacl, pAccess->GetMethodContext () ) ) == LSSS_STATUS_SUCCESS )
		                {
			                if(!psacl->CalculateSACLSize( &dwSACLSize ) )
			                {
				                dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
                                hr = WBEM_E_INVALID_PARAMETER;
			                }

                            if(SUCCEEDED(hr))
                            {
			                    if( dwSACLSize > sizeof(ACL) )
			                    {
				                    pSACL = (PACL) malloc(dwSACLSize) ;
				                    InitializeAcl(pSACL,dwSACLSize,ACL_REVISION ) ;

				                    BOOL bSaclDefaulted = ( control & SE_SACL_DEFAULTED ) ? true : false ;
				                    if(psacl->FillSACL( pSACL ) == ERROR_SUCCESS)
				                    {
					                    if(!SetSecurityDescriptorSacl(&absoluteSD, TRUE, pSACL, bSaclDefaulted) )
					                    {
						                    //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                                            dwStatus = GetLastError();
                                            hr = WBEM_E_INVALID_PARAMETER;
					                    }
				                    }
				                    else
				                    {
					                    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				                    }
			                    }
                            }
		                }
                    }
                    else
                    {
                        dwStatus = E_FAIL ;
		                hr = WBEM_E_PROVIDER_FAILURE ;
                    }
                }
            }

		    DWORD dwLength = 0 ;

            if(SUCCEEDED(hr))
            {
		        MakeSelfRelativeSD(&absoluteSD, NULL, &dwLength);
		        pRelativeSD= ( PSECURITY_DESCRIPTOR ) malloc( dwLength );

		        if (!MakeSelfRelativeSD(&absoluteSD, pRelativeSD, &dwLength))
		        {
			        //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                    dwStatus = GetLastError();
                    hr = WBEM_E_PROVIDER_FAILURE ;
		        }
            }

            if(pdacl != NULL)
            {
                delete pdacl;
                pdacl = NULL;
            }

            if(psacl != NULL)
            {
                delete psacl;
                psacl = NULL;
            }



		    if(SUCCEEDED(hr))
            {
		        CHString chsShareName ;
		        pInstance.GetCHString(IDS_Name, chsShareName) ;
		        bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;


		        if(	(dwStatus = NetAPI.Init() ) == ERROR_SUCCESS		&&
			        (dwStatus = NetAPI.NetShareGetInfo(	NULL,
												        (LPTSTR) bstrName,
												        502,
												        (LPBYTE *) &pShareInfo502) )== NERR_Success	)
		        {

			        //store old SD
			        pOldSD = pShareInfo502->shi502_security_descriptor ;

			        pShareInfo502->shi502_security_descriptor =  pRelativeSD ;

			        if( (dwStatus = NetAPI.NetShareSetInfo(	NULL,
									        (LPTSTR) bstrName,
									        502,
									        (LPBYTE ) pShareInfo502, NULL) ) != NERR_Success	)

			        {
				        //dwStatus = GetStatusCode(dwStatus) ;
			        }

					// Moved after Share
			        /*pShareInfo502->shi502_security_descriptor = pOldSD ;

			        NetAPI.NetApiBufferFree(pShareInfo502);
			        pShareInfo502 = NULL ;*/
		        }
		        else
		        {
			        //dwStatus = GetStatusCode(dwStatus) ;
		        }
            }

	    }

	    catch ( ... )
	    {
		    if ( pShareInfo502 )
		    {
			    if ( pOldSD )
			    {
				    pShareInfo502->shi502_security_descriptor = pOldSD ;
				    NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
				    pShareInfo502 = NULL ;
				    pOldSD = NULL ;
			    }
		    }
		    if ( pRelativeSD )
		    {
			    free ( pRelativeSD ) ;
			    pRelativeSD = NULL ;
		    }

		    if ( pDACL )
		    {
			    free ( pDACL ) ;
			    pDACL = NULL ;
		    }
		    if ( pSACL )
		    {
			    free ( pSACL ) ;
			    pSACL = NULL ;
		    }

		    throw ;
	    }
    }

	if ( pShareInfo502 )
	{
		if ( pOldSD )
		{
			pShareInfo502->shi502_security_descriptor = pOldSD ;
			NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
			pShareInfo502 = NULL ;
			pOldSD = NULL ;
		}
	}
	if ( pRelativeSD )
	{
		free ( pRelativeSD ) ;
		pRelativeSD = NULL ;
	}

	if ( pDACL )
	{
		free ( pDACL ) ;
		pDACL = NULL ;
	}
	if ( pSACL )
	{
		free ( pSACL ) ;
		pSACL = NULL ;
	}
    // If we had an invalid  parameter, the status code will report it.  The method succeeded, however.
	// If we had another type of error (such as invalid parameter), the status code will show it, and the method failed.
    if(hr == WBEM_E_INVALID_PARAMETER)
    {
        hr = WBEM_S_NO_ERROR;
    }
	return hr ;
}
#endif




///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalShareSecuritySetting::EnumerateInstances
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalShareSecuritySetting::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
#ifdef WIN9XONLY
    return WBEM_S_NO_ERROR;
#endif

#ifdef NTONLY
	HRESULT hr = WBEM_S_NO_ERROR;

	CAdvApi32Api *t_pAdvApi32 = NULL;
    t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);

    if(t_pAdvApi32 != NULL)
    {
        CHString chstrDllVer;
        if(t_pAdvApi32->GetDllVersion(chstrDllVer))
        {
            if(chstrDllVer >= _T("4.0"))
            {
                try
                {
                    hr = CWbemProviderGlue::GetInstancesByQueryAsynch(L"SELECT Name FROM Win32_Share",
                        this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, (void*)t_pAdvApi32 );
                }
                catch(...)
                {
                    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
                    t_pAdvApi32 = NULL;
                    throw;
                }
	        }
        }
	    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
        t_pAdvApi32 = NULL;
    }
	return(hr);
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalShareSecuritySetting::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::EnumerationCallback(CInstance* pShare, MethodContext* pMethodContext, void* pUserData)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	DWORD dwRetCode = ERROR_SUCCESS ;

	CHString chsShareName;
	pShare->GetCHString(IDS_Name, chsShareName);
	SHARE_INFO_502 *pShareInfo502 = NULL ;

    // Do the puts, and that's it
	if (!chsShareName.IsEmpty())
	{

		CNetAPI32 NetAPI ;

		bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;

		if(	NetAPI.Init() == ERROR_SUCCESS		&&
			( dwRetCode = NetAPI.NetShareGetInfo (	NULL,
													(LPTSTR) bstrName,
													502,
													(LPBYTE *) &pShareInfo502 ) ) == NERR_Success

		 )
		{
			try
			{
				// Start pumping out the instances
				CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
				if(pInstance != NULL)
				{
					PSECURITY_DESCRIPTOR pSD = NULL ;
					PACL pDacl = NULL ;
					if( pShareInfo502->shi502_security_descriptor == NULL && GetPlatformMajorVersion() >= 4 )
					{
						CAdvApi32Api *t_pAdvApi32 = NULL ;
						t_pAdvApi32 = ( CAdvApi32Api* ) pUserData ;
						if ( t_pAdvApi32 != NULL )
						{
							t_pAdvApi32->GetNamedSecurityInfoW(
													bstrName ,
													SE_LMSHARE,
													DACL_SECURITY_INFORMATION,
													NULL,
													NULL,
													&pDacl,
													NULL,
													&pSD,
                                                    NULL   // the real return value, which we don't care about
												) ;
						}
					}

					try
					{
						//Sec. Desc. is not returned for IPC$ ,C$ ...shares for Admin purposes
						if(pShareInfo502->shi502_security_descriptor != NULL || pSD )
						{
							CSecureShare SecShare(pSD ? pSD : pShareInfo502->shi502_security_descriptor) ;

							SECURITY_DESCRIPTOR_CONTROL control;
							SecShare.GetControl(&control);
							pInstance->SetDWORD(IDS_ControlFlags, control);
                            pInstance->SetCHString(IDS_Name, chsShareName);
                            CHString chstrTemp;
                            chstrTemp.Format(L"Security settings of %s", (LPCWSTR)chsShareName);
                            pInstance->SetCHString(IDS_Caption, chstrTemp);
                            pInstance->SetCHString(IDS_Description, chstrTemp);
							hr = pInstance->Commit () ;
						}
					}
					catch ( ... )
					{
						if( pSD )
						{
							LocalFree( pSD ) ;
							pSD = NULL ;
						}
						throw ;
					}

					if( pSD )
					{
						LocalFree( pSD ) ;
						pSD = NULL ;
					}
				}
				else // pInstance == NULL
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
			catch ( ... )
			{
				if ( pShareInfo502 )
				{
					NetAPI.NetApiBufferFree(pShareInfo502) ;
					pShareInfo502 = NULL ;
				}
				throw ;
			}
			if ( pShareInfo502 )
			{
				NetAPI.NetApiBufferFree(pShareInfo502) ;
				pShareInfo502 = NULL ;
			}
		}	// end if

	}

	return(hr);
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalShareSecuritySetting::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT WINAPI Win32LogicalShareSecuritySetting::StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData)
{
	Win32LogicalShareSecuritySetting* pThis;
	HRESULT hr;

	pThis = dynamic_cast<Win32LogicalShareSecuritySetting *>(pThat);
	ASSERT_BREAK(pThis != NULL);

	if (pThis)
	{
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
	}
	else
	{
    	hr = WBEM_E_FAILED;
	}
	return hr;
}
#endif

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalShareSecuritySetting::GetObject
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalShareSecuritySetting::GetObject ( CInstance* pInstance, long lFlags /* = 0L */ )
{
#ifdef WIN9XONLY
    return WBEM_E_NOT_FOUND;
#endif

#ifdef NTONLY
    HRESULT hr = WBEM_E_NOT_FOUND;
	DWORD dwRetCode = ERROR_SUCCESS ;
    CHString chsShareName ;
	SHARE_INFO_502 *pShareInfo502 = NULL ;

	if ( pInstance )
	{
		pInstance->GetCHString(IDS_Name,chsShareName);
		_bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;

		CNetAPI32 NetAPI;

		if(	NetAPI.Init() == ERROR_SUCCESS )
		{
			dwRetCode =	NetAPI.NetShareGetInfo (	NULL,
													(LPTSTR) bstrName,
													502,
													(LPBYTE *) &pShareInfo502 ) ;
			if ( dwRetCode == NERR_Success )
			{
				try
				{
					PSECURITY_DESCRIPTOR pSD = NULL ;
					try
					{
						PACL pDacl = NULL ;
						if( pShareInfo502->shi502_security_descriptor == NULL && GetPlatformMajorVersion() >= 4 )
						{
							CAdvApi32Api *t_pAdvApi32 = NULL;
							t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
							if ( t_pAdvApi32 != NULL )
							{
								try
								{
									t_pAdvApi32->GetNamedSecurityInfoW(
																			bstrName ,
																			SE_LMSHARE,
																			DACL_SECURITY_INFORMATION,
																			NULL,
																			NULL,
																			&pDacl,
																			NULL,
																			&pSD , &dwRetCode
																		) ;
								}
								catch ( ... )
								{
									CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
									t_pAdvApi32 = NULL;
									throw ;
								}

								CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
								t_pAdvApi32 = NULL;
							}
						}

						//Sec. Desc. is not returned for IPC$ ,C$ ...shares for Admin purposes
						if(pShareInfo502->shi502_security_descriptor != NULL || (pSD != NULL && dwRetCode == ERROR_SUCCESS) )
						{

							CSecureShare SecShare( pSD ? pSD : pShareInfo502->shi502_security_descriptor ) ;

							SECURITY_DESCRIPTOR_CONTROL control;
							SecShare.GetControl(&control);
							pInstance->SetDWORD(IDS_ControlFlags, control);
                            CHString chstrTemp;
                            chstrTemp.Format(L"Security settings of %s", (LPCWSTR)chsShareName);
                            pInstance->SetCHString(IDS_Caption, chstrTemp);
                            pInstance->SetCHString(IDS_Description, chstrTemp);
							hr = WBEM_S_NO_ERROR ;
						}

					}
					catch ( ... )
					{
						if( pSD )
						{
							LocalFree( pSD ) ;
							pSD = NULL ;
						}
						throw ;
					}
					if( pSD )
					{
						LocalFree( pSD ) ;
						pSD = NULL ;
					}
				}
				catch ( ... )
				{
					if ( pShareInfo502 )
					{
						NetAPI.NetApiBufferFree(pShareInfo502);
						pShareInfo502 = NULL ;
					}
					throw ;
				}

				if ( pShareInfo502 )
				{
					NetAPI.NetApiBufferFree(pShareInfo502);
					pShareInfo502 = NULL ;
				}
			}
		}
		else
		{
			hr = WBEM_E_FAILED ;
		}
	}	//if (pInstance)

	return(hr);
#endif
}


/*
#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::GetEmptyInstanceHelper(CHString chsClassName, CInstance**ppInstance, MethodContext* pMethodContext )
{

	CHString chsServer ;
	CHString chsPath ;
	HRESULT hr = S_OK ;

	chsServer = GetLocalComputerName() ;

	chsPath = _T("\\\\") + chsServer + _T("\\") + IDS_CimWin32Namespace + _T(":") + chsClassName ;

	CInstancePtr  pClassInstance = NULL ;
	if(SUCCEEDED( hr = CWbemProviderGlue::GetInstanceByPath(chsPath, &pClassInstance, pMethodContext) ) )
	{
		IWbemClassObjectPtr pClassObject ( pClassInstance->GetClassObjectInterface(), false ) ;

		IWbemClassObjectPtr piClone = NULL ;
		if(SUCCEEDED(hr = pClassObject->SpawnInstance(0, &piClone) ) )
		{
			*ppInstance = new CInstance(piClone, pMethodContext ) ;
		}
	}

	return hr ;
}
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupitemdatafile.cpp ===
//=================================================================

//

// Win32ProgramGroupItemDataFile.cpp -- Win32_LogicalProgramGroupItem to CIM_DataFile

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/98    a-kevhu         Created
//
// Comment: Relationship between win32_logicalprogramgroupitem and contained cim_datafiles
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "userhive.h"

#include "Win32ProgramGroupItemDataFile.h"
#include "cimdatafile.h"
#include "shortcutfile.h"


// Property set declaration
//=========================
CW32ProgGrpItemDataFile MyW32ProgGrpItemDF(PROPSET_NAME_WIN32LOGICALPROGRAMGROUPITEM_CIMDATAFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::CW32ProgGrpItemDataFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32ProgGrpItemDataFile::CW32ProgGrpItemDataFile(LPCWSTR setName, LPCWSTR pszNamespace)
:CImplement_LogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::~CW32ProgGrpItemDataFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32ProgGrpItemDataFile::~CW32ProgGrpItemDataFile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpItemDataFile::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrProgGroupItem;
    CHString chstrDataFile;
    HRESULT hr = WBEM_E_NOT_FOUND;
    CInstancePtr pProgGroupItem;
    CInstancePtr pDataFile;

    if(pInstance != NULL)
    {
        // Get the two paths
        pInstance->GetCHString(IDS_Antecedent, chstrProgGroupItem);
        pInstance->GetCHString(IDS_Dependent, chstrDataFile);

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrProgGroupItem, &pProgGroupItem, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDataFile, &pDataFile, pInstance->GetMethodContext())))
            {
                // Double check that the dependent instance really is a datafile (or derived) instance...
                CHString chstrClassName;
                if(pDataFile->GetCHString(IDS___Class, chstrClassName) &&
                    CWbemProviderGlue::IsDerivedFrom(L"CIM_LogicalFile", chstrClassName, pDataFile->GetMethodContext(), IDS_CimWin32Namespace))
                {
                    // Make sure the group is still a group that is registered (not just left over directory)
                    CHString chstrUserPart;
                    CHString chstrPathPart;
#ifdef NTONLY
                    {
                        CHString chstrProgGroupItemName;
                        pProgGroupItem->GetCHString(IDS_Name,chstrProgGroupItemName);
                        chstrUserPart = chstrProgGroupItemName.SpanExcluding(L":");
                        chstrPathPart = chstrProgGroupItemName.Mid(chstrUserPart.GetLength() + 1);
                        if(chstrUserPart.CompareNoCase(IDS_Default_User) == 0)
                        {
                            // Default user and All Users are not part of the user hive, they just are.
                            // Since we got this far, we know that the file exists in the specified location
                            // within the program group directory by virtue of the two GetInstanceByPath calls
                            // which would not have succeeded had the file not existed.  So all is well.
                            hr = WBEM_S_NO_ERROR;
                        }
                        else if(chstrUserPart.CompareNoCase(IDS_All_Users) == 0)
                        {
                            hr = WBEM_S_NO_ERROR;
                        }
                        else
                        {
                            CUserHive cuhUser;
                            TCHAR szKeyName[_MAX_PATH];
                            ZeroMemory(szKeyName,sizeof(szKeyName));
                            if (cuhUser.Load(chstrUserPart, szKeyName) == ERROR_SUCCESS)
		                    {
                                try
                                {
                                    CRegistry reg;
                                    CHString chstrTemp;
                                    CHString chstrProfileImagePath = L"ProfileImagePath";
                                    CHString chstrProfileImagePathValue;
                                    chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                                    chstrTemp += szKeyName;
                                    if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                                    {
                                        // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000"
                                        // Need to expand out the environment variable.
                                        TCHAR tstrProfilesDir[_MAX_PATH];
                                        ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
                                        DWORD dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfilesDir,_MAX_PATH);
                                        if(dw != 0 && dw < _MAX_PATH)
                                        {
                                            CHString chstrProgGroupDir;
                                            chstrProgGroupDir.Format(L"%s\\",
                                                                     (LPCWSTR)tstrProfilesDir);
                                            // Create a directory name based on what the registry says it should be
                                            CHString chstrDirectoryName;
                                            chstrDirectoryName.Format(L"%s%s", (LPCWSTR)chstrProgGroupDir, (LPCWSTR)chstrPathPart);
                                            EscapeBackslashes(chstrDirectoryName,chstrDirectoryName);
                                            // If the directory name above is a portion of chstrDataFile, we are valid.
                                            chstrDataFile.MakeUpper();
                                            chstrDirectoryName.MakeUpper();
                                            if(chstrDataFile.Find(chstrDirectoryName) > -1)
                                            {
                                                // Everything seems to actually exist.
                                                hr = WBEM_S_NO_ERROR;
                                            }
                                        } // expanded environment variable
                                        reg.Close();
                                    }
                                }
                                catch ( ... )
                                {
                                    cuhUser.Unload(szKeyName);
                                    throw ;
                                }  // could open registry key for profilelist
                                cuhUser.Unload(szKeyName);
                            } // userhive loaded
                        } // else a user-hive user account
                    } // was nt
#endif
#ifdef WIN9XONLY
                    {
                        // chstrUserPart = chstrName.SpanExcluding(_T(":")); //known to be "All Users"
                        // chstrPathPart = chstrProgGroup.Mid(chstrUserPart.GetLength() + 1);
                        // Easy by comparison to nt case; everything always under %systemdir%\\Start Menu\\Programs
                        CRegistry reg;
                        CHString chstrTemp;
                        CHString chstrRegKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
                        if(reg.OpenCurrentUser(
                                    chstrRegKey,
                                    KEY_READ) == ERROR_SUCCESS)
                        {
                            if(reg.GetCurrentKeyValue(L"Programs",chstrTemp) == ERROR_SUCCESS)
                            {
                                // Create a directory name based on what the registry says it should be
                                // chstrTemp contains something like "C:\\WINDOWS\\Start Menu\\Programs".  So need to remove the "C:"
                                // and add a trailing "\\"
                                CHString chstrRegPathPart = chstrTemp.Mid(chstrTemp.Find(L":")+1);
                                // Remove the Programs part...
                                int iLastWhackPos = chstrRegPathPart.ReverseFind(_T('\\'));
                                if(iLastWhackPos > -1)
                                {
                                    chstrRegPathPart = chstrRegPathPart.Left(iLastWhackPos);
                                    chstrRegPathPart += _T("\\");
                                    EscapeBackslashes(chstrRegPathPart,chstrRegPathPart);
                                    // If the directory name above is a portion of chstrDataFile, we are valid.
                                    if(chstrDataFile.Find(chstrRegPathPart) > -1)
                                    {
                                        // Everything seems to actually exist.
                                        hr = WBEM_S_NO_ERROR;
                                    }
                                }
                            }
                            reg.Close();
                        }
                    } // isnt
#endif
                }
            } //datafile instancebypath
        } //progroup instancebypath
    } // pinstance not null
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::ExecQuery
 *
 *  DESCRIPTION : Returns only the specific association asked for
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpItemDataFile::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    // We optimize on two types of queries only: those in which the antecedent was specified only (the programgroupitem),
    // or those in which the dependent was specified only (the datafile).  All others result in an enumeration.

    HRESULT hr = WBEM_E_NOT_FOUND;

    CHStringArray achstrAntecedent;
    CHStringArray achstrDependent;
    DWORD dwAntecedents = 0;
    DWORD dwDependents = 0;

    pQuery.GetValuesForProp(IDS_Antecedent, achstrAntecedent);
    dwAntecedents = achstrAntecedent.GetSize();
    pQuery.GetValuesForProp(IDS_Dependent, achstrDependent);
    dwDependents = achstrDependent.GetSize();

    if(dwAntecedents == 1 && dwDependents == 0)
    {
        hr = ExecQueryType1(pMethodContext, achstrAntecedent[0]);
    }
    else if(dwDependents == 1 && dwAntecedents == 0)
    {
        hr = ExecQueryType2(pMethodContext, achstrDependent[0]);
    }
    else // type of query we don't optimize on
    {
        hr = EnumerateInstances(pMethodContext);
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::ExecQueryType1
 *
 *  DESCRIPTION : Processes queries where we have a program group item
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 ****************************************************************************/
HRESULT CW32ProgGrpItemDataFile::ExecQueryType1(MethodContext* pMethodContext, CHString& chstrProgGroupItemNameIn)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Were given a programgroupitem.  Happens when hit associators on a programgroupitem.
    // Need the program group name extracted from the antecedent:
    CHString chstrProgGroupItemName(chstrProgGroupItemNameIn);
    chstrProgGroupItemName = chstrProgGroupItemName.Mid(chstrProgGroupItemName.Find(_T('=')) + 2);
    chstrProgGroupItemName = chstrProgGroupItemName.Left(chstrProgGroupItemName.GetLength() - 1);

    CHString chstrUserPart;
    CHString chstrPathPart;
    CHString chstrDatafile;
    CHString chstrProgGroupDir;
    CHString chstrQuery;
    chstrUserPart = chstrProgGroupItemName.SpanExcluding(L":");
    chstrPathPart = chstrProgGroupItemName.Mid(chstrUserPart.GetLength() + 1);  // already has escaped backslashes at this point
    RemoveDoubleBackslashes(chstrPathPart,chstrPathPart);

#ifdef NTONLY
    {
        TCHAR tstrProfilesDir[_MAX_PATH];
        ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
        CRegistry regProfilesDir;
        CHString chstrProfilesDirectory = L"";
        regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                       L"ProfilesDirectory",
                                                       chstrProfilesDirectory);

        // if that entry is not present, try %systemroot%\profiles instead
        if(chstrProfilesDirectory.GetLength() == 0)
        {
            chstrProfilesDirectory = L"%systemroot%\\Profiles";
        }

        if(chstrProfilesDirectory.GetLength() > 0)
        {
            // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
            // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
            DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,tstrProfilesDir,_MAX_PATH);
            if(dw != 0 && dw < _MAX_PATH)
            {
                if(chstrUserPart.CompareNoCase(IDS_Default_User)==0)
                {
                    chstrProgGroupDir.Format(L"%s\\%s\\", tstrProfilesDir, IDS_Default_User);
                    chstrDatafile = chstrProgGroupDir + chstrPathPart;
                    hr = AssociatePGIToDFNT(pMethodContext, chstrDatafile, chstrProgGroupItemNameIn);
                }
                else if(chstrUserPart.CompareNoCase(IDS_All_Users)==0)
                {
                    chstrProgGroupDir.Format(L"%s\\%s\\", tstrProfilesDir, IDS_All_Users);
                    chstrDatafile = chstrProgGroupDir + chstrPathPart;
                    hr = AssociatePGIToDFNT(pMethodContext, chstrDatafile, chstrProgGroupItemNameIn);
                }
                else
                {
                    CUserHive cuhUser;
                    TCHAR szKeyName[_MAX_PATH];
                    ZeroMemory(szKeyName,sizeof(szKeyName));
                    // chstrUserPart contains double backslashes; need singles for it to work, so...
                    if(cuhUser.Load(RemoveDoubleBackslashes(chstrUserPart), szKeyName) == ERROR_SUCCESS)
		            {
                        try
                        {
                            CRegistry reg;
                            CHString chstrTemp;
                            CHString chstrProfileImagePath = L"ProfileImagePath";
                            CHString chstrProfileImagePathValue;
                            chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                            chstrTemp += szKeyName;
                            if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                            {
                                // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000". Expand it:
                                TCHAR tstrProfileImagePath[_MAX_PATH];
                                ZeroMemory(tstrProfileImagePath,sizeof(tstrProfileImagePath));
                                dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfileImagePath,_MAX_PATH);
                                if(dw != 0 && dw < _MAX_PATH)
                                {
                                    CHString chstrProgGroupDir;
                                    chstrProgGroupDir.Format(L"%s\\",
                                                             tstrProfileImagePath);
                                    // Create a directory name based on what the registry says it should be
                                    chstrDatafile = chstrProgGroupDir + chstrPathPart;
                                    hr = AssociatePGIToDFNT(pMethodContext, chstrDatafile, chstrProgGroupItemNameIn);
                                }
                                reg.Close();
                            }
                        }
                        catch ( ... )
                        {
                            cuhUser.Unload(szKeyName);
                            throw;
                        }  // could open registry key for profilelist
                        cuhUser.Unload(szKeyName);
                    } // loaded user profile
                } // user part was...
            } // expanded profiles directory successfully
        } // got profiles directory from registry
    }
#endif
#ifdef WIN9XONLY
    {
        // Easy by comparison to nt case; everything always under %systemdir%\\Start Menu\\Programs
        CRegistry reg;
        CHString chstrTemp;
        CHString chstrRegKey = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
        if(reg.OpenCurrentUser(
                    chstrRegKey,
                    KEY_READ) == ERROR_SUCCESS)
        {
            if(reg.GetCurrentKeyValue(L"Programs",chstrTemp) == ERROR_SUCCESS)
            {
                int iLastWhackPos = chstrTemp.ReverseFind(_T('\\'));
                if(iLastWhackPos > -1)
                {
                    chstrTemp = chstrTemp.Left(iLastWhackPos);  // that took off the "programs" portion.
                    int iLastWhackPos = chstrTemp.ReverseFind(_T('\\'));
                    if(iLastWhackPos > -1)
                    {
                        chstrTemp = chstrTemp.Left(iLastWhackPos) + L"\\";  // that took off the "Start Menu" portion.
                        chstrDatafile = chstrTemp + chstrPathPart;
                        hr = AssociatePGIToDF95(pMethodContext, chstrDatafile, chstrProgGroupItemNameIn);
                    }
                }
            }
            reg.Close();
        }
    } // is nt?
#endif
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::ExecQueryType2
 *
 *  DESCRIPTION : Processes queries where we have a datafile
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 ****************************************************************************/
HRESULT CW32ProgGrpItemDataFile::ExecQueryType2(MethodContext* pMethodContext, CHString& chstrDependent)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // We were given a datafile (happens when hit associators on a datafile).
    // Need to find the corresponding programgroupitem and associate.
    CHString chstrModDependent(RemoveDoubleBackslashes(chstrDependent));

#ifdef NTONLY
    {
        CRegistry reg;
        BOOL fGotIt = FALSE;
        CHString chstrProfilesList = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
        if(reg.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
                                       chstrProfilesList,
                                       KEY_READ) == ERROR_SUCCESS)
        {
            CHString chstrSubKey;
            while(!fGotIt)
            {
                if(reg.GetCurrentSubKeyName(chstrSubKey) != ERROR_NO_MORE_ITEMS)
                {
                    CRegistry regUser;
                    CHString chstrUserSubKey;
                    chstrUserSubKey.Format(L"%s\\%s",(LPCWSTR)chstrProfilesList,(LPCWSTR)chstrSubKey);
                    if(regUser.Open(HKEY_LOCAL_MACHINE, chstrUserSubKey, KEY_READ) == ERROR_SUCCESS)
                    {
                        CHString chstrProfileImagePath;
                        if(regUser.GetCurrentKeyValue(L"ProfileImagePath", chstrProfileImagePath)
                                       == ERROR_SUCCESS)
                        {
                            WCHAR wstrProfilesDir[_MAX_PATH];
                            ZeroMemory(wstrProfilesDir,sizeof(wstrProfilesDir));
                            DWORD dw = ExpandEnvironmentStrings(chstrProfileImagePath,wstrProfilesDir,_MAX_PATH);
                            if(dw != 0 && dw < _MAX_PATH)
                            {
                                // Extract the directory pathname out of the dependent...
                                CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                                chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                                CHString chstrDepPathNameUserPortion = chstrDepPathName.Left(wcslen(wstrProfilesDir));
                                if(chstrDepPathNameUserPortion.CompareNoCase(wstrProfilesDir) == 0)
                                {
                                    // This user profile matches that of the file we were given.  Don't need to continue while loop.
                                    fGotIt = TRUE;
                                    // Look up this user's account from the profile...
                                    CUserHive cuh;
                                    CHString chstrUserAccount;
                                    if(cuh.UserAccountFromProfile(regUser,chstrUserAccount) == ERROR_SUCCESS)
                                    {
                                        // Extract the datafile pathname portion out of the dependent...
                                        CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                                        chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                                        // Get the non-user portion out of the file's pathname...
                                        CHString chstrItem = chstrDepPathName.Mid(wcslen(wstrProfilesDir) + 1);
                                        // Assemble name of the logical program group item...
                                        CHString chstrLPGIName;
                                        chstrLPGIName.Format(L"%s:%s",(LPCWSTR)chstrUserAccount,IDS_Start_Menu);
                                        if(chstrItem.GetLength() > 0)
                                        {
                                            chstrLPGIName += L"\\";
                                            chstrLPGIName += chstrItem;
                                        }
                                        // Construct a full PATH for the program group item...
                                        CHString chstrTemp;
                                        EscapeBackslashes(chstrLPGIName,chstrTemp);

                                        CHString chstrLPGIPATH;
                                        chstrLPGIPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroupItem.Name=\"%s\"",
                                                             (LPCWSTR)GetLocalComputerName(),
                                                             IDS_CimWin32Namespace,
                                                             (LPCWSTR)chstrTemp);

                                          // Can't just commit it here even though we have all the pieces, because
                                          // we never confirmed that such a file exists.  We have only confirmed that
                                          // a directory matching the first pieces of the specified path exists.
                                          // Hence we call our friend...
                                          hr = AssociatePGIToDFNT(pMethodContext, chstrDepPathName, chstrLPGIPATH);
                                    }
                                }
                            }
                        }
                        regUser.Close();
                    }
                } // got subkey
                if(reg.NextSubKey() != ERROR_SUCCESS)
                {
                    break;
                }
            }
        }
        if(!fGotIt)
        {
            // Wasn't a match for any of the user hive entries, but could be default user or all users.
            CRegistry regProfilesDir;
            CHString chstrProfilesDirectory = L"";
            CHString chstrDefaultUserProfile;
            regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                           L"ProfilesDirectory",
                                           chstrProfilesDirectory);
            regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                           L"DefaultUserProfile",
                                           chstrDefaultUserProfile);
            if(chstrProfilesDirectory.GetLength() > 0)
            {
                // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
                // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
                WCHAR wstrProfilesDir[_MAX_PATH];
                ZeroMemory(wstrProfilesDir,sizeof(wstrProfilesDir));
                DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,wstrProfilesDir,_MAX_PATH);
                if(dw != 0 && dw < _MAX_PATH)
                {
                    // First see if default user
                    CHString chstrTemp;
                    chstrTemp.Format(L"%s\\%s\\%s",wstrProfilesDir,(LPCWSTR)chstrDefaultUserProfile,IDS_Start_Menu);
                    // Extract the file pathname out of the dependent...
                    CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                    chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);

                    // Get the left lProfDirLen chars out of the file we were given...
                    CHString chstrProfDF = chstrDepPathName.Left(chstrTemp.GetLength());
                    // Get the item portion out of the file's pathname...
                    CHString chstrItem = chstrDepPathName.Mid(chstrProfDF.GetLength() + 1);
                    if(chstrProfDF.CompareNoCase(chstrTemp)==0)
                    {
                        // it was the default user
                        fGotIt = TRUE;
                        // Construct a full PATH for the program group item...
                        CHString chstrLPGIName;
                        chstrLPGIName.Format(L"%s:%s", (LPCWSTR)chstrDefaultUserProfile, IDS_Start_Menu);
                        if(chstrItem.GetLength() > 0)
                        {
                            chstrLPGIName += L"\\";
                            chstrLPGIName += chstrItem;
                        }

                        EscapeBackslashes(chstrLPGIName,chstrTemp);
                        CHString chstrLPGIPATH;
                        chstrLPGIPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroupItem.Name=\"%s\"",
                                             (LPCWSTR)GetLocalComputerName(),
                                             IDS_CimWin32Namespace,
                                             (LPCWSTR)chstrTemp);

                        // Can't just commit it here even though we have all the pieces, because
                        // we never confirmed that such a file exists.  We have only confirmed that
                        // a directory matching the first pieces of the specified path exists.
                        // Hence we call our friend...
                        hr = AssociatePGIToDFNT(pMethodContext, chstrDepPathName, chstrLPGIPATH);

                    }
                    // Then see if it was All Users
                    if(!fGotIt)
                    {
                        CHString chstrAllUsersProfile;
                        regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                       L"AllUsersProfile",
                                                       chstrAllUsersProfile);
                        if(chstrAllUsersProfile.GetLength() > 0)
                        {
                            chstrTemp.Format(L"%s\\%s\\%s",wstrProfilesDir,(LPCWSTR)chstrAllUsersProfile,IDS_Start_Menu);
                            chstrProfDF = chstrDepPathName.Left(chstrTemp.GetLength());
                            chstrItem = chstrDepPathName.Mid(chstrProfDF.GetLength() + 1);
                            if(chstrProfDF.CompareNoCase(chstrTemp)==0)
                            {
                                // it was All Users
                                fGotIt = TRUE;
                                // Construct a full PATH for the program group item...
                                CHString chstrLPGIName;
                                chstrLPGIName.Format(L"%s::%s",wstrProfilesDir,(LPCWSTR)chstrAllUsersProfile);
                                if(chstrItem.GetLength() > 0)
                                {
                                    chstrLPGIName += L"\\\\";
                                    chstrLPGIName += chstrItem;
                                }

                                EscapeBackslashes(chstrLPGIName,chstrTemp);
                                CHString chstrLPGIPATH;
                                chstrLPGIPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroupItem.Name=\"%s\"",
                                                     (LPCWSTR)GetLocalComputerName(),
                                                     IDS_CimWin32Namespace,
                                                     (LPCWSTR)chstrTemp);

                                // Can't just commit it here even though we have all the pieces, because
                                // we never confirmed that such a file exists.  We have only confirmed that
                                // a directory matching the first pieces of the specified path exists.
                                // Hence we call our friend...
                                hr = AssociatePGIToDFNT(pMethodContext, chstrDepPathName, chstrLPGIPATH);
                            }
                        }
                    }
                } // expanded env variables
            } //got profiles dir
        } // wasn't a userhive entry
    } // nt
#endif
#ifdef WIN9XONLY
    {
        // Easy by comparison to nt case; everything always under %systemdir%\\Start Menu\\Programs
        CRegistry reg;
        CHString chstrTemp;
        CHString chstrRegKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
        if(reg.OpenCurrentUser(
                    chstrRegKey,
                    KEY_READ) == ERROR_SUCCESS)
        {
            if(reg.GetCurrentKeyValue(L"Programs",chstrTemp) == ERROR_SUCCESS)
            {
                int iLastWhackPos = chstrTemp.ReverseFind(_T('\\'));
                if(iLastWhackPos > -1)
                {
                    chstrTemp = chstrTemp.Left(iLastWhackPos);

                    // Extract the file pathname out of the dependent...
                    CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                    chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                    // Get the item portion out of the file's pathname...
                    CHString chstrItem = chstrDepPathName.Mid(chstrTemp.GetLength() + 1);

                    // Construct a full PATH for the program group item...
                    CHString chstrLPGIName;
                    chstrLPGIName.Format(L"All Users:%s",(LPCWSTR)chstrItem);
                    EscapeBackslashes(chstrLPGIName,chstrTemp);
                    CHString chstrLPGIPATH;
                    chstrLPGIPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroupItem.Name=\"%s\"",
                                         (LPCWSTR)GetLocalComputerName(),
                                         IDS_CimWin32Namespace,
                                         (LPCWSTR)chstrTemp);

                    // Can't just commit it here even though we have all the pieces, because
                    // we never confirmed that such a file exists.  We have only confirmed that
                    // a directory matching the first pieces of the specified path exists.
                    // Hence we call our friend...
                    hr = AssociatePGIToDF95(pMethodContext, chstrDepPathName, chstrLPGIPATH);
                }
            }
            reg.Close();
        }
    } // os type
#endif

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpItemDataFile::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
#ifdef NTONLY
        hr = EnumerateInstancesNT(pMethodContext);
#endif
#ifdef WIN9XONLY
        hr = EnumerateInstances9x(pMethodContext);
#endif
    return hr;
}


#ifdef NTONLY
HRESULT CW32ProgGrpItemDataFile::EnumerateInstancesNT(MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LProgGroupItems;

    // Obtain, from the registry, the directory where proifles are stored:
    TCHAR tstrProfilesDir[_MAX_PATH];
    ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
    CRegistry regProfilesDir;
    CHString chstrProfilesDirectory = L"";
    regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                   L"ProfilesDirectory",
                                                   chstrProfilesDirectory);
    // if that entry is not present, try %systemroot%\profiles instead
    if(chstrProfilesDirectory.GetLength() == 0)
    {
        chstrProfilesDirectory = L"%systemroot%\\Profiles";
    }

    if(chstrProfilesDirectory.GetLength() > 0)
    {
        // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
        // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
        DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,tstrProfilesDir,_MAX_PATH);
        if(dw != 0 && dw < _MAX_PATH)
        {
            // Get list of program groups
            if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(L"Win32_LogicalProgramGroupItem"),
                                                            &LProgGroupItems,
                                                            IDS_CimWin32Namespace,
                                                            pMethodContext)))
            {
                REFPTRCOLLECTION_POSITION pos;

                if(LProgGroupItems.BeginEnum(pos))
                {
                    CInstancePtr pProgGroupItem;
                    CHString chstrName;
                    CHString chstrProgGrpPath;
                    CHString chstrUserPart;
                    CHString chstrPathPart;
                    CHString chstrProgGroupDir;

                    // Walk through the proggroups
                    for (pProgGroupItem.Attach(LProgGroupItems.GetNext(pos));
                         SUCCEEDED(hr) && (pProgGroupItem != NULL);
                         pProgGroupItem.Attach(LProgGroupItems.GetNext(pos)))
                    {
                        if(pProgGroupItem != NULL)
                        {
                            CHString chstrQueryPath;
                            CHString chstrQuery;

                            pProgGroupItem->GetCHString(IDS_Name, chstrName);     // looks like "Default User:Accessories\\Multimedia" for instance
                            pProgGroupItem->GetCHString(IDS___Path, chstrProgGrpPath); // goes back as 'Antecedent'
                            // On NT, under %systemdir%\\Profiles, various directories corresponding to users are
                            // listed.  Under each is Start Menu\\Programs, under which are the directories listed
                            // by Win32_LogicalProgramGroup.
                            chstrUserPart = chstrName.SpanExcluding(L":");
                            chstrPathPart = chstrName.Mid(chstrUserPart.GetLength() + 1);
                            if(chstrUserPart.CompareNoCase(IDS_Default_User)==0)
                            {
                                chstrProgGroupDir.Format(L"%s\\%s\\%s", tstrProfilesDir, IDS_Default_User, (LPCTSTR)chstrPathPart);
                                hr = AssociatePGIToDFNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                            }
                            else if(chstrUserPart.CompareNoCase(IDS_All_Users)==0)
                            {
                                chstrProgGroupDir.Format(L"%s\\%s\\%s", tstrProfilesDir, IDS_All_Users, (LPCTSTR)chstrPathPart);
                                hr = AssociatePGIToDFNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                            }
                            else // need to get the sid corresponding to that user to then look up ProfileImagePath under
                                 // the registry key HKLM\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList
                            {
                                CUserHive cuhUser;
                                //CHString chstrKeyName;
                                TCHAR szKeyName[_MAX_PATH];
                                ZeroMemory(szKeyName,sizeof(szKeyName));
                                if(cuhUser.Load(chstrUserPart, szKeyName) == ERROR_SUCCESS)
                                {
                                    try
                                    {
                                        CRegistry reg;
                                        CHString chstrTemp;
                                        CHString chstrProfileImagePath = L"ProfileImagePath";
                                        CHString chstrProfileImagePathValue;
                                        chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                                        chstrTemp += szKeyName;
                                        if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                                        {
                                            // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000". Expand it:
                                            TCHAR tstrProfileImagePath[_MAX_PATH];
                                            ZeroMemory(tstrProfileImagePath,sizeof(tstrProfileImagePath));
                                            dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfileImagePath,_MAX_PATH);
                                            if(dw != 0 && dw < _MAX_PATH)
                                            {
                                                CHString chstrProgGroupDir;
                                                chstrProgGroupDir.Format(L"%s\\%s",
                                                                         tstrProfileImagePath,
                                                                         (LPCTSTR)chstrPathPart);
                                                // Create a directory name based on what the registry says it should be
                                                hr = AssociatePGIToDFNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                                            }
                                            reg.Close();
                                        }
                                    }
                                    catch ( ... )
                                    {
                                        cuhUser.Unload(szKeyName);
                                        throw ;
                                    }  // could open registry key for profilelist
                                    cuhUser.Unload(szKeyName);
                                }  // if load worked; otherwise we skip that one
                            } // which user
                        } // pProgGroupItem != NULL
                    } // while programgroupitems
                    LProgGroupItems.EndEnum();
                } // if BeginEnum of programgroupitem worked
            } // Got all instances of win32_logicalprogramgroupitem
        } // expanded environment strings contained in profiles directory
    } // Got profiles directory from registry
    return hr;
}
#endif

#ifdef WIN9XONLY
HRESULT CW32ProgGrpItemDataFile::EnumerateInstances9x(MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LProgGroupItems;

    // Get list of program groups
    if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(_T("Win32_LogicalProgramGroupItem")),
                                                    &LProgGroupItems,
                                                    IDS_CimWin32Namespace,
                                                    pMethodContext)))
    {
        REFPTRCOLLECTION_POSITION pos;

        if(LProgGroupItems.BeginEnum(pos))
        {
            CInstancePtr pProgGroupItem;
            CHString chstrName;
            CHString chstrProgGrpPath;
            CHString chstrUserPart;
            CHString chstrPathPart;
            // GetNext() will AddRef() the pointer, so make sure we Release()
            // it when we are done with it.

            // Walk through the proggroups
            for (pProgGroupItem.Attach(LProgGroupItems.GetNext(pos));
                 SUCCEEDED(hr) && (pProgGroupItem != NULL);
                 pProgGroupItem.Attach(LProgGroupItems.GetNext(pos)))
            {
                if(pProgGroupItem != NULL)
                {
                    CHString chstrQuery;

                    pProgGroupItem->GetCHString(IDS_Name, chstrName);     // looks like "Default User:Accessories\\Multimedia" for instance
                    pProgGroupItem->GetCHString(IDS___Path, chstrProgGrpPath); // goes back as 'Antecedent'

                    chstrUserPart = chstrName.SpanExcluding(L":");
                    chstrPathPart = chstrName.Mid(chstrUserPart.GetLength() + 1);

                    // Easy by comparison to nt case; everything always under %systemdir%\\Start Menu\\Programs
                    CRegistry reg;
                    CHString chstrTemp;
                    if(reg.OpenCurrentUser(
                                L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                                KEY_READ) == ERROR_SUCCESS)
                    {
                        if(reg.GetCurrentKeyValue(L"Programs", chstrTemp) == ERROR_SUCCESS)
                        {
                            // chstrTemp contains something like "C:\\WINDOWS\\Start Menu\\Programs".
                            // Need to remove the "Programs" dir for this path...
                            int iLastWhackPos = chstrTemp.ReverseFind(_T('\\'));
                            if(iLastWhackPos > -1)
                            {
                                chstrTemp = chstrTemp.Left(iLastWhackPos);
                                // Whack off the part that says "start menu" too...
                                iLastWhackPos = chstrTemp.ReverseFind(_T('\\'));
                                if(iLastWhackPos > -1)
                                {
                                    chstrTemp = chstrTemp.Left(iLastWhackPos);
                                    chstrTemp += L"\\";
                                    chstrTemp += chstrPathPart;
                                    hr = AssociatePGIToDF95(pMethodContext, chstrTemp, chstrProgGrpPath);
                                }
                            }
                        }
                        reg.Close() ;
                    }
                } // pProgGroupItem != NULL
            } // while programgroupitems
            LProgGroupItems.EndEnum();
        } // if BeginEnum of programgroupitem worked
    } // Got all instances of win32_logicalprogramgroupitem
    return hr;
}
#endif



#ifdef NTONLY
HRESULT CW32ProgGrpItemDataFile::AssociatePGIToDFNT(MethodContext* pMethodContext,
                                              CHString& chstrDF,
                                              CHString& chstrProgGrpItemPATH)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrDFDrive;
    CHString chstrDFPath;
    CHString chstrDFName;
    CHString chstrDFExt;
    bool fRoot;

    // Break the directory into its constituent parts
    GetPathPieces(chstrDF, chstrDFDrive, chstrDFPath, chstrDFName, chstrDFExt);

    // Find out if we are looking for the root directory
    if(chstrDFPath==L"\\" && chstrDFName==L"" && chstrDFExt==L"")
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrDFPath = L"";
    }
    else
    {
        fRoot = false;
    }

    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                    chstrDFDrive,   // drive letter and colon
                    chstrDFPath,    // use the given path
                    chstrDFName,    // filename
                    chstrDFExt,     // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)(LPCWSTR)chstrProgGrpItemPATH)); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif


#ifdef WIN9XONLY
HRESULT CW32ProgGrpItemDataFile::AssociatePGIToDF95(MethodContext* pMethodContext,
                                              CHString& chstrDF,
                                              CHString& chstrProgGrpItemPATH)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrDFDrive;
    CHString chstrDFPath;
    CHString chstrDFName;
    CHString chstrDFExt;
    bool fRoot;

    // Break the directory into its constituent parts
    GetPathPieces(chstrDF, chstrDFDrive, chstrDFPath, chstrDFName, chstrDFExt);

    // Find out if we are looking for the root directory
    if(chstrDFPath==L"\\" && chstrDFName==L"" && chstrDFExt==L"")
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrDFPath = _T("");
    }
    else
    {
        fRoot = false;
    }

    hr = EnumDirs95(C95EnumParm(pMethodContext,
                    TOBSTRT(chstrDFDrive),   // drive letter and colon
                    TOBSTRT(chstrDFPath),    // use the given path
                    TOBSTRT(chstrDFName),    // filename
                    TOBSTRT(chstrDFExt),     // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)(LPCSTR)TOBSTRT(chstrProgGrpItemPATH))); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif




/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  That class
 *                returns files or directories where this one should only
 *                return files, in response to queries, getobject commands,
 *                etc.  It is overridden here to return TRUE only if the file
 *                (the information for which is contained in the function
 *                arguement pstFindData) is of type file.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if a file or FALSE if a directory
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CW32ProgGrpItemDataFile::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE);
    }
}
#endif


#ifdef WIN9XONLY
BOOL CW32ProgGrpItemDataFile::IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                             const char* strFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE);
    }
}
#endif




/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherrited from CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the PartComponent and GroupComponent
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef WIN9XONLY
void CW32ProgGrpItemDataFile::LoadPropertyValues95(CInstance* pInstance,
                                         LPCTSTR pszDrive,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszFSName,
                                         LPWIN32_FIND_DATA pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrFileName;
    CHString chstrFilePATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrFileName.Format(L"%s%s%s",(LPCWSTR)TOBSTRT(pszDrive),(LPCWSTR)TOBSTRT(pszPath),(LPCWSTR)TOBSTRT(pstFindData->cFileName));
    EscapeBackslashes(chstrFileName, chstrFileName);
    chstrFilePATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_CIMDATAFILE,
                        (LPCWSTR)chstrFileName);

    pInstance->SetCHString(IDS_Dependent, chstrFilePATH);
    pInstance->SetCharSplat(IDS_Antecedent, (LPCSTR)pvMoreData);
}
#endif


#ifdef NTONLY
void CW32ProgGrpItemDataFile::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrFileName;
    CHString chstrFilePATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrFileName.Format(L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
    EscapeBackslashes(chstrFileName, chstrFileName);
    chstrFilePATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_CIMDATAFILE,
                        (LPCWSTR)chstrFileName);

    pInstance->SetCHString(IDS_Dependent, chstrFilePATH);
    pInstance->SetWCHARSplat(IDS_Antecedent, (LPCWSTR)pvMoreData);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupcontents.h ===
//=================================================================

//

// Win32ProgramGroupContents.h -- Win32_ProgramGroup to Win32_ProgramGroupORItem

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/18/98    a-kevhu         Created
//
// Comment: Relationship between Win32_ProgramGroup and Win32_ProgramGroupORItem it contains
//
//=================================================================

// Property set identification
//============================
#define  PROPSET_NAME_WIN32PROGRAMGROUPCONTENTS L"Win32_ProgramGroupContents"

#define ID_FILEFLAG 0L
#define ID_DIRFLAG  1L

class CW32ProgGrpCont;

class CW32ProgGrpCont : public Provider 
{
    public:
        // Constructor/destructor
        //=======================
        CW32ProgGrpCont(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32ProgGrpCont() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

    private:
        VOID RemoveDoubleBackslashes(CHString& chstrIn);
        bool AreSimilarPaths(CHString& chstrPGCGroupComponent, CHString& chstrPGCPartComponent);

#ifdef WIN9XONLY
        HRESULT QueryForSubItemsAndCommit9x(CHString& chstrAntecedentPATH,
                                          CHString& chstrQuery,
                                          MethodContext* pMethodContext);
#endif
#ifdef NTONLY
        HRESULT QueryForSubItemsAndCommitNT(CHString& chstrAntecedentPATH,
                                          CHString& chstrQuery,
                                          MethodContext* pMethodContext);
#endif

        HRESULT DoesFileOrDirExist(WCHAR* wstrFullFileName, DWORD dwFileOrDirFlag);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupcontents.cpp ===
//=================================================================

//

// Win32ProgramCollectionProgramGroup.cpp -- Win32_ProgramGroup to Win32_ProgramGroupORItem

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/98    a-kevhu         Created
//
// Comment: Relationship between Win32_ProgramGroup and Win32_ProgramGroupORItem it contains
//
//=================================================================

#include "precomp.h"

#include "Win32ProgramGroupContents.h"
#include "LogicalProgramGroupItem.h"
#include "LogicalProgramGroup.h"
#include <frqueryex.h>
#include <utils.h>


// Property set declaration
//=========================
CW32ProgGrpCont MyCW32ProgGrpCont(PROPSET_NAME_WIN32PROGRAMGROUPCONTENTS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::CW32ProgGrpCont
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32ProgGrpCont::CW32ProgGrpCont(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::~CW32ProgGrpCont
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32ProgGrpCont::~CW32ProgGrpCont()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpCont::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    TRefPointerCollection<CInstance> GroupDirs;
    CHString chstrPGCGroupComponent;
    CHString chstrPGCPartComponent;

    if(pInstance == NULL)
    {
        return WBEM_E_FAILED;
    }

    pInstance->GetCHString(IDS_GroupComponent, chstrPGCGroupComponent);
    pInstance->GetCHString(IDS_PartComponent, chstrPGCPartComponent);

    if(AreSimilarPaths(chstrPGCGroupComponent, chstrPGCPartComponent))
    {
        CHString chstrPGCPartComponentFilenameOnly;
        chstrPGCPartComponentFilenameOnly = chstrPGCPartComponent.Mid(chstrPGCPartComponent.ReverseFind(_T('\\')));
        chstrPGCPartComponentFilenameOnly = chstrPGCPartComponentFilenameOnly.Left(chstrPGCPartComponentFilenameOnly.GetLength() - 1);

        // Need version of chstrPGCGroupComponent with escaped backslashes for the following query.
        CHString chstrPGCGroupComponentDblEsc;
        EscapeBackslashes(chstrPGCGroupComponent,chstrPGCGroupComponentDblEsc);
        // Also need to escape the quotes...
        CHString chstrPGCGroupComponentDblEscQuoteEsc;
        EscapeQuotes(chstrPGCGroupComponentDblEsc,chstrPGCGroupComponentDblEscQuoteEsc);
        CHString chstrProgGroupDirQuery;

        chstrProgGroupDirQuery.Format(L"SELECT * FROM Win32_LogicalProgramGroupDirectory WHERE Antecedent = \"%s\"", chstrPGCGroupComponentDblEscQuoteEsc);

        if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrProgGroupDirQuery,
                                                            &GroupDirs,
                                                            pInstance->GetMethodContext(),
                                                            IDS_CimWin32Namespace)))
        {
		    REFPTRCOLLECTION_POSITION pos;
		    CInstancePtr pProgramGroupDirInstance;

            // We'll need a normalized path for chstrPGCGroupComponent...
            CHString chstrPGCGroupComponentNorm;
            if(NormalizePath(chstrPGCGroupComponent, GetLocalComputerName(), IDS_CimWin32Namespace, NORMALIZE_NULL, chstrPGCGroupComponentNorm) == e_OK)
            {
		        if(GroupDirs.BeginEnum(pos))
		        {
                    CHString chstrPGDAntecedent;
                    CHString chstrPGDDependent;
                    CHString chstrPGDDependentFullFileName;
                    CHString chstrTemp;
                    CHString chstrLPGIClassName(PROPSET_NAME_LOGICALPRGGROUPITEM);

                    chstrLPGIClassName.MakeLower();
                    // Determine if the dependent (of this association class - PC) was a programgroup or a programgroupitem
                    chstrPGCPartComponent.MakeLower();
                    if(chstrPGCPartComponent.Find(chstrLPGIClassName) != -1)
                    {
                        // The dependent was a programgroupitem, so will look for matching file
                        // Go through PGD instances (should only be one) until find a PGDAntecedent that matches the PCAntecedent
                        for(pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos));
                            (pProgramGroupDirInstance != NULL) ;
                            pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos)))
			            {
				            pProgramGroupDirInstance->GetCHString(IDS_Antecedent, chstrPGDAntecedent);
                            pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrPGDDependent);

                            // Need a normalized version of the antecedent for the comparison below...
                            CHString chstrPGDAntecedentNorm;
                            if(NormalizePath(chstrPGDAntecedent, GetLocalComputerName(), IDS_CimWin32Namespace, NORMALIZE_NULL, chstrPGDAntecedentNorm) == e_OK)
                            {
                                // See if the PGDAntecedent matches the chstrPGCGroupComponentNorm
                                if(chstrPGDAntecedentNorm.CompareNoCase(chstrPGCGroupComponentNorm) == 0)
                                {
                                    // Got the proposed filename from the PCDependent at the beginning of GetObject.
                                    // Now Get the directory of the PGD (PGDDependent) associated with the PC antecedent
                                    chstrPGDDependentFullFileName = chstrPGDDependent.Mid(chstrPGDDependent.Find(_T('='))+2);
                                    chstrPGDDependentFullFileName = chstrPGDDependentFullFileName.Left(chstrPGDDependentFullFileName.GetLength() - 1);
                                    RemoveDoubleBackslashes(chstrPGDDependentFullFileName);
                                    chstrTemp.Format(L"%s%s",chstrPGDDependentFullFileName,chstrPGCPartComponentFilenameOnly);
                                    hr = DoesFileOrDirExist(_bstr_t(chstrTemp),ID_FILEFLAG);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            } // got normalized path for the antecedent
                        }
                    }
                    else
                    {
                        // The dependent was a programgroup, so will look for matching dir
                        // Go through PGD instances until find a PGDAntecedent that matches the PCAntecedent
                        for (pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos));
                             pProgramGroupDirInstance != NULL;
                             pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos)))
			            {
				            pProgramGroupDirInstance->GetCHString(IDS_Antecedent, chstrPGDAntecedent);
                            pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrPGDDependent);

                            // Need a normalized version of the antecedent for the comparison below...
                            CHString chstrPGDAntecedentNorm;
                            if(NormalizePath(chstrPGDAntecedent, GetLocalComputerName(), IDS_CimWin32Namespace, NORMALIZE_NULL, chstrPGDAntecedentNorm) == e_OK)
                            {
                                // See if the PGDAntecedent matches the PCAntecedent
                                if(chstrPGDAntecedentNorm.CompareNoCase(chstrPGCGroupComponentNorm) == 0)
                                {
                                    // Got the proposed filename (which is a directory name in this case) from the PCDependent at the beginning of GetObject.
                                    // Now Get the directory of the PGD (PGDDependent) associated with the PC antecedent
                                    chstrPGDDependentFullFileName = chstrPGDDependent.Mid(chstrPGDDependent.Find(_T('='))+2);
                                    chstrPGDDependentFullFileName = chstrPGDDependentFullFileName.Left(chstrPGDDependentFullFileName.GetLength() - 1);
                                    RemoveDoubleBackslashes(chstrPGDDependentFullFileName);
                                    chstrTemp.Format(L"%s\\%s",chstrPGDDependentFullFileName,chstrPGCPartComponentFilenameOnly);
                                    hr = DoesFileOrDirExist(_bstr_t(chstrTemp),ID_DIRFLAG);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            } // got normalized path for the antecedent
                        }
                    }
			        GroupDirs.EndEnum();
		        }	// IF BeginEnum
            } // got a normalized path successfully
	    }
    }
	return hr;
}




/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpCont::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL f3TokenOREqualArgs = FALSE;
    BOOL fGroupCompIsGroup = FALSE;
    _bstr_t bstrtGroupComponent;
    _bstr_t bstrtPartComponent;

    // I'm only going to optimize queries that had Antecedent and Dependent arguements OR'd together
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);
    if (pQuery2 != NULL)
    {
        variant_t vGroupComponent;
        variant_t vPartComponent;
        if(pQuery2->Is3TokenOR(L"GroupComponent", L"PartComponent", vGroupComponent, vPartComponent))
        {
            bstrtGroupComponent = V_BSTR(&vGroupComponent);
            bstrtPartComponent = V_BSTR(&vPartComponent);
            // I'm also going to insist that the arguements of the dependent and the antecedent be the same
            if(bstrtGroupComponent == bstrtPartComponent)
            {
                f3TokenOREqualArgs = TRUE;
            }
        }
    }

    // Only want to proceed if the Antecedent was a program group (Dependent can be either group or item, however).
    if(f3TokenOREqualArgs)
    {
        if(wcsstr((wchar_t*)bstrtGroupComponent,(wchar_t*)_bstr_t(PROPSET_NAME_LOGICALPRGGROUP)))
        {
            fGroupCompIsGroup = TRUE;
        }
    }

    if(fGroupCompIsGroup)
    {
        CHString chstrPGCPartComponent((wchar_t*)bstrtPartComponent);
        CHString chstrPGCGroupComponent((wchar_t*)bstrtGroupComponent);

        // We will get here is someone had a particular program group and asked for its associations.  This
        // provider will give back program groups and program group items associated with (underneath) the
        // supplied program group.  The query will look like the following:
        // select * from Win32_ProgramGroupContents where (PartComponent = "Win32_LogicalProgramGroup.Name=\"Default User:Accessories\"" OR GroupComponent = "Win32_LogicalProgramGroup.Name=\"Default User:Accessories\"")

        // Step 1: Do a GetInstanceByQuery to obtain the specific directory associated with the program group
        //==================================================================================================

        // Need version of chstrPGCGroupComponent with escaped backslashes for the following query...
        CHString chstrPGCGroupComponentDblEsc;
        EscapeBackslashes(chstrPGCGroupComponent,chstrPGCGroupComponentDblEsc);
        // Also need to escape the quotes...
        CHString chstrPGCGroupComponentDblEscQuoteEsc;
        EscapeQuotes(chstrPGCGroupComponentDblEsc,chstrPGCGroupComponentDblEscQuoteEsc);
        CHString chstrProgGroupDirQuery;
        TRefPointerCollection<CInstance> GroupDirs;

        chstrProgGroupDirQuery.Format(L"SELECT * FROM Win32_LogicalProgramGroupDirectory WHERE Antecedent = \"%s\"", (LPCWSTR)chstrPGCGroupComponentDblEscQuoteEsc);

        if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrProgGroupDirQuery,
                                                            &GroupDirs,
                                                            pMethodContext,
                                                            IDS_CimWin32Namespace)))
        {
            // Step 2: Eunumerate all the program groups (dirs) and program group items (files) found underneath it
            //=====================================================================================================

            REFPTRCOLLECTION_POSITION pos;

	        if(GroupDirs.BeginEnum(pos))
	        {
                CHString chstrDependent;
                CHString chstrFullPathName;
                CHString chstrPath;
                CHString chstrDrive;
                CHString chstrAntecedent;
                CHString chstrSearchPath;

    	        CInstancePtr pProgramGroupDirInstance;

                for (pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos)) ;
                    (pProgramGroupDirInstance != NULL) && (SUCCEEDED(hr)) ;
                     pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos)) )
			    {
                    // For each program group, get the drive and path associated on disk with it:
                    pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrDependent);
                    chstrFullPathName = chstrDependent.Mid(chstrDependent.Find(_T('='))+1);
                    chstrDrive = chstrFullPathName.Mid(1,2);
                    chstrPath = chstrFullPathName.Mid(3);
                    chstrPath = chstrPath.Left(chstrPath.GetLength() - 1);
                    chstrPath += L"\\\\";

                    // Query that directory for all the **CIM_LogicalFile** instances (of any type) it contains:
                    chstrSearchPath.Format(L"%s%s",chstrDrive,chstrPath);

                    // The function QueryForSubItemsAndCommit needs a search string with single backslashes...
                    RemoveDoubleBackslashes(chstrSearchPath);
#ifdef WIN9XONLY
                    hr = QueryForSubItemsAndCommit9x(chstrPGCGroupComponent, chstrSearchPath, pMethodContext);
#endif
#ifdef NTONLY
                    hr = QueryForSubItemsAndCommitNT(chstrPGCGroupComponent, chstrSearchPath, pMethodContext);
#endif
			    }
                GroupDirs.EndEnum();
            }
        }  // GetInstancesByQuery succeeded
    }
    else
    {
        hr = EnumerateInstances(pMethodContext);
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpCont::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> ProgGroupDirs;

    // Step 1: Get an enumeration of all the ProgramGroupDirectory association class instances
    if SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(L"Win32_LogicalProgramGroupDirectory", &ProgGroupDirs, IDS_CimWin32Namespace, pMethodContext))
    {
	    REFPTRCOLLECTION_POSITION pos;

	    if(ProgGroupDirs.BeginEnum(pos))
	    {
            CHString chstrDependent;
            CHString chstrFullPathName;
            CHString chstrPath;
            CHString chstrDrive;
            CHString chstrAntecedent;
            CHString chstrSearchPath;

    	    CInstancePtr pProgramGroupDirInstance;

            for (pProgramGroupDirInstance.Attach(ProgGroupDirs.GetNext(pos)) ;
                (pProgramGroupDirInstance != NULL) && (SUCCEEDED(hr)) ;
                 pProgramGroupDirInstance.Attach(ProgGroupDirs.GetNext(pos)) )
			{
                // Step 2: For each program group, get the drive and path associated on disk with it:
                pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrDependent);
                chstrFullPathName = chstrDependent.Mid(chstrDependent.Find(_T('='))+1);
                chstrDrive = chstrFullPathName.Mid(1,2);
                chstrPath = chstrFullPathName.Mid(3);
                chstrPath = chstrPath.Left(chstrPath.GetLength() - 1);
                chstrPath += _T("\\\\");

                // Step 3: For each program group, get the user account it is associated with:
                pProgramGroupDirInstance->GetCHString(IDS_Antecedent, chstrAntecedent);

                // Step 4: Query that directory for all the **CIM_LogicalFile** instances (of any type) it contains:
                chstrSearchPath.Format(L"%s%s",chstrDrive,chstrPath);

                // The function QueryForSubItemsAndCommit needs a search string with single backslashes...
                RemoveDoubleBackslashes(chstrSearchPath);
#ifdef WIN9XONLY
                hr = QueryForSubItemsAndCommit9x(chstrAntecedent, chstrSearchPath, pMethodContext);
#endif
#ifdef NTONLY
                hr = QueryForSubItemsAndCommitNT(chstrAntecedent, chstrSearchPath, pMethodContext);
#endif
			}
            ProgGroupDirs.EndEnum();
        }
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : QueryForSubItemsAndCommit
 *
 *  DESCRIPTION : Helper to fill property and commit instances of progcollectionproggroup
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CW32ProgGrpCont::QueryForSubItemsAndCommit9x(CHString& chstrGroupComponentPATH,
                                                     CHString& chstrQuery,
                                                     MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WIN32_FIND_DATA stFindData;
    ZeroMemory(&stFindData,sizeof(stFindData));
    SmartFindClose hFind;
    CHString chstrSearchString;;
    CHString chstrUserAccountAndGroup;
    CHString chstrPartComponent;

    chstrSearchString.Format(L"%s*.*",chstrQuery);
    hFind = FindFirstFile(TOBSTRT(chstrSearchString), &stFindData);
    DWORD dw = GetLastError();
    if (hFind == INVALID_HANDLE_VALUE || dw != ERROR_SUCCESS)
    {
        hr = WinErrorToWBEMhResult(GetLastError());
    }

    if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
    {
        hr = WBEM_S_NO_ERROR;
    }

    if(hr == WBEM_E_NOT_FOUND)
    {
        return WBEM_S_NO_ERROR;   // didn't find any files, but don't want the calling routine to abort
    }

    do
    {
        if((_tcscmp(stFindData.cFileName, _T(".")) != 0) &&
          (_tcscmp(stFindData.cFileName, _T("..")) != 0))
        {
            if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                // It is a program group item (a file)
                CInstancePtr pInstance(CreateNewInstance(pMethodContext),false);
                if(pInstance != NULL)
                {
                    // Need to set antecedent and dependent.  Antecedent is the group we were passed
                    // in (in chstrGroupComponentPATH); dependent is the (in this case) a Win32_ProgramGroupItem,
                    // since we found a file.
                    chstrUserAccountAndGroup = chstrGroupComponentPATH.Mid(chstrGroupComponentPATH.Find(_T('='))+2);
                    chstrUserAccountAndGroup = chstrUserAccountAndGroup.Left(chstrUserAccountAndGroup.GetLength() - 1);

                    chstrPartComponent.Format(L"\\\\%s\\%s:%s.Name=\"%s\\\\%s\"",
                                          (LPCWSTR)GetLocalComputerName(),
                                          IDS_CimWin32Namespace,
                                          L"Win32_LogicalProgramGroupItem",
                                          chstrUserAccountAndGroup,
                                          (LPCWSTR)CHString(stFindData.cFileName));
                    pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
                    pInstance->SetCHString(IDS_PartComponent, chstrPartComponent);
                    hr = pInstance->Commit();
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
            else if(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // It is a program group (a directory)
                CInstancePtr pInstance(CreateNewInstance(pMethodContext),false);
                if(pInstance != NULL)
                {
                    // Need to set antecedent and dependent.  Antecedent is the group we were passed
                    // in (in chstrGroupComponentPATH); dependent is the (in this case) a Win32_LogicalProgramGroup,
                    // since we found a directory.
                    chstrUserAccountAndGroup = chstrGroupComponentPATH.Mid(chstrGroupComponentPATH.Find(_T('='))+2);
                    chstrUserAccountAndGroup = chstrUserAccountAndGroup.Left(chstrUserAccountAndGroup.GetLength() - 1);

                    chstrPartComponent.Format(L"\\\\%s\\%s:%s.Name=\"%s\\\\%s\"",
                                          (LPCWSTR)GetLocalComputerName(),
                                          IDS_CimWin32Namespace,
                                          L"Win32_LogicalProgramGroup",
                                          chstrUserAccountAndGroup,
                                          (LPCWSTR)CHString(stFindData.cFileName));
                    pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
                    pInstance->SetCHString(IDS_PartComponent, chstrPartComponent);
                    hr = pInstance->Commit();
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
        if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
        {
            hr = WBEM_S_NO_ERROR;
        }
    }while((FindNextFile(hFind, &stFindData)) && (SUCCEEDED(hr)));

    return(hr);
}
#endif


#ifdef NTONLY
HRESULT CW32ProgGrpCont::QueryForSubItemsAndCommitNT(CHString& chstrGroupComponentPATH,
                                                     CHString& chstrQuery,
                                                     MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WIN32_FIND_DATAW stFindData;
    ZeroMemory(&stFindData,sizeof(stFindData));
    SmartFindClose hFind;
    _bstr_t bstrtSearchString((LPCTSTR)chstrQuery);
    WCHAR wstrDriveAndPath[_MAX_PATH];
    CHString chstrUserAccountAndGroup;
    CHString chstrPartComponent;

    wcscpy(wstrDriveAndPath,(wchar_t*)bstrtSearchString);
    bstrtSearchString += L"*.*";

    hFind = FindFirstFileW((wchar_t*)bstrtSearchString, &stFindData);
    DWORD dw = GetLastError();
    if (hFind == INVALID_HANDLE_VALUE || dw != ERROR_SUCCESS)
    {
        hr = WinErrorToWBEMhResult(GetLastError());
    }

    if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
    {
        hr = WBEM_S_NO_ERROR;
    }

    if(hr == WBEM_E_NOT_FOUND)
    {
        return WBEM_S_NO_ERROR;   // didn't find any files, but don't want the calling routine to abort
    }

    do
    {
        if((wcscmp(stFindData.cFileName, L".") != 0) &&
          (wcscmp(stFindData.cFileName, L"..") != 0))
        {
            if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                // It is a program group item (a file)
                CInstancePtr pInstance(CreateNewInstance(pMethodContext),false);
                if(pInstance != NULL)
                {
                    // Need to set antecedent and dependent.  Antecedent is the group we were passed
                    // in (in chstrGroupComponentPATH); dependent is the (in this case) a Win32_ProgramGroupItem,
                    // since we found a file.
                    chstrUserAccountAndGroup = chstrGroupComponentPATH.Mid(chstrGroupComponentPATH.Find(_T('='))+2);
                    chstrUserAccountAndGroup = chstrUserAccountAndGroup.Left(chstrUserAccountAndGroup.GetLength() - 1);

                    chstrPartComponent.Format(_T("\\\\%s\\%s:%s.Name=\"%s\\\\%s\""),
                                          (LPCTSTR)GetLocalComputerName(),
                                          IDS_CimWin32Namespace,
                                          _T("Win32_LogicalProgramGroupItem"),
                                          chstrUserAccountAndGroup,
                                          (LPCTSTR)CHString(stFindData.cFileName));
                    pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
                    pInstance->SetCHString(IDS_PartComponent, chstrPartComponent);
                    hr = pInstance->Commit();
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
            else if(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // It is a program group (a directory)
                CInstancePtr pInstance (CreateNewInstance(pMethodContext),false);
                if(pInstance != NULL)
                {
                    // Need to set antecedent and dependent.  Antecedent is the group we were passed
                    // in (in chstrGroupComponentPATH); dependent is the (in this case) a Win32_LogicalProgramGroup,
                    // since we found a directory.
                    chstrUserAccountAndGroup = chstrGroupComponentPATH.Mid(chstrGroupComponentPATH.Find(_T('='))+2);
                    chstrUserAccountAndGroup = chstrUserAccountAndGroup.Left(chstrUserAccountAndGroup.GetLength() - 1);

                    chstrPartComponent.Format(_T("\\\\%s\\%s:%s.Name=\"%s\\\\%s\""),
                                          (LPCTSTR)GetLocalComputerName(),
                                          IDS_CimWin32Namespace,
                                          _T("Win32_LogicalProgramGroup"),
                                          chstrUserAccountAndGroup,
                                          (LPCTSTR)CHString(stFindData.cFileName));
                    pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
                    pInstance->SetCHString(IDS_PartComponent, chstrPartComponent);
                    hr = pInstance->Commit();
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
        if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
        {
            hr = WBEM_S_NO_ERROR;
        }
    }while((FindNextFileW(hFind, &stFindData)) && (SUCCEEDED(hr)));

    return(hr);
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : RemoveDoubleBackslashes
 *
 *  DESCRIPTION : Helper to change double backslashes to single backslashes
 *
 *  INPUTS      : CHString& containing the string with double backslashes,
 *                which will be changed by this function to the new string.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

VOID CW32ProgGrpCont::RemoveDoubleBackslashes(CHString& chstrIn)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(L"\\\\");
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    chstrIn = chstrBuildString;
}


/*****************************************************************************
 *
 *  FUNCTION    : DoesFileOrDirExist
 *
 *  DESCRIPTION : Helper to determine if a file or a directory exists
 *
 *  INPUTS      : wstrFullFileName, the full path name of the file
 *                dwFileOrDirFlag, a flag indicating whether we want to check
 *                    for the existence of a file or a directory
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpCont::DoesFileOrDirExist(WCHAR* wstrFullFileName, DWORD dwFileOrDirFlag)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef WIN9XONLY
    {
        WIN32_FIND_DATA stFindData;
        //HANDLE hFind = NULL;
        SmartFindClose hFind;
        hFind = FindFirstFile(TOBSTRT(wstrFullFileName), &stFindData);
        DWORD dw = GetLastError();
        if(hFind != INVALID_HANDLE_VALUE && dw == ERROR_SUCCESS)
        {
            if((stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (dwFileOrDirFlag == ID_DIRFLAG))
            {
                hr = S_OK;
            }
             if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (dwFileOrDirFlag == ID_FILEFLAG))
            {
                hr = S_OK;
            }
        }
    }
#endif
#ifdef NTONLY
    {
        WIN32_FIND_DATAW stFindData;
        //HANDLE hFind = NULL;
        SmartFindClose hFind;
        hFind = FindFirstFileW(wstrFullFileName, &stFindData);
        DWORD dw = GetLastError();
        if(hFind != INVALID_HANDLE_VALUE && dw == ERROR_SUCCESS)
        {
            if((stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (dwFileOrDirFlag == ID_DIRFLAG))
            {
                hr = S_OK;
            }
             if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (dwFileOrDirFlag == ID_FILEFLAG))
            {
                hr = S_OK;
            }
        }
    }
#endif
    return hr;
}



bool CW32ProgGrpCont::AreSimilarPaths(CHString& chstrPGCGroupComponent, CHString& chstrPGCPartComponent)
{
    bool fRet = false;

    long EqualSign1 = -1L;
    long EqualSign2 = -1L;

    EqualSign1 = chstrPGCPartComponent.Find(L'=');
    EqualSign2 = chstrPGCGroupComponent.Find(L'=');

    if(EqualSign1 != -1L && EqualSign2 != -1L)
    {
        CHString chstrPartPath = chstrPGCPartComponent.Mid(EqualSign1+1);
        CHString chstrGroupPath = chstrPGCGroupComponent.Mid(EqualSign2+1);
        chstrGroupPath = chstrGroupPath.Left(chstrGroupPath.GetLength()-1);
        long lPosLastBackslash = chstrPartPath.ReverseFind(L'\\');
        if(lPosLastBackslash != -1L)
        {
            chstrPartPath = chstrPartPath.Left(lPosLastBackslash - 1);

            if(chstrPartPath.CompareNoCase(chstrGroupPath) == 0)
            {
                fRet = true;
            }
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupitemdatafile.h ===
//=================================================================

//

// Win32ProgramGroupItemDataFile.h -- Win32_LogicalProgramGroupItem to CIM_DataFile

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/98    a-kevhu         Created
//
// Comment: Relationship between Win32_LogicalProgramGroupItem and CIM_DataFile
//
//=================================================================

#ifndef _WIN32PROGRAMGROUPITEMDATAFILE_H
#define _WIN32PROGRAMGROUPITEMDATAFILE_H


// Property set identification
//============================
#define  PROPSET_NAME_WIN32LOGICALPROGRAMGROUPITEM_CIMDATAFILE L"Win32_LogicalProgramGroupItemDataFile"

#include "implement_logicalfile.h"

class CW32ProgGrpItemDataFile : public CImplement_LogicalFile 
{
    public:
        // Constructor/destructor
        //=======================
        CW32ProgGrpItemDataFile(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32ProgGrpItemDataFile() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

    protected:
       
       // Overridable function inherrited from CImplement_LogicalFile
#ifdef WIN9XONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                               const char* strFullPathName);

        virtual void LoadPropertyValues95(CInstance* pInstance,
                                          LPCTSTR pszDrive, 
                                          LPCTSTR pszPath, 
                                          LPCTSTR pszFSName, 
                                          LPWIN32_FIND_DATA pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual void LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif


    private:
        
        HRESULT ExecQueryType1(MethodContext* pMethodContext, CHString& chstrProgGroupItemName);
        HRESULT ExecQueryType2(MethodContext* pMethodContext, CHString& chstrDF);

#ifdef NTONLY
        HRESULT EnumerateInstancesNT(MethodContext* pMethodContex);
        HRESULT AssociatePGIToDFNT(MethodContext* pMethodContext,
                                   CHString& chstrDF,
                                   CHString& chstrProgGrpItemPATH);
#endif
#ifdef WIN9XONLY
        HRESULT EnumerateInstances9x(MethodContext* pMethodContext);
        HRESULT AssociatePGIToDF95(MethodContext* pMethodContext,
                                   CHString& chstrDF,
                                   CHString& chstrProgGrpItemPATH);
#endif

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupwin32directory.cpp ===
//=================================================================

//

// Win32ProgramGroupWin32Directory.cpp -- Win32_LogicalProgramGroup to Win32_Directory

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between win32_logicalprogramgroup and contained win32_directories
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "userhive.h"

#include "Win32ProgramGroupWin32Directory.h"
#include "directory.h"


// Property set declaration
//=========================
CW32ProgGrpW32Dir MyW32ProgGrpW32Dir(PROPSET_NAME_WIN32LOGICALPROGRAMGROUP_WIN32DIRECTORY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::CW32ProgGrpW32Dir
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32ProgGrpW32Dir::CW32ProgGrpW32Dir(LPCWSTR setName, LPCWSTR pszNamespace)
:CImplement_LogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::~CW32ProgGrpW32Dir
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32ProgGrpW32Dir::~CW32ProgGrpW32Dir()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpW32Dir::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrProgGroup;
    CHString chstrDataFile;
    HRESULT hr = WBEM_E_NOT_FOUND;
    CInstancePtr pProgGroup;
    CInstancePtr pDataFile;

    if(pInstance != NULL)
    {
        // Get the two paths
        pInstance->GetCHString(IDS_Antecedent, chstrProgGroup);
        pInstance->GetCHString(IDS_Dependent, chstrDataFile);

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrProgGroup, &pProgGroup, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDataFile, &pDataFile, pInstance->GetMethodContext())))
            {
                // Double check that the dependent instance really is a directory (or derived) instance...
                CHString chstrClass;
                if(pDataFile->GetCHString(IDS___Class, chstrClass) &&
                    CWbemProviderGlue::IsDerivedFrom(L"CIM_Directory", chstrClass, pDataFile->GetMethodContext(), IDS_CimWin32Namespace))
                {
                    // Make sure the group is still a group that is registered (not just left over directory)
                    CHString chstrUserPart;
                    CHString chstrPathPart;
#ifdef NTONLY
                    {
                        CHString chstrProgGroupName;
                        pProgGroup->GetCHString(IDS_Name,chstrProgGroupName);
                        chstrUserPart = chstrProgGroupName.SpanExcluding(L":");
                        chstrPathPart = chstrProgGroupName.Mid(chstrUserPart.GetLength() + 1);
                        if(chstrUserPart.CompareNoCase(IDS_Default_User) == 0)
                        {
                            // Default user and All Users are not part of the user hive, they just are.
                            // Since we got this far, we know that the file exists in the specified location
                            // within the program group directory by virtue of the two GetInstanceByPath calls
                            // which would not have succeeded had the file not existed.  So all is well.
                            hr = WBEM_S_NO_ERROR;
                        }
                        else if(chstrUserPart.CompareNoCase(IDS_All_Users) == 0)
                        {
                            hr = WBEM_S_NO_ERROR;
                        }
                        else
                        {
                            CUserHive cuhUser;
                            TCHAR szKeyName[_MAX_PATH];
                            ZeroMemory(szKeyName,sizeof(szKeyName));
                            if (cuhUser.Load(chstrUserPart, szKeyName) == ERROR_SUCCESS)
		                    {
                                try
                                {
                                    CRegistry reg;
                                    CHString chstrTemp;
                                    CHString chstrProfileImagePath = L"ProfileImagePath";
                                    CHString chstrProfileImagePathValue;
                                    chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                                    chstrTemp += szKeyName;
                                    if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                                    {
                                        // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000"
                                        // Need to expand out the environment variable.
                                        TCHAR tstrProfilesDir[_MAX_PATH];
                                        ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
                                        DWORD dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfilesDir,_MAX_PATH);
                                        if(dw != 0 && dw < _MAX_PATH)
                                        {
                                            CHString chstrProgGroupDir;
                                            chstrProgGroupDir.Format(L"%s\\",
                                                                     (LPCWSTR)tstrProfilesDir);
                                            // Create a directory name based on what the registry says it should be
                                            CHString chstrDirectoryName;
                                            chstrDirectoryName.Format(L"%s%s", (LPCWSTR)chstrProgGroupDir, (LPCWSTR)chstrPathPart);
                                            EscapeBackslashes(chstrDirectoryName,chstrDirectoryName);
                                            // If the directory name above is a portion of chstrDataFile, we are valid.
                                            chstrDataFile.MakeUpper();
                                            chstrDirectoryName.MakeUpper();
                                            if(chstrDataFile.Find(chstrDirectoryName) > -1)
                                            {
                                                // Everything seems to actually exist.
                                                hr = WBEM_S_NO_ERROR;
                                            }
                                        } // expanded environment variable
                                        reg.Close();
                                    }  // could open registry key for profilelist
                                }
                                catch ( ... )
                                {
                                    cuhUser.Unload(szKeyName);
                                    throw ;
                                }

                                cuhUser.Unload(szKeyName);
                            } // userhive loaded
                        } // else a user-hive user account
                    } // was nt
#endif
#ifdef WIN9XONLY
                    {
                        // chstrUserPart = chstrName.SpanExcluding(_T(":")); //known to be "All Users"
                        // chstrPathPart = chstrProgGroup.Mid(chstrUserPart.GetLength() + 1);
                        // Easy by comparison to nt case; everything always under %systemdir%\\Start Menu\\Programs
                        CRegistry reg;
                        CHString chstrTemp;
                        CHString chstrRegKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
                        if(reg.OpenCurrentUser(
                                    chstrRegKey,
                                    KEY_READ) == ERROR_SUCCESS)
                        {
                            if(reg.GetCurrentKeyValue(L"Programs",chstrTemp) == ERROR_SUCCESS)
                            {
                                // Create a directory name based on what the registry says it should be
                                // chstrTemp contains something like "C:\\WINDOWS\\Start Menu\\Programs".  So need to remove the "C:"
                                // and add a trailing "\\"
                                CHString chstrRegPathPart = chstrTemp.Mid(chstrTemp.Find(L":")+1);
                                chstrRegPathPart = chstrRegPathPart.Left(chstrRegPathPart.ReverseFind(L'\\'));
                                EscapeBackslashes(chstrRegPathPart,chstrRegPathPart);
                                // If the directory name above is a portion of chstrDataFile, we are valid.
                                chstrDataFile.MakeUpper();
                                chstrRegPathPart.MakeUpper();
                                if(chstrDataFile.Find(chstrRegPathPart) > -1)
                                {
                                    // Everything seems to actually exist.
                                    hr = WBEM_S_NO_ERROR;
                                }
                            }
                            reg.Close();
                        }
                    } // isnt
#endif
                }
            } //datafile instancebypath
        } //progroup instancebypath
    } // pinstance not null
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::ExecQuery
 *
 *  DESCRIPTION : Returns only the specific association asked for
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpW32Dir::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    // We optimize on two types of queries only: those in which the antecedent was specified only (the programgroupitem),
    // or those in which the dependent was specified only (the datafile).  All others result in an enumeration.

    HRESULT hr = WBEM_E_NOT_FOUND;

    CHStringArray achstrAntecedent;
    CHStringArray achstrDependent;
    DWORD dwAntecedents = 0;
    DWORD dwDependents = 0;

    pQuery.GetValuesForProp(IDS_Antecedent, achstrAntecedent);
    dwAntecedents = achstrAntecedent.GetSize();
    pQuery.GetValuesForProp(IDS_Dependent, achstrDependent);
    dwDependents = achstrDependent.GetSize();

    if(dwAntecedents == 1 && dwDependents == 0)
    {
        hr = ExecQueryType1(pMethodContext, achstrAntecedent[0]);
    }
    else if(dwDependents == 1 && dwAntecedents == 0)
    {
        hr = ExecQueryType2(pMethodContext, achstrDependent[0]);
    }
    else // type of query we don't optimize on
    {
        hr = EnumerateInstances(pMethodContext);
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::ExecQueryType1
 *
 *  DESCRIPTION : Processes queries where we have a program group.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 ****************************************************************************/
HRESULT CW32ProgGrpW32Dir::ExecQueryType1(MethodContext* pMethodContext, CHString& chstrProgGroupNameIn)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Were given a programgroup.  Happens when hit associators on a programgroup.
    // Need the program group name extracted from the antecedent:
    CHString chstrProgGroupName(chstrProgGroupNameIn);
    chstrProgGroupName = chstrProgGroupName.Mid(chstrProgGroupName.Find(_T('=')) + 2);
    chstrProgGroupName = chstrProgGroupName.Left(chstrProgGroupName.GetLength() - 1);

    CHString chstrUserPart;
    CHString chstrPathPart;
    CHString chstrDirectory;
    CHString chstrProgGroupDir;
    CHString chstrQuery;
    chstrUserPart = chstrProgGroupName.SpanExcluding(L":");
    chstrPathPart = chstrProgGroupName.Mid(chstrUserPart.GetLength() + 1);  // already has escaped backslashes at this point
    RemoveDoubleBackslashes(chstrPathPart,chstrPathPart);

#ifdef NTONLY
    {
        TCHAR tstrProfilesDir[_MAX_PATH];
        ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
        CRegistry regProfilesDir;
        CHString chstrProfilesDirectory = L"";
        regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                       L"ProfilesDirectory",
                                                       chstrProfilesDirectory);

        // if that entry is not present, try %systemroot%\profiles instead
        if(chstrProfilesDirectory.GetLength() == 0)
        {
            chstrProfilesDirectory = L"%systemroot%\\Profiles";
        }

        if(chstrProfilesDirectory.GetLength() > 0)
        {
            // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
            // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
            DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,tstrProfilesDir,_MAX_PATH);
            if(dw != 0 && dw < _MAX_PATH)
            {
                if(chstrUserPart.CompareNoCase(IDS_Default_User)==0)
                {
                    chstrProgGroupDir.Format(L"%s\\%s\\", tstrProfilesDir, IDS_Default_User);
                    chstrDirectory = chstrProgGroupDir + chstrPathPart;
                    hr = AssociatePGToDirNT(pMethodContext, chstrDirectory, chstrProgGroupNameIn);
                }
                else if(chstrUserPart.CompareNoCase(IDS_All_Users)==0)
                {
                    chstrProgGroupDir.Format(L"%s\\%s\\", tstrProfilesDir, IDS_All_Users);
                    chstrDirectory = chstrProgGroupDir + chstrPathPart;
                    hr = AssociatePGToDirNT(pMethodContext, chstrDirectory, chstrProgGroupNameIn);
                }
                else
                {
                    CUserHive cuhUser;
                    TCHAR szKeyName[_MAX_PATH];
                    ZeroMemory(szKeyName,sizeof(szKeyName));
                    // chstrUserPart contains double backslashes; need singles for it to work, so...
                    if(cuhUser.Load(RemoveDoubleBackslashes(chstrUserPart), szKeyName) == ERROR_SUCCESS)
		            {
                        try
                        {
                            CRegistry reg;
                            CHString chstrTemp;
                            CHString chstrProfileImagePath = L"ProfileImagePath";
                            CHString chstrProfileImagePathValue;
                            chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                            chstrTemp += szKeyName;
                            if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                            {
                                // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000". Expand it:
                                TCHAR tstrProfileImagePath[_MAX_PATH];
                                ZeroMemory(tstrProfileImagePath,sizeof(tstrProfileImagePath));
                                dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfileImagePath,_MAX_PATH);
                                if(dw != 0 && dw < _MAX_PATH)
                                {
                                    CHString chstrProgGroupDir;
                                    chstrProgGroupDir.Format(L"%s\\",
                                                             tstrProfileImagePath);
                                    // Create a directory name based on what the registry says it should be
                                    chstrDirectory = chstrProgGroupDir + chstrPathPart;
                                    hr = AssociatePGToDirNT(pMethodContext, chstrDirectory, chstrProgGroupNameIn);
                                }
                                reg.Close();
                            }  // could open registry key for profilelist
                        }
                        catch ( ... )
                        {
                            cuhUser.Unload(szKeyName);
                            throw ;
                        }

                        cuhUser.Unload(szKeyName);
                    }
                }
            } // expanded profiles directory successfully
        } // got profiles directory from registry
    }
#endif
#ifdef WIN9XONLY
    {
        // Easy by comparison to nt case; everything always under %systemdir%\\Start Menu\\Programs
        CRegistry reg;
        CHString chstrTemp;
        CHString chstrTemp2;
        CHString chstrRegKey = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
        if(reg.OpenCurrentUser(
                    chstrRegKey,
                    KEY_READ) == ERROR_SUCCESS)
        {
            if(reg.GetCurrentKeyValue(L"Programs",chstrTemp) == ERROR_SUCCESS)
            {
                // Need the name of the Start Menu directory (the user may have changed it under 9x...)
                if(reg.GetCurrentKeyValue(L"Start Menu",chstrTemp2) == ERROR_SUCCESS)
                {
                    chstrTemp2 = chstrTemp2.Mid(chstrTemp2.ReverseFind(L'\\'));
                    // Need to remove the "Programs" dir for this path...
                    int iLastWhackPos = chstrTemp.Find(chstrTemp2);
                    if(iLastWhackPos > -1)
                    {
                        chstrTemp = chstrTemp.Left(iLastWhackPos);
                        chstrDirectory = chstrTemp + L"\\" + chstrPathPart;
                        AssociatePGToDir95(pMethodContext, chstrDirectory, chstrProgGroupNameIn);
                    }
                }
            }
            reg.Close();
        }
    } // is nt?
#endif
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::ExecQueryType2
 *
 *  DESCRIPTION : Processes queries where we have a directory
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 ****************************************************************************/
HRESULT CW32ProgGrpW32Dir::ExecQueryType2(MethodContext* pMethodContext, CHString& chstrDependent)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // We were given a directory (happens when hit associators on a directory).
    // Need to find the corresponding programgroupitem and associate.
    CHString chstrModDependent(chstrDependent);

#ifdef NTONLY
    {
        CRegistry reg;
        BOOL fGotIt = FALSE;
        CHString chstrProfilesList = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
        if(reg.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
                                       chstrProfilesList,
                                       KEY_READ) == ERROR_SUCCESS)
        {
            CHString chstrSubKey;
            while(!fGotIt)
            {
                if(reg.GetCurrentSubKeyName(chstrSubKey) != ERROR_NO_MORE_ITEMS)
                {
                    CRegistry regUser;
                    CHString chstrUserSubKey;
                    chstrUserSubKey.Format(L"%s\\%s",(LPCWSTR)chstrProfilesList,(LPCWSTR)chstrSubKey);
                    if(regUser.Open(HKEY_LOCAL_MACHINE, chstrUserSubKey, KEY_READ) == ERROR_SUCCESS)
                    {
                        CHString chstrProfileImagePath;
                        if(regUser.GetCurrentKeyValue(L"ProfileImagePath", chstrProfileImagePath)
                                       == ERROR_SUCCESS)
                        {
                            WCHAR wstrProfilesDir[_MAX_PATH];
                            ZeroMemory(wstrProfilesDir,sizeof(wstrProfilesDir));
                            DWORD dw = ExpandEnvironmentStrings(chstrProfileImagePath,wstrProfilesDir,_MAX_PATH);
                            if(dw != 0 && dw < _MAX_PATH)
                            {
                                // Extract the directory pathname out of the dependent...
                                CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                                chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                                CHString chstrProfilesDirAdj;
                                EscapeBackslashes(CHString(wstrProfilesDir),chstrProfilesDirAdj);
                                chstrProfilesDirAdj += L"\\\\";
                                chstrProfilesDirAdj += IDS_Start_Menu;
                                CHString chstrDepPathNameUserPortion = chstrDepPathName.Left(chstrProfilesDirAdj.GetLength());
                                if(chstrDepPathNameUserPortion.CompareNoCase(chstrProfilesDirAdj) == 0)
                                {
                                    // This user profile matches that of the file we were given.  Don't need to continue while loop.
                                    fGotIt = TRUE;
                                    // Look up this user's account from the profile...
                                    CUserHive cuh;
                                    CHString chstrUserAccount;
                                    if(cuh.UserAccountFromProfile(regUser,chstrUserAccount) == ERROR_SUCCESS)
                                    {
                                        // Get the non-user portion out of the directory's pathname...
                                        CHString chstrDir = chstrDepPathName.Mid(chstrDepPathNameUserPortion.GetLength() + 2);
                                        // Assemble name of the logical program group...
                                        CHString chstrLPGName;
                                        EscapeBackslashes(chstrUserAccount, chstrUserAccount);
                                        chstrLPGName.Format(L"%s:%s",(LPCWSTR)chstrUserAccount, IDS_Start_Menu);
                                        if(chstrDir.GetLength() > 0)
                                        {
                                            chstrLPGName += L"\\\\";
                                            chstrLPGName += chstrDir;
                                        }

                                        // Construct a full PATH for the program group...
                                        CHString chstrLPGPATH;
                                        chstrLPGPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroup.Name=\"%s\"",
                                                             (LPCWSTR)GetLocalComputerName(),
                                                             IDS_CimWin32Namespace,
                                                             (LPCWSTR)chstrLPGName);

                                        // Can't just commit it here even though we have all the pieces, because
                                        // we never confirmed that such a directory exists.  We have only confirmed that
                                        // a directory matching the first pieces of the specified path exists.
                                        // Hence we call our friend...
                                        hr = AssociatePGToDirNT(pMethodContext, RemoveDoubleBackslashes(chstrDepPathName), chstrLPGPATH);
                                    }
                                }
                            }
                        }
                        regUser.Close();
                    }
                } // got subkey
                if(reg.NextSubKey() != ERROR_SUCCESS)
                {
                    break;
                }
            }
        }
        if(!fGotIt)
        {
            // Wasn't a match for any of the user hive entries, but could be default user or all users.
            CRegistry regProfilesDir;
            CHString chstrProfilesDirectory = L"";
            CHString chstrDefaultUserProfile;
            regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                           L"ProfilesDirectory",
                                           chstrProfilesDirectory);

            regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                           L"DefaultUserProfile",
                                           chstrDefaultUserProfile);
            if(chstrProfilesDirectory.GetLength() > 0)
            {
                // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
                // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
                WCHAR wstrProfilesDir[_MAX_PATH];
                ZeroMemory(wstrProfilesDir,sizeof(wstrProfilesDir));
                DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,wstrProfilesDir,_MAX_PATH);
                if((dw != 0) && (dw < _MAX_PATH) && (chstrDefaultUserProfile.GetLength() > 0))
                {
                    // First see if default user
                    CHString chstrTemp;
                    chstrTemp.Format(L"%s\\%s\\%s",wstrProfilesDir,(LPCWSTR)chstrDefaultUserProfile,IDS_Start_Menu);
                    // Extract the directory pathname out of the dependent...
                    CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                    chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                    EscapeBackslashes(chstrTemp,chstrTemp);
                    // Get the left lProfDirLen chars out of the file we were given...
                    CHString chstrProfDir = chstrDepPathName.Left(chstrTemp.GetLength());
                    // Get the directory portion out of the file's pathname...
                    CHString chstrDir = chstrDepPathName.Mid(chstrProfDir.GetLength() + 2);

                    if(chstrProfDir.CompareNoCase(chstrTemp)==0)
                    {
                        // it was the default user
                        fGotIt = TRUE;
                        // Construct a full PATH for the program group item...
                        CHString chstrLPGName;
                        chstrLPGName.Format(L"%s:%s", (LPCWSTR)chstrDefaultUserProfile, IDS_Start_Menu);
                        if(chstrDir.GetLength() > 0)
                        {
                            chstrLPGName += L"\\\\";
                            chstrLPGName += chstrDir;
                        }

                        CHString chstrLPGPATH;
                        chstrLPGPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroup.Name=\"%s\"",
                                             (LPCWSTR)GetLocalComputerName(),
                                             IDS_CimWin32Namespace,
                                             (LPCWSTR)chstrLPGName);

                        // Can't just commit it here even though we have all the pieces, because
                        // we never confirmed that such a directory exists.  We have only confirmed that
                        // a directory matching the first pieces of the specified path exists.
                        // Hence we call our friend...
                        // Need to remove the "Programs" dir for this path...
                        hr = AssociatePGToDirNT(pMethodContext, RemoveDoubleBackslashes(chstrDepPathName), chstrLPGPATH);
                    }
                    // Then see if it was All Users
                    if(!fGotIt)
                    {
                        CHString chstrAllUsersProfile;
                        regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                       L"AllUsersProfile",
                                                       chstrAllUsersProfile);
                        if(chstrAllUsersProfile.GetLength() > 0)
                        {
                            chstrTemp.Format(L"%s\\%s\\%s",wstrProfilesDir,(LPCWSTR)chstrAllUsersProfile,IDS_Start_Menu);
                            EscapeBackslashes(chstrTemp,chstrTemp);
                            chstrProfDir = chstrDepPathName.Left(chstrTemp.GetLength());
                            chstrDir = chstrDepPathName.Mid(chstrProfDir.GetLength() + 2);
                            if((chstrProfDir.CompareNoCase(chstrTemp)==0) && (chstrAllUsersProfile.GetLength() > 0))
                            {
                                // it was All Users
                                fGotIt = TRUE;
                                // Construct a full PATH for the program group item...
                                CHString chstrLPGName;
                                chstrLPGName.Format(L"%s:%s",chstrAllUsersProfile,IDS_Start_Menu);
                                if(chstrDir.GetLength() > 0)
                                {
                                    chstrLPGName += L"\\\\";
                                    chstrLPGName += chstrDir;
                                }
                            
                                //EscapeBackslashes(chstrLPGName,chstrTemp);
                                CHString chstrLPGPATH;
                                chstrLPGPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroup.Name=\"%s\"",
                                                     (LPCWSTR)GetLocalComputerName(),
                                                     IDS_CimWin32Namespace,
                                                     (LPCWSTR)chstrLPGName);

                                // Can't just commit it here even though we have all the pieces, because
                                // we never confirmed that such a directory exists.  We have only confirmed that
                                // a directory matching the first pieces of the specified path exists.
                                // Hence we call our friend...
                                hr = AssociatePGToDirNT(pMethodContext, RemoveDoubleBackslashes(chstrDepPathName), chstrLPGPATH);
                            }
                        }
                    }
                } // expanded env variables
            } //got profiles dir
        } // wasn't a userhive entry
    } // nt
#endif
#ifdef WIN9XONLY
    {
        // Easy by comparison to nt case; everything always under %systemdir%\\Start Menu\\Programs
        CRegistry reg;
        CHString chstrTemp;
        CHString chstrRegKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
        if(reg.OpenCurrentUser(
                    chstrRegKey,
                    KEY_READ) == ERROR_SUCCESS)
        {
            if(reg.GetCurrentKeyValue(L"Programs",chstrTemp) == ERROR_SUCCESS)
            {
                // Extract the directory pathname out of the dependent...
                CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                // Get the non-user portion out of the dependent's pathname...
                CHString chstrItem = chstrDepPathName.Mid(chstrTemp.GetLength() + 1);

                // Construct a full PATH for the program group item...
                CHString chstrLPGName;
                chstrLPGName.Format(L"All Users:%s",(LPCWSTR)chstrItem);
                EscapeBackslashes(chstrLPGName,chstrTemp);
                CHString chstrLPGPATH;
                chstrLPGPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroup.Name=\"%s\"",
                                     (LPCWSTR)GetLocalComputerName(),
                                     IDS_CimWin32Namespace,
                                     (LPCWSTR)chstrTemp);

                // Can't just commit it here even though we have all the pieces, because
                // we never confirmed that such a directory exists.  We have only confirmed that
                // a directory matching the first pieces of the specified path exists.
                // Hence we call our friend...
                // Need to remove the "Programs" dir for this path...
                hr = AssociatePGToDir95(pMethodContext, RemoveDoubleBackslashes(chstrDepPathName), chstrLPGPATH);
            }
            reg.Close();
        }
    } // os type
#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpW32Dir::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
#ifdef NTONLY
        hr = EnumerateInstancesNT(pMethodContext);
#endif
#ifdef WIN9XONLY
        hr = EnumerateInstances9x(pMethodContext);
#endif
    return hr;
}


#ifdef NTONLY
HRESULT CW32ProgGrpW32Dir::EnumerateInstancesNT(MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LProgGroups;

    // Obtain, from the registry, the directory where proifles are stored:
    TCHAR tstrProfilesDir[_MAX_PATH];
    ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
    CRegistry regProfilesDir;
    CHString chstrProfilesDirectory = L"";
    regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                   L"ProfilesDirectory",
                                                   chstrProfilesDirectory);
    // if that entry is not present, try %systemroot%\profiles instead
    if(chstrProfilesDirectory.GetLength() == 0)
    {
        chstrProfilesDirectory = L"%systemroot%\\Profiles";
    }

    if(chstrProfilesDirectory.GetLength() > 0)
    {
        // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
        // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
        DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,tstrProfilesDir,_MAX_PATH);
        if(dw != 0 && dw < _MAX_PATH)
        {
            // Get list of program groups
            if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(L"Win32_LogicalProgramGroup"),
                                                            &LProgGroups,
                                                            IDS_CimWin32Namespace,
                                                            pMethodContext)))
            {
                REFPTRCOLLECTION_POSITION pos;

                if(LProgGroups.BeginEnum(pos))
                {
                    CInstancePtr pProgGroup;
                    CHString chstrName;
                    CHString chstrProgGrpPath;
                    CHString chstrUserPart;
                    CHString chstrPathPart;
                    CHString chstrProgGroupDir;

                    // Walk through the proggroups
                    for (pProgGroup.Attach(LProgGroups.GetNext(pos));
                        SUCCEEDED(hr) && (pProgGroup != NULL) && SUCCEEDED(hr);
                        pProgGroup.Attach(LProgGroups.GetNext(pos)))
                    {
                        CHString chstrQueryPath;
                        CHString chstrQuery;

                        pProgGroup->GetCHString(IDS_Name, chstrName);     // looks like "Default User:Accessories\\Multimedia" for instance
                        pProgGroup->GetCHString(IDS___Path, chstrProgGrpPath); // goes back as 'Antecedent'
                        // On NT, under %systemdir%\\Profiles, various directories corresponding to users are
                        // listed.  Under each is Start Menu\\Programs, under which are the directories listed
                        // by Win32_LogicalProgramGroup.
                        chstrUserPart = chstrName.SpanExcluding(L":");
                        chstrPathPart = chstrName.Mid(chstrUserPart.GetLength() + 1);
                        if(chstrUserPart.CompareNoCase(IDS_Default_User)==0)
                        {
                            chstrProgGroupDir.Format(L"%s\\%s\\%s", tstrProfilesDir, IDS_Default_User, (LPCTSTR)chstrPathPart);
                            hr = AssociatePGToDirNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                        }
                        else if(chstrUserPart.CompareNoCase(IDS_All_Users)==0)
                        {
                            chstrProgGroupDir.Format(L"%s\\%s\\%s", tstrProfilesDir, IDS_All_Users, (LPCTSTR)chstrPathPart);
                            hr = AssociatePGToDirNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                        }
                        else // need to get the sid corresponding to that user to then look up ProfileImagePath under
                             // the registry key HKLM\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList
                        {
                            CUserHive cuhUser;
                            //CHString chstrKeyName;
                            TCHAR szKeyName[_MAX_PATH];
                            ZeroMemory(szKeyName,sizeof(szKeyName));
                            if(cuhUser.Load(chstrUserPart, szKeyName) == ERROR_SUCCESS)
                            {
                                try
                                {
                                    CRegistry reg;
                                    CHString chstrTemp;
                                    CHString chstrProfileImagePath = L"ProfileImagePath";
                                    CHString chstrProfileImagePathValue;
                                    chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                                    chstrTemp += szKeyName;
                                    if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                                    {
                                        // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000". Expand it:
                                        TCHAR tstrProfileImagePath[_MAX_PATH];
                                        ZeroMemory(tstrProfileImagePath,sizeof(tstrProfileImagePath));
                                        dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfileImagePath,_MAX_PATH);
                                        if(dw != 0 && dw < _MAX_PATH)
                                        {
                                            CHString chstrProgGroupDir;
                                            chstrProgGroupDir.Format(L"%s\\%s",
                                                                     tstrProfileImagePath,
                                                                     (LPCTSTR)chstrPathPart);
                                            // Create a directory name based on what the registry says it should be
                                            hr = AssociatePGToDirNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                                        }
                                        reg.Close();
                                    }  // could open registry key for profilelist
                                }
                                catch ( ... )
                                {
                                    cuhUser.Unload(szKeyName);
                                    throw ;
                                }

                                cuhUser.Unload(szKeyName);
                            }  // if load worked; otherwise we skip that one
                        } // which user
                    } // while programgroups
                    LProgGroups.EndEnum();
                } // if BeginEnum of programgroup worked
            } // Got all instances of win32_logicalprogramgroup
        } // expanded environment strings contained in profiles directory
    } // Got profiles directory from registry
    return hr;
}
#endif

#ifdef WIN9XONLY
HRESULT CW32ProgGrpW32Dir::EnumerateInstances9x(MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LProgGroups;

    // Get list of program groups
    if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(_T("Win32_LogicalProgramGroup")),
                                                    &LProgGroups,
                                                    IDS_CimWin32Namespace,
                                                    pMethodContext)))
    {
        REFPTRCOLLECTION_POSITION pos;

        if(LProgGroups.BeginEnum(pos))
        {
            CInstancePtr pProgGroup;
            CHString chstrName;
            CHString chstrProgGrpPath;
            CHString chstrUserPart;
            CHString chstrPathPart;

            // Walk through the proggroups
            for (pProgGroup.Attach(LProgGroups.GetNext(pos));
                SUCCEEDED(hr) && (pProgGroup != NULL) && SUCCEEDED(hr);
                pProgGroup.Attach(LProgGroups.GetNext(pos)))
            {
                CHString chstrQuery;

                pProgGroup->GetCHString(IDS_Name, chstrName);     // looks like "Default User:Accessories\\Multimedia" for instance
                pProgGroup->GetCHString(IDS___Path, chstrProgGrpPath); // goes back as 'Antecedent'

                chstrUserPart = chstrName.SpanExcluding(L":");
                chstrPathPart = chstrName.Mid(chstrUserPart.GetLength() + 1);

                // Easy by comparison to nt case; everything always under %systemdir%\\Start Menu\\Programs
                CRegistry reg;
                CHString chstrTemp;
                CHString chstrTemp2;
                if(reg.OpenCurrentUser(
                            L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                            KEY_READ) == ERROR_SUCCESS)
                {
                    if(reg.GetCurrentKeyValue(L"Programs", chstrTemp) == ERROR_SUCCESS)
                    {
                        // Need the name of the Start Menu directory (the user may have changed it under 9x...)
                        if(reg.GetCurrentKeyValue(L"Start Menu",chstrTemp2) == ERROR_SUCCESS)
                        {
                            chstrTemp2 = chstrTemp2.Mid(chstrTemp2.ReverseFind(L'\\'));
                            // chstrTemp contains something like "C:\\WINDOWS\\Start Menu\\Programs".
                            // Need to remove the "Programs" dir for this path...
                            int iLastWhackPos = chstrTemp.Find(chstrTemp2);
                            if(iLastWhackPos > -1)
                            {
                                chstrTemp = chstrTemp.Left(iLastWhackPos);
                                chstrTemp += _T("\\");
                                chstrTemp += chstrPathPart;
                                hr = AssociatePGToDir95(pMethodContext, chstrTemp, chstrProgGrpPath);
                            }
                        }
                    }
                    reg.Close() ;
                }
            } // while programgroups
            LProgGroups.EndEnum();
        } // if BeginEnum of programgroup worked
    } // Got all instances of win32_logicalprogramgroup
    return hr;
}
#endif



#ifdef NTONLY
HRESULT CW32ProgGrpW32Dir::AssociatePGToDirNT(MethodContext* pMethodContext,
                                              CHString& chstrDirectory,
                                              CHString& chstrProgGrpPATH)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrDirDrive;
    CHString chstrDirPath;
    CHString chstrDirName;
    CHString chstrDirExt;
    bool fRoot;

    // Break the directory into its constituent parts
    GetPathPieces(chstrDirectory, chstrDirDrive, chstrDirPath, chstrDirName, chstrDirExt);

    // Find out if we are looking for the root directory
    if(chstrDirPath==L"\\" && chstrDirName==L"" && chstrDirExt==L"")
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrDirPath = L"";
    }
    else
    {
        fRoot = false;
    }

    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                    chstrDirDrive,  // drive letter and colon
                    chstrDirPath,   // use the given path
                    chstrDirName,   // filename
                    chstrDirExt,    // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)(LPCWSTR)chstrProgGrpPATH)); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif


#ifdef WIN9XONLY
HRESULT CW32ProgGrpW32Dir::AssociatePGToDir95(MethodContext* pMethodContext,
                                              CHString& chstrDirectory,
                                              CHString& chstrProgGrpPATH)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrDirDrive;
    CHString chstrDirPath;
    CHString chstrDirName;
    CHString chstrDirExt;
    bool fRoot;

    // Break the directory into its constituent parts
    GetPathPieces(chstrDirectory, chstrDirDrive, chstrDirPath, chstrDirName, chstrDirExt);

    // Find out if we are looking for the root directory
    if(chstrDirPath==_T("\\") && chstrDirName==_T("") && chstrDirExt==_T(""))
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrDirPath = _T("");
    }
    else
    {
        fRoot = false;
    }

    hr = EnumDirs95(C95EnumParm(pMethodContext,
                    TOBSTRT(chstrDirDrive),  // drive letter and colon
                    TOBSTRT(chstrDirPath),   // use the given path
                    TOBSTRT(chstrDirName),   // filename
                    TOBSTRT(chstrDirExt),    // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)(LPCTSTR)TOBSTRT(chstrProgGrpPATH))); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif




/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  That class
 *                returns files or directories where this one should only
 *                return files, in response to queries, getobject commands,
 *                etc.  It is overridden here to return TRUE only if the file
 *                (the information for which is contained in the function
 *                arguement pstFindData) is of type file.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if a file or FALSE if a directory
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CW32ProgGrpW32Dir::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE);
    }
}
#endif


#ifdef WIN9XONLY
BOOL CW32ProgGrpW32Dir::IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                             const char* strFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE);
    }
}
#endif




/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherrited from CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the PartComponent and GroupComponent
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef WIN9XONLY
void CW32ProgGrpW32Dir::LoadPropertyValues95(CInstance* pInstance,
                                         LPCTSTR pszDrive,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszFSName,
                                         LPWIN32_FIND_DATA pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirPATH;

    // Get the dependent (the directory name) ready...
    chstrDirName.Format(L"%s%s%s",(LPCWSTR)TOBSTRT(pszDrive),(LPCWSTR)TOBSTRT(pszPath),(LPCWSTR)TOBSTRT(pstFindData->cFileName));
    EscapeBackslashes(chstrDirName, chstrDirName);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirName);

    pInstance->SetCHString(IDS_Dependent, chstrDirPATH);
    pInstance->SetCharSplat(IDS_Antecedent, (LPCSTR)pvMoreData);
}
#endif


#ifdef NTONLY
void CW32ProgGrpW32Dir::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirPATH;

    // Get the dependent (the directory name) ready...
    chstrDirName.Format(L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
    EscapeBackslashes(chstrDirName, chstrDirName);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirName);

    pInstance->SetCHString(IDS_Dependent, chstrDirPATH);
    pInstance->SetWCHARSplat(IDS_Antecedent, (LPCWSTR)pvMoreData);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupwin32directory.h ===
//=================================================================

//

// Win32ProgramGroupWin32Directory.h -- Win32_LogicalProgramGroup to Win32_Directory

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between Win32_LogicalProgramGroup and Win32_Directory
//
//=================================================================

#ifndef _WIN32PROGRAMGROUPWIN32DIRECTORY_H_
#define _WIN32PROGRAMGROUPWIN32DIRECTORY_H_



// Property set identification
//============================
#define  PROPSET_NAME_WIN32LOGICALPROGRAMGROUP_WIN32DIRECTORY L"Win32_LogicalProgramGroupDirectory"

#include"implement_logicalfile.h"

class CW32ProgGrpW32Dir;

class CW32ProgGrpW32Dir : public CImplement_LogicalFile 
{
    public:
        // Constructor/destructor
        //=======================
        CW32ProgGrpW32Dir(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32ProgGrpW32Dir() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

    protected:
       
       // Overridable function inherrited from CImplement_LogicalFile
#ifdef WIN9XONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                               const char* strFullPathName);

        virtual void LoadPropertyValues95(CInstance* pInstance,
                                          LPCTSTR pszDrive, 
                                          LPCTSTR pszPath, 
                                          LPCTSTR pszFSName, 
                                          LPWIN32_FIND_DATA pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual void LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

    private:
        HRESULT ExecQueryType1(MethodContext* pMethodContext, CHString& chstrProgGroupName);
        HRESULT ExecQueryType2(MethodContext* pMethodContext, CHString& chstrDirectory);

#ifdef NTONLY
        HRESULT EnumerateInstancesNT(MethodContext* pMethodContex);
        HRESULT AssociatePGToDirNT(MethodContext* pMethodContext,
                                   CHString& chstrDirectory,
                                   CHString& chstrProgGrpPATH);
#endif
#ifdef WIN9XONLY
        HRESULT EnumerateInstances9x(MethodContext* pMethodContext);
        HRESULT AssociatePGToDir95(MethodContext* pMethodContext,
                                   CHString& chstrDirectory,
                                   CHString& chstrProgGrpPATH);
#endif

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32scsicontrollerdevice.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32SCSIControllerDevice.h
//
//  Purpose: Relationship between Win32_SCSIController and CIM_LogicalDevice
//
//***************************************************************************

#ifndef _WIN32SCSICONTROLLERDEVICE_H_
#define _WIN32SCSICONTROLLERDEVICE_H_


#define SCSICTL_PROP_ALL_PROPS                    0xFFFFFFFF
#define SCSICTL_PROP_ALL_PROPS_KEY_ONLY           0x00000003
#define SCSICTL_PROP_Antecedent                   0x00000001
#define SCSICTL_PROP_Dependent                    0x00000002



// Property set identification
//============================
#define PROPSET_NAME_WIN32SCSICONTROLLERDEVICE  L"Win32_SCSIControllerDevice"


typedef std::vector<CHString*> VECPCHSTR;

class CW32SCSICntrlDev : public CWin32_ScsiController, public CWin32PNPEntity
{
    public:

        // Constructor/destructor
        //=======================
        CW32SCSICntrlDev(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32SCSICntrlDev() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags = 0L); 
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);

    protected:

        // Functions inherrited from CW32SCSICntrlDev
        //====================================
#if NTONLY == 4
        HRESULT LoadPropertyValues(void* pvData);
#else
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);
#endif

    private:

        CHPtrArray m_ptrProperties;
        void CleanPCHSTRVec(VECPCHSTR& vec);
        HRESULT GenerateSCSIDeviceList(const CHString& chstrControllerPNPID, 
                                      VECPCHSTR& vec);
        HRESULT RecursiveFillDeviceBranch(CConfigMgrDevice* pRootDevice, 
                                          VECPCHSTR& vecSCSIDevices); 
        HRESULT ProcessSCSIDeviceList(MethodContext* pMethodContext, 
                                     const CHString& chstrControllerRELPATH, 
                                     VECPCHSTR& vecSCSIDevices,
                                     const DWORD dwReqProps);
        HRESULT CreateAssociation(MethodContext* pMethodContext,
                                  const CHString& chstrControllerPATH, 
                                  const CHString& chstrSCSIDevice,
                                  const DWORD dwReqProps);
        LONG FindInStringVector(const CHString& chstrSCSIDevicePNPID, 
                                VECPCHSTR& vecSCSIDevices);


};

// This derived class commits here, not in the base.
#if ( NTONLY >= 5 || defined(WIN9XONLY) )	
inline bool CW32SCSICntrlDev::ShouldBaseCommit(void* pvData) { return false; }
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32scsicontrollerdevice.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32SCSIControllerDevice.cpp
//
//  Purpose: Relationship between Win32_SCSIController and CIM_LogicalDevice
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>
#include <vector>

#include "scsi.h"

#include "PNPEntity.h"
#include "LPVParams.h"
#include <FRQueryEx.h>

#include "WIN32SCSIControllerDevice.h"

// Property set declaration
//=========================
CW32SCSICntrlDev MyCW32SCSICntrlDev(PROPSET_NAME_WIN32SCSICONTROLLERDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::CW32SCSICntrlDev
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32SCSICntrlDev::CW32SCSICntrlDev
(
    LPCWSTR setName,
    LPCWSTR pszNamespace
)
: CWin32_ScsiController(setName, pszNamespace),
  CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::~CW32SCSICntrlDev
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32SCSICntrlDev::~CW32SCSICntrlDev()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::GetObject
(
    CInstance *pInstance,
    long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

#if (NTONLY >= 5) || defined(WIN9XONLY)

    if(pInstance != NULL)
    {
        CHString chstrAntecedent, chstrDependent;
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
        pInstance->GetCHString(IDS_Dependent, chstrDependent);

        // Obtain the antecedent's device id:
        CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
        chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
        CHString chstrAntecedentDevIDAdj;
        RemoveDoubleBackslashes(chstrAntecedentDevID,chstrAntecedentDevIDAdj);

        // Obtain the dependent's device id:
        CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
        chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
        CHString chstrDependentDevIDAdj;
        RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

        CConfigManager cfgmgr;

        // Now see if the dependent is visible to config manager...
        CConfigMgrDevicePtr pPNPDevice;
        if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, &pPNPDevice))
        {
            // It is visible to config manager.  Is it a PNPDevice?
            if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
            {
                // It is. Is its parent a SCSIController?
                CConfigMgrDevicePtr pParentDevice;
                bool bFound = false;

                // or its parent?  Or its parent? Or...
                while (pPNPDevice->GetParent(&pParentDevice))
                {
                    if(CWin32_ScsiController::IsOneOfMe(pParentDevice))
                    {
                        bFound = true;
                        break;
                    }
                    else
                    {
                        pPNPDevice = pParentDevice;
                    }
                }

                if (bFound)
                {
                    // It is. Is it's PNP ID the same as that which we were given?
                    CHString chstrControllerPNPID;
                    pParentDevice->GetDeviceID(chstrControllerPNPID);
                    if(chstrAntecedentDevIDAdj.CompareNoCase(chstrControllerPNPID)==0)
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
        }
    }

#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32SCSICntrlDev::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CW32SCSICntrlDev::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if NTONLY >= 5
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwReqProps;

    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwReqProps);

    std::vector<_bstr_t> vecDependents;
    pQuery.GetValuesForProp(IDS_Dependent, vecDependents);
    DWORD dwDependents = vecDependents.size();

    // Only will have one SCSIcontroller, so if the query asked for that
    // as the antecedent, do an enumeration.  If the query asked for a
    // specific device as the dependent, just get that one.
    if(dwDependents > 0)
    {
        for(LONG m = 0L; m < dwDependents; m++)
        {
            // Obtain the dependent's device id:
            CHString chstrDependent((LPCTSTR)vecDependents[m]);
            CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
            chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
            CHString chstrDependentDevIDAdj;
            RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

            CConfigManager cfgmgr;

            // Now see if the dependent is visible to config manager...
            CConfigMgrDevicePtr pPNPDevice;
            if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, &pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // It is. Is its parent a SCSIController?
                    CConfigMgrDevicePtr pParentDevice;
                    bool bFound = false;

                    // or its parent?  Or its parent? Or...
                    while (pPNPDevice->GetParent(&pParentDevice))
                    {
                        if(CWin32_ScsiController::IsOneOfMe(pParentDevice))
                        {
                            bFound = true;
                            break;
                        }
                        else
                        {
                            pPNPDevice = pParentDevice;
                        }
                    }

                    if (bFound)
                    {
                        // It is, so create the association.
                        CHString chstrControllerPNPID;
                        pParentDevice->GetDeviceID(chstrControllerPNPID);
                        CHString chstrControllerPNPIDAdj;
                        EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                        CHString chstrControllerPATH;
                        chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                                   (LPCWSTR)GetLocalComputerName(),
                                                   IDS_CimWin32Namespace,
                                                   PROPSET_NAME_SCSICONTROLLER,
                                                   IDS_DeviceID,
                                                   (LPCWSTR)chstrControllerPNPIDAdj);

                        CHString chstrDevicePATH;
                        chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                               (LPCWSTR)GetLocalComputerName(),
                                               IDS_CimWin32Namespace,
                                               PROPSET_NAME_PNPEntity,
                                               IDS_DeviceID,
                                               (LPCWSTR)chstrDependentDevID);

                        hr = CreateAssociation(pMethodContext, chstrControllerPATH, chstrDevicePATH, dwReqProps);
                    }
                }
            }
        }
    }
    else
    {
        hr = CWin32_ScsiController::Enumerate(pMethodContext, lFlags, dwReqProps);
    }
#endif

#ifdef WIN9XONLY
    hr = CWin32_ScsiController::EnumerateInstances(pMethodContext, lFlags);
#endif

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::EnumerateInstances
 *
 *  DESCRIPTION : Enumerate is present here to prevent ambiguous upcasting to
 *                functions of the same name from both base classes.  The
 *                logic in LoadPropertyValues works when CWin32_ScsiController's (the
 *                SCSIController class) version of EnumerateInstances is called,
 *                so that is what we call here.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

#if ( NTONLY >= 5 || defined(WIN9XONLY) )
    t_Result = CWin32_ScsiController::Enumerate(pMethodContext, SCSICTL_PROP_ALL_PROPS);
#endif

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::LoadPropertyValues
(
    void* pv
)
{

    // Algorithm:
    // 1) Get all instances of Win32_SCSIController
    // 2) For each in #1, using cfg mgr, get its children, their children, etc.
    // 3) For each in #2, obtain DeviceID from cfg mgr, and look for instances of
    //    CIM_LogicalDevice with PNPDeviceIDs that match.
    // 4) For matches from #3, create association instances

    HRESULT hr = WBEM_S_NO_ERROR;

#if (NTONLY >= 5) || defined(WIN9XONLY)

    CHString chstrControllerPNPID;
    CHString chstrControllerPATH;
    MethodContext* pMethodContext = NULL;

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance* pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);
    if(pInstance == NULL || pDevice == NULL) return WBEM_E_FAILED;

    if((pMethodContext = pInstance->GetMethodContext()) != NULL)
    {
        VECPCHSTR vecSCSIDevices;

        pDevice->GetDeviceID(chstrControllerPNPID);

        try
        {
            hr = GenerateSCSIDeviceList(chstrControllerPNPID, vecSCSIDevices);
            if(SUCCEEDED(hr) && vecSCSIDevices.size() > 0L)
            {
                CHString chstrControllerPNPIDAdj;
                EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                           (LPCWSTR)GetLocalComputerName(),
                                           IDS_CimWin32Namespace,
                                           L"Win32_SCSIController",
                                           IDS_DeviceID,
                                           (LPCWSTR)chstrControllerPNPIDAdj);
                hr = ProcessSCSIDeviceList(pMethodContext, chstrControllerPATH, vecSCSIDevices, dwReqProps);
            }
        }
        catch ( ... )
        {
            CleanPCHSTRVec(vecSCSIDevices);
            throw ;
        }
        CleanPCHSTRVec(vecSCSIDevices);
    }

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::GenerateSCSIDeviceList
 *
 *  DESCRIPTION : This helper creates a list of devices hanging off the passed
 *                in device.
 *
 *  INPUTS      : vecSCSIDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPNPID, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::GenerateSCSIDeviceList
(
    const CHString& chstrControllerPNPID,
    VECPCHSTR& vec
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if (NTONLY >= 5) || defined(WIN9XONLY)

    CConfigManager cfgManager;
    CConfigMgrDevicePtr pController;
    if(cfgManager.LocateDevice(chstrControllerPNPID, &pController))
    {
        if(pController != NULL)
        {
            hr = RecursiveFillDeviceBranch(pController, vec);
        }
    }

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::RecursiveFillDeviceBranch
 *
 *  DESCRIPTION : This helper obtains all down branch devices starting with,
 *                but not including, pDevice.
 *
 *  INPUTS      : pDevice, a device to populate the children of;
 *                vecSCSIDevices, a list of devices to try to associate
 *                   to the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::RecursiveFillDeviceBranch
(
    CConfigMgrDevice* pDevice,
    VECPCHSTR& vecSCSIDevices
)
{

    HRESULT hr = WBEM_S_NO_ERROR;

#if (NTONLY >= 5) || defined(WIN9XONLY)

    CConfigMgrDevicePtr pDeviceChild;
    CConfigMgrDevicePtr pDeviceSibling;
    CConfigMgrDevicePtr pDeviceSiblingNext;
    CHString* pchstrTemp = NULL;

    if(pDevice != NULL)
    {
        if(pDevice->GetChild(&pDeviceChild))
        {
            // Need this child's PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                if(chstrChildPNPDeviceID.GetLength() > 0)
                {
                    // Record this child...
                    pchstrTemp = NULL;
                    pchstrTemp = (CHString*) new CHString(chstrChildPNPDeviceID);
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            vecSCSIDevices.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            pchstrTemp = NULL;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }

                    // If we've hit another controller, add this one (done above), but don't go
                    // any deeper.
                    if (!CWin32_ScsiController::IsOneOfMe(pDeviceChild))
                    {
                        hr = RecursiveFillDeviceBranch(pDeviceChild, vecSCSIDevices);
                    }
                }
            }
            // Now call its brothers and sisters until none left (GetSibling
            // call will return FALSE):
            if(SUCCEEDED(hr))
            {
                if(pDeviceChild->GetSibling(&pDeviceSibling))
                {
                    BOOL fContinue = TRUE;
                    CHString chstrSiblingPNPDeviceID;
                    while(SUCCEEDED(hr) && fContinue)
                    {
                        // Record the sibling now...
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            if(chstrSiblingPNPDeviceID.GetLength() > 0)
                            {
                                pchstrTemp = NULL;
                                pchstrTemp = (CHString*) new CHString(chstrSiblingPNPDeviceID);
                                if(pchstrTemp != NULL)
                                {
                                    try
                                    {
                                        vecSCSIDevices.push_back(pchstrTemp);
                                    }
                                    catch ( ... )
                                    {
                                        delete pchstrTemp;
                                        pchstrTemp = NULL;
                                        throw ;
                                    }
                                }
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                        }

                        // If we've hit another controller, add this one (done above), but don't go
                        // any deeper.
                        if (!CWin32_ScsiController::IsOneOfMe(pDeviceSibling))
                        {
                            hr = RecursiveFillDeviceBranch(pDeviceSibling, vecSCSIDevices);
                        }

                        // Then get the next sibling...
                        pDeviceSiblingNext = NULL;
                        fContinue = pDeviceSibling->GetSibling(&pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

#endif

    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::ProcessSCSIDeviceList
 *
 *  DESCRIPTION : This helper runs through the list, creating an association
 *                instance for each element in the list (vecSCSIDevices) with
 *                the controller (chstrControllerPNPID).
 *
 *  INPUTS      : pMethodContext;
 *                vecSCSIDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::ProcessSCSIDeviceList
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    VECPCHSTR& vecSCSIDevices,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if (NTONLY >= 5) || defined(WIN9XONLY)

    for(LONG m = 0L; m < vecSCSIDevices.size() && SUCCEEDED(hr); m++)
    {
        // For each element of the vector, we need to see if there is an instance
        // of a win32_pnpentity that has the specified PNPDeviceID.
        CHString chstrDevicePATH, chstrDevPATHAdj;
        CConfigManager cfgmgr;

        // Let's see if config manager recognizes this device at all
        CConfigMgrDevicePtr pDevice;
        if(cfgmgr.LocateDevice(*vecSCSIDevices[m], &pDevice))
        {
            // Ok, it knows about it.  Is it a PNPDevice device?
            if(CWin32PNPEntity::IsOneOfMe(pDevice))
            {
                // It would appear that it is.  Create the association...
                EscapeBackslashes(*vecSCSIDevices[m], chstrDevPATHAdj);
                chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_PNPEntity,
                                       IDS_DeviceID,
                                       (LPCWSTR)chstrDevPATHAdj);

                hr = CreateAssociation(pMethodContext, chstrControllerPATH, chstrDevicePATH, dwReqProps);
            }
        }
    }

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::CreateAssociation
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : pMethodContext;
 *                SCSIDevice, a device to associate with the controller
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper actually creates the association instance and
 *                commits it.
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::CreateAssociation
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    const CHString& chstrDevicePATH,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;

#if (NTONLY >= 5) || defined(WIN9XONLY)

    if(pMethodContext != NULL)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            if(dwReqProps & SCSICTL_PROP_Antecedent || dwReqProps & SCSICTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Antecedent, chstrControllerPATH);
            }

            if(dwReqProps & SCSICTL_PROP_Dependent || dwReqProps & SCSICTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Dependent, chstrDevicePATH);
            }

            hr = pInstance->Commit();
        }
    }

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::FindInStringVector
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : chstrSCSIDevicePNPID, device to look for
 *                vecSCSIDevices, list of devices to look in
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG, number indicating 0 based offset into vecSCSIDevices of
 *                the found device, or -1 if not found.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CW32SCSICntrlDev::FindInStringVector
(
    const CHString& chstrSCSIDevicePNPID,
    VECPCHSTR& vecSCSIDevices
)
{
    LONG lPos = -1L;

#if (NTONLY >= 5) || defined(WIN9XONLY)

    bool fFoundIt;
    for(LONG m = 0; m < vecSCSIDevices.size(); m++)
    {
        if(chstrSCSIDevicePNPID == *vecSCSIDevices[m])
        {
            fFoundIt = true;
            break;
        }
    }
    if(fFoundIt) lPos = m;

#endif

    return lPos;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::CleanPCHSTRVec
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : vec, a vector of CHString pointers
 *
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper deletes members of a vector that are pointers.
 *
 *****************************************************************************/
void CW32SCSICntrlDev::CleanPCHSTRVec
(
    VECPCHSTR& vec
)
{
#if (NTONLY >= 5) || defined(WIN9XONLY)

    for(LONG m = 0L; m < vec.size(); m++)
    {
        delete vec[m];
    }
    vec.clear();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitydescriptor.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*******************************************************************
 *
 *    DESCRIPTION:	Win32SecurityDescriptor.H
 *
 *    AUTHOR:
 *
 *    HISTORY:    
 *
 *******************************************************************/

#ifndef __WIN32SECURITY_H_
#define __WIN32SECURITY_H_
#include "accessentry.h"
#include "SACL.h"
#include "DACL.h"
#include "win32ace.h"


#define  WIN32_SECURITY_DESCRIPTOR_NAME L"Win32_SecurityDescriptor" 

// provider provided for test provisions
class Win32SecurityDescriptor : public Provider
{
public:	
	Win32SecurityDescriptor(const CHString &setName, LPCTSTR pszNameSpace);
	~Win32SecurityDescriptor();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

	void GetDescriptor ( CInstance* pInstance, 
							PSECURITY_DESCRIPTOR& pDescriptor,
							PSECURITY_DESCRIPTOR* pLocalSD = NULL);

	void SetDescriptor ( CInstance* pInstance, PSECURITY_DESCRIPTOR& pDescriptor, PSECURITY_INFORMATION& pSecurityInfo );

#ifdef NTONLY
	DWORD FillSACLFromInstance (CInstance* pInstance, CSACL& sacl, MethodContext* pMethodContext);

	DWORD FillDACLFromInstance (CInstance* pInstance, CDACL& dacl, MethodContext* pMethodContext);
#endif
	
	bool Win32SecurityDescriptor::GetArray(IWbemClassObject *piClassObject, const CHString& name,  VARIANT& v, VARTYPE eVariantType) const ;
	DWORD Win32SecurityDescriptor::FillSIDFromTrustee(CInstance *pTrustee, CSid& sid ) ;

	DWORD SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR psd,
                             SECURITY_DESCRIPTOR_CONTROL wControlMask,
                             SECURITY_DESCRIPTOR_CONTROL wControlBits);

#ifdef NTONLY
	HRESULT FillInstanceSACLFromSDSACL (CInstance* pInstance, CSACL& sacl);

	HRESULT FillInstanceDACLFromSDDACL (CInstance* pInstance, CDACL& dacl);
#endif

	void FillTrusteeFromSID (CInstance* pTrustee, CSid& Sid);

protected:

	DWORD	m_dwPlatformID;
	
private:

};

//
/*extern "C" POLARITY*/ void GetDescriptorFromMySecurityDescriptor(
	CInstance* pInstance, PSECURITY_DESCRIPTOR *ppDescriptor);

extern "C" POLARITY 
void GetSDFromWin32SecurityDescriptor( IWbemClassObject* pObject, 
						PSECURITY_DESCRIPTOR *ppDescriptor);

extern "C" POLARITY 
void SetWin32SecurityDescriptorFromSD(	PSECURITY_DESCRIPTOR pDescriptor,
											PSECURITY_INFORMATION pInformation,
											bstr_t lpszPath,
											IWbemClassObject **ppObject);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitydescriptor.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*******************************************************************
 *
 *    DESCRIPTION:	Win32Security.CPP
 *
 *    AUTHOR:
 *
 *    HISTORY:
 *
 *******************************************************************/
#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureregkey.h"
#include "securefile.h"
//#include "logfilesec.h"
#include "win32ace.h"

// DON'T ADD ANY INCLUDES AFTER THIS POINT!
#undef POLARITY
#define POLARITY __declspec(dllexport)
#include "Win32securityDescriptor.h"


/*
	THIS IS THE SECURITY DESCRIUPTOR CLASS DECLARED IN THE MOF

	[abstract,
    description("Structural representation of a SECURITY_DESCRIPTOR")]
class Win32_SecurityDescriptor : Win32_MethodParameterClass
{
    Win32_Trustee Owner;

    Win32_Trustee Group;

    Win32_ACE DACL[];

    Win32_ACE SACL[];

    uint32 ControlFlags;
};
*/

POLARITY Win32SecurityDescriptor MySecurityDescriptor( WIN32_SECURITY_DESCRIPTOR_NAME, IDS_CimWin32Namespace );

Win32SecurityDescriptor::Win32SecurityDescriptor (const CHString& setName, LPCTSTR pszNameSpace)
: Provider (setName, pszNameSpace )
{
}

Win32SecurityDescriptor::~Win32SecurityDescriptor()
{
}



HRESULT Win32SecurityDescriptor::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

HRESULT Win32SecurityDescriptor::GetObject ( CInstance* pInstance, long lFlags /* = 0L */ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	return(hr);

}

void Win32SecurityDescriptor::GetDescriptor ( CInstance* pInstance,
											 PSECURITY_DESCRIPTOR& pDescriptor,
											 PSECURITY_DESCRIPTOR* pLocalSD)
{

 	// takes the Win32_SecurityDescriptor object that is passed in
	// converts it to a CSecurityDescriptor/CSecureFile object
	// and applies it the the CSecureFile
	pDescriptor = NULL ;
	CInstancePtr pTrusteeOwner;
	CInstancePtr pTrusteeGroup;
	SECURITY_DESCRIPTOR absoluteSD;
	InitializeSecurityDescriptor((PVOID)&absoluteSD, SECURITY_DESCRIPTOR_REVISION) ;

	PSECURITY_DESCRIPTOR pRelativeSD = NULL;
	DWORD dwLength = 0;
	bool bExists = false ;
	VARTYPE eType ;

	if (pInstance)
	{
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		// get the control flags
		SECURITY_DESCRIPTOR_CONTROL control;
        DWORD dwControlTemp;
		pInstance->GetDWORD(IDS_ControlFlags, dwControlTemp);
        control = (SECURITY_DESCRIPTOR_CONTROL)dwControlTemp;

		//SetSecurityDescriptorControl(&absoluteSD, control, control);

		CSid sidOwner ;
		// get the owner SID
		if( pInstance->GetStatus ( IDS_Owner , bExists , eType ) && bExists && eType != VT_NULL )
		{
 			if( pInstance->GetEmbeddedObject(IDS_Owner, &pTrusteeOwner, pMethodContext) && (pTrusteeOwner != NULL) )
			{
				// now, take the Win32_Trustee instance and get the SID out of it
				// convert it to a CSid, and apply to the SecureFile
				// get SID information out of the Trustee
				if( !FillSIDFromTrustee( pTrusteeOwner, sidOwner ) )
				{
					BOOL bOwnerDefaulted = ( control & SE_OWNER_DEFAULTED ) ? true : false ;

					//sid validity checked here as FillSIDFromTrustee returns success if null sid
					if ( sidOwner.IsValid() )
					{
						if( !SetSecurityDescriptorOwner( &absoluteSD, sidOwner.GetPSid(), bOwnerDefaulted ) )
						{
							return ;
						}
					}
				}
				else
				{
					return ;
				}
			}
			else
			{
				return ;
			}
		}

		CSid sidGroup ;
		// get the group SID
		if( pInstance->GetStatus ( IDS_Group , bExists , eType ) && bExists && eType != VT_NULL )
		{
			if( pInstance->GetEmbeddedObject( IDS_Group, &pTrusteeGroup, pMethodContext ) && (pTrusteeGroup != NULL))
			{
				// now, take the Win32_Trustee instance and get the SID out of it
				// get SID information out of the Trustee
				if( !FillSIDFromTrustee( pTrusteeGroup, sidGroup ) )
				{
					BOOL bGroupDefaulted = ( control & SE_GROUP_DEFAULTED ) ? true : false ;

					//sid validity checked here as FillSIDFromTrustee returns success if null sid
					if ( sidGroup.IsValid() )
					{
						if( !SetSecurityDescriptorGroup( &absoluteSD, sidGroup.GetPSid(), bGroupDefaulted ) )
						{
							return ;
						}
					}
				}
				else
				{
					return ;
				}
			}
			else
			{
				return ;
			}
		}

		// get the DACL
		CDACL dacl;
		PACL pDACL = NULL ;
		DWORD dwACLSize =0 ;

        if( FillDACLFromInstance( pInstance, dacl, pMethodContext ) == ERROR_SUCCESS )
		{
			if( dacl.CalculateDACLSize( &dwACLSize ) )
			{
				if( dwACLSize > sizeof(ACL) )
				{
                    pDACL = (PACL) malloc(dwACLSize) ;
					if (pDACL == NULL)
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;

                    }
					InitializeAcl(pDACL,dwACLSize,ACL_REVISION ) ;

					BOOL bDaclDefaulted = ( control & SE_DACL_DEFAULTED ) ? true : false ;
					if( dacl.FillDACL( pDACL ) == ERROR_SUCCESS )
					{
						if( !SetSecurityDescriptorDacl( &absoluteSD, TRUE, pDACL, bDaclDefaulted ) )
						{
							free(pDACL) ;
							return ;
						}
					}
					else
					{
						free(pDACL) ;
						return ;
					}
				}
		        else if(dwACLSize == 0)
		        {
                    pDACL = (PACL) malloc(sizeof(ACL)) ;
			    
					if (pDACL == NULL)
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
                    InitializeAcl(pDACL,sizeof(ACL),ACL_REVISION ) ;

			        BOOL bDaclDefaulted = ( control & SE_DACL_DEFAULTED ) ? true : false ;
			        if( dacl.FillDACL( pDACL ) == ERROR_SUCCESS )
			        {
				        if( !SetSecurityDescriptorDacl( &absoluteSD, TRUE, pDACL, bDaclDefaulted ) )
				        {
					        free(pDACL) ;
                            pDACL = NULL ;
					        return ;
				        }
			        }
			        else
			        {
				        free(pDACL) ;
                        pDACL = NULL ;
				        return ;
			        }
		        }
			}
		}

		// get the SACL
		CSACL sacl;
		PACL pSACL = NULL ;
		DWORD dwSACLSize =0 ;
		if( !FillSACLFromInstance( pInstance, sacl, pMethodContext ) )
		{
			if( sacl.CalculateSACLSize( &dwSACLSize ) )
			{
				if( dwSACLSize > sizeof(ACL) )
				{
                    pSACL = (PACL) malloc(dwSACLSize) ;
					if (pSACL == NULL)
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}

					InitializeAcl(pSACL,dwSACLSize,ACL_REVISION ) ;

					BOOL bSaclDefaulted = ( control & SE_SACL_DEFAULTED ) ? true : false ;
					if( sacl.FillSACL( pSACL ) == ERROR_SUCCESS )
					{
						if( SetSecurityDescriptorSacl( &absoluteSD, TRUE, pSACL, bSaclDefaulted ) )
						{
						}
						else
						{
							if(pDACL)
							{
								free(pDACL) ;
							}
							free(pSACL) ;
							return ;
						}
					}
					else
					{
						if(pDACL)
						{
							free(pDACL) ;
						}
						free(pSACL) ;
						return ;
					}
				}
			}
		}

		// allocate the selfrelative securitydescriptor based on sizes
		// from the absolute.

		// convert security descriptor to SelfRelative

		// get the size that the buffer has to be.
		// THIS CALL WILL ALWAYS FAIL
		MakeSelfRelativeSD(&absoluteSD, NULL, &dwLength);

	    pRelativeSD = (PSECURITY_DESCRIPTOR) malloc( dwLength );

		if (pRelativeSD == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		if (!MakeSelfRelativeSD(&absoluteSD, pRelativeSD, &dwLength))
		{
			free( pRelativeSD ) ;
			pRelativeSD = NULL ;
		}

		if(pDACL)
		{
			free(pDACL) ;
		}
		if(pSACL)
		{
			free(pSACL) ;
		}

		pDescriptor = pRelativeSD;

		// if the caller wants one allocated with LocalAlloc...
		if(pLocalSD)
		{
			// give him a copy.
            try
            {
			    *pLocalSD = LocalAlloc(LPTR, dwLength);

				if (*pLocalSD == NULL)
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

			    memcpy(*pLocalSD, pRelativeSD, dwLength);
            }
            catch(...)
            {
                if(*pLocalSD != NULL)
                {
                    LocalFree(*pLocalSD);
                    *pLocalSD = NULL;
                }
                throw;
            }
		}

	}
}

void Win32SecurityDescriptor::SetDescriptor ( CInstance* pInstance, PSECURITY_DESCRIPTOR& pDescriptor, PSECURITY_INFORMATION& pSecurityInfo )
{
	// the purpose of this function is to set the security stuff in the
	// instance so it matches what is in the security descriptor.
	if (pInstance && pDescriptor)
	{
		CSecureFile NullFile(NULL, pDescriptor);

//    Win32_Trustee Owner;
		CInstancePtr pTrusteeOwnerInstance;
		if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrusteeOwnerInstance, GetNamespace())))
		{
			CSid sidOwner;
			NullFile.GetOwner( sidOwner );
			FillTrusteeFromSID(pTrusteeOwnerInstance, sidOwner);
			pInstance->SetEmbeddedObject(L"Owner", *pTrusteeOwnerInstance);
		}	// end if

	//    Win32_Trustee Group;
		CInstancePtr pTrusteeGroupInstance;
		if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrusteeGroupInstance, GetNamespace())))
		{
			CSid sidGroup;
			NullFile.GetGroup( sidGroup );
			FillTrusteeFromSID(pTrusteeGroupInstance, sidGroup);
			pInstance->SetEmbeddedObject(L"Group", *pTrusteeGroupInstance);
		}	// end if

	//    Win32_ACE DACL[];
    	CDACL dacl;
		HRESULT hr;

		NullFile.GetDACL( dacl );
 		hr = FillInstanceDACLFromSDDACL(pInstance, dacl);

	//    Win32_ACE SACL[];
		CSACL sacl;
		NullFile.GetSACL( sacl );
 		hr = FillInstanceSACLFromSDSACL(pInstance, sacl);

	//    uint32 ControlFlags;
		SECURITY_DESCRIPTOR_CONTROL sdControl;
		NullFile.GetControl( &sdControl );

		pInstance->SetDWORD(L"ControlFlags", (DWORD)sdControl);
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32SecurityDescriptor::FillDACLFromInstance
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD Win32SecurityDescriptor::FillDACLFromInstance (CInstance* pInstance, CDACL& dacl, MethodContext* pMethodContext)
{
	IWbemClassObjectPtr piClassObject;
    piClassObject.Attach(pInstance->GetClassObjectInterface()) ;
	DWORD dwStatus = ERROR_SUCCESS ;

	if(piClassObject)
	{
		VARIANT vDacl ;
		if(GetArray(piClassObject,IDS_DACL, vDacl, VT_UNKNOWN|VT_ARRAY) )
		{

			if( vDacl.parray )
			{

				// walk DACL
				LONG lDimension = 1 ;
				LONG lLowerBound ;
				SafeArrayGetLBound ( vDacl.parray , lDimension , &lLowerBound ) ;
				LONG lUpperBound ;
				SafeArrayGetUBound ( vDacl.parray , lDimension , &lUpperBound ) ;

				for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
				{
					if( dwStatus != ERROR_SUCCESS )
					{
						break ;
					}
					IWbemClassObjectPtr pACEObject;
					SafeArrayGetElement ( vDacl.parray , &lIndex , &pACEObject ) ;
					// take out IWbemClassObject and cast it to a Win32_ACE object.
					if(pACEObject)
					{
						CInstance ACEInstance(pACEObject, pMethodContext);

						// create an AccessEntry object from the Win32_ACE object.

						bool bExists =false ;
						VARTYPE eType ;
						// get Win32_Trustee object from Win32_ACE ...& decipher the ACE
						if ( ACEInstance.GetStatus ( IDS_Trustee, bExists , eType ) && bExists && eType == VT_UNKNOWN )
						{

							CInstancePtr pTrustee;
							if ( ACEInstance.GetEmbeddedObject ( IDS_Trustee, &pTrustee, ACEInstance.GetMethodContext() ) )
							{

								CSid sid ;
								if(FillSIDFromTrustee(pTrustee, sid) == ERROR_SUCCESS)
								{

									DWORD dwAceType, dwAceFlags, dwAccessMask ;
									CHString chstrInhObjGuid;
                                    GUID *pguidInhObjGuid = NULL;
                                    CHString chstrObjGuid;
                                    GUID *pguidObjGuid = NULL;

									ACEInstance.GetDWORD(IDS_AceType, dwAceType);
									ACEInstance.GetDWORD(IDS_AceFlags, dwAceFlags);
									ACEInstance.GetDWORD(IDS_AccessMask, dwAccessMask);

									if(!(dwAceFlags & INHERITED_ACE))
                                    {
                                        switch (dwAceType)
									    {
									    case ACCESS_DENIED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_DENIED_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
											    break;
										    }
									    case ACCESS_ALLOWED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
											    break;
										    }
#if NTONLY >= 5
                                        // Not yet supported on W2K
                                        //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
										//    {
										//	    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
										//	    break;
										//    }
                                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                                ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid);
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidObjGuid;
											    break;
										    }
                                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                                ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid);
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidObjGuid;
											    break;
										    }
#endif
									    default:
										    {
											    dwStatus = ERROR_INVALID_PARAMETER ;
											    break ;
										    }
									    }
                                    }
                                    else
                                    {
                                        switch (dwAceType)
									    {
									    case ACCESS_DENIED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_DENIED_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
											    break;
										    }
									    case ACCESS_ALLOWED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
											    break;
										    }
#if NTONLY >= 5
                                        // Not yet supported on W2K
                                        //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
										//    {
										//	    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
										//	    break;
										//    }
                                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                                ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidObjGuid;
											    break;
										    }
                                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                                ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidObjGuid;
											    break;
										    }
#endif
									    default:
										    {
											    dwStatus = ERROR_INVALID_PARAMETER ;
											    break ;
										    }
									    }

                                    }
								}
                                pTrustee->Release();
                                pTrustee = NULL;
							}

						}  // get Win32_Trustee object from Win32_ACE ...& decipher the ACE

					}

				}
			}

			VariantClear( &vDacl ) ;
		}
		else
		{
			dwStatus = ERROR_INVALID_PARAMETER ;
		}

	}

	return dwStatus ;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32SecurityDescriptor::FillSACLFromInstance
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD Win32SecurityDescriptor::FillSACLFromInstance (CInstance* pInstance, CSACL& sacl, MethodContext* pMethodContext)
{
	IWbemClassObjectPtr piClassObject;
    piClassObject.Attach(pInstance->GetClassObjectInterface()) ;
	DWORD dwStatus = ERROR_SUCCESS ;

	if(piClassObject)
	{
		VARIANT vSacl ;
		if(GetArray(piClassObject, IDS_SACL, vSacl, VT_UNKNOWN|VT_ARRAY ) )
		{

			if( vSacl.parray )
			{

				// walk DACL
				LONG lDimension = 1 ;
				LONG lLowerBound ;
				SafeArrayGetLBound ( vSacl.parray , lDimension , &lLowerBound ) ;
				LONG lUpperBound ;
				SafeArrayGetUBound ( vSacl.parray , lDimension , &lUpperBound ) ;

				for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
				{
					if( dwStatus != ERROR_SUCCESS )
					{
						break ;
					}
					IWbemClassObjectPtr pACEObject;
					SafeArrayGetElement ( vSacl.parray , &lIndex , &pACEObject ) ;
					// take out IWbemClassObject and cast it to a Win32_ACE object.
					if(pACEObject)
					{
						CInstance ACEInstance(pACEObject, pMethodContext);

						// create an AccessEntry object from the Win32_ACE object.

						bool bExists =false ;
						VARTYPE eType ;
						// get Win32_Trustee object from Win32_ACE ...& decipher the ACE
						if ( ACEInstance.GetStatus ( IDS_Trustee, bExists , eType ) && bExists && eType == VT_UNKNOWN )
						{

							CInstancePtr pTrustee;
							if ( ACEInstance.GetEmbeddedObject ( IDS_Trustee, &pTrustee, ACEInstance.GetMethodContext() ) )
							{

								CSid sid ;
								if(FillSIDFromTrustee(pTrustee, sid) == ERROR_SUCCESS)
								{

									DWORD dwAceType, dwAceFlags, dwAccessMask ;
									CHString chstrInhObjGuid;
                                    GUID *pguidInhObjGuid = NULL;
                                    CHString chstrObjGuid;
                                    GUID *pguidObjGuid = NULL;

									ACEInstance.GetDWORD(IDS_AceType, dwAceType);
									ACEInstance.GetDWORD(IDS_AceFlags, dwAceFlags);
									ACEInstance.GetDWORD(IDS_AccessMask, dwAccessMask);

                                    switch(dwAceType)
									{
                                    case SYSTEM_AUDIT_ACE_TYPE:
									    {
										    sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_AUDIT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            break;
									    }
#if NTONLY >= 5
                                    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
									    {
										    // Need to get the guids for this type...
                                            ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                            if(chstrObjGuid.GetLength() != 0)
                                            {
                                                try
                                                {
                                                    pguidObjGuid = new GUID;
                                                }
                                                catch(...)
                                                {
                                                    if(pguidObjGuid != NULL)
                                                    {
                                                        delete pguidObjGuid;
                                                        pguidObjGuid = NULL;
                                                    }
                                                }
                                                CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                            }
                                            ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                            if(chstrInhObjGuid.GetLength() != 0)
                                            {
                                                try
                                                {
                                                    pguidInhObjGuid = new GUID;
                                                }
                                                catch(...)
                                                {
                                                    if(pguidInhObjGuid != NULL)
                                                    {
                                                        delete pguidInhObjGuid;
                                                        pguidInhObjGuid = NULL;
                                                    }
                                                }
                                                CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                            }
                                            sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_AUDIT_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            if(pguidObjGuid != NULL) delete pguidObjGuid;
                                            if(pguidInhObjGuid != NULL) delete pguidObjGuid;
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************
                                    case SYSTEM_ALARM_ACE_TYPE:
									    {
										    sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_ALARM_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************/

/********************************* type not yet supported under w2k ********************************************
                                    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
									    {
										    // Need to get the guids for this type...
                                            ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                            if(chstrObjGuid.GetLength() != 0)
                                            {
                                                try
                                                {
                                                    pguidObjGuid = new GUID;
                                                }
                                                catch(...)
                                                {
                                                    if(pguidObjGuid != NULL)
                                                    {
                                                        delete pguidObjGuid;
                                                        pguidObjGuid = NULL;
                                                    }
                                                }
                                                CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                            }
                                            ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                            if(chstrInhObjGuid.GetLength() != 0)
                                            {
                                                try
                                                {
                                                    pguidInhObjGuid = new GUID;
                                                }
                                                catch(...)
                                                {
                                                    if(pguidInhObjGuid != NULL)
                                                    {
                                                        delete pguidInhObjGuid;
                                                        pguidInhObjGuid = NULL;
                                                    }
                                                }
                                                CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                            }
                                            sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_ALARM_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            if(pguidObjGuid != NULL) delete pguidObjGuid;
                                            if(pguidInhObjGuid != NULL) delete pguidObjGuid;
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************/

#endif
									default:
									    {
										    dwStatus = ERROR_INVALID_PARAMETER ;
                                            break;
									    }
                                    }
								}
                                pTrustee->Release();
                                pTrustee = NULL;
							}

						}  // get Win32_Trustee object from Win32_ACE ...& decipher the ACE

					} //if(pACEObject)

				} //for
			}	//if(pSACL)

			VariantClear( &vSacl ) ;
		}
		else
		{
			dwStatus = ERROR_INVALID_PARAMETER ;
		}

	}

	return dwStatus ;
}

bool Win32SecurityDescriptor::GetArray(IWbemClassObject *piClassObject, const CHString& name,  VARIANT& v, VARTYPE eVariantType) const
{
	bool bRet = FALSE;
	VariantInit(&v);

	if (piClassObject)
	{
		BSTR pName = NULL;
		try
        {
            pName = name.AllocSysString();

		    HRESULT hr;
		    hr = piClassObject->Get(pName, 0, &v, NULL, NULL);
		    ASSERT_BREAK((SUCCEEDED(hr)) && ((v.vt == VT_NULL) || (v.vt == eVariantType )));

		    if (bRet = (bool)SUCCEEDED(hr))
		    {
			    if ( v.vt != VT_NULL && v.parray != NULL )
			    {
                    if (v.vt == eVariantType )
                    {
					    bRet = TRUE ;
                    }
                    else
                    {
                        bRet = FALSE;
                    }
			    }
                else
			    {
				    bRet = FALSE;
			    }
		    }
        }
        catch(...)
        {
            if(pName != NULL)
            {
                SysFreeString(pName);
                pName = NULL;
            }
            throw;
        }

       if(pName != NULL)
       {
            SysFreeString(pName);
            pName = NULL;
       }
	}


	if (!bRet)
	{
		VariantClear(&v);
	}

	return bRet;
}


DWORD Win32SecurityDescriptor::FillSIDFromTrustee(CInstance *pTrustee, CSid& sid )
{

	IWbemClassObjectPtr m_piClassObject;
    m_piClassObject.Attach(pTrustee->GetClassObjectInterface());

	VARIANT vtmp ;
	DWORD dwStatus = ERROR_SUCCESS ;

	if(GetArray(m_piClassObject,IDS_SID,  vtmp, VT_UI1|VT_ARRAY ) )
	{

		if( vtmp.parray )
		{

			if ( SafeArrayGetDim ( vtmp.parray ) == 1 )
			{
				long lLowerBound , lUpperBound = 0 ;

				SafeArrayGetLBound ( vtmp.parray, 1, & lLowerBound ) ;
				SafeArrayGetUBound ( vtmp.parray, 1, & lUpperBound ) ;

				PSID pSid = NULL ;
				PVOID pTmp = NULL ;
				if(SUCCEEDED(SafeArrayAccessData(vtmp.parray, &pTmp) ) )
				{
					pSid = (PSID) malloc(lUpperBound - lLowerBound + 1) ;

					if (pSid == NULL)
					{
						SafeArrayUnaccessData(vtmp.parray) ;
						VariantClear( &vtmp ) ;
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}

					memcpy(pSid,pTmp,lUpperBound - lLowerBound + 1) ;
					SafeArrayUnaccessData(vtmp.parray) ;

					try
					{
						sid = CSid(pSid);
							//free(pSid) ;
					}
					catch (...)
					{
						if(pSid != NULL)
						{
							free(pSid);
							pSid = NULL;
						}

						VariantClear( &vtmp ) ;
						throw;
					}

					if(pSid != NULL)
                    {
                        free(pSid);
                        pSid = NULL;
                    }
				}
				else
				{
					dwStatus = ERROR_INVALID_PARAMETER ;
				}
			}
			else
			{
				dwStatus = ERROR_INVALID_PARAMETER ;
			}
		}
		VariantClear( &vtmp ) ;
	}
	else
	{
		dwStatus = ERROR_INVALID_PARAMETER ;
	}


	return dwStatus ;
}


void Win32SecurityDescriptor::FillTrusteeFromSID (CInstance* pTrustee, CSid& Sid)
{
	if (pTrustee)
	{
		PSID pSid = NULL;
		pSid = Sid.GetPSid();

		// get account name
		CHString chsAccount = Sid.GetAccountName();
		pTrustee->SetCHString(IDS_Name, chsAccount);

		// set the UINT8 array for the pSid
		DWORD dwSidLength = Sid.GetLength();
		SAFEARRAY* sa;
		SAFEARRAYBOUND rgsabound[1];
		VARIANT vValue;
		VariantInit(&vValue);

		rgsabound[0].cElements = dwSidLength;

		PSID pSidTrustee = NULL ;

		rgsabound[0].lLbound = 0;
		sa = SafeArrayCreate(VT_UI1, 1, rgsabound);

        if ( V_ARRAY ( &vValue ) == NULL )
		{
			if (pSid != NULL)
            {
                FreeSid(pSid);
            }
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		     // Get a pointer to read the data into
  		SafeArrayAccessData(sa, &pSidTrustee);
  		memcpy(pSidTrustee, pSid, rgsabound[0].cElements);
  		SafeArrayUnaccessData(sa);

		// Put the safearray into a variant, and send it off
		V_VT(&vValue) = VT_UI1 | VT_ARRAY; V_ARRAY(&vValue) = sa;
		pTrustee->SetVariant(L"SID", vValue);

		VariantClear(&vValue);

		FreeSid(pSid);

        pTrustee->SetDWORD(IDS_SidLength, dwSidLength);

        // Fill in the SIDString property...
        pTrustee->SetCHString(IDS_SIDString, Sid.GetSidString());
	}
}

HRESULT Win32SecurityDescriptor::FillInstanceDACLFromSDDACL (CInstance* pInstance, CDACL& dacl)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	SAFEARRAY* saDACL;
	SAFEARRAYBOUND rgsabound[1];

    // Need merged list..
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
	    DWORD dwLength = t_ael.NumEntries();
	    rgsabound[0].cElements = dwLength;
	    rgsabound[0].lLbound = 0;

	    saDACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);

	    // walk DACL looking for the sid path passed in....
	    ACLPOSITION aclPos;
	    t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CInstancePtr pACEInstance;
	    long ix[1];
	    ix[0] = 0;

	    while (t_ael.GetNext(aclPos, ACE ))
	    {
		    // take the AccessEntry and turn it into a Win32_ACE instance
		    hr = CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_ACE", &pACEInstance, GetNamespace());
		    if (SUCCEEDED(hr))
		    {
			    CSid TrusteeSid;
			    PSID pSID = NULL;
		        //Win32_Trustee Trustee;
			    ACE.GetSID( TrusteeSid );

			    CInstancePtr pTrusteeInstance;
			    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrusteeInstance, GetNamespace())))
			    {
				    FillTrusteeFromSID(pTrusteeInstance, TrusteeSid);
				    pACEInstance->SetEmbeddedObject(L"Trustee", *pTrusteeInstance);
			    }	// end if
			    else
			    {
				    LogMessage(L"FillInstanceDACL - Failed to get an empty Win32_Trustee object");
				    hr = WBEM_E_FAILED;
			    }

			    DWORD dwAccessMask = ACE.GetAccessMask();
			    pACEInstance->SetDWORD(L"AccessMask", dwAccessMask);

			    DWORD dwAceType = ACE.GetACEType( );
			    pACEInstance->SetDWORD(L"AceType", dwAceType);

			    DWORD dwAceFlags = ACE.GetACEFlags( );
			    pACEInstance->SetDWORD(L"AceFlags", dwAceFlags);

		        //string GuidObjectType;	-- NT 5 only

		        //string GuidInheritedObjectType;	-- NT 5 only

			    // Get the IUnknown of the Win32_ACE object.   Convert it to a
			    // variant of type VT_UNKNOWN.  Then, add the variant to the
			    // SafeArray.   Eventually, to add the list to the actual
			    // Win32_SecurityDescriptor object, we will be using SetVariant
			    IWbemClassObjectPtr pClassObject;
                pClassObject.Attach(pACEInstance->GetClassObjectInterface());
			    if ( pClassObject != NULL )
			    {

				    VARIANT v;
				    VariantInit(&v);

				    v.vt   = VT_UNKNOWN;
				    v.punkVal = pClassObject ;


				    SafeArrayPutElement(saDACL, ix, pClassObject);

				    VariantClear(&v);
			    }	// end if

		    }
		    else
		    {
			    hr = WBEM_E_FAILED;
		    }
	    }	// end while loop

	    t_ael.EndEnum(aclPos);
    }

	// now, set the DACL property in the Instance passed in.
	pInstance->SetStringArray(L"DACL", *saDACL);
	return(hr);
}

HRESULT Win32SecurityDescriptor::FillInstanceSACLFromSDSACL (CInstance* pInstance, CSACL& sacl)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	SAFEARRAY* saSACL;
	SAFEARRAYBOUND rgsabound[1];

    // First need a merged list...
    CAccessEntryList t_ael;
    if(sacl.GetMergedACL(t_ael))
    {
	    DWORD dwLength = t_ael.NumEntries();
	    rgsabound[0].cElements = dwLength;
	    rgsabound[0].lLbound = 0;

	    saSACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);

	    // walk DACL looking for the sid path passed in....
	    ACLPOSITION aclPos;
	    t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CInstancePtr pACEInstance;
	    long ix[1];
	    ix[0] = 0;

	    while (t_ael.GetNext(aclPos, ACE ))
	    {
		    // take the AccessEntry and turn it into a Win32_ACE instance
		    hr = CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_ACE", &pACEInstance, GetNamespace());
		    if (SUCCEEDED(hr))
		    {
			    CSid TrusteeSid;
			    PSID pSID = NULL;
		        //Win32_Trustee Trustee;
			    ACE.GetSID( TrusteeSid );

			    CInstancePtr pTrusteeInstance;
			    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrusteeInstance, GetNamespace())))
			    {
				    FillTrusteeFromSID(pTrusteeInstance, TrusteeSid);
				    pACEInstance->SetEmbeddedObject(L"Trustee", *pTrusteeInstance);
			    }	// end if
			    else
			    {
				    LogMessage(L"FillInstanceSACL - Failed to get an empty Win32_Trustee object");
				    hr = WBEM_E_FAILED;
			    }

			    DWORD dwAccessMask = ACE.GetAccessMask();
			    pACEInstance->SetDWORD(L"AccessMask", dwAccessMask);

			    DWORD dwAceType = ACE.GetACEType( );
			    pACEInstance->SetDWORD(L"AceType", dwAceType);

			    DWORD dwAceFlags = ACE.GetACEFlags( );
			    pACEInstance->SetDWORD(L"AceFlags", dwAceFlags);

		        //string GuidObjectType;	-- NT 5 only

		        //string GuidInheritedObjectType;	-- NT 5 only

			    // Get the IUnknown of the Win32_ACE object.   Convert it to a
			    // variant of type VT_UNKNOWN.  Then, add the variant to the
			    // SafeArray.   Eventually, to add the list to the actual
			    // Win32_SecurityDescriptor object, we will be using SetVariant
			    IWbemClassObjectPtr pClassObject;
                pClassObject.Attach(pACEInstance->GetClassObjectInterface());
			    if ( pClassObject )
			    {

				    VARIANT v;
				    VariantInit(&v);

				    v.vt   = VT_UNKNOWN;
				    v.punkVal = pClassObject ;


				    SafeArrayPutElement(saSACL, ix, pClassObject);

				    VariantClear(&v);
			    }	// end if

		    }
		    else
		    {
			    hr = WBEM_E_FAILED;
		    }
	    }	// end while loop

	    t_ael.EndEnum(aclPos);
    }
	// now, set the DACL property in the Instance passed in.
	pInstance->SetStringArray(L"DACL", *saSACL);
	return(hr);
}




// NT4 SP4 doesn't support SetSecurityDescriptorControl, so
// emulate it here
//
DWORD Win32SecurityDescriptor::SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR psd,
                             SECURITY_DESCRIPTOR_CONTROL wControlMask,
                             SECURITY_DESCRIPTOR_CONTROL wControlBits)
{
    DWORD dwErr = NOERROR;
    PISECURITY_DESCRIPTOR pSD = (PISECURITY_DESCRIPTOR)psd;

    if (pSD)
        pSD->Control = (pSD->Control & ~wControlMask) | wControlBits;
    else
        dwErr = ERROR_INVALID_PARAMETER;

    return dwErr;
}

//extern "C" POLARITY
void GetDescriptorFromMySecurityDescriptor( CInstance* pInstance,
											PSECURITY_DESCRIPTOR *ppDescriptor)
{
	PSECURITY_DESCRIPTOR pTempDescriptor;

	MySecurityDescriptor.GetDescriptor(pInstance, pTempDescriptor);

	*ppDescriptor = pTempDescriptor;
}

//extern "C" POLARITY
void SetSecurityDescriptorFromMyDescriptor(	PSECURITY_DESCRIPTOR pDescriptor,
											PSECURITY_INFORMATION pInformation,
											CInstance* pInstance)
{
	MySecurityDescriptor.SetDescriptor(pInstance, pDescriptor, pInformation);
}

//extern "C" POLARITY
void GetSDFromWin32SecurityDescriptor( IWbemClassObject* pObject,
											PSECURITY_DESCRIPTOR *ppDescriptor)
{
	PSECURITY_DESCRIPTOR pTempDescriptor, temp2 = NULL;

	CInstance Instance(pObject, NULL);
	try
    {
        MySecurityDescriptor.GetDescriptor(&Instance, pTempDescriptor, &temp2);
    }
    catch(...)
    {
        if(pTempDescriptor != NULL)
        {
            free(pTempDescriptor);
            pTempDescriptor = NULL;
        }
    }
	pObject = Instance.GetClassObjectInterface();

	// I dont want this copy.
	free(pTempDescriptor);

	*ppDescriptor = temp2;
}

//extern "C" POLARITY
void SetWin32SecurityDescriptorFromSD(	PSECURITY_DESCRIPTOR pDescriptor,
											PSECURITY_INFORMATION pInformation,
											bstr_t lpszPath,
											IWbemClassObject **ppObject)
{
	CInstance Instance(*ppObject, NULL);
	if (0 < lpszPath.length())
	{
		Instance.SetWCHARSplat(IDS_Path, (WCHAR*)lpszPath);
		MySecurityDescriptor.SetDescriptor(&Instance, pDescriptor, pInformation);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitysettingoflogicalfile.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//	Win32SecuritySettingOfLogicalFile.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include "sid.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "Win32SecuritySettingOfLogicalFile.h"
#include "securefile.h"
#include "file.h"
#include "Win32LogicalFileSecuritySetting.h"

typedef std::vector<_bstr_t> BSTRTVEC;

/*
    [Dynamic, Provider, dscription("")]
class Win32_SecuritySettingOfLogicalFile : Win32_SecuritySettingOfObject
{
    	[key]
    CIM_LogicalFile ref Element;

    	[key]
    Win32_LogicalFileSecuritySetting ref Setting;
};

*/

Win32SecuritySettingOfLogicalFile MyWin32SecuritySettingOfLogicalFile( WIN32_SECURITY_SETTING_OF_LOGICAL_FILE_NAME, IDS_CimWin32Namespace );

Win32SecuritySettingOfLogicalFile::Win32SecuritySettingOfLogicalFile ( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/ )
: CImplement_LogicalFile(setName, pszNameSpace)
{
}

Win32SecuritySettingOfLogicalFile::~Win32SecuritySettingOfLogicalFile ()
{
}

HRESULT Win32SecuritySettingOfLogicalFile::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We might have been asked for the security settings for a specific set of files,
    // in which case we don't have to ask for all the instances of cim_logicalfile, of
    // which there might be a few.
    BSTRTVEC vectorElements;
    BSTRTVEC vectorSettings;
    pQuery.GetValuesForProp(IDS_Element, vectorElements);
    pQuery.GetValuesForProp(IDS_Setting, vectorSettings);
    DWORD dwElements = vectorElements.size();
    DWORD dwSettings = vectorSettings.size();
    // TYPE 1
    if(dwElements != 0 && dwSettings == 0)
    {
        // We have a list of the files the user is interested in.  Run through each:
        CHString chstrFileFullPathName;
        for(LONG m = 0L; m < dwElements; m++)
        {
            CHString chstrElement((WCHAR*)vectorElements[m]);

            chstrFileFullPathName = chstrElement.Mid(chstrElement.Find(_T('='))+2);
            chstrFileFullPathName = chstrFileFullPathName.Left(chstrFileFullPathName.GetLength() - 1);
            CHString chstrLFSSPATH;
            chstrLFSSPATH.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                     (LPCTSTR)GetLocalComputerName(),
                                     IDS_CimWin32Namespace,
                                     (LPCTSTR)chstrFileFullPathName);
            AssociateLFSSToLFNT(pMethodContext, chstrElement, chstrLFSSPATH, 1);

        }
    }
    // TYPE 2
    else if(dwSettings != 0 && dwElements == 0)
    {
        // We have a list of the LogicalFileSecuritySettings the user is interested in.  Run through each:
        CHString chstrFileFullPathName;
        for(LONG m = 0L; m < dwSettings; m++)
        {
            CHString chstrSetting((WCHAR*)vectorSettings[m]);;

            chstrFileFullPathName = chstrSetting.Mid(chstrSetting.Find(_T('='))+2);
            chstrFileFullPathName = chstrFileFullPathName.Left(chstrFileFullPathName.GetLength() - 1);
            CHString chstrLFSSPATH;
            chstrLFSSPATH.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                     (LPCTSTR)GetLocalComputerName(),
                                     IDS_CimWin32Namespace,
                                     (LPCTSTR)chstrFileFullPathName);
            AssociateLFSSToLFNT(pMethodContext, chstrSetting, chstrLFSSPATH, 2);
        }
    }
    else
    {
        EnumerateInstances(pMethodContext,lFlags);
    }
    return hr;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	Win32SecuritySettingOfLogicalFile::EnumerateInstances
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32SecuritySettingOfLogicalFile::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;

			// let the callback do the real work
	if (SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstancesAsynch(L"CIM_LogicalFile", this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, NULL)))
	{

	}

	return(hr);

}

/*****************************************************************************
 *
 *  FUNCTION    : Win32SecuritySettingOfLogicalFile::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32SecuritySettingOfLogicalFile::EnumerationCallback(CInstance* pFile, MethodContext* pMethodContext, void* pUserData)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// Start pumping out the instances
    CInstancePtr pInstance;
    pInstance.Attach(CreateNewInstance(pMethodContext));
	if (NULL != pInstance)
	{
	    CHString chsNamePath;
	    CHString chsName;
		CHString chsFileName;
	    CHString chsFilePath;
	    CHString chsFileSecurityPath;

	    // take the file and make a path for the CIM_LogicalFIle part of the instance
	    pFile->GetCHString(L"__RELPATH", chsNamePath);
	    pFile->GetCHString(IDS_Name, chsName);
	    chsFilePath.Format(L"\\\\%s\\%s:%s", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, (LPCTSTR)chsNamePath);

	    // now, build a path for the LogicalFileSecuritySetting
		// but first, escape the chsName with backslashes
		int nLength;
		nLength = chsName.GetLength();
		for (int i = 0; i<nLength; i++)
		{
			chsFileName += chsName[i];
			if (chsName[i] == L'\\')
			{
				chsFileName += L"\\";
			}
		}

	    chsFileSecurityPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, L"Win32_LogicalFileSecuritySetting", IDS_Path, (LPCTSTR)chsFileName);

	    //  now set the elements of the actual instance
	    pInstance->SetCHString(IDS_Element, chsFilePath);
	    pInstance->SetCHString(IDS_Setting, chsFileSecurityPath);
	    hr = pInstance->Commit();
	}	// end if
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32SecuritySettingOfLogicalFile::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT WINAPI Win32SecuritySettingOfLogicalFile::StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData)
{
	Win32SecuritySettingOfLogicalFile* pThis;
	HRESULT hr;

	pThis = dynamic_cast<Win32SecuritySettingOfLogicalFile *>(pThat);
	ASSERT_BREAK(pThis != NULL);

	if (pThis)
	{
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
	}
	else
	{
    	hr = WBEM_E_FAILED;
	}
	return hr;
}


HRESULT Win32SecuritySettingOfLogicalFile::GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	if (pInstance)
	{
		CHString chsFilePath;
        CHString chstrTemp;
        CHString chstrElement;
        CHString chstrElementPathname;
        CHString chstrSetting;
        CHString chstrSettingPathname;
		pInstance->GetCHString(IDS_Element, chstrElement);
        pInstance->GetCHString(IDS_Setting, chstrSetting);

        // Get the file pathname portion from each:
        chstrElementPathname = chstrElement.Mid(chstrElement.Find(_T('='))+2);
        chstrElementPathname = chstrElementPathname.Left(chstrElementPathname.GetLength() - 1);
        chstrSettingPathname = chstrSetting.Mid(chstrSetting.Find(_T('='))+2);
        chstrSettingPathname = chstrSettingPathname.Left(chstrSettingPathname.GetLength() - 1);

        // they must be the same
        if(chstrElementPathname.CompareNoCase(chstrSettingPathname)==0)
        {
            // Now just confirm that the file exists and that we can get security from it:
            CHString chstrLFSSPATH;
            chstrLFSSPATH.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                     (LPCTSTR)GetLocalComputerName(),
                                     IDS_CimWin32Namespace,
                                     (LPCTSTR)chstrElementPathname);
            hr = AssociateLFSSToLFNT(pInstance->GetMethodContext(), chstrElement, chstrLFSSPATH, 1);
        }
    }
	return(hr);
}





#ifdef NTONLY
HRESULT Win32SecuritySettingOfLogicalFile::AssociateLFSSToLFNT(MethodContext* pMethodContext,
                                                               CHString& chstrLF,
                                                               CHString& chstrLFSSPATH,
                                                               short sQueryType)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrLFDrive;
    CHString chstrLFPath;
    CHString chstrLFName;
    CHString chstrLFExt;
    CHString chstrFullPathName;
    bool fRoot;

    // If we came from a TYPE 1 query (see above), the chstrLF arg will be a full
    // wbem path like \\1of1\root\cimv2:Win32_Directory.Name="x:\\temp" ; on the
    // other hand, if we came from a TYPE 2 query, chstrLF will  contain
    // \\1of1\root\cimv2:Win32_LogicalFileSecuritySetting.Name="x:\\temp" (which of
    // course isn't a logicalfile, but we just need the file name.

    // So to get the file name, extract it and remove the extra backslashes.
    chstrFullPathName = chstrLF.Mid(chstrLF.Find(_T('='))+2);
    chstrFullPathName = chstrFullPathName.Left(chstrFullPathName.GetLength() - 1);


    // Break the directory into its constituent parts
    GetPathPieces(RemoveDoubleBackslashes(chstrFullPathName), chstrLFDrive, chstrLFPath, chstrLFName, chstrLFExt);

    // Find out if we are looking for the root directory
    if(chstrLFPath==L"\\" && chstrLFName==L"" && chstrLFExt==L"")
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrLFPath = L"";
    }
    else
    {
        fRoot = false;
    }

    // EnumDirsNT will call LoadPropertyValues in this class, and it needs the element and
    // setting entries, so populate here...
    ELSET elset;
    elset.pwstrElement = (LPCWSTR) chstrLF;
    elset.pwstrSetting = (LPCWSTR) chstrLFSSPATH;

    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                    chstrLFDrive,   // drive letter and colon
                    chstrLFPath,    // use the given path
                    chstrLFName,    // filename
                    chstrLFExt,     // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)&elset)); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif


#ifdef WIN9XONLY
HRESULT Win32SecuritySettingOfLogicalFile::AssociateLFSSToLF95(MethodContext* pMethodContext,
                                                               CHString& chstrLF,
                                                               CHString& chstrLFSSPATH,
                                                               short sQueryType);
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrLFDrive;
    CHString chstrLFPath;
    CHString chstrLFName;
    CHString chstrLFExt;
    CHString chstrFullPathName;
    bool fRoot;

    // If we came from a TYPE 1 query (see above), the chstrLF arg will be a full
    // wbem path like \\1of1\root\cimv2:Win32_Directory.Name="x:\\temp" ; on the
    // other hand, if we came from a TYPE 2 query, chstrLF will  contain
    // \\1of1\root\cimv2:Win32_LogicalFileSecuritySetting.Name="x:\\temp" (which of
    // course isn't a logicalfile, but we just need the file name.

    // So to get the file name, extract it and remove the extra backslashes.
    chstrFullPathName = chstrLF.Mid(chstrLF.Find(_T('='))+2);
    chstrFullPathName = chstrFullPathName.Left(chstrFullPathName.GetLength() - 1);


    // Break the directory into its constituent parts
    GetPathPieces(RemoveDoubleBackSlashes(chstrFullPathName), chstrLFDrive, chstrLFPath, chstrDFName, chstrLFExt);

    // Find out if we are looking for the root directory
    if(chstrLFPath==_T("\\") && chstrLFName==_T("") && chstrLFExt==_T(""))
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrLFPath = _T("");
    }
    else
    {
        fRoot = false;
    }

    // EnumDirsNT will call LoadPropertyValues in this class, and it needs the element and
    // setting entries, so populate here...
    ELSET elset;
    elset.pwstrElement = (LPCWSTR) chstrLF;
    elset.pwstrSetting = (LPCWSTR) chstrLFSSPATH;

    hr = EnumDirs95(C95EnumParm(pMethodContext,
                    chstrLFDrive,   // drive letter and colon
                    chstrLFPath,    // use the given path
                    chstrLFName,    // filename
                    chstrLFExt,     // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)&elset)); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif




/*****************************************************************************
 *
 *  FUNCTION    : Win32SecuritySettingOfLogicalFile::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  Overridden here
 *                to return true only if we can get the security on the file,
 *                via the class CSecurFile.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE can get security info, FALSE otherwise.
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL Win32SecuritySettingOfLogicalFile::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    BOOL fRet = FALSE;
    if(wcslen(wstrFullPathName) < 2)
    {
        fRet = FALSE;
    }
    else
    {
        CSecureFile secFile;
        DWORD dwRet = secFile.SetFileName(wstrFullPathName, TRUE);
		if (ERROR_ACCESS_DENIED != dwRet)
		{
            fRet = TRUE;
		}	// end if
		else
		{
			fRet = FALSE;
		}
    }
    return fRet;
}
#endif


#ifdef WIN9XONLY
BOOL Win32SecuritySettingOfLogicalFile::IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                             const char* strFullPathName)
{
    BOOL fRet = FALSE;
    if(strlen(strFullPathName) < 2)
    {
        fRet = FALSE;
    }
    else
    {
        CSecureFile secFile;
        DWORD dwRet = secFile.SetFileName(strFullPathName, TRUE);
		if (ERROR_ACCESS_DENIED != dwRet)
		{
            fRet = TRUE;
		}	// end if
		else
		{
			fRet = FALSE;
		}
    }
    return fRet;
}
#endif




/*****************************************************************************
 *
 *  FUNCTION    : Win32SecuritySettingOfLogicalFile::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherrited from CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the Element and Setting
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef WIN9XONLY
void Win32SecuritySettingOfLogicalFile::LoadPropertyValues95(CInstance* pInstance,
                                         LPCTSTR pszDrive,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszFSName,
                                         LPWIN32_FIND_DATA pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrFileName;
    CHString chstrFilePATH;

    // Note: this routine will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    PELSET pelset = (PELSET)pvMoreData;

    // It is possible (if we got here from a TYPE 2 query - see above), that the Element member of pelset
    // is actually the setting.  We need to convert one to the other.  So here is what we have and want:
    // Have:   \\1of1\\root\cimv2:Win32_LogicalFileSecuritySetting.Path="x:\\test"
    // Want:   \\1of1\\root\cimv2:CimLogicalFile.Name="x:\\test"
    CHString chstrElement;
    if(wcsstr(pelset->pwstrElement, WIN32_LOGICAL_FILE_SECURITY_SETTING))
    {
        // So it was from a TYPE 2, so need to convert.
        CHString chstrTmp2;
        CHString chstrTmp(pelset->pwstrElement);
        chstrTmp2 = chstrTmp.Mid(chstrTmp.Find(_T('='))+2);
        chstrTmp2 = chstrTmp2.Left(chstrTmp2.GetLength() - 1);
        chstrElement.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                            (LPCWSTR)GetLocalComputerName(),
                            IDS_CimWin32Namespace,
                            PROPSET_NAME_FILE,
                            (LPCWSTR)chstrTmp2);
    }
    else
    {
        chstrElement = pelset->pwstrElement;
    }
    pInstance->SetCHString(IDS_Element, chstrElement);
    pInstance->SetWCHARSplat(IDS_Setting, pelset->pwstrSetting);


}
#endif


#ifdef NTONLY
void Win32SecuritySettingOfLogicalFile::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrFileName;
    CHString chstrFilePATH;

    // Note: this routine will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    PELSET pelset = (PELSET)pvMoreData;

    // It is possible (if we got here from a TYPE 2 query - see above), that the Element member of pelset
    // is actually the setting.  We need to convert one to the other.  So here is what we have and want:
    // Have:   \\1of1\\root\cimv2:Win32_LogicalFileSecuritySetting.Path="x:\\test"
    // Want:   \\1of1\\root\cimv2:CimLogicalFile.Name="x:\\test"
    CHString chstrElement;
    if(wcsstr(pelset->pwstrElement, WIN32_LOGICAL_FILE_SECURITY_SETTING))
    {
        // So it was from a TYPE 2, so need to convert.
        CHString chstrTmp2;
        CHString chstrTmp(pelset->pwstrElement);
        chstrTmp2 = chstrTmp.Mid(chstrTmp.Find(_T('='))+2);
        chstrTmp2 = chstrTmp2.Left(chstrTmp2.GetLength() - 1);
        chstrElement.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                            (LPCWSTR)GetLocalComputerName(),
                            IDS_CimWin32Namespace,
                            PROPSET_NAME_FILE,
                            (LPCWSTR)chstrTmp2);
    }
    else
    {
        chstrElement = pelset->pwstrElement;
    }
    pInstance->SetCHString(IDS_Element, chstrElement);
    pInstance->SetWCHARSplat(IDS_Setting, pelset->pwstrSetting);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitysettingoflogicalshare.h ===
//

//

//	Win32SecuritySettingOfLogicalShare

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////
#ifndef __Win32SecuritySettingOfLogicalShare_H_
#define __Win32SecuritySettingOfLogicalShare_H_

#define  WIN32_SECURITY_SETTING_OF_LOGICAL_SHARE_NAME L"Win32_SecuritySettingOfLogicalShare"

class Win32SecuritySettingOfLogicalShare : public Provider
{
private:
protected:
public:
	Win32SecuritySettingOfLogicalShare (LPCWSTR setName, LPCWSTR pszNameSpace =NULL);
	~Win32SecuritySettingOfLogicalShare ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

};	// end class Win32SecuritySettingOfLogicalShare

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitysettingoflogicalshare.cpp ===
//

//	Win32SecuritySettingOfLogicalShare.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////
#include "precomp.h"
//#include "helper.h"
#include "sid.h"
#include "Win32SecuritySettingOfLogicalShare.h"
/*
    [Dynamic, Provider("cimwin33"), dscription("")]
class Win32_SecuritySettingOfLogicalShare : Win32_SecuritySettingOfObject
{
    	[key]
    Win32_Share ref Element;

    	[key]
    Win32_LogicalShareSecuritySetting ref Setting;
};

*/

Win32SecuritySettingOfLogicalShare MyWin32SecuritySettingOfLogicalShare( WIN32_SECURITY_SETTING_OF_LOGICAL_SHARE_NAME, IDS_CimWin32Namespace );

Win32SecuritySettingOfLogicalShare::Win32SecuritySettingOfLogicalShare (LPCWSTR setName, LPCWSTR pszNameSpace /*=NULL*/ )
: Provider(setName, pszNameSpace)
{
}

Win32SecuritySettingOfLogicalShare::~Win32SecuritySettingOfLogicalShare ()
{
}

HRESULT Win32SecuritySettingOfLogicalShare::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	CInstancePtr pInstance ;

	// Collections
	TRefPointerCollection<CInstance>	shareList;

	// Perform queries
	//================

//	if (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_Share"),
//		&shareList, IDS_CimWin32Namespace, pMethodContext )))

	if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"SELECT Name FROM Win32_Share",
		&shareList, pMethodContext, GetNamespace() )))
	{
		REFPTRCOLLECTION_POSITION	sharePos;

		CInstancePtr pShare ;

		if ( shareList.BeginEnum( sharePos ) )
		{

			for (	pShare.Attach ( shareList.GetNext( sharePos ) ) ;
					( pShare != NULL ) && SUCCEEDED ( hr ) ;
					pShare.Attach ( shareList.GetNext( sharePos ) )
				)
			{
                CHString chsName;
				pShare->GetCHString(IDS_Name, chsName);

				if (!chsName.IsEmpty())
				{
					pInstance.Attach ( CreateNewInstance ( pMethodContext ) ) ;
                    if(pInstance != NULL)
                    {
					    // only proceed if we can get a corresponding instance of win32_logicalsharesecuritysetting
                        // (which we may not as we may not have security permissions to get that info)
                        CInstancePtr pTmpInst ;
                        CHString settingPath;
                        settingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                                L"Win32_LogicalShareSecuritySetting", IDS_Name, chsName);

                        if(SUCCEEDED(CWbemProviderGlue::GetInstanceKeysByPath(settingPath, &pTmpInst, pMethodContext )))
                        {
                            // set relpath to file
					        CHString chsSharePath;
					        GetLocalInstancePath(pShare, chsSharePath);
					        pInstance->SetCHString(IDS_Element, chsSharePath);

					        // and set the reference in the association
					        pInstance->SetCHString(IDS_Setting, settingPath);
					        // to that relpath.
					        hr = pInstance->Commit () ;
                        }
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
				}
			}	// WHILE GetNext

			shareList.EndEnum();
		}	// IF BeginEnum
	}
	return(hr);
}

HRESULT Win32SecuritySettingOfLogicalShare::GetObject ( CInstance* pInstance, long lFlags)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	if(pInstance)
	{
		CInstancePtr pLogicalShareInstance ;
		CInstancePtr pSecurityInstance ;

		// get instance by path on CIM_LogicalFile part
		CHString chsSharePath;
		pInstance->GetCHString(IDS_Element, chsSharePath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsSharePath, &pLogicalShareInstance, pMethodContext)))
		{
            CHString chstrElementName;
            pLogicalShareInstance->GetCHString(IDS_Name, chstrElementName);
            CHString chsSecurityPath;
			pInstance->GetCHString(IDS_Setting, chsSecurityPath);

			if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsSecurityPath, &pSecurityInstance, pMethodContext)))
            {
                // endpoints exist... are they related?
                CHString chstrSettingName;
                pSecurityInstance->GetCHString(IDS_Name, chstrSettingName);
                if(chstrSettingName.CompareNoCase(chstrElementName) == 0)
                {
                    // they had the same name... good enough...
                    hr = WBEM_S_NO_ERROR;
                }
            }
		}
	}
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitysettingoflogicalfile.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//
//	Win32SecuritySettingOfLogicalFile
//
//////////////////////////////////////////////////////
#ifndef __Win32SecuritySettingOfLogicalFile_H_
#define __Win32SecuritySettingOfLogicalFile_H_

#define  WIN32_SECURITY_SETTING_OF_LOGICAL_FILE_NAME L"Win32_SecuritySettingOfLogicalFile"

#include "implement_logicalfile.h"


typedef struct _ELSET
{
    LPCWSTR pwstrElement;
    LPCWSTR pwstrSetting;
} ELSET, *PELSET;

class Win32SecuritySettingOfLogicalFile : public CImplement_LogicalFile
{        
    public:
	    Win32SecuritySettingOfLogicalFile (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	    ~Win32SecuritySettingOfLogicalFile ();

	    virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );
	    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);

	    HRESULT EnumerationCallback(CInstance* pFile, MethodContext* pMethodContext, void* pUserData);
	    static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData);

    protected:

       // Overridable function inherrited from CImplement_LogicalFile
#ifdef WIN9XONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                               const char* strFullPathName);

        virtual void LoadPropertyValues95(CInstance* pInstance,
                                          LPCTSTR pszDrive, 
                                          LPCTSTR pszPath, 
                                          LPCTSTR pszFSName, 
                                          LPWIN32_FIND_DATA pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual void LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif


    private:

#ifdef NTONLY
        HRESULT AssociateLFSSToLFNT(MethodContext* pMethodContext,
                                    CHString& chstrLF,
                                    CHString& chstrLFSSPATH,
                                    short sQueryType);
#endif
#ifdef WIN9XONLY
        HRESULT AssociateLFSSToLF95(MethodContext* pMethodContext,
                                    CHString& chstrLF,
                                    CHString& chstrLFSSPATH,
                                    short sQueryType);
#endif

};	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32sid.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//
//	Win32SID
//
//////////////////////////////////////////////////////
#ifndef __Win32SID_H_
#define __Win32SID_H_

#define  WIN32_SID_NAME L"Win32_SID"

class Win32SID : public Provider
{
private:
	DWORD m_dwPlatformID;
protected:
public:
	Win32SID (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	~Win32SID ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

	HRESULT FillInstance(CInstance* pInstance, CHString& chsSID);
};	// end class Win32LogicalFileSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32sessionprocess.h ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
*******************************************************************/

// Property set identification
//============================

#pragma once

#define PROVIDER_NAME_WIN32SESSIONPROCESS L"Win32_SessionProcess"

#define PROP_ALL_REQUIRED          0xFFFFFFFF
#define PROP_NONE_REQUIRED         0x00000000
#define PROP_ANTECEDENT            0x00000001
#define PROP_DEPENDENT             0x00000002


class CWin32SessionProcess;


_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class CWin32SessionProcess : public Provider 
{
    public:
        // Constructor/destructor
        //=======================

        CWin32SessionProcess(
            LPCWSTR lpwszClassName, 
            LPCWSTR lpwszNameSpace);

        virtual ~CWin32SessionProcess();

#ifdef NTONLY

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(
            MethodContext*  pMethodContext, 
            long lFlags = 0L);

        virtual HRESULT GetObject(
            CInstance* pInstance, 
            long lFlags, 
            CFrameworkQuery& Query);
        


    private:
        HRESULT Enumerate(
            MethodContext *pMethodContext, 
            DWORD dwPropsRequired);

        HRESULT LoadPropertyValues(
            CInstance* pInstance, 
            CSession& user, 
            CProcess& proc, 
            DWORD dwPropsRequired);

        bool AreAssociated(
            const CInstance *pSesInst, 
             const CInstance *pProcInst);

        HRESULT ValidateEndPoints(
            MethodContext *pMethodContext, 
            const CInstance *pInstance, 
            CInstancePtr &pAntSesInst, 
            CInstancePtr &pDepProcInst);

        HRESULT EnumerateProcessesForSession(
            CSession& ses, 
            MethodContext *pMethodContext, 
            DWORD dwPropsRequired);

        DWORD GetRequestedProps(
            CFrameworkQuery& Query);

#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32subdirectory.cpp ===
//=================================================================

//

// Win32SubDirectory.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between win32_directory and its sub-directories
//
//=================================================================

#include "precomp.h"
#include <frqueryex.h>

#include "FileFile.h"
#include "Win32SubDirectory.h"
#include "directory.h"

// Property set declaration
//=========================
CW32SubDir MyCW32SubDir(PROPSET_NAME_WIN32SUBDIRECTORY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::CW32SubDir
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32SubDir::CW32SubDir(LPCWSTR setName, LPCWSTR pszNamespace)
:CImplement_LogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::~CW32SubDir
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32SubDir::~CW32SubDir()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32SubDir::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    if(pInstance != NULL)
    {
        CHString chstrParentDir;
        CHString chstrChildDir;

        // Get the two paths
        pInstance->GetCHString(IDS_GroupComponent, chstrParentDir);
        pInstance->GetCHString(IDS_PartComponent, chstrChildDir);

        CInstancePtr pinstParentDir;
        CInstancePtr pinstChildDir;

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrParentDir, &pinstParentDir, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrChildDir, &pinstChildDir, pInstance->GetMethodContext())))
            {
                // Both directories exist, but is one a subdirectory of the other?
                CHString chstrParentDirPathNameWhack;
                CHString chstrParentDirName;
                CHString chstrChildDirPath;
                LONG lPos;

                pinstParentDir->GetCHString(IDS_Name, chstrParentDirName);
                pinstChildDir->GetCHString(IDS_Path, chstrChildDirPath);

                lPos = chstrParentDirName.Find(L":");
                chstrParentDirPathNameWhack = chstrParentDirName.Mid(lPos+1);
                if(chstrParentDirPathNameWhack != _T("\\"))
                {
                    chstrParentDirPathNameWhack += _T("\\");
                }

                if(chstrChildDirPath == chstrParentDirPathNameWhack)
                {
                    // Yes, the child is a sub-directory of the parent
                    hr = WBEM_S_NO_ERROR;
                }

            } //childdir instancebypath
        } //parentdir instancebypath
    } // pinstance not null

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32SubDir::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    std::vector<_bstr_t> vecGroupComponents;
    std::vector<_bstr_t> vecPartComponents;
    DWORD dwNumGroupComponents;
    DWORD dwNumPartComponents;

    // Did they just ask for parent directories?
    pQuery.GetValuesForProp(IDS_GroupComponent, vecGroupComponents);
    dwNumGroupComponents = vecGroupComponents.size();

    // Did they just ask for subdirectories?
    pQuery.GetValuesForProp(IDS_PartComponent, vecPartComponents);
    dwNumPartComponents = vecPartComponents.size();

    // Find out what type of query it was.
    // Was it a 3TokenOR?
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);
    if (pQuery2 != NULL)
    {
        variant_t vCurrentDir;
        variant_t vSubDir;
        CHString chstrSubDirPath;
        CHString chstrCurrentDir;

        if ( (pQuery2->Is3TokenOR(IDS_GroupComponent, IDS_PartComponent, vCurrentDir, vSubDir)) &&
             ((V_BSTR(&vCurrentDir) != NULL) && (V_BSTR(&vSubDir) != NULL)) &&
             (wcscmp(V_BSTR(&vCurrentDir), V_BSTR(&vSubDir)) == 0) )
        {
            // It was indeed a three token or.  Also, the antecedent and decendent are equal as I expected.

            // 1) Associate this directory with its subdirectories:
            //======================================================
            ParsedObjectPath    *pParsedPath = NULL;
            CObjectPathParser	objpathParser;

            // Parse the path to get the domain/user
            int nStatus = objpathParser.Parse(V_BSTR(&vCurrentDir),  &pParsedPath);

            // Did we parse it and does it look reasonable?
            if (nStatus == 0)
            {
                try
                {
                    if ( (pParsedPath->m_dwNumKeys == 1) &&
                         (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) )
                    {

                        // This contains the complete object path
                        chstrCurrentDir = V_BSTR(&vCurrentDir);

                        // This contains just the 'value' part of the object path
                        chstrSubDirPath = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                        // Trim off the drive letter
                        CHString chstrDiskLetter = chstrSubDirPath.Left(2);
                        chstrSubDirPath = chstrSubDirPath.Mid(2);

                        if(chstrSubDirPath != _T("\\")) // it is not a root dir (proper syntax for root is just "\\", not "\\\\")
                        {
                            chstrSubDirPath += _T("\\"); // if not the root, need to tack on trailing pair of backslashes
                        }
                        hr = AssociateSubDirectories(pMethodContext, chstrDiskLetter, chstrSubDirPath);


                        // 2) This directory is also associated with its parent directory.  Manually create that
                        //    association here.  However, if this is the root dir, don't try to associate with
                        //    some non-existent parent!
                        //======================================================================================

                        if(chstrSubDirPath != _T("\\"))
                        {
                            hr = AssociateParentDirectory(pMethodContext, chstrCurrentDir);
                        }
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OBJECT_PATH;
                    }
                }
                catch ( ... )
                {
                    objpathParser.Free( pParsedPath );
                    throw;
                }

                objpathParser.Free( pParsedPath );
            }
            else
            {
                hr = WBEM_E_INVALID_OBJECT_PATH;
            }
        }
        else if(dwNumPartComponents > 0)
        {
            ParsedObjectPath    *pParsedPath = NULL;
            CObjectPathParser	objpathParser;

            for(LONG m = 0L; m < dwNumPartComponents; m++)
            {
                // Parse the path to get the domain/user
                int nStatus = objpathParser.Parse(vecPartComponents[m],  &pParsedPath);

                // Did we parse it?
                if (nStatus == 0)
                {
                    try
                    {
                        // Does it look reasonable
                        if ( (pParsedPath->m_dwNumKeys == 1) &&
                             (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) )
                        {
                            // This contains the complete object path
                            chstrCurrentDir = (wchar_t*)vecPartComponents[m];

                            // This contains just the 'value' part of the object path
                            chstrSubDirPath = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                            // Trim off the drive letter
                            chstrSubDirPath = chstrSubDirPath.Mid(2);

                            // Just want to associate to the parent directory (only if this isn't the root though)...
                            if(chstrSubDirPath != _T("\\"))
                            {   // Here the "current directory" is a subdirectory, and we want its parent
                                hr = AssociateParentDirectory(pMethodContext, chstrCurrentDir);
                            }
                        }
                    }
                    catch (...)
                    {
                        objpathParser.Free( pParsedPath );
                        throw;
                    }

                    // Clean up the Parsed Path
                    objpathParser.Free( pParsedPath );
                }
            }
        }
        else if(dwNumGroupComponents > 0)
        {
            ParsedObjectPath    *pParsedPath = NULL;
            CObjectPathParser	objpathParser;

            for(LONG m = 0L; m < dwNumGroupComponents; m++)
            {
                // Parse the path to get the domain/user
                int nStatus = objpathParser.Parse(vecGroupComponents[m],  &pParsedPath);

                // Did we parse it and does it look reasonable?
                if (nStatus == 0)
                {
                    try
                    {
                        if ( (pParsedPath->m_dwNumKeys == 1) &&
                             (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) )
                        {
                            // This contains the complete object path
                            chstrCurrentDir = (wchar_t*) vecGroupComponents[m];

                            // This contains just the 'value' part of the object path
                            chstrSubDirPath = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                            // Trim off the drive letter
                            CHString chstrDiskLetter = chstrSubDirPath.Left(2);
                            chstrSubDirPath = chstrSubDirPath.Mid(2);

                            if(chstrSubDirPath != _T("\\")) // it is not a root dir (proper syntax for root is just "\\", not "\\\\")
                            {
                                chstrSubDirPath += _T("\\"); // if not the root, need to tack on trailing pair of backslashes
                            }
                            // Just want to associate to subdirectories...
                            hr = AssociateSubDirectories(pMethodContext, chstrDiskLetter, chstrSubDirPath);
                        }
                    }
                    catch (...)
                    {
                        objpathParser.Free( pParsedPath );
                        throw;
                    }

                    // Clean up the Parsed Path
                    objpathParser.Free( pParsedPath );
                }
            }
        }
        else
        {
            // Don't have a clue, so return 'em all and let CIMOM sort it out...
            hr = EnumerateInstances(pMethodContext);
        }
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set. Let's hope nobody ever does
 *                this! It could take quite some time!!
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE
//
//WITH CHANGE TO MAKE THIS CLASS INHERRIT FROM CIMPLEMENTLOGICALFILE, NO NEED TO
//IMPLEMENT HERE AT ALL.  WHAT WILL HAPPEN IS ENUMINSTANCES FROM THE PARENT CLASS
//WILL BE CALLED, BUT ONLY DIRECTORIES WILL SATISFY THIS CLASS'S ISONEOFME (WHICH WILL
//BE THE VERSION OF THAT FUNCTION CALLED AS THIS IS THE MOST DERIVED VERSION),
//AND SIMILARLY THIS CLASS'S LOADPROPERTYVALUES WILL BE CALLED.
//
// NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE
//
//HRESULT CW32SubDir::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
//{
//    HRESULT hr = WBEM_S_NO_ERROR;
//    TRefPointerCollection<CInstance> LWin32Directories;
//
//    CHString chstrAllDirsQuery;
//    chstrAllDirsQuery.Format(_T("SELECT __PATH, %s, %s FROM Win32_Directory"), IDS_Drive, IDS_Name);
//    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllDirsQuery,
//                                                        &LWin32Directories,
//                                                        pMethodContext,
//                                                        IDS_CimWin32Namespace)))
//
//    {
//        REFPTRCOLLECTION_POSITION pos;
//        if(LWin32Directories.BeginEnum(pos))
//        {
//            CInstance* pinstWin32Directory = NULL;
//            CHString chstrQuery;
//            CHString chstrDrive;
//            CHString chstrDirPath;
//            CHString chstrDirName;
//            CHString chstrQueryPath;
//            CHString chstrParentDirPATH;
//            LONG lPos;
//
//           while((SUCCEEDED(hr)) && (pinstWin32Directory = LWin32Directories.GetNext(pos)))
//            {
//                if(pinstWin32Directory != NULL)
//                {
//                    pinstWin32Directory->GetCHString(_T("__PATH"), chstrParentDirPATH);
//                    pinstWin32Directory->GetCHString(IDS_Drive, chstrDrive);
//                    pinstWin32Directory->GetCHString(IDS_Name, chstrDirName);
//
//                    lPos = chstrDirName.Find(_T(":"));
//                   chstrDirPath = chstrDirName.Mid(lPos+1);
//                    if(chstrDirPath != _T("\\"))
//                    {
//                        chstrDirPath += _T("\\");
//                    }
//                    CHString chstrWbemizedPath;
//                    EscapeBackslashes(chstrDirPath, chstrWbemizedPath);
//                    chstrQuery.Format(_T("SELECT __PATH FROM Win32_Directory where Drive = \"%s\" and Path = \"%s\""), (LPCTSTR)chstrDrive, (LPCTSTR)chstrWbemizedPath);
//                    hr = QueryForSubItemsAndCommit(chstrParentDirPATH, chstrQuery, pMethodContext);
//
//                    pinstWin32Directory->elease();
//                }
//            }
//            LWin32Directories.EndEnum();
//        }
//    }
//    return hr;
//}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  That class
 *                returns files or directories where this one should only
 *                return directories, in response to queries, getobject commands,
 *                etc.  It is overridden here to return TRUE only if the file
 *                (the information for which is contained in the function
 *                arguement pstFindData) is of type directory.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if a file or FALSE if a directory
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CW32SubDir::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE);
    }
}
#endif


#ifdef WIN9XONLY
BOOL CW32SubDir::IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                             const char* strFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE);
    }
}
#endif




/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherritedfrom CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the PartComponent and GroupComponent
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef WIN9XONLY
void CW32SubDir::LoadPropertyValues95(CInstance* pInstance,
                                         LPCTSTR pszDrive,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszFSName,
                                         LPWIN32_FIND_DATA pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirNameAdj;
    CHString chstrDirPATH;

    CHString chstrSubDirName;
    CHString chstrSubDirNameAdj;
    CHString chstrSubDirPATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrDirName.Format(L"%s%s",(LPCWSTR)TOBSTRT(pszDrive),(LPCWSTR)TOBSTRT(pszPath));
    if(chstrDirName.GetLength() != 3)
    {   // it was not the root dir, so need to trim off trailing backslash.
        chstrDirName = chstrDirName.Left(chstrDirName.GetLength() - 1);
    }
    EscapeBackslashes(chstrDirName, chstrDirNameAdj);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirNameAdj);
    // Get the PartComponent (the subdirectory name) ready...
    chstrSubDirName.Format(L"%s%s%s",(LPCWSTR)TOBSTRT(pszDrive),(LPCWSTR)TOBSTRT(pszPath),(LPCWSTR)TOBSTRT(pstFindData->cFileName));
    EscapeBackslashes(chstrSubDirName, chstrSubDirNameAdj);
    chstrSubDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                          (LPCWSTR)GetLocalComputerName(),
                          IDS_CimWin32Namespace,
                          PROPSET_NAME_DIRECTORY,
                          (LPCWSTR)chstrSubDirNameAdj);
    // Set Properties...
    pInstance->SetCHString(IDS_GroupComponent, chstrDirPATH);
    pInstance->SetCHString(IDS_PartComponent, chstrSubDirPATH);

}
#endif


#ifdef NTONLY
void CW32SubDir::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirNameAdj;
    CHString chstrDirPATH;

    CHString chstrSubDirName;
    CHString chstrSubDirNameAdj;
    CHString chstrSubDirPATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrDirName.Format(L"%s%s",pszDrive,pszPath);
    if(chstrDirName.GetLength() != 3)
    {   // it was not the root dir, so need to trim off trailing backslash.
        chstrDirName = chstrDirName.Left(chstrDirName.GetLength() - 1);
    }
    EscapeBackslashes(chstrDirName, chstrDirNameAdj);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirNameAdj);
    // Get the PartComponent (the subdirectory name) ready...
    chstrSubDirName.Format(L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
    EscapeBackslashes(chstrSubDirName, chstrSubDirNameAdj);
    chstrSubDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                          (LPCWSTR)GetLocalComputerName(),
                          IDS_CimWin32Namespace,
                          PROPSET_NAME_DIRECTORY,
                          (LPCWSTR)chstrSubDirNameAdj);
    // Set Properties...
    pInstance->SetCHString(IDS_GroupComponent, chstrDirPATH);
    pInstance->SetCHString(IDS_PartComponent, chstrSubDirPATH);
}
#endif


HRESULT CW32SubDir::AssociateSubDirectories(MethodContext *pMethodContext, const CHString &chstrDiskLetter, const CHString& chstrSubDirPath)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                    chstrDiskLetter,
                    chstrSubDirPath, // use the given path
                    L"*",               // filename
                    L"*",               // extension
                    false,              // no recursion desired
                    NULL,               // don't need the file system name
                    NULL,               // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    false,              // this association is not interested in calling LoadPropertyValues for the root, only for files off of it
                    NULL));             // no extra parms needed
#endif
#ifdef WIN9XONLY
    hr = EnumDirs95(C95EnumParm(pMethodContext,
                    TOBSTRT(chstrDiskLetter),
                    TOBSTRT(chstrSubDirPath), // use the given path
                    _T("*"),            // filename
                    _T("*"),            // extension
                    false,              // no recursion desired
                    NULL,
                    NULL,
                    false,              // this association is not interested in calling LoadPropertyValues for the root, only for files off of it
                    NULL));             // no extra parms needed
#endif
    return hr;
}


HRESULT CW32SubDir::AssociateParentDirectory(MethodContext *pMethodContext, const CHString &chstrCurrentDir)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chstrParentDirPATH;

    if (chstrCurrentDir.Left(2) == L"\\\\")
    {
        chstrParentDirPATH = chstrCurrentDir;
    }
    else
    {
        chstrParentDirPATH.Format(L"\\\\%s\\%s:%s", GetLocalComputerName(), IDS_CimWin32Namespace, chstrCurrentDir);
    }

    CInstancePtr pEndPoint;
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceKeysByPath(chstrCurrentDir, &pEndPoint, pMethodContext)))
    {
        CInstancePtr pInstance( CreateNewInstance(pMethodContext), false);

        pInstance->SetCHString(IDS_PartComponent, chstrParentDirPATH);

        // Need the name of the directory above this one
        CHString chstrAboveParentDirName;

        chstrAboveParentDirName = chstrParentDirPATH.Left(chstrParentDirPATH.GetLength() - 1);
        LONG lPos = chstrParentDirPATH.ReverseFind(_T('\\'));
        chstrAboveParentDirName = chstrParentDirPATH.Left(lPos-1);

        lPos = chstrAboveParentDirName.Find(L"=");
        CHString chstrTemp = chstrAboveParentDirName.Mid(lPos+1);
        if(chstrTemp[chstrTemp.GetLength() - 1] == L':')
        {
            // our dir hangs off the root. We've stripped the only \\ from it, so need to put it back:
            chstrAboveParentDirName += _T("\\\\");
        }

        CHString chstrAboveParentDirPATH;
        chstrAboveParentDirPATH.Format(L"%s\"", (LPCWSTR)chstrAboveParentDirName);
        pInstance->SetCHString(IDS_GroupComponent, chstrAboveParentDirPATH);

        hr = pInstance->Commit();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32sid.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//	Win32Sid.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "sid.h"
#include "Win32Sid.h"

/*
    [Dynamic,
    description("Represents an arbitrary SID -- CANNOT BE ENUMERATED")]
class Win32_SID : CIM_Setting
{
        [Description (
        ""
        ) , Read, Key]
    string SID;

        [Description (
        ""
        ) , Read]
    uint8 BinaryRepresentation[];

        [Description (
        ""
        ) , Read]
    string AccountName;

        [Description (
        ""
        ) , Read]
     string ReferencedDomainName;
};
*/
Win32SID MySid( WIN32_SID_NAME, IDS_CimWin32Namespace );

Win32SID::Win32SID ( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/ )
: Provider (setName, pszNameSpace)
{
}

Win32SID::~Win32SID ()
{
}

HRESULT Win32SID::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
	return(hr);

}

HRESULT Win32SID::GetObject ( CInstance* pInstance, long lFlags)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	CHString chsSID;

	if (pInstance)
	{
		pInstance->GetCHString(IDS_SID, chsSID);
		// NOTE: a blank sid means the NT None group
		if (!chsSID.IsEmpty())
		{
			hr = FillInstance(pInstance, chsSID);
		}	// end if
		else
		{
			hr = WBEM_S_NO_ERROR;
		}
	}
	return(hr);
}

HRESULT Win32SID::FillInstance(CInstance* pInstance, CHString& chsSID)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	PSID pSid = NULL;
    try
    {
	    pSid = StrToSID(chsSID);
	    CSid sid(pSid);
	    if (sid.IsValid())
	    {
		    // get account name
		    CHString chsAccount = sid.GetAccountName();
		    pInstance->SetCHString(IDS_AccountName, chsAccount);
            pInstance->SetCHString(IDS_SID, chsSID);

		    // get domain name
		    CHString chsDomain = sid.GetDomainName();
		    pInstance->SetCHString(IDS_ReferencedDomainName, chsDomain);

		    // set the UINT8 array for the pSid
		    DWORD dwSidLength = sid.GetLength();
    //			BYTE bByte;
            pInstance->SetDWORD(IDS_SidLength, dwSidLength);
		    SAFEARRAY* sa;
		    SAFEARRAYBOUND rgsabound[1];
		    VARIANT vValue;
		    void* pVoid;

            VariantInit(&vValue);

		    rgsabound[0].cElements = dwSidLength;
    //		char Buf[100];

		    rgsabound[0].lLbound = 0;
		    sa = SafeArrayCreate(VT_UI1, 1, rgsabound);
            if ( sa == NULL )
		    {
			    if (pSid != NULL)
                {
                    FreeSid(pSid);
                }
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		    }

		         // Get a pointer to read the data into
  		    SafeArrayAccessData(sa, &pVoid);
  		    memcpy(pVoid, pSid, rgsabound[0].cElements);
  		    SafeArrayUnaccessData(sa);

		    // Put the safearray into a variant, and send it off
		    V_VT(&vValue) = VT_UI1 | VT_ARRAY; V_ARRAY(&vValue) = sa;
		    pInstance->SetVariant(_T("BinaryRepresentation"), vValue);

		    VariantClear(&vValue);
            hr = WBEM_S_NO_ERROR;

	    }	// end if

    }
    catch(...)
    {
        if(pSid != NULL)
        {
            FreeSid(pSid);
            pSid = NULL;
        }
        throw;
    }

    if(pSid != NULL)
    {
        FreeSid(pSid);
        pSid = NULL;
    }

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32subdirectory.h ===
//=================================================================

//

// Win32SubDirectory 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/09/98    a-kevhu         Created
//
// Comment: Relationship between a Win32_Directory and its sub-directories
//
//=================================================================

// Property set identification
//============================

#ifndef _WIN32SUBDIRECTORY_H_
#define _WIN32SUBDIRECTORY_H_

#define  PROPSET_NAME_WIN32SUBDIRECTORY L"Win32_SubDirectory"


#include "implement_logicalfile.h"


class CW32SubDir;

class CW32SubDir : public CImplement_LogicalFile 
{
    public:
        // Constructor/destructor
        //=======================
        CW32SubDir(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32SubDir() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        //virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);
        
        // a parent implements this, but this class doesn't support it...
        virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L) { return WBEM_E_PROVIDER_NOT_CAPABLE; }

    protected:
       
       // Overridable function inherrited from CImplement_LogicalFile
#ifdef WIN9XONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                               const char* strFullPathName);

        virtual void LoadPropertyValues95(CInstance* pInstance,
                                          LPCTSTR pszDrive, 
                                          LPCTSTR pszPath, 
                                          LPCTSTR pszFSName, 
                                          LPWIN32_FIND_DATA pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual void LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

    private:

        HRESULT AssociateSubDirectories(MethodContext *pMethodContext, const CHString &chstrCurrentDir, const CHString& chstrSubDirPath);
        HRESULT AssociateParentDirectory(MethodContext *pMethodContext, const CHString &chstrCurrentDir);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32systemdriverpnpentity.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  win32SystemDriverPNPEntity.cpp
//
//  Purpose: Relationship between Win32_SystemDriver and Win32_PNPEntity
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>
#include <vector>
#include "PNPEntity.h"
#include "bservice.h"

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"

#include "systemdriver.h"
#include "LPVParams.h"
#include <FRQueryEx.h>
#include <assertbreak.h>

#include "WIN32SystemDriverPNPEntity.h"

#define BIT_ALL_PROPS  0xffffffff
#define BIT_Antecedent 0x00000001
#define BIT_Dependent  0x00000002

// Property set declaration
//=========================
CW32SysDrvPnp MyCW32SysDrvPnp(PROPSET_NAME_WIN32SYSTEMDRIVER_PNPENTITY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32SysDrvPnp::CW32SysDrvPnp
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32SysDrvPnp::CW32SysDrvPnp(LPCWSTR setName, LPCWSTR pszNamespace)
: CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SysDrvPnp::~CW32SysDrvPnp
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32SysDrvPnp::~CW32SysDrvPnp()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SysDrvPnp::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SysDrvPnp::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if(pInstance != NULL)
    {
        // Get the key properties
        CHString chstrDependent, chstrAntecedent;
        pInstance->GetCHString(IDS_Dependent, chstrDependent);
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);

        // Obtain the Dependent's device id:
        CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
        chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
        CHString chstrDependentDevIDAdj;
        RemoveDoubleBackslashes(chstrDependentDevID, chstrDependentDevIDAdj);

        // Obtain the Antecedent's device id:
        CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
        chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
        CHString chstrAntecedentDevIDAdj;
        RemoveDoubleBackslashes(chstrAntecedentDevID, chstrAntecedentDevIDAdj);

        CConfigManager cfgmgr;
        CConfigMgrDevicePtr pPNPDevice(NULL);

        // Now see if the Antecedent is visible to config manager...
        if(cfgmgr.LocateDevice(chstrAntecedentDevIDAdj, &pPNPDevice))
        {
            // It is visible to config manager.  Is it a PNPDevice?
            if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
            {

                CHString sServiceName;
                if (pPNPDevice->GetService(sServiceName))
                {
                    // It does. Is it's service name the same as that which we were given?
                    if(chstrDependentDevIDAdj.CompareNoCase(sServiceName)==0)
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32SysDrvPnp::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CW32SysDrvPnp::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwReqProps;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwReqProps);

    std::vector<_bstr_t> vecAntecedents;
    pQuery.GetValuesForProp(IDS_Antecedent, vecAntecedents);
    DWORD dwAntecedents = vecAntecedents.size();

    std::vector<_bstr_t> vecDependents;
    pQuery.GetValuesForProp(IDS_Dependent, vecDependents);
    DWORD dwDependents = vecDependents.size();

    // We don't have an efficient way to walk services, but we do have a way to walk
    // devices.
    if(dwAntecedents > 0)
    {
        for (DWORD x=0; x < dwAntecedents; x++)
        {
            // Obtain the Antecedent's device id:
            CHString chstrAntecedent((LPCTSTR)vecAntecedents[x]);
            CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
            chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
            CHString chstrAntecedentDevIDAdj;
            RemoveDoubleBackslashes(chstrAntecedentDevID, chstrAntecedentDevIDAdj);

            CConfigManager cfgmgr;
            CConfigMgrDevicePtr pPNPDevice(NULL);

            // Now see if the Antecedent is visible to config manager...
            if(cfgmgr.LocateDevice(chstrAntecedentDevIDAdj, &pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // Let's make an instance
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                    if(NULL != pInstance)
                    {
                        hr = LoadPropertyValues(&CLPVParams(pInstance, pPNPDevice, dwReqProps));
                    }
                }
            }
        }
    }
    else
    {
        CWin32PNPEntity::Enumerate(pMethodContext, lFlags, dwReqProps);
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SysDrvPnp::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances or ExecQuery function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SysDrvPnp::LoadPropertyValues(void* pv)
{

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance *pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);

    if(pInstance == NULL || pDevice == NULL)
    {
        // This would imply a coding failure and should never happen
        ASSERT_BREAK(FALSE);
        return WBEM_E_FAILED;
    }

    HRESULT hr = WBEM_S_NO_ERROR;
    CHString sPNPId, sSystemDriver;
    CHString chstrControllerPATH;

    // Make sure we can retrieve the values and that they are non-blank
    if ((pDevice->GetDeviceID(sPNPId)) && (pDevice->GetService(sSystemDriver)) &&
        (!sPNPId.IsEmpty()) && (!sSystemDriver.IsEmpty()))
    {

        // Format to suit and commit
        if (dwReqProps & BIT_Antecedent)
        {
            CHString sPNPIdAdj;
            CHString sPNPIdPath;

            EscapeBackslashes(sPNPId, sPNPIdAdj);

            sPNPIdPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_PNPEntity,
                                       IDS_DeviceID,
                                       (LPCWSTR)sPNPIdAdj);
            pInstance->SetCHString(IDS_Antecedent, sPNPIdPath);
        }

        if (dwReqProps & BIT_Dependent)
        {
            CHString sSystemDriverAdj, sSystemDriverPath;

            EscapeBackslashes(sSystemDriver, sSystemDriverAdj);

            sSystemDriverPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_SYSTEM_DRIVER,
                                       IDS_Name,
                                       (LPCWSTR)sSystemDriverAdj);

            pInstance->SetCHString(IDS_Dependent, sSystemDriverPath);
        }

        hr = pInstance->Commit();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32sessionprocess.cpp ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
******************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
//#include <ntlsa.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <frqueryex.h>

#include <Session.h>

#include "Win32SessionProcess.h"

CWin32SessionProcess MyWin32_SessionProcess(
    PROVIDER_NAME_WIN32SESSIONPROCESS, 
    IDS_CimWin32Namespace);


/*****************************************************************************
 *
 *  FUNCTION    :   CWin32SessionProcess::CWin32SessionProcess
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CWin32SessionProcess::CWin32SessionProcess(
    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace)
  :
    Provider(lpwszName, lpwszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CWin32SessionProcess::~CWin32SessionProcess
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CWin32SessionProcess::~CWin32SessionProcess ()
{
}



/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with 
*                   WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the 
*                   following flags are handled by (and filtered out by) 
*                   WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::EnumerateInstances(
    MethodContext* pMethodContext, 
    long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = Enumerate(
        pMethodContext, 
        PROP_ALL_REQUIRED);

    return hr;
}
#endif
/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    A valid HRESULT 
*
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::GetObject(
    CInstance* pInstance, 
    long lFlags,
    CFrameworkQuery& Query)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pAntSesInst, pDepProcInst;
    MethodContext *pMethodContext = pInstance->GetMethodContext();

    // The Antecedent property contains an object path that points to a logon
    // session.  The Dependent property contains an object path that points 
    // to a process.  Let's do a GetObject on these two and make sure they 
    // point to valid sessions and processes.

    hr = ValidateEndPoints(
        pMethodContext, 
        pInstance, 
        pAntSesInst, 
        pDepProcInst);

    if (SUCCEEDED(hr))
    {
        // Ok, the session and the process both exist.  Now, does this
        // process belong to this session?
        if (AreAssociated(
            pAntSesInst, 
            pDepProcInst))
        {
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::Enumerate
*
*  DESCRIPTION :    Internal helper function used to enumerate instances of
*                   this class.  All instances are enumerated, but only the
*                   properties specified are obtained.
*
*  INPUTS      :    A pointer to a the MethodContext for the call.
*                   A DWORD specifying which properties are requested.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::Enumerate(
    MethodContext *pMethodContext, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We will use the helper class CUserSessionCollection to get
    // a mapping of users and their associated sessions.
    CUserSessionCollection usc;

    USER_SESSION_ITERATOR usiter;
    SmartDelete<CSession> pses;

    pses = usc.GetFirstSession(usiter);
    while(pses != NULL)
    {
        hr = EnumerateProcessesForSession(
            *pses,
            pMethodContext, 
            dwPropsRequired);

        pses = usc.GetNextSession(usiter);
    }

    return hr;
}
#endif

/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::EnumerateProcessesForSession
*
*  DESCRIPTION :    Called by Enumerate to enumerate the processes of a given
*                   session. 
*
*  INPUTS      :    The session to enumerate processes for, the methodcontext
*                   to communicate to winmgmt with, and a property bitmask of
*                   which properties to populate
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::EnumerateProcessesForSession(
    CSession& session, 
    MethodContext *pMethodContext, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    PROCESS_ITERATOR prociter;
    SmartDelete<CProcess> pproc;

    pproc = session.GetFirstProcess(
        prociter);

    while(pproc != NULL)
    {
        // Create a new instance based on the passed-in 
        // MethodContext.  Note that CreateNewInstance may 
        // throw, but will never return NULL.
        CInstancePtr pInstance(
            CreateNewInstance(
                pMethodContext), 
                false);

        hr = LoadPropertyValues(
            pInstance, 
            session, 
            *pproc, 
            dwPropsRequired);

        if(SUCCEEDED(hr))
        {
            hr = pInstance->Commit();   
        }

        pproc = session.GetNextProcess(
            prociter);
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::LoadPropertyValues
*
*  DESCRIPTION :    Internal helper function used to fill in all unfilled
*                   property values.  At a minimum, it must fill in the key
*                   properties.
*
*  INPUTS      :    A pointer to a CInstance containing the instance we are
*                   attempting to locate and fill values for.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::LoadPropertyValues(
    CInstance* pInstance, 
    CSession& session, 
    CProcess& proc, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chstrValue;

    WCHAR wstrBuff[MAXI64TOA];

    _i64tow(
        session.GetLUIDint64(), 
        wstrBuff, 
        10);

    if (dwPropsRequired & PROP_ANTECEDENT)
    {
        chstrValue.Format(
            L"\\\\.\\%s:Win32_LogonSession.LogonId=\"%s\"", 
            IDS_CimWin32Namespace, 
            (LPCWSTR)wstrBuff);

        pInstance->SetCHString(
            IDS_Antecedent, 
            chstrValue);
    }

    if (dwPropsRequired & PROP_DEPENDENT)
    {
        chstrValue.Format(
            L"\\\\.\\%s:Win32_Process.Handle=\"%d\"", 
            IDS_CimWin32Namespace, 
            proc.GetPID());

        pInstance->SetCHString(
            IDS_Dependent, 
            chstrValue);
    }

    return hr;
}
#endif



/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::ValidateEndPoints
*
*  DESCRIPTION :    Internal helper function used to determine whether the
*                   two object paths in the association currently point
*                   to valid users/sessions.
*
*
*  INPUTS      :    MethodContext to call back into winmgmt with, and
*                   the CInstance that is to be checked.
*
*  OUTPUTS     :    Pointers to CInstances that contain the actual objects
*                   from the endpoint classes.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::ValidateEndPoints(
    MethodContext *pMethodContext, 
    const CInstance *pInstance, 
    CInstancePtr &pAntSesInst, 
    CInstancePtr &pDepProcInst)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrSessionPath;

    // See if the session specified exists
    pInstance->GetCHString(
        IDS_Antecedent, 
        chstrSessionPath);

    hr = CWbemProviderGlue::GetInstanceKeysByPath(
        chstrSessionPath, 
        &pAntSesInst, 
        pMethodContext);

    if (SUCCEEDED(hr))
    {
        // The users exists.  Now, see if the session exists.
        CHString chstrProcessPath;
        pInstance->GetCHString(
            IDS_Dependent, 
            chstrProcessPath);

        hr = CWbemProviderGlue::GetInstanceKeysByPath(
            chstrProcessPath, 
            &pDepProcInst, 
            pMethodContext);
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::AreAssociated
*
*  DESCRIPTION :    Internal helper function used to determine whether a
*                   specific session is associated to the specified process.
*
*  INPUTS      :    
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
bool CWin32SessionProcess::AreAssociated(
    const CInstance *pSesInst, 
    const CInstance *pProcInst)
{
    bool fRet = false;

    CHString chstrSesLogonId;
    CHString chstrProcessHandle;

    pSesInst->GetCHString(IDS_LogonId, chstrSesLogonId);
    pProcInst->GetCHString(IDS_Handle, chstrProcessHandle);
    
    CSession sesTmp;
    if(sesTmp.IsSessionIDValid(chstrSesLogonId))
    {
        __int64 i64LogonId = _wtoi64(chstrSesLogonId);
    
        WCHAR* pwchStop = NULL;
        DWORD dwHandle = wcstoul(
            chstrProcessHandle, 
            &pwchStop,
            10);


        // We will use the helper class CUserSessionCollection to get
        // a mapping of users and their associated sessions, and from
        // those sessions, their processes.
        CUserSessionCollection usc; 
        SmartDelete<CSession> pses;

        pses = usc.FindSession(
            i64LogonId);

        if(pses)
        {
            SmartDelete<CProcess> pproc;
            PROCESS_ITERATOR prociter;

            pproc = pses->GetFirstProcess(
                prociter);

            while(pproc && !fRet)
            {
                // see if we find a session id match for this user...
                if(dwHandle == pproc->GetPID())
                {
                    fRet = true;
                }
        
                pproc = pses->GetNextProcess(
                    prociter);
            }
        }
    }

    return fRet;
}
#endif



/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::GetRequestedProps
*
*  DESCRIPTION :    Internal helper function used to determine which
*                   properties are required to satisfy the GetObject or
*                   ExecQuery request.
*
*  INPUTS      :    A pointer to a CFrameworkQuery from which we can determine
*                   the required properties.
*
*  RETURNS     :    A DWORD bitmask that maps those properties that are
*                   required. 
*
*****************************************************************************/
#ifdef NTONLY
DWORD CWin32SessionProcess::GetRequestedProps(CFrameworkQuery& Query)
{
    DWORD dwReqProps = 0;

    if (Query.IsPropertyRequired(IDS_Antecedent)) dwReqProps |= PROP_ANTECEDENT;
    if (Query.IsPropertyRequired(IDS_Dependent)) dwReqProps |= PROP_DEPENDENT;

    return dwReqProps;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32systemdriverpnpentity.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  win32SystemDriverPNPEntity.h
//
//  Purpose: Relationship between Win32_SystemDriver and Win32_PNPEntity
//
//***************************************************************************

#ifndef _WIN32USBCONTROLLERDEVICE_H_
#define _WIN32USBCONTROLLERDEVICE_H_


// Property set identification
//============================
#define PROPSET_NAME_WIN32SYSTEMDRIVER_PNPENTITY  L"Win32_SystemDriverPNPEntity"


class CW32SysDrvPnp;

class CW32SysDrvPnp : public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================
        CW32SysDrvPnp(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32SysDrvPnp() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long a_Flags = 0L);
//        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L); 

    protected:

        // Functions inherrited from CWin32USB
        //====================================
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        CHPtrArray m_ptrProperties;
};

// This derived class commits here, not in the base.
inline bool CW32SysDrvPnp::ShouldBaseCommit(void* pvData) { return false; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32systemusers.cpp ===
//=================================================================

//

// Win32SystemUsers.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    3/6/99    davwoh         Extracted from grouppart.cpp
//
// Comment:
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "wbemnetapi32.h"
#include <lmwksta.h>
#include "sid.h"
#include "Win32SystemUsers.h"

CWin32SystemUsers	MyLocalUser( PROPSET_NAME_SYSTEMUSER, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemUsers::CWin32SystemUsers
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : LPCWSTR strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SystemUsers::CWin32SystemUsers( LPCWSTR strName, LPCWSTR pszNamespace )
:	Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemUsers::~CWin32SystemUsers
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SystemUsers::~CWin32SystemUsers()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SystemUsers::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32SystemUsers::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    HRESULT         hr = WBEM_E_FAILED;
    CInstancePtr    pLocInstance;
    CHString        systemPath,
                    userPath,
                    sOurDomain,
                    sReqDomain,
                    sReqName;
    CNetAPI32       NetAPI;

    // First, find out what domain we are in
    if (NetAPI.Init() == ERROR_SUCCESS)
    {
#ifdef WIN9XONLY
        {
            //sOurDomain = GetLocalComputerName();
            sOurDomain = L"";   // on 9x, we now don't report a domain for users of the local system.
            hr = WBEM_S_NO_ERROR;
        }
#endif
#ifdef NTONLY
    WKSTA_INFO_100  *pstInfo;
    NET_API_STATUS  dwStatus;

        {
            // Get the computer name and domain name
            if ((dwStatus = NetAPI.NetWkstaGetInfo(NULL, 100,
                (LPBYTE *) &pstInfo)) == NERR_Success)
            {
                try
                {
                    // If we are a domain controller, we want all the users in our
                    // domain, else all the users on our machine
                    if (NetAPI.IsDomainController(NULL))
                    {
                        sOurDomain = (WCHAR *)pstInfo->wki100_langroup;
                    }
                    else
                    {
                        sOurDomain = (WCHAR *)pstInfo->wki100_computername;
                    }
                }
                catch ( ... )
                {
                    NetAPI.NetApiBufferFree(pstInfo);
                    throw ;
                }

                NetAPI.NetApiBufferFree(pstInfo);
                hr = WBEM_S_NO_ERROR;
            }
            else
                hr = WinErrorToWBEMhResult(dwStatus);
        }
#endif

        if (SUCCEEDED(hr))
        {
            // Now, let's check the system part
            pInstance->GetCHString(IDS_GroupComponent, systemPath);
            hr = CWbemProviderGlue::GetInstanceByPath(systemPath,
                    &pLocInstance, pInstance->GetMethodContext());
        }
    }

    // Ok, system is ok (and we got the domain), what about the user?
    if (SUCCEEDED(hr))
    {
        // Let's just try getting the user from Win32_UserAccount
        pInstance->GetCHString(IDS_PartComponent, userPath);
        hr = CWbemProviderGlue::GetInstanceByPath(userPath, &pLocInstance, pInstance->GetMethodContext());

        if (SUCCEEDED(hr))
        {
            // Ok, we found it, but is it one of 'our' users?
            pLocInstance->GetCHString(IDS_Domain, sReqDomain);
            if (sReqDomain.CompareNoCase(sOurDomain) != 0)
            {
                // Nope, not ours.  Try the registry.
                hr = WBEM_E_NOT_FOUND;
            }
        }

        // Well, if that didn't work, let's check the registry
        if (hr == WBEM_E_NOT_FOUND)
        {
            ParsedObjectPath    *pParsedPath = 0;
            CObjectPathParser	objpathParser;

            hr = WBEM_E_INVALID_PARAMETER;

            // Parse the path to get the domain/user
            int nStatus = objpathParser.Parse(userPath,  &pParsedPath);

            // Did we parse it and does it look reasonable?
            if (nStatus == 0 && pParsedPath->m_dwNumKeys == 2)
            {
                // Get the value out (order is not guaranteed)
                for (int i = 0; i < 2; i++)
                {
                    if (_wcsicmp(pParsedPath->m_paKeys[i]->m_pName,
                        L"Name") == 0)
                    {
                        if (pParsedPath->m_paKeys[i]->m_vValue.vt == VT_BSTR)
                            sReqName = pParsedPath->m_paKeys[i]->m_vValue.bstrVal;
                    }
                    else if (_wcsicmp(pParsedPath->m_paKeys[i]->m_pName,
                        L"Domain") == 0)
                    {
                        if (pParsedPath->m_paKeys[i]->m_vValue.vt == VT_BSTR)
                            sReqDomain = pParsedPath->m_paKeys[i]->m_vValue.bstrVal;
                    }
                }
            }

            if(nStatus == 0)
            {
                objpathParser.Free(pParsedPath);
            }


            // If we got the names
            if (!sReqName.IsEmpty() && !sReqDomain.IsEmpty())
            {
                hr = WBEM_E_NOT_FOUND;

                // Only take this one if it is NOT from our machine's domain
                if (sOurDomain.CompareNoCase(sReqDomain) != 0)
                {
                    // Turn the domain/name into a sid
                    CSid sid(sReqDomain, sReqName, NULL);

                    if (sid.IsOK() && sid.IsAccountTypeValid())
                    {
                        CHString    sSid;
                        CRegistry   RegInfo;
                        HRESULT     hres;

                        // Turn the sid into a string
                        sid.StringFromSid(sid.GetPSid(), sSid);

                        // Use the string to open a registry key
                        sSid = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\"
                            + sSid;
                        if ((hres = RegInfo.Open(HKEY_LOCAL_MACHINE, sSid,
                            KEY_READ)) == ERROR_SUCCESS)
                        {
                            // If the key is there, we win!
                            hr = WBEM_S_NO_ERROR;
                        }
                        else if (hres == ERROR_ACCESS_DENIED)
                             hr = WBEM_E_ACCESS_DENIED;
                    }

                }
            }
        }
    }

	// an invalid namespace in the reference path constitutes a "NOT FOUND" for us
    if (hr == WBEM_E_INVALID_NAMESPACE)
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SystemUsers::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SystemUsers::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
   CNetAPI32 NetAPI;
   CHString sName, sDomain, sTemp, sOurDomain, strComputerName, sQuery1;
   HRESULT hr = WBEM_E_FAILED;
   CRegistry RegInfo1, RegInfo2;
   CInstancePtr pInstance;

   strComputerName = GetLocalComputerName();

   // Fire up the net api's
   if (NetAPI.Init() == ERROR_SUCCESS) {

#ifdef WIN9XONLY
      {
         //sOurDomain = GetLocalComputerName();
         sOurDomain = L"";
		 hr = WBEM_S_NO_ERROR;
      }
#endif
#ifdef NTONLY
   WKSTA_INFO_100 *pstInfo;
   NET_API_STATUS dwStatus;

      {
         // Get the computer name and domain name
         if ((dwStatus = NetAPI.NetWkstaGetInfo(NULL, 100, (LPBYTE *)&pstInfo)) == NERR_Success)
         {
             try
             {
                 // If we are a domain controller, we want all the users in our domain, else all the users on our machine
                 if (NetAPI.IsDomainController(NULL))
                 {
                    sOurDomain = (WCHAR *)pstInfo->wki100_langroup;
                 }
                 else
                 {
                    sOurDomain = (WCHAR *)pstInfo->wki100_computername;
                 }
             }
             catch ( ... )
             {
                 NetAPI.NetApiBufferFree(pstInfo);
                 throw ;
             }

             NetAPI.NetApiBufferFree(pstInfo);
             hr = WBEM_S_NO_ERROR;
         }
         else
         {
             hr = WinErrorToWBEMhResult(GetLastError());
         }

      }
#endif

      CHString chstrNTAuth;
      GetNTAuthorityName(chstrNTAuth);

      if (SUCCEEDED(hr))
      {
          sTemp.Format(L"select name from win32_useraccount where domain = \"%s\"", sOurDomain);
          sQuery1 = L"SELECT __RELPATH FROM Win32_ComputerSystem";

          TRefPointerCollection<CInstance> Users;

          // get the path of the system
          CHString systemPath;
          TRefPointerCollection<CInstance> system;
          REFPTRCOLLECTION_POSITION posSystem;
//          if (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances("Win32_ComputerSystem", &system, NULL, pMethodContext)))
          if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &system, pMethodContext, IDS_CimWin32Namespace)))
          {
             // get the path of the system
             system.BeginEnum(posSystem);
             CInstancePtr pSystem(system.GetNext(posSystem), false);
             system.EndEnum();

             if (pSystem != NULL)
             {

                 if (GetLocalInstancePath(pSystem, systemPath)) {

                    // Now get all the users.  We use the query to allow win32_useraccount to optimize our request
                    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sTemp, &Users, pMethodContext, IDS_CimWin32Namespace))) {
                       REFPTRCOLLECTION_POSITION pos;
                       CInstancePtr pUser;

                       if (Users.BeginEnum(pos)) {
                          for (pUser.Attach(Users.GetNext( pos ));
                              (SUCCEEDED(hr)) && (pUser != NULL);
                              pUser.Attach(Users.GetNext( pos )))
                           {

                             // Match the user with the system and send it back
                             pInstance.Attach(CreateNewInstance(pMethodContext));
                             if (pInstance)
                             {
                                 pUser->GetCHString(IDS_Name, sName);
      //                         pUser->GetCHString(IDS_Domain, sDomain);

                                 // Note that this is an absolute path
                                 if(sOurDomain.CompareNoCase(chstrNTAuth) != 0)
                                 {
                                    sTemp.Format(
                                        L"\\\\%s\\%s:%s.%s=\"%s\",%s=\"%s\"", 
                                        strComputerName, 
                                        IDS_CimWin32Namespace, 
                                        L"Win32_UserAccount", 
                                        IDS_Name, 
                                        sName, 
                                        IDS_Domain, 
                                        sOurDomain);

                                     pInstance->SetCHString(IDS_PartComponent, sTemp);
                                     pInstance->SetCHString(IDS_GroupComponent, systemPath);

                                     hr = pInstance->Commit();
                                 }

                                
                             }
                             else
                             {
                                 hr = WBEM_E_OUT_OF_MEMORY;
                             }

                          }
                       }
                    }

                    // If we are on nt, let's get all the domain users that have logged in too
#ifdef NTONLY
                    if (SUCCEEDED(hr))
                    {
                       CHString strName;
                       CHString sSid;
                       HRESULT res;

                       // This is the list of users
                       if( (res = RegInfo1.Open(HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList", KEY_READ)) == ERROR_SUCCESS )	{

                          // Walk the keys
                          for( res = ERROR_SUCCESS ; (res == ERROR_SUCCESS) && SUCCEEDED(hr); res = RegInfo1.NextSubKey()) {

                             // Get the key name
                             // Open the child key under this key
                             // Get the SID property
                             if (((res = RegInfo1.GetCurrentSubKeyPath( strName )) == ERROR_SUCCESS ) &&
                                ((res = RegInfo2.Open(HKEY_LOCAL_MACHINE, strName, KEY_READ)) == ERROR_SUCCESS) &&
                                ((res = RegInfo2.GetCurrentKeyValue( L"Sid", sSid)) == ERROR_SUCCESS )) {

                                // Convert it to a CSid, since that will get us the UserName and Domain
                                CSid sid( (PSID) (LPCTSTR)sSid );

                                // If the conversion worked
                                if ( sid.IsOK() && sid.IsAccountTypeValid() ) {

                                   // Check the domain.  Don't need to do our domain, we got all those above
                                   sDomain = sid.GetDomainName();
                                   if (sDomain.CompareNoCase(sOurDomain) != 0) {

                                      // Ok, this looks like a goodie.  Pack it up and send it back
                                      sName = sid.GetAccountName();
                                      pInstance.Attach(CreateNewInstance( pMethodContext ));
                                      if (pInstance)
                                      {
                                          if(sDomain.CompareNoCase(chstrNTAuth) != 0)
                                          {
                                              sTemp.Format(
                                                L"\\\\%s\\%s:%s.%s=\"%s\",%s=\"%s\"", 
                                                strComputerName, 
                                                IDS_CimWin32Namespace, 
                                                L"Win32_UserAccount", 
                                                IDS_Name, 
                                                sName, 
                                                IDS_Domain, 
                                                sDomain);

                                              pInstance->SetCHString(IDS_PartComponent, sTemp);
                                              pInstance->SetCHString(IDS_GroupComponent, systemPath);

                                              hr = pInstance->Commit();
                                          }
                                      }
                                      else
                                          hr = WBEM_E_OUT_OF_MEMORY;
                                   }
                                }
                             } else if (res == ERROR_ACCESS_DENIED) {
                                 hr = WBEM_E_ACCESS_DENIED;
                             }
                          }
                       } else if (res == ERROR_ACCESS_DENIED) {
                                 hr = WBEM_E_ACCESS_DENIED;
                       }
                    }
#endif
                 }
             }
          }
      }
   }

   return hr;
}



// Need the string "NT AUTHORITY".  However, on non-english
// builds, this is something else.  Hence, get if from the
// sid.
void CWin32SystemUsers::GetNTAuthorityName(
    CHString& chstrNTAuth)
{
    PSID pSidNTAuthority = NULL;
	SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    CHString cstrAuthorityDomain;
	if (AllocateAndInitializeSid (&sia ,1,SECURITY_LOCAL_SYSTEM_RID,0,0,0,0,0,0,0,&pSidNTAuthority))
	{
		try
        {
            CSid sidNTAuth(pSidNTAuthority);
            chstrNTAuth = sidNTAuth.GetDomainName();
        }
        catch(...)
        {
            FreeSid(pSidNTAuthority);
            throw;
        }
		FreeSid(pSidNTAuthority);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32systemusers.h ===
//=================================================================

//

// Win32SystemUsers.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    3/6/99    davwoh         Extracted from grouppart.cpp
//
// Comment: 
//=================================================================

#define	PROPSET_NAME_SYSTEMUSER L"Win32_SystemUsers" 

class CWin32SystemUsers : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32SystemUsers( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32SystemUsers() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

    private:

        void GetNTAuthorityName(
            CHString& chstrNTAuth);


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_1394controllerdevice.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN321394ControllerDevice.cpp
//
//  Purpose: Relationship between Win32_1394Controller and Win32_PNPEntity
//
//***************************************************************************

#include "precomp.h"

#include "WIN32_1394ControllerDevice.h"

// Property set declaration
//=========================
CW32_1394CntrlDev MyCW32_1394CntrlDev(PROPSET_NAME_WIN32_1394CONTROLLERDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::CW32_1394CntrlDev
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32_1394CntrlDev::CW32_1394CntrlDev(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::~CW32_1394CntrlDev
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32_1394CntrlDev::~CW32_1394CntrlDev()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32_1394CntrlDev::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString chstrAntecedent;
    CHString chstrDependent;
    if(pInstance != NULL)
    {
        CInstancePtr pinst1394Controller;
        CInstancePtr pinst1394Device;
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
        pInstance->GetCHString(IDS_Dependent, chstrDependent);
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrAntecedent, &pinst1394Controller, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDependent, &pinst1394Device, pInstance->GetMethodContext())))
            {
                // So there are instances in CIMOM of both.  Are they related?
                CHString chstr1394ControllerPNPID;
                CHString chstr1394DevicePNPID;
                pinst1394Controller->GetCHString(IDS_PNPDeviceID, chstr1394ControllerPNPID);
                pinst1394Device->GetCHString(IDS_PNPDeviceID, chstr1394DevicePNPID);
                if(chstr1394ControllerPNPID.GetLength() > 0 && chstr1394DevicePNPID.GetLength() > 0)
                {
                    VECPCHSTR vec1394Devices;
                    try
                    {
                        hr = Generate1394DeviceList(chstr1394ControllerPNPID, vec1394Devices);
                        if(SUCCEEDED(hr) && vec1394Devices.size() > 0L)
                        {
                            if(FindInStringVector(chstr1394DevicePNPID, vec1394Devices) > -1L)
                            {
                                // It would appear they are.
                                hr = WBEM_S_NO_ERROR;
                            }
                        }
                    }
                    catch ( ... )
                    {
                        CleanPCHSTRVec(vec1394Devices);
                        throw ;
                    }

                    CleanPCHSTRVec(vec1394Devices);
                }
            }
        }
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32_1394CntrlDev::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrControllersQuery(_T("SELECT __PATH, PNPDeviceID FROM Win32_1394Controller"));
    TRefPointerCollection<CInstance> ControllersList;
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrControllersQuery,
                                                        &ControllersList,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))
    {
        REFPTRCOLLECTION_POSITION pos;

        if(ControllersList.BeginEnum(pos))
        {
            CHString chstrControllerPNPID;
            CHString chstrControllerPATH;
            LONG lNum1394Devices = 0L;
            CInstancePtr pinstController;

            for (pinstController.Attach(ControllersList.GetNext(pos));
                 SUCCEEDED(hr) && (pinstController != NULL);
                 pinstController.Attach(ControllersList.GetNext(pos)))
            {
                pinstController->GetCHString(IDS_PNPDeviceID, chstrControllerPNPID);
                pinstController->GetCHString(IDS___Path, chstrControllerPATH);
                if(chstrControllerPNPID.GetLength() > 0 && chstrControllerPATH.GetLength() > 0)
                {
                    VECPCHSTR vec1394Devices;
                    try
                    {
                        hr = Generate1394DeviceList(chstrControllerPNPID, vec1394Devices);
                        if(SUCCEEDED(hr) && vec1394Devices.size() > 0L)
                        {
                            hr = Process1394DeviceList(pMethodContext, chstrControllerPATH, vec1394Devices);
                        }
                    }
                    catch ( ... )
                    {
                        CleanPCHSTRVec(vec1394Devices);
                        throw ;
                    }
                    CleanPCHSTRVec(vec1394Devices);
                }
                else
                {
                    hr = WBEM_E_FAILED; // PNPDeviceID and __RELPATH for 1394controller should never be empty
                }
            }
        }
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::Generate1394DeviceList
 *
 *  DESCRIPTION : This helper creates a list of devices hanging off the passed
 *                in device.
 *
 *  INPUTS      : vec1394Devices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPNPID, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32_1394CntrlDev::Generate1394DeviceList(const CHString& chstrControllerPNPID,
                                               VECPCHSTR& vec)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CConfigManager cfgManager;
    CConfigMgrDevicePtr pController;
    if(cfgManager.LocateDevice(chstrControllerPNPID, &pController))
    {
        if(pController != NULL)
        {
            hr = RecursiveFillDeviceBranch(pController, vec);
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::RecursiveFillDeviceBranch
 *
 *  DESCRIPTION : This helper obtains all down branch devices starting with,
 *                but not including, pDevice.
 *
 *  INPUTS      : pDevice, a device to populate the children of;
 *                vec1394Devices, a list of devices to try to associate
 *                   to the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32_1394CntrlDev::RecursiveFillDeviceBranch(CConfigMgrDevice* pDevice,
                                                   VECPCHSTR& vec1394Devices)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(pDevice != NULL)
    {
        CConfigMgrDevice* pDeviceChild = NULL;
        if(pDevice->GetChild(&pDeviceChild))
        {
            // Need this child's PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                if(chstrChildPNPDeviceID.GetLength() > 0)
                {
                    // Record this child...
                    CHString* pchstrTemp = NULL;
                    pchstrTemp = (CHString*) new CHString(chstrChildPNPDeviceID);
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            vec1394Devices.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            pchstrTemp = NULL;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }

                    // Now do its children...
                    hr = RecursiveFillDeviceBranch(pDeviceChild, vec1394Devices);
                }
            }
            // Now call its brothers and sisters until none left (GetSibling
            // call will return FALSE):
            if(SUCCEEDED(hr))
            {
                CConfigMgrDevicePtr pDeviceSibling;
                if(pDeviceChild->GetSibling(&pDeviceSibling))
                {
                    CConfigMgrDevicePtr pDeviceSiblingNext;
                    BOOL fContinue = TRUE;
                    CHString chstrSiblingPNPDeviceID;
                    while(SUCCEEDED(hr) && fContinue)
                    {
                        // Record the sibling now...
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            if(chstrSiblingPNPDeviceID.GetLength() > 0)
                            {
                                CHString* pchstrTemp = NULL;
                                pchstrTemp = (CHString*) new CHString(chstrSiblingPNPDeviceID);
                                if(pchstrTemp != NULL)
                                {
                                    try
                                    {
                                        vec1394Devices.push_back(pchstrTemp);
                                    }
                                    catch ( ... )
                                    {
                                        delete pchstrTemp;
                                        pchstrTemp = NULL;
                                        throw ;
                                    }
                                }
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                        }
                        // Then do the sibling's children...
                        hr = RecursiveFillDeviceBranch(pDeviceSibling, vec1394Devices);

                        // Then get the next sibling...
                        pDeviceSiblingNext = NULL;
                        fContinue = pDeviceSibling->GetSibling(&pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::Process1394DeviceList
 *
 *  DESCRIPTION : This helper runs through the list, creating an association
 *                instance for each element in the list (vec1394Devices) with
 *                the controller (chstrControllerPNPID).
 *
 *  INPUTS      : pMethodContext;
 *                vec1394Devices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32_1394CntrlDev::Process1394DeviceList(MethodContext* pMethodContext,
                                              const CHString& chstrControllerPATH,
                                              VECPCHSTR& vec1394Devices)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrDevPATHAdj, chstrDevicePATH;

    for(LONG m = 0L; m < vec1394Devices.size() && SUCCEEDED(hr); m++)
    {

        EscapeBackslashes(*vec1394Devices[m], chstrDevPATHAdj);
        chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                               (LPCWSTR)GetLocalComputerName(),
                               IDS_CimWin32Namespace,
                               L"Win32_PNPEntity",
                               IDS_DeviceID,
                               (LPCWSTR)chstrDevPATHAdj);

        hr = CreateAssociation(pMethodContext, chstrControllerPATH, chstrDevicePATH);
    }
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::CreateAssociation
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : pMethodContext;
 *                1394Device, a device to associate with the controller
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper actually creates the association instance and
 *                commits it.
 *
 *****************************************************************************/
HRESULT CW32_1394CntrlDev::CreateAssociation(MethodContext* pMethodContext,
                                           const CHString& chstrControllerPATH,
                                           const CHString& chstrDevicePATH)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(pMethodContext != NULL)
    {

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            // Need to find an instance of the file
            pInstance->SetCHString(IDS_Antecedent, chstrControllerPATH);
            pInstance->SetCHString(IDS_Dependent, chstrDevicePATH);
            hr = pInstance->Commit();
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::FindInStringVector
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : chstr1394DevicePNPID, device to look for
 *                vec1394Devices, list of devices to look in
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG, number indicating 0 based offset into vec1394Devices of
 *                the found device, or -1 if not found.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CW32_1394CntrlDev::FindInStringVector(const CHString& chstr1394DevicePNPID,
                                         VECPCHSTR& vec1394Devices)
{
    LONG lPos = -1L;
    bool fFoundIt;
    for(LONG m = 0; m < vec1394Devices.size(); m++)
    {
        if(chstr1394DevicePNPID == *vec1394Devices[m])
        {
            fFoundIt = true;
            break;
        }
    }
    if(fFoundIt) lPos = m;
    return lPos;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::CleanPCHSTRVec
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : vec, a vector of CHString pointers
 *
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper deletes members of a vector that are pointers.
 *
 *****************************************************************************/
void CW32_1394CntrlDev::CleanPCHSTRVec(VECPCHSTR& vec)
{
    for(LONG m = 0L; m < vec.size(); m++)
    {
        delete vec[m];
    }
    vec.clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32usbcontrollerdevice.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32USBControllerDevice.h
//
//  Purpose: Relationship between CIM_USBController and CIM_LogicalDevice
//
//***************************************************************************

#ifndef _WIN32USBCONTROLLERDEVICE_H_
#define _WIN32USBCONTROLLERDEVICE_H_


#define USBCTL_PROP_ALL_PROPS                    0xFFFFFFFF
#define USBCTL_PROP_ALL_PROPS_KEY_ONLY           0x00000003
#define USBCTL_PROP_Antecedent                   0x00000001
#define USBCTL_PROP_Dependent                    0x00000002



// Property set identification
//============================
#define PROPSET_NAME_WIN32USBCONTROLLERDEVICE  L"Win32_USBControllerDevice"


typedef std::vector<CHString*> VECPCHSTR;

class CW32USBCntrlDev;

class CW32USBCntrlDev : public CWin32USB, public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================
        CW32USBCntrlDev(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32USBCntrlDev() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long a_Flags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L); 

    protected:

        // Functions inherrited from CWin32USB
        //====================================
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        CHPtrArray m_ptrProperties;
        void CleanPCHSTRVec(VECPCHSTR& vec);
        HRESULT GenerateUSBDeviceList(const CHString& chstrControllerPNPID, 
                                      VECPCHSTR& vec);
        HRESULT RecursiveFillDeviceBranch(CConfigMgrDevice* pRootDevice, 
                                          VECPCHSTR& vecUSBDevices); 
        HRESULT ProcessUSBDeviceList(MethodContext* pMethodContext, 
                                     const CHString& chstrControllerRELPATH, 
                                     VECPCHSTR& vecUSBDevices,
                                     const DWORD dwReqProps);
        HRESULT CreateAssociation(MethodContext* pMethodContext,
                                  const CHString& chstrControllerPATH, 
                                  const CHString& chstrUSBDevice,
                                  const DWORD dwReqProps);
        LONG FindInStringVector(const CHString& chstrUSBDevicePNPID, 
                                VECPCHSTR& vecUSBDevices);
        bool GetHighestUSBAncestor(CConfigMgrDevice* pUSBDevice, CHString& chstrUSBControllerDeviceID);
};

// This derived class commits here, not in the base.
inline bool CW32USBCntrlDev::ShouldBaseCommit(void* pvData) { return false; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_1394controllerdevice.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN321394ControllerDevice.h
//
//  Purpose: Relationship between CIM_1394Controller and CIM_LogicalDevice
//
//***************************************************************************

#ifndef _WIN32_1394CONTROLLERDEVICE_H_
#define _WIN32_1394CONTROLLERDEVICE_H_


// Property set identification
//============================
#define PROPSET_NAME_WIN32_1394CONTROLLERDEVICE  L"Win32_1394ControllerDevice"

#include <vector>

typedef std::vector<CHString*> VECPCHSTR;

class CW32_1394CntrlDev;

class CW32_1394CntrlDev : public Provider 
{
    public:

        // Constructor/destructor
        //=======================
        CW32_1394CntrlDev(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32_1394CntrlDev() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);

    private:

        void CleanPCHSTRVec(VECPCHSTR& vec);
        HRESULT Generate1394DeviceList(const CHString& chstrControllerPNPID, 
                                      VECPCHSTR& vec);
        HRESULT RecursiveFillDeviceBranch(CConfigMgrDevice* pRootDevice, 
                                          VECPCHSTR& vec1394Devices); 
        HRESULT Process1394DeviceList(MethodContext* pMethodContext, 
                                     const CHString& chstrControllerRELPATH, 
                                     VECPCHSTR& vec1394Devices);
        HRESULT CreateAssociation(MethodContext* pMethodContext,
                                  const CHString& chstrControllerPATH, 
                                  const CHString& chstr1394Device);
        LONG FindInStringVector(const CHString& chstr1394DevicePNPID, 
                                VECPCHSTR& vec1394Devices);


//        HRESULT QueryForSubItemsAndCommit(CHString& chstrProgGrpPath,
//                                          CHString& chstrQuery,
//                                          MethodContext* pMethodContext);
//        HRESULT EnumerateInstancesNT(MethodContext* pMethodContex);
//        HRESULT EnumerateInstances9x(MethodContext* pMethodContext);
//
//        VOID RemoveDoubleBackslashes(CHString& chstrIn);



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomapplicationclasses.h ===
//=============================================================================================================

//

// Win32_ClassicCOMApplicationClasses.h -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#define  CLASSIC_COM_APP_CLASSES L"Win32_ClassicCOMApplicationClasses"

class Win32_ClassicCOMApplicationClasses : public Provider
{
public:
	Win32_ClassicCOMApplicationClasses (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_ClassicCOMApplicationClasses ();

	virtual HRESULT EnumerateInstances (MethodContext*  a_pMethodContext, long a_lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* a_pInstance, long a_lFlags = 0L );

private:	
	HRESULT Win32_ClassicCOMApplicationClasses::CreateInstances 
	( 
		
		CInstance* a_pComObject, 
		PSECURITY_DESCRIPTOR a_pSD, 
		MethodContext*  a_pMethodContext 
	) ;
	
	HRESULT Win32_ClassicCOMApplicationClasses::CheckInstance ( CInstance* a_pComObject, PSECURITY_DESCRIPTOR a_pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32usbcontrollerdevice.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32USBControllerDevice.cpp
//
//  Purpose: Relationship between CIM_USBController and CIM_LogicalDevice
//
//***************************************************************************

#include "precomp.h"
#include <vector>
#include "usb.h"
#include "PNPEntity.h"
#include "LPVParams.h"
#include <FRQueryEx.h>

#include "WIN32USBControllerDevice.h"

// Property set declaration
//=========================
CW32USBCntrlDev MyCW32USBCntrlDev(PROPSET_NAME_WIN32USBCONTROLLERDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::CW32USBCntrlDev
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32USBCntrlDev::CW32USBCntrlDev
(
    LPCWSTR setName,
    LPCWSTR pszNamespace
)
: CWin32USB(setName, pszNamespace),
  CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::~CW32USBCntrlDev
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32USBCntrlDev::~CW32USBCntrlDev()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::GetObject
(
    CInstance *pInstance,
    long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if(pInstance != NULL)
    {
        CHString chstrAntecedent, chstrDependent;
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
        pInstance->GetCHString(IDS_Dependent, chstrDependent);

        // Obtain the antecedent's device id:
        CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
        chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
        CHString chstrAntecedentDevIDAdj;
        RemoveDoubleBackslashes(chstrAntecedentDevID,chstrAntecedentDevIDAdj);

        // Obtain the dependent's device id:
        CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
        chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
        CHString chstrDependentDevIDAdj;
        RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

        if(chstrAntecedentDevIDAdj.CompareNoCase(chstrDependentDevIDAdj))
        {
            CConfigManager cfgmgr;

            // Now see if the dependent is visible to config manager...
            CConfigMgrDevicePtr pPNPDevice;
            if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, &pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // It is. Does it exist at some level under a USBController?
                    CHString chstrControllerPNPID;
                    if(GetHighestUSBAncestor(pPNPDevice, chstrControllerPNPID))
                    {
                        // It does. Is it's PNP ID the same as that which we were given?
                        if(chstrAntecedentDevIDAdj.CompareNoCase(chstrControllerPNPID)==0)
                        {
                            hr = WBEM_S_NO_ERROR;
                        }
                    }
                }
            } 
        }
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32USBCntrlDev::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CW32USBCntrlDev::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwReqProps;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwReqProps);

    std::vector<_bstr_t> vecDependents;
    pQuery.GetValuesForProp(IDS_Dependent, vecDependents);
    DWORD dwDependents = vecDependents.size();

    if(dwDependents > 0)
    {
        for(LONG m = 0L; m < dwDependents; m++)
        {
            // Obtain the dependent's device id:
            CHString chstrDependent((LPCTSTR)vecDependents[m]);
            CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
            chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
            CHString chstrDependentDevIDAdj;
            RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

            CConfigManager cfgmgr;

            // Now see if the dependent is visible to config manager...
            CConfigMgrDevicePtr pPNPDevice;
            if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, &pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // It is. Is its parent a USBController?
                    CHString chstrControllerPNPID;
                    if(GetHighestUSBAncestor(pPNPDevice, chstrControllerPNPID))
                    {
                        // It is, so create the association.
                        CHString chstrControllerPNPIDAdj;
                        EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                        CHString chstrControllerPATH;
                        chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                                   (LPCWSTR)GetLocalComputerName(),
                                                   IDS_CimWin32Namespace,
                                                   PROPSET_NAME_USB,
                                                   IDS_DeviceID,
                                                   (LPCWSTR)chstrControllerPNPIDAdj);

                        CHString chstrDevicePATH;
                        chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                               (LPCWSTR)GetLocalComputerName(),
                                               IDS_CimWin32Namespace,
                                               PROPSET_NAME_PNPEntity,
                                               IDS_DeviceID,
                                               (LPCWSTR)chstrDependentDevID);

                        hr = CreateAssociation(pMethodContext,
                                               chstrControllerPATH,
                                               chstrDevicePATH,
                                               dwReqProps);
                    }
                }
            }
        } // for
    }  // dwDependents > 0
    else
    {
        CWin32USB::Enumerate(pMethodContext, lFlags, dwReqProps);
    }
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::EnumerateInstances
 *
 *  DESCRIPTION : Enumerate is present here to prevent ambiguous upcasting to
 *                functions of the same name from both base classes.  The
 *                logic in LoadPropertyValues works when CWin32USB's (the
 *                USBController class) version of EnumerateInstances is called,
 *                so that is what we call here.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags
)
{
    return CWin32USB::Enumerate(pMethodContext, lFlags);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::LoadPropertyValues
(
    void* pv
)
{
    // Algorithm:
    // 1) Get all instances of CIM_USBController
    // 2) For each in #1, using cfg mgr, get its children, their children, etc.
    // 3) For each in #2, obtain DeviceID from cfg mgr, and look for instances of
    //    CIM_LogicalDevice with PNPDeviceIDs that match.
    // 4) For matches from #3, create association instances

    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrControllerPNPID;
    CHString chstrControllerPATH;
    MethodContext* pMethodContext = NULL;

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance* pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);
    if(pInstance == NULL || pDevice == NULL) return WBEM_E_FAILED;

    if((pMethodContext = pInstance->GetMethodContext()) != NULL)
    {
        VECPCHSTR vecUSBDevices;

        pDevice->GetDeviceID(chstrControllerPNPID);

        try
        {
            hr = GenerateUSBDeviceList(chstrControllerPNPID, vecUSBDevices);
            if(SUCCEEDED(hr) && vecUSBDevices.size() > 0L)
            {
                CHString chstrControllerPNPIDAdj;
                EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                           (LPCWSTR)GetLocalComputerName(),
                                           IDS_CimWin32Namespace,
                                           PROPSET_NAME_USB,
                                           IDS_DeviceID,
                                           (LPCWSTR)chstrControllerPNPIDAdj);
                hr = ProcessUSBDeviceList(pMethodContext,
                                          chstrControllerPATH,
                                          vecUSBDevices,
                                          dwReqProps);
            }
        }
        catch ( ... )
        {
            CleanPCHSTRVec(vecUSBDevices);
            throw ;
        }

        CleanPCHSTRVec(vecUSBDevices);
    }

    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::GenerateUSBDeviceList
 *
 *  DESCRIPTION : This helper creates a list of devices hanging off the passed
 *                in device.
 *
 *  INPUTS      : vecUSBDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPNPID, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::GenerateUSBDeviceList
(
    const CHString& chstrControllerPNPID,
    VECPCHSTR& vec
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CConfigManager cfgManager;
    CConfigMgrDevicePtr pController;

    if(cfgManager.LocateDevice(chstrControllerPNPID, &pController))
    {
        if(pController != NULL)
        {
            hr = RecursiveFillDeviceBranch(pController, vec);
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::RecursiveFillDeviceBranch
 *
 *  DESCRIPTION : This helper obtains all down branch devices starting with,
 *                but not including, pDevice.
 *
 *  INPUTS      : pDevice, a device to populate the children of;
 *                vecUSBDevices, a list of devices to try to associate
 *                   to the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::RecursiveFillDeviceBranch
(
    CConfigMgrDevice* pDevice,
    VECPCHSTR& vecUSBDevices
)
{
    CConfigMgrDevicePtr pDeviceChild;
    CConfigMgrDevicePtr pDeviceSibling;
    CConfigMgrDevicePtr pDeviceSiblingNext;
    CHString* pchstrTemp = NULL;

    HRESULT hr = WBEM_S_NO_ERROR;
    if(pDevice != NULL)
    {
        if(pDevice->GetChild(&pDeviceChild))
        {
            // Need this child's PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                if(chstrChildPNPDeviceID.GetLength() > 0)
                {
                    // Record this child...
                    pchstrTemp = NULL;
                    pchstrTemp = (CHString*) new CHString(chstrChildPNPDeviceID);
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            vecUSBDevices.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            pchstrTemp = NULL;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }

                    // If we've hit another controller, add this one (done above), but don't go
                    // any deeper.
                    if (!CWin32USB::IsOneOfMe(pDeviceChild))
                    {
                        hr = RecursiveFillDeviceBranch(pDeviceChild, vecUSBDevices);
                    }
                }
            }
            // Now call its brothers and sisters until none left (GetSibling
            // call will return FALSE):
            if(SUCCEEDED(hr))
            {
                if(pDeviceChild->GetSibling(&pDeviceSibling))
                {
                    BOOL fContinue = TRUE;
                    CHString chstrSiblingPNPDeviceID;
                    while(SUCCEEDED(hr) && fContinue)
                    {
                        // Record the sibling now...
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            if(chstrSiblingPNPDeviceID.GetLength() > 0)
                            {
                                pchstrTemp = NULL;
                                pchstrTemp = (CHString*) new CHString(chstrSiblingPNPDeviceID);
                                if(pchstrTemp != NULL)
                                {
                                    try
                                    {
                                        vecUSBDevices.push_back(pchstrTemp);
                                    }
                                    catch ( ... )
                                    {
                                        delete pchstrTemp;
                                        pchstrTemp = NULL;
                                        throw ;
                                    }
                                }
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                        }

                        // If we've hit another controller, add this one (done above), but don't go
                        // any deeper.
                        if (!CWin32USB::IsOneOfMe(pDeviceSibling))
                        {
                            hr = RecursiveFillDeviceBranch(pDeviceSibling, vecUSBDevices);
                        }

                        // Then get the next sibling...
                        fContinue = pDeviceSibling->GetSibling(&pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::ProcessUSBDeviceList
 *
 *  DESCRIPTION : This helper runs through the list, creating an association
 *                instance for each element in the list (vecUSBDevices) with
 *                the controller (chstrControllerPNPID).
 *
 *  INPUTS      : pMethodContext;
 *                vecUSBDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::ProcessUSBDeviceList
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    VECPCHSTR& vecUSBDevices,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    for(LONG m = 0L; m < vecUSBDevices.size() && SUCCEEDED(hr); m++)
    {
        // For each element of the vector, we need to see if there is an instance
        // of a win32_pnpentity that has the specified PNPDeviceID.
        CHString chstrDevicePATH, chstrDevPATHAdj;
        CConfigManager cfgmgr;

        // Let's see if config manager recognizes this device at all
        CConfigMgrDevicePtr pDevice;
        if(cfgmgr.LocateDevice(*vecUSBDevices[m], &pDevice))
        {
            // Ok, it knows about it.  Is it a PNPDevice device?
            if(CWin32PNPEntity::IsOneOfMe(pDevice))
            {
                // It would appear that it is.  Create the association...
                EscapeBackslashes(*vecUSBDevices[m], chstrDevPATHAdj);
                chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_PNPEntity,
                                       IDS_DeviceID,
                                       (LPCWSTR)chstrDevPATHAdj);

                hr = CreateAssociation(pMethodContext, chstrControllerPATH, chstrDevicePATH, dwReqProps);
            }
        }
    }
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::CreateAssociation
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : pMethodContext;
 *                USBDevice, a device to associate with the controller
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper actually creates the association instance and
 *                commits it.
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::CreateAssociation
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    const CHString& chstrDevicePATH,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;
    if(pMethodContext != NULL)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            if(dwReqProps & USBCTL_PROP_Antecedent ||
               dwReqProps & USBCTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Antecedent, chstrControllerPATH);
            }

            if(dwReqProps & USBCTL_PROP_Dependent ||
               dwReqProps & USBCTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Dependent, chstrDevicePATH);
            }

            hr = pInstance->Commit();
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::FindInStringVector
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : chstrUSBDevicePNPID, device to look for
 *                vecUSBDevices, list of devices to look in
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG, number indicating 0 based offset into vecUSBDevices of
 *                the found device, or -1 if not found.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CW32USBCntrlDev::FindInStringVector
(
    const CHString& chstrUSBDevicePNPID,
    VECPCHSTR& vecUSBDevices
)
{
    LONG lPos = -1L;
    bool fFoundIt;
    for(LONG m = 0L; m < vecUSBDevices.size(); m++)
    {
        if(chstrUSBDevicePNPID == *vecUSBDevices[m])
        {
            fFoundIt = true;
            break;
        }
    }
    if(fFoundIt) lPos = m;
    return lPos;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::CleanPCHSTRVec
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : vec, a vector of CHString pointers
 *
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper deletes members of a vector that are pointers.
 *
 *****************************************************************************/
void CW32USBCntrlDev::CleanPCHSTRVec
(
    VECPCHSTR& vec
)
{
    for(LONG m = 0L; m < vec.size(); m++)
    {
        delete vec[m];
    }
    vec.clear();
}


// The highest USB ancestor of a given USB
// device should be the USB controller.
bool CW32USBCntrlDev::GetHighestUSBAncestor
(
    CConfigMgrDevice* pUSBDevice,
    CHString& chstrUSBControllerDeviceID
)
{  
    bool fRet = false;
    CConfigMgrDevicePtr pCurrent, pParent, pHighestUSB;

    if(pUSBDevice != NULL)
    {
        for(pCurrent = pUSBDevice, pHighestUSB = pUSBDevice; 
            pCurrent->GetParent(&pParent); 
            pCurrent = pParent)
        {
            if(pParent->IsClass(L"USB"))
            {
                pHighestUSB = pParent;
            }
        }

        if((CConfigMgrDevice*)(pHighestUSB) != pUSBDevice)
        {
            // Exited loop because we couldn't get parent.  This
            // happens when we reach the top of the tree.
            // If we started out of class USB, and got this error,
            // it means we didn't have an ancestor of type USB
            // prior to reaching the base of the tree.  In such a
            // case, we are a USB controller, and are done.  
            fRet = (bool) pHighestUSB->GetDeviceID(chstrUSBControllerDeviceID);
        }
    }
    
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomapplicationclasses.cpp ===
//=============================================================================================================

//

// Win32_ClassicCOMApplicationClasses.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================
#include "precomp.h"
#include "Win32_ClassicCOMApplicationClasses.h"
#include <cregcls.h>

Win32_ClassicCOMApplicationClasses MyWin32_ClassicCOMApplicationClasses (

CLASSIC_COM_APP_CLASSES,
IDS_CimWin32Namespace
);


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMApplicationClasses::Win32_ClassicCOMApplicationClasses
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const WCHAR strName		- Name of the class
 *				  const WCHAR pszNameSpace	- CIM Namespace
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
Win32_ClassicCOMApplicationClasses::Win32_ClassicCOMApplicationClasses
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMApplicationClasses::~Win32_ClassicCOMApplicationClasses
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
Win32_ClassicCOMApplicationClasses::~Win32_ClassicCOMApplicationClasses ()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMApplicationClasses::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext* a_pMethodContext - Context to enum
 *													instance data in.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClassicCOMApplicationClasses::EnumerateInstances
(

	MethodContext *a_pMethodContext,
	long a_lFlags
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance> t_ComClassList ;
	CRegistry t_RegInfo ;
	CInstancePtr t_pComClassInstance  ;
	CInstancePtr t_pInstance  ;

	//get all instances of Win32_DCOMApplication
	if (
			t_RegInfo.Open (

				HKEY_LOCAL_MACHINE,
				CHString ( L"SOFTWARE\\Classes\\AppID" ),
				KEY_READ
				) == ERROR_SUCCESS
			&&

			SUCCEEDED (

				t_hResult = CWbemProviderGlue::GetInstancesByQuery (

										L"Select ComponentId, AppID FROM Win32_ClassicCOMClassSetting",
										&t_ComClassList, a_pMethodContext, GetNamespace()
									)
				)
		)
	{
		REFPTRCOLLECTION_POSITION	t_pos;

		if ( t_ComClassList.BeginEnum ( t_pos ) )
		{
			t_pComClassInstance.Attach ( t_ComClassList.GetNext( t_pos ) ) ;
			while ( t_pComClassInstance != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString t_chsComponentPath ;
				t_pComClassInstance->GetCHString ( IDS_ComponentId, t_chsComponentPath ) ;

				//get the AppID of the Win32_ClassicCOMClass
				VARIANT vAppid ;
				VariantInit ( &vAppid ) ;

				//check if the AppID entry is present
				if ( t_pComClassInstance->GetVariant( IDS_AppID, vAppid ) && V_VT ( &vAppid ) != VT_NULL )
				{
					_variant_t vartAppid ;
					vartAppid.Attach ( vAppid ) ;
					CHString t_chsAppid ( V_BSTR ( &vAppid ) ) ;
					CRegistry t_RegAppidInfo ;

					if ( t_RegAppidInfo.Open ( t_RegInfo.GethKey() , t_chsAppid, KEY_READ ) == ERROR_SUCCESS )
					{
						t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
						if ( t_pInstance != NULL )
						{
							CHString t_chsFullPath ;
							t_chsFullPath.Format (
													L"\\\\%s\\%s:%s.%s=\"%s\"",
													(LPCWSTR)GetLocalComputerName(),
													IDS_CimWin32Namespace,
													L"Win32_ClassicComClass",
													IDS_ComponentId,
													(LPCWSTR)t_chsComponentPath );
							t_pInstance->SetCHString ( IDS_PartComponent, t_chsFullPath ) ;

							t_chsFullPath.Format (
													L"\\\\%s\\%s:%s.%s=\"%s\"",
													(LPCWSTR)GetLocalComputerName(),
													IDS_CimWin32Namespace,
													L"Win32_DCOMApplication",
													IDS_AppID,
													( LPCWSTR ) t_chsAppid );
							t_pInstance->SetCHString ( IDS_GroupComponent, t_chsFullPath ) ;
							t_hResult =  t_pInstance->Commit ()  ;

							if ( SUCCEEDED ( t_hResult ) )
							{
							}
							else
							{
								break ;
							}
						}
						else
						{
							t_hResult = WBEM_E_OUT_OF_MEMORY ;
							break ;
						}
					}
				}

				t_pComClassInstance.Attach ( t_ComClassList.GetNext( t_pos ) ) ;
			}
			t_ComClassList.EndEnum () ;
		}
	}

	return t_hResult ;

}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMApplicationClasses::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance - Instance into which we
 *                                       retrieve data.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClassicCOMApplicationClasses::GetObject ( CInstance* a_pInstance, long a_lFlags )
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND;
    CHString t_chsClsid, t_chsApplication ;

	CInstancePtr t_pClassicCOMClass , t_pApplicationInstance ;

	a_pInstance->GetCHString ( IDS_PartComponent, t_chsClsid );
	a_pInstance->GetCHString ( IDS_GroupComponent, t_chsApplication );
	MethodContext *t_pMethodContext = a_pInstance->GetMethodContext();

	//check whether the end-pts. are present
	t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsClsid, &t_pClassicCOMClass, t_pMethodContext ) ;

	if ( SUCCEEDED ( t_hResult ) )
	{
		t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsApplication, &t_pApplicationInstance, t_pMethodContext ) ;
	}

	CRegistry t_RegInfo ;
	if ( SUCCEEDED ( t_hResult ) )
	{
		CHString t_chsAppID, t_chsTmp ;
		t_pApplicationInstance->GetCHString ( IDS_AppID, t_chsAppID ) ;
		t_pClassicCOMClass->GetCHString ( IDS_ComponentId, t_chsTmp ) ;

		if ( !t_chsAppID.IsEmpty () &&

			t_RegInfo.Open (

						HKEY_LOCAL_MACHINE,
						CHString ( L"SOFTWARE\\Classes\\CLSID\\" ) + t_chsTmp,
						KEY_READ
					) == ERROR_SUCCESS
			)
		{

			if (	t_RegInfo.GetCurrentKeyValue( L"AppID", t_chsTmp ) == ERROR_SUCCESS  &&
					! t_chsAppID.CompareNoCase ( t_chsTmp )
				)
				{
					t_hResult = WBEM_S_NO_ERROR ;
				}
				else
				{
					t_hResult = WBEM_E_NOT_FOUND ;
				}
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclass.cpp ===
//=============================================================================================================

//

// Win32_ClassicCOMClass.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#include "precomp.h"
#include "Win32_ClassicCOMClass.h"
#include <cregcls.h>
#include <frqueryex.h>

// Property set declaration
//=========================

Win32_ClassicCOMClass MyWin32_ClassicCOMClass(PROPSET_NAME_CLASSIC_COM_CLASS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::Win32_ClassicCOMClass
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_ClassicCOMClass :: Win32_ClassicCOMClass (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::~Win32_ClassicCOMClass
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_ClassicCOMClass :: ~Win32_ClassicCOMClass ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::ExecQuery
 *
 *  DESCRIPTION : Creates an instance for each com class.  It only populates
 *                the requested properties.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClass :: ExecQuery(

    MethodContext *a_pMethodContext,
    CFrameworkQuery& a_pQuery,
    long a_lFlags /*= 0L*/
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR ;
	std::vector<_bstr_t> t_abstrtvectorClsids ;
	std::vector<_bstr_t>::iterator t_pbstrtTmpClsid ;
	CHString t_chsRegKeyPath = L"SOFTWARE\\Classes\\CLSID\\" ;
	t_hResult = a_pQuery.GetValuesForProp(L"ComponentId", t_abstrtvectorClsids ) ;
	if ( SUCCEEDED ( t_hResult ) && t_abstrtvectorClsids.size () )
	{
		for ( t_pbstrtTmpClsid = t_abstrtvectorClsids.begin (); t_pbstrtTmpClsid != t_abstrtvectorClsids.end (); t_pbstrtTmpClsid++ )
		{

			CRegistry t_RegInfo ;
			CHString t_chsClsid ( (PWCHAR)*t_pbstrtTmpClsid ) ;
			CInstancePtr t_pInstance  ;

			//Enumerate all the CLSID's present under HKEY_CLASSES_ROOT
			if ( t_RegInfo.Open (

									HKEY_LOCAL_MACHINE,
									t_chsRegKeyPath + (PWCHAR)*t_pbstrtTmpClsid,
									KEY_READ
								) == ERROR_SUCCESS
				)
			{
				t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;

				if ( t_pInstance != NULL )
				{
					t_pInstance->SetCHString ( IDS_ComponentId, t_chsClsid ) ;
					CHString t_chsTmp ;
					if ( t_RegInfo.GetCurrentKeyValue ( NULL, t_chsTmp ) == ERROR_SUCCESS )
					{
						t_pInstance->SetCHString ( IDS_Name, t_chsTmp ) ;
						t_pInstance->SetCHString ( IDS_Caption, t_chsTmp ) ;
						t_pInstance->SetCHString ( IDS_Description, t_chsTmp ) ;
					}

					t_hResult = t_pInstance->Commit () ;
					if ( SUCCEEDED ( t_hResult ) )
					{
					}
					else
					{
						break ;
					}
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
					break ;
				}
			}
		}
	}
	else
	{
		t_hResult =  WBEM_E_PROVIDER_NOT_CAPABLE ;
	}

	return t_hResult ;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClass :: GetObject (

	CInstance *a_pInstance,
	long a_lFlags /*= 0L*/
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CHString t_chsClsid ;
	CRegistry t_RegInfo ;

	if ( a_pInstance->GetCHString ( IDS_ComponentId, t_chsClsid ) )
	{
		//check to see that the clsid is present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID
		if ( t_RegInfo.Open (
							HKEY_LOCAL_MACHINE,
							CHString ( _T("SOFTWARE\\Classes\\CLSID\\") ) + t_chsClsid,
							KEY_READ ) == ERROR_SUCCESS
						)
		{
			t_RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID", KEY_READ ) ;
			HKEY t_hParentKey = t_RegInfo.GethKey() ;

            DWORD t_dwBits = 0 ;

			t_hResult = FillInstanceWithProperites ( a_pInstance, t_hParentKey, t_chsClsid, &t_dwBits ) ;
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_INVALID_PARAMETER ;
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClass :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CRegistry t_RegInfo ;
	CHString t_chsClsid ;
	CInstancePtr t_pInstance  ;

	//Enumerate all the CLSID's present under HKEY_CLASSES_ROOT
	if ( t_RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\CLSID",
							KEY_READ ) == ERROR_SUCCESS  &&

		t_RegInfo.GetCurrentSubKeyCount() )
	{
		HKEY t_hTmpKey = t_RegInfo.GethKey() ;

		//skip the CLSID\CLSID subkey
		t_RegInfo.NextSubKey() ;
		do
		{
			if ( t_RegInfo.GetCurrentSubKeyName ( t_chsClsid ) == ERROR_SUCCESS )
			{
				t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;

				if ( t_pInstance != NULL )
				{
					DWORD t_dwBits = 0 ;

					t_hResult = FillInstanceWithProperites ( t_pInstance, t_hTmpKey, t_chsClsid, &t_dwBits ) ;
					if ( SUCCEEDED ( t_hResult ) )
					{
						t_hResult = t_pInstance->Commit () ;

						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( t_hResult == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					t_hResult = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( t_RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return t_hResult ;
}

HRESULT Win32_ClassicCOMClass :: FillInstanceWithProperites (

	CInstance *a_pInstance,
	HKEY a_hParentKey,
	CHString& a_rchsClsid,
    LPVOID a_dwProperties
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CRegistry t_ClsidRegInfo, t_TmpReg ;
	CHString t_chsTmp ;

	//open the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{clsid} key
	if ( t_ClsidRegInfo.Open ( a_hParentKey, a_rchsClsid, KEY_READ ) == ERROR_SUCCESS )
	{
		//set the clsid of the component
		a_pInstance->SetCHString ( IDS_ComponentId, a_rchsClsid ) ;

		//set the component name if present
		if ( t_ClsidRegInfo.GetCurrentKeyValue ( NULL, t_chsTmp ) == ERROR_SUCCESS )
		{
			a_pInstance->SetCHString ( IDS_Name, t_chsTmp ) ;
			a_pInstance->SetCHString ( IDS_Description, t_chsTmp ) ;
			a_pInstance->SetCHString ( IDS_Caption, t_chsTmp ) ;
		}

	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclass.h ===
//=============================================================================================================

//

// Win32_ClassicCOMClass.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

// Property set identification
//============================

#define PROPSET_NAME_CLASSIC_COM_CLASS L"Win32_ClassicCOMClass"


class Win32_ClassicCOMClass : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_ClassicCOMClass(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_ClassicCOMClass() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *a_pInstance, 
		long a_lFlags = 0L
	);

	HRESULT EnumerateInstances (

		MethodContext *a_pMethodContext, 
		long a_lFlags = 0L
	);

    HRESULT ExecQuery(
        
        MethodContext *a_pMethodContext, 
        CFrameworkQuery& a_pQuery, 
        long a_lFlags = 0L
    );

protected:
	
	HRESULT Win32_ClassicCOMClass :: FillInstanceWithProperites 
	( 
			CInstance *a_pInstance, 
			HKEY a_hParentKey, 
			CHString& a_rchsClsid, 
            LPVOID a_dwProperties
	) ;

private:

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclasssettings.cpp ===
//=============================================================================================================

//

// Win32_ClassicCOMClassSettings.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================
#include "precomp.h"
#include "Win32_ClassicCOMClassSettings.h"

Win32_ClassicCOMClassSettings MyWin32_ClassicCOMClassSettings (

CLASSIC_COM_SETTING,
IDS_CimWin32Namespace
);


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSettings::Win32_ClassicCOMClassSettings
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const WCHAR strName		- Name of the class
 *				  const WCHAR pszNameSpace	- CIM Namespace
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
Win32_ClassicCOMClassSettings::Win32_ClassicCOMClassSettings
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSettings::~Win32_ClassicCOMClassSettings
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
Win32_ClassicCOMClassSettings::~Win32_ClassicCOMClassSettings ()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSettings::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext* a_pMethodContext - Context to enum
 *													instance data in.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClassicCOMClassSettings::EnumerateInstances
(

	MethodContext *a_pMethodContext,
	long a_lFlags
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance> t_ClassicComList ;

	CInstancePtr t_pClassicCOMClass  ;
	CInstancePtr t_pInstance  ;

	//get all instances of Win32_DCOMApplication
	if ( SUCCEEDED ( t_hResult = CWbemProviderGlue::GetInstancesByQuery ( L"Select __relpath, ComponentId FROM Win32_ClassicCOMClass",
		&t_ClassicComList, a_pMethodContext, GetNamespace() ) ) )
	{
		REFPTRCOLLECTION_POSITION	t_pos;

		if ( t_ClassicComList.BeginEnum ( t_pos ) )
		{
			t_pClassicCOMClass.Attach ( t_ClassicComList.GetNext( t_pos ) ) ;
			while ( t_pClassicCOMClass != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString t_chsComponentPath ;
				t_pClassicCOMClass->GetCHString ( L"__RELPATH", t_chsComponentPath ) ;

				//get the AppID of the Win32_ClassicCOMClass
				VARIANT vClsid ;
				VariantInit ( &vClsid ) ;

				//check if the AppID entry is present
				if ( t_pClassicCOMClass->GetVariant( IDS_ComponentId, vClsid ) && V_VT ( &vClsid ) != VT_NULL )
				{
					_variant_t vartClsid ;
					vartClsid.Attach ( vClsid ) ;
					CHString t_chsClsid ( V_BSTR ( &vClsid ) ) ;

					t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
					if ( t_pInstance != NULL )
					{
						CHString t_chsFullPath ;
						t_chsFullPath.Format (
												L"\\\\%s\\%s:%s",
												(LPCWSTR)GetLocalComputerName(),
												IDS_CimWin32Namespace,
												(LPCWSTR)t_chsComponentPath );
						t_pInstance->SetCHString ( IDS_Element, t_chsFullPath ) ;

						t_chsFullPath.Format (
												L"\\\\%s\\%s:%s.%s=\"%s\"",
												(LPCWSTR)GetLocalComputerName(),
												IDS_CimWin32Namespace,
												L"Win32_ClassicCOMClassSetting",
												IDS_ComponentId,
												( LPCWSTR ) t_chsClsid );
						t_pInstance->SetCHString ( IDS_Setting, t_chsFullPath ) ;
						t_hResult =  t_pInstance->Commit ()  ;

						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
					else
					{
						t_hResult = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}

				t_pClassicCOMClass.Attach ( t_ClassicComList.GetNext( t_pos ) ) ;
			}
			t_ClassicComList.EndEnum () ;
		}
	}

	return t_hResult ;

}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSettings::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance - Instance into which we
 *                                       retrieve data.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClassicCOMClassSettings::GetObject ( CInstance* a_pInstance, long a_lFlags )
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND;
    CHString t_chsClsid, t_chsSetting ;

	CInstancePtr t_pSettingInstance , t_pClsidInstance  ;

	a_pInstance->GetCHString ( IDS_Element, t_chsClsid );
	a_pInstance->GetCHString ( IDS_Setting, t_chsSetting );
	MethodContext *t_pMethodContext = a_pInstance->GetMethodContext();

	//check whether the end-pts. are present
	t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsClsid, &t_pClsidInstance, t_pMethodContext ) ;

	if ( SUCCEEDED ( t_hResult ) )
	{
		t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsSetting, &t_pSettingInstance, t_pMethodContext ) ;
	}

	if ( SUCCEEDED ( t_hResult ) )
	{
		CHString t_chsClsid, t_chsTmp ;
		t_pClsidInstance->GetCHString ( IDS_ComponentId, t_chsClsid ) ;
		t_pSettingInstance->GetCHString ( IDS_ComponentId, t_chsTmp ) ;

		if (	!t_chsClsid.IsEmpty () &&
				!t_chsClsid.CompareNoCase ( t_chsTmp )
			)
		{
			t_hResult = WBEM_S_NO_ERROR ;
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclasssettings.h ===
//=============================================================================================================

//

// Win32_ClassicCOMClassSettings.h -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#define  CLASSIC_COM_SETTING L"Win32_ClassicCOMClassSettings"

class Win32_ClassicCOMClassSettings : public Provider
{
public:
	Win32_ClassicCOMClassSettings (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_ClassicCOMClassSettings ();

	virtual HRESULT EnumerateInstances (MethodContext*  a_pMethodContext, long a_lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* a_pInstance, long a_lFlags = 0L );

private:	
	HRESULT Win32_ClassicCOMClassSettings::CreateInstances 
	( 
		
		CInstance* a_pComObject, 
		PSECURITY_DESCRIPTOR a_pSD, 
		MethodContext*  a_pMethodContext 
	) ;
	
	HRESULT Win32_ClassicCOMClassSettings::CheckInstance ( CInstance* a_pComObject, PSECURITY_DESCRIPTOR a_pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclasssetting.cpp ===
//=============================================================================================================

//

// Win32_ClassicCOMClassSetting.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#include "precomp.h"
#include "Win32_ClassicCOMClassSetting.h"
#include <cregcls.h>
#include <frqueryex.h>

// Property set declaration
//=========================

Win32_ClassicCOMClassSetting MyWin32_ClassicCOMClassSetting(PROPSET_NAME_CLASSIC_COM_CLASS_SETTING, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::Win32_ClassicCOMClassSetting
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_ClassicCOMClassSetting :: Win32_ClassicCOMClassSetting (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{

    m_ptrProperties.SetSize(24);

    m_ptrProperties[0] = ( (LPVOID) IDS_AppID );
    m_ptrProperties[1] = ( (LPVOID) IDS_AutoConvertToClsid );
    m_ptrProperties[2] = ( (LPVOID) IDS_AutoTreatAsClsid );
    m_ptrProperties[3] = ( (LPVOID) IDS_ComponentId );
    m_ptrProperties[4] = ( (LPVOID) IDS_Control );
    m_ptrProperties[5] = ( (LPVOID) IDS_DefaultIcon );
    m_ptrProperties[6] = ( (LPVOID) IDS_InprocServer );
    m_ptrProperties[7] = ( (LPVOID) IDS_InprocServer32 );
    m_ptrProperties[8] = ( (LPVOID) IDS_Insertable );
    m_ptrProperties[9] = ( (LPVOID) IDS_InprocHandler );
    m_ptrProperties[10] = ( (LPVOID) IDS_InprocHandler32 );
    m_ptrProperties[11] = ( (LPVOID) IDS_JavaClass );
    m_ptrProperties[12] = ( (LPVOID) IDS_LocalServer );
    m_ptrProperties[13] = ( (LPVOID) IDS_LocalServer32 );
    m_ptrProperties[14] = ( (LPVOID) IDS_LongDisplayName );
    m_ptrProperties[15] = ( (LPVOID) IDS_Name );
    m_ptrProperties[16] = ( (LPVOID) IDS_ProgId );
    m_ptrProperties[17] = ( (LPVOID) IDS_ShortDisplayName );
    m_ptrProperties[18] = ( (LPVOID) IDS_ThreadingModel );
    m_ptrProperties[19] = ( (LPVOID) IDS_ToolBoxBitmap32 );
    m_ptrProperties[20] = ( (LPVOID) IDS_TreatAsClsid );
    m_ptrProperties[21] = ( (LPVOID) IDS_TypeLibraryId );
    m_ptrProperties[22] = ( (LPVOID) IDS_Version );
    m_ptrProperties[23] = ( (LPVOID) IDS_VersionIndependentProgId  );

}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::~Win32_ClassicCOMClassSetting
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_ClassicCOMClassSetting :: ~Win32_ClassicCOMClassSetting ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::ExecQuery
 *
 *  DESCRIPTION : Creates an instance for each com class.  It only populates
 *                the requested properties.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClassSetting :: ExecQuery(

    MethodContext *a_pMethodContext,
    CFrameworkQuery& a_pQuery,
    long a_lFlags /*= 0L*/
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR ;
	DWORD t_dwBits[(BIT_LAST_ENTRY + 32)/32];

    CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx *>(&a_pQuery);  // for use far below to check IfNTokenAnd
    t_pQuery2->GetPropertyBitMask ( m_ptrProperties, &t_dwBits ) ;

	CRegistry t_RegInfo ;
	CHString t_chsClsid ;

	CInstancePtr t_pInstance  ;

	//Enumerate all the CLSID's present under HKEY_CLASSES_ROOT
	if ( t_RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\CLSID",
							KEY_READ ) == ERROR_SUCCESS  &&

		t_RegInfo.GetCurrentSubKeyCount() )
	{
		HKEY t_hTmpKey = t_RegInfo.GethKey() ;

		//skip the CLSID\CLSID subkey
		t_RegInfo.NextSubKey() ;
		do
		{
			if ( t_RegInfo.GetCurrentSubKeyName ( t_chsClsid ) == ERROR_SUCCESS )
			{
				t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;

				if ( t_pInstance != NULL )
				{
					t_hResult = FillInstanceWithProperites ( t_pInstance, t_hTmpKey, t_chsClsid, &t_dwBits ) ;
					if ( SUCCEEDED ( t_hResult ) )
					{
						t_hResult = t_pInstance->Commit () ;
						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( t_hResult == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					t_hResult = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( t_RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return t_hResult ;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClassSetting :: GetObject (

	CInstance *a_pInstance,
	long a_lFlags,
    CFrameworkQuery& a_pQuery

)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CHString t_chsClsid ;
	CRegistry t_RegInfo ;

	if ( a_pInstance->GetCHString ( IDS_ComponentId, t_chsClsid ) )
	{
		//check to see that the clsid is present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID
		if ( t_RegInfo.Open (
							HKEY_LOCAL_MACHINE,
							CHString ( _T("SOFTWARE\\Classes\\CLSID\\") ) + t_chsClsid,
							KEY_READ ) == ERROR_SUCCESS
						)
		{
			t_RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID", KEY_READ ) ;
			HKEY t_hParentKey = t_RegInfo.GethKey() ;

	        DWORD t_dwBits[(BIT_LAST_ENTRY + 32)/32];

            CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx *>(&a_pQuery);  // for use far below to check IfNTokenAnd
            t_pQuery2->GetPropertyBitMask ( m_ptrProperties, &t_dwBits ) ;

			t_hResult = FillInstanceWithProperites ( a_pInstance, t_hParentKey, t_chsClsid, &t_dwBits ) ;
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_INVALID_PARAMETER ;
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClassSetting :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CRegistry t_RegInfo ;
	CHString t_chsClsid ;
	CInstancePtr t_pInstance  ;

	//Enumerate all the CLSID's present under HKEY_CLASSES_ROOT
	if ( t_RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\CLSID",
							KEY_READ ) == ERROR_SUCCESS  &&

		t_RegInfo.GetCurrentSubKeyCount() )
	{
		HKEY t_hTmpKey = t_RegInfo.GethKey() ;

		//skip the CLSID\CLSID subkey
		t_RegInfo.NextSubKey() ;
		do
		{
			if ( t_RegInfo.GetCurrentSubKeyName ( t_chsClsid ) == ERROR_SUCCESS )
			{
				t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;

				if ( t_pInstance != NULL )
				{
					DWORD t_dwBits[(BIT_LAST_ENTRY + 32)/32];

					SetAllBits ( t_dwBits, BIT_LAST_ENTRY ) ;
					t_hResult = FillInstanceWithProperites ( t_pInstance, t_hTmpKey, t_chsClsid, t_dwBits ) ;
					if ( SUCCEEDED ( t_hResult ) )
					{
						t_hResult = t_pInstance->Commit () ;

						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( t_hResult == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					t_hResult = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( t_RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return t_hResult ;
}

HRESULT Win32_ClassicCOMClassSetting :: FillInstanceWithProperites (

	CInstance *a_pInstance,
	HKEY a_hParentKey,
	CHString& a_rchsClsid,
    LPVOID a_dwProperties
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CRegistry t_ClsidRegInfo, t_TmpReg ;
	CHString t_chsTmp ;

	//open the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{clsid} key
	if ( t_ClsidRegInfo.Open ( a_hParentKey, a_rchsClsid, KEY_READ ) == ERROR_SUCCESS )
	{
		HKEY t_hClsidKey = t_ClsidRegInfo.GethKey() ;

		//set the clsid of the component
		a_pInstance->SetCHString ( IDS_ComponentId, a_rchsClsid ) ;

		//set the component name if present
		if ( t_ClsidRegInfo.GetCurrentKeyValue ( NULL, t_chsTmp ) == ERROR_SUCCESS )
		{
			a_pInstance->SetCHString ( IDS_Caption, t_chsTmp ) ;
			a_pInstance->SetCHString ( IDS_Description, t_chsTmp ) ;
		}

		//find if AppID is present
		if ( IsBitSet( a_dwProperties, BIT_AppID ) && ( t_ClsidRegInfo.GetCurrentKeyValue( L"AppID", t_chsTmp ) == ERROR_SUCCESS ) )
		{
			a_pInstance->SetCHString ( IDS_AppID, t_chsTmp ) ;
		}

		//find if the "Control" subkey is present
        if ( IsBitSet ( a_dwProperties, BIT_Control ))
        {
		    if ( t_TmpReg.Open ( t_hClsidKey, L"Control", KEY_READ ) == ERROR_SUCCESS )
		    {
			    a_pInstance->Setbool ( IDS_Control, true ) ;
		    }
		    else
		    {
			    a_pInstance->Setbool ( IDS_Control, false ) ;
		    }
        }

        if ( IsBitSet ( a_dwProperties, BIT_Insertable ))
        {
		    //find if the "Insertable" subkey is present
		    if ( t_TmpReg.Open ( t_hClsidKey, L"Insertable", KEY_READ ) == ERROR_SUCCESS )
		    {
			    a_pInstance->Setbool ( IDS_Insertable, true ) ;
		    }
		    else
		    {
			    a_pInstance->Setbool ( IDS_Insertable, false ) ;
		    }
        }

        if ( IsBitSet ( a_dwProperties, BIT_JavaClass ) ||
             IsBitSet ( a_dwProperties, BIT_InprocServer32) ||
             IsBitSet ( a_dwProperties, BIT_ThreadingModel ) )
        {
		    //find if the InProcServer32 subkey is present
		    if ( t_TmpReg.Open ( t_hClsidKey, L"InprocServer32", KEY_READ ) == ERROR_SUCCESS )
		    {
			    //check if the "JavaClass" named value is present
                if ( IsBitSet ( a_dwProperties, BIT_JavaClass)  || IsBitSet ( a_dwProperties, BIT_InprocServer32 ) )
                {
			        if ( t_TmpReg.GetCurrentKeyValue( L"JavaClass", t_chsTmp )  == ERROR_SUCCESS )
			        {
				        a_pInstance->Setbool ( IDS_JavaClass, true ) ;
				        a_pInstance->SetCHString ( IDS_InprocServer32, t_chsTmp ) ;
			        }
			        else
			        {
				        a_pInstance->Setbool ( IDS_JavaClass, false ) ;
				        if ( IsBitSet ( a_dwProperties, BIT_InprocServer32 ) && ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS ) )
				        {
					        a_pInstance->SetCHString ( IDS_InprocServer32, t_chsTmp ) ;
				        }
			        }
                }

			    //check the threading model
			    if ( IsBitSet ( a_dwProperties, BIT_ThreadingModel ) && ( t_TmpReg.GetCurrentKeyValue( L"ThreadingModel", t_chsTmp )  == ERROR_SUCCESS ) )
			    {
				    a_pInstance->SetCHString ( IDS_ThreadingModel, t_chsTmp ) ;
			    }
		    }
		    else
		    {
			    a_pInstance->Setbool ( IDS_JavaClass, false ) ;
		    }
        }

		//find if the InProcServer subkey is present
		if ( IsBitSet ( a_dwProperties,  BIT_InprocServer ) && ( t_TmpReg.Open ( t_hClsidKey, L"InprocServer", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_InprocServer, t_chsTmp ) ;
			}
		}

		//find if the LocalServer32 subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_LocalServer32 ) && ( t_TmpReg.Open ( t_hClsidKey, L"LocalServer32", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_LocalServer32, t_chsTmp ) ;
			}
		}

		//find if the LocalServer subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_LocalServer ) && ( t_TmpReg.Open ( t_hClsidKey, L"LocalServer", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_LocalServer, t_chsTmp ) ;
			}
		}

		//find if the InprocHandler32 subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_InprocHandler32 ) && ( t_TmpReg.Open ( t_hClsidKey, L"InprocHandler32", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_InprocHandler32, t_chsTmp ) ;
			}
		}

		//find if the InprocHandler subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_InprocHandler ) && ( t_TmpReg.Open ( t_hClsidKey, L"InprocHandler", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_InprocHandler, t_chsTmp ) ;
			}
		}

		//find if the TreatAs subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_TreatAsClsid ) && ( t_TmpReg.Open ( t_hClsidKey, L"TreatAs", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_TreatAsClsid, t_chsTmp ) ;
			}
		}

		//find if the AutoTreatAs subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_AutoTreatAsClsid ) && ( t_TmpReg.Open ( t_hClsidKey, L"AutoTreatAs", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_AutoTreatAsClsid, t_chsTmp ) ;
			}
		}

		//find if the ProgId subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_ProgId ) && ( t_TmpReg.Open ( t_hClsidKey, L"ProgID", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue ( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_ProgId, t_chsTmp ) ;
			}
		}

		//find if the VersionIndependentProgId subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_VersionIndependentProgId ) && ( t_TmpReg.Open ( t_hClsidKey, L"VersionIndependentProgId", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_VersionIndependentProgId, t_chsTmp ) ;
			}
		}

		//find if the TypeLib subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_TypeLibraryId ) && ( t_TmpReg.Open ( t_hClsidKey, L"TypeLib", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_TypeLibraryId, t_chsTmp ) ;
			}
		}

		//TODO:get hlp/tlb file

		//find if the Version subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_Version ) && ( t_TmpReg.Open ( t_hClsidKey, L"Version", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_Version, t_chsTmp ) ;
			}
		}

		//find if the AutoConvertTo subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_AutoConvertToClsid ) && ( t_TmpReg.Open ( t_hClsidKey, L"AutoConvertTo", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_AutoConvertToClsid, t_chsTmp ) ;
			}
		}

		//find if the DefaultIcon subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_DefaultIcon ) && ( t_TmpReg.Open ( t_hClsidKey, L"DefaultIcon", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_DefaultIcon, t_chsTmp ) ;
			}
		}

		//find if the ToolBoxBitmap32 subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_ToolBoxBitmap32 ) && ( t_TmpReg.Open ( t_hClsidKey, L"ToolBoxBitmap32", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_ToolBoxBitmap32, t_chsTmp ) ;
			}
		}

		// Find if the Short & Long display names are present
		// These are stored as :
		// 1.	HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\AuxUserType\2 = <ShortDisplayName>
		// 2.	HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\AuxUserType\3 = <ApplicationName>
        if ( IsBitSet ( a_dwProperties, BIT_ShortDisplayName ) || IsBitSet ( a_dwProperties, BIT_LongDisplayName ) )
        {
		    if ( t_TmpReg.Open ( t_hClsidKey, L"AuxUserType", KEY_READ ) == ERROR_SUCCESS )
		    {
			    CRegistry t_RegAuxUsrType ;
			    if ( IsBitSet ( a_dwProperties,  BIT_ShortDisplayName ) && ( t_RegAuxUsrType.Open ( t_TmpReg.GethKey (), L"2", KEY_READ ) == ERROR_SUCCESS ) )
			    {
				    if ( t_RegAuxUsrType.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
				    {
					    a_pInstance->SetCHString ( IDS_ShortDisplayName, t_chsTmp ) ;
				    }
			    }

			    if ( IsBitSet ( a_dwProperties,  BIT_LongDisplayName ) && ( t_RegAuxUsrType.Open ( t_TmpReg.GethKey (), L"3", KEY_READ ) == ERROR_SUCCESS ) )
			    {
				    if ( t_RegAuxUsrType.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
				    {
					    a_pInstance->SetCHString ( IDS_LongDisplayName, t_chsTmp ) ;
				    }
			    }
		    }
        }
	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclasssetting.h ===
//=============================================================================================================

//

// Win32_ClassicCOMClassSetting.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

// Property set identification
//============================

#define PROPSET_NAME_CLASSIC_COM_CLASS_SETTING L"Win32_ClassicCOMClassSetting"

#define BIT_AppID 0
#define BIT_AutoConvertToClsid 1
#define BIT_AutoTreatAsClsid 2
#define BIT_ComponentId 3
#define BIT_Control 4
#define BIT_DefaultIcon 5
#define BIT_InprocServer 6
#define BIT_InprocServer32 7
#define BIT_Insertable 8
#define BIT_InprocHandler 9
#define BIT_InprocHandler32 10
#define BIT_JavaClass 11
#define BIT_LocalServer 12
#define BIT_LocalServer32 13
#define BIT_LongDisplayName 14
#define BIT_Name 15
#define BIT_ProgId 16
#define BIT_ShortDisplayName 17
#define BIT_ThreadingModel 18
#define BIT_ToolBoxBitmap32 19
#define BIT_TreatAsClsid 20
#define BIT_TypeLibraryId 21
#define BIT_Version 22
#define BIT_VersionIndependentProgId 23

#define BIT_LAST_ENTRY BIT_VersionIndependentProgId

class Win32_ClassicCOMClassSetting : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_ClassicCOMClassSetting(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_ClassicCOMClassSetting() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *a_pInstance, 
		long a_lFlags,
        CFrameworkQuery& a_pQuery
	);

	HRESULT EnumerateInstances (

		MethodContext *a_pMethodContext, 
		long a_lFlags = 0L
	);

    HRESULT ExecQuery(
        
        MethodContext *a_pMethodContext, 
        CFrameworkQuery& a_pQuery, 
        long a_lFlags = 0L
    );

protected:
	
	HRESULT Win32_ClassicCOMClassSetting :: FillInstanceWithProperites 
	( 
			CInstance *a_pInstance, 
			HKEY a_hParentKey, 
			CHString& a_rchsClsid, 
            LPVOID a_dwProperties
	) ;

private:
    CHPtrArray m_ptrProperties;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_clientapplicationsetting.h ===
//=============================================================================================================

//

// Win32_ClientApplicationSetting.h

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#ifndef __Win32_ClientApplicationSetting_H_
#define __Win32_ClientApplicationSetting_H_

#define  DCOM_CLIENT_APP_SETTING L"Win32_ClientApplicationSetting"

class Win32_ClientApplicationSetting : public Provider
{
private:
protected:
public:
	Win32_ClientApplicationSetting (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_ClientApplicationSetting ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

	virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);


private:	
	HRESULT Win32_ClientApplicationSetting::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_ClientApplicationSetting::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
	PWCHAR Win32_ClientApplicationSetting::GetFileName ( bstr_t& bstrtTmp ) ;

	BOOL Win32_ClientApplicationSetting::FileNameExists ( CHString& file );
};	

#endif //__Win32_ClientApplicationSetting_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comapplicationsettings.h ===
//=============================================================================================================

//

// Win32_COMApplicationSettings.h -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#define  COM_APP_SETTING L"Win32_COMApplicationSettings"

class Win32_COMApplicationSettings : public Provider
{
public:
	Win32_COMApplicationSettings (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_COMApplicationSettings ();

	virtual HRESULT EnumerateInstances (MethodContext*  a_pMethodContext, long a_lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* a_pInstance, long a_lFlags = 0L );

private:	
	HRESULT Win32_COMApplicationSettings::CreateInstances 
	( 
		
		CInstance* a_pComObject, 
		PSECURITY_DESCRIPTOR a_pSD, 
		MethodContext*  a_pMethodContext 
	) ;
	
	HRESULT Win32_COMApplicationSettings::CheckInstance ( CInstance* a_pComObject, PSECURITY_DESCRIPTOR a_pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comapplicationsettings.cpp ===
//=============================================================================================================

//

// Win32_COMApplicationSettings.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================
#include "precomp.h"
#include "Win32_COMApplicationSettings.h"

Win32_COMApplicationSettings MyWin32_COMApplicationSettings (

COM_APP_SETTING,
IDS_CimWin32Namespace
);


/*****************************************************************************
 *
 *  FUNCTION    : Win32_COMApplicationSettings::Win32_COMApplicationSettings
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const WCHAR strName		- Name of the class
 *				  const WCHAR pszNameSpace	- CIM Namespace
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
Win32_COMApplicationSettings::Win32_COMApplicationSettings
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_COMApplicationSettings::~Win32_COMApplicationSettings
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
Win32_COMApplicationSettings::~Win32_COMApplicationSettings ()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_COMApplicationSettings::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext* a_pMethodContext - Context to enum
 *													instance data in.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_COMApplicationSettings::EnumerateInstances
(

	MethodContext *a_pMethodContext,
	long a_lFlags
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance> t_DCOMAppList ;

	CInstancePtr t_pDCOMAppInstance  ;
	CInstancePtr t_pInstance  ;

	//get all instances of Win32_DCOMApplication
	if ( SUCCEEDED ( t_hResult = CWbemProviderGlue::GetInstancesByQuery ( L"Select __relpath, AppID FROM Win32_DCOMApplication",
		&t_DCOMAppList, a_pMethodContext, GetNamespace() ) ) )
	{
		REFPTRCOLLECTION_POSITION	t_pos;

		if ( t_DCOMAppList.BeginEnum ( t_pos ) )
		{
			t_pDCOMAppInstance.Attach ( t_DCOMAppList.GetNext( t_pos ) ) ;
			while ( t_pDCOMAppInstance != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString t_chsComponentPath ;
				t_pDCOMAppInstance->GetCHString ( L"__RELPATH", t_chsComponentPath ) ;

				//get the AppID of the Win32_ClassicCOMClass
				VARIANT vAppid ;
				VariantInit ( &vAppid ) ;

				//check if the AppID entry is present
				if ( t_pDCOMAppInstance->GetVariant( IDS_AppID, vAppid ) && V_VT ( &vAppid ) != VT_NULL )
				{
					_variant_t vartAppid ;
					vartAppid.Attach ( vAppid ) ;
					CHString t_chsAppid ( V_BSTR ( &vAppid ) ) ;

					t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
					if ( t_pInstance != NULL )
					{
						CHString t_chsFullPath ;
						t_chsFullPath.Format (
												L"\\\\%s\\%s:%s",
												(LPCWSTR)GetLocalComputerName(),
												IDS_CimWin32Namespace,
												(LPCWSTR)t_chsComponentPath );
						t_pInstance->SetCHString ( IDS_Element, t_chsFullPath ) ;

						t_chsFullPath.Format (
												L"\\\\%s\\%s:%s.%s=\"%s\"",
												(LPCWSTR)GetLocalComputerName(),
												IDS_CimWin32Namespace,
												L"Win32_DCOMApplicationSetting",
												IDS_AppID,
												( LPCWSTR ) t_chsAppid );
						t_pInstance->SetCHString ( IDS_Setting, t_chsFullPath ) ;
						t_hResult =  t_pInstance->Commit ()  ;

						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
					else
					{
						t_hResult = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}

				t_pDCOMAppInstance.Attach ( t_DCOMAppList.GetNext( t_pos ) ) ;
			}
			t_DCOMAppList.EndEnum () ;
		}
	}

	return t_hResult ;

}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_COMApplicationSettings::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance - Instance into which we
 *                                       retrieve data.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_COMApplicationSettings::GetObject ( CInstance* a_pInstance, long a_lFlags )
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND;
    CHString t_chsAppid, t_chsSetting ;

	CInstancePtr t_pSettingInstance , t_pApplicationInstance ;

	a_pInstance->GetCHString ( IDS_Element, t_chsAppid );
	a_pInstance->GetCHString ( IDS_Setting, t_chsSetting );
	MethodContext *t_pMethodContext = a_pInstance->GetMethodContext();

	//check whether the end-pts. are present
	t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsAppid, &t_pApplicationInstance, t_pMethodContext ) ;

	if ( SUCCEEDED ( t_hResult ) )
	{
		t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsSetting, &t_pSettingInstance, t_pMethodContext ) ;
	}

	if ( SUCCEEDED ( t_hResult ) )
	{
		CHString t_chsAppID, t_chsTmp ;
		t_pApplicationInstance->GetCHString ( IDS_AppID, t_chsAppID ) ;
		t_pSettingInstance->GetCHString ( IDS_AppID, t_chsTmp ) ;

		if (	!t_chsAppID.IsEmpty () &&
				!t_chsAppID.CompareNoCase ( t_chsTmp )
			)
		{
			t_hResult = WBEM_S_NO_ERROR ;
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comclassautoemulator.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_COMClassAutoEmulator
//
//////////////////////////////////////////////////////

#define  Win32_COM_CLASS_AUTO_EMULATOR L"Win32_COMClassAutoEmulator"

class Win32_COMClassAutoEmulator : public Provider
{
private:
protected:
public:
	Win32_COMClassAutoEmulator (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_COMClassAutoEmulator ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

private:	
	HRESULT Win32_COMClassAutoEmulator::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_COMClassAutoEmulator::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_clientapplicationsetting.cpp ===
//=============================================================================================================

//

// Win32_ClientApplicationSetting.CPP

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#include "precomp.h"
#include <cregcls.h>
#include "Win32_ClientApplicationSetting.h"

#include "NtDllApi.h"

//MOF Definition
/*
	[Association:  ToInstance, Dynamic, Provider("cimw32ex")]
class Win32_ClientApplicationSetting
{
	[key]
	CIM_DataFile ref Client ;


	Win32_DCOMApplication ref Application ;
};

*/

/*
 *NOTE:		Instances of this class can be obtained only by doing Associators of given Cim_DataFile.
 *			Instances cannot be obtained by calling Associators of Win32_DCOMApplication.This is because
 *			Given an AppID, we do not get the complete path to the .exe under the AppID hive in the registry
 *
 */

Win32_ClientApplicationSetting MyWin32_ClientApplicationSetting (
																		DCOM_CLIENT_APP_SETTING,
																		IDS_CimWin32Namespace );


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::Win32_ClientApplicationSetting
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
Win32_ClientApplicationSetting::Win32_ClientApplicationSetting
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::~Win32_ClientApplicationSetting
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/
Win32_ClientApplicationSetting::~Win32_ClientApplicationSetting ()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::ExecQuery
 *
 *  DESCRIPTION :
 *
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClientApplicationSetting::ExecQuery(

	MethodContext *a_pMethodContext,
	CFrameworkQuery& a_pQuery,
	long a_lFlags /* = 0L*/
)
{
	HRESULT t_hResult;
	CHStringArray t_achsNames ;

	CInstancePtr t_pInstance ;

	t_hResult = a_pQuery.GetValuesForProp(L"Client", t_achsNames );
	if ( SUCCEEDED ( t_hResult ) )
	{
		DWORD t_dwSize = t_achsNames.GetSize();
		if ( t_dwSize == 1 )
		{
			if ( FileNameExists ( t_achsNames[0] ) )
			{
				//Get the Name of the Client .Exe. Format will be Cim_DataFile.Name="{path}\Filename"
				bstr_t t_bstrtTmp = t_achsNames[0] ;
				PWCHAR t_pwcExecutable = GetFileName ( t_bstrtTmp ) ;

				if ( t_pwcExecutable )
				{
					CHString t_chsExe = t_pwcExecutable ;
					CRegistry t_RegInfo ;

					//check if there is an entry for the executable under HKLM\SOFTWARE\Classes\AppID
					if ( t_RegInfo.Open (
										HKEY_LOCAL_MACHINE,
										CHString ( L"SOFTWARE\\Classes\\AppID\\" ) + t_chsExe,
										KEY_READ ) == ERROR_SUCCESS
									)
					{
						CHString t_chsTmp ;
						if ( t_RegInfo.GetCurrentKeyValue( L"AppID", t_chsTmp ) == ERROR_SUCCESS && !t_chsTmp.IsEmpty () )
						{
							t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
							if ( t_pInstance != NULL )
							{
								CHString t_chsReferencePath ;

								t_chsReferencePath.Format (

														L"\\\\%s\\%s:%s",
														(LPCWSTR) GetLocalComputerName(),
														IDS_CimWin32Namespace,
														t_achsNames[0] ) ;

								t_pInstance->SetCHString ( IDS_Client, t_chsReferencePath ) ;

								t_chsReferencePath.Format(

														L"\\\\%s\\%s:%s.%s=\"%s\"",
														(LPCWSTR) GetLocalComputerName(),
														IDS_CimWin32Namespace,
														L"Win32_DCOMApplication",
														IDS_AppID,
														t_chsTmp );

								t_pInstance->SetCHString ( IDS_Application, t_chsReferencePath ) ;
								t_hResult = t_pInstance->Commit () ;
							}
							else
							{
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}
					else
					{
//						t_hResult = WBEM_E_NOT_FOUND ;
						t_hResult = WBEM_S_NO_ERROR ;
					}
				}
				else
				{
//					t_hResult = WBEM_E_PROVIDER_NOT_CAPABLE ;
					t_hResult = WBEM_S_NO_ERROR ;
				}
			}
			else
			{
//				t_hResult = WBEM_E_NOT_FOUND ;
				t_hResult = WBEM_S_NO_ERROR ;
			}
		}
		else
		{
			//we can't handle this query
//			t_hResult = WBEM_E_PROVIDER_NOT_CAPABLE ;
			t_hResult = WBEM_S_NO_ERROR ;
		}
	}
	else
	{
//		t_hResult = WBEM_E_PROVIDER_NOT_CAPABLE ;
		t_hResult = WBEM_S_NO_ERROR ;
	}

	return t_hResult ;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext* a_pMethodContext - Context to enum
 *													instance data in.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    : Instances of this class cannot be obtained.This is because
 *				  given an AppID, we do not get the complete path to the .exe under the AppID hive in the registry
 *
 *****************************************************************************/
HRESULT Win32_ClientApplicationSetting::EnumerateInstances
(
	MethodContext*  a_pMethodContext,
	long a_lFlags
)
{
	return WBEM_E_NOT_SUPPORTED;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance - Instance into which we
 *                                       retrieve data.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClientApplicationSetting::GetObject (

CInstance* a_pInstance,
long a_lFlags
)
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND;
	CHString t_chsClient ;
	PWCHAR t_pwcColon = L":" ;
	a_pInstance->GetCHString ( IDS_Client, t_chsClient ) ;
	if ( !t_chsClient.IsEmpty() )
	{
		if ( FileNameExists ( t_chsClient ) )
		{
			bstr_t t_bstrtClient = t_chsClient ;
			PWCHAR t_pwcTmp = t_bstrtClient ;

			if ( t_pwcTmp = GetFileName ( t_bstrtClient ) )
			{
				//check if there is an entry for the executable under HKLM\SOFTWARE\Classes\AppID
				CHString t_chsExe ( t_pwcTmp ) ;
				CRegistry t_RegInfo ;
				if ( t_RegInfo.Open (
									HKEY_LOCAL_MACHINE,
									CHString ( _T("SOFTWARE\\Classes\\AppID\\") ) + t_chsExe,
									KEY_READ ) == ERROR_SUCCESS
								)
				{
					CHString t_chsTmp ;
					if ( t_RegInfo.GetCurrentKeyValue( L"AppID", t_chsTmp ) == ERROR_SUCCESS && !t_chsTmp.IsEmpty () )
					{
						CHString t_chsReferencePath ;
						t_chsReferencePath.Format(

												L"\\\\%s\\%s:%s.%s=\"%s\"",
												GetLocalComputerName(),
												IDS_CimWin32Namespace,
												L"Win32_DCOMApplication",
												IDS_AppID,
												t_chsTmp );

						a_pInstance->SetCHString ( IDS_Application, t_chsReferencePath ) ;
						t_hResult = WBEM_S_NO_ERROR ;
					}
					else
					{
						t_hResult = WBEM_E_NOT_FOUND ;
					}
				}
				else
				{
					t_hResult = WBEM_E_NOT_FOUND ;
				}
			}
			else
			{
				t_hResult = WBEM_E_INVALID_OBJECT_PATH ;
			}
		}
	}
	else
	{
		t_hResult = WBEM_E_INVALID_PARAMETER ;
	}

	return t_hResult ;
}


PWCHAR Win32_ClientApplicationSetting::GetFileName ( bstr_t& a_bstrtTmp )
{

	//Remove the complete path & get only the filename as that's what is stored in the registry
	PWCHAR t_pwcKey = NULL;
	PWCHAR t_pwcCompletePath = a_bstrtTmp ;

	if (t_pwcCompletePath)
	{
		UCHAR t_wack = L'\\' ;
		t_pwcKey = wcsrchr ( t_pwcCompletePath, t_wack ) ;

		if ( t_pwcKey != NULL )
		{
			t_pwcKey += 1 ;

			if ( t_pwcKey != NULL )
			{
				PWCHAR t_pwcQuote = L"\"" ;

				//remove the final quote from the filename
				PWCHAR t_pwcTmp = wcsstr ( t_pwcKey, t_pwcQuote ) ;
				if ( t_pwcTmp )
				{
					*t_pwcTmp = 0 ;
				}
			}
		}
	}

	return t_pwcKey ;
}


BOOL Win32_ClientApplicationSetting::FileNameExists ( CHString& file )
{
	BOOL bResult = FALSE;

	if( ! file.IsEmpty () )
	{
		BOOL bContinue = TRUE;

		PWCHAR t_pwcFile	= NULL;
		PWCHAR t_pwcQuote	= L"\"" ;
		PWCHAR t_pwcTmp		= wcsstr ( static_cast < LPCWSTR > ( file ), t_pwcQuote ) ;

		if ( t_pwcTmp )
		{
			// remove first quote
			t_pwcTmp++;

			try
			{
				if ( ( t_pwcFile = new WCHAR [ lstrlenW ( t_pwcTmp ) ] ) != NULL )
				{
					memcpy ( t_pwcFile, t_pwcTmp, ( lstrlenW ( t_pwcTmp ) - 1 ) * sizeof ( WCHAR ) );
					t_pwcFile [ lstrlenW ( t_pwcTmp ) - 1 ] = L'\0';
				}
				else
				{
					bContinue = FALSE;
				}
			}
			catch ( ... )
			{
				if ( t_pwcFile )
				{
					delete [] t_pwcFile;
					t_pwcFile = NULL;
				}

				bContinue = FALSE;
			}
		}
		else
		{
			bContinue = FALSE;
		}

		if ( bContinue )
		{
			PWCHAR t_pwcFileTmp = NULL;

			try
			{
				if ( ( t_pwcFileTmp = new WCHAR [ lstrlenW ( t_pwcFile ) + 4 + 1 ] ) != NULL )
				{
					wcscpy ( t_pwcFileTmp, L"\\??\\" );

					PWCHAR t_pwc  = NULL;
					PWCHAR t_pwc1 = NULL;

					t_pwc  = t_pwcFile;
					t_pwc1 = t_pwcFileTmp;

					t_pwcFileTmp = t_pwcFileTmp + 4;

					DWORD dw = 4L;

					BOOL bEscape  = TRUE;
					BOOL bProceed = TRUE;

					while ( *t_pwc )
					{
						if ( *t_pwc == L'\\' )
						{
							if ( bEscape )
							{
								bEscape  = FALSE;
								bProceed = FALSE;
							}
							else
							{
								bEscape  = TRUE;
								bProceed = TRUE;
							}
						}
						else
						{
							bProceed = TRUE;
						}

						if ( bProceed )
						{
							*t_pwcFileTmp = *t_pwc;

							t_pwcFileTmp++;
							dw++;
						}

						t_pwc++;
					}

					t_pwcFileTmp = t_pwc1;
					t_pwcFileTmp [ dw ] = L'\0';

					if ( t_pwcFile )
					{
						delete [] t_pwcFile;
						t_pwcFile = NULL;
					}

					t_pwcFile = t_pwcFileTmp;
				}
				else
				{
					if ( t_pwcFile )
					{
						delete [] t_pwcFile;
						t_pwcFile = NULL;
					}

					bContinue = FALSE;
				}
			}
			catch ( ... )
			{
				if ( t_pwcFileTmp )
				{
					delete [] t_pwcFileTmp;
					t_pwcFileTmp = NULL;
				}

				if ( t_pwcFile )
				{
					delete [] t_pwcFile;
					t_pwcFile = NULL;
				}

				bContinue = FALSE;
			}
		}

		if ( bContinue )
		{
			CNtDllApi *pNtDllApi = NULL;
			pNtDllApi = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);

			if ( pNtDllApi != NULL )
			{
				HANDLE hFileHandle = 0L;

				UNICODE_STRING ustrNtFileName = { 0 };

				OBJECT_ATTRIBUTES oaAttributes;
				IO_STATUS_BLOCK IoStatusBlock;

				try
				{
					ustrNtFileName.Length			= ( lstrlenW ( t_pwcFile ) + 1 ) * sizeof(WCHAR);
					ustrNtFileName.MaximumLength	= ustrNtFileName.Length;
					ustrNtFileName.Buffer			= t_pwcFile;

					InitializeObjectAttributes	(	&oaAttributes,
													&ustrNtFileName,
													OBJ_CASE_INSENSITIVE,
													NULL,
													NULL
												);

					NTSTATUS ntstat = -1L;
					ntstat = pNtDllApi->NtOpenFile	(	&hFileHandle,
														GENERIC_READ,
														&oaAttributes,
														&IoStatusBlock,
														FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
														0
													);

					if ( NT_SUCCESS ( ntstat ) || ntstat == STATUS_PRIVILEGE_NOT_HELD )
					{
						if ( hFileHandle )
						{
							pNtDllApi->NtClose ( hFileHandle );
							hFileHandle = 0L;
						}

						bResult = TRUE;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtDllApi );
					pNtDllApi = NULL;
				}
				catch ( ... )
				{
					if ( hFileHandle )
					{
						pNtDllApi->NtClose ( hFileHandle );
						hFileHandle = 0L;
					}

					if ( t_pwcFile )
					{
						delete [] t_pwcFile;
						t_pwcFile = NULL;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtDllApi );
					pNtDllApi = NULL;

					throw;
				}
			}

			if ( t_pwcFile )
			{
				delete [] t_pwcFile;
				t_pwcFile = NULL;
			}
		}
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comclassemulator.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_COMClassEmulator.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "Win32_COMClassEmulator.h"
#include <cregcls.h>

Win32_COMClassEmulator MyWin32_COMClassEmulator ( Win32_COM_CLASS_EMULATOR, IDS_CimWin32Namespace );

Win32_COMClassEmulator::Win32_COMClassEmulator
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_COMClassEmulator::~Win32_COMClassEmulator ()
{
}

HRESULT Win32_COMClassEmulator::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance>	ComClassList ;
	CRegistry t_RegInfo ;
	//get all instances of Win32_DCOMApplication
	if (
			t_RegInfo.Open (

				HKEY_LOCAL_MACHINE,
				CHString ( L"SOFTWARE\\Classes\\CLSID" ),
				KEY_READ
				) == ERROR_SUCCESS
			&&

			SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery ( L"SELECT ComponentId, TreatAsClsid FROM Win32_ClassicCOMClassSetting "
                                                                 L"WHERE TreatAsClsid <> NULL and TreatAsClsid <> \"\"",
		&ComClassList, pMethodContext, GetNamespace()) ) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		CInstancePtr	pComClassInstance ;

		if ( ComClassList.BeginEnum( pos ) )
		{
			pComClassInstance.Attach ( ComClassList.GetNext( pos ) ) ;
			while ( pComClassInstance != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString chsComponentPath ;
				pComClassInstance->GetCHString ( IDS_ComponentId, chsComponentPath ) ;

				//get the TreatAsClsid of the Win32_ClassicCOMClass
				CHString chsTreatAs ;
				pComClassInstance->GetCHString ( IDS_TreatAsClsid, chsTreatAs ) ;
				CRegistry t_RegClsidInfo ;
				//check if the TreatAs entry is present
				if ( t_RegClsidInfo.Open ( t_RegInfo.GethKey() , chsTreatAs, KEY_READ ) == ERROR_SUCCESS )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
					if ( pInstance != NULL )
					{
						CHString chsFullPath ;
						chsFullPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
											(LPCWSTR)GetLocalComputerName(),
											IDS_CimWin32Namespace,
											L"Win32_ClassicCOMClass",
											IDS_ComponentId,
											(LPCWSTR)chsComponentPath );
						pInstance->SetCHString ( IDS_OldVersion, chsFullPath ) ;

						chsFullPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
											(LPCWSTR)GetLocalComputerName(),
											IDS_CimWin32Namespace,
											L"Win32_ClassicCOMClass",
											IDS_ComponentId,
											(LPCWSTR)chsTreatAs );
						pInstance->SetCHString ( IDS_NewVersion, chsFullPath ) ;
						hr = pInstance->Commit () ;
						if ( SUCCEEDED ( hr ) )
						{
						}
						else
						{
							break ;
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}

				pComClassInstance.Attach ( ComClassList.GetNext( pos ) ) ;
			}
			ComClassList.EndEnum () ;
		}
	}

	return hr ;
}

HRESULT Win32_COMClassEmulator::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chsClsid, chsEmulator ;
    CInstancePtr pClassicCOMClass , pEmulatorInstance ;
    pInstance->GetCHString ( IDS_OldVersion, chsClsid );
	pInstance->GetCHString ( IDS_NewVersion, chsEmulator );
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsClsid, &pClassicCOMClass, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsEmulator, &pEmulatorInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
        CRegistry t_RegInfo, t_TmpReg ;
		CHString chsTreatAs, chsTmp ;
		pEmulatorInstance->GetCHString ( IDS_ComponentId, chsTreatAs ) ;
		pClassicCOMClass->GetCHString ( IDS_ComponentId, chsTmp ) ;

		if (	!chsTreatAs.IsEmpty () &&

				t_RegInfo.Open (

				HKEY_LOCAL_MACHINE,
				CHString ( L"SOFTWARE\\Classes\\CLSID\\" ) + chsTmp,
				KEY_READ
				) == ERROR_SUCCESS
			)
		{
			if (	t_TmpReg.Open ( t_RegInfo.GethKey (), L"TreatAs", KEY_READ ) == ERROR_SUCCESS	&&
					t_TmpReg.GetCurrentKeyValue( NULL, chsTmp ) == ERROR_SUCCESS					&&
					!chsTreatAs.CompareNoCase ( chsTmp )
				)
			{
				hr = WBEM_S_NO_ERROR ;
			}
			else
			{
				hr  = WBEM_E_NOT_FOUND ;
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comclassautoemulator.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_COMClassAutoEmulator.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "Win32_COMClassAutoEmulator.h"
#include <cregcls.h>

Win32_COMClassAutoEmulator MyWin32_COMClassAutoEmulator ( Win32_COM_CLASS_AUTO_EMULATOR, IDS_CimWin32Namespace );

Win32_COMClassAutoEmulator::Win32_COMClassAutoEmulator
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_COMClassAutoEmulator::~Win32_COMClassAutoEmulator ()
{
}

HRESULT Win32_COMClassAutoEmulator::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance>	ComClassList ;
	CRegistry t_RegInfo ;
	//get all instances of Win32_DCOMApplication
//	if ( SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances ( _T("Win32_ClassicCOMClass"),
//		&ComClassList, pMethodContext, IDS_CimWin32Namespace ) ) )

	if (
			t_RegInfo.Open (

			HKEY_LOCAL_MACHINE,
			CHString ( L"SOFTWARE\\Classes\\CLSID" ),
			KEY_READ
			) == ERROR_SUCCESS

			&&

			SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery ( L"SELECT ComponentId, AutoTreatAsClsid  FROM Win32_ClassicCOMClassSetting WHERE AutoTreatAsClsid <> NULL and AutoTreatAsClsid <> \"\"",
			&ComClassList, pMethodContext, GetNamespace() ) ) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		CInstancePtr pComClassInstance  ;

		if ( ComClassList.BeginEnum( pos ) )
		{
			pComClassInstance.Attach ( ComClassList.GetNext( pos ) ) ;
			while ( pComClassInstance  != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString chsComponentPath ;
				pComClassInstance->GetCHString ( IDS_ComponentId, chsComponentPath ) ;

				//get the AutoTreatAsClsid of the Win32_ClassicCOMClass
				CHString chsAutoTreatAs ;
				pComClassInstance->GetCHString ( IDS_AutoTreatAsClsid, chsAutoTreatAs ) ;
				CRegistry t_RegClsidInfo ;
				//check if the AutoTreatAs entry is present
				if ( t_RegClsidInfo.Open ( t_RegInfo.GethKey() , chsAutoTreatAs, KEY_READ ) == ERROR_SUCCESS )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
					if ( pInstance )
					{
						CHString chsFullPath ;
						chsFullPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
											(LPCWSTR)GetLocalComputerName(),
											IDS_CimWin32Namespace,
											L"Win32_ClassicCOMClass",
											IDS_ComponentId,
											(LPCWSTR)chsComponentPath );
						pInstance->SetCHString ( IDS_OldVersion, chsFullPath ) ;

						chsFullPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
											(LPCWSTR)GetLocalComputerName(),
											IDS_CimWin32Namespace,
											L"Win32_ClassicCOMClass",
											IDS_ComponentId,
											(LPCWSTR)chsAutoTreatAs );
						pInstance->SetCHString ( IDS_NewVersion, chsFullPath ) ;
						hr = pInstance->Commit () ;
						if ( SUCCEEDED ( hr ) )
						{
						}
						else
						{
							break ;
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}

				pComClassInstance.Attach ( ComClassList.GetNext( pos ) ) ;
			}
			ComClassList.EndEnum () ;
		}
	}

	return hr ;
}

HRESULT Win32_COMClassAutoEmulator::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chsClsid, chsAutoEmulator ;
    CInstancePtr pClassicCOMClass , pAutoEmulatorInstance  ;
    pInstance->GetCHString ( IDS_OldVersion, chsClsid );
	pInstance->GetCHString ( IDS_NewVersion, chsAutoEmulator );
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsClsid, &pClassicCOMClass, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsAutoEmulator, &pAutoEmulatorInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
        CRegistry t_RegInfo, t_TmpReg ;
        CHString chsAutoTreatAs, chsTmp ;
		pAutoEmulatorInstance->GetCHString ( IDS_ComponentId, chsAutoTreatAs ) ;
		pClassicCOMClass->GetCHString ( IDS_ComponentId, chsTmp ) ;

		if (	!chsAutoTreatAs.IsEmpty () &&

				t_RegInfo.Open (

				HKEY_LOCAL_MACHINE,
				CHString ( L"SOFTWARE\\Classes\\CLSID\\" ) + chsTmp,
				KEY_READ
				) == ERROR_SUCCESS
			)
		{
			if (	t_TmpReg.Open ( t_RegInfo.GethKey (), L"AutoTreatAs", KEY_READ ) == ERROR_SUCCESS	&&
					t_TmpReg.GetCurrentKeyValue( NULL, chsTmp ) == ERROR_SUCCESS					&&
					!chsAutoTreatAs.CompareNoCase ( chsTmp )
				)
			{
				hr = WBEM_S_NO_ERROR ;
			}
			else
			{
				hr  = WBEM_E_NOT_FOUND ;
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comclassemulator.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_COMClassEmulator
//
//////////////////////////////////////////////////////

#define  Win32_COM_CLASS_EMULATOR L"Win32_COMClassEmulator"

class Win32_COMClassEmulator : public Provider
{
private:
protected:
public:
	Win32_COMClassEmulator (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_COMClassEmulator ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

private:	
	HRESULT Win32_COMClassEmulator::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_COMClassEmulator::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_componentcategory.h ===
//=================================================================

//

// Win32_ComponentCategory.h -- Registered COM Application property set provider 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

// Property set identification
//============================
#include <comcat.h>

#define PROPSET_NAME_COMPONENT_CATEGORY L"Win32_ComponentCategory"


class Win32_ComponentCategory : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_ComponentCategory(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_ComponentCategory() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags = 0L
	);

	HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

protected:
	
	HRESULT Win32_ComponentCategory :: FillInstanceWithProperites ( 

		CInstance *pInstance, 
		CATEGORYINFO stCatInfo
	) ;

	HRESULT Win32_ComponentCategory :: GetAllOrRequiredCaregory ( 
		
		bool a_bAllCategories , 
		CATID & a_rCatid ,
		CInstance *a_pInstance ,
		MethodContext *a_pMethodContext

	) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplication.h ===
//=================================================================

//

// Win32_DCOMApplication.h -- Registered COM Application property set provider 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_DCOM_APPLICATION L"Win32_DCOMApplication"


class Win32_DCOMApplication : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_DCOMApplication(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_DCOMApplication() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags = 0L
	);

	HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

protected:
	
	HRESULT Win32_DCOMApplication :: FillInstanceWithProperites ( 

		CInstance *pInstance, 
		HKEY hAppIdKey,
		CHString& rchsAppid
	) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplication.cpp ===
//=================================================================

//

// Win32_DCOMApplication.CPP -- Registered AppID Object property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

#include "precomp.h"
#include "Win32_DCOMApplication.h"
#include <cregcls.h>

// Property set declaration
//=========================

Win32_DCOMApplication MyWin32_DCOMApplication(PROPSET_NAME_DCOM_APPLICATION, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplication::Win32_DCOMApplication
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_DCOMApplication :: Win32_DCOMApplication (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplication::~Win32_DCOMApplication
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_DCOMApplication :: ~Win32_DCOMApplication ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplication::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_DCOMApplication :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CHString chsAppid ;
	CRegistry RegInfo ;
	HKEY hAppIdKey = NULL ;

	if ( pInstance->GetCHString ( IDS_AppID, chsAppid ) )
	{
		//check to see that the appid is present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
		if ( RegInfo.Open (
							HKEY_LOCAL_MACHINE,
							CHString ( L"SOFTWARE\\Classes\\AppID\\" ) + chsAppid,
							KEY_READ ) == ERROR_SUCCESS
			)
		{
			if ( RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\AppID", KEY_READ ) == ERROR_SUCCESS )
			{
				HKEY hAppIdKey = RegInfo.GethKey() ;

				hr = FillInstanceWithProperites ( pInstance, hAppIdKey, chsAppid ) ;
			}
			else
			{
				hr = WBEM_E_FAILED ;
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplication::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_DCOMApplication :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CRegistry RegInfo ;
	CHString chsAppid ;
	CInstancePtr pInstance ;

	//Enumerate all the AppID's present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
	if ( RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\AppID",
							KEY_READ ) == ERROR_SUCCESS  &&

			RegInfo.GetCurrentSubKeyCount()
		)
	{
		HKEY hAppIdKey = RegInfo.GethKey() ;

		do
		{
			if ( RegInfo.GetCurrentSubKeyName ( chsAppid ) == ERROR_SUCCESS )
			{
				pInstance.Attach ( CreateNewInstance ( pMethodContext ) ) ;
				if ( pInstance != NULL )
				{

					hr = FillInstanceWithProperites ( pInstance, hAppIdKey, chsAppid ) ;
					if ( SUCCEEDED ( hr ) )
					{
						hr = pInstance->Commit () ;
						if ( SUCCEEDED ( hr ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					//we're out of memory
					hr = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( hr == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					hr = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return hr ;
}


HRESULT Win32_DCOMApplication :: FillInstanceWithProperites (

	CInstance *pInstance,
	HKEY hAppIdKey,
	CHString& rchsAppid
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CRegistry AppidRegInfo ;
	CHString chsTmp ;
	CLSID t_clsid ;

	//NOTE: Executables are registered under the AppID key in a named-value indicating the module name
	//		such as "MYOLDAPP.EXE". This named-value is of type REG_SZ and contains the stringized AppID
	//		associated with the executable. We want to skip these duplicate AppID entries.
	if ( CLSIDFromString( _bstr_t ( rchsAppid ) , &t_clsid ) != NOERROR )
	{
		//found an execuatble, so don't process the entry
		return WBEM_E_NOT_FOUND ;
	}

	//open the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID\{appid} key
	if ( AppidRegInfo.Open ( hAppIdKey, rchsAppid, KEY_READ ) == ERROR_SUCCESS )
	{
		pInstance->SetCHString ( IDS_AppID, rchsAppid ) ;

		if ( AppidRegInfo.GetCurrentKeyValue ( NULL, chsTmp ) == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_Name, chsTmp ) ;
			pInstance->SetCHString ( IDS_Caption, chsTmp ) ;
			pInstance->SetCHString ( IDS_Description, chsTmp ) ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_componentcategory.cpp ===
//=================================================================

//

// Win32_ComponentCategory.CPP -- Registered AppID Object property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

#include "precomp.h"
#include "Win32_ComponentCategory.h"
#include <winnls.h>

// Property set declaration
//=========================

Win32_ComponentCategory MyWin32_ComponentCategory( PROPSET_NAME_COMPONENT_CATEGORY, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ComponentCategory::Win32_ComponentCategory
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_ComponentCategory :: Win32_ComponentCategory (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ComponentCategory::~Win32_ComponentCategory
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_ComponentCategory :: ~Win32_ComponentCategory ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ComponentCategory::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ComponentCategory :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_NOT_FOUND ;
	CHString chsCatid ;

	if ( pInstance->GetCHString ( IDS_CategoryId, chsCatid ) && !chsCatid.IsEmpty () )
	{
		bstr_t bstrtCatId = (LPCWSTR) chsCatid ;
		CATID CatId ;
		hr = CLSIDFromString( bstrtCatId, &CatId ) ;
		if ( SUCCEEDED ( hr ) )
		{
			hr = GetAllOrRequiredCaregory ( false , CatId , pInstance , NULL ) ;
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}
	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ComponentCategory::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ComponentCategory :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	CATID t_DummyCatid ;
	return GetAllOrRequiredCaregory ( true , t_DummyCatid , NULL , pMethodContext ) ;
}


HRESULT Win32_ComponentCategory :: GetAllOrRequiredCaregory
(
	bool a_bAllCategories ,
	CATID & a_rCatid ,
	CInstance *a_pInstance ,
	MethodContext *a_pMethodContext
)
{

	HRESULT hr ;
	if ( a_bAllCategories )
	{
		hr = WBEM_S_NO_ERROR ;
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	ICatInformationPtr pCatInfo ;

	hr = CoCreateInstance(

							CLSID_StdComponentCategoriesMgr,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_ICatInformation,
							(LPVOID*) &pCatInfo );

	if ( SUCCEEDED ( hr ) )
	{
		IEnumCATEGORYINFOPtr pEnumCatInfo ;
		hr  = pCatInfo->EnumCategories (

										GetUserDefaultLCID () ,
										&pEnumCatInfo );

		CATEGORYINFO stCatInfo ;
		ULONG ulFetched ;
		if ( SUCCEEDED ( hr ) )
		{
			bool t_bFound = false ;
			while ( SUCCEEDED ( pEnumCatInfo->Next (
															1,
															&stCatInfo,
															&ulFetched ) ) && ulFetched > 0 )
			{
				if ( ( !a_bAllCategories && IsEqualCLSID ( stCatInfo.catid , a_rCatid ) ) || a_bAllCategories )
				{
					CInstancePtr pInstance ( a_pInstance ) ;
					if ( a_bAllCategories )
					{
						pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
					}

					if ( pInstance != NULL )
					{
						hr = FillInstanceWithProperites ( pInstance, stCatInfo ) ;
						if ( SUCCEEDED ( hr ) )
						{
							hr = pInstance->Commit () ;
							if ( SUCCEEDED ( hr ) )
							{
								t_bFound = true ;
							}
							else
							{
								break ;
							}
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY ;
					}

					//stop EnumInstances only if we're out of memory
					if ( hr == WBEM_E_OUT_OF_MEMORY )
					{
						break ;
					}
					else
					{
						hr = WBEM_S_NO_ERROR ;
					}
					if ( !a_bAllCategories )
					{
						break ;
					}
				}
			}
			if ( !a_bAllCategories && !t_bFound )
			{
				hr = WBEM_E_NOT_FOUND ;
			}
		}
		else
		{
			hr = WBEM_E_FAILED ;
		}
	}
	else
	{
		hr = WBEM_E_FAILED ;
	}
	return hr ;

}

HRESULT Win32_ComponentCategory :: FillInstanceWithProperites (

	CInstance *pInstance,
	CATEGORYINFO stCatInfo
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	LPOLESTR pwcTmp = NULL ;
	hr = StringFromCLSID ( stCatInfo.catid, &pwcTmp ) ;

	if ( hr == E_OUTOFMEMORY )
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	try
	{

		if ( SUCCEEDED ( hr ) )
		{
			CHString chsTmp ( pwcTmp ) ;
			pInstance->SetCHString ( IDS_CategoryId, chsTmp ) ;

			//there might not be a description for the selected locale
			if ( stCatInfo.szDescription != NULL )
			{
				chsTmp = stCatInfo.szDescription ;
				pInstance->SetCHString ( IDS_Name, chsTmp ) ;
				pInstance->SetCHString ( IDS_Caption, chsTmp ) ;
				pInstance->SetCHString ( IDS_Description, chsTmp ) ;
			}
		}

		if ( hr == E_OUTOFMEMORY )
		{
			hr = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	catch ( ... )
	{
		if ( pwcTmp )
		{
			CoTaskMemFree ( pwcTmp ) ;
		}

		throw ;
		return WBEM_E_FAILED; // To get rid of compiler warning
	}

	//NOTE//TODO:: If we're not using the default OLE task memory allocator , get the right IMalloc .
	if ( pwcTmp )
	{
		CoTaskMemFree ( pwcTmp ) ;
	}
	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationaccessallowedsetting.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	Win32_DCOMApplicationAccessAllowedSetting
//
//////////////////////////////////////////////////////
#ifndef __Win32_DCOMApplicationAccessAllowedSetting_H_
#define __Win32_DCOMApplicationAccessAllowedSetting_H_

#define  DCOM_APP_ACCESS_SETTING L"Win32_DCOMApplicationAccessAllowedSetting"

class Win32_DCOMApplicationAccessAllowedSetting : public Provider
{
private:
protected:
public:
	Win32_DCOMApplicationAccessAllowedSetting (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_DCOMApplicationAccessAllowedSetting ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

private:	
	HRESULT Win32_DCOMApplicationAccessAllowedSetting::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_DCOMApplicationAccessAllowedSetting::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
};	

#endif //__Win32_DCOMApplicationAccessAllowedSetting_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationlaunchallowedsetting.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_DCOMApplicationLaunchAllowedSetting
//
//////////////////////////////////////////////////////
#ifndef __Win32_DCOMApplicationLaunchAllowedSetting_H_
#define __Win32_DCOMApplicationLaunchAllowedSetting_H_

#define  DCOM_APP_LAUNCH_ACCESS_SETTING L"Win32_DCOMApplicationLaunchAllowedSetting"

class Win32_DCOMApplicationLaunchAllowedSetting : public Provider
{
private:
protected:
public:
	Win32_DCOMApplicationLaunchAllowedSetting (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_DCOMApplicationLaunchAllowedSetting ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

private:	
	HRESULT Win32_DCOMApplicationLaunchAllowedSetting::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_DCOMApplicationLaunchAllowedSetting::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
	
};	

#endif //__Win32_DCOMApplicationLaunchAllowedSetting_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationaccessallowedsetting.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	CIM_COMObjectAccessSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "COMObjSecRegKey.h"
#include "Win32_DCOMApplicationAccessAllowedSetting.h"

Win32_DCOMApplicationAccessAllowedSetting MyWin32_DCOMApplicationAccessAllowedSetting (
																		DCOM_APP_ACCESS_SETTING,
																		IDS_CimWin32Namespace );

Win32_DCOMApplicationAccessAllowedSetting::Win32_DCOMApplicationAccessAllowedSetting
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_DCOMApplicationAccessAllowedSetting::~Win32_DCOMApplicationAccessAllowedSetting ()
{
}

HRESULT Win32_DCOMApplicationAccessAllowedSetting::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	//open the HKEY_LOCAL\MACHINE\SOFTWARE\Classes\AppID key
	CRegistry TmpReg, AppidRegInfo ;

	if ( AppidRegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\AppID", KEY_READ ) == ERROR_SUCCESS )
	{
		// Collections
		TRefPointerCollection<CInstance>	DcomAppList ;

		// Perform queries
		//================

		//get all instances of Win32_DCOMApplication
//		if ( SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances ( _T("Win32_DCOMApplication"),
//			&DcomAppList, pMethodContext, IDS_CimWin32Namespace ) ) )

		if ( SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery ( L"SELECT AppID FROM Win32_DCOMApplication",
			&DcomAppList, pMethodContext, GetNamespace() ) ) )
		{
			REFPTRCOLLECTION_POSITION	pos;
			CInstancePtr pDcomApplication;

			if ( DcomAppList.BeginEnum( pos ) )
			{
				pDcomApplication.Attach ( DcomAppList.GetNext( pos ) ) ;
				while ( pDcomApplication != NULL )
				{
					CHString chsAppID ;

					//get the Appid of the Win32_DCOMApplication
					pDcomApplication->GetCHString ( IDS_AppID, chsAppID ) ;
					if ( ! chsAppID.IsEmpty() && TmpReg.Open ( AppidRegInfo.GethKey(), chsAppID, KEY_READ )
													== ERROR_SUCCESS
						)
					{
						DWORD dwSize = 0 ;
						if ( TmpReg.GetCurrentBinaryKeyValue( L"AccessPermission", NULL ,&dwSize )
								== ERROR_SUCCESS
							)
						{
							PSECURITY_DESCRIPTOR pSD = ( PSECURITY_DESCRIPTOR ) new BYTE[dwSize] ;
							if ( pSD )
							{
								try
								{
									if ( TmpReg.GetCurrentBinaryKeyValue( L"AccessPermission", ( PBYTE ) pSD ,&dwSize )
											== ERROR_SUCCESS
										)
									{
										hr = CreateInstances ( pDcomApplication, pSD, pMethodContext ) ;
									}
									if ( SUCCEEDED ( hr ) )
									{
									}
									else
									{
										break ;
									}
								}
								catch ( ... )
								{
									if ( pSD )
									{
										delete[] (PBYTE) pSD ;
										pSD = NULL ;
									}

									throw ;
								}

								delete[] (PBYTE) pSD ;
								pSD = NULL ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
						else
						{
							//getit from default
						}
					}
					if ( hr == WBEM_E_OUT_OF_MEMORY )
					{
						break ;
					}

					pDcomApplication.Attach ( DcomAppList.GetNext( pos ) ) ;
				}

				DcomAppList.EndEnum();
			}
		}
	}
    return hr ;
}


HRESULT Win32_DCOMApplicationAccessAllowedSetting::CreateInstances ( CInstance* pDcomApplication, PSECURITY_DESCRIPTOR pSD, MethodContext*  pMethodContext )
{
	HRESULT hr = S_OK ;
#ifdef NTONLY
	CCOMObjectSecurityRegistryKey tp ( pSD ) ;
	CHString chsSid;

	// create relpath for cim_comobject
	CHString chsDcomApplicationPath ;
	CHString chsFullDcomApplicationPath ;
	pDcomApplication->GetCHString( _T( "__RELPATH" ), chsDcomApplicationPath );
	chsFullDcomApplicationPath.Format(_T("\\\\%s\\%s:%s"), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, (LPCTSTR)chsDcomApplicationPath );

	CDACL dacl;
	tp.GetDACL(dacl);

	// walk DACL & create new instance for each ACE....
	ACLPOSITION aclPos;
	// Need merged list...
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
        t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CSid sidTrustee;

	    while ( t_ael.GetNext(aclPos, ACE ) && SUCCEEDED ( hr ) )
	    {
		    ACE.GetSID(sidTrustee);

		    if ( sidTrustee.IsValid() && ACE.IsAllowed () )
		    {
			    CInstancePtr pInstance ( CreateNewInstance( pMethodContext ), false ) ;
			    if ( pInstance != NULL )
			    {
				    pInstance->SetCHString ( IDS_Element, chsFullDcomApplicationPath );
				    chsSid.Format(_T("\\\\%s\\%s:%s.%s=\"%s\""), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
							    _T("Win32_SID"), IDS_SID, (LPCTSTR)sidTrustee.GetSidString() );

				    pInstance->SetCHString ( IDS_Setting, chsSid );
				    hr = pInstance->Commit () ;
				    if ( SUCCEEDED ( hr ) )
				    {
				    }
				    else
				    {
					    break ;
				    }
			    }
			    else
			    {
				    hr = WBEM_E_OUT_OF_MEMORY ;
			    }
		    }
	    }

	    t_ael.EndEnum(aclPos);
    }
#endif

	return hr ;
}



HRESULT Win32_DCOMApplicationAccessAllowedSetting::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
    CRegistry Reg ;
    CHString chsSid, chsApplication ;
    CInstancePtr pSidInstance , pDcomApplicationInstance ;
    pInstance->GetCHString ( IDS_Element, chsApplication );
	pInstance->GetCHString( IDS_Setting, chsSid);
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsApplication, &pDcomApplicationInstance, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsSid, &pSidInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
        CHString chsAppID ;
		pDcomApplicationInstance->GetCHString ( IDS_AppID, chsAppID ) ;

		//if appid is present & configured...
		if ( ! chsAppID.IsEmpty() && Reg.Open ( HKEY_LOCAL_MACHINE,
												CHString ( _T("SOFTWARE\\Classes\\AppID\\")) + chsAppID ,
												KEY_READ
											  ) == ERROR_SUCCESS
			)
		{
			DWORD dwSize = 0 ;
			if ( Reg.GetCurrentBinaryKeyValue( _T("AccessPermission"), NULL ,&dwSize )
					== ERROR_SUCCESS
				)
			{
				PSECURITY_DESCRIPTOR pSD = ( PSECURITY_DESCRIPTOR ) new BYTE[dwSize] ;
				if ( pSD )
				{
					try
					{
						if ( Reg.GetCurrentBinaryKeyValue( _T("AccessPermission"), ( PBYTE ) pSD ,&dwSize )
								== ERROR_SUCCESS
							)
						{
							hr = CheckInstance ( pInstance, pSD ) ;
						}
					}
					catch ( ... )
					{
						if ( pSD )
						{
							delete[] (PBYTE) pSD ;
						}

						throw ;
					}

					delete[] (PBYTE) pSD ;
					pSD = NULL ;
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			else
			{
				//getit from default
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}
#endif

	return hr ;
}


HRESULT Win32_DCOMApplicationAccessAllowedSetting::CheckInstance ( CInstance* pInstance, PSECURITY_DESCRIPTOR pSD )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
	CCOMObjectSecurityRegistryKey tp ( pSD ) ;
	CHString chsSid, chsSettingSid ;
	pInstance->GetCHString(IDS_Setting, chsSettingSid );

	CDACL dacl;
	tp.GetDACL(dacl);

	// walk DACL & create new instance for each ACE....
	ACLPOSITION aclPos;
    // Need merged list...
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
	    t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CSid sidTrustee;

	    while ( t_ael.GetNext(aclPos, ACE ) )
	    {
		    ACE.GetSID(sidTrustee);
		    if ( sidTrustee.IsValid() && ACE.IsAllowed () )
		    {
			    chsSid.Format (_T("\\\\%s\\%s:%s.%s=\"%s\""), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
						     _T("Win32_SID"), IDS_SID, (LPCTSTR)sidTrustee.GetSidString() );

			    //check if the sid is in the dacl for the object
			    if ( ! chsSid.CompareNoCase ( chsSettingSid ) )
			    {
				    hr = WBEM_S_NO_ERROR ;
				    break ;
			    }
		    }
	    }
        t_ael.EndEnum(aclPos);
    }
#endif
	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_implementedcategory.h ===
//////////////////////////////////////////////////////

//	Win32_ImplementedCategory

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//////////////////////////////////////////////////////

#define  Win32_IMPLEMENTED_CATEGORIES L"Win32_ImplementedCategory"

class Win32_ImplementedCategory : public Provider
{
public:
	Win32_ImplementedCategory (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_ImplementedCategory ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationsetting.h ===
//=================================================================

//

// Win32_DCOMApplicationSetting.h -- Registered COM Application property set provider 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_DCOM_APPLICATION_SETTING L"Win32_DCOMApplicationSetting"


class Win32_DCOMApplicationSetting : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_DCOMApplicationSetting(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_DCOMApplicationSetting() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags = 0L
	);

	HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

protected:
	
	HRESULT Win32_DCOMApplicationSetting :: FillInstanceWithProperites ( 

		CInstance *pInstance, 
		HKEY hAppIdKey,
		CHString& rchsAppid
	) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationlaunchallowedsetting.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	CIM_COMObjectAccessSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "COMObjSecRegKey.h"
#include "Win32_DCOMApplicationLaunchAllowedSetting.h"

Win32_DCOMApplicationLaunchAllowedSetting MyWin32_DCOMApplicationLaunchAllowedSetting (
																		DCOM_APP_LAUNCH_ACCESS_SETTING,
																		IDS_CimWin32Namespace );

Win32_DCOMApplicationLaunchAllowedSetting::Win32_DCOMApplicationLaunchAllowedSetting
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_DCOMApplicationLaunchAllowedSetting::~Win32_DCOMApplicationLaunchAllowedSetting ()
{
}

//NOTE: The Security Descriptor obtained from the registry contains owner & group information.
//		But the Sid present as the owner & group can't be mapped to a valid domain/account name and we
//		get a assert because of this.
//		Same behaviour is repro'ed in DCOMCnfg.exe which reports "Account Unknown" as the owner.


HRESULT Win32_DCOMApplicationLaunchAllowedSetting::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
	//open the HKEY_LOCAL\MACHINE\SOFTWARE\Classes\AppID key
	CRegistry TmpReg, AppidRegInfo ;

	if ( AppidRegInfo.Open ( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Classes\\AppID"), KEY_READ ) == ERROR_SUCCESS )
	{
		// Collections
		TRefPointerCollection<CInstance>	DcomAppList ;

		// Perform queries
		//================

		//get all instances of Win32_DCOMApplication
//		if ( SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances ( _T("Win32_DCOMApplication"),
//			&DcomAppList, pMethodContext, IDS_CimWin32Namespace ) ) )

		if ( SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery ( L"SELECT AppID FROM Win32_DCOMApplication",
			&DcomAppList, pMethodContext, GetNamespace() ) ) )
		{
			REFPTRCOLLECTION_POSITION	pos;
			CInstancePtr pDcomApplication ;

			if ( DcomAppList.BeginEnum( pos ) )
			{
				pDcomApplication.Attach ( DcomAppList.GetNext( pos ) ) ;
				while ( pDcomApplication != NULL )
				{
					CHString chsAppID ;

					//get the Appid of the Win32_DCOMApplication
					pDcomApplication->GetCHString ( IDS_AppID, chsAppID ) ;
					if ( ! chsAppID.IsEmpty() && TmpReg.Open ( AppidRegInfo.GethKey(), chsAppID, KEY_READ )
													== ERROR_SUCCESS
						)
					{
						DWORD dwSize = 0 ;
						if ( TmpReg.GetCurrentBinaryKeyValue( _T("LaunchPermission"), NULL ,&dwSize )
								== ERROR_SUCCESS
							)
						{
							PSECURITY_DESCRIPTOR pSD = ( PSECURITY_DESCRIPTOR ) new BYTE[dwSize] ;
							if ( pSD )
							{
								try
								{
									if ( TmpReg.GetCurrentBinaryKeyValue( _T("LaunchPermission"), ( PBYTE ) pSD ,&dwSize )
											== ERROR_SUCCESS
										)
									{
										hr = CreateInstances ( pDcomApplication, pSD, pMethodContext ) ;
									}

									if ( SUCCEEDED ( hr ) )
									{
									}
									else
									{
										break ;
									}
								}
								catch ( ... )
								{
									if ( pSD )
									{
										delete[] (PBYTE) pSD ;
										pSD = NULL ;
									}

									throw ;
								}

								delete[] (PBYTE) pSD ;
								pSD = NULL ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
						else
						{
							//getit from default
						}
					}

					if ( hr == WBEM_E_OUT_OF_MEMORY )
					{
						break ;
					}

					pDcomApplication.Attach ( DcomAppList.GetNext( pos ) ) ;
				}

				DcomAppList.EndEnum();
			}
		}
	}
#endif
    return hr ;
}


HRESULT Win32_DCOMApplicationLaunchAllowedSetting::CreateInstances ( CInstance* pDcomApplication, PSECURITY_DESCRIPTOR pSD, MethodContext*  pMethodContext )
{
	HRESULT hr = S_OK ;
#ifdef NTONLY
	CCOMObjectSecurityRegistryKey tp ( pSD ) ;
	CHString chsSid;

	// create relpath for cim_comobject
	CHString chsDcomApplicationPath ;
	CHString chsFullDcomApplicationPath ;
	pDcomApplication->GetCHString( _T( "__RELPATH" ), chsDcomApplicationPath );
	chsFullDcomApplicationPath.Format(_T("\\\\%s\\%s:%s"), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, (LPCTSTR)chsDcomApplicationPath );

	CDACL dacl;
	tp.GetDACL(dacl);

	// walk DACL & create new instance for each ACE....
	ACLPOSITION aclPos;
    // Need merged list...
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
    	t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CSid sidTrustee;

	    while ( t_ael.GetNext(aclPos, ACE ) && SUCCEEDED ( hr ) )
	    {
		    ACE.GetSID(sidTrustee);

		    if ( sidTrustee.IsValid() && ACE.IsAllowed () )
		    {
			    CInstancePtr pInstance ( CreateNewInstance( pMethodContext ), false ) ;
			    if ( pInstance != NULL )
			    {
				    pInstance->SetCHString ( IDS_Element, chsFullDcomApplicationPath );
				    chsSid.Format(_T("\\\\%s\\%s:%s.%s=\"%s\""), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
							    _T("Win32_SID"), IDS_SID, (LPCTSTR)sidTrustee.GetSidString() );

				    pInstance->SetCHString ( IDS_Setting, chsSid );
				    hr = pInstance->Commit () ;
				    if ( SUCCEEDED ( hr ) )
				    {
				    }
				    else
				    {
					    break ;
				    }
			    }
			    else
			    {
				    hr = WBEM_E_OUT_OF_MEMORY ;
			    }
		    }
	    }
	    t_ael.EndEnum(aclPos);
    }
#endif

	return hr ;
}



HRESULT Win32_DCOMApplicationLaunchAllowedSetting::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CRegistry Reg ;
    CHString chsSid, chsApplication ;
    CInstancePtr pSidInstance , pDcomApplicationInstance ;
    pInstance->GetCHString ( IDS_Element, chsApplication );
	pInstance->GetCHString( IDS_Setting, chsSid);
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsApplication, &pDcomApplicationInstance, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsSid, &pSidInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
        CHString chsAppID ;
		pDcomApplicationInstance->GetCHString ( IDS_AppID, chsAppID ) ;

		//if appid is present & configured...
		if ( ! chsAppID.IsEmpty() && Reg.Open ( HKEY_LOCAL_MACHINE,
												CHString ( L"SOFTWARE\\Classes\\AppID\\") + chsAppID ,
												KEY_READ
											  ) == ERROR_SUCCESS
			)
		{
			DWORD dwSize = 0 ;
			if ( Reg.GetCurrentBinaryKeyValue( L"LaunchPermission", NULL ,&dwSize )
					== ERROR_SUCCESS
				)
			{
				PSECURITY_DESCRIPTOR pSD = ( PSECURITY_DESCRIPTOR ) new BYTE[dwSize] ;
				if ( pSD )
				{
					try
					{
						if ( Reg.GetCurrentBinaryKeyValue( L"LaunchPermission", ( PBYTE ) pSD ,&dwSize )
								== ERROR_SUCCESS
							)
						{
							hr = CheckInstance ( pInstance, pSD ) ;
						}

					}
					catch ( ... )
					{
						if ( pSD )
						{
							delete[] (PBYTE) pSD ;
							pSD = NULL ;
						}

						throw ;
					}

					delete[] (PBYTE) pSD ;
					pSD = NULL ;
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			else
			{
				//getit from default
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}


HRESULT Win32_DCOMApplicationLaunchAllowedSetting::CheckInstance ( CInstance* pInstance, PSECURITY_DESCRIPTOR pSD )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
	CCOMObjectSecurityRegistryKey tp ( pSD ) ;
	CHString chsSid, chsSettingSid ;
	pInstance->GetCHString(IDS_Setting, chsSettingSid );

	CDACL dacl;
	tp.GetDACL(dacl);

	// walk DACL & create new instance for each ACE....
	ACLPOSITION aclPos;
    // Need merged list...
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
	    t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CSid sidTrustee;

	    while ( t_ael.GetNext(aclPos, ACE ) )
	    {
		    ACE.GetSID(sidTrustee);
		    if ( sidTrustee.IsValid() && ACE.IsAllowed () )
		    {
			    chsSid.Format (_T("\\\\%s\\%s:%s.%s=\"%s\""), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
						     _T("Win32_SID"), IDS_SID, (LPCTSTR)sidTrustee.GetSidString() );

			    //check if the sid is in the dacl for the object
			    if ( ! chsSid.CompareNoCase ( chsSettingSid ) )
			    {
				    hr = WBEM_S_NO_ERROR ;
				    break ;
			    }
		    }
	    }
        t_ael.EndEnum(aclPos);
    }
#endif
	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationsetting.cpp ===
//=================================================================

//

// Win32_DCOMApplicationSetting.CPP -- Registered AppID Object property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

#include "precomp.h"
#include "Win32_DCOMApplicationSetting.h"
#include <cregcls.h>

// Property set declaration
//=========================

Win32_DCOMApplicationSetting MyWin32_DCOMApplicationSetting(PROPSET_NAME_DCOM_APPLICATION_SETTING, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplicationSetting::Win32_DCOMApplicationSetting
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_DCOMApplicationSetting :: Win32_DCOMApplicationSetting (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplicationSetting::~Win32_DCOMApplicationSetting
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_DCOMApplicationSetting :: ~Win32_DCOMApplicationSetting ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplicationSetting::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_DCOMApplicationSetting :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CHString chsAppid ;
	CRegistry RegInfo ;
	HKEY hAppIdKey = NULL ;

	if ( pInstance->GetCHString ( IDS_AppID, chsAppid ) )
	{
		//check to see that the appid is present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
		if ( RegInfo.Open (
							HKEY_LOCAL_MACHINE,
							CHString ( L"SOFTWARE\\Classes\\AppID\\" ) + chsAppid,
							KEY_READ ) == ERROR_SUCCESS
			)
		{
			if ( RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\AppID", KEY_READ ) == ERROR_SUCCESS )
			{
				HKEY hAppIdKey = RegInfo.GethKey() ;

				hr = FillInstanceWithProperites ( pInstance, hAppIdKey, chsAppid ) ;
			}
			else
			{
				hr = WBEM_E_FAILED ;
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplicationSetting::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_DCOMApplicationSetting :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CRegistry RegInfo ;
	CHString chsAppid ;
	CInstancePtr pInstance ;

	//Enumerate all the AppID's present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
	if ( RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\AppID",
							KEY_READ ) == ERROR_SUCCESS  &&

			RegInfo.GetCurrentSubKeyCount()
		)
	{
		HKEY hAppIdKey = RegInfo.GethKey() ;

		do
		{
			if ( RegInfo.GetCurrentSubKeyName ( chsAppid ) == ERROR_SUCCESS )
			{
				pInstance.Attach ( CreateNewInstance ( pMethodContext ) ) ;
				if ( pInstance != NULL )
				{

					hr = FillInstanceWithProperites ( pInstance, hAppIdKey, chsAppid ) ;
					if ( SUCCEEDED ( hr ) )
					{
						hr = pInstance->Commit () ;
						if ( SUCCEEDED ( hr ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					//we're out of memory
					hr = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( hr == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					hr = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return hr ;
}


HRESULT Win32_DCOMApplicationSetting :: FillInstanceWithProperites (

	CInstance *pInstance,
	HKEY hAppIdKey,
	CHString& rchsAppid
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CRegistry AppidRegInfo ;
	CHString chsTmp ;
	CLSID t_clsid ;
	//NOTE: Executables are registered under the AppID key in a named-value indicating the module name
	//		such as "MYOLDAPP.EXE". This named-value is of type REG_SZ and contains the stringized AppID
	//		associated with the executable. We want to skip these duplicate AppID entries.
	if ( CLSIDFromString( _bstr_t ( rchsAppid ) , &t_clsid ) != NOERROR )
	{
		//found an execuatble, so don't process the entry
		return WBEM_E_NOT_FOUND ;
	}

	//open the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID\{appid} key
	if ( AppidRegInfo.Open ( hAppIdKey, rchsAppid, KEY_READ ) == ERROR_SUCCESS )
	{
		pInstance->SetCHString ( IDS_AppID, rchsAppid ) ;

		//see if other DCOM configuration settings are present
		if ( AppidRegInfo.GetCurrentKeyValue ( NULL, chsTmp ) == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_Caption, chsTmp ) ;
			pInstance->SetCHString ( IDS_Description, chsTmp ) ;
		}

		//check if the DllSurrogate value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"DllSurrogate", chsTmp )  == ERROR_SUCCESS )
		{
			pInstance->Setbool ( IDS_UseSurrogate, true ) ;

			//if the DllSurrogate value contains data , then custom surrogate is used
			if(! chsTmp.IsEmpty() )
			{
				pInstance->SetCHString ( IDS_CustomSurrogate, chsTmp ) ;
			}
		}
		else
		{
			pInstance->Setbool ( IDS_UseSurrogate, false ) ;
		}

		//check if the RemoteServerName value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"RemoteServerName", chsTmp )  == ERROR_SUCCESS &&
			 ! chsTmp.IsEmpty() )
		{
			pInstance->SetCHString ( IDS_RemoteServerName, chsTmp ) ;
		}

		//check if the RunAs value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"RunAs", chsTmp )  == ERROR_SUCCESS &&
			 ! chsTmp.IsEmpty() )
		{
			pInstance->SetCHString ( IDS_RunAsUser, chsTmp ) ;
		}

		//check if ActivateAtStorage value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"ActivateAtStorage", chsTmp )  == ERROR_SUCCESS )
		{
			if ( (! chsTmp.IsEmpty() ) && !chsTmp.CompareNoCase ( L"Y" ) )
			{
				pInstance->Setbool ( IDS_EnableAtStorageActivation, true ) ;
			}
			else
			{
				pInstance->Setbool ( IDS_EnableAtStorageActivation, false ) ;
			}
		}
		else
		{
			pInstance->Setbool ( IDS_EnableAtStorageActivation, false ) ;
		}

		//check if the AuthenticationLevel value is present
		DWORD dwAuthenticationLevel ;
		if ( AppidRegInfo.GetCurrentKeyValue( L"AuthenticationLevel", dwAuthenticationLevel )  == ERROR_SUCCESS )
		{
			pInstance->SetDWORD ( IDS_AuthenticationLevel, dwAuthenticationLevel ) ;
		}

		//check if the LocalService value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"LocalService", chsTmp )  == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_LocalService, chsTmp ) ;
		}

		//check if the ServiceParameters value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"ServiceParameters", chsTmp )  == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_ServiceParameters, chsTmp ) ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\win32_implementedcategory.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	CIM_COMObjectAccessSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "Win32_ImplementedCategory.h"
#include <comcat.h>


Win32_ImplementedCategory MyWin32_ImplementedCategory (
														Win32_IMPLEMENTED_CATEGORIES,
														IDS_CimWin32Namespace );

Win32_ImplementedCategory::Win32_ImplementedCategory
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_ImplementedCategory::~Win32_ImplementedCategory ()
{
}

HRESULT Win32_ImplementedCategory::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	// Collections
	TRefPointerCollection<CInstance>	CatIdList ;

	//get all instances of Category-id's present
	if ( SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances ( L"Win32_ComponentCategory",
		&CatIdList, pMethodContext, IDS_CimWin32Namespace ) ) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		CInstancePtr pCatIdInstance;
		ICatInformationPtr pCatInfo = NULL ;
		hr = CoCreateInstance(
								CLSID_StdComponentCategoriesMgr,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_ICatInformation,
								(LPVOID*) &pCatInfo );
		if ( SUCCEEDED ( hr ) )
		{
			if ( CatIdList.BeginEnum( pos ) )
			{
				pCatIdInstance.Attach ( CatIdList.GetNext( pos ) ) ;
				while ( pCatIdInstance != NULL )
				{
					CHString chsCatid ;

					//get the Catid from the instance
					pCatIdInstance->GetCHString ( IDS_CategoryId, chsCatid ) ;
					bstr_t bstrtCatId = chsCatid ;
					CATID CatId ;
					hr = CLSIDFromString( bstrtCatId, &CatId ) ;

					//check if we got a valid cat-id
					if ( SUCCEEDED ( hr ) )
					{
						IEnumGUIDPtr pEnumCLSID ;
						hr = pCatInfo->EnumClassesOfCategories( 1,
																&CatId,
																((ULONG) -1),
																NULL,
																&pEnumCLSID ) ;
						//Got the Clsid enumerator....
						if ( SUCCEEDED ( hr ) )
						{
							CLSID clsid ;
							ULONG ulFetched ;
							CHString chsRef1,chsCatRef ;
							pCatIdInstance->GetCHString( L"__RELPATH", chsRef1 );
							chsCatRef.Format(L"\\\\%s\\%s:%s", (LPCWSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
															(LPCWSTR)chsRef1 );
							//get all the clsid's which support this category...
							while ( SUCCEEDED ( pEnumCLSID->Next ( 1, &clsid, &ulFetched ) ) &&
									ulFetched > 0 )
							{
								PWCHAR pwcTmp = NULL ;
								hr = StringFromCLSID ( clsid, &pwcTmp ) ;

								if ( hr == E_OUTOFMEMORY )
								{
									throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
								}

								try
								{
									//see if it's a valid clsid
									if ( SUCCEEDED ( hr ) )
									{
										CHString chsTmp ( pwcTmp ) ;
										CoTaskMemFree ( pwcTmp ) ;
										pwcTmp = NULL ;

										CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
										if ( pInstance != NULL )
										{
											//set the 2 reference properties
											pInstance->SetCHString ( IDS_Category, chsCatRef ) ;
											CHString chsComponentPath ;
											chsComponentPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
																	(LPCWSTR)GetLocalComputerName(),
																	IDS_CimWin32Namespace,
																	L"Win32_ClassicCOMClass",
																	IDS_ComponentId,
																	(LPCWSTR) chsTmp );

											pInstance->SetCHString ( IDS_Component, chsComponentPath ) ;
											hr = pInstance->Commit () ;

											if ( SUCCEEDED ( hr ) )
											{
											}
											else
											{
												break ;
											}
										}
										else
										{
											hr = WBEM_E_OUT_OF_MEMORY ;
										}

										if ( hr == WBEM_E_OUT_OF_MEMORY )
										{
											break ;
										}
									}
								}
								catch ( ... )
								{
									if ( pwcTmp )
									{
										CoTaskMemFree ( pwcTmp ) ;
										pwcTmp = NULL ;
									}

									throw ;
								}

								if ( pwcTmp )
								{
									CoTaskMemFree ( pwcTmp ) ;
									pwcTmp = NULL ;
								}
							}
						}
					}

					pCatIdInstance.Attach ( CatIdList.GetNext( pos ) ) ;
				}
				CatIdList.EndEnum() ;
			}
		}
	}
	return hr ;
}


HRESULT Win32_ImplementedCategory::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CInstancePtr pComponentInstance, pCategoryInstance ;
    CHString chsComponent, chsCategory ;
	pInstance->GetCHString ( IDS_Component, chsComponent );
	pInstance->GetCHString ( IDS_Category, chsCategory );
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsCategory, &pCategoryInstance, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsComponent, &pComponentInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
		ICatInformationPtr pCatInfo = NULL ;
		CHString chsComponentId, chsCategoryId ;
		pComponentInstance->GetCHString ( IDS_ComponentId, chsComponentId ) ;
		pCategoryInstance->GetCHString ( IDS_CategoryId, chsCategoryId ) ;
		bstr_t bstrtClsId = chsComponentId ;
		bstr_t t_bstrtCatId = chsCategoryId ;
		CLSID ClsId ;
		hr = CLSIDFromString ( bstrtClsId, &ClsId ) ;
		CLSID t_CatId ;
		if ( SUCCEEDED ( hr ) )
		{
			hr = CLSIDFromString ( t_bstrtCatId, &t_CatId ) ;
		}

		if ( SUCCEEDED ( hr ) )
		{
			hr = CoCreateInstance (
									CLSID_StdComponentCategoriesMgr,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_ICatInformation,
									(LPVOID*) &pCatInfo );
			if ( SUCCEEDED ( hr ) )
			{

				hr = pCatInfo->IsClassOfCategories (

												ClsId,
												1 ,
												&t_CatId,
												((ULONG) -1),    //Number of category IDs in the rgcatidReq
												NULL
											) ;
				if ( hr == S_OK )
				{
					hr = WBEM_S_NO_ERROR ;
				}
				else
				{
					hr = WBEM_E_NOT_FOUND ;
				}
			}
			else
			{
				hr = WBEM_E_FAILED ;
			}
		}
		else
		{
			hr = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}
	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\wnaspi32.h ===
/****************************************************************************

*                                                                           *

* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *

* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *

* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *

* PURPOSE.                                                                  *

*                                                                           *

* Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved *
*                                                                           *
****************************************************************************/

//***************************************************************************
//
// Name: 	      WNASPI32.H
//
// Description:	ASPI for Win32 definitions ('C' Language)
//
//***************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

typedef void *LPSRB;
typedef void (*PFNPOST)();

DWORD SendASPI32Command    (LPSRB);
DWORD GetASPI32SupportInfo (VOID);

#define SENSE_LEN					14			// Default sense buffer length
#define SRB_DIR_SCSI				0x00		// Direction determined by SCSI 															// command
#define SRB_DIR_IN					0x08		// Transfer from SCSI target to 															// host
#define SRB_DIR_OUT					0x10		// Transfer from host to SCSI 															// target
#define SRB_POSTING					0x01		// Enable ASPI posting
#define SRB_EVENT_NOTIFY            0x40        // Enable ASPI event notification
#define SRB_ENABLE_RESIDUAL_COUNT	0x04		// Enable residual byte count 															// reporting
#define SRB_DATA_SG_LIST			0x02		// Data buffer points to 																	// scatter-gather list
#define WM_ASPIPOST					0x4D42		// ASPI Post message
//***************************************************************************
//						 %%% ASPI Command Definitions %%%
//***************************************************************************
#define SC_HA_INQUIRY				0x00		// Host adapter inquiry
#define SC_GET_DEV_TYPE				0x01		// Get device type
#define SC_EXEC_SCSI_CMD			0x02		// Execute SCSI command
#define SC_ABORT_SRB				0x03		// Abort an SRB
#define SC_RESET_DEV				0x04		// SCSI bus device reset
#define SC_GET_DISK_INFO			0x06		// Get Disk information

//***************************************************************************
//								  %%% SRB Status %%%
//***************************************************************************
#define SS_PENDING			0x00		// SRB being processed
#define SS_COMP				0x01		// SRB completed without error
#define SS_ABORTED			0x02		// SRB aborted
#define SS_ABORT_FAIL		0x03		// Unable to abort SRB
#define SS_ERR 				0x04		// SRB completed with error

#define SS_INVALID_CMD		0x80		// Invalid ASPI command
#define SS_INVALID_HA		0x81		// Invalid host adapter number
#define SS_NO_DEVICE		0x82		// SCSI device not installed
							
#define SS_INVALID_SRB		0xE0		// Invalid parameter set in SRB
#define SS_FAILED_INIT		0xE4		// ASPI for windows failed init
#define SS_ASPI_IS_BUSY		0xE5		// No resources available to execute cmd
#define SS_BUFFER_TO_BIG	0xE6		// Buffer size to big to handle!

//***************************************************************************
//							%%% Host Adapter Status %%%
//***************************************************************************
#define HASTAT_OK					0x00	// Host adapter did not detect an 															// error
#define HASTAT_SEL_TO				0x11	// Selection Timeout
#define HASTAT_DO_DU				0x12	// Data overrun data underrun
#define HASTAT_BUS_FREE				0x13	// Unexpected bus free
#define HASTAT_PHASE_ERR			0x14	// Target bus phase sequence 																// failure
#define HASTAT_TIMEOUT				0x09	// Timed out while SRB was 																	waiting to beprocessed.
#define HASTAT_COMMAND_TIMEOUT 		0x0B	// While processing the SRB, the
															// adapter timed out.
#define HASTAT_MESSAGE_REJECT		0x0D	// While processing SRB, the 																// adapter received a MESSAGE 															// REJECT.
#define HASTAT_BUS_RESET			0x0E	// A bus reset was detected.
#define HASTAT_PARITY_ERROR			0x0F	// A parity error was detected.
#define HASTAT_REQUEST_SENSE_FAILED	0x10	// The adapter failed in issuing
														//   REQUEST SENSE.

//***************************************************************************
//			 %%% SRB - HOST ADAPTER INQUIRY - SC_HA_INQUIRY %%%
//***************************************************************************
typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_HA_INQUIRY
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved, MUST = 0
	BYTE	HA_Count;				// Number of host adapters present
	BYTE	HA_SCSI_ID;				// SCSI ID of host adapter
	BYTE	HA_ManagerId[16];		// String describing the manager
	BYTE	HA_Identifier[16];		// String describing the host adapter
	BYTE	HA_Unique[16];			// Host Adapter Unique parameters
	WORD	HA_Rsvd1;

} SRB_HAInquiry, *PSRB_HAInquiry;

//***************************************************************************
//			  %%% SRB - GET DEVICE TYPE - SC_GET_DEV_TYPE %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_GET_DEV_TYPE
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE	SRB_DeviceType;			// Target's peripheral device type
	BYTE	SRB_Rsvd1;

} SRB_GDEVBlock, *PSRB_GDEVBlock;

//***************************************************************************
//		  %%% SRB - EXECUTE SCSI COMMAND - SC_EXEC_SCSI_CMD %%%
//***************************************************************************

typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	WORD 	SRB_Rsvd1;				// Reserved for Alignment
	DWORD	SRB_BufLen;				// Data Allocation Length
	BYTE	*SRB_BufPointer;		// Data Buffer Pointer
	BYTE	SRB_SenseLen;			// Sense Allocation Length 	
	BYTE	SRB_CDBLen;				// CDB Length
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved for alignment
	BYTE	CDBByte[16];			// SCSI CDB
	BYTE	SenseArea[SENSE_LEN+2];	// Request Sense buffer

} SRB_ExecSCSICmd, *PSRB_ExecSCSICmd;

//***************************************************************************
//				  %%% SRB - ABORT AN SRB - SC_ABORT_SRB %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	void	*SRB_ToAbort;			// Pointer to SRB to abort

} SRB_Abort, *PSRB_Abort;

//***************************************************************************
//				%%% SRB - BUS DEVICE RESET - SC_RESET_DEV %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_Rsvd1[12];			// Reserved for Alignment
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void 	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved
	BYTE	CDBByte[16];			// SCSI CDB

} SRB_BusDeviceReset, *PSRB_BusDeviceReset;

//***************************************************************************
//				%%% SRB - GET DISK INFORMATION - SC_GET_DISK_INFO %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_DriveFlags;			// Driver flags
	BYTE	SRB_Int13HDriveInfo;	// Host Adapter Status
	BYTE	SRB_Heads;				// Preferred number of heads translation
	BYTE	SRB_Sectors;			// Preferred number of sectors translation
	BYTE	SRB_Rsvd1[10];			// Reserved
} SRB_GetDiskInfo, *PSRB_GetDiskInfo;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\w2k\serialport.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  w2k\serialport.cpp
//
//  Purpose: serialport property set provider
//
//***************************************************************************

#include "precomp.h"

#include <winbase.h>
#include <winioctl.h>
#include <ntddscsi.h>

#include <FRQueryEx.h>
#include <devguid.h>
#include <cregcls.h>

#include "..\WDMBase.h"
#include "..\serialport.h"


#include <comdef.h>


// Property set declaration
//=========================

CWin32SerialPort win32SerialPort(PROPSET_NAME_SERPORT, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::CWin32SerialPort
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SerialPort::CWin32SerialPort(
	LPCWSTR pszName,
	LPCWSTR pszNamespace) :
    Provider(pszName, pszNamespace)
{
    // Identify the platform right away
    //=================================

	// property set names for query optimization
	m_ptrProperties.SetSize(e_End_Property_Marker);

	// Win32_SerialPort
	m_ptrProperties[e_Binary]					=(LPVOID) IDS_Binary;
	m_ptrProperties[e_MaximumInputBufferSize]	=(LPVOID) IDS_MaximumInputBufferSize;
	m_ptrProperties[e_MaximumOutputBufferSize]	=(LPVOID) IDS_MaximumOutputBufferSize;
	m_ptrProperties[e_ProviderType]				=(LPVOID) IDS_ProviderType;
	m_ptrProperties[e_SettableBaudRate]			=(LPVOID) IDS_SettableBaudRate;
	m_ptrProperties[e_SettableDataBits]			=(LPVOID) IDS_SettableDataBits;
	m_ptrProperties[e_SettableFlowControl]		=(LPVOID) IDS_SettableFlowControl;
	m_ptrProperties[e_SettableParity]			=(LPVOID) IDS_SettableParity;
	m_ptrProperties[e_SettableParityCheck]		=(LPVOID) IDS_SettableParityCheck;
	m_ptrProperties[e_SettableRLSD]				=(LPVOID) IDS_SettableRLSD;
	m_ptrProperties[e_SettableStopBits]			=(LPVOID) IDS_SettableStopBits;
	m_ptrProperties[e_Supports16BitMode]		=(LPVOID) IDS_Supports16BitMode;
	m_ptrProperties[e_SupportsDTRDSR]			=(LPVOID) IDS_SupportsDTRDSR;
	m_ptrProperties[e_SupportsElapsedTimeouts]	=(LPVOID) IDS_SupportsElapsedTimeouts;
	m_ptrProperties[e_SupportsIntTimeouts]		=(LPVOID) IDS_SupportsIntervalTimeouts;
	m_ptrProperties[e_SupportsParityCheck]		=(LPVOID) IDS_SupportsParityCheck;
	m_ptrProperties[e_SupportsRLSD]				=(LPVOID) IDS_SupportsRLSD;
	m_ptrProperties[e_SupportsRTSCTS]			=(LPVOID) IDS_SupportsRTSCTS;
	m_ptrProperties[e_SupportsSpecialCharacters]=(LPVOID) IDS_SupportsSpecialChars;
	m_ptrProperties[e_SupportsXOnXOff]			=(LPVOID) IDS_SupportsXOnXOff;
	m_ptrProperties[e_SupportsXOnXOffSet]		=(LPVOID) IDS_SupportsSettableXOnXOff;
	m_ptrProperties[e_OSAutoDiscovered]			=(LPVOID) IDS_OSAutoDiscovered;

	// CIM_SerialController
	m_ptrProperties[e_MaxBaudRate]				=(LPVOID) IDS_MaximumBaudRate;

	// CIM_Controller
	m_ptrProperties[e_MaxNumberControlled]		=(LPVOID) IDS_MaxNumberControlled;
	m_ptrProperties[e_ProtocolSupported]		=(LPVOID) IDS_ProtocolSupported;
	m_ptrProperties[e_TimeOfLastReset]			=(LPVOID) IDS_TimeOfLastReset;

	// CIM_LogicalDevice
	m_ptrProperties[e_Availability]				=(LPVOID) IDS_Availability;
	m_ptrProperties[e_CreationClassName]		=(LPVOID) IDS_CreationClassName;
	m_ptrProperties[e_ConfigManagerErrorCode]	=(LPVOID) IDS_ConfigManagerErrorCode;
	m_ptrProperties[e_ConfigManagerUserConfig]	=(LPVOID) IDS_ConfigManagerUserConfig;
	m_ptrProperties[e_DeviceID]					=(LPVOID) IDS_DeviceID;
	m_ptrProperties[e_PNPDeviceID]				=(LPVOID) IDS_PNPDeviceID;
	m_ptrProperties[e_PowerManagementCapabilities] =(LPVOID) IDS_PowerManagementCapabilities;
	m_ptrProperties[e_PowerManagementSupported] =(LPVOID) IDS_PowerManagementSupported;
	m_ptrProperties[e_StatusInfo]				=(LPVOID) IDS_StatusInfo;
	m_ptrProperties[e_SystemCreationClassName]	=(LPVOID) IDS_SystemCreationClassName;
	m_ptrProperties[e_SystemName]				=(LPVOID) IDS_SystemName;

	// CIM_ManagedSystemElement
	m_ptrProperties[e_Caption]					=(LPVOID) IDS_Caption;
	m_ptrProperties[e_Description]				=(LPVOID) IDS_Description;
	m_ptrProperties[e_InstallDate]				=(LPVOID) IDS_InstallDate;
	m_ptrProperties[e_Name]						=(LPVOID) IDS_Name;
	m_ptrProperties[e_Status]					=(LPVOID) IDS_Status;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::~CWin32SerialPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SerialPort::~CWin32SerialPort()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32SerialPort::GetObject
//
//  Inputs:     CInstance*      pInst - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SerialPort::GetObject(CInstance *pInst, long lFlags, CFrameworkQuery &Query)
{
    BYTE bBits[e_End_Property_Marker/8 + 1];

	CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&Query);

	pQuery2->GetPropertyBitMask(m_ptrProperties, &bBits);

    return Enumerate(NULL, pInst, lFlags, bBits);
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32SerialPort::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SerialPort::EnumerateInstances(MethodContext *pMethodContext, long Flags)
{
	HRESULT hResult;

	// Property mask
	BYTE bBits[e_End_Property_Marker/8 + 1];
	SetAllBits(&bBits, e_End_Property_Marker);

	hResult = Enumerate(pMethodContext, NULL, Flags, bBits);

	return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SerialPort::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery &Query, long lFlags)
{
    HRESULT hResult;

    BYTE bBits[e_End_Property_Marker/8 + 1];

	CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&Query);

	pQuery2->GetPropertyBitMask(m_ptrProperties, &bBits);

  	hResult = Enumerate(pMethodContext, NULL, lFlags, bBits);

    return hResult;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32SerialPort::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

// Used to keep track of which ports we've already seen.
typedef std::map<CHString, BOOL> STRING2BOOL;

HRESULT CWin32SerialPort::Enumerate(
    MethodContext *pMethodContext,
    CInstance *pinstGetObj,
    long Flags,
    BYTE bBits[])
{
    // Here's the story: W2K will 'create' COM ports for various devices that
    // get plugged into the box, like modems, IR devices, etc.  These COM
    // ports won't show up in cfg mgr under the Ports class, because they
    // share the same device ID with the host device.  But, these COM
    // ports do show up in Hardware\DeviceMap\SerialComm.  So, enum the
    // values in the SerialCom and use the service name to enum the ports
    // found in the registry under the service name.  Examples:
    // \Device\Serial0 = COM1  --> Go to \SYSTEM\CurrentControlSet\Serial\Enum
    //                             From 0 to Count, get the PnPID and add the port
    // \Device\Serial1 = COM2  --> Skip since we already enumed Serial\Enum
    // RocketPort0     = COM5  --> Go to \SYSTEM\CurrentControlSet\RocketPort\Enum
    //                             From 0 to Count, get the PnPID and add the port
    //
    // This also allows us to pick up COM ports that aren't functioning because
    // such ports show up on the Enum key, but not in Hardware\DeviceMap\SerialComm.


    HRESULT   hResult = WBEM_S_NO_ERROR;
    CRegistry reg;
    BOOL      bDone = FALSE;

	if (reg.Open(
        HKEY_LOCAL_MACHINE,
        L"Hardware\\DeviceMap\\SerialComm",
        KEY_READ) == ERROR_SUCCESS)
	{
        STRING2BOOL    mapServices;
	    int            nKeys = reg.GetValueCount();
        CInstancePtr   pInstance;
        CHString       strDeviceID;
        CConfigManager cfgMgr;

	    // If this is a GetObject, get the DeviceID.
        if (!pMethodContext)
        {
            pinstGetObj->GetCHString(L"DeviceID", strDeviceID);
        }

		for (DWORD dwKey = 0;
            dwKey < nKeys && SUCCEEDED(hResult) && !bDone;
            dwKey++)
		{
		    WCHAR *pName;
            BYTE  *pValue;

            if (reg.EnumerateAndGetValues(
                dwKey,
                pName,
                pValue) != ERROR_SUCCESS)
			{
				continue;
			}

            // Wrap with CSmartBuffer so the memory will go away when the
            // variables go out of scope.
            CSmartBuffer bufferName((LPBYTE) pName),
                         bufferValue(pValue);
            CHString     strService;

            RegNameToServiceName(pName, strService);

            // Have we not seen this service name yet?
            if (mapServices.find(strService) == mapServices.end())
            {
			    CConfigMgrDevicePtr pDevice;
                CRegistry           regEnum;
                CHString            strKey;

                // Make sure we don't do this service again.
                mapServices[strService] = 0;

                strKey.Format(
                    L"SYSTEM\\CurrentControlSet\\Services\\%s\\Enum",
                    (LPCWSTR) strService);

                if (regEnum.Open(
                    HKEY_LOCAL_MACHINE,
                    strKey,
                    KEY_READ) == ERROR_SUCCESS)
                {
                    DWORD dwCount = 0;

                    regEnum.GetCurrentKeyValue(L"Count", dwCount);

                    // Each registry value looks like:
                    // # = PNPID
                    for (DWORD dwCurrent = 0; dwCurrent < dwCount; dwCurrent++)
                    {
                        WCHAR               szValue[MAXITOA];
                        CHString            strPNPID;
              			CConfigMgrDevicePtr pDevice;

                        _itow(dwCurrent, szValue, 10);

                        regEnum.GetCurrentKeyValue(szValue, strPNPID);

                        if (cfgMgr.LocateDevice(strPNPID, &pDevice))
                        {
                            CHString strKey;

                            if (pDevice->GetRegistryKeyName(strKey))
                            {
                                CRegistry regDeviceParam;
                                CHString  strPort;

                                strKey += L"\\Device Parameters";

                                regDeviceParam.OpenLocalMachineKeyAndReadValue(
                                    strKey,
                                    L"PortName",
                                    strPort);

                                if (!strPort.IsEmpty())
                                {
                					if (pMethodContext)
                                    {
                                        pInstance.Attach(CreateNewInstance(pMethodContext));

                                        hResult =
                                            LoadPropertyValues(
                                                pInstance,
                                                pDevice,
                                                strPort, // COM1, COM2, etc.
                                                bBits);

					                    if (SUCCEEDED(hResult))
					                    {
						                    hResult = pInstance->Commit();
					                    }
                                    }
                                    else if (!_wcsicmp(strPort, strDeviceID))
                                    {
                                        hResult =
                                            LoadPropertyValues(
                                                pinstGetObj,
                                                pDevice,
                                                strPort, // COM1, COM2, etc.
                                                bBits);

                                        bDone = TRUE;

                                        break;
                                    }
                                } // if (!strPort.IsEmpty())
                            } // if (pDevice->GetRegistryKeyName
                        } // if (cfgMgr.LocateDevice
                    } // for (DWORD dwCurrent = 0;
                } // if (regEnum.Open(
            } // if (mapServices.find(pName) == mapPorts.end())
        } // for (DWORD dwKey
    } // if (reg.Open == ERROR_SUCCESS)

	// If we're doing a get object and we never finished, return not found.
    if (!bDone && pinstGetObj)
        hResult = WBEM_E_NOT_FOUND;

    return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance *pInst - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SerialPort::LoadPropertyValues(
	CInstance *pInst,
	CConfigMgrDevice *pDevice,
	LPCWSTR szDeviceName,
	BYTE bBits[])
{
	HRESULT hResult = WBEM_S_NO_ERROR;

	// Begin of CIM_LogicalDevice properties

    // Availability -- preset, will be reset if different than this default
	if (IsBitSet(bBits, e_Availability))
	{
		//set the Availability to unknown...
		pInst->SetWBEMINT16(IDS_Availability, 2);
	}

	// CreationClassName
	if (IsBitSet(bBits, e_CreationClassName))
	{
		SetCreationClassName(pInst);
	}

	// ConfigManagerErrorCode
	if (IsBitSet(bBits, e_ConfigManagerErrorCode))
	{
		DWORD	dwStatus,
				dwProblem;

		if (pDevice->GetStatus(&dwStatus, &dwProblem))
		{
			pInst->SetDWORD(IDS_ConfigManagerErrorCode, dwProblem);
		}
	}

	// ConfigManagerUserConfig
	if (IsBitSet(bBits, e_ConfigManagerUserConfig))
	{
		pInst->SetDWORD(IDS_ConfigManagerUserConfig, pDevice->IsUsingForcedConfig());
	}

	//	DeviceID
    // Always populate the key
	pInst->SetCHString(IDS_DeviceID, szDeviceName);

	// PNPDeviceID
	if (IsBitSet(bBits, e_PNPDeviceID))
	{
		CHString	strDeviceID;

		if (pDevice->GetDeviceID(strDeviceID))
			pInst->SetCHString(IDS_PNPDeviceID, strDeviceID);
	}

	// PowerManagementCapabilities
	if (IsBitSet(bBits, e_PowerManagementCapabilities))
	{
		//set the PowerManagementCapabilities to not supported...
		variant_t      vCaps;
        SAFEARRAYBOUND rgsabound;
		long           ix;

        ix = 0;
		rgsabound.cElements = 1;
		rgsabound.lLbound   = 0;

		V_ARRAY(&vCaps) = SafeArrayCreate(VT_I2, 1, &rgsabound);
        V_VT(&vCaps) = VT_I2 | VT_ARRAY;

		if (V_ARRAY(&vCaps))
		{
			int iPowerCapabilities = 1; // not supported

        	if (S_OK == SafeArrayPutElement(V_ARRAY(&vCaps), &ix, &iPowerCapabilities))
			{
				pInst->SetVariant(IDS_PowerManagementCapabilities, vCaps);
			}
		}
    }

	// PowerManagementSupported
	if (IsBitSet(bBits, e_PowerManagementSupported))
	{
		pInst->Setbool(IDS_PowerManagementSupported, FALSE);
	}

	// SystemCreationClassName
	if (IsBitSet(bBits, e_SystemCreationClassName))
	{
		pInst->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
	}

	// SystemName
	if (IsBitSet(bBits, e_SystemName))
	{
		pInst->SetCHString(IDS_SystemName, GetLocalComputerName());
	}



    // Begin of CIM_ManagedSystemElement properties
	CHString strFriendlyName,
             strDescription;

	pDevice->GetFriendlyName(strFriendlyName);
	pDevice->GetDeviceDesc(strDescription);

    if (strFriendlyName.IsEmpty())
        strFriendlyName = strDescription;

	// Caption
	if (IsBitSet(bBits, e_Caption))
	{
		pInst->SetCHString(IDS_Caption, strFriendlyName);
	}

	// Description
	if (IsBitSet(bBits, e_Description))
	{
		pInst->SetCHString(IDS_Description, strDescription);
	}

	// InstallDate
	// if (IsBitSet(bBits, e_InstallDate)){}

	// Name
	if (IsBitSet(bBits, e_Name))
	{
		pInst->SetCHString(IDS_Name, strFriendlyName);
	}

	// Status
	if (IsBitSet(bBits, e_Status))
	{
        CHString sStatus;
		if (pDevice->GetStatus(sStatus))
		{
			pInst->SetCHString(IDS_Status, sStatus);
		}
	}


    // Begin of properties local to Win32_SerialPort.
	SHORT	    Status = 2; // Unknown
	WCHAR		szTemp[MAX_PATH];
	SmartCloseHandle
                hCOMHandle;
	COMMPROP	COMProp;

	// OSAutoDiscovered
	if (IsBitSet(bBits, e_OSAutoDiscovered))
	{
		pInst->Setbool(IDS_OSAutoDiscovered,(bool) TRUE);
	}

	if (!pInst->IsNull(IDS_DeviceID))
	{
		CHString sPortName;
		pInst->GetCHString(IDS_DeviceID, sPortName);
		swprintf(szTemp, L"\\\\.\\%s", (LPCWSTR) sPortName);
		hCOMHandle = CreateFile(szTemp, 0, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	}

	if (hCOMHandle == INVALID_HANDLE_VALUE)
	{
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
		{
			// Try using wdm's interface to the kernel
			if (WBEM_S_NO_ERROR == hLoadWmiSerialData(pInst, bBits))
			{
				// status
				if (IsBitSet(bBits, e_StatusInfo))
				{
					Status = 3; // Running/Full Power
					pInst->SetWBEMINT16(IDS_StatusInfo, Status);
				}
			}
		}

		// com port is valid, but we can't get to it.
		return hResult;
	}

	COMProp.wPacketLength = sizeof(COMMPROP);
	if (GetCommProperties(hCOMHandle, &COMProp))
	{
		// MaximumOutputBufferSize
		if (IsBitSet(bBits, e_MaximumOutputBufferSize))
		{
			pInst->SetDWORD(IDS_MaximumOutputBufferSize, COMProp.dwMaxTxQueue);
		}

		// MaximumInputBufferSize
		if (IsBitSet(bBits, e_MaximumInputBufferSize))
		{
			pInst->SetDWORD(IDS_MaximumInputBufferSize, COMProp.dwMaxTxQueue);
		}

		// SerialController::MaximumBaudRate
		if (IsBitSet(bBits, e_MaxBaudRate))
		{
			DWORD dwMaxBaudRate = 0L;

			switch(COMProp.dwMaxBaud)
			{
				case BAUD_075:
					dwMaxBaudRate = 75;
					break;

				case BAUD_110:
					dwMaxBaudRate = 110;
					break;

				case BAUD_134_5:
					dwMaxBaudRate = 1345;
					break;

				case BAUD_150:
					dwMaxBaudRate = 150;
					break;

				case BAUD_300:
					dwMaxBaudRate = 300;
					break;

				case BAUD_600:
					dwMaxBaudRate = 600;
					break;

				case BAUD_1200:
					dwMaxBaudRate = 1200;
					break;

				case BAUD_1800:
					dwMaxBaudRate = 1800;
					break;

				case BAUD_2400:
					dwMaxBaudRate = 2400;
					break;

				case BAUD_4800:
					dwMaxBaudRate = 4800;
					break;

				case BAUD_7200:
					dwMaxBaudRate = 7200;
					break;

				case BAUD_9600:
					dwMaxBaudRate = 9600;
					break;

				case BAUD_14400:
					dwMaxBaudRate = 14400;
					break;

				case BAUD_19200:
					dwMaxBaudRate = 19200;
					break;

				case BAUD_38400:
					dwMaxBaudRate = 38400;
					break;

				case BAUD_56K:
					dwMaxBaudRate = 56000;
					break;

				case BAUD_57600:
					dwMaxBaudRate = 57600;
					break;

				case BAUD_115200:
					dwMaxBaudRate = 115200;
					break;

				case BAUD_128K:
					dwMaxBaudRate = 128000;
					break;

				case BAUD_USER:
				{
					DWORD dwMaskBaudRate = COMProp.dwSettableBaud;

					if ( dwMaskBaudRate & BAUD_128K )
					{
						dwMaxBaudRate = 128000;
					}
					else
					if ( dwMaskBaudRate & BAUD_115200 )
					{
						dwMaxBaudRate = 115200;
					}
					else
					if ( dwMaskBaudRate & BAUD_57600 )
					{
						dwMaxBaudRate = 57600;
					}
					else
					if ( dwMaskBaudRate & BAUD_56K )
					{
						dwMaxBaudRate = 56000;
					}
					else
					if ( dwMaskBaudRate & BAUD_38400 )
					{
						dwMaxBaudRate = 38400;
					}
					else
					if ( dwMaskBaudRate & BAUD_19200 )
					{
						dwMaxBaudRate = 19200;
					}
					else
					if ( dwMaskBaudRate & BAUD_14400 )
					{
						dwMaxBaudRate = 14400;
					}
					else
					if ( dwMaskBaudRate & BAUD_9600 )
					{
						dwMaxBaudRate = 9600;
					}
					else
					if ( dwMaskBaudRate & BAUD_7200 )
					{
						dwMaxBaudRate = 7200;
					}
					else
					if ( dwMaskBaudRate & BAUD_4800 )
					{
						dwMaxBaudRate = 4800;
					}
					else
					if ( dwMaskBaudRate & BAUD_2400 )
					{
						dwMaxBaudRate = 2400;
					}
					else
					if ( dwMaskBaudRate & BAUD_134_5 )
					{
						dwMaxBaudRate = 1345;
					}
					else
					if ( dwMaskBaudRate & BAUD_1200 )
					{
						dwMaxBaudRate = 1200;
					}
					else
					if ( dwMaskBaudRate & BAUD_600 )
					{
						dwMaxBaudRate = 600;
					}
					else
					if ( dwMaskBaudRate & BAUD_300 )
					{
						dwMaxBaudRate = 300;
					}
					else
					if ( dwMaskBaudRate & BAUD_150 )
					{
						dwMaxBaudRate = 150;
					}
					else
					if ( dwMaskBaudRate & BAUD_110 )
					{
						dwMaxBaudRate = 110;
					}
					else
					if ( dwMaskBaudRate & BAUD_075 )
					{
						dwMaxBaudRate = 75;
					}
					else
					{
#ifdef NTONLY
						dwMaxBaudRate = GetPortPropertiesFromRegistry (	szDeviceName );
#else
						dwMaxBaudRate = 0L;
#endif
					}

					break;
				}

				default:
#ifdef NTONLY
					dwMaxBaudRate = GetPortPropertiesFromRegistry (	szDeviceName );
#else
					dwMaxBaudRate = 0L;
#endif
					break;
			}

			if (dwMaxBaudRate != 0)
				pInst->SetDWORD(IDS_MaximumBaudRate, dwMaxBaudRate);
		}

		// ProviderType
		if (IsBitSet(bBits, e_ProviderType))
		{
			CHString chsProviderType;
			switch(COMProp.dwProvSubType)
			{
				case PST_FAX:
					chsProviderType = L"FAX Device";
					break;

				case PST_LAT:
					chsProviderType = L"LAT Protocol";
					break;

				case PST_MODEM:
					chsProviderType = L"Modem Device";
					break;

				case PST_NETWORK_BRIDGE:
					chsProviderType = L"Network Bridge";
					break;

				case PST_PARALLELPORT:
					chsProviderType = L"Parallel Port";
					break;

				case PST_RS232:
					chsProviderType = L"RS232 Serial Port";
					break;

				case PST_RS422:
					chsProviderType = L"RS422 Port";
					break;

				case PST_RS423:
					chsProviderType = L"RS423 Port";
					break;

				case PST_RS449:
					chsProviderType = L"RS449 Port";
					break;

				case PST_SCANNER:
					chsProviderType = L"Scanner Device";
					break;

				case PST_TCPIP_TELNET:
					chsProviderType = L"TCP/IP TelNet";
					break;

				case PST_X25:
					chsProviderType = L"X.25";
					break;

				default:
					chsProviderType = L"Unspecified";
					break;
			}

			pInst->SetCHString(IDS_ProviderType, chsProviderType);
		}

		// Supports16BitMode
		if (IsBitSet(bBits, e_Supports16BitMode))
		{
			pInst->Setbool(IDS_Supports16BitMode,
								COMProp.dwProvCapabilities & PCF_16BITMODE ? TRUE : FALSE);
		}

		// SupportsDTRDSR
		if (IsBitSet(bBits, e_SupportsDTRDSR))
		{
			pInst->Setbool(IDS_SupportsDTRDSR,
								COMProp.dwProvCapabilities & PCF_DTRDSR ? TRUE : FALSE);
		}

		// SupportsIntervalTimeouts
		if (IsBitSet(bBits, e_SupportsIntTimeouts))
		{
			pInst->Setbool(IDS_SupportsIntervalTimeouts,
								COMProp.dwProvCapabilities & PCF_INTTIMEOUTS ? TRUE : FALSE);
		}

		// SupportsParityCheck
		if (IsBitSet(bBits, e_SupportsParityCheck))
		{
			pInst->Setbool(IDS_SupportsParityCheck,
								COMProp.dwProvCapabilities & PCF_PARITY_CHECK ? TRUE : FALSE);
		}

		// SupportsRLSD
		if (IsBitSet(bBits, e_SupportsRLSD))
		{
			pInst->Setbool(IDS_SupportsRLSD,
								COMProp.dwProvCapabilities & PCF_RLSD ? TRUE : FALSE);
		}

		// SupportsRTSCTS
		if (IsBitSet(bBits, e_SupportsRTSCTS))
		{
			pInst->Setbool(IDS_SupportsRTSCTS,
								COMProp.dwProvCapabilities & PCF_RTSCTS ? TRUE : FALSE);
		}

		// SupportsSettableXOnXOff
		if (IsBitSet(bBits, e_SupportsXOnXOffSet))
		{
			pInst->Setbool(IDS_SupportsSettableXOnXOff,
								COMProp.dwProvCapabilities & PCF_SETXCHAR ? TRUE : FALSE);
		}

		// SupportsSpecialChars
		if (IsBitSet(bBits, e_SupportsSpecialCharacters))
		{
			pInst->Setbool(IDS_SupportsSpecialChars,
								COMProp.dwProvCapabilities & PCF_SPECIALCHARS ? TRUE : FALSE);
		}

		// SupportsTotalTimeouts
		if (IsBitSet(bBits, e_SupportsElapsedTimeouts))
		{
			// Elapsed timeout support.....not total timeouts.
			pInst->Setbool(IDS_SupportsElapsedTimeouts,
								COMProp.dwProvCapabilities & PCF_TOTALTIMEOUTS ? TRUE : FALSE);
		}

		// SupportsXOnXOff
		if (IsBitSet(bBits, e_SupportsXOnXOff))
		{
			pInst->Setbool(IDS_SupportsXOnXOff,
								COMProp.dwProvCapabilities & PCF_XONXOFF ? TRUE : FALSE);
		}

		// SettableBaudRate
		if (IsBitSet(bBits, e_SettableBaudRate))
		{
			pInst->Setbool(IDS_SettableBaudRate,
								COMProp.dwSettableParams & SP_BAUD ? TRUE : FALSE);
		}

		// SettableDataBits
		if (IsBitSet(bBits, e_SettableDataBits))
		{
			pInst->Setbool(IDS_SettableDataBits,
								COMProp.dwSettableParams & SP_DATABITS ? TRUE : FALSE);
		}

		// SettableFlowControl
		if (IsBitSet(bBits, e_SettableFlowControl))
		{
			pInst->Setbool(IDS_SettableFlowControl,
								COMProp.dwSettableParams & SP_HANDSHAKING ? TRUE : FALSE);
		}

		// SettableParity
		if (IsBitSet(bBits, e_SettableParity))
		{
			pInst->Setbool(IDS_SettableParity,
								COMProp.dwSettableParams & SP_PARITY ? TRUE : FALSE);
		}

		// SettableParityCheck
		if (IsBitSet(bBits, e_SettableParityCheck))
		{
			pInst->Setbool(IDS_SettableParityCheck,
								COMProp.dwSettableParams & SP_PARITY_CHECK	? TRUE : FALSE);
		}

		// SettableRLSD
		if (IsBitSet(bBits, e_SettableRLSD))
		{
			pInst->Setbool(IDS_SettableRLSD,
								COMProp.dwSettableParams & SP_RLSD ? TRUE : FALSE);
		}

		// SettableStopBits
		if (IsBitSet(bBits, e_SettableStopBits))
		{
			pInst->Setbool(IDS_SettableStopBits,
								COMProp.dwSettableParams & SP_STOPBITS ? TRUE : FALSE);
		}

		// Binary
		if (IsBitSet(bBits, e_Binary))
		{
			DCB dcb;
			if (GetCommState(hCOMHandle, &dcb))
			{
				BOOL fBinary = FALSE;

				fBinary =(BOOL) dcb.fBinary;
				pInst->Setbool(IDS_Binary, fBinary);
			}
		}

		Status = 3; // Running/Full Power
	}

	// Status --
	if (IsBitSet(bBits, e_StatusInfo))
	{
		pInst->SetWBEMINT16(IDS_StatusInfo, Status);
	}


	return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::Load_Win32_SerialPort
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance *pInst - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    : This sets  fields in the Load_Win32_SerialPort class
 *
 *****************************************************************************/

#define Serial_ComInfo_Guid _T("{EDB16A62-B16C-11D1-BD98-00A0C906BE2D}")
#define Serial_Name_Guid	_T("{A0EC11A8-B16C-11D1-BD98-00A0C906BE2D}")

HRESULT CWin32SerialPort::hLoadWmiSerialData(CInstance *pInst, BYTE bBits[])
{
	HRESULT			hRes = WBEM_E_NOT_FOUND;
	CWdmInterface	wdm;
	CNodeAll		oSerialNames(Serial_Name_Guid);

	hRes = wdm.hLoadBlock(oSerialNames);
	if (S_OK == hRes)
	{
		CHString chsName;
		pInst->GetCHString(IDS_DeviceID, chsName);


		CHString chsSerialPortName;
		bool bValid = oSerialNames.FirstInstance();

		while (bValid)
		{
			// Extract the friendly name
			oSerialNames.GetString(chsSerialPortName);

			// friendly name is a match
			if (!chsSerialPortName.CompareNoCase(chsName))
			{
				// instance name
				CHString chsNameInstanceName;
				oSerialNames.GetInstanceName(chsNameInstanceName);

				// key on the instance name
				return GetWMISerialInfo(pInst, wdm, chsName, chsNameInstanceName, bBits);

			}
			bValid = oSerialNames.NextInstance();
		}
	}
	return hRes;
}

//
HRESULT CWin32SerialPort::GetWMISerialInfo(CInstance *pInst,
										   CWdmInterface& rWdm,
										   LPCWSTR szName,
										   LPCWSTR szNameInstanceName,
                                           BYTE bBits[])
{
	HRESULT		hRes = WBEM_E_NOT_FOUND;
	CNodeAll	oSerialData(Serial_ComInfo_Guid);

	hRes = rWdm.hLoadBlock(oSerialData);
	if (S_OK == hRes)
	{
		CHString chsDataInstanceName;
		bool bValid = oSerialData.FirstInstance();

		while (bValid)
		{
			oSerialData.GetInstanceName(chsDataInstanceName);

			// friendly name is a match
			if (!chsDataInstanceName.CompareNoCase(szNameInstanceName))
			{
				// collect this MSSerial_CommInfo instance
				MSSerial_CommInfo ci;

				/*	We are currently without a class contract. The class within
					the wmi mof is not expected to changed however we have to
					explicitly indicate how the data is layed out. Having the class
					definition would allow us to examine the property qualifiers
					to get us the order(WmiDataId) and property types.

					Secondly, because the data is aligned on natural boundaries
					a direct offset to a specific piece of data is conditioned on
					what has preceeded it. Thus, a string followed by a DWORD may
					be 0 to 2 bytes away from each other.

					Serially extracting each property in order will take into
					account the alignment problem.
				*/
				oSerialData.GetDWORD(ci.BaudRate);
				oSerialData.GetDWORD(ci.BitsPerByte);
				oSerialData.GetDWORD(ci.Parity);
				oSerialData.GetBool( ci.ParityCheckEnable);
				oSerialData.GetDWORD(ci.StopBits);
				oSerialData.GetDWORD(ci.XoffCharacter);
				oSerialData.GetDWORD(ci.XoffXmitThreshold);
				oSerialData.GetDWORD(ci.XonCharacter);
				oSerialData.GetDWORD(ci.XonXmitThreshold);
				oSerialData.GetDWORD(ci.MaximumBaudRate);
				oSerialData.GetDWORD(ci.MaximumOutputBufferSize);
				oSerialData.GetDWORD(ci.MaximumInputBufferSize);
				oSerialData.GetBool( ci.Support16BitMode);
				oSerialData.GetBool( ci.SupportDTRDSR);
				oSerialData.GetBool( ci.SupportIntervalTimeouts);
				oSerialData.GetBool( ci.SupportParityCheck);
				oSerialData.GetBool( ci.SupportRTSCTS);
				oSerialData.GetBool( ci.SupportXonXoff);
				oSerialData.GetBool( ci.SettableBaudRate);
				oSerialData.GetBool( ci.SettableDataBits);
				oSerialData.GetBool( ci.SettableFlowControl);
				oSerialData.GetBool( ci.SettableParity);
				oSerialData.GetBool( ci.SettableParityCheck);
				oSerialData.GetBool( ci.SettableStopBits);
				oSerialData.GetBool( ci.IsBusy);

				// populate the instance

				// MaximumOutputBufferSize
				if (IsBitSet(bBits, e_MaximumOutputBufferSize))
				{
					pInst->SetDWORD(IDS_MaximumOutputBufferSize, ci.MaximumOutputBufferSize);
				}

				// MaximumInputBufferSize
				if (IsBitSet(bBits, e_MaximumInputBufferSize))
				{
					pInst->SetDWORD(IDS_MaximumInputBufferSize, ci.MaximumInputBufferSize);
				}

				// SerialController::MaximumBaudRate
				if (IsBitSet(bBits, e_MaxBaudRate))
				{
					pInst->SetDWORD(IDS_MaximumBaudRate, ci.MaximumBaudRate);
				}

				// Supports16BitMode
				if (IsBitSet(bBits, e_Supports16BitMode))
				{
					pInst->Setbool(IDS_Supports16BitMode, ci.Support16BitMode ? TRUE : FALSE);
				}

				// SupportsDTRDSR
				if (IsBitSet(bBits, e_SupportsDTRDSR))
				{
					pInst->Setbool(IDS_SupportsDTRDSR,	ci.SupportDTRDSR ? TRUE : FALSE);
				}

				// SupportsIntervalTimeouts
				if (IsBitSet(bBits, e_SupportsIntTimeouts))
				{
					pInst->Setbool(IDS_SupportsIntervalTimeouts, ci.SupportIntervalTimeouts	? TRUE : FALSE);
				}

				// SupportsParityCheck
				if (IsBitSet(bBits, e_SupportsParityCheck))
				{
					pInst->Setbool(IDS_SupportsParityCheck, ci.SupportParityCheck ? TRUE : FALSE);
				}

				// SupportsRTSCTS
				if (IsBitSet(bBits, e_SupportsRTSCTS))
				{
					pInst->Setbool(IDS_SupportsRTSCTS,	ci.SupportRTSCTS ? TRUE : FALSE);
				}

				// SupportsXOnXOff
				if (IsBitSet(bBits, e_SupportsXOnXOff))
				{
					pInst->Setbool(IDS_SupportsXOnXOff, ci.SupportXonXoff ? TRUE : FALSE);
				}

				// SettableBaudRate
				if (IsBitSet(bBits, e_SettableBaudRate))
				{
					pInst->Setbool(IDS_SettableBaudRate, ci.SettableBaudRate ? TRUE : FALSE);
				}

				// SettableDataBits
				if (IsBitSet(bBits, e_SettableDataBits))
				{
					pInst->Setbool(IDS_SettableDataBits, ci.SettableDataBits ? TRUE : FALSE);
				}

				// SettableFlowControl
				if (IsBitSet(bBits, e_SettableFlowControl))
				{
					pInst->Setbool(IDS_SettableFlowControl, ci.SettableFlowControl	? TRUE : FALSE);
				}

				// SettableParity
				if (IsBitSet(bBits, e_SettableParity))
				{
					pInst->Setbool(IDS_SettableParity,	ci.SettableParityCheck	? TRUE : FALSE);
				}

				// SettableParityCheck
				if (IsBitSet(bBits, e_SettableParityCheck))
				{
					pInst->Setbool(IDS_SettableParityCheck, ci.SettableParityCheck	? TRUE : FALSE);
				}

				// SettableStopBits
				if (IsBitSet(bBits, e_SettableStopBits))
				{
					pInst->Setbool(IDS_SettableStopBits, ci.SettableStopBits ? TRUE : FALSE);
				}

				return WBEM_S_NO_ERROR;
			}
			bValid = oSerialData.NextInstance();
		}
	}
	return hRes;
}

// Strip off the service name from the registry value name.
// The service name will be in the form of service# (e.g. RocketPort5) or
// \Device\Service# (e.g. \Device\Serial0).

void WINAPI CWin32SerialPort::RegNameToServiceName(
    LPCWSTR szName,
    CHString &strService)
{
    LPWSTR szSlash = wcsrchr(szName, '\\');

    if (szSlash)
        strService = szSlash + 1;
    else
        strService = szName;

    int iWhere = strService.GetLength();

    while (iWhere && iswdigit(strService[iWhere - 1]))
    {
        iWhere--;
    }

    strService = strService.Left(iWhere);
}

#ifdef	NTONLY
DWORD CWin32SerialPort::GetPortPropertiesFromRegistry (	LPCWSTR szDeviceName )
{
	DWORD dwResult = 0L;

	// get registry value
	CRegistry reg;
	if ( ( reg.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Ports", KEY_READ ) ) == ERROR_SUCCESS )
	{
		// get value for serial port
		CHString Key ( szDeviceName );
		Key += L':';

		CHString Value;
		if ( ( reg.GetCurrentKeyValue ( Key, Value ) ) == ERROR_SUCCESS )
		{
			DWORD dwCount = 0L;
			if ( ! Value.IsEmpty () && ( dwCount = Value.Find ( L',' ) ) != 0L )
			{
				CHString BaudRate ( Value.Mid ( 0, dwCount ) );

				// get final baud rate from registry as devicer manager does
				dwResult = static_cast < DWORD > ( _wtoi ( static_cast < LPCWSTR > ( BaudRate ) ) ); 
			}
		}
	}

	return dwResult;
}
#endif	//NTONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\w2k\cdrom.cpp ===
//=================================================================

//

// w2k\CDROM.cpp -- CDROM property set provider

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/97    Davwoh        Created
//				 02/07/99	StevM		Updated
//
//=================================================================

#include "precomp.h"

#include <devioctl.h>
#include <ntddscsi.h>
#include <ntddstor.h>

#include "kernel32api.h"

#include "..\cdrom.h"

#include "..\MSINFO_cdrom.h"
#include <comdef.h>


//#include <sdkioctl.h>
// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_CDROM L"CDROM"
#define CONFIG_MANAGER_CLASS_GUID_CDROM L"{4d36e965-e325-11ce-bfc1-08002be10318}"

CWin32CDROM s_Cdrom ( PROPSET_NAME_CDROM , IDS_CimWin32Namespace );

const WCHAR *IDS_MfrAssignedRevisionLevel = L"MfrAssignedRevisionLevel";


/*
 *	Note QueryDosDevice doesn't allow us to get the actual size of the buffer.
 *	We would have to call the underlying OS api ( NtQueryDevice.... ) to do it
 *	properly. The buffers should be large enough however.
 */


/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::CWin32CDROM
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32CDROM :: CWin32CDROM (

	LPCWSTR a_pszName,
	LPCWSTR a_pszNamespace

) : Provider ( a_pszName, a_pszNamespace )
{
    // Identify the platform right away
    //=================================

	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::~CWin32CDROM
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32CDROM :: ~CWin32CDROM()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM :: GetObject ( CInstance *a_Instance, long a_Flags, CFrameworkQuery &a_Query)
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;

    CConfigManager t_ConfigManager ;

/*
 * Let's see if config manager recognizes this device at all
 */

    CHString t_Key ;
    a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

    CConfigMgrDevicePtr t_Device;
    if ( t_ConfigManager.LocateDevice ( t_Key , & t_Device ) )
    {
/*
 * Ok, it knows about it.  Is it a CDROM device?
 */
		CHString t_DeviceClass ;
		if ( t_Device->GetClassGUID ( t_DeviceClass ) && t_DeviceClass.CompareNoCase ( CONFIG_MANAGER_CLASS_GUID_CDROM ) == 0 )
		{
			TCHAR *t_DosDeviceNameList = NULL ;
			if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
			{
				try
				{
					CHString t_DeviceId ;
					if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
					{
						DWORD t_SpecifiedProperties = GetBitMask(a_Query);
						t_Result = LoadPropertyValues ( a_Instance, t_Device , t_DeviceId , t_DosDeviceNameList , t_SpecifiedProperties ) ;
					}
				}
				catch ( ... )
				{
					delete [] t_DosDeviceNameList ;
					throw;
				}

				delete [] t_DosDeviceNameList ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask(a_Query);

	//if ( t_SpecifiedProperties )  //removed since would result in no query being executed if no special properties were selected.
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;

	TCHAR *t_DosDeviceNameList = NULL ;
	if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
	{
		try
		{
			CConfigManager t_ConfigManager ;
			CDeviceCollection t_DeviceList ;

		/*
		*	While it might be more performant to use FilterByGuid, it appears that at least some
		*	95 boxes will report InfraRed info if we do it this way.
		*/

			if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_CDROM ) )
			{
				REFPTR_POSITION t_Position ;

				if ( t_DeviceList.BeginEnum ( t_Position ) )
				{
					CConfigMgrDevicePtr t_Device;

					t_Result = WBEM_S_NO_ERROR ;

					// Walk the list

					for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
						 SUCCEEDED(t_Result) && (t_Device != NULL);
						 t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
					{
						CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
						CHString t_DeviceId ;
						if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
						{
							t_Result = LoadPropertyValues ( t_Instance , t_Device , t_DeviceId , t_DosDeviceNameList , a_SpecifiedProperties ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
									t_Result = t_Instance->Commit (  ) ;
							}
						}
						else
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}
					}

					// Always call EndEnum().  For all Beginnings, there must be an End

					t_DeviceList.EndEnum();
				}
			}
		}
		catch ( ... )
		{
			delete [] t_DosDeviceNameList ;

			throw ;
		}

		delete [] t_DosDeviceNameList ;
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

    return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: LoadPropertyValues (

	CInstance *a_Instance,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{
	HRESULT t_Result = LoadConfigManagerPropertyValues ( a_Instance , a_Device , a_DeviceName , a_SpecifiedProperties ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SpecifiedProperties & SPECIAL_MEDIA )
		{
			CHString t_DosDeviceName ;
			t_Result = GetDeviceInformation ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList , a_SpecifiedProperties ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = LoadMediaPropertyValues ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_SpecifiedProperties ) ;
			}
			else
			{
				t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
			}
		}
	}

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: LoadConfigManagerPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

	a_Instance->SetWBEMINT16(IDS_Availability, 3 ) ;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID ) // Always populate the key
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
//	{
//	    a_Instance->SetWBEMINT16 ( _T("ProtocolSupported") , 16 ) ;
//	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM :: GetDeviceInformation
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM :: GetDeviceInformation (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	CHString a_DeviceName ,
	CHString &a_DosDeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_CreatedSymbolicLink = FALSE ;
	CHString t_SymbolicLinkName ;

    try
    {

	    BOOL t_Status = FindDosDeviceName ( a_DosDeviceNameList , a_DeviceName , t_SymbolicLinkName, TRUE ) ;
	    if ( ! t_Status )
	    {
		    t_SymbolicLinkName = CHString ( _TEXT("WMI_CDROMDEVICE_SYBOLICLINK") ) ;
		    EnterCriticalSection ( & m_CriticalSection ) ;
		    t_Status = DefineDosDevice ( DDD_RAW_TARGET_PATH , t_SymbolicLinkName , a_DeviceName ) ;
		    LeaveCriticalSection ( & m_CriticalSection ) ;
		    if ( t_Status )
		    {
			    t_CreatedSymbolicLink = TRUE ;
		    }
		    else
		    {
			    t_Result = WBEM_E_PROVIDER_FAILURE ;

			    DWORD t_LastError = GetLastError () ;
		    }
	    }

	    if ( t_Status )
	    {
		    CHString t_Device = CHString ( "\\\\.\\" ) + t_SymbolicLinkName ;

		    SmartCloseHandle t_Handle = CreateFile (

			    t_Device,
			    GENERIC_READ,
			    FILE_SHARE_READ|FILE_SHARE_WRITE,
			    NULL,
			    OPEN_EXISTING,
			    0,
			    NULL
		    );

		    if ( t_Handle != INVALID_HANDLE_VALUE )
		    {
			    STORAGE_DEVICE_NUMBER t_DeviceNumber;
			    DWORD t_BytesReturned;
			    ULONG t_Return = 0;

			    t_Status = DeviceIoControl (

				    t_Handle ,
				    IOCTL_STORAGE_GET_DEVICE_NUMBER ,
				    NULL ,
				    0 ,
				    & t_DeviceNumber ,
				    sizeof ( STORAGE_DEVICE_NUMBER ) ,
				    & t_BytesReturned ,
				    NULL
			    ) ;

			    if ( t_Status )
			    {
				    TCHAR t_DeviceLabel [ sizeof ( TCHAR ) * 17 + sizeof ( _TEXT("\\Device\\CDROM") ) ] ;
				    _stprintf ( t_DeviceLabel , _TEXT("\\Device\\CDROM%d") , t_DeviceNumber.DeviceNumber ) ;

				    t_Status = FindDosDeviceName ( a_DosDeviceNameList , t_DeviceLabel, a_DosDeviceName, TRUE ) ;
				    if ( ! t_Status )
				    {
					    t_Result = WBEM_E_NOT_FOUND ;
				    }
			    }
			    else
			    {
				    t_Result = WBEM_E_PROVIDER_FAILURE ;

				    DWORD t_Error = GetLastError () ;
			    }


	    /*
	     * Get SCSI information (IDE drives are still
	     * controlled by subset of SCSI miniport)
	     */

			    if ( a_SpecifiedProperties & SPECIAL_SCSIINFO )
			    {
				    SCSI_ADDRESS t_SCSIAddress ;
				    DWORD t_Length ;

				    t_Status = DeviceIoControl (

					    t_Handle ,
					    IOCTL_SCSI_GET_ADDRESS ,
					    NULL ,
					    0 ,
					    &t_SCSIAddress ,
					    sizeof ( SCSI_ADDRESS ) ,
					    &t_Length ,
					    NULL
				    ) ;

				    if ( t_Status )
				    {
					    if ( a_SpecifiedProperties & SPECIAL_PROPS_SCSITARGETID )
					    {
						    a_Instance->SetDWORD ( IDS_SCSITargetId , DWORD ( t_SCSIAddress.TargetId ) ) ;
					    }

					    if ( a_SpecifiedProperties & SPECIAL_PROPS_SCSIBUS )
					    {
						    a_Instance->SetWBEMINT16 ( IDS_SCSIBus , DWORD ( t_SCSIAddress.PathId ) ) ;
					    }

					    if ( a_SpecifiedProperties & SPECIAL_PROPS_SCSILUN )
					    {
						    a_Instance->SetWBEMINT16 ( IDS_SCSILogicalUnit , DWORD ( t_SCSIAddress.Lun ) ) ;
					    }

					    if ( a_SpecifiedProperties & SPECIAL_PROPS_SCSIPORT )
					    {
						    a_Instance->SetWBEMINT16 ( IDS_SCSIPort , DWORD ( t_SCSIAddress.PortNumber ) ) ;
					    }
				    }
			    }
#if NTONLY >= 5
				// Get Revision Number
				STORAGE_DEVICE_DESCRIPTOR t_StorageDevice;
				STORAGE_PROPERTY_QUERY	t_QueryPropQuery;
				

				t_QueryPropQuery.PropertyId = ( STORAGE_PROPERTY_ID ) 0;
				t_QueryPropQuery.QueryType = ( STORAGE_QUERY_TYPE ) 0;

		//		t_StorageDevice.Size = sizeof(STORAGE_DEVICE_DESCRIPTOR);
				DWORD dwLength;
				t_Status = DeviceIoControl (

					t_Handle,
					IOCTL_STORAGE_QUERY_PROPERTY,
					&t_QueryPropQuery,
					sizeof ( STORAGE_PROPERTY_QUERY ),
					&t_StorageDevice,
					sizeof(STORAGE_DEVICE_DESCRIPTOR),
					&dwLength,
					NULL
				) ;

				if ( t_Status )
				{
					if ( t_StorageDevice.ProductRevisionOffset != 0 )
					{
						LPWSTR lpBaseAddres = ( LPWSTR ) &t_StorageDevice;
						LPWSTR lpRevisionAddress =  lpBaseAddres + t_StorageDevice.ProductRevisionOffset;
						CHString t_Revision ( lpRevisionAddress );
						a_Instance->SetCHString ( IDS_MfrAssignedRevisionLevel, t_Revision );
					}
				}
				else
				{
					DWORD dwError = GetLastError();
				}
		
#endif
		    }
		    else
		    {
			    t_Result = WBEM_E_PROVIDER_FAILURE ;

			    DWORD t_Error = GetLastError () ;
		    }
	    }
    }
    catch ( ... )
    {

	    if ( t_CreatedSymbolicLink )
	    {
		    EnterCriticalSection ( & m_CriticalSection ) ;
		    BOOL t_Status = DefineDosDevice ( DDD_EXACT_MATCH_ON_REMOVE | DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
		    LeaveCriticalSection ( & m_CriticalSection ) ;
			DWORD t_LastError = GetLastError () ;
	    }

        throw;
    }

	if ( t_CreatedSymbolicLink )
	{
		EnterCriticalSection ( & m_CriticalSection ) ;
		BOOL t_Status = DefineDosDevice ( DDD_EXACT_MATCH_ON_REMOVE | DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
		LeaveCriticalSection ( & m_CriticalSection ) ;
		if ( ! t_Status )
		{
			t_Result = WBEM_E_PROVIDER_FAILURE ;

			DWORD t_LastError = GetLastError () ;
		}
	}

	return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32CDROM :: LoadMediaPropertyValues
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32CDROM::LoadMediaPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const CHString &a_DosDeviceName ,
	DWORD a_SpecifiedProperties
)
{

	HRESULT t_Result = S_OK ;

/*
 *
 */
    // Set common drive properties
    //=============================

	CHString t_DeviceLabel = CHString ( a_DosDeviceName ) ;

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DRIVE )
	{
	    a_Instance->SetCharSplat ( IDS_Drive, t_DeviceLabel ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_ID )
    {
		a_Instance->SetCharSplat ( IDS_Id, t_DeviceLabel ) ;
    }

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPABILITY )
	{
		// Create a safearray for the Capabilities information

		SAFEARRAYBOUND t_ArrayBounds ;

		t_ArrayBounds.cElements = 2;
		t_ArrayBounds.lLbound = 0;

		variant_t t_CapabilityValue ;

		if ( V_ARRAY ( & t_CapabilityValue ) = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
		{
			V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;

			long t_Capability = 3 ;
			long t_Index = 0;
			SafeArrayPutElement ( V_ARRAY(&t_CapabilityValue) , & t_Index , & t_Capability) ;

			t_Index = 1;
			t_Capability = 7 ;
			SafeArrayPutElement ( V_ARRAY(&t_CapabilityValue) , & t_Index , & t_Capability ) ;

			a_Instance->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;
		}
	}

/*
 * Media type
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIATYPE )
	{
	    a_Instance->SetCharSplat ( IDS_MediaType , IDS_MDT_CD ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_VOLUMEINFORMATION )
	{

/*
 * Set the DriveIntegrity and TransferRate properties:
 */

//		CHString t_VolumeDevice = CHString ( "\\\\.\\" ) + a_DosDeviceName + CHString ( "\\" ) ;
		CHString t_VolumeDevice = a_DosDeviceName;

		if ( a_SpecifiedProperties & SPECIAL_PROPS_TEST_TRANSFERRATE )
		{
			DOUBLE t_TransferRate = ProfileDrive ( t_VolumeDevice ) ;
			if ( t_TransferRate != -1 )
			{
				a_Instance->SetDOUBLE ( IDS_TransferRate , t_TransferRate ) ;
			}
		}

		if ( a_SpecifiedProperties & SPECIAL_PROPS_TEST_INTEGRITY )
		{
            CHString t_IntegrityFile;
			BOOL t_DriveIntegrity = TestDriveIntegrity ( t_VolumeDevice, t_IntegrityFile ) ;

            // If we didn't find an appropriate file, we didn't run the test
            if (!t_IntegrityFile.IsEmpty())
            {
			    a_Instance->Setbool ( IDS_DriveIntegrity,  t_DriveIntegrity ) ;
            }
		}

/*
 *	Volume information
 */

		TCHAR t_FileSystemName [ _MAX_PATH ] = _T("Unknown file system");

		TCHAR t_VolumeName [ _MAX_PATH ] ;
		DWORD t_VolumeSerialNumber ;
		DWORD t_MaxComponentLength ;
		DWORD t_FileSystemFlags ;

		BOOL t_SizeFound = FALSE ;

		BOOL t_Status =	GetVolumeInformation (

			t_VolumeDevice ,
			t_VolumeName ,
			sizeof ( t_VolumeName ) / sizeof(TCHAR) ,
			& t_VolumeSerialNumber ,
			& t_MaxComponentLength ,
			& t_FileSystemFlags ,
			t_FileSystemName ,
			sizeof ( t_FileSystemName ) / sizeof(TCHAR)
		) ;

		if ( t_Status )
		{
/*
 * There's a disk in -- set disk-related props
 */
			if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIALOADED )
			{
				a_Instance->Setbool ( IDS_MediaLoaded , true ) ;
			}

//			if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
//			{
//				a_Instance->SetCharSplat ( IDS_Status , IDS_OK ) ;
//			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_VOLUMENAME )
			{
				a_Instance->SetCharSplat ( IDS_VolumeName , t_VolumeName ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_MAXCOMPONENTLENGTH )
			{
				a_Instance->SetDWORD ( IDS_MaximumComponentLength , t_MaxComponentLength ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_FILESYSTEMFLAGS )
			{
				a_Instance->SetDWORD ( IDS_FileSystemFlags , t_FileSystemFlags ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_FILESYSTEMFLAGSEX )
			{
				a_Instance->SetDWORD ( IDS_FileSystemFlagsEx , t_FileSystemFlags ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_SERIALNUMBER )
			{
				TCHAR t_SerialNumber [ 9 ] ;

				_stprintf ( t_SerialNumber , _T("%x"), t_VolumeSerialNumber ) ;
				_tcsupr ( t_SerialNumber ) ;

				a_Instance->SetCharSplat ( IDS_VolumeSerialNumber , t_SerialNumber ) ;
			}

/*
 *	See if GetDiskFreeSpaceEx() is supported
 */

			if ( a_SpecifiedProperties & SPECIAL_VOLUMESPACE )
			{
				CHString t_DiskDevice = CHString ( _TEXT ("\\\\?\\") ) + a_DosDeviceName + CHString ( _TEXT("\\") ) ;

				ULARGE_INTEGER t_AvailableQuotaBytes ;
				ULARGE_INTEGER t_TotalBytes ;
				ULARGE_INTEGER t_AvailableBytes ;

				TCHAR t_TotalBytesString [ _MAX_PATH ];

                CKernel32Api* t_pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
                if(t_pKernel32 != NULL)
                {
                    // See if the function is available...
                    if(t_pKernel32->GetDiskFreeSpaceEx(t_DiskDevice, &t_AvailableQuotaBytes, &t_TotalBytes, &t_AvailableBytes, &t_Status))
                    {   // The function exists.
					    if ( t_Status ) // The call result was TRUE.
					    {
						    _stprintf ( t_TotalBytesString , _T("%I64d"), t_TotalBytes.QuadPart ) ;
						    a_Instance->SetCHString ( IDS_Size , t_TotalBytesString ) ;
						    t_SizeFound = TRUE ;
					    }
                    }
                    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, t_pKernel32);
                    t_pKernel32 = NULL;
                }

		/*
		 *	If we couldn't get extended info -- use old API
		 *  (known to be inaccurate on Win95 for >2G drives)
		 */
				if ( ! t_SizeFound )
				{
					DWORD t_SectorsPerCluster ;
					DWORD t_BytesPerSector ;
					DWORD t_FreeClusters ;
					DWORD t_TotalClusters ;

					t_Status = GetDiskFreeSpace (

						t_DiskDevice ,
						& t_SectorsPerCluster,
						& t_BytesPerSector,
						& t_FreeClusters,
						& t_TotalClusters
					) ;

					if ( t_Status )
					{
						t_TotalBytes.QuadPart = (DWORDLONG) t_BytesPerSector * (DWORDLONG) t_SectorsPerCluster * (DWORDLONG) t_TotalClusters ;
						_stprintf( t_TotalBytesString , _T("%I64d"), t_TotalBytes.QuadPart ) ;
						a_Instance->SetCHString ( IDS_Size , t_TotalBytesString ) ;
					}
					else
					{
						DWORD t_LastError = GetLastError () ;
					}

				}
			}
		}
		else
		{
			DWORD t_LastError = GetLastError () ;

//			if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
//			{
//				a_Instance->SetCharSplat ( IDS_Status , IDS_STATUS_Unknown ) ;
//			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIALOADED )
			{
				a_Instance->Setbool ( IDS_MediaLoaded , false ) ;
			}
		}
	}


	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ProfileDrive
 *
 *  DESCRIPTION : Determins how fast a drive can be read, in Kilobytes/second.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : KBPS/sec read
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

DOUBLE CWin32CDROM :: ProfileDrive ( CHString &a_VolumeName )
{
    CCdTest t_Cd ;
    DOUBLE t_TransferRate = -1;

    // Need to find a file of adequate size for use in profiling:

    CHString t_TransferFile = GetTransferFile ( a_VolumeName ) ;

    if ( ! t_TransferFile.IsEmpty () )
    {
	    if ( t_Cd.ProfileDrive ( t_TransferFile ) )
        {
            t_TransferRate = t_Cd.GetTransferRate();
        }
    }

    return t_TransferRate ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::TestDriveIntegrity
 *
 *  DESCRIPTION : Confirms that data can be read from the drive reliably
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : nichts
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32CDROM::TestDriveIntegrity ( CHString &a_VolumeName, CHString &a_IntegrityFile)
{
    CCdTest t_Cd ;

    a_IntegrityFile = GetIntegrityFile ( a_VolumeName ) ;
    if ( ! a_IntegrityFile.IsEmpty () )
    {
        return ( t_Cd.TestDriveIntegrity ( a_IntegrityFile ) ) ;
    }

    return FALSE;
}

DWORD CWin32CDROM::GetBitMask(CFrameworkQuery &a_Query)
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( _T("ProtocolSupported") ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSITargetId ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSITARGETID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSIBus ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSIBUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSILogicalUnit ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSILUN ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSIPort ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSIPORT ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSITargetId ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSITARGETID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Drive ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DRIVE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Id ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_ID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Capabilities ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPABILITY ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaType ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIATYPE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaLoaded ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIALOADED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_VOLUMENAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MaximumComponentLength ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MAXCOMPONENTLENGTH ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_FileSystemFlags ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_FILESYSTEMFLAGS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_FileSystemFlagsEx ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_FILESYSTEMFLAGSEX ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeSerialNumber ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SERIALNUMBER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Size ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SIZE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_TransferRate ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_TEST_TRANSFERRATE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_DriveIntegrity ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_TEST_INTEGRITY ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\w2k\scsi.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  w2k\scsi.cpp
//
//  Purpose: scsi controller property set provider
//
//***************************************************************************

#include "precomp.h"

#include <winbase.h>
#include <winioctl.h>
#include <ntddscsi.h>

#include "..\scsi.h"

#include <comdef.h>

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_SCSICONTROLLER L"SCSIAdapter"

CWin32_ScsiController s_ScsiController ( PROPSET_NAME_SCSICONTROLLER , IDS_CimWin32Namespace );

/*
 *	Note QueryDosDevice doesn't allow us to get the actual size of the buffer.
 *	We would have to call the underlying OS api ( NtQueryDevice.... ) to do it
 *	properly. The buffers should be large enough however.
 */

#define SCSIPORT_MAX 0x4000

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::CWin32_ScsiController
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_ScsiController :: CWin32_ScsiController (LPCTSTR a_Name,
	                                            LPCTSTR a_Namespace)
: Provider(a_Name, a_Namespace)
{
	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::~CWin32_ScsiController
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_ScsiController :: ~CWin32_ScsiController()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController :: GetObject ( CInstance *a_Instance, long a_Flags, CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND;
    CConfigManager t_ConfigManager;

    // Let's see if config manager recognizes this device at all
    CHString t_Key;
    a_Instance->GetCHString( IDS_DeviceID , t_Key);

    CConfigMgrDevicePtr t_pDevice;

	if(t_ConfigManager.LocateDevice(t_Key , &t_pDevice))
    {
        //Ok, it knows about it.  Is it a scsi controller?
        if(IsOneOfMe( t_pDevice ) )
        {
			CHString t_DeviceId;
			if( t_pDevice->GetPhysicalDeviceObjectName( t_DeviceId ) )
			{
				TCHAR *t_DosDeviceNameList = NULL ;

				try
				{
					if ( QueryDosDeviceNames(t_DosDeviceNameList) )
					{
						UINT64     t_SpecifiedProperties = GetBitmap(a_Query);

						t_Result = LoadPropertyValues(&W2K_SCSI_LPVParms(a_Instance,
																		 t_pDevice ,
																		 t_DeviceId ,
																		 t_DosDeviceNameList,
																		 t_SpecifiedProperties));

						delete t_DosDeviceNameList;
						t_DosDeviceNameList = NULL ;
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				catch( ... )
				{
					if( t_DosDeviceNameList )
					{
						delete t_DosDeviceNameList ;
					}
					throw ;
				}
			}
        }
    }
    return t_Result ;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result ;
	t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_ScsiController :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    UINT64     t_SpecifiedProperties = GetBitmap(a_Query);

	//if ( t_SpecifiedProperties ) //removed since would result in no query being executed if no special properties were selected.
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController :: Enumerate ( MethodContext *a_pMethodContext , long a_Flags , UINT64 a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;
	TCHAR *t_DosDeviceNameList = NULL ;
	CConfigManager t_ConfigManager ;
	CDeviceCollection t_DeviceList ;

	try
	{
		if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
		{
		// While it might be more performant to use FilterByGuid, it appears that at least some
		// 95 boxes will report InfraRed info if we do it this way.
			if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_SCSICONTROLLER ) )
			{
				REFPTR_POSITION t_Position ;
				if( t_DeviceList.BeginEnum ( t_Position ) )
				{
					// smart ptrs
					CConfigMgrDevicePtr t_pDevice;
					CInstancePtr		t_pInst;

					t_Result = WBEM_S_NO_ERROR ;

					// Walk the list
					for (t_pDevice.Attach(t_DeviceList.GetNext ( t_Position ));
						 SUCCEEDED( t_Result ) && (t_pDevice != NULL);
						 t_pDevice.Attach(t_DeviceList.GetNext ( t_Position )))
					{
						// Now to find out if this is the scsi controller
						if(IsOneOfMe( t_pDevice ) )
						{
							t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

							CHString t_DeviceId ;
							if( t_pDevice->GetPhysicalDeviceObjectName ( t_DeviceId ) )
							{
								if( SUCCEEDED( t_Result =
									LoadPropertyValues(	&W2K_SCSI_LPVParms(	t_pInst,
																			t_pDevice,
																			t_DeviceId,
																			t_DosDeviceNameList,
																			a_SpecifiedProperties ) ) ) )
								{
									// Derived classes (like CW32SCSICntrlDev) may commit as result of call to LoadPropertyValues,
									// so check if we should -> only do so if we are of this class's type.
									if( ShouldBaseCommit( NULL ) )
									{
										t_Result = t_pInst->Commit();
									}
								}
							}
							else
							{
								t_Result = WBEM_E_PROVIDER_FAILURE;
							}
						}
					}
					// Always call EndEnum().  For all Beginnings, there must be an End
					t_DeviceList.EndEnum();
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}
	catch( ... )
	{
		// NOTE: EndEnum is not needed here. When t_DeviceList goes out of scope it will release a mutex.
		// same as .EndEnum
		if( t_DosDeviceNameList )
		{
			delete t_DosDeviceNameList ;
		}

		throw ;
	}

	delete t_DosDeviceNameList ;
	t_DosDeviceNameList = NULL ;

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_ScsiController::LoadPropertyValues(void* pv)
{
	// Unpack and confirm our parameters...
    W2K_SCSI_LPVParms* pData = (W2K_SCSI_LPVParms*)pv;
    CInstance* a_Instance = (CInstance*)(pData->m_pInstance);  // This instance released by caller
    CConfigMgrDevice* a_Device = (CConfigMgrDevice*)(pData->m_pDevice);
    CHString a_DeviceName = (CHString)(pData->m_chstrDeviceName);
    TCHAR* a_DosDeviceNameList = (TCHAR*)(pData->m_tstrDosDeviceNameList);
    UINT64 a_SpecifiedProperties = (UINT64)(pData->m_ui64SpecifiedProperties);
    if(a_Instance == NULL || a_Device == NULL) return WBEM_E_PROVIDER_FAILURE;

    HRESULT t_Result = LoadConfigManagerPropertyValues ( a_Instance , a_Device , a_DeviceName , a_SpecifiedProperties ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SpecifiedProperties & SPECIAL_SCSI )
		{
			CHString t_DosDeviceName ;
			t_Result = GetDeviceInformation ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList , a_SpecifiedProperties ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = LoadMediaPropertyValues ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_SpecifiedProperties ) ;
			}
			else
			{
				t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
			}
		}
	}
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::LoadConfigManagerPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_ScsiController :: LoadConfigManagerPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	UINT64 a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

    if ( a_SpecifiedProperties & SPECIAL_PROPS_DRIVERNAME )
    {
        CHString t_DriverName;

        if ( a_Device->GetService( t_DriverName ) )
        {
            a_Instance->SetCHString (IDS_DriverName, t_DriverName ) ;
        }
    }

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
	{
	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported , 2 ) ;
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController :: GetDeviceInformation
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController :: GetDeviceInformation (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	CHString a_DeviceName ,
	CHString &a_DosDeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	UINT64 a_SpecifiedProperties
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_CreatedSymbolicLink = FALSE ;

	CHString t_SymbolicLinkName ;

	try
	{
		BOOL t_Status = FindDosDeviceName ( a_DosDeviceNameList , a_DeviceName , t_SymbolicLinkName ) ;
		if ( ! t_Status )
		{
			t_SymbolicLinkName = CHString ( L"WMI_SCSICONTROLLERDEVICE_SYBOLICLINK" ) ;
			EnterCriticalSection ( & m_CriticalSection ) ;
			t_Status = DefineDosDevice ( DDD_RAW_TARGET_PATH , t_SymbolicLinkName , a_DeviceName ) ;
			LeaveCriticalSection ( & m_CriticalSection ) ;
			if ( t_Status )
			{
				t_CreatedSymbolicLink = TRUE ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				DWORD t_LastError = GetLastError () ;
			}
		}

	#if 0
		if ( t_Status )
		{
			CHString t_Device = CHString ( L"\\\\.\\" ) + t_SymbolicLinkName ;

			HANDLE t_Handle = CreateFile (

				t_Device,
				GENERIC_READ | GENERIC_WRITE ,
				FILE_SHARE_READ | FILE_SHARE_WRITE ,
				NULL,
				OPEN_EXISTING,
				0,
				NULL
			);

			if ( t_Handle != INVALID_HANDLE_VALUE )
			{
		/*
		 * Get SCSI information (IDE drives are still
		 * controlled by subset of SCSI miniport)
		 */

				if ( a_SpecifiedProperties & SPECIAL_SCSIINFO )
				{
					DWORD t_BytesReturned ;
					ULONG t_Return = 0;

					SCSI_ADAPTER_BUS_INFO *t_DeviceInfo = ( SCSI_ADAPTER_BUS_INFO * ) new UCHAR [ SCSIPORT_MAX ] ;
					ZeroMemory ( t_DeviceInfo , SCSIPORT_MAX ) ;

					t_Status = DeviceIoControl (

						t_Handle ,
						IOCTL_SCSI_GET_INQUIRY_DATA ,
						NULL ,
						0 ,
						t_DeviceInfo  ,
						SCSIPORT_MAX ,
						& t_BytesReturned ,
						NULL
					) ;

					if ( t_Status )
					{

						ULONG t_NumberOfBuses = t_DeviceInfo->NumberOfBuses ;
						a_Instance->SetDWORD ( IDS_ECC , ( DWORD )t_NumberOfBuses ) ;
					}
				}

				CloseHandle ( t_Handle ) ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				DWORD t_Error = GetLastError () ;
			}
		}
	#endif

		if ( t_CreatedSymbolicLink )
		{
			EnterCriticalSection ( & m_CriticalSection ) ;
			BOOL t_Status = DefineDosDevice ( /* DDD_EXACT_MATCH_ON_REMOVE | */ DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
			LeaveCriticalSection ( & m_CriticalSection ) ;
			if ( ! t_Status )
			{
				//t_Result = WBEM_E_PROVIDER_FAILURE ;

				DWORD t_LastError = GetLastError () ;
			}
		}

		return t_Result ;
	}
	catch( ... )
	{
		if ( t_CreatedSymbolicLink )
		{
			EnterCriticalSection ( & m_CriticalSection ) ;
			DefineDosDevice ( /* DDD_EXACT_MATCH_ON_REMOVE | */ DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
			LeaveCriticalSection ( & m_CriticalSection ) ;
		}

		throw ;
	}
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController :: LoadMediaPropertyValues
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController::LoadMediaPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const CHString &a_DosDeviceName ,
	UINT64 a_SpecifiedProperties
)
{

	HRESULT t_Result = S_OK ;

/*
 *
 */
    // Set common drive properties
    //=============================

	CHString t_DeviceLabel = CHString ( a_DosDeviceName ) ;

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DRIVE )
	{
	    if(t_DeviceLabel.GetLength() != 0) a_Instance->SetCharSplat ( IDS_Drive, t_DeviceLabel ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_ID )
	{
		if(t_DeviceLabel.GetLength() != 0) a_Instance->SetCharSplat ( IDS_Id, t_DeviceLabel ) ;
	}
    /* Capability is not a property of this class at this time...
	if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPABILITY )
	{
		// Create a safearray for the Capabilities information

		SAFEARRAYBOUND t_ArrayBounds ;

		t_ArrayBounds.cElements = 2;
		t_ArrayBounds.lLbound = 0;

		SAFEARRAY *t_SafeArray = NULL ;

		if ( t_SafeArray = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
		{
			long t_Capability = 3 ;
			long t_Index = 0;
			SafeArrayPutElement ( t_SafeArray , & t_Index , & t_Capability) ;

			t_Index = 1;
			t_Capability = 7 ;
			SafeArrayPutElement ( t_SafeArray , & t_Index , & t_Capability ) ;

			VARIANT t_CapabilityValue ;
			VariantInit( & t_CapabilityValue ) ;

			V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;
			V_ARRAY ( & t_CapabilityValue ) = t_SafeArray ;

			a_Instance->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;

			VariantClear ( & t_CapabilityValue ) ;
		}
	}
    */

	if ( a_SpecifiedProperties & ( SPECIAL_PROPS_AVAILABILITY || SPECIAL_PROPS_STATUS || SPECIAL_PROPS_STATUSINFO ) )
	{
        CHString t_sStatus;
		if ( a_Device->GetStatus ( t_sStatus ) )
		{
			if (t_sStatus == IDS_STATUS_Degraded)
            {
				a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
				a_Instance->SetWBEMINT16 ( IDS_Availability , 10 ) ;
            }
            else if (t_sStatus == IDS_STATUS_OK)
            {

				a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
				a_Instance->SetWBEMINT16 ( IDS_Availability,  3 ) ;
            }
            else if (t_sStatus == IDS_STATUS_Error)
            {
				a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 4 ) ;
				a_Instance->SetWBEMINT16 ( IDS_Availability , 4 ) ;
            }
            else
            {
				a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 2 ) ;
				a_Instance->SetWBEMINT16 ( IDS_Availability , 2 ) ;
            }

            a_Instance->SetCHString(IDS_Status, t_sStatus);
        }
	}

	return t_Result ;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of SCSI device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid USB class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32_ScsiController::IsOneOfMe(void* pv)
{
    bool fRet = false;

    if(pv != NULL)
    {
        CConfigMgrDevice* pDevice = (CConfigMgrDevice*) pv;
        // Ok, it knows about it.  Is it a usb device?
        if(pDevice->IsClass(CONFIG_MANAGER_CLASS_SCSICONTROLLER) )
        {
            fRet = true;
        }
    }
    return fRet;
}

DWORD CWin32_ScsiController::GetBitmap(CFrameworkQuery &a_Query)
{

    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_StatusInfo ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUSINFO ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Drive ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DRIVE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Id ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_ID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Capabilities ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPABILITY ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Availability ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_AVAILABILITY ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    if (a_Query.IsPropertyRequired (IDS_DriverName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_DRIVERNAME;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\connectiontosession.cpp ===
/******************************************************************

   ConnectionToSession.CPP -- C provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Association between Connection To Session  
   

******************************************************************/

#include "precomp.h"
#include "ConnectionToSession.h"

CConnectionToSession MyCConnectionToSession ( 

	PROVIDER_NAME_CONNECTIONTOSESSION , 
	Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CConnectionToSession::CConnectionToSession
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CConnectionToSession :: CConnectionToSession (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CConnectionToSession::~CConnectionToSession
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CConnectionToSession :: ~CConnectionToSession ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CConnectionToSession :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{	
 	HRESULT hRes = WBEM_S_NO_ERROR ;
	DWORD dwPropertiesReq = CONNECTIONSTOSESSION_ALL_PROPS;

	hRes = EnumConnectionInfo ( 
				L"",
				L"",
				pMethodContext,
				dwPropertiesReq
			);

    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CConnectionToSession :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CHString t_Connection ;
	CHString t_Session;


    if  ( pInstance->GetCHString ( IDS_Connection , t_Connection ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_Session , t_Session ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}
   
	if ( SUCCEEDED ( hRes ) )
	{
		CHString t_ConnComputerName;
		CHString t_ConnShareName;
		CHString t_ConnUserName;

		hRes = GetConnectionsKeyVal ( t_Connection, t_ConnComputerName, t_ConnShareName, t_ConnUserName );

		if ( SUCCEEDED ( hRes ) )
		{
			CHString t_SessComputerName;
			CHString t_SessUserName;

			hRes = GetSessionKeyVal ( t_Session, t_SessComputerName, t_SessUserName );

			if ( SUCCEEDED ( hRes ) )
			{
				// now check the shares in t_Connection and t_Session  should match
				hRes = _wcsicmp ( t_ConnComputerName, t_SessComputerName ) == 0 ? hRes : WBEM_E_NOT_FOUND;

				if ( SUCCEEDED ( hRes ) )
				{
					hRes = _wcsicmp ( t_ConnUserName, t_SessUserName ) == 0 ? hRes : WBEM_E_NOT_FOUND;

					if ( SUCCEEDED ( hRes ) )
					{
#ifdef NTONLY
						hRes = FindAndSetNTConnection ( t_ConnShareName.GetBuffer(0), t_ConnComputerName, t_ConnUserName, 
										0, pInstance, NoOp );
#endif

#if 0
#ifdef WIN9XONLY
						hRes = FindAndSet9XConnection ( t_ConnShareName, t_ConnComputerName, t_ConnUserName, 
										0, pInstance, NoOp );
#endif
#endif
					}
				}
			}
		}
	}

    return hRes ;
}

#ifdef NTONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::EnumNTConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/
HRESULT  CConnectionToSession :: EnumNTConnectionsFromComputerToShare ( 

	LPWSTR a_ComputerName,
	LPWSTR a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;
	DWORD   dwResumeHandle = 0;	

	CONNECTION_INFO  *pBuf = NULL;
	CONNECTION_INFO  *pTmpBuf = NULL;
	LPWSTR t_ComputerName = NULL;

	if ( a_ComputerName && a_ComputerName[0] != L'\0' )
	{
		//let's skip the \\ chars
		t_ComputerName = a_ComputerName + 2;
	}
	
    // ShareName and Computer Name both cannot be null at the same time
	while ( TRUE )
	{
		if ( a_ShareName[0] != L'\0' )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ShareName, 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
				
		}
		else
		if ( a_ComputerName[0] != L'\0' )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ComputerName, 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
		}

		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == 0 ) )
			break;
			
		if ( dwNoOfEntriesRead > 0 )
		{
			try
			{
				pTmpBuf = pBuf;
	
				for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf++ )
				{
                    if (pTmpBuf->coni1_netname && pBuf->coni1_username)
                    {
						CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), FALSE);
				    
					    hRes = LoadInstance ( pInstance, a_ShareName, t_ComputerName ? t_ComputerName : a_ComputerName, pTmpBuf, dwPropertiesReq );

					    if ( SUCCEEDED ( hRes ) )
					    {
						    hRes = pInstance->Commit();
					    }
                    }
				}
			}
			catch ( ... )
			{
				NetApiBufferFree ( pBuf );
				pBuf = NULL;
				throw;
			}
			NetApiBufferFree ( pBuf );
			pBuf = NULL;
		}

		if ( t_Status != ERROR_MORE_DATA )
		{
			break;
		}
	}

	return hRes;
}
#endif

#if 0
#ifdef WIN9XONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::Enum9XConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/
HRESULT  CConnectionToSession :: Enum9XConnectionsFromComputerToShare ( 

	LPWSTR a_ComputerName,
	LPWSTR a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;

	BOOL bFound = FALSE;

    CONNECTION_INFO * pBuf = NULL;
    CONNECTION_INFO * pTmpBuf = NULL;

    DWORD dwBufferSize =   MAX_ENTRIES * sizeof( CONNECTION_INFO  );

    pBuf = ( CONNECTION_INFO  *) malloc(dwBufferSize);

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = 	NetConnectionEnum( 
								NULL, 
								(char FAR *) ( a_ShareName ),  // ShareName
								1, 
								(char *) pBuf, 
								( unsigned short )dwBufferSize, 
								( unsigned short *) &dwNoOfEntriesRead, 
								( unsigned short *) &dwTotalConnections 
						);	
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}
		// otherwise we are not to frr the buffer, we have use it and then free the buffer.
		if ( ( dwNoOfEntriesRead < dwTotalConnections ) && ( t_Status == ERROR_MORE_DATA ) )
		{
			free ( pBuf );
			pBuf = NULL;

			pBuf = ( CONNECTION_INFO  *) malloc( dwTotalConnections );

			if ( pBuf != NULL ) 
			{
				try
				{
					t_Status = 	NetConnectionEnum( 
									NULL, 
									(char FAR *) ( a_ShareName ),  // ShareName
									1, 
									(char *) pBuf, 
									( unsigned short )dwBufferSize, 
									( unsigned short *) &dwNoOfEntriesRead, 
									( unsigned short *) &dwTotalConnections 
								);	
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;				
				}
				// We need to use the buffer before we free it
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		// The buffer  is yet to be used
		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == dwTotalConnections ) )
		{
			// use the buffer first and then free 
			if ( pBuf != NULL )
			{
				try
				{
					pTmpBuf = pBuf;
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf ++)
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadInstance ( pInstance, a_ShareName, a_ComputerName, pTmpBuf, dwPropertiesReq );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();
							if ( FAILED ( hRes ) )
							{
								break;
							}
						}
					}
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;
				}
				// finally free the buffer
				free (pBuf );
				pBuf = NULL;
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return hRes;
}
#endif
#endif

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession:: LoadInstance
*
*  DESCRIPTION :    Loading an instance with the connection to Session info 
*
*****************************************************************************/
HRESULT CConnectionToSession :: LoadInstance ( 
																				
	CInstance *pInstance,
	LPCWSTR a_Share, 
	LPCWSTR a_Computer,
	CONNECTION_INFO *pBuf, 
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	LPWSTR ObjPath = NULL;
	LPWSTR SessObjPath = NULL;

	try
	{
		CHString t_NetName ( pBuf->coni1_netname );

		if ( a_Share[0] != L'\0' )
		{	
			hRes = MakeObjectPath ( ObjPath,  PROVIDER_NAME_CONNECTION, 	IDS_ComputerName, t_NetName );
			if ( SUCCEEDED ( hRes ) )
			{
				hRes = AddToObjectPath ( ObjPath, IDS_ShareName, a_Share );
			}
			if ( SUCCEEDED ( hRes ) )
			{
				hRes = MakeObjectPath ( SessObjPath, PROVIDER_NAME_SESSION, IDS_ComputerName, t_NetName );
			}
		}
		else
		{
			hRes = MakeObjectPath ( ObjPath,  PROVIDER_NAME_CONNECTION, 	IDS_ComputerName, a_Computer  );
			if ( SUCCEEDED ( hRes ) )
			{
				hRes = AddToObjectPath ( ObjPath, IDS_ShareName, t_NetName );
			}
			if ( SUCCEEDED ( hRes ) )
			{
				MakeObjectPath ( SessObjPath, PROVIDER_NAME_SESSION, IDS_ComputerName, a_Computer);
			}
		}

		CHString t_UserName ( pBuf->coni1_username );

		if ( SUCCEEDED ( hRes ) )
		{
			hRes = AddToObjectPath ( ObjPath, IDS_UserName, t_UserName );
		}

		if ( SUCCEEDED ( hRes ) )
		{
			hRes = AddToObjectPath ( SessObjPath, IDS_UserName, t_UserName );
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( pInstance->SetCHString ( IDS_Connection, ObjPath ) == FALSE )
			{
				hRes =  WBEM_E_PROVIDER_FAILURE ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( pInstance->SetCHString ( IDS_Session, SessObjPath ) == FALSE )
			{
				hRes = WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}
	catch (...)
	{
		if (SessObjPath)
		{
			delete [] SessObjPath;
			SessObjPath = NULL;
		}

		if (ObjPath)
		{
			delete [] ObjPath;
			ObjPath = NULL;
		}

		throw;
	}

	if (SessObjPath)
	{
		delete [] SessObjPath;
		SessObjPath = NULL;
	}

	if (ObjPath)
	{
		delete [] ObjPath;
		ObjPath = NULL;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::GetSessionKeyVal
*
*  DESCRIPTION :    Parsing the key to get Connection Key Value
*
*****************************************************************************/
HRESULT CConnectionToSession::GetSessionKeyVal ( 
												 
	LPCWSTR a_Key, 
	CHString &a_ComputerName, 
	CHString &a_UserName 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	ParsedObjectPath *t_ObjPath;
	CObjectPathParser t_PathParser;

	DWORD dwAllKeys = 0;

    if ( t_PathParser.Parse( a_Key, &t_ObjPath ) == t_PathParser.NoError )
	{
		try
		{
			hRes  = t_ObjPath->m_dwNumKeys != 2 ? WBEM_E_INVALID_PARAMETER : hRes;

			if ( SUCCEEDED ( hRes ) )
			{
				hRes = _wcsicmp ( t_ObjPath->m_pClass, PROVIDER_NAME_SESSION ) != 0 ? WBEM_E_INVALID_PARAMETER : hRes;

				if ( SUCCEEDED ( hRes ) )
				{
					for ( int i = 0; i < 2; i++ )
					{
                        if (V_VT(&t_ObjPath->m_paKeys[i]->m_vValue) == VT_BSTR)
                        {
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_ComputerName ) == 0 )
						    {
							    a_ComputerName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 1;							
						    }
						    else
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_UserName ) == 0 )
						    {
							    a_UserName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 2;
						    }
                        }
					}
					if ( dwAllKeys != 3 )
					{
						hRes = WBEM_E_INVALID_PARAMETER;
					}
				}
				else
				{
					hRes = WBEM_E_INVALID_PARAMETER;
				}
			}
		}
		catch ( ... )
		{
			delete t_ObjPath;
			throw;
		}
		delete t_ObjPath;
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\connection.cpp ===
/******************************************************************

   Connection.CPP -- C provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description:  Connection Provider
  
******************************************************************/

//#include <windows.h>
#include "precomp.h"
#include "Connection.h"

CConnection MyCConnection ( 

	PROVIDER_NAME_CONNECTION , 
	Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CConnection::CConnection
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CConnection :: CConnection (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CConnection::~CConnection
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CConnection :: ~CConnection ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CConnection::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CConnection :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
 	HRESULT hRes = WBEM_S_NO_ERROR;

	DWORD dwPropertiesReq = CONNECTIONS_ALL_PROPS;

	// Passing empty string to indicate no NULL computer name and shareName
	hRes = EnumConnectionInfo ( 
						L"",
						L"",
						pMethodContext,
						dwPropertiesReq
				 );

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnection::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CConnection :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ShareName ;
	CHString t_ComputerName;
	CHString t_UserName;

    if  ( pInstance->GetCHString ( IDS_ShareName , t_ShareName ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_ComputerName , t_ComputerName ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_UserName , t_UserName ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		DWORD dwPropertiesReq;

		hRes = WBEM_E_NOT_FOUND;

		if ( Query.AllPropertiesAreRequired() )
		{
			dwPropertiesReq = CONNECTIONS_ALL_PROPS;
		}
		else
		{
			SetPropertiesReq ( Query, dwPropertiesReq );
		}

#ifdef NTONLY
		hRes = FindAndSetNTConnection ( t_ShareName.GetBuffer(0), t_ComputerName, t_UserName, dwPropertiesReq, pInstance, Get );
#endif

#if 0
#ifdef WIN9XONLY
		hRes = FindAndSet9XConnection ( t_ShareName, t_ComputerName, t_UserName, dwPropertiesReq, pInstance, Get );
#endif
#endif

	}
    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    :    CConnection::ExecQuery
*
*  DESCRIPTION :    Optimization of a query only on one of the key values
*
*****************************************************************************/

HRESULT CConnection :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwPropertiesReq;
	DWORD t_Size;

	if ( Query.AllPropertiesAreRequired() )
	{
		dwPropertiesReq = CONNECTIONS_ALL_PROPS;
	}
	else
	{
		SetPropertiesReq ( Query, dwPropertiesReq );
	}

	CHStringArray t_ShareValues;
	CHStringArray t_ComputerValues;

	// Connections can be enumerated to the shares or the connections made from the computer only on one key value we can optimize
	// Otherwise we will need to take both the set of instances, take the union of the two sets and then commit.
	// Implmenting only if one of the two keyvalues Sharename or Computername is specified.
	hRes = Query.GetValuesForProp(
			 IDS_ShareName,
			 t_ShareValues
		   );

	hRes = Query.GetValuesForProp(
			 IDS_ComputerName,
			 t_ComputerValues
		   );

	if ( SUCCEEDED ( hRes ) )
	{
		hRes = OptimizeQuery ( t_ShareValues, t_ComputerValues, pMethodContext, dwPropertiesReq );
	}

	return hRes;
}

#ifdef NTONLY

/*****************************************************************************
*
*  FUNCTION    :    CConnection::EnumNTConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/
HRESULT  CConnection :: EnumNTConnectionsFromComputerToShare ( 

	LPWSTR a_ComputerName,
	LPWSTR a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;
	DWORD   dwResumeHandle = 0;	

	CONNECTION_INFO  *pBuf = NULL;
	CONNECTION_INFO  *pTmpBuf = NULL;
	LPWSTR t_ComputerName = NULL;

	if ( a_ComputerName && a_ComputerName[0] != L'\0' )
	{
		//let's skip the \\ chars
		t_ComputerName = a_ComputerName + 2;
	}
	
    // ShareName and COmputer Name both cannot be null at the same time
	while ( TRUE )
	{
		if ( a_ShareName[0] != L'\0' )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ShareName, 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
				
		}
		else
		if ( a_ComputerName[0] != L'\0' )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ComputerName, 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
		}

		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == 0 ) )
			break;
			
		if ( dwNoOfEntriesRead > 0 )
		{
			try
			{
				pTmpBuf = pBuf;
	
				for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf++ )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
				
					hRes = LoadInstance ( pInstance, a_ShareName, t_ComputerName ? t_ComputerName : a_ComputerName, pTmpBuf, dwPropertiesReq );

					if ( SUCCEEDED ( hRes ) )
					{
						hRes = pInstance->Commit();
						if ( FAILED ( hRes ) )
						{
							break;
						}
					}
				}
			}
			catch ( ... )
			{
				NetApiBufferFree ( pBuf );
				pBuf = NULL;
				throw;
			}
			NetApiBufferFree ( pBuf );
			pBuf = NULL;
		}

		if ( t_Status != ERROR_MORE_DATA )
		{
			break;
		}
	}

	return hRes;
}

#endif //NTONLY

#if 0
#ifdef WIN9XONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnection::Enum9XConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/

Coonnections on win9x is broken, since it cannot return a sharename and it is a part of the 
key.

HRESULT  CConnection :: Enum9XConnectionsFromComputerToShare ( 

	LPWSTR a_ComputerName,
	LPWSTR a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	USHORT dwNoOfEntriesRead = 0;
	USHORT dwTotalConnections = 0;

	BOOL bFound = FALSE;

    CONNECTION_INFO * pBuf = NULL;
    CONNECTION_INFO * pTmpBuf = NULL;

    unsigned short dwBufferSize =   MAX_ENTRIES * sizeof( CONNECTION_INFO  );

    pBuf =  ( CONNECTION_INFO *) malloc(dwBufferSize);

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = 	NetConnectionEnum( 
								NULL, 
								TOBSTRT ( a_ShareName ),  // ShareName
								( short ) 1, 
								(char FAR *) pBuf, 
								dwBufferSize, 
								&dwNoOfEntriesRead, 
								&dwTotalConnections 
						);	
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}
		// otherwise we are not to frr the buffer, we have use it and then free the buffer.
		if ( ( dwNoOfEntriesRead < dwTotalConnections ) && ( t_Status == ERROR_MORE_DATA ) )
		{
			free ( pBuf );
			pBuf = NULL;

			dwBufferSize = dwTotalConnections * sizeof( CONNECTION_INFO  );
			pBuf = ( CONNECTION_INFO *) malloc( dwBufferSize );
			
			if ( pBuf != NULL ) 
			{
				try
				{
					t_Status = 	NetConnectionEnum( 
									NULL, 
									TOBSTRT( a_ShareName),  // ShareName
									( short ) 1, 
									(char FAR *) pBuf, 
									dwBufferSize, 
									&dwNoOfEntriesRead, 
									&dwTotalConnections 
								);	
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;
				}
				// We need to use the buffer before we free it
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );;
			}
		}

		// The buffer  is yet to be used
		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == dwTotalConnections ) )
		{
			// use the buffer first and then free 
			if ( pBuf != NULL )
			{
				try
				{
					pTmpBuf = pBuf;
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf ++)
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadInstance ( pInstance, a_ShareName, a_ComputerName, pTmpBuf, dwPropertiesReq );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();
					
							if ( FAILED ( hRes ) )
							{
								break;
							}
						}
						else
						{
							break;
						}
					}
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;
				}
				// finally free the buffer
				free (pBuf );
				pBuf = NULL;
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
	}

	return hRes;
}
#endif
#endif

/*****************************************************************************
*
*  FUNCTION    :    CConnection:: LoadInstance
*
*  DESCRIPTION :    Loading an instance with the connection info 
*
*****************************************************************************/

HRESULT CConnection :: LoadInstance ( 
										  
	CInstance *pInstance, 
	LPCWSTR a_Share, 
	LPCWSTR a_Computer, 
	CONNECTION_INFO *pBuf, 
	DWORD dwPropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;	

	if ( a_Share[0] != L'\0' )
	{	
		if ( dwPropertiesReq & CONNECTIONS_PROP_ShareName ) 
		{
			if ( pInstance->SetCharSplat ( IDS_ShareName, a_Share ) == FALSE )
			{
				hRes = WBEM_E_PROVIDER_FAILURE;
			}
		}

		if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ComputerName ) )
		{
			if ( pInstance->SetCharSplat ( IDS_ComputerName, pBuf->coni1_netname ) == FALSE )
			{
				hRes = WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}
	else
	{
		if ( dwPropertiesReq & CONNECTIONS_PROP_ComputerName ) 
		{
			if ( pInstance->SetCharSplat ( IDS_ComputerName, a_Computer ) == FALSE )
			{
				hRes =  WBEM_E_PROVIDER_FAILURE ;
			}
		}

		if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ShareName ) )
		{
			if ( pInstance->SetCharSplat ( IDS_ShareName, pBuf->coni1_netname ) == FALSE )
			{
				hRes =  WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}

	if ( SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_UserName ) )
	{
		if ( pInstance->SetCharSplat ( IDS_UserName, pBuf->coni1_username ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}

/*	if ( SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ConnectionType	 ) )
	{
		DWORD dwConnectionType;
		switch ( pBuf->coni1_type )
		{
			case STYPE_DISKTREE:	dwConnectionType = 0; break;
			case STYPE_PRINTQ:		dwConnectionType = 1; break;
			case STYPE_DEVICE:		dwConnectionType = 2; break;
			case STYPE_IPC:			dwConnectionType = 3; break;
			default:				dwConnectionType = 4; break;
		}

		if ( pInstance->SetWORD ( ConnectionType,  dwConnectionType ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}

	}
*/
	if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ConnectionID ) )
	{
		if ( pInstance->SetWORD ( IDS_ConnectionID,  pBuf->coni1_id ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}

	if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_NumberOfUsers ) )
	{
		if ( pInstance->SetWORD ( IDS_NumberOfUsers,  pBuf->coni1_num_users ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}


	if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_NumberOfFiles ) )
	{
		if ( pInstance->SetWORD ( IDS_NumberOfFiles,  pBuf->coni1_num_opens ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}

	if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ActiveTime	 ) )
	{
		if ( pInstance->SetWORD ( IDS_ActiveTime,  pBuf->coni1_time ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnection::OptimizeQuery
*
*  DESCRIPTION :    Optimizes a query based on the Key Values.
*
*****************************************************************************/

HRESULT CConnection::OptimizeQuery ( 
									  
	CHStringArray& a_ShareValues, 
	CHStringArray& a_ComputerValues, 
	MethodContext *pMethodContext, 
	DWORD dwPropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	if ( ( a_ShareValues.GetSize() == 0 ) && ( a_ComputerValues.GetSize() == 0 ) )
	{
		// This is a query for which there is no where clause, so it means only a few Properties are requested
		// hence we need to deliver only those properties of instances to the WinMgmt while enumerating connecctions
		hRes = EnumConnectionInfo ( 
						L"",
						L"",
						pMethodContext,
						dwPropertiesReq
					);
	}
	else
	if  ( a_ComputerValues.GetSize() != 0 ) 
	{
		CHString t_ComputerName; 
		for ( int i = 0; i < a_ComputerValues.GetSize(); i++ )
		{
			t_ComputerName.Format ( L"%s%s", L"\\\\", (LPCWSTR)a_ComputerValues.GetAt(i) );
	
			hRes = EnumConnectionInfo ( 
							t_ComputerName.GetBuffer(0),
							L"", // Share name is empty
							pMethodContext,
							dwPropertiesReq
					   );


			if ( FAILED ( hRes ) )
			{
				break;
			}	
		}
	}
	else
	if  ( a_ShareValues.GetSize() != 0 )  
	{
		for ( int i = 0; i < a_ShareValues.GetSize(); i++ )
		{
			hRes = EnumConnectionInfo ( 
							L"", 
							a_ShareValues.GetAt(i).GetBuffer(0),
							pMethodContext,
							dwPropertiesReq
					   );


			if ( FAILED ( hRes ) )
			{
				break;
			}	
		}
	}
	else
		hRes = WBEM_E_PROVIDER_NOT_CAPABLE;

	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CConnection::SetPropertiesReq
*
*  DESCRIPTION :    Setting a bitmap for the required properties
*
*****************************************************************************/

void CConnection :: SetPropertiesReq ( CFrameworkQuery &Query, DWORD &dwPropertiesReq )
{
	dwPropertiesReq = 0;

	if ( Query.IsPropertyRequired ( IDS_ComputerName ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_ComputerName;
	}

	if ( Query.IsPropertyRequired ( IDS_ShareName ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_ShareName;
	}

	if ( Query.IsPropertyRequired ( IDS_UserName ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_UserName;
	}

	if ( Query.IsPropertyRequired ( IDS_ActiveTime ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_ActiveTime;
	}
	
	if ( Query.IsPropertyRequired ( IDS_NumberOfUsers ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_NumberOfUsers;
	}

	if ( Query.IsPropertyRequired ( IDS_NumberOfFiles ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_NumberOfFiles;
	}

	if ( Query.IsPropertyRequired ( IDS_ConnectionID ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_ConnectionID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\w2k\tapedrive.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  w2k\tapedrive.cpp
//
//  Purpose: CDROM property set provider
//
//***************************************************************************

#include "precomp.h"

#include <winioctl.h>
#include <ntddscsi.h>
#include <ntddtape.h>

#include <dllutils.h>
#include <strings.h>

#include "..\tapedrive.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_TAPEDRIVE L"TAPEDRIVE"

CWin32TapeDrive s_TapeDrive ( PROPSET_NAME_TAPEDRIVE , IDS_CimWin32Namespace );

/*
 *	Note QueryDosDevice doesn't allow us to get the actual size of the buffer.
 *	We would have to call the underlying OS api ( NtQueryDevice.... ) to do it
 *	properly. The buffers should be large enough however.
 */


/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::CWin32TapeDrive
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32TapeDrive :: CWin32TapeDrive (

	LPCWSTR a_pszName,
	LPCWSTR a_pszNamespace

) : Provider ( a_pszName, a_pszNamespace )
{
	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::~CWin32TapeDrive
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32TapeDrive :: ~CWin32TapeDrive()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive :: GetObject ( CInstance *a_Inst, long a_Flags , CFrameworkQuery &a_Query )
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND ;

    CConfigManager t_ConfigManager ;

/*
 * Let's see if config manager recognizes this device at all
 */

    CHString t_Key ;
    a_Inst->GetCHString ( IDS_DeviceID , t_Key ) ;

    CConfigMgrDevice *t_Device = NULL;
    if ( t_ConfigManager.LocateDevice ( t_Key , & t_Device ) )
    {
/*
 * Ok, it knows about it.  Is it a CDROM device?
 */

        if ( t_Device->IsClass ( CONFIG_MANAGER_CLASS_TAPEDRIVE ) )
        {
			TCHAR *t_DosDeviceNameList = NULL ;
			if (QueryDosDeviceNames ( t_DosDeviceNameList ))
            {
                try
                {
			        CHString t_DeviceId ;
			        if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
			        {
                        UINT64 t_SpecifiedProperties = GetBitMask( a_Query );
				        t_hResult = LoadPropertyValues ( a_Inst, t_Device , t_DeviceId , t_DosDeviceNameList , t_SpecifiedProperties ) ;
			        }
                }
                catch ( ... )
                {
                    delete [] t_DosDeviceNameList ;
                    throw ;
                }

				delete [] t_DosDeviceNameList ;
            }
        }
    }

    return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_hResult ;
	t_hResult = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32TapeDrive :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_hResult = WBEM_E_FAILED ;

    UINT64 t_SpecifiedProperties = GetBitMask( a_Query );
	//if ( t_SpecifiedProperties ) //removed since would result in no query being executed if no special properties were selected.
	{
		t_hResult = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , UINT64 a_SpecifiedProperties )
{
    HRESULT t_hResult = WBEM_E_FAILED ;

	TCHAR *t_DosDeviceNameList = NULL ;
	if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
	{
		CConfigManager		t_ConfigManager ;
		CDeviceCollection	t_DeviceList ;
		CInstancePtr        t_pInst;
		CConfigMgrDevicePtr t_Device;

		/*
		*	While it might be more performant to use FilterByGuid, it appears that at least some
		*	95 boxes will report InfraRed info if we do it this way.
		*/

		if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_TAPEDRIVE ) )
		{
			try
			{
				REFPTR_POSITION t_Position ;

				if ( t_DeviceList.BeginEnum ( t_Position ) )
				{
					t_hResult = WBEM_S_NO_ERROR ;

					// Walk the list

					for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
						 SUCCEEDED ( t_hResult ) && ( NULL != t_Device );
						 t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
					{

						t_pInst.Attach(CreateNewInstance ( a_MethodContext ));
						CHString t_DeviceId ;
						if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
						{
							t_hResult = LoadPropertyValues ( t_pInst , t_Device , t_DeviceId , t_DosDeviceNameList , a_SpecifiedProperties ) ;
							if ( SUCCEEDED ( t_hResult ) )
							{
								t_hResult = t_pInst->Commit (  ) ;
							}
						}
						else
						{
							t_hResult = WBEM_E_PROVIDER_FAILURE ;
							LogErrorMessage(L"Failed to GetPhysicalDeviceObjectName");
						}
					}

					// Always call EndEnum().  For all Beginnings, there must be an End

					t_DeviceList.EndEnum();
				}
			}
			catch( ... )
			{
				t_DeviceList.EndEnum();

				if( t_DosDeviceNameList )
				{
					delete [] t_DosDeviceNameList ;
				}

				throw ;
			}

			delete [] t_DosDeviceNameList ;
			t_DosDeviceNameList = NULL ;

		}
	}
	else
	{
		t_hResult = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32TapeDrive :: LoadPropertyValues (

	CInstance *a_Inst,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	UINT64 a_SpecifiedProperties
)
{
	HRESULT t_hResult = LoadConfigManagerPropertyValues ( a_Inst , a_Device , a_DeviceName , a_SpecifiedProperties ) ;
	if ( SUCCEEDED ( t_hResult ) )
	{
		if ( a_SpecifiedProperties & (SPECIAL_MEDIA | SPECIAL_TAPEINFO) )
		{
			CHString t_DosDeviceName ;
			t_hResult = GetDeviceInformation ( a_Inst , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList , a_SpecifiedProperties ) ;
			if ( SUCCEEDED ( t_hResult ) && (a_SpecifiedProperties & SPECIAL_MEDIA) )
			{
				t_hResult = LoadMediaPropertyValues ( a_Inst , a_Device , a_DeviceName , t_DosDeviceName , a_SpecifiedProperties ) ;
			}
			else
			{
				t_hResult = ( t_hResult == WBEM_E_NOT_FOUND ) ? S_OK : t_hResult ;
			}
		}
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32TapeDrive :: LoadConfigManagerPropertyValues (

	CInstance *a_Inst ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	UINT64 a_SpecifiedProperties
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Inst ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & ( SPECIAL_PROPS_AVAILABILITY | SPECIAL_PROPS_STATUS | SPECIAL_PROPS_STATUSINFO ) )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				if (t_sStatus == IDS_STATUS_Degraded)
                {
					a_Inst->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
					a_Inst->SetWBEMINT16 ( IDS_Availability , 10 ) ;
                }
                else if (t_sStatus == IDS_STATUS_OK)
                {

				    a_Inst->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
				    a_Inst->SetWBEMINT16 ( IDS_Availability,  3 ) ;
                }
                else if (t_sStatus == IDS_STATUS_Error)
                {
				    a_Inst->SetWBEMINT16 ( IDS_StatusInfo , 4 ) ;
				    a_Inst->SetWBEMINT16 ( IDS_Availability , 4 ) ;
                }
                else
                {
					a_Inst->SetWBEMINT16 ( IDS_StatusInfo , 2 ) ;
					a_Inst->SetWBEMINT16 ( IDS_Availability , 2 ) ;
                }

                a_Inst->SetCHString(IDS_Status, t_sStatus);
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Inst->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Inst->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Inst->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Inst ) ;
	}

	if ( a_SpecifiedProperties & (SPECIAL_PROPS_DESCRIPTION | SPECIAL_PROPS_CAPTION | SPECIAL_PROPS_NAME) )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties &  SPECIAL_PROPS_DESCRIPTION)
			{
				a_Inst->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & (SPECIAL_PROPS_CAPTION | SPECIAL_PROPS_NAME) )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Inst->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Inst->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Inst->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Inst->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Inst->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_ID )
	{
		CHString t_ManufacturerFriendlyName ;

		if ( a_Device->GetFriendlyName ( t_ManufacturerFriendlyName ) )
		{
			a_Inst->SetCharSplat ( IDS_Id, t_ManufacturerFriendlyName ) ;
		}
	}


/*
 *	Fixed value from enumerated list
 */

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
//	{
//	    a_Inst->SetWBEMINT16 ( _T("ProtocolSupported") , 16 ) ;
//	}

    return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive :: GetDeviceInformation
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive :: GetDeviceInformation (

	CInstance *a_Inst ,
	CConfigMgrDevice *a_Device ,
	CHString a_DeviceName ,
	CHString &a_DosDeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	UINT64 a_SpecifiedProperties
)
{
	HRESULT t_hResult = S_OK ;
	BOOL t_CreatedSymbolicLink = FALSE ;

	CHString t_SymbolicLinkName ;
	BOOL t_Status = FindDosDeviceName ( a_DosDeviceNameList , a_DeviceName , t_SymbolicLinkName ) ;
	if ( ! t_Status )
	{
		t_SymbolicLinkName = CHString ( L"WMI_TAPEDEVICE_SYBOLICLINK" ) ;

		try
		{
			EnterCriticalSection ( &m_CriticalSection ) ;
			t_Status = DefineDosDevice ( DDD_RAW_TARGET_PATH , t_SymbolicLinkName , a_DeviceName ) ;
			LeaveCriticalSection ( &m_CriticalSection ) ;
		}
		catch( ... )
		{
			LeaveCriticalSection ( &m_CriticalSection ) ;
			throw ;
		}

		if ( t_Status )
		{
			t_CreatedSymbolicLink = TRUE ;
		}
		else
		{
			t_hResult = WBEM_E_PROVIDER_FAILURE ;

			DWORD t_LastError = GetLastError () ;
            LogErrorMessage2(L"Failed to DefineDosDevice (%d)", t_LastError);
		}
	}

	if ( t_Status )
	{
		CHString t_Device = CHString ( L"\\\\.\\" ) + t_SymbolicLinkName ;

		SmartCloseHandle t_Handle = CreateFile (

			t_Device,
			GENERIC_READ,
			FILE_SHARE_READ,
			NULL,
			OPEN_EXISTING,
			0,
			NULL
		);

		if ( t_Handle != INVALID_HANDLE_VALUE )
		{
			STORAGE_DEVICE_NUMBER t_DeviceNumber;
			DWORD t_BytesReturned;
			ULONG t_Return = 0;

			t_Status = DeviceIoControl (

				t_Handle ,
				IOCTL_STORAGE_GET_DEVICE_NUMBER ,
				NULL ,
				0 ,
				& t_DeviceNumber ,
				sizeof ( STORAGE_DEVICE_NUMBER ) ,
				& t_BytesReturned ,
				NULL
			) ;

			if ( t_Status )
			{
				TCHAR t_DeviceLabel [ sizeof ( TCHAR ) * 17 + sizeof ( _TEXT("\\Device\\Tape") ) ] ;
				_stprintf ( t_DeviceLabel , _TEXT("\\Device\\Tape%d") , t_DeviceNumber.DeviceNumber ) ;

				t_Status = FindDosDeviceName ( a_DosDeviceNameList , t_DeviceLabel, a_DosDeviceName ) ;
				if ( ! t_Status )
				{
					t_hResult = WBEM_E_NOT_FOUND ;
				}
			}
			else
			{
				t_hResult = WBEM_E_PROVIDER_FAILURE ;

				DWORD t_Error = GetLastError () ;
                LogErrorMessage2(L"Failed DeviceIoControl (%d)", t_Error);
			}

	/*
	 * Get SCSI information (IDE drives are still
	 * controlled by subset of SCSI miniport)
	 */

			if ( a_SpecifiedProperties & SPECIAL_TAPEINFO )
			{
				TAPE_GET_DRIVE_PARAMETERS t_DriveInfo ;
				t_Return = sizeof ( t_DriveInfo ) ;

				//Get info on drive, using Win32 API function
				//===========================================
				DWORD t_Status = GetTapeParameters (

					t_Handle,
					GET_TAPE_DRIVE_INFORMATION,
					& t_Return ,
					& t_DriveInfo
				) ;

				if ( t_Status == NO_ERROR)
				{
					if ( a_SpecifiedProperties & SPECIAL_PROPS_ECC )
					{
						a_Inst->SetDWORD ( IDS_ECC , ( DWORD ) t_DriveInfo.ECC ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_COMPRESSION )
					{
						a_Inst->SetDWORD ( IDS_Compression , ( DWORD ) t_DriveInfo.Compression ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_PADDING )
					{
						a_Inst->SetDWORD ( IDS_Padding , ( DWORD ) t_DriveInfo.DataPadding ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_REPORTSETMARKS )
					{
						a_Inst->SetDWORD ( IDS_ReportSetMarks , ( DWORD ) t_DriveInfo.ReportSetmarks ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_DEFAULTBLOCKSIZE )
					{
						a_Inst->SetWBEMINT64 ( IDS_DefaultBlockSize , (ULONGLONG)t_DriveInfo.DefaultBlockSize ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_MAXIMUMBLOCKSIZE )
					{
						a_Inst->SetWBEMINT64 ( IDS_MaximumBlockSize , (ULONGLONG)t_DriveInfo.MaximumBlockSize ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_MINIMUMBLOCKSIZE )
					{
						a_Inst->SetWBEMINT64 ( IDS_MinimumBlockSize , (ULONGLONG)t_DriveInfo.MinimumBlockSize ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_MAXPARTITIONCOUNT )
					{
						a_Inst->SetDWORD ( IDS_MaximumPartitionCount , t_DriveInfo.MaximumPartitionCount ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_FEATURESLOW )
					{
						a_Inst->SetDWORD ( IDS_FeaturesLow , t_DriveInfo.FeaturesLow ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_FEATUREHIGH )
					{
						a_Inst->SetDWORD ( IDS_FeaturesHigh , t_DriveInfo.FeaturesHigh ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_ENDOFTAPEWARNINGZONESIZE )
					{
						a_Inst->SetDWORD ( IDS_EndOfTapeWarningZoneSize , t_DriveInfo.EOTWarningZoneSize ) ;
					}
				}
			}

		}
		else
		{
			DWORD t_Error = GetLastError () ;

            // Non-admins might get this error.  We return the instance anyway
            if (t_Error == ERROR_ACCESS_DENIED)
            {
                t_hResult = WBEM_S_NO_ERROR;
            }
            else
            {
                t_hResult = WBEM_E_PROVIDER_FAILURE ;
                LogErrorMessage2(L"Failed to CreateFile (%d)", t_Error);
            }
		}
	}

	if ( t_CreatedSymbolicLink )
	{
		BOOL t_Status ;

		try
		{
			EnterCriticalSection ( &m_CriticalSection ) ;
			t_Status = DefineDosDevice ( DDD_EXACT_MATCH_ON_REMOVE | DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
			LeaveCriticalSection ( &m_CriticalSection ) ;
		}
		catch( ... )
		{
			LeaveCriticalSection ( &m_CriticalSection ) ;
			throw ;
		}

		if ( ! t_Status )
		{
			t_hResult = WBEM_E_PROVIDER_FAILURE ;

			DWORD t_LastError = GetLastError () ;
            LogErrorMessage2(L"Failed to Delete DOS Device (%d)", t_LastError);
		}
	}

	return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive :: LoadMediaPropertyValues
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive::LoadMediaPropertyValues (

	CInstance *a_Inst ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const CHString &a_DosDeviceName ,
	UINT64 a_SpecifiedProperties
)
{

	HRESULT t_hResult = S_OK ;

/*
 *
 */
    // Set common drive properties
    //=============================

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPABILITY )
	{
		// Create a safearray for the Capabilities information

		SAFEARRAYBOUND t_ArrayBounds ;

		t_ArrayBounds.cElements = 2;
		t_ArrayBounds.lLbound = 0;

		variant_t t_CapabilityValue ;

		if ( V_ARRAY ( & t_CapabilityValue ) = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
		{
			V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;
			long t_Capability = 2 ;
			long t_Index = 0;
			SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ) , & t_Index , & t_Capability) ;

			t_Index = 1;
			t_Capability = 7 ;
			SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ) , & t_Index , & t_Capability ) ;

			a_Inst->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;
		}
	}

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_AVAILABILITY )
//	{
//		a_Inst->SetWBEMINT16(IDS_Availability, 3);
//	}

/*
 * Media type
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIATYPE )
	{
	    a_Inst->SetWCHARSplat ( IDS_MediaType , L"Tape Drive" ) ;
	}

	return t_hResult ;
}

UINT64 CWin32TapeDrive::GetBitMask(CFrameworkQuery &a_Query)
{
    UINT64 t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_StatusInfo ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUSINFO ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSITargetId ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSITARGETID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Id ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_ID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Capabilities ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPABILITY ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaType ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIATYPE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_VOLUMENAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MaximumComponentLength ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MAXCOMPONENTLENGTH ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_FileSystemFlags ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_FILESYSTEMFLAGS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeSerialNumber ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SERIALNUMBER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Size ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SIZE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Availability ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_AVAILABILITY ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ECC ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_ECC ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_Compression ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_COMPRESSION ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_Padding ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PADDING ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ReportSetMarks ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_REPORTSETMARKS ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_DefaultBlockSize ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_DEFAULTBLOCKSIZE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_MaximumBlockSize ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_MAXIMUMBLOCKSIZE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_MinimumBlockSize ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_MINIMUMBLOCKSIZE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_MaximumPartitionCount ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_MAXPARTITIONCOUNT ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_FeaturesLow ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_FEATURESLOW;
    }

    if ( a_Query.IsPropertyRequired ( IDS_FeaturesHigh ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_FEATUREHIGH ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_EndOfTapeWarningZoneSize ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_ENDOFTAPEWARNINGZONESIZE ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\connectiontoshare.cpp ===
/******************************************************************

   ConnectionToShare.CPP -- C provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Association between Connection and Share class
  
******************************************************************/

#include "precomp.h"

#include "ConnectionToShare.h"

CConnectionToShare MyCConnectionToShare ( 

	PROVIDER_NAME_CONNECTIONTOSHARE , 
	Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CConnectionToShare::CConnectionToShare
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CConnectionToShare :: CConnectionToShare (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CConnectionToShare::~CConnectionToShare
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CConnectionToShare :: ~CConnectionToShare ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CConnectionToShare :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{	
 	HRESULT hRes = WBEM_S_NO_ERROR ;
	DWORD dwPropertiesReq = CONNECTIONSTOSHARE_ALL_PROPS;
	CHString t_ComputerName;
	CHString t_ShareName;

	hRes = EnumConnectionInfo ( 
				t_ComputerName,
				t_ShareName,
				pMethodContext,
				dwPropertiesReq
			 ) ;

    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CConnectionToShare :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CHString t_Key1 ;
	CHString t_Key2;

    if  ( pInstance->GetCHString ( IDS_Connection , t_Key1 ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_Resource , t_Key2 ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}
	// here we will need to unparse the keys and check if the instance exist
	// We can take the resource (share) key and enumerate all  the shares, 
	// check if the share exists, if the share exists only for that share enumerate connections
	// and if the connection user and computer enumerate the connections, if it is found set the keys
	// otherwise return not found
	CHString t_Share;
	hRes = GetShareKeyVal ( t_Key2, t_Share );
	
	if ( SUCCEEDED ( hRes ) )
	{
		CHString t_ComputerName;
		CHString t_ShareName;
		CHString t_UserName;

		hRes = GetConnectionsKeyVal ( t_Key1, t_ComputerName, t_ShareName, t_UserName );
		if ( SUCCEEDED ( hRes ) )
		{
			// now check the shares in t_key1 and t_key  should match
			if ( _wcsicmp ( t_Key2, t_ShareName ) == 0 )
			{
#ifdef NTONLY
				hRes = FindAndSetNTConnection ( t_ShareName, t_ComputerName, t_UserName, 
										0, pInstance, NoOp );
#endif

#if 0
#ifdef WIN9XONLY
				hRes = FindAndSet9XConnection ( t_ShareName, t_ComputerName, t_UserName, 
										0, pInstance, NoOp );
#endif
#endif
			}
		}
	}

    return hRes ;
}

#ifdef NTONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::EnumNTConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerates all Connections from a computer to share
*
*****************************************************************************/

HRESULT CConnectionToShare :: EnumNTConnectionsFromComputerToShare ( 

	CHString a_ComputerName,
	CHString a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;
	DWORD   dwResumeHandle = 0;	

	CONNECTION_INFO  *pBuf = NULL;
	CONNECTION_INFO  *pTmpBuf = NULL;
	LPWSTR t_ComputerName = NULL;

	if ( a_ComputerName && a_ComputerName[0] != L'\0' )
	{
		//let's skip the \\ chars
		t_ComputerName = a_ComputerName + 2;
	}
	
    // ShareName and COmputer Name both cannot be null at the same time
	while ( TRUE )
	{
		if ( ! a_ShareName.IsEmpty())
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ShareName.GetBuffer ( a_ShareName.GetLength() + 1), 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
				
		}
		else
		if ( ! a_ComputerName.IsEmpty() )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ComputerName.GetBuffer ( a_ShareName.GetLength() + 1 ), 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
		}

		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == 0 ) )
			break;
			
		if ( dwNoOfEntriesRead > 0 )
		{
			try
			{
				pTmpBuf = pBuf;

				for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf++ )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
				
					hRes = LoadInstance ( pInstance, a_ShareName, t_ComputerName ? t_ComputerName : a_ComputerName, pTmpBuf, dwPropertiesReq );

					if ( SUCCEEDED ( hRes ) )
					{
						hRes = pInstance->Commit();
				
						if ( FAILED ( hRes ) )
						{
							hRes = WBEM_E_FAILED;
							break;
						}
					}
				}
			}
			catch ( ... )
			{
				NetApiBufferFree ( pBuf );
				pBuf = NULL;
				throw;
			}
			NetApiBufferFree ( pBuf );
			pBuf = NULL;
		}

		if ( t_Status != ERROR_MORE_DATA )
		{
			break;
		}
	}
	return hRes;
}
#endif

#if 0 
#ifdef WIN9XONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::Enum9XConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/
HRESULT  CConnectionToShare :: Enum9XConnectionsFromComputerToShare ( 

	CHString a_ComputerName,
	CHString a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;

	BOOL bFound = FALSE;

    CONNECTION_INFO * pBuf = NULL;
    CONNECTION_INFO * pTmpBuf = NULL;

    DWORD dwBufferSize =   MAX_ENTRIES * sizeof( CONNECTION_INFO  );

    pBuf = ( CONNECTION_INFO  *) malloc(dwBufferSize);

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = 	NetConnectionEnum( 
								NULL, 
								(char FAR *) ( a_ShareName.GetBuffer ( a_ShareName.GetLength () + 1 )),  // ShareName
								1, 
								(char *) pBuf, 
								( unsigned short )dwBufferSize, 
								( unsigned short *) &dwNoOfEntriesRead, 
								( unsigned short *) &dwTotalConnections 
						);	
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}
		// otherwise we are not to frr the buffer, we have use it and then free the buffer.
		if ( ( dwNoOfEntriesRead < dwTotalConnections ) && ( t_Status == ERROR_MORE_DATA ) )
		{
			free ( pBuf );
			pBuf = NULL;

			pBuf = ( CONNECTION_INFO  *) malloc( dwTotalConnections );

			if ( pBuf != NULL ) 
			{
				try
				{
					t_Status = 	NetConnectionEnum( 
									NULL, 
									(char FAR *) ( a_ShareName.GetBuffer ( a_ShareName.GetLength () + 1 )),  // ShareName
									1, 
									(char *) pBuf, 
									( unsigned short )dwBufferSize, 
									( unsigned short *) &dwNoOfEntriesRead, 
									( unsigned short *) &dwTotalConnections 
								);	
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;				
				}
				// We need to use the buffer before we free it
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		// The buffer  is yet to be used
		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == dwTotalConnections ) )
		{
			// use the buffer first and then free 
			if ( pBuf != NULL )
			{
				try
				{
					pTmpBuf = pBuf;
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf ++)
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadInstance ( pInstance, a_ShareName, a_ComputerName, pTmpBuf, dwPropertiesReq );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();
						}
					}
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;
				}
				// finally free the buffer
				free (pBuf );
				pBuf = NULL;
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return hRes;
}
#endif
#endif

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::LoadInstance
*
*  DESCRIPTION :    Loads the Given Instance
*
*****************************************************************************/

HRESULT CConnectionToShare :: LoadInstance ( 
											
	CInstance *pInstance,
	CHString a_Share, 
	CHString a_Computer,
	CONNECTION_INFO *pBuf, 
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	LPWSTR ObjPath;
	LPWSTR ResObjPath;

	CHString t_NetName ( pBuf->coni1_netname );
	if ( ! a_Share.IsEmpty() )
	{	
		hRes = MakeObjectPath ( ObjPath,  PROVIDER_NAME_CONNECTION, IDS_ComputerName, t_NetName.GetBuffer ( t_NetName.GetLength () + 1) );
		if ( SUCCEEDED ( hRes ) )
		{
			hRes = AddToObjectPath ( ObjPath, IDS_ShareName, a_Share.GetBuffer (a_Share.GetLength () + 1)  );
		}
		
		if ( SUCCEEDED ( hRes ) )
		{
			hRes = MakeObjectPath ( ResObjPath, PROVIDER_SHARE, IDS_ShareKeyName, a_Share.GetBuffer (a_Share.GetLength () + 1) );
		}
	}
	else
	{
		hRes = MakeObjectPath ( ObjPath,  PROVIDER_NAME_CONNECTION, IDS_ComputerName, a_Computer.GetBuffer ( a_Computer.GetLength () +1));
		if ( SUCCEEDED ( hRes ) )
		{
			hRes = AddToObjectPath ( ObjPath, IDS_ShareName, t_NetName.GetBuffer ( t_NetName.GetLength () + 1) );
		}

		if ( SUCCEEDED ( hRes ) )
		{
			MakeObjectPath ( ResObjPath, PROVIDER_SHARE, IDS_ShareKeyName, t_NetName.GetBuffer ( t_NetName.GetLength () + 1) );
		}
	}

	CHString t_UserName ( pBuf->coni1_username );

	if ( SUCCEEDED ( hRes ) )
	{
		hRes = AddToObjectPath ( ObjPath, IDS_UserName, t_UserName.GetBuffer ( t_UserName.GetLength () + 1 ) );
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( pInstance->SetCHString ( IDS_Connection, ObjPath ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE;
		}	
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( pInstance->SetCHString ( IDS_Resource, ResObjPath ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE;
		}
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::GetShareKeyVal
*
*  DESCRIPTION :    Parsing the key to get the share key value
*
*****************************************************************************/

HRESULT CConnectionToShare::GetShareKeyVal ( CHString a_Key, CHString &a_Share )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	ParsedObjectPath *t_ShareObjPath;
	CObjectPathParser t_PathParser;

    if ( t_PathParser.Parse( a_Key.GetBuffer ( a_Key.GetLength () + 1 ), &t_ShareObjPath ) == t_PathParser.NoError )
	{
		try
		{
			if ( t_ShareObjPath->m_dwNumKeys == 1 )
			{
				a_Share = t_ShareObjPath->GetKeyString();
				if ( ! a_Share.IsEmpty() )
				{
					CHStringArray t_aShares;

#ifdef NTONLY
					hRes = GetNTShares ( t_aShares );
#endif
#if 0
#ifdef WIN9XONLY
					hRes = Get9XShares ( t_aShares );
#endif
#endif
					if ( SUCCEEDED ( hRes ) )
					{
						int i = 0;
						for ( i = 0; i < t_aShares.GetSize(); i++ )
						{
							if ( _wcsicmp ( a_Share, t_aShares.GetAt(i) ) == 0 )
							{	
								break;
							}
						}
						
						if ( i >= t_aShares.GetSize() )
						{
							hRes = WBEM_E_NOT_FOUND;
						}
					}
				}
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER;
			}
		}
		catch ( ... )
		{
			delete t_ShareObjPath;
			throw;
		}
		delete t_ShareObjPath;
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <Binding.h>

CBinding Win32_ConnectionShare(
    L"Win32_ConnectionShare",
    Namespace,
    L"Win32_ServerConnection",
    L"Win32_Share",
    L"Dependent",
    L"Antecedent",
    L"ShareName",
    L"Name"
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\precomp.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

// Description:  Precompiled headers for Sessions and connections

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <initguid.h>
#include <fwcommon.h>
#include <smartptr.h>
#include <sessionConnectionCommon.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\connshare.cpp ===
/******************************************************************



 ConnShare.cpp-- Implementation of base class from which ConnectionToShare

			   ConnectionToSession and Connection classes are derived



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#include "precomp.h"
#include "connshare.h"


/*****************************************************************************
*
*  FUNCTION    :    CConnShare::CConnShare
*
*  DESCRIPTION :    Constructor
*
*****************************************************************************/
CConnShare ::  CConnShare ( )
{
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::~CConnShare
*
*  DESCRIPTION :    Destructor
*
*****************************************************************************/
CConnShare :: ~ CConnShare ( ) 
{
}

#ifdef NTONLY

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::GetNTShares
*
*  DESCRIPTION :    Enumerates all the  Shares on NT
*
*****************************************************************************/
HRESULT CConnShare :: GetNTShares ( CHStringArray &t_Shares )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;

	DWORD dwNoOfEntriesRead = 0;
	DWORD dwTotalEntries = 0;

	DWORD dwResumeHandle = 0;
	PSHARE_INFO_0 pBuf, pTempBuf;

	while ( true ) 
	{
		t_Status = NetShareEnum ( 
						NULL,  //Server
						0,		//level
						(LPBYTE *) &pBuf, 
						-1,  // Preferred Max Length
						&dwNoOfEntriesRead, 
						&dwTotalEntries, 
						&dwResumeHandle 
				   );

		if (( t_Status == NERR_Success ) || (t_Status == ERROR_MORE_DATA))
		{
			try
			{
				pTempBuf = pBuf;

				for( DWORD i = 0; i < dwNoOfEntriesRead; i++, pTempBuf++ )
				{ 
					t_Shares.Add ( pTempBuf->shi0_netname ); 
				}
			}
			catch ( ... )
			{
				NetApiBufferFree( pBuf );
				pBuf = NULL;
				throw;
			}

			NetApiBufferFree( pBuf );
			pBuf = NULL;
		}

		if ( t_Status != ERROR_MORE_DATA )
		{
			break;
		}
	}

	if ( t_Status != NERR_Success )
	{
		hRes = WBEM_E_FAILED;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::FindAndSetNTConnection
*
*  DESCRIPTION :    Finds the instance and if presnt does an appropriate operation.
*
*****************************************************************************/
HRESULT CConnShare :: FindAndSetNTConnection ( 
											   
	LPWSTR t_ShareName, 
	LPCWSTR t_NetName, 
	LPCWSTR t_UserName, 
	DWORD dwPropertiesReq, 
	CInstance *pInstance, 
	DWORD eOperation 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;
	DWORD   dwResumeHandle = 0;

	CONNECTION_INFO  *pBuf = NULL;
	CONNECTION_INFO  *pTempBuf = NULL;
		
	while ( true )
	{
		t_Status = 	NetConnectionEnum( 
						NULL, 
						t_ShareName,  // ShareName
						1, 
						(LPBYTE *) &pBuf, 
						-1, 
						&dwNoOfEntriesRead, 
						&dwTotalConnections, 
						&dwResumeHandle
					);

		if ( ( ( t_Status == NERR_Success )  && ( dwNoOfEntriesRead == 0 ) ) ||
			( ( t_Status != NERR_Success ) && ( t_Status != ERROR_MORE_DATA ) ) )
		{
			hRes = WBEM_E_NOT_FOUND;
			break;
		}

		try
		{
			pTempBuf = pBuf;
			BOOL bFound = FALSE;
			for ( DWORD dwConnIndex = 0 ; dwConnIndex < dwNoOfEntriesRead ; dwConnIndex ++, pTempBuf++ )
			{
				if ( pTempBuf->coni1_netname && 
                     pTempBuf->coni1_username &&
                     ( _wcsicmp ( t_NetName, pTempBuf->coni1_netname ) == 0 ) && 
					 ( _wcsicmp (t_UserName, pTempBuf->coni1_username ) == 0 ) )
				{
					bFound = TRUE;
					break ;
				}
			}

			if ( bFound ) 
			{
				// We are not to free the buff in this loop, but free it after using this buffer
				break;
			}

			if ( t_Status != ERROR_MORE_DATA )
			{
				hRes = WBEM_E_NOT_FOUND;
				NetApiBufferFree ( pBuf );
				pBuf = NULL;

				break;
			}
		}
		catch ( ... )
		{
			NetApiBufferFree ( pBuf );
			pBuf = NULL;
			throw;
		}
		NetApiBufferFree ( pBuf );
		pBuf = NULL;
	}
			
	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			switch ( eOperation )
			{
			case Get:		hRes = LoadInstance ( 
										pInstance,
										t_ShareName,
										t_NetName,
										pTempBuf, 
										dwPropertiesReq 
								   );
			case NoOp:		break; //do nothing

			default:		hRes = WBEM_E_INVALID_PARAMETER; break;

			}
		}
		catch ( ... )
		{
			NetApiBufferFree( pBuf );
			pBuf = NULL;
			throw;
		}

		NetApiBufferFree( pBuf );
		pBuf = NULL;
	}
	return hRes;
}
#endif

#if 0
#ifdef WIN9XONLY
	
/*****************************************************************************
*
*  FUNCTION    :    CConnShare::Get9XShares
*
*  DESCRIPTION :    Enumerates all the  Shares on WIN9X
*
*****************************************************************************/

HRESULT CConnShare :: Get9XShares ( CHStringArray &t_Shares )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD t_Status = NERR_Success;

	DWORD dwNoOfEntriesRead = 0;
	DWORD dwTotalEntries = 0;

    struct share_info_1* pBuf = NULL;
    struct share_info_1* pTmpBuf = NULL;

    DWORD dwBufferSize =   MAX_ENTRIES * sizeof( struct share_info_0 );

    pBuf = ( struct share_info_1 *) malloc ( dwBufferSize );

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = NetShareEnum (
								NULL,
								1,
								(char FAR *)pBuf,
								 ( unsigned short ) dwBufferSize,
								 ( unsigned short *) &dwNoOfEntriesRead,
								 ( unsigned short *) &dwTotalEntries
					   );


			if ( dwNoOfEntriesRead > 0 ) 
			{
				pTmpBuf = pBuf;
                CHString t_NetName;

				for( DWORD i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf++ )
				{ 
					t_NetName = pTmpBuf->shi1_netname;
					t_Shares.Add ( t_NetName ); 
				}
			}
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}
		free ( pBuf );
		pBuf = NULL;
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	if ( ( dwNoOfEntriesRead < dwTotalEntries ) || ( t_Status == ERROR_MORE_DATA ) )
	{ 
		DWORD oldENtriesRead = dwNoOfEntriesRead;

		pBuf = ( struct share_info_1 *) malloc ( dwTotalEntries );

		if ( pBuf != NULL )
		{
			try
			{
				t_Status = NetShareEnum (
									NULL,
									1,
									(char FAR *)pBuf,
									 ( unsigned short ) dwBufferSize,
									 ( unsigned short *) &dwNoOfEntriesRead,
									 ( unsigned short *) &dwTotalEntries
						   );


				if ( t_Status == NERR_Success ) 
				{
					pTmpBuf = pBuf;
                    CHString t_NetName;

					for( DWORD i = oldENtriesRead; i < dwNoOfEntriesRead; i++, pTmpBuf )
					{ 
						t_NetName = pTmpBuf->shi1_netname;
						t_Shares.Add ( t_NetName ); 
					}
				}
				else
				{
					hRes = WBEM_E_FAILED;
				}
			}
			catch ( ... )
			{
				free ( pBuf );
				pBuf = NULL;
				throw;
			}
			free ( pBuf );
			pBuf = NULL;
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::FindAndSet9XConnection
*
*  DESCRIPTION :    Finds the instance and if presnt does an appropriate operation.
*
*****************************************************************************/
HRESULT CConnShare :: FindAndSet9XConnection ( 
											   
	LPWSTR t_ShareName, 
	LPCWSTR t_NetName, 
	LPCWSTR t_UserName, 
	DWORD dwPropertiesReq, 
	CInstance *pInstance, 
	DWORD eOperation 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;

	BOOL bFound = FALSE;

    CONNECTION_INFO * pBuf = NULL;
    CONNECTION_INFO * pTmpBuf = NULL;

    DWORD dwBufferSize =   MAX_ENTRIES * sizeof( CONNECTION_INFO  );

    pBuf = ( CONNECTION_INFO *) malloc(dwBufferSize);

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = 	NetConnectionEnum( 
								NULL, 
								(char FAR *) ( t_ShareName ),  // ShareName
								1, 
								(char *) pBuf, 
								( unsigned short )dwBufferSize, 
								( unsigned short *) &dwNoOfEntriesRead, 
								( unsigned short *) &dwTotalConnections 
							);


			if ( dwNoOfEntriesRead > 0 ) 
			{
				pTmpBuf = pBuf;
                CHString t_TempNetNameStr, t_UserName ;

				for ( DWORD dwConnIndex = 0 ; dwConnIndex < dwNoOfEntriesRead ; dwConnIndex ++, pTmpBuf++ )
				{
					t_TempNetNameStr = pTmpBuf->coni1_netname;
					t_UserName = pTmpBuf->coni1_username;

					if ( ( _wcsicmp ( t_NetName, t_TempNetNameStr ) == 0 ) && 
									( t_UserName.CompareNoCase ( t_UserName ) == 0 ) )
					{
						bFound = TRUE;
						break ;
					}
				}
			}
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}

		if ( bFound == FALSE )
		{
			// if found is TRUE pBuf is not to be freed since the found entry is yet to be used
			free ( pBuf );
			pBuf = NULL;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	if ( ! bFound && ( dwNoOfEntriesRead < dwTotalConnections ) && ( t_Status == ERROR_MORE_DATA ) )
	{
		DWORD dwOldNoOfEntries = dwNoOfEntriesRead;
		dwBufferSize =   dwTotalConnections * sizeof( CONNECTION_INFO );

		pBuf = ( CONNECTION_INFO  *) malloc(dwBufferSize);

		if ( pBuf != NULL )
		{
			try
			{
				t_Status = 	NetConnectionEnum( 
								NULL, 
								(char FAR *) ( t_ShareName ),  // ShareName
								1, 
								(char *) pBuf, 
								( unsigned short )dwBufferSize, 
								( unsigned short *) &dwNoOfEntriesRead, 
								( unsigned short *) &dwTotalConnections 
							);

				if ( dwNoOfEntriesRead > 0 ) 
				{
					pTmpBuf = pBuf;
                    CHString t_TempNetNameStr, t_UserName;
					for ( DWORD dwConnIndex = dwOldNoOfEntries ; dwConnIndex < dwNoOfEntriesRead ; dwConnIndex ++, pTmpBuf++ )
					{
						t_TempNetNameStr = pTmpBuf->coni1_netname;
						t_UserName = pTmpBuf->coni1_username;

						if ( ( _wcsicmp ( t_NetName, t_TempNetNameStr ) == 0 ) && 
										( _wcsicmp (t_UserName, t_UserName ) == 0 ) )
						{
							bFound = TRUE;
							break ;
						}
					}
				}
			}
			catch ( ... )
			{
				free ( pBuf );
				pBuf = NULL;
				throw;
			}
			if ( ! bFound )
			{
				// Free the buffer only if not found, otherwise it needs to be freed after using this found entry
				free ( pBuf );						
				pBuf = NULL;
			}
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	if ( bFound == FALSE ) 
	{
		hRes = WBEM_E_NOT_FOUND;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			switch ( eOperation )
			{
			case Get:		hRes = LoadInstance ( 
										pInstance,
										t_ShareName,
										t_NetName,
										pTmpBuf, 
										dwPropertiesReq 
								   );
			case NoOp:		break; //do nothing

			default:		hRes = WBEM_E_INVALID_PARAMETER; break;

			}
		}
		catch ( ... )
		{
			free( pBuf );
			pBuf = NULL;
			throw;
		}

		free( pBuf );
		pBuf = NULL;
	}
	return hRes;
}
#endif
#endif // #if 0

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::EnumConnectionInfo
*
*  DESCRIPTION :    Enumerates all the NT connections information
*
*****************************************************************************/

HRESULT CConnShare :: EnumConnectionInfo (
	
	LPWSTR  a_ComputerName,
	LPWSTR  a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	if ( ( a_ComputerName[0] != L'\0' ) || ( a_ShareName[0] != L'\0' ) )
	{
#ifdef NTONLY
		hRes = EnumNTConnectionsFromComputerToShare ( 

					a_ComputerName,
					a_ShareName,
					pMethodContext,
					dwPropertiesReq
				 );	
#endif

#if 0
#ifdef WIN9XONLY
		hRes = Enum9XConnectionsFromComputerToShare ( 

						a_ComputerName,
						a_ShareName,
						pMethodContext,
						dwPropertiesReq
					);
#endif
#endif // #if 0
	}	
	else
	if ( ( a_ComputerName[0] == L'\0' ) && (  a_ShareName[0] == L'\0' ) )
	{	
		CHStringArray t_Shares;

#ifdef NTONLY
		hRes = GetNTShares ( t_Shares );
#endif

#if 0
#ifdef WIN9XONLY
		hRes = Get9XShares ( t_Shares );
#endif
#endif // #if 0

		if  ( SUCCEEDED ( hRes ) )
		{
			for ( int i = 0; i < t_Shares.GetSize() ; i++ )
			{
#ifdef NTONLY
				hRes = EnumNTConnectionsFromComputerToShare ( 

								a_ComputerName,
								t_Shares.GetAt ( i ).GetBuffer(0),
								pMethodContext,
								dwPropertiesReq
							);
#endif

#if 0
#ifdef WIN9XONLY
				hRes = Enum9XConnectionsFromComputerToShare ( 

								a_ComputerName,
								t_Shares.GetAt ( i ),
								pMethodContext,
								dwPropertiesReq
							);
#endif
#endif // #if 0
			}
		}	
	}

	return hRes;;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::GetConnectionsKeyVal
*
*  DESCRIPTION :    Parsing the key to get Connection Key Value
*
*****************************************************************************/
HRESULT CConnShare::GetConnectionsKeyVal ( 
												 
	LPCWSTR a_Key, 
	CHString &a_ComputerName, 
	CHString &a_ShareName, 
	CHString &a_UserName 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	ParsedObjectPath *t_ObjPath;
	CObjectPathParser t_PathParser;

	DWORD dwAllKeys = 0;

    if ( t_PathParser.Parse( a_Key, &t_ObjPath ) == t_PathParser.NoError )
	{
		try
		{
			hRes  = t_ObjPath->m_dwNumKeys != 3 ? WBEM_E_INVALID_PARAMETER : hRes;

			if ( SUCCEEDED ( hRes ) )
			{
                hRes = (t_ObjPath->m_pClass) && _wcsicmp ( t_ObjPath->m_pClass, PROVIDER_NAME_CONNECTION ) == 0 ? WBEM_S_NO_ERROR: WBEM_E_INVALID_PARAMETER;

				if ( SUCCEEDED ( hRes ) )
				{
					for ( int i = 0; i < 3; i++ )
					{
                        if (V_VT(&t_ObjPath->m_paKeys[i]->m_vValue) == VT_BSTR)
                        {
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_ComputerName ) == 0 )
						    {
							    a_ComputerName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 1;							
						    }
						    else
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_ShareName ) == 0 )
						    {
							    a_ShareName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 2;

						    }
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_UserName ) == 0 )
						    {
							    a_UserName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 4;

						    }
                        }
                        else
                        {
                            break;
                        }
					}
					if ( dwAllKeys != 7 )
					{
						hRes = WBEM_E_INVALID_PARAMETER;
					}
				}
				else
				{
					hRes = WBEM_E_INVALID_PARAMETER;
				}
			}
		}
		catch ( ... )
		{
			delete t_ObjPath;
			throw;
		}
		delete t_ObjPath;
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::MakeObjectPath
*
*  DESCRIPTION :    Makes the Object Path Given given a class name, a key Name 
*					and a key value
*
*****************************************************************************/

HRESULT CConnShare::MakeObjectPath (
										   
	 LPWSTR &a_ObjPathString,  
	 LPCWSTR a_ClassName, 
	 LPCWSTR a_AttributeName, 
	 LPCWSTR a_AttributeVal 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	ParsedObjectPath t_ObjPath;
	variant_t t_Path;

	t_Path = a_AttributeVal;

	hRes = t_ObjPath.SetClassName ( a_ClassName ) ? hRes : WBEM_E_INVALID_PARAMETER;
	
	if ( SUCCEEDED ( hRes ) )
	{
		hRes = t_ObjPath.AddKeyRef ( a_AttributeName, &t_Path ) ? hRes : WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		CObjectPathParser t_PathParser;

		hRes = t_PathParser.Unparse( &t_ObjPath, &a_ObjPathString ) == t_PathParser.NoError ? hRes : WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::AddToObjectPath
*
*  DESCRIPTION :    Adds a key name and a value to the existing Object path
*
*****************************************************************************/

HRESULT CConnShare::AddToObjectPath ( 

	 LPWSTR &a_ObjPathString,  
	 LPCWSTR a_AttributeName, 
	 LPCWSTR  a_AttributeVal 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	ParsedObjectPath *t_ObjPath;
	variant_t t_Path;
	CObjectPathParser t_PathParser;

    if ( t_PathParser.Parse( a_ObjPathString, &t_ObjPath ) == t_PathParser.NoError )
	{
		try
		{
			t_Path = a_AttributeVal;
			if ( t_ObjPath->AddKeyRef ( a_AttributeName, &t_Path ) )
			{
				// delete the oldpath string
				if ( a_ObjPathString != NULL )
				{
					delete [] a_ObjPathString;
					a_ObjPathString = NULL;
				}
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER;
			}

			hRes = t_PathParser.Unparse( t_ObjPath, &a_ObjPathString ) == t_PathParser.NoError ? hRes : WBEM_E_INVALID_PARAMETER;
		}
		catch ( ... )
		{
			delete t_ObjPath;
			throw;
		}
		delete t_ObjPath;		
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WMI Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <brodcast.h>
#include <initguid.h>

HMODULE ghModule;

// {6E78DAD9-E187-4d6e-BA63-760256D6F405}
DEFINE_GUID( CLSID_WMISESSION, 
0x6e78dad9, 0xe187, 0x4d6e, 0xba, 0x63, 0x76, 0x2, 0x56, 0xd6, 0xf4, 0x5);

#define PROVIDER_NAME L"WMIPSESS"

//Count number of objects and number of locks.
long g_cLock = 0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    
    try
    {
        if ( CLSID_WMISESSION == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow()
{
    SCODE sc = S_FALSE;

    try
    {
        sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("Microsoft Session And Connection Provider"), CLSID_WMISESSION ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_WMISESSION ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\connectiontosession.h ===
/******************************************************************



 ConnectionToSession.h -- 



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#ifndef  _CONNTOSESSION_H_
#define  _CONNTOSESSION_H_

#include "Connshare.h"

class CConnectionToSession : public Provider , public CConnShare
{

private:

#ifdef NTONLY
	HRESULT EnumNTConnectionsFromComputerToShare ( 

		LPWSTR a_ComputerName,
		LPWSTR a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif

#if 0
#ifdef WIN9XONLY
	HRESULT Enum9XConnectionsFromComputerToShare ( 

		LPWSTR a_ComputerName,
		LPWSTR a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif
#endif

	HRESULT GetSessionKeyVal ( 
													 
		LPCWSTR a_Key, 
		CHString &a_ComputerName, 
		CHString &a_UserName 
	);

	HRESULT LoadInstance ( 
												
		CInstance *pInstance,
		LPCWSTR a_ComputerName, 
		LPCWSTR a_ShareName,
		CONNECTION_INFO *pBuf, 
		DWORD dwPropertiesReq
	);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;
		

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

public:

        CConnectionToSession (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CConnectionToSession () ;

private:

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\connection.h ===
/******************************************************************





 Connection.h-- 



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/
#ifndef  _CONNECTION_H_
#define  _CONNECTION_H_

#include "Connshare.h"


class CConnection : public Provider, public CConnShare
{

private:

#ifdef NTONLY
	HRESULT  EnumNTConnectionsFromComputerToShare ( 

		LPWSTR a_ComputerName,
		LPWSTR a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif

#if 0
#ifdef WIN9XONLY
	HRESULT  Enum9XConnectionsFromComputerToShare ( 

		LPWSTR a_ComputerName,
		LPWSTR a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif 
#endif // #if 0
// for this method only the type of the connection structure parameter changes based on the OS.
	HRESULT LoadInstance ( 
		CInstance *pInstance,
		LPCWSTR a_Share, 
		LPCWSTR a_Computer, 
		CONNECTION_INFO *pBuf, 
		DWORD PropertiesReq
	);

	HRESULT OptimizeQuery ( 
										  
		CHStringArray& a_ShareValues, 
		CHStringArray& a_ComputerValues, 
		MethodContext *pMethodContext, 
		DWORD dwPropertiesReq 
	);

	void SetPropertiesReq ( 
		
		CFrameworkQuery &Query,
		DWORD &PropertiesReq
	);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;
		

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0
		) ;

public:
  
        CConnection (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CConnection () ;

private:

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\session.cpp ===
/******************************************************************

   Session.CPP -- C provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Session Provider 
   
******************************************************************/

#include "precomp.h"

#include "Session.h"

CSession MyCSession ( 

	PROVIDER_NAME_SESSION , 
	Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CSession::CSession
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CSession :: CSession (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CSession::~CSession
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CSession :: ~CSession ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CSession :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
 	HRESULT hRes = WBEM_S_NO_ERROR ;

	DWORD dwPropertiesReq = SESSION_ALL_PROPS;

#ifdef NTONLY
	hRes = EnumNTSessionInfo ( 
					NULL,
					NULL,
					502,
					pMethodContext,
					dwPropertiesReq
			 );
#endif

#if 0
#ifdef WIN9XONLY

	hRes = Enum9XSessionInfo ( 

					50,
					pMethodContext,
					dwPropertiesReq
			 );
#endif
#endif // #if 0

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CSession :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ComputerName ;
	CHString t_UserName;

    if  ( pInstance->GetCHString ( IDS_ComputerName , t_ComputerName ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED  ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_UserName , t_UserName ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED  ( hRes ) )
	{
		DWORD dwPropertiesReq = 0;

		if ( Query.AllPropertiesAreRequired () )
		{
			dwPropertiesReq = SESSION_ALL_PROPS;
		}
		else
		{
			SetPropertiesReq ( Query,dwPropertiesReq );
		}

		short t_Level;

#ifdef NTONLY
		GetNTLevelInfo ( dwPropertiesReq, &t_Level );
		hRes = FindAndSetNTSession ( t_ComputerName, t_UserName.GetBuffer(0), t_Level, dwPropertiesReq, pInstance, Get );
#endif

#if 0
#ifdef WIN9XONLY
		Get9XLevelInfo ( dwPropertiesReq, &t_Level );
		hRes = FindAndSet9XSession ( t_ComputerName, t_UserName, t_Level, dwPropertiesReq, pInstance, Get );
#endif
#endif // #if 0
	}

    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    :    CSession:: DeleteInstance
*
*  DESCRIPTION :    Deletes an Session if it exists
*
*****************************************************************************/

HRESULT CSession :: DeleteInstance (

	const CInstance &Instance, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ComputerName ;
	CHString t_UserName;

    if  ( Instance.GetCHString ( IDS_ComputerName , t_ComputerName ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED  ( hRes ) )
	{
		if  ( Instance.GetCHString ( IDS_UserName , t_UserName ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED  ( hRes ) )
	{
		CInstancePtr pInstance;		// This will not be used in this method.
#ifdef NTONLY
		hRes = FindAndSetNTSession ( t_ComputerName, t_UserName.GetBuffer(0), 10, 0, pInstance, Delete );
#endif

#if 0
#ifdef WIN9XONLY
		hRes = FindAndSet9XSession ( t_ComputerName, t_UserName, 50, 0, pInstance, Delete );
#endif
#endif // #if 0

	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::ExecQuery
*
*  DESCRIPTION :    Optimizing a query  on filtering Properties and the Key value
*
*****************************************************************************/

HRESULT CSession :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwPropertiesReq;
	short t_Level;

	if ( Query.AllPropertiesAreRequired () )
	{
		dwPropertiesReq = SESSION_ALL_PROPS;
	}
	else
	{
		SetPropertiesReq ( Query,dwPropertiesReq );
	}

#ifdef NTONLY
	GetNTLevelInfo ( dwPropertiesReq, &t_Level );
#endif
#if 0
#ifdef WIN9XONLY
	Get9XLevelInfo ( dwPropertiesReq, &t_Level );
#endif
#endif // #if 0

	CHStringArray t_ComputerValues;
	CHStringArray  t_UserValues;

	hRes = Query.GetValuesForProp(
				IDS_ComputerName,
				t_ComputerValues
		   );

	hRes = Query.GetValuesForProp(
				IDS_UserName,
				t_UserValues
		   );

	if ( SUCCEEDED ( hRes ) )
	{
		short t_Level;

#ifdef NTONLY
		GetNTLevelInfo ( dwPropertiesReq, &t_Level );
		hRes = OptimizeNTQuery ( t_ComputerValues, t_UserValues, t_Level, pMethodContext, dwPropertiesReq );
#endif

#if 0
#ifdef WIN9XONLY 
		Get9XLevelInfo ( dwPropertiesReq, &t_Level );
		hRes = Optimize9XQuery ( t_ComputerValues, t_UserValues, t_Level, pMethodContext, dwPropertiesReq );
#endif
#endif // #if 0
	}

	return hRes;
}

#ifdef NTONLY
/*****************************************************************************
*
*  FUNCTION    :    CSession::EnumNTSessionInfo
*
*  DESCRIPTION :    Enumerating all the Sessions 
*
*****************************************************************************/

HRESULT CSession :: EnumNTSessionInfo (

	LPWSTR lpComputerName,
	LPWSTR lpUserName,
	short a_Level,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	NET_API_STATUS t_Status = NERR_Success;
	HRESULT hRes = WBEM_S_NO_ERROR;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalSessions = 0;
	DWORD   dwResumeHandle = 0;

	void *pBuf = NULL;
	void *pTmpBuf = NULL;

	while ( ( t_Status == NERR_Success ) || ( t_Status == ERROR_MORE_DATA ) )
	{
		t_Status =  NetSessionEnum(
						NULL,     
						lpComputerName,  
						lpUserName,       
						a_Level,           
						(LPBYTE *) &pBuf,        
						-1,      
						&dwNoOfEntriesRead,   
						&dwTotalSessions,  
						&dwResumeHandle  
				    );

		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == 0 ) )
		{
			break;
		}

		if ( ( dwNoOfEntriesRead > 0 ) && ( t_Status == NERR_Success ) )
		{
			try
			{
				pTmpBuf = pBuf;

				for ( int i = 0; i < dwNoOfEntriesRead; i++ )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
				
					hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );

					if ( SUCCEEDED ( hRes ) )
					{
						hRes = pInstance->Commit();

						if ( FAILED ( hRes ) )
						{
							break;
						}
					}
	
					// here need to go to the next structure based on the level, we will typecast with the apropriate structure
					// and then increment by one
					switch ( a_Level )
					{
					case 502 :  SESSION_INFO_502 *pTmpTmpBuf502;
								pTmpTmpBuf502 = ( SESSION_INFO_502 *) pTmpBuf;
								pTmpTmpBuf502 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf502;
								break;
					case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
								pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
								pTmpTmpBuf2 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf2;
								break;
					case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
								pTmpTmpBuf1 = ( SESSION_INFO_1 *) pTmpBuf;
								pTmpTmpBuf1 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf1;
								break;
					case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
								pTmpTmpBuf10 = ( SESSION_INFO_10 *) pTmpBuf;
								pTmpTmpBuf10 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf10;
								break;
					}
				}

				if ( FAILED ( hRes ) )
				{
					break;
				}
			}
			catch ( ... )
			{
				NetApiBufferFree ( pBuf );
				pBuf = NULL;
				throw;
			}
			NetApiBufferFree ( pBuf );
			pBuf = NULL;
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::FindAndSetNTSession
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CSession::FindAndSetNTSession ( LPCWSTR a_ComputerName, LPWSTR a_UserName, short a_Level, DWORD dwPropertiesReq, 
								CInstance *pInstance, DWORD eOperation )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;		
	CHString t_TempKey;

	t_TempKey.Format ( L"%s%s",L"\\\\", a_ComputerName );

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalSessions = 0;
	DWORD   dwResumeHandle = 0;

	void *pBuf = NULL;

	// since it will be only one structure 
	t_Status =  NetSessionEnum(
					NULL,     
					t_TempKey.GetBuffer ( 0 ),  
					a_UserName,   
					a_Level,           
					(LPBYTE *) &pBuf,        
					-1,      
					&dwNoOfEntriesRead,   
					&dwTotalSessions,  
					&dwResumeHandle  
			  );


	hRes = ( t_Status != NERR_Success ) && ( dwNoOfEntriesRead == 0 ) ? WBEM_E_NOT_FOUND : hRes;

	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			switch ( eOperation )
			{
			case Get:	hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );
						break;
			case Delete: hRes =  t_Status = NetSessionDel( 
										NULL,
										t_TempKey.GetBuffer ( 0 ), 
										a_UserName
								 );
								 hRes = t_Status == NERR_Success ? hRes : WBEM_E_FAILED;
								 break;

			default:	hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
						break;
			}
		}
		catch ( ... )
		{
			if ( pBuf != NULL )
			{
				NetApiBufferFree(pBuf);
				pBuf = NULL;
			}
			throw;
		}
		if ( pBuf != NULL )
		{
			NetApiBufferFree(pBuf);
			pBuf = NULL;
		}
	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    Session::OptimizeNTQuery
*
*  DESCRIPTION :    Optimizes a query based on the key values.
*
*****************************************************************************/

HRESULT CSession::OptimizeNTQuery ( 
									  
	CHStringArray& a_ComputerValues, 
	CHStringArray& a_UserValues,
	short a_Level,
	MethodContext *pMethodContext, 
	DWORD dwPropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	if ( ( a_ComputerValues.GetSize() == 0 ) && ( a_UserValues.GetSize() == 0 ) )
	{
		// This is a query for which there is no where clause, so it means only a few Properties are requested
		// hence we need to deliver only those properties of instances to the WinMgmt while enumerating Sessions
		hRes = EnumNTSessionInfo ( 
						NULL,
						NULL,
						a_Level,
						pMethodContext,
						dwPropertiesReq
					);
	}
	else
	if  ( a_UserValues.GetSize() != 0 ) 
	{
		for ( int i = 0; i < a_UserValues.GetSize(); i++ )
		{
			hRes = EnumNTSessionInfo ( 
							NULL,
							a_UserValues.GetAt( i ).GetBuffer ( 0 ),
							a_Level,
							pMethodContext,
							dwPropertiesReq
						);
		}
	}
	else
	if  ( a_ComputerValues.GetSize() != 0 ) 
	{
		CHString t_ComputerName;
		for ( int i = 0; i < a_ComputerValues.GetSize(); i++ )
		{
			t_ComputerName.Format ( L"%s%s", L"\\\\", (LPCWSTR)a_ComputerValues.GetAt(i) );

			hRes = EnumNTSessionInfo ( 
							t_ComputerName.GetBuffer(0),
							NULL,
							a_Level,
							pMethodContext,
							dwPropertiesReq
					   );
		}
	}
	else
	{
		hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::GetNTLevelInfo
*
*  DESCRIPTION :    Getting the level info, so that the appropriate structure
*					Can be passed to make a call.
*
*****************************************************************************/

void CSession :: GetNTLevelInfo ( 

	DWORD dwPropertiesReq,
	short *a_Level 
)
{
	if ( ( dwPropertiesReq == SESSION_ALL_PROPS )  || 
		 ( (dwPropertiesReq & SESSION_PROP_TransportName) == SESSION_PROP_TransportName )
	   )
	{
		*a_Level = 502;
	}
	else
	if ( (dwPropertiesReq & SESSION_PROP_ClientType) == SESSION_PROP_ClientType )
	{
		*a_Level = 2;
	}
	else
	if ( ( (dwPropertiesReq & SESSION_PROP_NumOpens) == SESSION_PROP_NumOpens ) ||  
		 ( (dwPropertiesReq & SESSION_PROP_SessionType) == SESSION_PROP_SessionType )
	   )
	{
		*a_Level = 1;
	}
	else
	{
		// Since keys will be always required we need to atleast use Level 10 structure and level 0 cannot be used since,
		// it gives only username, where as computername is also a key.
		*a_Level = 10;
	}
} 
#endif

/*****************************************************************************
*
*  FUNCTION    :    CSession::LoadData
*  DESCRIPTION :    Loading an instance with the obtained information
*
*****************************************************************************/

HRESULT CSession :: LoadData ( 
						
	short a_Level,
	void *pTmpBuf,
	DWORD dwPropertiesReq ,
	CInstance *pInstance
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	// every property is to be set based on the level and then typecasting that buffer with that level.
	if ( dwPropertiesReq & SESSION_PROP_Computer) 
	{
		CHString  t_ComputerName;
		switch ( a_Level )
		{
#ifdef NTONLY
		case 502 :  t_ComputerName = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_cname;
					break;
#endif
		case 2:		t_ComputerName = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_cname;
					break;
		case 1:		t_ComputerName = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_cname;
					break;
		case 10:	t_ComputerName = ( (SESSION_INFO_10 *) pTmpBuf )->sesi10_cname;
					break;
#if 0
#ifdef WIN9XONLY
		case 50:	t_ComputerName = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_cname;
					break;
#endif
#endif // #if 0
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( pInstance->SetCHString ( IDS_ComputerName, t_ComputerName ) == FALSE )
			{
				hRes = WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_User )
		{
			CHString  t_User;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_User = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_username;
						break;
#endif
			case 2:		t_User = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_username;
						break;
			case 1:		t_User = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_username;
						break;
			case 10:	t_User = ( (SESSION_INFO_10 *) pTmpBuf )->sesi10_username;
						break;
#if 0
#ifdef WIN9XONLY
			case 50:	t_User = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_username;
						break;
#endif
#endif // #if 0
			}
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetCHString ( IDS_UserName, t_User ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_ActiveTime ) 
		{
			DWORD  t_ActiveTime;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_ActiveTime = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_time;
						break;
#endif
			case 2:		t_ActiveTime = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_time;
						break;
			case 1:		t_ActiveTime = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_time;
						break;
			case 10:	t_ActiveTime = ( (SESSION_INFO_10 *) pTmpBuf )->sesi10_time;
						break;
#if 0
#ifdef WIN9XONLY
			case 50:	t_ActiveTime = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_time;
						break;
#endif
#endif // #if 0
			}
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetWORD ( IDS_ActiveTime, t_ActiveTime ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_IdleTime ) 
		{
			DWORD  t_IdleTime;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_IdleTime = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_idle_time;
						break;
#endif
			case 2:		t_IdleTime = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_idle_time;
						break;
			case 1:		t_IdleTime = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_idle_time;
						break;
			case 10:	t_IdleTime = ( (SESSION_INFO_10 *) pTmpBuf )->sesi10_idle_time;
						break;
#if 0
#ifdef WIN9XONLY
			case 50:	t_IdleTime = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_idle_time;
						break;
#endif
#endif
			}

			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetWORD ( IDS_IdleTime, t_IdleTime ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_NumOpens ) 
		{
			DWORD  t_NumOpens;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_NumOpens = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_num_opens;
						break;
#endif
			case 2:		t_NumOpens = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_num_opens;
						break;
			case 1:		t_NumOpens = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_num_opens;
						break;
#if 0
#ifdef WIN9XONLY
			case 50:	t_NumOpens = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_num_opens;
						break;
#endif
#endif
			}
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetWORD ( IDS_ResourcesOpened, t_NumOpens ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{	
		if ( dwPropertiesReq & SESSION_PROP_TransportName ) 
		{
			CHString  t_TransportName;
#ifdef NTONLY
			if  ( a_Level == 502 )
			{
				t_TransportName = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_transport;
			}
#endif

#if 0
#ifdef WIN9XONLY
			if  ( a_Level == 50 )
			{
				WCHAR w_TName[100];
				w_TName[0] = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_protocol;
				w_TName [ 1 ] = _T('\0');
				t_TransportName = w_TName;
			}
#endif
#endif
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetCHString ( IDS_TransportName, t_TransportName ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_ClientType ) 
		{
			CHString  t_ClientType;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_ClientType = ( (SESSION_INFO_502 *) pTmpBuf)->sesi502_cltype_name;
						break;
#endif

#if 0
#ifdef WIN9XONLY 
			case 2:		t_ClientType = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_cltype_name;
						break;
#endif
#endif // #if 0
			}
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetCHString ( IDS_ClientType, t_ClientType ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

#ifdef NTONLY
	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_SessionType ) 
		{
			DWORD dwflags;
			DWORD dwSessionType;

			switch ( a_Level )
			{
			case 502 :  dwflags = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_user_flags;
						break;
			}

			switch ( dwflags )
			{
			case SESS_GUEST:	dwSessionType =  0;
								break;

			case SESS_NOENCRYPTION: dwSessionType = 1;
									break;

			default : dwSessionType =  dwSessionType = 2;
			}

			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetDWORD ( IDS_SessionType, dwSessionType ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}
#endif

	return hRes;
}

#if 0
#ifdef WIN9XONLY

/*****************************************************************************
*
*  FUNCTION    :    CSession::Enum9XSessionInfo
*
*  DESCRIPTION :    Enumerating all the Sessions on 9X
*
*****************************************************************************/

HRESULT CSession :: Enum9XSessionInfo (

	short  a_Level,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	NET_API_STATUS t_Status = NERR_Success;
	HRESULT hRes = WBEM_S_NO_ERROR;

	unsigned short dwNoOfEntriesRead = 0;
	unsigned short dwTotalSessions = 0;

	void *pBuf = NULL;
	void *pTmpBuf = NULL;
	DWORD dwSize = 0;

	// Determine the size of the structure, for the level passed.
	switch ( a_Level )
	{
		case 1:  dwSize = sizeof ( SESSION_INFO_1 );
				 break;
        case 2:  dwSize = sizeof ( SESSION_INFO_2 );
				 break;
		case 10: dwSize = sizeof ( SESSION_INFO_10 );
				 break;
		case 50:  dwSize = sizeof ( SESSION_INFO_50 );
				 break;
	}

	unsigned short  cbBuffer = MAX_ENTRIES * dwSize;

	pBuf = ( char FAR * )  malloc ( cbBuffer );

	if ( pBuf != NULL )
	{
		try
		{
			t_Status =  NetSessionEnum(
							NULL,      
							a_Level,                       
							(char FAR *) pBuf,                
							cbBuffer,           
							&dwNoOfEntriesRead, 
							&dwTotalSessions   
						);

			if ( ( t_Status == ERROR_MORE_DATA ) || ( dwTotalSessions > dwNoOfEntriesRead ) )
			{
				// Free the buffer and make a API call again by allocating a buffer of the required size.
				free ( pBuf );
				pBuf = NULL;

				cbBuffer = ( dwTotalSessions * dwSize );

				pBuf = ( char FAR * )  malloc ( cbBuffer );

				if ( pBuf != NULL )
				{
					try
					{
						t_Status =  NetSessionEnum(
										NULL,      
										a_Level,                       
										( char FAR *) pBuf,                
										cbBuffer,           
										&dwNoOfEntriesRead, 
										&dwTotalSessions   
						);

						if ( t_Status != NERR_Success )
						{
							hRes = WBEM_E_FAILED;
						}
					}
					catch ( ... )
					{
						if ( pBuf != NULL )
						{
							free ( pBuf );
						}
						pBuf = NULL;
					}
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
		}
		catch ( ... )
		{
			if ( pBuf != NULL )
			{
				free ( pBuf );
				pBuf = NULL;
			}
			throw;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}
	
	if ( SUCCEEDED ( hRes ) )
	{
		if ( ( dwNoOfEntriesRead > 0 ) && ( pBuf != NULL ) )
		{
			try
			{
				pTmpBuf = pBuf;

				for ( int i = 0; i < dwNoOfEntriesRead; i++ )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
				
					hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );

					if ( SUCCEEDED ( hRes ) )
					{
						hRes = pInstance->Commit();
				
						if ( FAILED ( hRes ) )
						{
							break;
						}
					}
	
					// here need to go to the next structure based on the level, we will typecast with the apropriate structure
					// and then increment by one
					switch ( a_Level )
					{
					case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
								pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
								pTmpTmpBuf2 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf2;
								break;
					case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
								pTmpTmpBuf1 = ( SESSION_INFO_1 *) pTmpBuf;
								pTmpTmpBuf1 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf1;
								break;
					case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
								pTmpTmpBuf10 = ( SESSION_INFO_10 *) pTmpBuf;
								pTmpTmpBuf10 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf10;
								break;
					case 50:	SESSION_INFO_50 *pTmpTmpBuf50;
								pTmpTmpBuf50 = ( SESSION_INFO_50 *) pTmpBuf;
								pTmpTmpBuf50 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf50;
								break;
					default:	hRes = WBEM_E_FAILED; 
					}
				}
			}
			catch ( ... )
			{
				free ( pBuf );
				pBuf = NULL;
				throw;
			}
			free ( pBuf );
			pBuf = NULL;
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::FindAndSet9XSession
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CSession::FindAndSet9XSession ( 
									   
	LPCWSTR a_ComputerName, 
	LPWSTR a_UserName, 
	short a_Level, 
	DWORD dwPropertiesReq, 								
	CInstance *pInstance, 
	DWORD eOperation 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;		
	CHString t_TempKey;

	t_TempKey.Format ( L"%s%s",L"\\\\", a_ComputerName );

	unsigned short dwNoOfEntriesRead = 0;
	unsigned short dwTotalSessions = 0;

	void *pBuf = NULL;
	void *pTmpBuf = NULL;
	DWORD dwSize = 0;

	// Determine the size of the structure, for the level passed.
	switch ( a_Level )
	{
		case 1:  dwSize = sizeof ( SESSION_INFO_1 );
				 break;
        case 2:  dwSize = sizeof ( SESSION_INFO_2 );
				 break;
		case 10: dwSize = sizeof ( SESSION_INFO_10 );
				 break;
		case 50: dwSize = sizeof ( SESSION_INFO_50 );
				 break;
	}

	unsigned short  cbBuffer = 0; 

	t_Status =  NetSessionGetInfo(
					NULL,
					(const char FAR *) ( a_UserName.GetBuffer ( 0 ) ),    
					a_Level,                      
					( char FAR * ) pBuf,               
					cbBuffer,          
					&dwTotalSessions 
				);

	hRes =  dwTotalSessions == 0 ? WBEM_E_NOT_FOUND : hRes;

	if ( SUCCEEDED ( hRes ) )
	{
		// here we need to read all the entries associated with the user, and then 
		// search from this list for a given computer
		if ( t_Status != NERR_BufTooSmall )
		{

			cbBuffer = dwTotalSessions * dwSize;

			pBuf = ( char FAR * )  malloc ( cbBuffer );

			if ( pBuf != NULL )
			{
				t_Status =  NetSessionGetInfo(
								NULL,
								(const char FAR *) ( a_UserName.GetBuffer ( 0 ) ),    
								a_Level,                      
								( char FAR * ) pBuf,               
								cbBuffer,          
								&dwTotalSessions 
							);
				try 
				{
					// now search for a given computer
					void *pTempBuf = pBuf;
					int i = 0;
					for ( i = 0; i < dwTotalSessions; i ++ )
					{
						CHString t_CompName;

						switch ( a_Level )
						{
						case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
									pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
									t_CompName = pTmpTmpBuf2->sesi2_cname;
									break;

						case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
									pTmpTmpBuf1 = (SESSION_INFO_1 *) pTmpBuf;
									t_CompName = pTmpTmpBuf1->sesi1_cname;
									break;

						case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
									pTmpTmpBuf10 = (SESSION_INFO_10 *) pTmpBuf;
									t_CompName = pTmpTmpBuf10->sesi10_cname;
									break;
						case 50:	SESSION_INFO_50 *pTmpTmpBuf50;
										pTmpTmpBuf50 = (SESSION_INFO_50 *) pTmpBuf;
										t_CompName = pTmpTmpBuf50->sesi50_cname;
										break;
						}

						if ( a_ComputerName.CompareNoCase ( t_TempKey ) == 0 )
						{
							break;
						}
						// otherwise need to go to the next entry;
						switch ( a_Level )
						{
						case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
									pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
									pTmpTmpBuf2++;
									pTmpBuf = ( void * ) pTmpTmpBuf2;
									break;

						case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
									pTmpTmpBuf1 = (SESSION_INFO_1 *) pTmpBuf;
									pTmpTmpBuf1++;
									pTmpBuf = ( void * ) pTmpTmpBuf1;
									break;

						case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
									pTmpTmpBuf10 = (SESSION_INFO_10 *) pTmpBuf;
									pTmpTmpBuf10++;
									pTmpBuf = ( void * ) pTmpTmpBuf10;
									break;
						case 50:	SESSION_INFO_50 *pTmpTmpBuf50;
									pTmpTmpBuf50 = (SESSION_INFO_50 *) pTmpBuf;
									pTmpTmpBuf50++;
									pTmpBuf = ( void * ) pTmpTmpBuf50;
									break;
						}
					}
					if ( i >= dwTotalSessions )
					{
						hRes = WBEM_E_NOT_FOUND;
					}
				}
				catch ( ... )
				{
					free ( pBuf );
					throw;
				}
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			switch ( eOperation )
			{
			case Get:	hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );
						break;
			// Expects  a Session Key as a parameter and as a result we need to read more than one structure for every instance.
			// but the documents say it requires a sharename.
		/*	case Delete: hRes =  t_Status = NetSessionDel( 
										NULL,
										(LPTSTR) t_TempKey.GetBuffer ( 0 ), 
										(LPTSTR) a_UserName.GetBuffer ( 0 ) ;
								 );
								 hRes = t_Status == NERR_Success ? hRes : WBEM_E_FAILED;
								 break;*/
		

			default:	hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
						break;
			}
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;

			throw;
		}
		free ( pBuf );
		pBuf = NULL;
	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    Session::Optimize9XQuery
*
*  DESCRIPTION :    Optimizes a query based on the key values.
*
*****************************************************************************/

HRESULT CSession::Optimize9XQuery ( 
									  
	CHStringArray &a_ComputerValues, 
	CHStringArray &a_UserValues,
	short a_Level,
	MethodContext *pMethodContext, 
	DWORD dwPropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	if  ( a_ComputerValues.GetSize() == 0 ) 
	{
		// This is a query for which there is no where clause, so it means only a few Properties are requested
		// hence we need to deliver only those properties of instances to the WinMgmt while enumerating Sessions
		hRes = Enum9XSessionInfo ( 

						a_Level,
						pMethodContext,
						dwPropertiesReq
					);
	}
	else
	if  ( a_UserValues.GetSize() != 0 ) 
	{
		DWORD	dwNoOfEntriesRead = 0;
		DWORD   dwTotalSessions = 0;
		void *pBuf = NULL;
		void *pTmpBuf = NULL;
		DWORD dwSize = 0;
		BOOL bNoMoreEnums = FALSE;
		// Determine the size of the structure, for the level passed.
		switch ( a_Level )
		{
			case 1:  dwSize = sizeof ( SESSION_INFO_1 );
					 break;
			case 2:  dwSize = sizeof ( SESSION_INFO_2 );
					 break;
			case 10: dwSize = sizeof ( SESSION_INFO_10 );
					 break;
			case 50: dwSize = sizeof ( SESSION_INFO_50 );
					 break;
		}

		for ( int i = 0; i < a_UserValues.GetSize(); i++ )
		{
			unsigned short  cbBuffer = 0; 

			t_Status =  NetSessionGetInfo(
							NULL,
							(const char FAR *) ( a_UserValues.GetAt ( i ).GetBuffer ( 0 ) ),    
							a_Level,                      
							( char FAR * ) pBuf,               
							cbBuffer,          
							(unsigned short FAR *) dwTotalSessions 
						);

			if ( dwTotalSessions == 0 )
			{
				continue;
			}

			if ( SUCCEEDED ( hRes ) )
			{
				// here we need to read all the entries associated with the user, and then 
				// search from this list for a given computer
				if ( t_Status != NERR_BufTooSmall )
				{

					cbBuffer = dwTotalSessions * dwSize;

					pBuf = ( char FAR * )  malloc ( cbBuffer );

					if ( pBuf != NULL )
					{
						t_Status =  NetSessionGetInfo(
										NULL,
										(const char FAR *) ( a_UserValues.GetAt ( i ).GetBuffer ( 0 ) ),    
										a_Level,                      
										( char FAR * ) pBuf,               
										cbBuffer,          
										(unsigned short FAR *) dwTotalSessions 
									);
						try 
						{
							void *pTempBuf = pBuf;
							int i = 0;
							for ( i = 0; i < dwTotalSessions; i ++ )
							{
								CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
							
								hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );

								if ( SUCCEEDED ( hRes ) )
								{
									hRes = pInstance->Commit();
							
									if ( FAILED ( hRes ) )
									{
										bNoMoreEnums = TRUE;
										break;
									}
								}

								if ( bNoMoreEnums )
								{
									break;
								}

								// otherwise need to go to the next entry;
								switch ( a_Level )
								{
								case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
											pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
											pTmpTmpBuf2++;
											pTmpBuf = ( void * ) pTmpTmpBuf2;
											break;

								case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
											pTmpTmpBuf1 = (SESSION_INFO_1 *) pTmpBuf;
											pTmpTmpBuf1++;
											pTmpBuf = ( void * ) pTmpTmpBuf1;
											break;

								case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
											pTmpTmpBuf10 = (SESSION_INFO_10 *) pTmpBuf;
											pTmpTmpBuf10++;
											pTmpBuf = ( void * ) pTmpTmpBuf10;
											break;
								case 50:	SESSION_INFO_50 *pTmpTmpBuf50;
											pTmpTmpBuf50 = (SESSION_INFO_50 *) pTmpBuf;
											pTmpTmpBuf50++;
											pTmpBuf = ( void * ) pTmpTmpBuf50;
											break;
								}
							}
						}
						catch ( ... )
						{
							free ( pBuf );
							pBuf = NULL;
							throw;
						}
						free ( pBuf );
						pBuf = NULL;
					}
					else
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}
			}
		}
	}
	else
	{
		hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::Get9XLevelInfo
*
*  DESCRIPTION :    Getting the level info, so that the appropriate structure
*					Can be passed to make a call.
*
*****************************************************************************/

void CSession :: Get9XLevelInfo ( 

	DWORD dwPropertiesReq,
	short *a_Level 
)
{
	// Right now making an assumption that Transport/Protocol name is not required 
	// as otherwise we will need to make 2 api calls if we need to get Protocol and Clienttype.
	// There is no support for the other levels other than level 50.

	*a_Level = 50;
	/*if ( dwPropertiesReq == SESSION_ALL_PROPS )  
	{
		*a_Level = 2;
	}
	else
	if (dwPropertiesReq & SESSION_PROP_NumOpens)
	{
		*a_Level = 1;
	}
	else
	{
		*a_Level = 10;
	}*/
} 

#endif 
#endif // #if 0

/*****************************************************************************
*
*  FUNCTION    :    CSession::SetPropertiesReq
*
*  DESCRIPTION :    Setting a bitmap for the required properties
*
*****************************************************************************/

void CSession :: SetPropertiesReq ( 
									 
	CFrameworkQuery &Query,
	DWORD &dwPropertiesReq
)
{
	dwPropertiesReq = 0;

	if ( Query.IsPropertyRequired ( IDS_ComputerName ) )
	{
		dwPropertiesReq |= SESSION_PROP_Computer;
	}
	if ( Query.IsPropertyRequired ( IDS_UserName ) )
	{
		dwPropertiesReq |= SESSION_PROP_User;
	}
	if ( Query.IsPropertyRequired ( IDS_SessionType ) )
	{
		dwPropertiesReq |= SESSION_PROP_SessionType;
	}
	if ( Query.IsPropertyRequired ( IDS_ClientType ) )
	{
		dwPropertiesReq |= SESSION_PROP_ClientType;
	}
	if ( Query.IsPropertyRequired ( IDS_TransportName ) )
	{
		dwPropertiesReq |= SESSION_PROP_TransportName;
	}
	if ( Query.IsPropertyRequired ( IDS_ResourcesOpened ) )
	{
		dwPropertiesReq |= SESSION_PROP_NumOpens;
	}
	if ( Query.IsPropertyRequired ( IDS_ActiveTime ) )
	{
		dwPropertiesReq |= SESSION_PROP_ActiveTime;
	}
	if ( Query.IsPropertyRequired ( IDS_IdleTime ) )
	{
		dwPropertiesReq |= SESSION_PROP_IdleTime;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\connectiontoshare.h ===
/******************************************************************



 ConnectionToShare.h -- 



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#include "Connshare.h"

#ifndef  _CONNTOSHARE_H_
#define  _CONNTOSHARE_H_

class CConnectionToShare : public Provider, public CConnShare
{
private:

#ifdef NTONLY
	HRESULT  EnumNTConnectionsFromComputerToShare ( 

		CHString a_ComputerName,
		CHString a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif

#if 0
#ifdef WIN9XONLY
	HRESULT  Enum9XConnectionsFromComputerToShare ( 

		CHString a_ComputerName,
		CHString a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif
#endif // 0
	HRESULT LoadInstance ( 
												
		CInstance *pInstance,
		CHString a_ComputerName, 
		CHString a_ShareName,
		CONNECTION_INFO *pBuf, 
		DWORD dwPropertiesReq
	);


	HRESULT GetShareKeyVal ( 
		
		CHString a_Key, 
		CHString &a_Share 
	);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;
		

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

public:

        CConnectionToShare (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CConnectionToShare () ;

private:

} ;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\connshare.h ===
/******************************************************************



 ConnShare.h-- Definition of base class from which ConnectionToShare

			   ConnectionToSession and Connection classes are derived



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#ifndef _CCONNSHARE_
#define _CCONNSHARE_

#ifdef UNICODE
#define TOBSTRT(x)        x
#else
#define TOBSTRT(x)        _bstr_t(x)
#endif

#if 0
#ifdef WIN9XONLY
#include "svrapi.h"
// max entries of the structure that can be read at a time.		#define		MAX_ENTRIES						50 
#define	MAX_ENTRIES							50

	// Typedefinition of the structures
	typedef struct connection_info_1	CONNECTION_INFO;
	typedef struct session_info_1		SESSION_INFO_1;
	typedef struct session_info_2		SESSION_INFO_2;
	typedef struct session_info_10		SESSION_INFO_10;
	typedef struct session_info_50		SESSION_INFO_50;
#endif
#endif // #if 0

#ifdef NTONLY
#include <lm.h>
#include <LMShare.h>
	// COnnection INfo Structure Type defininition
	typedef CONNECTION_INFO_1			CONNECTION_INFO;
#endif

class CConnShare
{
public:
    CConnShare ( ) ;

    virtual ~CConnShare () ;

#ifdef NTONLY
	HRESULT FindAndSetNTConnection ( LPWSTR t_ShareName, LPCWSTR t_NetName, LPCWSTR t_UserName, 
													DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation );
	HRESULT GetNTShares ( CHStringArray &t_Shares );
	virtual HRESULT EnumNTConnectionsFromComputerToShare ( LPWSTR a_ComputerName, LPWSTR a_ShareName, 
													MethodContext *pMethodContext, DWORD dwPropertiesReq ) = 0;
#endif

#if 0
#ifdef WIN9XONLY
	HRESULT FindAndSet9XConnection ( LPWSTR t_ShareName, LPCWSTR t_NetName, LPCWSTR t_UserName, 
													DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation );
	virtual HRESULT Enum9XConnectionsFromComputerToShare ( LPWSTR a_ComputerName, LPWSTR a_ShareName, 
													MethodContext *pMethodContext, DWORD dwPropertiesReq ) = 0;
	HRESULT Get9XShares ( CHStringArray &t_Shares );
#endif
#endif // #if 0

	// These are common methods irrespective of OS
	virtual HRESULT LoadInstance ( CInstance *pInstance, LPCWSTR a_Share, LPCWSTR a_Computer, CONNECTION_INFO *pBuf, 
										DWORD dwPropertiesReq ) = 0;
	HRESULT EnumConnectionInfo ( LPWSTR a_ComputerName, LPWSTR a_ShareName, MethodContext *pMethodContext, 
													DWORD dwPropertiesReq );
	HRESULT GetConnectionsKeyVal ( LPCWSTR a_Key, CHString &a_ComputerName, CHString &a_ShareName, CHString &a_UserName );
	HRESULT AddToObjectPath ( LPWSTR &a_ObjPathString, LPCWSTR a_AttributeName, LPCWSTR  a_AttributeVal );
	HRESULT MakeObjectPath ( LPWSTR &a_ObjPathString, LPCWSTR a_ClassName, LPCWSTR a_AttributeName, LPCWSTR  a_AttributeVal );
private:

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\session.h ===
/******************************************************************



 Session.h--



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#ifndef  _SESSION_H_
#define  _SESSION_H_

#ifdef NTONLY
#include <lm.h>
#endif

#if 0
#ifdef WIN9XONLY
#include "Connshare.h"
#endif
#endif // #if 0
class CSession : public Provider 
{

private:

#ifdef NTONLY
	HRESULT EnumNTSessionInfo (
	
		LPWSTR lpComputerName,
		LPWSTR lpUserName,
		short a_Level,
		MethodContext *pMethodContext,
		DWORD dwPropertiesReq
	);

	HRESULT FindAndSetNTSession ( 
												   
		LPCWSTR t_ComputerName,
		LPWSTR t_UserName,
		short t_Level,
		DWORD dwPropertiesReq, 
		CInstance *pInstance, 
		DWORD eOperation 
	);

	HRESULT OptimizeNTQuery ( 
										  
		CHStringArray& a_ComputerValues, 
		CHStringArray& a_UserValues,
		short a_Level,
		MethodContext *pMethodContext, 
		DWORD dwPropertiesReq 
	);

	void GetNTLevelInfo ( 
		
		DWORD dwPropertiesReq,
		short *a_Level
	);

#endif

#if 0
#ifdef WIN9XONLY
	HRESULT Enum9XSessionInfo (
	
		short a_Level,
		MethodContext *pMethodContext,
		DWORD dwPropertiesReq
	);

	HRESULT FindAndSet9XSession ( 
												   
		CHString &t_ComputerName,
		CHString &_UserName,
		short t_Level,
		DWORD dwPropertiesReq, 
		CInstance *pInstance, 
		DWORD eOperation 
	);

	HRESULT Optimize9XQuery ( 
										  
		CHStringArray &a_ComputerValues, 
		CHStringArray &a_UserValues,
		short a_Level,
		MethodContext *pMethodContext, 
		DWORD dwPropertiesReq 
	);

	void Get9XLevelInfo ( 
		
		DWORD dwPropertiesReq,
		short *a_Level
	);

#endif
#endif // #if 0

	HRESULT LoadData ( 
						
		short a_Level,
		void *pTmpBuf,
		DWORD dwPropertiesReq,
		CInstance *pInstance
	);

	void SetPropertiesReq ( 

		CFrameworkQuery &Query,  
		DWORD &dwPropertiesReq
	);

protected:
   
    HRESULT EnumerateInstances ( 

		MethodContext *pMethodContext, 
		long lFlags = 0L
	) ;
	
    HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags,
		CFrameworkQuery &Query
	) ;

    HRESULT ExecQuery ( 

		MethodContext *pMethodContext, 
		CFrameworkQuery& Query, 
		long lFlags = 0
	) ;

    HRESULT DeleteInstance (

		const CInstance& Instance, 
		long lFlags = 0L
	) ;

public:

	CSession (

		LPCWSTR lpwszClassName, 
		LPCWSTR lpwszNameSpace
	) ;

    virtual ~CSession () ;

private:
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win32thk.h ===
//////////////////////////////////////////////////////////////////////////////

//

// Module:

//

//   win32thk.h

//

// History:

//

//   jennymc    8/2/95  Initial version

//

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _WIN32THK_H_
#define _WIN32THK_H_

#ifdef WIN9XONLY
#define CIM16NET_DLL "CIM16NET.dll"
#define CIM32NET_DLL "CIM32NET.dll"

typedef unsigned long FAR * LPULONG;
typedef unsigned short FAR * LPUSHORT;

#ifdef _WIN32
#pragma pack(push, 1)
#include <lmcons.h>
#else
#include <netcons.h>
#define LM20_DEVLEN DEVLEN
#define LM20_RMLEN RMLEN
#endif

typedef struct _use_info_1 {
    char	   ui1_local[LM20_DEVLEN+1];
    char	   ui1_pad_1;
    char far *	   ui1_remote;
    char far *	   ui1_password;
    unsigned short ui1_status;
    short 	   ui1_asg_type;
    unsigned short ui1_refcount;
    unsigned short ui1_usecount;
} use_info_1;	/* use_info_1 */

typedef struct _use_info_1Out {
    char	   ui1_local[8+1];
    char	   ui1_pad_1;
    char  	   ui1_remote[LM20_RMLEN + 2];
    unsigned short ui1_status;
    short 	   ui1_asg_type;
    unsigned short ui1_refcount;
    unsigned short ui1_usecount;
} use_info_1Out;

typedef struct _LOGONDETAILS
{
   ULONG AuthorizationFlags; 
   LONG LastLogon;
   LONG LastLogoff;
   LONG AccountExpires;
   ULONG MaximumStorage; 
   USHORT UnitsPerWeek;
   unsigned char LogonHours[21]; 
   USHORT BadPasswordCount;
   USHORT NumberOfLogons;
   USHORT CountryCode;
   USHORT CodePage; 
} LOGONDETAILS, FAR *LPLOGONDETAILS;

// Config Manager definitions
typedef DWORD DEVNODE;
typedef DEVNODE FAR * PDEVNODE;
typedef	DWORD CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE FAR * PCMBUSTYPE;	// Pointer to a bus type.
typedef	DWORD LOG_CONF;	// Logical configuration.
typedef	LOG_CONF FAR * PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD RES_DES;	// Resource descriptor.
typedef	RES_DES FAR * PRES_DES;	// Pointer to resource descriptor.
typedef	ULONG RESOURCEID;	// Resource type ID.
typedef	RESOURCEID FAR * PRESOURCEID;	// Pointer to resource type ID.
typedef DWORD RANGE_LIST;
typedef DWORD RANGE_ELEMENT;
typedef RANGE_ELEMENT FAR * PRANGE_ELEMENT;

/*
Format of hard disk master boot sector:
Offset	Size	Description	(Table 0574)
 00h 446 BYTEs	Master bootstrap loader code
1BEh 16 BYTEs	partition record for partition 1 (see #0575)
1CEh 16 BYTEs	partition record for partition 2
1DEh 16 BYTEs	partition record for partition 3
1EEh 16 BYTEs	partition record for partition 4
1FEh	WORD	signature, AA55h indicates valid boot block

Format of partition record:
Offset	Size	Description	(Table 0575)
 00h	BYTE	boot indicator (80h = active partition)
 01h	BYTE	partition start head
 02h	BYTE	partition start sector (bits 0-5)
 03h	BYTE	partition start track (bits 8,9 in bits 6,7 of sector)
 04h	BYTE	operating system indicator (see #0576)
 05h	BYTE	partition end head
 06h	BYTE	partition end sector (bits 0-5)
 07h	BYTE	partition end track (bits 8,9 in bits 6,7 of sector)
 08h	DWORD	sectors preceding partition
 0Ch	DWORD	length of partition in sectors
 */

typedef struct  
{
    BYTE cBoot;
    BYTE cStartHead;
    BYTE cStartSector;
    BYTE cStartTrack;
    BYTE cOperatingSystem;
    BYTE cEndHead;
    BYTE cEndSector;
    BYTE cEndTrack;
    DWORD dwSectorsPreceding;
    DWORD dwLengthInSectors;
} PartitionRecord, FAR *pPartitionRecord;

typedef struct 
{
    BYTE cLoader[446];
    PartitionRecord stPartition[4];
    WORD wSignature;
} MasterBootSector, FAR *pMasterBootSector;

typedef struct
{
    // Article ID: Q140418 & Windows NT Server 4.0 resource kit - Chap 3 (partition boot sector)
    BYTE cJMP[3];
    BYTE cOEMID[8];
    WORD wBytesPerSector;
    BYTE cSectorsPerCluster;
    WORD wReservedSectors;
    BYTE cFats;
    WORD cRootEntries;
    WORD wSmallSectors;
    BYTE cMediaDescriptor;
    WORD wSectorsPerFat;
    WORD wSectorsPerTrack;
    WORD wHeads;
    DWORD dwHiddenSectors;
    DWORD dwLargeSectors;

    // ExtendedBiosParameterBlock (not always supported)
    BYTE cPhysicalDriveNumber;
    BYTE cCurrentHead;
    BYTE cSignature;
    DWORD dwID;
    BYTE cVolumeLabel[11];
    BYTE cSystemID[8];

    BYTE cBootStrap[448];
    BYTE cEndOfSector[2];

} PartitionBootSector, FAR *pPartitionBootSector;

typedef struct
{
    DWORD dwMaxCylinder;
    DWORD dwMaxSector;
    DWORD dwMaxHead;

    // This is really an __int64, but the 16bit compiler doesn't understand about those
    DWORD dwSectors[2];  

    WORD wFlags;
    WORD wSectorSize;

    WORD wExtStep;

} Int13DriveParams, FAR *pInt13DriveParams;

typedef BYTE (WINAPI *fnGetWin9XPartitionTable) (BYTE cDrive, pMasterBootSector pMBR);
typedef BYTE (WINAPI *fnGetWin9XDriveParams) (BYTE cDrive, pInt13DriveParams pParams);
typedef WORD (WINAPI *fnGetWin9XBiosUnit) (LPSTR lpDeviceID);
typedef ULONG (WINAPI *fnGetWin9XUseInfo1)(LPSTR Name, LPSTR Local, LPSTR Remote, LPSTR Password, LPULONG pdwStatus, LPULONG pdwType, LPULONG pdwRefCount, LPULONG pdwUseCount);
typedef DWORD (WINAPI *fnGetWin9XFreeSpace) (DWORD option);

 //////////////////////////////////////////////////////////////////////
#ifdef _WIN32
#pragma pack(pop)
#endif

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\sessionconnectioncommon.h ===
/******************************************************************

   SessionConnectionCommon.h -- 



   Description:  Definition of the headers

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/
// Common routines required for Session and connection  Provider

//#ifndef UNICODE
//#define UNICODE
//#endif

#ifndef  _CSESSIONCONNECTIONCOMMON_H
#define  _CSESSIONCONNECTIONCOMMON_H

#define	NTONLY
//#define WIN9XONLY

#define	Namespace								L"root\\cimv2"

// Provider Classess
#define PROVIDER_NAME_CONNECTION				L"Win32_ServerConnection"
#define PROVIDER_NAME_SESSION					L"Win32_ServerSession"
#define PROVIDER_NAME_CONNECTIONTOSHARE			L"Win32_ConnectionShare"
#define PROVIDER_SHARE							L"Win32_Share"
#define PROVIDER_NAME_CONNECTIONTOSESSION		L"Win32_SessionConnection"

// Property names for Connection
const static WCHAR *IDS_ShareName					= L"sharename" ;	
const static WCHAR *IDS_ComputerName				= L"computername" ;
const static WCHAR *IDS_UserName					= L"UserName" ;
const static WCHAR *IDS_NumberOfFiles				= L"NumberOfFiles" ;
const static WCHAR *IDS_ActiveTime					= L"ActiveTime" ;
const static WCHAR *IDS_ConnectionID				= L"ConnectionID" ;
const static WCHAR *IDS_NumberOfUsers				= L"NumberOfUsers" ;

// for session in addition to ComputerName, ShareName  and ActiveTime
const static WCHAR *IDS_ResourcesOpened				= L"resourcesopened" ;
const static WCHAR *IDS_IdleTime					= L"idletime" ;
const static WCHAR *IDS_SessionType					= L"sessiontype" ;
const static WCHAR *IDS_ClientType					= L"clienttype" ;
const static WCHAR *IDS_TransportName				= L"transportname" ;

// for Connection to Share 
const static WCHAR *IDS_Connection					= L"Dependent" ;
const static WCHAR *IDS_Resource					= L"Antecedent" ;

// property for ConnectionToSession
const static WCHAR *IDS_Session						= L"Antecedent" ;

// Win32_Share Key name
const static WCHAR *IDS_ShareKeyName				= L"Name" ;

// Defining bit values for the property, which will be used for defining the bitmap of properties required connections
#define CONNECTIONS_ALL_PROPS							0xFFFFFFFF
#define CONNECTIONS_PROP_ShareName						0x00000001
#define CONNECTIONS_PROP_ComputerName					0x00000002
#define CONNECTIONS_PROP_UserName						0x00000004
#define CONNECTIONS_PROP_NumberOfFiles					0x00000008
#define CONNECTIONS_PROP_ConnectionID					0x00000010
#define CONNECTIONS_PROP_NumberOfUsers					0x00000020
#define CONNECTIONS_PROP_ConnectionType					0x00000040
#define CONNECTIONS_PROP_ActiveTime						0x00000080

// Defining bit values for the property, which will be used for defining the bitmap of properties required for sessions
#define SESSION_ALL_PROPS								0xFFFFFFFF
#define SESSION_PROP_Computer							0x00000001
#define SESSION_PROP_User								0x00000002
#define SESSION_PROP_NumOpens							0x00000004
#define SESSION_PROP_ActiveTime							0x00000008
#define SESSION_PROP_IdleTime							0x00000010
#define SESSION_PROP_SessionType						0x00000020
#define SESSION_PROP_ClientType							0x00000040
#define SESSION_PROP_TransportName						0x00000080
#define SESSION_PROP_SessionKey							0x00000100
#define SESSION_PROP_NumOfConnections					0x00000200

// Property Bit Map for Connection To Share Association class
#define CONNECTIONSTOSHARE_ALL_PROPS					0xFFFFFFFF

// Property Bit Map for Connection To Session Association class
#define CONNECTIONSTOSESSION_ALL_PROPS					0xFFFFFFFF


enum { Get, Delete, NoOp };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\cim16net.c ===
//////////////////////////////////////////////////////////////////////////////

//

// Description:

//

//   This module contains the entry and exit functions for windows DLL

//   initialization and the 16 bit net functions.

//

//////////////////////////////////////////////////////////////////////////////

//

// History:

//

//  jennymc     8/2/95      Initial version

//  jennymc     1/8/98      modified for wbem

//

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////////////
//  These are specific data types defined in the thunk
//////////////////////////////////////////////////////////////////////////////

#define WIN32_LEAN_AND_MEAN 1
#define NOWINDOWSX 1

#include <windows.h>
#include <string.h>
#include <stdlib.h>

#define LANMAN_BUFFER_SIZE      0x0800
#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETERRORS
#define INCL_NETDOMAIN
#define INCL_NETUSE
#include "lan.h"

#define Not_VxD
typedef unsigned long ULONG;
#include "vmm.h"
#define MIDL_PASS
#include "configmg.h"

#include <win32thk.h>

//
#define MAKEWORD(low, high) \
           ((WORD)((((WORD)(high)) << 8) | ((BYTE)(low))))
#define SECTOR_SIZE 512       // Size, in bytes, of a disk sector
#define CARRY_FLAG  0x0001
#define __export _export

typedef BYTE FAR *LPBYTE;
typedef struct tagRMCS {

   DWORD edi, esi, ebp, RESERVED, ebx, edx, ecx, eax;
   WORD  wFlags, es, ds, fs, gs, ip, cs, sp, ss;
} RMCS, FAR* LPRMCS;
BOOL FAR PASCAL SimulateRM_Int (BYTE bIntNum, LPRMCS lpCallStruct);

void FAR PASCAL BuildRMCS (LPRMCS lpCallStruct);

//////////////////////////////////////////////////////////////////////////////

BOOL WINAPI _export DllEntryPoint (DWORD dwReason,
                               WORD  hInst,
                               WORD  wDS,
                               WORD  wHeapSize,
                               DWORD dwReserved1,
                               WORD  wReserved2);

BOOL WINAPI _export win32thk_ThunkConnect16(LPSTR pszDll16,
                                   LPSTR pszDll32,
                                   WORD  hInst,
                                   DWORD dwReason);



//////////////////////////////////////////////////////////////////////////////
//  NET FUNCTIONS
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
// Function:
//
//   WEP(int)
//
// Description:
//
//   This function is called when the DLL is unloaded by the last application
//   which has it open.
//
//////////////////////////////////////////////////////////////////////////////

VOID FAR PASCAL WEP(int bSystemExit)
{

  return;
}

//////////////////////////////////////////////////////////////////////
ULONG WINAPI _export CIM16GetUserInfo1(LPSTR Name,	LPSTR HomeDirectory,
					   LPSTR Comment, LPSTR ScriptPath, LPULONG PasswordAge,
					   LPUSHORT Privileges, LPUSHORT Flags )
{
	// Used to get the the data
	struct user_info_1 * lpUserInfo1;
	char szBuffer[LANMAN_BUFFER_SIZE];
	char szLogon[LANMAN_BUFFER_SIZE];
	USHORT uSize = LANMAN_BUFFER_SIZE,uTotal=0;
	ULONG apiRc;

	apiRc = NetGetDCName(NULL,NULL,szLogon,uSize);
	if( apiRc == NERR_Success ){

		//***********************************************************	
		//  Get info for User Info 1
		//***********************************************************	
		apiRc = NetUserGetInfo(szLogon,Name,1,szBuffer,uSize,&uTotal );
		if (apiRc == NERR_Success){
		
			//***********************************************************	
			//  Assign the stuff we got from the user_info_1 struct
			//***********************************************************	
			lpUserInfo1 = (struct user_info_1 * ) szBuffer;
			strcpy( HomeDirectory, lpUserInfo1->usri1_home_dir);
			strcpy( ScriptPath, lpUserInfo1->usri1_script_path);
			strcpy( Comment,lpUserInfo1->usri1_comment);
			*PasswordAge = lpUserInfo1->usri1_password_age;
			*Privileges  = lpUserInfo1->usri1_priv;
			*Flags       = lpUserInfo1->usri1_flags;
		}	
	}	
	return apiRc;
}
//////////////////////////////////////////////////////////////////////
ULONG WINAPI __export CIM16GetUserInfo2(LPSTR Name, LPSTR FullName,
	LPSTR UserComment, LPSTR Parameters, LPSTR Workstations,
	LPSTR LogonServer,	LPLOGONDETAILS LogonDetails )

{
	// Used to get the the data
	struct user_info_2 * lpUserInfo2;
	char szBuffer[LANMAN_BUFFER_SIZE];
	char szLogon[LANMAN_BUFFER_SIZE];
	USHORT uSize = LANMAN_BUFFER_SIZE,uTotal=0;
	ULONG apiRc;
	
	apiRc = NetGetDCName(NULL,NULL,szLogon,uSize);
	if( apiRc == NERR_Success ){
		
		//***********************************************************	
		// Get the user_info_2 struct stuff
		//***********************************************************	
		apiRc = NetUserGetInfo(szLogon,Name,2,szBuffer,uSize,&uTotal );
		if (apiRc == NERR_Success){
		
			//***********************************************************	
			//  Assign the stuff we got from the user_info_1 struct
			//***********************************************************	
			lpUserInfo2 = (struct user_info_2 * ) szBuffer;
			strcpy( FullName,lpUserInfo2->usri2_full_name );
			strcpy( UserComment,lpUserInfo2->usri2_usr_comment);
			strcpy( Parameters,lpUserInfo2->usri2_parms);
			strcpy( Workstations,lpUserInfo2->usri2_workstations);
			strcpy( LogonServer,lpUserInfo2->usri2_logon_server);
			
			strcpy(LogonDetails->LogonHours,lpUserInfo2->usri2_logon_hours);
			LogonDetails->AuthorizationFlags = lpUserInfo2->usri2_auth_flags;
			LogonDetails->LastLogon  = lpUserInfo2->usri2_last_logon;
			LogonDetails->LastLogoff  = lpUserInfo2->usri2_last_logoff;
			LogonDetails->AccountExpires = lpUserInfo2->usri2_acct_expires;
			LogonDetails->MaximumStorage = lpUserInfo2->usri2_max_storage;
			LogonDetails->UnitsPerWeek = lpUserInfo2->usri2_units_per_week;
			LogonDetails->BadPasswordCount = lpUserInfo2->usri2_bad_pw_count;
			LogonDetails->NumberOfLogons = lpUserInfo2->usri2_num_logons;
			LogonDetails->CountryCode = lpUserInfo2->usri2_country_code;
			LogonDetails->CodePage  = lpUserInfo2->usri2_code_page;
		}
	}
	return apiRc;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
ULONG WINAPI __export CIM16GetUserInfo1Ex(LPSTR Domain, LPSTR Name,	DWORD fGetDC, LPSTR HomeDirectory,
					   LPSTR Comment, LPSTR ScriptPath, LPULONG PasswordAge,
					   LPUSHORT Privileges, LPUSHORT Flags )
{
	// Used to get the the data
	struct user_info_1 * lpUserInfo1;
	char szBuffer[LANMAN_BUFFER_SIZE];
	char szLogon[LANMAN_BUFFER_SIZE];
	USHORT uSize = LANMAN_BUFFER_SIZE,uTotal=0;
	ULONG apiRc = 1;

    // If a domain was specified, use it to get the dc. Otherwise,
    // go straight to the NetUserGetInfoCall with the name of the
    // local machine for szLogon...
    if(fGetDC != 0)
    {
	    apiRc = NetGetDCName(NULL,Domain,szLogon,uSize);
        apiRc = NetUserGetInfo(szLogon,Name,1,szBuffer,uSize,&uTotal );
    }
    else
    {
        apiRc = NetUserGetInfo(NULL,Name,1,szBuffer,uSize,&uTotal );
    }

	if( apiRc == NERR_Success )
    {
    	//***********************************************************	
		//  Assign the stuff we got from the user_info_1 struct
		//***********************************************************	
		lpUserInfo1 = (struct user_info_1 * ) szBuffer;
		strcpy( HomeDirectory, lpUserInfo1->usri1_home_dir);
		strcpy( ScriptPath, lpUserInfo1->usri1_script_path);
		strcpy( Comment,lpUserInfo1->usri1_comment);
		*PasswordAge = lpUserInfo1->usri1_password_age;
		*Privileges  = lpUserInfo1->usri1_priv;
		*Flags       = lpUserInfo1->usri1_flags;
	}
	return apiRc;
}
//////////////////////////////////////////////////////////////////////
ULONG WINAPI __export CIM16GetUserInfo2Ex(LPSTR Domain, LPSTR Name, DWORD fGetDC, LPSTR FullName,
	LPSTR UserComment, LPSTR Parameters, LPSTR Workstations,
	LPSTR LogonServer,	LPLOGONDETAILS LogonDetails )

{
	// Used to get the the data
	struct user_info_2 * lpUserInfo2;
	char szBuffer[LANMAN_BUFFER_SIZE];
	char szLogon[LANMAN_BUFFER_SIZE];
	USHORT uSize = LANMAN_BUFFER_SIZE,uTotal=0;
	ULONG apiRc;
	
	// If a domain was specified, use it to get the dc. Otherwise,
    // go straight to the NetUserGetInfoCall with the name of the
    // local machine for szLogon...
    if(fGetDC != 0)
    {
	    apiRc = NetGetDCName(NULL,Domain,szLogon,uSize);
        apiRc = NetUserGetInfo(szLogon,Name,2,szBuffer,uSize,&uTotal );
    }
    else
    {
        apiRc = NetUserGetInfo(NULL,Name,2,szBuffer,uSize,&uTotal );
    }

	if( apiRc == NERR_Success )
    {
		//***********************************************************	
		//  Assign the stuff we got from the user_info_2 struct
		//***********************************************************	
		lpUserInfo2 = (struct user_info_2 * ) szBuffer;
		strcpy( FullName,lpUserInfo2->usri2_full_name );
		strcpy( UserComment,lpUserInfo2->usri2_usr_comment);
		strcpy( Parameters,lpUserInfo2->usri2_parms);
		strcpy( Workstations,lpUserInfo2->usri2_workstations);
		strcpy( LogonServer,lpUserInfo2->usri2_logon_server);
		
		strcpy(LogonDetails->LogonHours,lpUserInfo2->usri2_logon_hours);
		LogonDetails->AuthorizationFlags = lpUserInfo2->usri2_auth_flags;
		LogonDetails->LastLogon  = lpUserInfo2->usri2_last_logon;
		LogonDetails->LastLogoff  = lpUserInfo2->usri2_last_logoff;
		LogonDetails->AccountExpires = lpUserInfo2->usri2_acct_expires;
		LogonDetails->MaximumStorage = lpUserInfo2->usri2_max_storage;
		LogonDetails->UnitsPerWeek = lpUserInfo2->usri2_units_per_week;
		LogonDetails->BadPasswordCount = lpUserInfo2->usri2_bad_pw_count;
		LogonDetails->NumberOfLogons = lpUserInfo2->usri2_num_logons;
		LogonDetails->CountryCode = lpUserInfo2->usri2_country_code;
		LogonDetails->CodePage  = lpUserInfo2->usri2_code_page;
	}
	return apiRc;
}

//////////////////////////////////////////////////////////////////////
API_RET_TYPE WINAPI __export CIM16GetUseInfo1(
    LPSTR Name,
    LPSTR Local,
    LPSTR Remote,
    LPSTR Password,
    LPULONG pdwStatus,
    LPULONG pdwType,
    LPULONG pdwRefCount,
    LPULONG pdwUseCount)
{
    char            szBuffer[LANMAN_BUFFER_SIZE];
	USHORT          uSize = sizeof(szBuffer),
                    uTotal = 0;
	API_RET_TYPE    ret;

    ret = NetUseGetInfo(NULL, Name, 1, szBuffer, uSize, &uTotal);

    if (ret == NERR_Success)
    {
        struct use_info_1 *pInfo = (struct use_info_1 *) szBuffer;

        lstrcpy(Local, pInfo->ui1_local);
        lstrcpy(Remote, pInfo->ui1_remote);
        lstrcpy(Password, pInfo->ui1_password);
        *pdwStatus = pInfo->ui1_status;
        *pdwType = pInfo->ui1_asg_type;
        *pdwRefCount = pInfo->ui1_refcount;
        *pdwUseCount = pInfo->ui1_usecount;
    }

    return ret;
}

// pbBuffer is used internally as a work buffer.  It should be allocated and
// freed by the caller, and should be the same length as pBuffer2, which 
// is a pointer to an array of use_info_1Out structures.

// The reason we need to do this, is because if we just send back a LPSTR, the
// ui1_remote pointer in the use_info_1 structure won't get adjusted correctly
// by the thunking layer.  So, we make a fixed length structure, and send
// the value back in it.
API_RET_TYPE WINAPI __export CIM16NetUseEnum(
    LPCSTR pszServer,
    short sLevel,
    LPSTR pbBuffer,
    use_info_1Out far *pBuffer2,
    unsigned short cbBuffer,
    unsigned short far *pcEntriesRead,
    unsigned short far *pcTotalAvail
)
{
    API_RET_TYPE art;
    use_info_1 *pBuffer3;
    unsigned int x;
    
    art = NetUseEnum(pszServer, sLevel, pbBuffer, cbBuffer, pcEntriesRead, pcTotalAvail);

    if (art == NERR_Success)
    {
        if (*pcEntriesRead <= (cbBuffer / sizeof(use_info_1Out)))
        {
            pBuffer3 = (use_info_1 *)pbBuffer;
            for (x=0; x < *pcEntriesRead; x++)
            {
                strcpy(pBuffer2[x].ui1_local, pBuffer3[x].ui1_local);
                pBuffer2[x].ui1_pad_1 = pBuffer3[x].ui1_pad_1;
                strcpy(pBuffer2[x].ui1_remote, pBuffer3[x].ui1_remote);
                pBuffer2[x].ui1_status = pBuffer3[x].ui1_status;
                pBuffer2[x].ui1_asg_type = pBuffer3[x].ui1_asg_type;
                pBuffer2[x].ui1_refcount = pBuffer3[x].ui1_refcount;
                pBuffer2[x].ui1_usecount = pBuffer3[x].ui1_usecount;
            }
        }
        else
        {
            // This means that although the pbBuffer was big enough
            // to hold the data, pBuffer2 didn't have enough entries.
            // Remember that pBuffer2 uses fixed lengths.
            art = ERROR_MORE_DATA;
        }
    }

    return art;
}

//////////////////////////////////////////////////////////////////////
ULONG WINAPI __export CIM16GetConfigManagerStatus(LPSTR HardwareKey)
{
	// Used to get the the data
	DEVNODE Devnode;
	ULONG ulStatus = 0L;
	ULONG ulProblem = 0L;
	
	memset(&Devnode,NULL,sizeof(Devnode));	
	if( CR_SUCCESS == CM_Locate_DevNode(&Devnode,HardwareKey,0)){
   		CM_Get_DevNode_Status(&ulStatus,&ulProblem,Devnode,0);
	}		
	
	return ulStatus;	
}

WORD WINAPI __export CIM16_CM_Locate_DevNode( PDEVNODE pdn, LPSTR HardwareKey, ULONG ulFlags )
{
	return CM_Locate_DevNode( pdn, HardwareKey, 0 );
}

WORD WINAPI __export CIM16_CM_Get_Parent( PDEVNODE pdn, DEVNODE dnChild, ULONG ulFlags )
{
	return CM_Get_Parent( pdn, dnChild, 0 );
}

WORD WINAPI __export CIM16_CM_Get_Child( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags )
{
	return CM_Get_Child( pdn, dnParent, 0 );
}

WORD WINAPI __export CIM16_CM_Get_Sibling( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags )
{
	return CM_Get_Sibling( pdn, dnParent, 0 );
}

WORD WINAPI __export CIM16_CM_Read_Registry_Value( DEVNODE dnDevNode, LPSTR pszSubKey, LPSTR pszValueName, ULONG ulExpectedType, LPVOID Buffer, LPULONG pulLength, ULONG ulFlags )
{
	return CM_Read_Registry_Value( dnDevNode, pszSubKey, pszValueName, ulExpectedType, Buffer, pulLength, ulFlags );
}

WORD WINAPI __export CIM16_CM_Get_DevNode_Status( LPULONG pulStatus, LPULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags )
{
	return CM_Get_DevNode_Status( pulStatus, pulProblemNumber, dnDevNode, ulFlags );
}

WORD WINAPI __export CIM16_CM_Get_Device_ID( DEVNODE dnDevNode, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags )
{
	return CM_Get_Device_ID( dnDevNode, Buffer, BufferLen, ulFlags );
}

WORD WINAPI __export CIM16_CM_Get_Device_ID_Size( LPULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags )
{
	return CM_Get_Device_ID_Size( pulLen, dnDevNode, ulFlags );
}

WORD WINAPI __export CIM16_CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags )
{
	return CM_Get_First_Log_Conf( plcLogConf, dnDevNode, ulFlags );
}

WORD WINAPI __export CIM16_CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags )
{
	return CM_Get_Next_Res_Des( prdResDes, rdResDes, ForResource, pResourceID, ulFlags );
}

WORD WINAPI __export CIM16_CM_Get_Res_Des_Data_Size( LPULONG pulSize, RES_DES rdResDes, ULONG ulFlags )
{
	return CM_Get_Res_Des_Data_Size( pulSize, rdResDes, ulFlags );
}

WORD WINAPI __export CIM16_CM_Get_Res_Des_Data( RES_DES rdResDes, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags )
{
	return CM_Get_Res_Des_Data( rdResDes, Buffer, BufferLen, ulFlags );
}

WORD WINAPI __export CIM16_CM_Get_Bus_Info(DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags)
{
	return CM_Get_Bus_Info( dnDevNode, pbtBusType, pulSizeOfInfo, pInfo, ulFlags );
}

WORD WINAPI __export CIM16_CM_Query_Arbitrator_Free_Data(LPVOID pData, ULONG DataLen, DEVNODE dnDevInst, RESOURCEID ResourceID, ULONG ulFlags)
{
    return CM_Query_Arbitrator_Free_Data(pData, DataLen, dnDevInst, ResourceID, ulFlags);
}

WORD WINAPI __export CIM16_CM_Delete_Range(ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags)
{
    return CM_Delete_Range(ulStartValue, ulEndValue, rlh, ulFlags);
}

WORD WINAPI __export CIM16_CM_First_Range(RANGE_LIST rlh, LPULONG pulStart, LPULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags)
{
    return CM_First_Range(rlh, pulStart, pulEnd, preElement, ulFlags);
}

WORD WINAPI __export CIM16_CM_Next_Range(PRANGE_ELEMENT preElement, LPULONG pulStart, LPULONG pullEnd, ULONG ulFlags)
{
    return CM_Next_Range(preElement, pulStart, pullEnd, ulFlags);
}

WORD WINAPI __export CIM16_CM_Free_Range_List(RANGE_LIST rlh, ULONG ulFlags)
{
    return CM_Free_Range_List(rlh, ulFlags);
}

// Use int13 to read drive parameters
BYTE FAR PASCAL __export CIM16GetDriveParams (BYTE   bDrive,
                                              pInt13DriveParams pParams)
{
    typedef struct {
        WORD wInfo_size;
        WORD wFlags;                // information flags
        DWORD dwCylinders;          // number of cylinders on disk
        DWORD dwHeads;              // number of heads on disk
        DWORD dwSec_per_track;      // number of sectors per track
        DWORD dwSectors[2];         // number of sectors on requested disk
        WORD sector_size;           // number of bytes per sector
    } stGetDriveParmsEx, *pstGetDriveParmsEx;

    BYTE   cResult;
    RMCS   callStruct;
    DWORD  gdaBuffer;     // Return value of GlobalDosAlloc().
    LPBYTE RMlpBuffer;    // Real-mode buffer pointer
    LPBYTE PMlpBuffer;    // Protected-mode buffer pointer
    BOOL bFound;

    pstGetDriveParmsEx pExParams;
    memset(pParams, 0, sizeof(Int13DriveParams));

/*
Validate params:
bDrive should be int 13h device unit -- let the BIOS validate
this parameter -- user could have a special controller with
its own BIOS.
*/

    if (pParams == NULL)
        return 0xee;

    bFound = FALSE;

/*
Initialize the real-mode call structure and set all values needed
to read the first sector of the specified physical drive.
*/

    BuildRMCS (&callStruct);

    // First let's see if we can use extended int13 stuff
    callStruct.eax = 0x4100;                // GET DRIVE PARAMETERS
    callStruct.ebx = 0;
    callStruct.edx = MAKEWORD(bDrive, 0);   // Drive #
    pParams->wExtStep = 1;

    if (SimulateRM_Int (0x13, &callStruct) &&   // Did the DPMI call succeed?
        (!(callStruct.wFlags & CARRY_FLAG)) &&  // Did the int13 call succeed?
        (callStruct.ebx == 0xaa55) &&           // Did it set the signature for int13 extensions?
        (callStruct.ecx & 1))                   // Does the extended int13 support the api we need?
    {
        pParams->wExtStep = 2;

        // Yes, we can use extended int13.  Now, let's set up to do so.  First allocate some
        // memory that can be accessed from real mode
        gdaBuffer = GlobalDosAlloc (sizeof(stGetDriveParmsEx));

        if (!gdaBuffer)
            return 0xee;

        // Next, make a real mode and protected mode pointer to this memory
        RMlpBuffer = (LPBYTE)MAKELONG(0, HIWORD(gdaBuffer));
        PMlpBuffer = (LPBYTE)MAKELONG(0, LOWORD(gdaBuffer));

        // Now, we need to set a data member in that memory block to the size of the memory block
        pExParams = (pstGetDriveParmsEx) PMlpBuffer;
        pExParams->wInfo_size = sizeof(stGetDriveParmsEx);

        callStruct.eax = 0x4800;                // Extended GET DRIVE PARAMETERS
        callStruct.edx = MAKEWORD(bDrive, 0);   // Drive #
        callStruct.esi = LOWORD(RMlpBuffer);    // Offset of sector buffer
        callStruct.ds  = HIWORD(RMlpBuffer);    // Segment of sector buffer

        if (SimulateRM_Int (0x13, &callStruct) &&   // Did the DPMI call succeed?
            (!(callStruct.wFlags & CARRY_FLAG))   // Did the int13 call succeed?
            // Actually, experience shows that this seems to indicate whether the NON-extended 
            // call returns the correct information.
//            (pExParams->wFlags & 2)                 // Did the CHS stuff get populated?
            )
        {
            pParams->wExtStep = 3;

            // Cylinder and head are returned from the interrupt zero based, sector is returned one based
            cResult = (BYTE)((callStruct.eax >> 8) & 0xff);

            pParams->dwMaxCylinder = pExParams->dwCylinders;
            pParams->dwMaxSector = pExParams->dwSec_per_track;
            pParams->dwMaxHead = pExParams->dwHeads;
            pParams->wSectorSize = pExParams->sector_size;
            pParams->wFlags = pExParams->wFlags;
            pParams->dwSectors[0] = pExParams->dwSectors[0];
            pParams->dwSectors[0] = pExParams->dwSectors[0];

            bFound = TRUE;
        }

        // Free the sector data buffer this function allocated
        GlobalDosFree (LOWORD(gdaBuffer));
    }

    if (!bFound)
    {
        // No extended int13.  Take what we can get
        callStruct.eax = 0x0800;                // GET DRIVE PARAMETERS
        callStruct.edx = MAKEWORD(bDrive, 0);   // Drive #

/*
Call Int 13h BIOS and check both the DPMI call
itself and the BIOS function result for success.
*/

        if (SimulateRM_Int (0x13, &callStruct)) // Did the DPMI call succeed?
        {
            if (!(callStruct.wFlags & CARRY_FLAG))
            {
                // It might also be necessary to make sure that bDrive <= DL after the call is made.
                // Cylinder and head are returned from the interrupt zero based, sector is returned one based
                cResult = (BYTE)((callStruct.eax >> 8) & 0xff);

                pParams->dwMaxCylinder = (WORD)(((callStruct.ecx & 0xff00) >> 8) | ((callStruct.ecx & 0xc0) << 2)) + 1;
                pParams->dwMaxSector = (WORD)(callStruct.ecx & 0x3f);
                pParams->dwMaxHead = (WORD)((callStruct.edx & 0xff00) >> 8)+1;
                pParams->wSectorSize = SECTOR_SIZE;
            }
            else
            {
                cResult = (BYTE)((callStruct.eax >> 8) & 0xff);
            }
        }
        else
        {
            cResult = 0xef;
        }
    }

    return cResult;
}

// This routine (and the dpmi routines below) shamelessly stolen from Q137176
// It will read the MasterBootSector and return it.
BYTE FAR PASCAL __export CIM16GetDrivePartitions (BYTE   bDrive,
                                              pMasterBootSector pMBS)
{
   BYTE   cResult;
   RMCS   callStruct;
   DWORD  gdaBuffer;     // Return value of GlobalDosAlloc().
   LPBYTE RMlpBuffer;    // Real-mode buffer pointer
   LPBYTE PMlpBuffer;    // Protected-mode buffer pointer

   /*
     Validate params:
        bDrive should be int 13h device unit -- let the BIOS validate
           this parameter -- user could have a special controller with
           its own BIOS.
        pMBS must not be NULL
   */

   if (pMBS == NULL)
      return 0xee;

   /*
     Allocate the buffer that the Int 13h function will put the sector
     data into. As this function uses DPMI to call the real-mode BIOS, it
     must allocate the buffer below 1 MB, and must use a real-mode
     paragraph-segment address.

     After the memory has been allocated, create real-mode and
     protected-mode pointers to the buffer. The real-mode pointer
     will be used by the BIOS, and the protected-mode pointer will be
     used by this function because it resides in a Windows 16-bit DLL,
     which runs in protected mode.
   */

   gdaBuffer = GlobalDosAlloc (sizeof(MasterBootSector));

   if (!gdaBuffer)
      return 0xee;

   RMlpBuffer = (LPBYTE)MAKELONG(0, HIWORD(gdaBuffer));
   PMlpBuffer = (LPBYTE)MAKELONG(0, LOWORD(gdaBuffer));

   /*
     Initialize the real-mode call structure and set all values needed
     to read the first sector of the specified physical drive.
   */

   BuildRMCS (&callStruct);

   callStruct.eax = 0x0201;                // BIOS read, 1 sector
   callStruct.ecx = 0x0001;                // Sector 1, Cylinder 0
   callStruct.edx = MAKEWORD(bDrive, 0);   // Head 0, Drive #
   callStruct.ebx = LOWORD(RMlpBuffer);    // Offset of sector buffer
   callStruct.es  = HIWORD(RMlpBuffer);    // Segment of sector buffer

   /*
      Call Int 13h BIOS Read Track and check both the DPMI call
      itself and the BIOS Read Track function result for success.  If
      successful, copy the sector data retrieved by the BIOS into the
      caller's buffer.
   */

   if (SimulateRM_Int (0x13, &callStruct))
   {
      if (!(callStruct.wFlags & CARRY_FLAG))
      {
         _fmemcpy (pMBS, PMlpBuffer, (size_t)sizeof(MasterBootSector));
         cResult = (BYTE)((callStruct.eax >> 8) & 0xff);
      }
      else
      {
         cResult = (BYTE)((callStruct.eax >> 8) & 0xff);
      }
   }
   else
   {
       cResult = 0xef;
   }

   // Free the sector data buffer this function allocated
   GlobalDosFree (LOWORD(gdaBuffer));

   return cResult;
}


/*--------------------------------------------------------------------
  SimulateRM_Int()

  Allows protected mode software to execute real mode interrupts such
  as calls to DOS TSRs, DOS device drivers, etc.

  This function implements the "Simulate Real Mode Interrupt" function
  of the DPMI specification v0.9.

  Parameters
     bIntNum
        Number of the interrupt to simulate

     lpCallStruct
        Call structure that contains params (register values) for
        bIntNum.

  Return Value
     SimulateRM_Int returns TRUE if it succeeded or FALSE if it
     failed.

  Comments
     lpCallStruct is a protected-mode selector:offset address, not a
     real-mode segment:offset address.
--------------------------------------------------------------------*/
BOOL FAR PASCAL SimulateRM_Int (BYTE bIntNum, LPRMCS lpCallStruct)

   {
   BOOL fRetVal = FALSE;      // Assume failure

   _asm {
         push di

         mov  ax, 0300h         ; DPMI Simulate Real Mode Int
         mov  bl, bIntNum       ; Number of the interrupt to simulate
         mov  bh, 01h           ; Bit 0 = 1; all other bits must be 0
         xor  cx, cx            ; No words to copy
         les  di, lpCallStruct
         int  31h                   ; Call DPMI
         jc   END1                  ; CF set if error occurred
         mov  fRetVal, TRUE
      END1:
         pop di
        }
   return (fRetVal);
   }

/*--------------------------------------------------------------------
  BuildRMCS()

  Initializes a real mode call structure to contain zeros in all its
  members.

  Parameters:
     lpCallStruct
        Points to a real mode call structure

  Comments:
     lpCallStruct is a protected-mode selector:offset address, not a
     real-mode segment:offset address.
--------------------------------------------------------------------*/

void FAR PASCAL BuildRMCS (LPRMCS lpCallStruct)
   {
   _fmemset (lpCallStruct, 0, sizeof (RMCS));
   }


WORD WINAPI __export CIM16GetBiosUnit(LPSTR lpDeviceID)
{
    WORD btAddress[2];
    WORD wRetVal,
            wSeg = HIWORD(lpDeviceID),
            wOffset = LOWORD(lpDeviceID);

    _asm {
        PUSH    BX
        PUSH    DI
        PUSH    ES

        // Get the pointer to IOS
        MOV     AX,0x1684   // Get VXD Entry Point
        MOV     BX,0x0010   // for IOS service
        MOV     DI,0x0000   // Empty register
        MOV     ES,DI       // Empty register
        INT     0x2F

        // Check to make sure it worked.  Result returned in es:di
        MOV     AX,ES
        OR      AX,0x0000
        JE      failed

        // Move it to a memory location to allow for the indirect call
        MOV     [btAddress],DI
        MOV     [btAddress + 2],ES

        // Set up to call ios.  Parameters are as follows:

        /* (from Bill Parry)
        It is added as a VxD PM usermode API.   David, you need to find out how to call VxD PM API's from your app,
        as I've never done this and don't remember the details of how it works.   I do recall that you can either
        reference the VxD by name or device ID.

        To call the function, you need to use vxd name "IOS" (or use IOS_DEVICE_ID from IOS.H), and pass in:
        AX = 7
        ES:BX -> PNP ID string to compare, null terminated.

        If the API succeeds, it returns clear carry and DL = INT 13 unit # if the device is an int 13 device, or DL = -1 if not.
        If the API fails, carry is set upon return and DL is undefined.
        */

        MOV     AX,0x0007
        LEA     DI,btAddress
        MOV     BX,wSeg
        MOV     ES,BX
        MOV     BX,wOffset
        MOV     DL,0xff
        CALL    DWORD PTR ss:[di]

        // Value comes back in dl
        MOV     AH,0
        MOV     AL,DL
        JNC     done

        // We either jump here on failure, or fall through from lack of success
        failed:
        MOV     AX,0xffff

        done:
        MOV     wRetVal, AX

        POP     ES
        POP     DI
        POP     BX
    }

    return wRetVal;

}

DWORD WINAPI __export CIM16GetFreeSpace ( UINT option )
{
	return GetFreeSpace ( option ) ;
}

///////////////////////////////////////////////////////////////////////
//
//  This is required to setup the thunking to the 32 bit dll
//
///////////////////////////////////////////////////////////////////////

BOOL FAR PASCAL __export DllEntryPoint (DWORD dwReason,
                               WORD  hInst,
                               WORD  wDS,
                               WORD  wHeapSize,
                               DWORD dwReserved1,
                               WORD  wReserved2)
{
    if (!win32thk_ThunkConnect16(CIM16NET_DLL, CIM32NET_DLL, hInst, dwReason))
        return FALSE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\configmg.h ===
/****************************************************************************

*                                                                           *

* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *

* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *

* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *

* PURPOSE.                                                                  *

*                                                                           *

* Copyright (c) 1993-2001 Microsoft Corporation, All Rights Reserved
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

//#ifdef	GOLDEN	
#ifndef	DEBUG
#define	CM_GOLDEN_RETAIL
#endif
//#endif

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"All/None", \
	"Mem     ", \
	"IO      ", \
	"DMA     ", \
	"IRQ     ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0x0003		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share		1			// IRQ can be shared
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_HARDWIRED		0x0000E000
#define	LCPRI_IMPOSSIBLE	0x0000F000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Find_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Global_State, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Reinsert_All, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"Get_Version", \
	"Initialize", \
	"Locate_DevNode", \
	"Get_Parent", \
	"Get_Child", \
	"Get_Sibling", \
	"Get_Device_ID_Size", \
	"Get_Device_ID", \
	"Get_Depth", \
	"Get_Private_DWord", \
	"Set_Private_DWord", \
	"Create_DevNode", \
	"Query_Remove_SubTree", \
	"Remove_SubTree", \
	"Register_Device_Driver", \
	"Register_Enumerator", \
	"Register_Arbitrator", \
	"Deregister_Arbitrator", \
	"Query_Arbitrator_Free_Size", \
	"Query_Arbitrator_Free_Data", \
	"Sort_NodeList", \
	"Yield", \
	"Lock", \
	"Unlock", \
	"Add_Empty_Log_Conf", \
	"Free_Log_Conf", \
	"Get_First_Log_Conf", \
	"Get_Next_Log_Conf", \
	"Add_Res_Des", \
	"Modify_Res_Des", \
	"Free_Res_Des", \
	"Get_Next_Res_Des", \
	"Get_Performance_Info", \
	"Get_Res_Des_Data_Size", \
	"Get_Res_Des_Data", \
	"Process_Events_Now", \
	"Create_Range_List", \
	"Add_Range", \
	"Delete_Range", \
	"Test_Range_Available", \
	"Dup_Range_List", \
	"Free_Range_List", \
	"Invert_Range_List", \
	"Intersect_Range_List", \
	"First_Range", \
	"Next_Range", \
	"Dump_Range_List", \
	"Load_DLVxDs", \
	"Get_DDBs", \
	"Get_CRC_CheckSum", \
	"Register_DevLoader", \
	"Reenumerate_DevNode", \
	"Setup_DevNode", \
	"Reset_Children_Marks", \
	"Get_DevNode_Status", \
	"Remove_Unmarked_Children", \
	"ISAPNP_To_CM", \
	"CallBack_Device_Driver", \
	"CallBack_Enumerator", \
	"Get_Alloc_Log_Conf", \
	"Get_DevNode_Key_Size", \
	"Get_DevNode_Key", \
	"Read_Registry_Value", \
	"Write_Registry_Value", \
	"Disable_DevNode", \
	"Enable_DevNode", \
	"Move_DevNode", \
	"Set_Bus_Info", \
	"Get_Bus_Info", \
	"Set_HW_Prof", \
	"Recompute_HW_Prof", \
	"Query_Change_HW_Prof", \
	"Get_Device_Driver_Private_DWord", \
	"Set_Device_Driver_Private_DWord", \
	"Get_HW_Prof_Flags", \
	"Set_HW_Prof_Flags", \
	"Read_Registry_Log_Confs", \
	"Run_Detection", \
	"Call_At_Appy_Time", \
	"Fail_Change_HW_Prof", \
	"Set_Private_Problem", \
	"Debug_DevNode", \
	"Get_Hardware_Profile_Info", \
	"Register_Enumerator_Function", \
	"Call_Enumerator_Function", \
	"Add_ID", \
	"Find_Range", \
	"Get_Global_State", \
	"Broadcast_Device_Change_Message", \
	"Call_DevNode_Handler", \
	"Remove_Reinsert_All", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			NODELIST;	// Pointer to a nodelist element.
typedef	DWORD			NODELIST_HEADER;// Pointer to a nodelist header.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, NODELIST_HEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040

/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS		0x00000000
#define	CR_DEFAULT		0x00000001
#define	CR_OUT_OF_MEMORY	0x00000002
#define	CR_INVALID_POINTER	0x00000003
#define	CR_INVALID_FLAG		0x00000004
#define	CR_INVALID_DEVNODE	0x00000005
#define	CR_INVALID_RES_DES	0x00000006
#define	CR_INVALID_LOG_CONF	0x00000007
#define	CR_INVALID_ARBITRATOR	0x00000008
#define	CR_INVALID_NODELIST	0x00000009
#define	CR_DEVNODE_HAS_REQS	0x0000000A
#define	CR_INVALID_RESOURCEID	0x0000000B
#define	CR_DLVXD_NOT_FOUND	0x0000000C
#define	CR_NO_SUCH_DEVNODE	0x0000000D
#define	CR_NO_MORE_LOG_CONF	0x0000000E
#define	CR_NO_MORE_RES_DES	0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE	0x00000010
#define	CR_INVALID_RANGE_LIST	0x00000011
#define	CR_INVALID_RANGE	0x00000012
#define	CR_FAILURE		0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV	0x00000014
#define	CR_CREATE_BLOCKED	0x00000015
#define	CR_NOT_SYSTEM_VM	0x00000016
#define	CR_REMOVE_VETOED	0x00000017
#define	CR_APM_VETOED		0x00000018
#define	CR_INVALID_LOAD_TYPE	0x00000019
#define	CR_BUFFER_SMALL		0x0000001A
#define	CR_NO_ARBITRATOR	0x0000001B
#define	CR_NO_REGISTRY_HANDLE	0x0000001C
#define	CR_REGISTRY_ERROR	0x0000001D
#define	CR_INVALID_DEVICE_ID	0x0000001E
#define	CR_INVALID_DATA		0x0000001F
#define	CR_INVALID_API		0x00000020
#define	CR_DEVLOADER_NOT_READY	0x00000021
#define	CR_NEED_RESTART		0x00000022
#define	CR_NO_MORE_HW_PROFILES	0x00000023
#define	CR_DEVICE_NOT_THERE	0x00000024
#define	CR_NO_SUCH_VALUE	0x00000025
#define	CR_WRONG_TYPE		0x00000026
#define	CR_INVALID_PRIORITY	0x00000027
#define	CR_NOT_DISABLEABLE	0x00000028
#define	CR_FREE_RESOURCES	0x00000029
#define	CR_QUERY_VETOED		0x0000002A
#define	CR_CANT_SHARE_IRQ	0x0000002B
#define	NUM_CR_RESULTS		0x0000002C

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_SYSTEM_VM", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_NO_MORE_HW_PROFILES", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_FREE_RESOURCES", \
	"CR_QUERY_VETOED", \
	"CR_CANT_SHARE_IRQ", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_LIAR				0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	CM_PROB_FAILED_INSTALL			0x0000001C
#define	CM_PROB_HARDWARE_DISABLED		0x0000001D
#define	CM_PROB_CANT_SHARE_IRQ			0x0000001E
#define	NUM_CM_PROB				0x0000001F

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"Device failed something not failable", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
	"Failed install", \
	"Hardware Disabled", \
	"Can't share IRQ", \
};

/*XLATON*/

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_VXDLDR			0x00000001
#define	CM_INITIALIZE_BITS			0x00000001

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_BITS			0x00000001

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x00000003

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000001

#define	CM_QUERY_REMOVE_UI_OK			0x00000000
#define	CM_QUERY_REMOVE_UI_NOT_OK		0x00000001
#define	CM_QUERY_REMOVE_BITS			0x00000001

#define	CM_REMOVE_UI_OK				0x00000000
#define	CM_REMOVE_UI_NOT_OK			0x00000001
#define	CM_REMOVE_BITS				0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_WRITE_LOG_CONFS		0x00000002
#define	CM_SETUP_PROP_CHANGE			0x00000003
#define	CM_SETUP_BITS				0x00000003

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_HARDWARE			0x00000002	// Don't ask the driver, and won't be restarteable
#define	CM_DISABLE_BITS				0x00000003	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

#define	CM_BROADCAST_SEND			0x00000000
#define	CM_BROADCAST_QUERY			0x00000001
#define	CM_BROADCAST_BITS			0x00000001

#define	CM_CALL_HANDLER_ENUMERATOR		0x00000000
#define	CM_CALL_HANDLER_DEVICE_DRIVER		0x00000001
#define	CM_CALL_HANDLER_BITS			0x00000001

#define	CM_GLOBAL_STATE_CAN_DO_UI		0x00000001
#define	CM_GLOBAL_STATE_ON_BIG_STACK		0x00000002
#define	CM_GLOBAL_STATE_SERVICES_AVAILABLE	0x00000004
#define	CM_GLOBAL_STATE_SHUTING_DOWN		0x00000008
#define	CM_GLOBAL_STATE_DETECTION_PENDING	0x00000010

#define	CM_REMOVE_REINSERT_ALL_REMOVE		0x00000000
#define	CM_REMOVE_REINSERT_ALL_REINSERT		0x00000001
#define	CM_REMOVE_REINSERT_ALL_BITS		0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 * 
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process. 
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.
#define	CONFIG_PROP_CHANGE	0x00000010	// The property page is exiting.
#define	CONFIG_PRIVATE		0x00000011	// Someone called Call_Handler.
#define	CONFIG_PRESHUTDOWN	0x00000012	// We are shutting down

#define	NUM_CONFIG_COMMANDS	0x00000013	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
	"CONFIG_PROP_CHANGE", \
	"CONFIG_PRIVATE", \
	"CONFIG_PRESHUTDOWN", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

//
// For both CONFIG_REMOVE, CONFIG_PREREMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define	CONFIG_APM_TEST_STANDBY				0x00000000
#define	CONFIG_APM_TEST_SUSPEND				0x00000001
#define	CONFIG_APM_TEST_STANDBY_FAILED			0x00000002
#define	CONFIG_APM_TEST_SUSPEND_FAILED			0x00000003
#define	CONFIG_APM_TEST_STANDBY_SUCCEEDED		0x00000004
#define	CONFIG_APM_TEST_SUSPEND_SUCCEEDED		0x00000005
#define	CONFIG_APM_RESUME_STANDBY			0x00000006
#define	CONFIG_APM_RESUME_SUSPEND			0x00000007
#define	CONFIG_APM_RESUME_CRITICAL			0x00000008
#define	CONFIG_APM_UI_ALLOWED                  		0x80000000

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makles no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC
#define	NUM_ARB_COMMANDS	0x00000007	// Number of arb commands

#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
};

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	cann be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000013	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
};

struct vmmtime_s {
DWORD		vmmtime_lo;
DWORD		vmmtime_hi;
};

typedef	struct vmmtime_s	VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctRegistry;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctReceiveMessage;
CMTIME		ctAppyTime;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	ARB_GLOBAL		0x00000001	// Arbitrator is global.
#define	ARB_LOCAL		0x00000000	// Arbitrator is local.
#define	ARB_SCOPE_BIT		0x00000001	// Arbitrator is global/local bit.

#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	NUM_LOG_CONF		0x00000005	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

#ifndef	Not_VxD

/****************************************************************************
 *
 * Arbitration list structures
 *
 ***************************************************************************/
struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	struct devnode_s	*nl_ItsDevNode;		// The dev node it represent

	// You can add fields to this structure, but the first three
	// fields must NEVER be changed.

	struct Log_Conf 	*nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct	nodelist_s	*nlh_Head;		// First node element
	struct	nodelist_s	*nlh_Tail;		// Last node element
};

struct	arbitfree_s {
	PVOID			*af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};

#endif

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name (OEM format)
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUGBUG(d, id, msg)	message("BUGBUG: "##d##", "##id##": "##msg)

#ifndef	DEBUG

#define	CM_WARN1(strings)
#define	CM_WARN2(strings)
#define	CM_ERROR(strings)

#else

#ifndef	MAXDEBUG

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings)
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#else

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG
#define	CURSEG()		LCODE

#else

#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#pragma warning (disable:4005)			// turn off redefinition

#define	CURSEG()		CCODE

#pragma warning (default:4005)			// turn on redefinition

#endif

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL \
_asm	popfd\

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

/****************************************************************************
 *
 *	CONFIGMG_Get_Entry_Point - Return the address to call to get in
 *				   Config Manager.
 *
 *	Exported.
 *
 *	ENTRY:	None.
 *
 *	EXIT:	None.
 *
 *	On return, the variable CMEntryPoint has been updated with the
 *	proper address to call to get to Configuration Manager.
 *
 ***************************************************************************/
DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (NODELIST_HEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (DEVNODE dnDevnode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))
MAKE_CM_HEADER(Find_Range, (PFARULONG pulStart, ULONG ulStart, ULONG ulLength, ULONG ulAlignment, ULONG ulEnd, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Global_State, (PFARULONG pulState, ULONG ulFlags))
MAKE_CM_HEADER(Broadcast_Device_Change_Message, (ULONG ulwParam, PFARVOID plParam, ULONG ulFlags))
MAKE_CM_HEADER(Call_DevNode_Handler, (DEVNODE dnDevNode, ULONG ulPrivate, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Reinsert_All, (ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\makefile.inc ===
{..\}.thk{$O\}.asm:
    thunk -o $@ $<

$(O)\win32thk.asm: ..\win32thk.thk

$(O)\win32thk.obj: $(O)\win32thk.asm
     ml611d.exe -c -W2 -Zi -DIS_16=1 /Fo$(O)\win32thk.obj $(O)\win32thk.asm

$(O)\cim16net.obj: cim16net.c
   $(PATH_TOOLS16)\cl16 -c @<<
   -I$(SDK_INC16_PATH) 
   -I$(CRT_INC_PATH) 
   -I$(SDK_INC_PATH) 
   -I$(WIN32THUNK)
   /DWIN9XONLY 
   /BATCH
   /AL 
   /Zi 
   /GD
   /W3
   /Od
   /Fo$(O)\cim16net.obj
   /Fd$(O)\cim16net.pdb
   cim16net.c
<<nokeep

$(O)\cim16net.dll: $(O)\cim16net.obj $(O)\win32thk.obj
    $(PATH_TOOLS16)\link16 @<<
    $(O)\cim16net.obj $(O)\win32thk.obj,
    $(O)\cim16net.dll,
    $(O)\cim16net.map,
    $(SDK_LIB16_PATH)\libw.lib $(SDK_LIB16_PATH)\ldllcew.lib lan.lib,
    cim16net.def /NODEFAULTLIBRARYSEARCH /NOE /BATCH;
<<nokeep
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\lan.h ===
/********************************************************************/

/**                     Microsoft LAN Manager                      **/

/** Copyright (c) 1990-2001 Microsoft Corporation, All Rights Reserved**/
/********************************************************************/

/********************************************************************
 *                                                                  *
 * LAN.H                                                            *
 *                                                                  *
 * This is the top level include file that includes all the         *
 * files necessary for writing a LAN Manager application.           *
 *                                                                  *
 ********************************************************************/

#ifndef LAN_INCLUDED


   #define LAN_INCLUDED

/* Include LAN Manager errors if including OS/2 errors: */
#ifdef INCL_ERRORS
    #define INCL_NETERRORS
#endif

/* INCL_NET includes all LAN Manager headers: */
#ifdef INCL_NET
    #define INCL_NETACCESS
    #define INCL_NETALERT
    #define INCL_NETAUDIT
    #define INCL_NETBIOS
    #define INCL_NETCHARDEV
    #define INCL_NETCONFIG
    #define INCL_NETCONNECTION
    #define INCL_NETDOMAIN
    #define INCL_NETERRORLOG
    #define INCL_NETERRORS
    #define INCL_NETFILE
    #define INCL_NETGROUP
    #define INCL_NETHANDLE
    #define INCL_NETMAILSLOT
    #define INCL_NETMESSAGE
    #define INCL_NETNMPIPE
    #define INCL_NETPROFILE
    #define INCL_NETREMUTIL
    #define INCL_NETSERVER
    #define INCL_NETSERVICE
    #define INCL_NETSESSION
    #define INCL_NETSHARE
    #define INCL_NETSTATS
    #define INCL_NETUSE
    #define INCL_NETUSER
    #define INCL_NETWKSTA
#endif

/* Include Access definitions with the Share class: */
#ifdef INCL_NETSHARE
    #define INCL_NETACCESS
#endif

/* Include User definitions with the Domain class: */
#ifdef INCL_NETDOMAIN
    #define INCL_NETUSER
#endif

/* Include User definitions with the Workstation class: */
#ifdef INCL_NETWKSTA
    #define INCL_NETUSER
#endif


#include <netcons.h>    /* LAN Manager common definitions */


/* Unconditional includes: */

#include <access.h>     /* Access, Domain, Group and User classes */

#include <chardev.h>    /* Character Device and Handle classes */

#include <shares.h>     /* Connection, File, Session and Share classes */


#endif          /* LAN_INCLUDED */


/* Conditional includes: */

#ifdef INCL_NETERRORS
#include <neterr.h>     /* LAN Manager network error definitions */
#endif

#ifdef INCL_NETALERT
#include <alert.h>      /* Alert class */
#endif

#ifdef INCL_NETAUDIT
#include <audit.h>      /* Audit class */
#endif

#ifdef INCL_NETBIOS
#include <ncb.h>        /* NETBIOS class */
#include <netbios.h>
#endif

#ifdef INCL_NETCONFIG
#include <config.h>     /* Configuration class */
#endif

#ifdef INCL_NETERRORLOG
#include <errlog.h>     /* Error Logging class */
#endif

#ifdef INCL_NETMAILSLOT
#include <mailslot.h>   /* Mailslot class */
#endif

#ifdef INCL_NETMESSAGE
#include <message.h>    /* Message class */
#endif

#ifdef INCL_NETNMPIPE
#include <nmpipe.h>     /* Named pipe class */
#endif

#ifdef INCL_NETPROFILE
#include <profile.h>    /* Profile class */
#endif

#ifdef INCL_NETREMUTIL
#include <remutil.h>    /* Remote Utility class */
#endif

#ifdef INCL_NETSERVER
#include <servers.h>     /* Server class */
#endif

#ifdef INCL_NETSERVICE
#include <service.h>    /* Service class */
#endif

#ifdef INCL_NETSTATS
#include <netstats.h>   /* Statistics class */
#endif

#ifdef INCL_NETUSE
#include <use.h>        /* Use class */
#endif

#ifdef INCL_NETWKSTA
#include <wksta.h>      /* Workstation class */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\access.h ===
/********************************************************************/

/**                     Microsoft LAN Manager                      **/

/** Copyright (c) 1987-2001 Microsoft Corporation, All Rights Reserved **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  ACCESS.H				    *
 *								    *
 *  This file contains information about the NetUser, NetGroup,     *
 *  NetAccess, and NetAccounts APIs.  There is a section for each   *
 *  set of APIs.  Each section contains:			    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 *	   This file is always included by LAN.H		    *
 *								    *
 ********************************************************************/




/****************************************************************
 *								*
 *	  	User Class			                *
 *								*
 ****************************************************************/

#if (defined( INCL_NETUSER ) || !defined( LAN_INCLUDED )) \
    && !defined( NETUSER_INCLUDED )

#define NETUSER_INCLUDED


/****************************************************************
 *								*
 *	  	Function prototypes - USER			*
 *								*
 ****************************************************************/

extern API_FUNCTION
  NetUserAdd ( const char far * pszServer,
               short            sLevel,
               char far *       pbBuffer,
               unsigned short   cbBuffer );

extern API_FUNCTION
  NetUserDel ( const char far * pszServer,
               char far *       pszUserName );

extern API_FUNCTION
  NetUserEnum ( const char far *     pszServer,
                short                sLevel,
                char far *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short far * pcEntriesRead,
                unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetUserGetInfo ( const char far *     pszServer,
                   char far *           pszUserName,
                   short                sLevel,
                   char far *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetUserSetInfo ( const char far * pszServer,
                   char far *       pszUserName,
                   short            sLevel,
                   char far *       pbBuffer,
                   unsigned short   cbBuffer,
                   short            sParmNum );

extern API_FUNCTION
  NetUserPasswordSet ( const char far * pszServer,
                       char far *       pszUserName,
                       char far *       pszOldPassword,
                       char far *       pszNewPassword );

extern API_FUNCTION
  NetUserGetGroups ( const char far *     pszServer,
                     const char far *     pszUserName,
                     short                sLevel,
                     char far *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short far * pcEntriesRead,
                     unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetUserSetGroups ( const char far * pszServer,
                     const char far * pszUserName,
                     short            sLevel,
                     char far *       pbBuffer,
                     unsigned short   cbBuffer,
                     unsigned short   cEntries );

extern API_FUNCTION
  NetUserModalsGet ( const char far *     pszServer,
                     short                sLevel,
                     char far *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetUserModalsSet ( const char far * pszServer,
                     short            sLevel,
                     char far *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetUserValidate ( char far *           pszReserved,
                    char far *           pszUserName,
                    char far *           pszPassword,
                    unsigned short far * pusPrivilege );

extern API_FUNCTION
  NetUserValidate2 ( char far *           pszReserved1,
                     short                sLevel,
                     char far *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short       usReserved2,
                     unsigned short far * pcbTotalAvail );



/****************************************************************
 *								*
 *              Data structure templates - USER			*
 *								*
 ****************************************************************/

struct user_info_0 {
	char usri0_name[UNLEN+1];
};	/* user_info_0 */

struct user_info_1 {
	char 		usri1_name[UNLEN+1];
    	char 		usri1_pad_1;
    	char 		usri1_password[ENCRYPTED_PWLEN];/* See note below */
    	long 		usri1_password_age;
    	unsigned short 	usri1_priv;			/* See values below */
    	char far *	usri1_home_dir;
    	char far *	usri1_comment;
    	unsigned short 	usri1_flags;			/* See values below */
    	char far *	usri1_script_path;
};	/* user_info_1 */

/*
 *	NOTE:  The maximum length of a user password is PWLEN.  The
 *	field usri1_password contains extra room for transporting
 *	the encrypted form of the password over the network.  When
 *	setting the user's password, check length vs. PWLEN, not
 *	the size of this field.  PWLEN is defined in NETCONS.H.
 */



struct user_info_2 {
    	char           	usri2_name[UNLEN+1];
    	char           	usri2_pad_1;
    	char           	usri2_password[ENCRYPTED_PWLEN];
    	long           	usri2_password_age;
    	unsigned short 	usri2_priv;
    	char far *     	usri2_home_dir;
    	char far *     	usri2_comment;
    	unsigned short 	usri2_flags;
    	char far *     	usri2_script_path;
    	unsigned long 	usri2_auth_flags;
    	char far *     	usri2_full_name;
    	char far *     	usri2_usr_comment;
    	char far *     	usri2_parms;
    	char far *     	usri2_workstations;
    	long	   	usri2_last_logon;
    	long	   	usri2_last_logoff;
    	long  	   	usri2_acct_expires;
    	unsigned long  	usri2_max_storage;
    	unsigned short 	usri2_units_per_week;
    	unsigned char far *   	usri2_logon_hours;
    	unsigned short 	usri2_bad_pw_count;
    	unsigned short 	usri2_num_logons;
	char far *	usri2_logon_server;
    	unsigned short 	usri2_country_code;
    	unsigned short 	usri2_code_page;
};	/* user_info_2 */


struct user_info_10 {
    	char           	usri10_name[UNLEN+1];
    	char           	usri10_pad_1;
    	char far *     	usri10_comment;
    	char far *     	usri10_usr_comment;
    	char far *     	usri10_full_name;
};	/* user_info_10 */

struct user_info_11 {
    	char           	usri11_name[UNLEN+1];
    	char           	usri11_pad_1;
    	char far *     	usri11_comment;
    	char far *     	usri11_usr_comment;
    	char far *     	usri11_full_name;
	unsigned short	usri11_priv;
    	unsigned long 	usri11_auth_flags;
    	long           	usri11_password_age;
    	char far *     	usri11_home_dir;
    	char far *     	usri11_parms;
    	long  	   	usri11_last_logon;
    	long  	   	usri11_last_logoff;
    	unsigned short 	usri11_bad_pw_count;
    	unsigned short 	usri11_num_logons;
	char far *	usri11_logon_server;
    	unsigned short 	usri11_country_code;
	char far *	usri11_workstations;
    	unsigned long 	usri11_max_storage;
    	unsigned short 	usri11_units_per_week;
	char far *	usri11_logon_hours;
	unsigned short	usri11_code_page;
};	/* user_info_11 */

/*
 *	For User Modals
*/

struct	user_modals_info_0 {
	unsigned short	usrmod0_min_passwd_len;
	unsigned long	usrmod0_max_passwd_age;
	unsigned long	usrmod0_min_passwd_age;
	unsigned long	usrmod0_force_logoff;
	unsigned short	usrmod0_password_hist_len;
	unsigned short	usrmod0_reserved1;
};	/* user_modals_info_0 */


struct	user_modals_info_1 {
	unsigned short	usrmod1_role;
	char far *	usrmod1_primary;
};	/* user_modals_info_1 */



/*
 *	For User Logon Validation
*/

struct user_logon_req_1 {
	char		usrreq1_name[UNLEN+1];
	char		usrreq1_pad_1;
	char		usrreq1_password[SESSION_PWLEN];
	char far *	usrreq1_workstation;
};	/* user_logon_req_1 */
	

struct user_logon_info_0 {
    	char      	usrlog0_eff_name[UNLEN+1];
    	char      	usrlog0_pad_1;
};	/* user_logon_info_0 */

struct user_logon_info_1 {
    	unsigned short 	usrlog1_code;
    	char           	usrlog1_eff_name[UNLEN+1];
    	char      	usrlog1_pad_1;
    	unsigned short 	usrlog1_priv;
    	unsigned long  	usrlog1_auth_flags;
    	unsigned short 	usrlog1_num_logons;
    	unsigned short 	usrlog1_bad_pw_count;
    	unsigned long 	usrlog1_last_logon;
    	unsigned long 	usrlog1_last_logoff;
    	unsigned long  	usrlog1_logoff_time;
    	unsigned long  	usrlog1_kickoff_time;
    	long           	usrlog1_password_age;
    	unsigned long  	usrlog1_pw_can_change;
    	unsigned long  	usrlog1_pw_must_change;
    	char far *     	usrlog1_computer;
    	char far *     	usrlog1_domain;
    	char far *     	usrlog1_script_path;
    	unsigned long  	usrlog1_reserved1;
};	/* user_logon_info_1 */


struct user_logon_info_2 {
    	char           	usrlog2_eff_name[UNLEN+1];
    	char      	usrlog2_pad_1;
    	char far *     	usrlog2_computer;
    	char far *     	usrlog2_full_name;
    	char far *     	usrlog2_usrcomment;
    	unsigned long 	usrlog2_logon_time;
};	/* user_logon_info_2 */



struct user_logoff_req_1 {
	char		usrlfreq1_name[UNLEN+1];
	char		usrlfreq1_pad_1;
	char		usrlfreq1_workstation[CNLEN+1];
};	/* user_logoff_req_1 */
	
struct user_logoff_info_1 {
	unsigned short	usrlogf1_code;
	unsigned long	usrlogf1_duration;
	unsigned short	usrlogf1_num_logons;
};	/* user_logoff_info_1 */

/****************************************************************
 *								*
 *	  	Special values and constants - USER		*
 *								*
 ****************************************************************/


/*
 *	Bit masks for field usriX_flags of user_info_X (X = 0/1).
 */

#define		UF_SCRIPT		0x1
#define 	UF_ACCOUNTDISABLE	0x2
#define 	UF_DELETE_PROHIBITED	0x4
#define 	UF_HOMEDIR_REQUIRED	0x8
#define         UF_LOCKOUT              0x10
#define 	UF_PASSWD_NOTREQD	0x20
#define 	UF_PASSWD_CANT_CHANGE	0x40

/*
 *	Bit masks for field usri2_auth_flags of user_info_2.
*/

#define		AF_OP_PRINT		0x1
#define		AF_OP_COMM		0x2
#define		AF_OP_SERVER		0x4
#define		AF_OP_ACCOUNTS		0x8


/*
 *	UAS role manifests under NETLOGON
 */
#define		UAS_ROLE_STANDALONE	0
#define		UAS_ROLE_MEMBER		1
#define		UAS_ROLE_BACKUP		2
#define		UAS_ROLE_PRIMARY	3

/*
 *	Values for parmnum for NetUserSetInfo.
 */

/* LM1.0 style */
#define 	U1_ALL			0
#define 	U1_NAME			1
#define 	U1_PAD			2
#define 	U1_PASSWD		3
#define 	U1_PASSWDAGE		4
#define 	U1_PRIV			5
#define 	U1_DIR			6
#define 	U1_COMMENT		7
#define 	U1_USER_FLAGS		8
#define 	U1_SCRIPT_PATH		9


/* LM2.0 style */
#ifndef  PARMNUM_ALL
#define		PARMNUM_ALL		0
#endif

#define		PARMNUM_NAME		1
#define 	PARMNUM_PAD		2
#define 	PARMNUM_PASSWD		3
#define 	PARMNUM_PASSWDAGE	4
#define 	PARMNUM_PRIV		5
#define 	PARMNUM_DIR		6
#define 	PARMNUM_COMMENT		7
#define 	PARMNUM_USER_FLAGS	8
#define 	PARMNUM_SCRIPT_PATH	9
#define		PARMNUM_AUTH_FLAGS	10
#define		PARMNUM_FULL_NAME	11
#define		PARMNUM_USR_COMMENT	12
#define		PARMNUM_PARMS		13
#define		PARMNUM_WORKSTATIONS	14
#define		PARMNUM_LAST_LOGON	15
#define		PARMNUM_LAST_LOGOFF	16
#define		PARMNUM_ACCT_EXPIRES	17
#define		PARMNUM_MAX_STORAGE	18
#define		PARMNUM_UNITS_PER_WEEK	19
#define		PARMNUM_LOGON_HOURS	20
#define		PARMNUM_BADPW_COUNT	21
#define		PARMNUM_NUM_LOGONS	22
#define		PARMNUM_LOGON_SERVER	23
#define		PARMNUM_COUNTRY_CODE	24
#define		PARMNUM_CODE_PAGE	25

/*
 *	For SetInfo call (parmnum 0) when password change not required
 */
#define 	NULL_USERSETINFO_PASSWD 	"              "



#define		TIMEQ_FOREVER			((unsigned long) -1L)
#define		USER_MAXSTORAGE_UNLIMITED	((unsigned long) -1L)
#define		USER_NO_LOGOFF			((unsigned long) -1L)
#define		UNITS_PER_DAY			24
#define		UNITS_PER_WEEK			UNITS_PER_DAY * 7


/*
 *	Privilege levels (user_info_X field usriX_priv (X = 0/1)).
 */
#define		USER_PRIV_MASK		0x3
#define 	USER_PRIV_GUEST		0
#define 	USER_PRIV_USER		1
#define 	USER_PRIV_ADMIN		2

/*
 *	user modals related defaults
 */
#define		MAX_PASSWD_LEN		PWLEN
#define 	DEF_MIN_PWLEN		6
#define		DEF_PWUNIQUENESS	5
#define		DEF_MAX_PWHIST		8
#define		DEF_MAX_PWAGE		TIMEQ_FOREVER              /* forever */
#define		DEF_MIN_PWAGE		(unsigned long) 0L         /* 0 days */
#define		DEF_FORCE_LOGOFF	(unsigned long) 0xffffffff /* never */
#define		DEF_MAX_BADPW		0			   /* no limit*/
#define		ONE_DAY			(unsigned long) 01*24*3600 /* 01 day  */
/*
 *	User Logon Validation (codes returned)
*/
#define		VALIDATED_LOGON		0
#define 	PASSWORD_EXPIRED	2
#define 	NON_VALIDATED_LOGON	3

#define		VALID_LOGOFF		1


/*
 *	parmnum manifests for user modals
*/

#define		MODAL0_PARMNUM_ALL		0
#define		MODAL0_PARMNUM_MIN_LEN		1
#define		MODAL0_PARMNUM_MAX_AGE		2
#define		MODAL0_PARMNUM_MIN_AGE		3
#define		MODAL0_PARMNUM_FORCEOFF		4
#define		MODAL0_PARMNUM_HISTLEN		5
#define		MODAL0_PARMNUM_RESERVED1	6

#define		MODAL1_PARMNUM_ALL		0
#define		MODAL1_PARMNUM_ROLE		1
#define		MODAL1_PARMNUM_PRIMARY		2


#endif /* NETUSER_INCLUDED */


/****************************************************************
 *								*
 *	  	Group Class			                *
 *								*
 ****************************************************************/

#if (defined( INCL_NETGROUP ) || !defined( LAN_INCLUDED )) \
    && !defined( NETGROUP_INCLUDED )

#define NETGROUP_INCLUDED


/****************************************************************
 *								*
 *	  	Function prototypes - GROUP			*
 *								*
 ****************************************************************/

extern API_FUNCTION
  NetGroupAdd ( const char far * pszServer,
                short            sLevel,
                char far *       pbBuffer,
                unsigned short   cbBuffer );

extern API_FUNCTION
  NetGroupDel ( const char far * pszServer,
                char far *       pszGroupName );

extern API_FUNCTION
  NetGroupEnum ( const char far *     pszServer,
                 short                sLevel,
                 char far *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short far * pcEntriesRead,
                 unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetGroupAddUser ( const char far * pszServer,
                    char far *       pszGroupName,
                    char far *       pszUserName );

extern API_FUNCTION
  NetGroupDelUser ( const char far * pszServer,
                    char far *       pszGroupName,
                    char far *       pszUserName );

extern API_FUNCTION
  NetGroupGetUsers ( const char far *     pszServer,
                     const char far *     pszGroupName,
                     short                sLevel,
                     char far *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short far * pcEntriesRead,
                     unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetGroupSetUsers ( const char far * pszServer,
                     const char far * pszGroupName,
                     short            sLevel,
                     char far *       pbBuffer,
                     unsigned short   cbBuffer,
                     unsigned short   cEntries );

extern API_FUNCTION
  NetGroupGetInfo ( const char far *     pszServer,
                    char far *           pszGroupName,
                    short                sLevel,
                    char far *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetGroupSetInfo ( const char far * pszServer,
                    char far *       pszGroupName,
                    short            sLevel,
                    char far *       pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *                                                              *
 *             Data structure templates - GROUP                 *
 *                                                              *
 ****************************************************************/


struct group_info_0 {
    	char 		grpi0_name[GNLEN+1];
};	/* group_info_0 */

struct group_info_1 {
    	char      	grpi1_name[GNLEN+1];
    	char      	grpi1_pad;
    	char far *	grpi1_comment;
};	/* group_info_1 */

struct group_users_info_0 {
    	char 		grui0_name[UNLEN+1];
};	/* group_users_info_0 */



/****************************************************************
 *								*
 *	  	Special values and constants - GROUP		*
 *								*
 ****************************************************************/

#define		GROUPIDMASK	0x8000	/* MSB set if uid refers to a group */

/*
 * 	Predefined group for all normal users, administrators and guests
 *	LOCAL is a special group for pinball local security.
*/

#define 	GROUP_SPECIALGRP_USERS		"USERS"
#define 	GROUP_SPECIALGRP_ADMINS		"ADMINS"
#define 	GROUP_SPECIALGRP_GUESTS		"GUESTS"
#define 	GROUP_SPECIALGRP_LOCAL		"LOCAL"


/*
 *	parmnum manifests for SetInfo calls (only comment is settable)
*/

#define		GRP1_PARMNUM_ALL	0
#define		GRP1_PARMNUM_NAME	1
#define		GRP1_PARMNUM_COMMENT	2

#endif /* NETGROUP_INCLUDED */

/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/

#if (defined( INCL_NETACCESS ) || !defined( LAN_INCLUDED )) \
    && !defined( NETACCESS_INCLUDED )

#define NETACCESS_INCLUDED


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char far * pszServer,
                 short            sLevel,
                 char far *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char far *           pszReserved,
                   char far *           pszUserName,
                   char far *           pszResource,
                   unsigned short       usOperation,
                   unsigned short far * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char far * pszServer,
                 char far *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char far *     pszServer,
                  char far *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char far *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short far * pcEntriesRead,
                  unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char far *     pszServer,
                     char far *           pszResource,
                     short                sLevel,
                     char far *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char far * pszServer,
                     char far *       pszResource,
                     short            sLevel,
                     char far *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char far *           pszServer,
                          char far *           pszUgName,
                          char far *           pszResource,
                          unsigned short far * pusPerms );


/****************************************************************
 *								*
 *	  	Data structure templates - ACCESS		*
 *								*
 ****************************************************************/

struct access_list {
    	char   		acl_ugname[UNLEN+1];
    	char   		acl_ugname_pad_1;
    	short  		acl_access;
};	/* access_list */

struct access_info_0 {
    	char far * 	acc0_resource_name;
};	/* access_info_0 */

struct access_info_1 {
    	char  far * 	acc1_resource_name;
    	short 		acc1_attr; 		  	/* See values below */
    	short 		acc1_count;
};	/* access_info_1 */

/****************************************************************
 *								*
 *	  	Special values and constants - ACCESS		*
 *								*
 ****************************************************************/

/*
 *	Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *	Bit values for the access permissions.  ACCESS_ALL is a handy
 *	way to specify maximum permissions.  These are used in
 *	acl_access field of access_list structures.
 */
#define		ACCESS_NONE	0
#define 	ACCESS_ALL     (ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM)
#define 	ACCESS_READ   	0x1
#define 	ACCESS_WRITE  	0x2
#define 	ACCESS_CREATE 	0x4
#define 	ACCESS_EXEC   	0x8
#define 	ACCESS_DELETE 	0x10
#define 	ACCESS_ATRIB  	0x20
#define 	ACCESS_PERM   	0x40

#define 	ACCESS_GROUP  	0x8000

/*
 *	Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define 	ACCESS_AUDIT		0x1

/*
 *	Parmnum value for NetAccessSetInfo.
 */

#define 	ACCESS_ATTR_PARMNUM 	2


/*
 *	ACCESS_LETTERS defines a letter for each bit position in
 *	the acl_access field of struct access_list.  Note that some
 *	bits have a corresponding letter of ' ' (space).
 */

#define 	ACCESS_LETTERS 		"RWCXDAP         "


#endif /* NETACCESS_INCLUDED */

/****************************************************************
 *								*
 *	  	Domain Class			                *
 *								*
 ****************************************************************/

#if (defined( INCL_NETDOMAIN ) || !defined( LAN_INCLUDED )) \
    && !defined( NETDOMAIN_INCLUDED )

#define NETDOMAIN_INCLUDED


/****************************************************************
 *                                                              *
 *                  Function prototypes - DOMAIN                *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetGetDCName ( const char far * pszServer,
                 const char far * pszDomain,
                 char far *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetLogonEnum ( const char far *     pszServer,
                 short                sLevel,
                 char far *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short far * pcEntriesRead,
                 unsigned short far * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Special values and constants - DOMAIN		*
 *								*
 ****************************************************************/

#define		LOGON_INFO_UNKNOWN	-1


#endif /* NETDOMAIN_INCLUDED */

/****************************************************************
 *								*
 *	  	Accounts Class			                *
 *								*
 ****************************************************************/

#if (defined( INCL_NETACCOUNTS ) || !defined( LAN_INCLUDED )) \
    && !defined( NETACCOUNTS_INCLUDED )

#define NETACCOUNTS_INCLUDED

/****************************************************************
 *								*
 *	  	Function prototypes - ACCOUNTS			*
 *								*
 ****************************************************************/

extern API_FUNCTION
  NetAccountsReplicate( char far * pszServer,
			unsigned long	 ulReserved );

#endif /* NETACCOUNTS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\netcons.h ===
/********************************************************************/

/**                     Microsoft LAN Manager                      **/

/** Copyright (c) 1987-2001 Microsoft Corporation, All Rights Reserved **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  NETCONS.H				    *
 *								    *
 *  This file contains constants used throughout the LAN Manager    *
 *  API header files.  It should be included in any source file     *
 *  that is going to include other LAN Manager API header files or  *
 *  call a LAN Manager API.					    *
 *								    *
 ********************************************************************/

/*
 *	NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *	strlen() value.  This does not include space for the 
 *	terminating 0-byte.  When allocating space for such an item,
 *	use the form:
 *
 *		char username[UNLEN+1];
 *
 *	An exception to this is the PATHLEN manifest, which does
 *	include space for the terminating 0-byte.
 */

#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED


#define CNLEN		15		    /* Computer name length     */
#define UNCLEN		(CNLEN+2)	    /* UNC computer name length */
#define NNLEN		12		    /* 8.3 Net name length      */
#define RMLEN		(UNCLEN+1+NNLEN)    /* Maximum remote name length */

#define SNLEN		15		    /* Service name length      */
#define STXTLEN		63		    /* Service text length      */

#define PATHLEN 	260

#define DEVLEN		 8 		    /* Device name length	*/

#define DNLEN		CNLEN		    /* Maximum domain name length */
#define EVLEN		16		    /* event name length        */
#define JOBSTLEN	80		    /* status length in print job */
#define	AFLEN		64		    /* Maximum length of alert  */
					    /* names field 		*/
#define UNLEN		20	   	    /* Maximum user name length	*/
#define GNLEN 		UNLEN		    /* Group name               */
#define PWLEN		14		    /* Maximum password length  */
#define SHPWLEN 	 8		    /* Share password length	*/
#define CLTYPE_LEN	12		    /* Length of client type string */


#define MAXCOMMENTSZ	48		    /* server & share comment length */

#define QNLEN		12		    /* Queue name maximum length     */
#define PDLEN		 8		    /* Print destination length      */
#define DTLEN		 9	            /* Spool file data type          */
					    /* e.g. IBMQSTD,IBMQESC,IBMQRAW  */
#define ALERTSZ		128		    /* size of alert string in server */
#define MAXDEVENTRIES	(sizeof (int)*8)    /* Max number of device entries   */
					    /* We use int bitmap to represent */

#define	HOURS_IN_WEEK		24*7	    /* for struct user_info_2 in UAS */
#define	MAXWORKSTATIONS		8	    /* for struct user_info_2 in UAS */

#define NETBIOS_NAME_LEN	16	    /* NetBIOS net name */



/*
 *	Constants used with encryption
 */

#define	CRYPT_KEY_LEN	7
#define	CRYPT_TXT_LEN	8
#define ENCRYPTED_PWLEN	16
#define SESSION_PWLEN	24
#define SESSION_CRYPT_KLEN 21

/*
 *  Value to be used with SetInfo calls to allow setting of all
 *  settable parameters (parmnum zero option)
*/
#ifndef  PARMNUM_ALL
#define		PARMNUM_ALL		0
#endif

/*
 *	Message File Names
 */

#define MESSAGE_FILE		"NETPROG\\NET.MSG"
#define MESSAGE_FILENAME	"NET.MSG"
#define OS2MSG_FILE		"NETPROG\\OSO001.MSG"
#define OS2MSG_FILENAME		"OSO001.MSG"
#define HELP_MSG_FILE		"NETPROG\\NETH.MSG"
#define HELP_MSG_FILENAME	"NETH.MSG"
#define NMP_MSG_FILE		"NETPROG\\NMP.MSG"
#define NMP_MSG_FILENAME	"NMP.MSG"

#define MESSAGE_FILE_BASE	"NETPROG\\NET00000"
#define MESSAGE_FILE_EXT	".MSG"



#define NMP_LOW_END		230
#define NMP_HIGH_END		240

#ifndef NULL
#define  NULL    0
#endif


#define PUNAVAIL NULL
#define API_RET_TYPE unsigned
#define API_FUNCTION API_RET_TYPE far pascal







#endif /* NETCONS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\chardev.h ===
/********************************************************************/

/**                     Microsoft LAN Manager                      **/

/** Copyright (c) 1987-2001 Microsoft Corporation, All Rights Reserved **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  CHARDEV.H				    *
 *								    *
 *  This file contains information about the NetCharDev 	    *
 *  and NetHandle class APIs.					    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 *	   This file is always included by LAN.H.		    *
 *								    *
 ********************************************************************/


/****************************************************************
 *								*
 *	  	Character Device Class			        *
 *								*
 ****************************************************************/

#if (defined( INCL_NETCHARDEV ) || !defined( LAN_INCLUDED )) \
    && !defined( NETCHARDEV_INCLUDED )

#define NETCHARDEV_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes - CHARDEV                   *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetCharDevControl ( const char far * pszServer,
                      const char far * pszDevName,
                      short            sOpCode );

extern API_FUNCTION
  NetCharDevEnum ( const char far *     pszServer,
                   short                sLevel,
                   char far *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short far * pcEntriesRead,
                   unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetCharDevGetInfo ( const char far *     pszServer,
                      const char far *     pszDevName,
                      short                sLevel,
                      char far *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetCharDevQEnum ( const char far *     pszServer,
                    const char far *     pszUserName,
                    short                sLevel,
                    char far *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short far * pcEntriesRead,
                    unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetCharDevQGetInfo ( const char far *     pszServer,
                       const char far *     pszQueueName,
                       const char far *     pszUserName,
                       short                sLevel,
                       char far *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetCharDevQSetInfo ( const char far * pszServer,
                       const char far * pszQueueName,
                       short            sLevel,
                       const char far * pbBuffer,
                       unsigned short   cbBuffer,
                       short            sParmNum );

extern API_FUNCTION
  NetCharDevQPurge ( const char far * pszServer,
                     const char far * pszQueueName );

extern API_FUNCTION
  NetCharDevQPurgeSelf ( const char far * pszServer,
                         const char far * pszQueueName,
                         const char far * pszComputerName );


/****************************************************************
 *								*
 *	  	Data structure templates - CHARDEV		*
 *								*
 ****************************************************************/

struct chardev_info_0 {
    char	   ch0_dev[DEVLEN+1];  /* device name			    */
};	/* chardev_info_0 */

struct chardev_info_1 {
    char	   ch1_dev[DEVLEN+1]; /* device name			    */
    char	   ch1_pad1;	      /* pad to a word boundary		    */
    unsigned short ch1_status;        /* status                             */
				      /*   bit 0 reserved		    */
                                      /*   bit 1 on = opened                */
				      /*   bit 1 off = idle		    */
				      /*   bit 2 on = error		    */
				      /*   bit 2 off = no error 	    */
    char	   ch1_username[UNLEN+1]; /* name of device's current user  */
    char	   ch1_pad2;	      /* pad to a word boundary		    */
    unsigned long  ch1_time;          /* time current user attached         */
}; /* chardev_info_1 */


struct chardevQ_info_0 {
    char	   cq0_dev[NNLEN+1];   /* queue name (network name)	    */
}; /* chardevQ_info_0 */

struct chardevQ_info_1 {
    char	   cq1_dev[NNLEN+1];   /* queue name (network name)	    */
    char	   cq1_pad;	       /* pad to a word boundary 	    */
    unsigned short cq1_priority;       /* priority (1 - 9)		    */
    char far *     cq1_devs;           /* names of devices assigned to queue */
    unsigned short cq1_numusers;       /* # of users waiting in queue        */
    unsigned short cq1_numahead;       /* # of users in queue ahead of this  */
                                       /*     user. -1 is returned if the    */
                                       /*     user is not in the queue.      */
}; /* chardevQ_info_1 */

/****************************************************************
 *								*
 *	  	Special values and constants - CHARDEV		*
 *								*
 ****************************************************************/

/*
 *	Bits for chardev_info_1 field ch1_status.
 */

#define CHARDEV_STAT_OPENED		0x02
#define CHARDEV_STAT_ERROR		0x04

/*
 *	Opcodes for NetCharDevControl
 */

#define CHARDEV_CLOSE			0

/*
 *	Values for parmnum parameter to NetCharDevQSetInfo.
 */

#define CHARDEVQ_PRIORITY_PARMNUM	2
#define CHARDEVQ_DEVICES_PARMNUM	3


/*
 *	Minimum, maximum, and recommended default for priority.
 */

#define CHARDEVQ_MAX_PRIORITY		1
#define CHARDEVQ_MIN_PRIORITY		9
#define CHARDEVQ_DEF_PRIORITY		5

/*
 *	Value indicating no requests in the queue.
 */

#define CHARDEVQ_NO_REQUESTS		-1


#endif /* NETCHARDEV_INCLUDED */

/****************************************************************
 *								*
 *	  	Handle Class					*
 *								*
 ****************************************************************/

#if (defined( INCL_NETHANDLE ) || !defined( LAN_INCLUDED )) \
    && !defined( NETHANDLE_INCLUDED )

#define NETHANDLE_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes - HANDLE                    *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetHandleGetInfo ( unsigned short       hHandle,
                     short                sLevel,
                     char far *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetHandleSetInfo ( unsigned short hHandle,
                     short          sLevel,
                     char far *     pbBuffer,
                     unsigned short cbBuffer,
                     unsigned short sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - HANDLE		*
 *								*
 ****************************************************************/

struct handle_info_1 {
	unsigned long	hdli1_chartime;	/* time in msec to wait before send */
	unsigned short	hdli1_charcount; /* max size of send buffer */
}; /* handle_info_1 */

struct handle_info_2 {
	char far * hdli2_username;	/* owner of name-pipe handle */
}; /* handle_info_2 */

struct handle_info_3 {
	char far * 	hdli3_username;		/* User name attached to pipe */
	char far * 	hdli3_computername;	/* Computername of user */
	unsigned short	hdli3_priv;		/* Privilege for user */
	unsigned long	hdli3_authflags;	/* Operator rights for user */
	char far *	hdli3_reserved;		/* reserved */
}; /* handle_info_3 */


/****************************************************************
 *								*
 *	  	Special values and constants - HANDLE		*
 *								*
 ****************************************************************/


/*
 *	Handle Get Info Levels
 */

#define HANDLE_INFO_LEVEL_1		1
#define	HANDLE_INFO_LEVEL_2		2
#define HANDLE_INFO_LEVEL_3		3


/*
 *	Handle Set Info    parm numbers
 */

#define	HANDLE_SET_CHAR_TIME		1
#define	HANDLE_SET_CHAR_COUNT		2


#endif /* NETHANDLE_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\neterr.h ===
/********************************************************************/

/**                     Microsoft LAN Manager                      **/

/** Copyright (c) 1987-2001 Microsoft Corporation, All Rights Reserved **/
/********************************************************************/

/***	neterr.h - network error definitions
 *
 */



#ifndef NETERR_INCLUDED

#define NETERR_INCLUDED 


#define NERR_Success		0	/* Success */

/*
 *	Redirector related
 *		Error codes from 50 to 79, 88, and 230 to 249
 */

#define ERROR_NOT_SUPPORTED	50	/* The network request is not supported.  */
#define ERROR_REM_NOT_LIST	51	/* This remote computer is not listening. */
#define ERROR_DUP_NAME		52	/* A duplicate name exists on the network. */
#define ERROR_BAD_NETPATH	53	/* The network path cannot be located. */
#define ERROR_NETWORK_BUSY	54	/* The network is busy. */
#define ERROR_DEV_NOT_EXIST	55	/* This device does not exist on the network. */
#define ERROR_TOO_MANY_CMDS	56	/* The network BIOS command limit has been reached. */
#define ERROR_ADAP_HDW_ERR	57	/* A network adapter hardware error has occurred. */
#define ERROR_BAD_NET_RESP	58	/* The network responded incorrectly. */
#define ERROR_UNEXP_NET_ERR	59	/* An unexpected network error occurred. */
#define ERROR_BAD_REM_ADAP	60	/* The remote adapter is not compatible. */
#define ERROR_PRINTQ_FULL	61	/* The printer queue is full. */
#define ERROR_NO_SPOOL_SPACE	62	/* Space to store the file waiting to be printed is not available on the server. */
#define ERROR_PRINT_CANCELLED	63	/* The requested print file has been cancelled. */
#define ERROR_NETNAME_DELETED	64	/* The network name was deleted. */
#define	ERROR_NETWORK_ACCESS_DENIED 65	/* Network access is denied. */
#define ERROR_BAD_DEV_TYPE	66	/* The network resource type is not correct. */
#define ERROR_BAD_NET_NAME	67	/* The network name cannot be found. */
#define ERROR_TOO_MANY_NAMES	68	/* The name limit for the local computer network adapter card was exceeded. */
#define ERROR_TOO_MANY_SESS	69	/* The network BIOS session limit was exceeded. */
#define ERROR_SHARING_PAUSED	70	/* File sharing has been temporarily paused. */
#define ERROR_REQ_NOT_ACCEP	71	/* The network request was not accepted. */
#define ERROR_REDIR_PAUSED	72	/* Print or disk redirection is temporarily paused. */

#define ERROR_NET_WRITE_FAULT	88	/* A network data fault occurred. */

#define	ERROR_BAD_PIPE		230	/* This is a nonexistent pipe or an invalid operation. */
#define	ERROR_PIPE_BUSY		231	/* The specified pipe is busy. */
#define	ERROR_NO_DATA		232	/* There is no data to be read on a non-blocking read. */
#define	ERROR_PIPE_NOT_CONNECTED 233	/* The server disconnected the pipe. */
#define	ERROR_MORE_DATA		234	/* Additional data is available. */

#define	ERROR_VC_DISCONNECTED	240	/* The session was cancelled. */


/***	NERR_BASE is the base of error codes from network utilities,
 *	chosen to avoid conflict with OS/2 and redirector error codes.
 *	2100 is a value that has been assigned to us by OS/2.
 */
#define	NERR_BASE	2100



/* UNUSED BASE+0 */
/* UNUSED BASE+1 */
#define NERR_NetNotStarted	(NERR_BASE+2)	/* The workstation driver (NETWKSTA.SYS on OS/2 workstations, NETWKSTA.EXE on DOS workstations) isn't installed. */
#define NERR_UnknownServer	(NERR_BASE+3)	/* The server cannot be located. */
#define NERR_ShareMem		(NERR_BASE+4)	/* An internal error occurred.  The network cannot access a shared memory segment. */
#define NERR_NoNetworkResource	(NERR_BASE+5)	/* A network resource shortage occurred . */
#define NERR_RemoteOnly		(NERR_BASE+6)	/* This operation is not supported on workstations. */
#define NERR_DevNotRedirected	(NERR_BASE+7)	/* The device is not connected. */
/* UNUSED BASE+8 */
/* UNUSED BASE+9 */
/* UNUSED BASE+10 */
/* UNUSED BASE+11 */
/* UNUSED BASE+12 */
/* UNUSED BASE+13 */
#define NERR_ServerNotStarted	(NERR_BASE+14)	/* The Server service isn't started. */
#define NERR_ItemNotFound	(NERR_BASE+15)	/* The queue is empty. */
#define NERR_UnknownDevDir	(NERR_BASE+16)	/* The device or directory does not exist. */
#define NERR_RedirectedPath	(NERR_BASE+17)	/* The operation is invalid on a redirected resource. */
#define NERR_DuplicateShare	(NERR_BASE+18)	/* The name has already been shared. */
#define NERR_NoRoom		(NERR_BASE+19)	/* The server is currently out of the requested resource. */
/* UNUSED BASE+20 */
#define NERR_TooManyItems	(NERR_BASE+21)	/* Requested add of item exceeds maximum allowed. */
#define NERR_InvalidMaxUsers	(NERR_BASE+22)	/* The Peer service supports only two simultaneous users. */
#define NERR_BufTooSmall	(NERR_BASE+23)	/* The API return buffer is too small. */
/* UNUSED BASE+24 */
/* UNUSED BASE+25 */
/* UNUSED BASE+26 */
#define NERR_RemoteErr		(NERR_BASE+27)	/* A remote API error occurred.  */
/* UNUSED BASE+28 */
/* UNUSED BASE+29 */
/* UNUSED BASE+30 */
#define NERR_LanmanIniError	(NERR_BASE+31)	/* An error occurred when opening or reading LANMAN.INI. */
/* UNUSED BASE+32 */
/* UNUSED BASE+33 */
#define NERR_OS2IoctlError	(NERR_BASE+34)	/* An internal error occurred when calling the workstation driver. */
/* UNUSED BASE+35 */
#define	NERR_NetworkError	(NERR_BASE+36)	/* A general network error occurred. */
/* UNUSED BASE+37 */
#define NERR_WkstaNotStarted	(NERR_BASE+38)	/* The Workstation service has not been started. */
#define NERR_BrowserNotStarted	(NERR_BASE+39)	/* The requested information is not available. */
#define NERR_InternalError	(NERR_BASE+40)	/* An internal LAN Manager error occurred.*/
#define NERR_BadTransactConfig	(NERR_BASE+41)	/* The server is not configured for transactions. */
#define NERR_InvalidAPI		(NERR_BASE+42)	/* The requested API isn't supported on the remote server. */
#define NERR_BadEventName	(NERR_BASE+43)	/* The event name is invalid. */
/* UNUSED BASE+44 */

/*
 *	Config API related
 *		Error codes from BASE+45 to BASE+49
 */

/* UNUSED BASE+45 */
#define NERR_CfgCompNotFound	(NERR_BASE+46)	/* Could not find the specified component in LANMAN.INI. */
#define NERR_CfgParamNotFound	(NERR_BASE+47)	/* Could not find the specified parameter in LANMAN.INI. */
#define NERR_LineTooLong	(NERR_BASE+49)	/* A line in LANMAN.INI is too long. */

/*
 *	Spooler API related
 *		Error codes from BASE+50 to BASE+79
 */

#define NERR_QNotFound		(NERR_BASE+50)	/* The printer queue does not exist. */
#define NERR_JobNotFound	(NERR_BASE+51)	/* The print job does not exist. */
#define NERR_DestNotFound	(NERR_BASE+52)	/* The printer destination cannot be found. */
#define NERR_DestExists 	(NERR_BASE+53)	/* The printer destination already exists. */
#define NERR_QExists		(NERR_BASE+54)	/* The printer queue already exists. */
#define NERR_QNoRoom		(NERR_BASE+55)	/* No more printer queues can be added. */
#define NERR_JobNoRoom		(NERR_BASE+56)	/* No more print jobs can be added.  */
#define NERR_DestNoRoom 	(NERR_BASE+57)	/* No more printer destinations can be added. */
#define NERR_DestIdle		(NERR_BASE+58)	/* This printer destination is idle and cannot accept control operations. */
#define NERR_DestInvalidOp	(NERR_BASE+59)	/* This printer destination request contains an invalid control function. */
#define NERR_ProcNoRespond	(NERR_BASE+60)	/* The printer processor is not responding. */
#define NERR_SpoolerNotLoaded	(NERR_BASE+61)	/* The spooler is not running. */
#define NERR_DestInvalidState	(NERR_BASE+62)	/* This operation cannot be performed on the print destination in its current state. */
#define NERR_QInvalidState	(NERR_BASE+63)	/* This operation cannot be performed on the printer queue in its current state. */
#define NERR_JobInvalidState	(NERR_BASE+64)	/* This operation cannot be performed on the print job in its current state. */
#define	NERR_SpoolNoMemory	(NERR_BASE+65)	/* A spooler memory allocation failure occurred. */
#define NERR_DriverNotFound	(NERR_BASE+66)	/* The device driver does not exist. */
#define NERR_DataTypeInvalid	(NERR_BASE+67)	/* The datatype is not supported by the processor. */
#define NERR_ProcNotFound	(NERR_BASE+68)	/* The print processor is not installed. */

/*
 *	Service API related
 *		Error codes from BASE+80 to BASE+99
 */

#define NERR_ServiceTableLocked	(NERR_BASE+80)	/* The service does not respond to control actions. */
#define NERR_ServiceTableFull	(NERR_BASE+81)	/* The service table is full. */
#define NERR_ServiceInstalled	(NERR_BASE+82)	/* The requested service has already been started. */
#define NERR_ServiceEntryLocked	(NERR_BASE+83)	/* The service does not respond to control actions. */
#define NERR_ServiceNotInstalled (NERR_BASE+84) /* The service has not been started. */
#define NERR_BadServiceName	(NERR_BASE+85)	/* The service name is invalid. */
#define NERR_ServiceCtlTimeout	(NERR_BASE+86)	/* The service is not responding to the control function. */
#define NERR_ServiceCtlBusy	(NERR_BASE+87)	/* The service control is busy. */
#define NERR_BadServiceProgName	(NERR_BASE+88)	/* LANMAN.INI contains an invalid service program name. */
#define NERR_ServiceNotCtrl	(NERR_BASE+89)	/* The service cannot be controlled in its present state. */
#define NERR_ServiceKillProc	(NERR_BASE+90)	/* The service ended abnormally. */
#define NERR_ServiceCtlNotValid	(NERR_BASE+91)	/* The requested pause or stop is not valid for this service. */

/*
 *	Wksta and Logon API related
 *		Error codes from BASE+100 to BASE+118
 */

#define NERR_AlreadyLoggedOn	(NERR_BASE+100)	/* This workstation is already logged on to the local-area network. */
#define NERR_NotLoggedOn	(NERR_BASE+101)	/* The workstation isn't logged on to the local-area network. */
#define NERR_BadUsername	(NERR_BASE+102)	/* The username or groupname parameter is invalid.  */
#define NERR_BadPassword	(NERR_BASE+103)	/* The password parameter is invalid. */
#define NERR_UnableToAddName_W	(NERR_BASE+104)	/* @W The logon processor did not add the message alias. */
#define NERR_UnableToAddName_F	(NERR_BASE+105)	/* The logon processor did not add the message alias. */
#define NERR_UnableToDelName_W	(NERR_BASE+106)	/* @W The logoff processor did not delete the message alias. */
#define NERR_UnableToDelName_F	(NERR_BASE+107)	/* The logoff processor did not delete the message alias. */
/* UNUSED BASE+108 */
#define NERR_LogonsPaused 	(NERR_BASE+109) /* Network logons are paused. */
#define NERR_LogonServerConflict (NERR_BASE+110)/* A centralized logon-server conflict occurred. */
#define NERR_LogonNoUserPath	(NERR_BASE+111) /* The server is configured without a valid user path. */
#define NERR_LogonScriptError	(NERR_BASE+112) /* An error occurred while loading or running the logon script. */
/* UNUSED BASE+113 */
#define NERR_StandaloneLogon    (NERR_BASE+114) /* The logon server was not specified.  Your computer will be logged on as STANDALONE. */
#define NERR_LogonServerNotFound (NERR_BASE+115) /* The logon server cannot be found.  */
#define NERR_LogonDomainExists	(NERR_BASE+116) /* There is already a logon domain for this computer.  */
#define NERR_NonValidatedLogon	(NERR_BASE+117) /* The logon server could not validate the logon. */

/*
 *	ACF API related (access, user, group)
 *		Error codes from BASE+119 to BASE+149
 */

#define NERR_ACFNotFound	(NERR_BASE+119)	/* The accounts file NET.ACC cannot be found. */
#define NERR_GroupNotFound	(NERR_BASE+120)	/* The groupname cannot be found. */
#define NERR_UserNotFound	(NERR_BASE+121)	/* The username cannot be found. */
#define NERR_ResourceNotFound	(NERR_BASE+122)	/* The resource name cannot be found.  */
#define NERR_GroupExists	(NERR_BASE+123)	/* The group already exists. */
#define NERR_UserExists		(NERR_BASE+124)	/* The user account already exists. */
#define NERR_ResourceExists	(NERR_BASE+125)	/* The resource permission list already exists. */
#define NERR_NotPrimary		(NERR_BASE+126)	/* The UAS database is replicant and will not allow updates. */
#define NERR_ACFNotLoaded	(NERR_BASE+127) /* The user account system has not been started. */
#define NERR_ACFNoRoom		(NERR_BASE+128)	/* There are too many names in the user account system. */
#define NERR_ACFFileIOFail	(NERR_BASE+129)	/* A disk I/O failure occurred.*/
#define NERR_ACFTooManyLists	(NERR_BASE+130)	/* The limit of 64 entries per resource was exceeded. */
#define NERR_UserLogon		(NERR_BASE+131) /* Deleting a user with a session is not allowed. */
#define NERR_ACFNoParent	(NERR_BASE+132)	/* The parent directory cannot be located. */
#define NERR_CanNotGrowSegment  (NERR_BASE+133) /* Unable to grow UAS session cache segment. */
#define NERR_SpeGroupOp		(NERR_BASE+134) /* This operation is not allowed on this special group. */
#define NERR_NotInCache  	(NERR_BASE+135) /* This user is not cached in UAS session cache. */
#define NERR_UserInGroup	(NERR_BASE+136) /* The user already belongs to this group. */
#define NERR_UserNotInGroup	(NERR_BASE+137) /* The user does not belong to this group. */
#define NERR_AccountUndefined	(NERR_BASE+138) /* This user account is undefined. */
#define NERR_AccountExpired	(NERR_BASE+139) /* This user account has expired. */
#define NERR_InvalidWorkstation (NERR_BASE+140) /* The user is not allowed to log on from this workstation. */
#define NERR_InvalidLogonHours	(NERR_BASE+141) /* The user is not allowed to log on at this time.  */
#define NERR_PasswordExpired	(NERR_BASE+142) /* The password of this user has expired. */
#define NERR_PasswordCantChange (NERR_BASE+143) /* The password of this user cannot change. */
#define NERR_PasswordHistConflict (NERR_BASE+144) /* This password cannot be used now. */
#define NERR_PasswordTooShort	(NERR_BASE+145) /* The password is shorter than required. */
#define NERR_PasswordTooRecent	(NERR_BASE+146) /* The password of this user is too recent to change.  */
#define NERR_InvalidDatabase	(NERR_BASE+147) /* The UAS database file is corrupted. */
#define NERR_DatabaseUpToDate	(NERR_BASE+148) /* No updates are necessary to this replicant UAS database. */
#define NERR_SyncRequired	(NERR_BASE+149) /* This replicant database is outdated; synchronization is required. */

/*
 *	Use API related 
 *		Error codes from BASE+150 to BASE+169
 */

#define NERR_UseNotFound	(NERR_BASE+150)	/* The connection cannot be found. */
#define NERR_BadAsgType		(NERR_BASE+151)	/* This asg_type is invalid. */
#define NERR_DeviceIsShared	(NERR_BASE+152) /* This device is currently being shared. */

/* 
 *	Message Server related 
 *		Error codes BASE+170 to BASE+209
 */

#define	NERR_NoComputerName	(NERR_BASE+170)	/* A computername has not been configured.  */
#define	NERR_MsgAlreadyStarted	(NERR_BASE+171)	/* The Messenger service is already started. */
#define NERR_MsgInitFailed	(NERR_BASE+172)	/* The Messenger service failed to start.  */
#define	NERR_NameNotFound	(NERR_BASE+173)	/* The message alias cannot be found on the local-area network. */
#define	NERR_AlreadyForwarded	(NERR_BASE+174)	/* This message alias has already been forwarded. */
#define NERR_AddForwarded	(NERR_BASE+175)	/* This message alias has been added but is still forwarded. */
#define NERR_AlreadyExists	(NERR_BASE+176)	/* This message alias already exists locally. */
#define	NERR_TooManyNames	(NERR_BASE+177)	/* The maximum number of added message aliases has been exceeded. */
#define NERR_DelComputerName	(NERR_BASE+178)	/* The computername cannot be deleted.*/
#define	NERR_LocalForward	(NERR_BASE+179)	/* Messages cannot be forwarded back to the same workstation. */
#define NERR_GrpMsgProcessor	(NERR_BASE+180) /* Error in domain message processor */
#define NERR_PausedRemote	(NERR_BASE+181)	/* The message was sent, but the recipient has paused the Messenger service. */
#define	NERR_BadReceive		(NERR_BASE+182)	/* The message was sent but not received. */
#define	NERR_NameInUse		(NERR_BASE+183)	/* The message alias is currently in use. Try again later. */
#define	NERR_MsgNotStarted	(NERR_BASE+184)	/* The Messenger service has not been started. */
#define	NERR_NotLocalName	(NERR_BASE+185)	/* The name is not on the local computer. */
#define	NERR_NoForwardName	(NERR_BASE+186)	/* The forwarded message alias cannot be found on the network. */
#define	NERR_RemoteFull		(NERR_BASE+187)	/* The message alias table on the remote station is full. */
#define NERR_NameNotForwarded	(NERR_BASE+188)	/* Messages for this alias are not currently being forwarded. */
#define NERR_TruncatedBroadcast	(NERR_BASE+189)	/* The broadcast message was truncated. */
#define	NERR_InvalidDevice	(NERR_BASE+194)	/* This is an invalid devicename. */
#define	NERR_WriteFault		(NERR_BASE+195)	/* A write fault occurred. */
/* UNUSED BASE+196 */
#define	NERR_DuplicateName	(NERR_BASE+197)	/* A duplicate message alias exists on the local-area network. */
#define	NERR_DeleteLater	(NERR_BASE+198)	/* @W This message alias will be deleted later. */
#define NERR_IncompleteDel	(NERR_BASE+199) /* The message alias was not successfully deleted from all networks. */
#define NERR_MultipleNets	(NERR_BASE+200) /* This operation is not supported on machines with multiple networks. */

/* 
 * 	Server API related 
 *		Error codes BASE+210 to BASE+229
 */
 
#define NERR_NetNameNotFound	(NERR_BASE+210)	/* This shared resource does not exist.*/
#define	NERR_DeviceNotShared	(NERR_BASE+211)	/* This device is not shared. */
#define NERR_ClientNameNotFound	(NERR_BASE+212)	/* A session does not exist with that computername. */
#define NERR_FileIdNotFound	(NERR_BASE+214)	/* There isn't an open file with that ID number. */
#define NERR_ExecFailure	(NERR_BASE+215)	/* A failure occurred when executing a remote administration command. */
#define NERR_TmpFile		(NERR_BASE+216) /* A failure occurred when opening a remote temporary file. */
#define NERR_TooMuchData	(NERR_BASE+217) /* The data returned from a remote administration command has been truncated to 64K. */
#define NERR_DeviceShareConflict (NERR_BASE+218) /* This device cannot be shared as both a spooled and a non-spooled resource. */
#define NERR_BrowserTableIncomplete (NERR_BASE+219)  /* The information in the list of servers may be incorrect. */
#define NERR_NotLocalDomain	(NERR_BASE+220) /* The computer isn't active on this domain. */

/* 
 * 	CharDev API related 
 *		Error codes BASE+230 to BASE+249
 */
 
/* UNUSED BASE+230 */
#define NERR_DevInvalidOpCode	(NERR_BASE+231)	/* The operation is invalid for this device. */
#define NERR_DevNotFound	(NERR_BASE+232)	/* This device cannot be shared. */
#define NERR_DevNotOpen		(NERR_BASE+233)	/* This device was not open. */
#define NERR_BadQueueDevString	(NERR_BASE+234)	/* This devicename list is invalid. */
#define NERR_BadQueuePriority	(NERR_BASE+235)	/* The queue priority is invalid. */
#define NERR_NoCommDevs		(NERR_BASE+237)	/* There are no shared communication devices. */
#define NERR_QueueNotFound	(NERR_BASE+238)	/* The queue you specified doesn't exist. */
#define NERR_BadDevString	(NERR_BASE+240) /* This list of devices is invalid. */
#define NERR_BadDev		(NERR_BASE+241) /* The requested device is invalid. */
#define NERR_InUseBySpooler	(NERR_BASE+242) /* This device is already in use by the spooler. */
#define NERR_CommDevInUse	(NERR_BASE+243) /* This device is already in use as a communication device. */

/* 
 *	NetICanonicalize and NetIType and NetIMakeLMFileName
 *	NetIListCanon and NetINameCheck
 *		Error codes BASE+250 to BASE+269
 */
 
#define NERR_InvalidComputer   (NERR_BASE+251) /* This computername is invalid. */
/* UNUSED BASE+252 */
/* UNUSED BASE+253 */
#define NERR_MaxLenExceeded    (NERR_BASE+254) /* The string and prefix specified are too long. */
/* UNUSED BASE+255 */
#define NERR_BadComponent      (NERR_BASE+256) /* This path component is invalid. */
#define NERR_CantType	       (NERR_BASE+257) /* Cannot determine type of input. */
/* UNUSED BASE+258 */
/* UNUSED BASE+259 */
#define NERR_TooManyEntries    (NERR_BASE+262) /* The buffer for types is not big enough. */

/* 
 *	NetProfile
 *		Error codes BASE+270 to BASE+276
 */
 
#define NERR_ProfileFileTooBig	(NERR_BASE+270) /* Profile files cannot exceed 64K. */
#define NERR_ProfileOffset	(NERR_BASE+271) /* The start offset is out of range. */
#define NERR_ProfileCleanup	(NERR_BASE+272) /* The system cannot delete current connections to network resources. */
#define NERR_ProfileUnknownCmd	(NERR_BASE+273) /* The system was unable to parse the command line in this file.*/
#define NERR_ProfileLoadErr	(NERR_BASE+274) /* An error occurred while loading the profile file. */
#define NERR_ProfileSaveErr	(NERR_BASE+275) /* @W Errors occurred while saving the profile file.  The profile was partially saved. */


/*
 * 	NetAudit and NetErrorLog
 *		Error codes BASE+277 to BASE+279
 */

#define NERR_LogOverflow	   (NERR_BASE+277)	/* This log file exceeds the maximum defined size. */
#define NERR_LogFileChanged	   (NERR_BASE+278)	/* This log file has changed between reads. */
#define NERR_LogFileCorrupt	   (NERR_BASE+279)	/* This log file is corrupt. */

/* 
 *	NetRemote
 *		Error codes BASE+280 to BASE+299
 */
#define NERR_SourceIsDir   (NERR_BASE+280) /* The source path cannot be a directory. */
#define NERR_BadSource     (NERR_BASE+281) /* The source path is illegal. */
#define NERR_BadDest       (NERR_BASE+282) /* The destination path is illegal. */
#define NERR_DifferentServers   (NERR_BASE+283) /* The source and destination paths are on different servers. */
/* UNUSED BASE+284 */
#define NERR_RunSrvPaused 	(NERR_BASE+285) /* The Run server you requested is paused. */
/* UNUSED BASE+286 */
/* UNUSED BASE+287 */
/* UNUSED BASE+288 */
#define NERR_ErrCommRunSrv 	(NERR_BASE+289) /* An error occurred when communicating with a Run server. */
/* UNUSED BASE+290 */
#define NERR_ErrorExecingGhost 	(NERR_BASE+291) /* An error occurred when starting a background process. */
#define NERR_ShareNotFound 	(NERR_BASE+292) /* The shared resource you are connected to could not be found.*/
/* UNUSED BASE+293 */
/* UNUSED BASE+294 */


/*
 *  NetWksta.sys (redir) returned error codes.
 *
 *          NERR_BASE + (300-329)
 */

#define NERR_InvalidLana        (NERR_BASE+300) /* The LAN adapter number is invalid.  */
#define NERR_OpenFiles          (NERR_BASE+301) /* There are open files on the connection.    */
#define NERR_ActiveConns        (NERR_BASE+302) /* Active connections still exist. */
#define NERR_BadPasswordCore    (NERR_BASE+303) /* This netname or password is invalid. */
#define NERR_DevInUse           (NERR_BASE+304) /* The device is being accessed by an active process. */
#define NERR_LocalDrive		(NERR_BASE+305) /* The drive letter is in use locally. */

/*
 *  Alert error codes.
 *
 *          NERR_BASE + (330-339)
 */
#define NERR_AlertExists	(NERR_BASE+330)	/* The specified client is already registered for the specified event. */
#define NERR_TooManyAlerts	(NERR_BASE+331)	/* The alert table is full. */
#define NERR_NoSuchAlert	(NERR_BASE+332)	/* An invalid or nonexistent alertname was raised. */
#define NERR_BadRecipient       (NERR_BASE+333) /* The alert recipient is invalid.*/
#define NERR_AcctLimitExceeded	(NERR_BASE+334) /* A user's session with this server has been deleted
						 * because his logon hours are no longer valid */

/*
 *  Additional Error and Audit log codes.
 *
 *	    NERR_BASE +(340-343)
 */
#define NERR_InvalidLogSeek	(NERR_BASE+340) /* The log file does not contain the requested record number. */
/* UNUSED BASE+341 */
/* UNUSED BASE+342 */
/* UNUSED BASE+343 */

/*
 *  Additional UAS and NETLOGON codes
 *
 *	    NERR_BASE +(350-359)
 */
#define NERR_BadUasConfig	(NERR_BASE+350) /* The user account system database is not configured correctly. */
#define NERR_InvalidUASOp	(NERR_BASE+351) /* This operation is not permitted when the Netlogon service is running. */
#define NERR_LastAdmin		(NERR_BASE+352) /* This operation is not allowed on the last admin account. */
#define NERR_DCNotFound		(NERR_BASE+353) /* Unable to find domain controller for this domain. */
#define NERR_LogonTrackingError	(NERR_BASE+354) /* Unable to set logon information for this user. */
#define NERR_NetlogonNotStarted (NERR_BASE+355) /* The Netlogon service has not been started. */
#define NERR_CanNotGrowUASFile	(NERR_BASE+356) /* Unable to grow the user account system database. */
#define NERR_TimeDiffAtDC       (NERR_BASE+357) /* The time on this machine is not synchronized with the time on the primary domain controller. */
#define NERR_PasswordMismatch   (NERR_BASE+358) /* A password mismatch has been detected. */
/* UNUSED BASE+359 */

/*
 *  Server Integration error codes.
 *
 *	    NERR_BASE +(360-369)
 */
#define NERR_NoSuchServer	(NERR_BASE+360) /* The server ID does not specify a valid server. */
#define NERR_NoSuchSession	(NERR_BASE+361) /* The session ID does not specify a valid session. */
#define NERR_NoSuchConnection	(NERR_BASE+362) /* The connection ID does not specify a valid connection. */
#define NERR_TooManyServers	(NERR_BASE+363) /* There is no space for another entry in the table of available servers. */
#define NERR_TooManySessions	(NERR_BASE+364) /* The server has reached the maximum number of sessions it supports. */
#define NERR_TooManyConnections (NERR_BASE+365) /* The server has reached the maximum number of connections it supports. */
#define NERR_TooManyFiles	(NERR_BASE+366) /* The server cannot open more files because it has reached its maximum number. */
#define NERR_NoAlternateServers (NERR_BASE+367) /* There are no alternate servers registered on this server. */
/* UNUSED BASE+368 */
/* UNUSED BASE+369 */

/*
 *  UPS error codes.
 *
 *	    NERR_BASE + (380-384)
 */
#define NERR_UPSDriverNotStarted    (NERR_BASE+380) /* The UPS driver could not be accessed by the UPS service. */
/* UNUSED BASE+381 */
/* UNUSED BASE+382 */
/* UNUSED BASE+383 */
/* UNUSED BASE+384 */

/*
 *  Remoteboot error codes.
 *
 *          NERR_BASE + (400-419)
 *          Error codes 400 - 405 are used by RPLBOOT.SYS.
 *          Error codes 403, 407 - 416 are used by RPLLOADR.COM,
 *          Error code 417 is the alerter message of REMOTEBOOT (RPLSERVR.EXE).
 *          Error code 418 is for when REMOTEBOOT can't start
 *          Error code 419 is for a disallowed 2nd rpl connection
 */
#define NERR_BadDosRetCode      (NERR_BASE+400) /* The program below returned an MS-DOS error code:*/
#define NERR_ProgNeedsExtraMem  (NERR_BASE+401) /* The program below needs more memory:*/
#define NERR_BadDosFunction     (NERR_BASE+402) /* The program below called an unsupported MS-DOS function:*/
#define NERR_RemoteBootFailed   (NERR_BASE+403) /* The workstation failed to boot.*/
#define NERR_BadFileCheckSum    (NERR_BASE+404) /* The file below is corrupt.*/
#define NERR_NoRplBootSystem    (NERR_BASE+405) /* No loader is specified in the boot-block definition file.*/
#define NERR_RplLoadrNetBiosErr (NERR_BASE+406) /* NetBIOS returned an error: The NCB and SMB are dumped above.*/
#define NERR_RplLoadrDiskErr    (NERR_BASE+407) /* A disk I/O error occurred.*/
#define NERR_ImageParamErr      (NERR_BASE+408) /* Image parameter substitution failed.*/
#define NERR_TooManyImageParams (NERR_BASE+409) /* Too many image parameters cross disk sector boundaries.*/
#define NERR_NonDosFloppyUsed   (NERR_BASE+410) /* The image was not generated from an MS-DOS diskette formatted with /S.*/
#define NERR_RplBootRestart     (NERR_BASE+411) /* Remote boot will be restarted later.*/
#define NERR_RplSrvrCallFailed  (NERR_BASE+412) /* The call to the Remoteboot server failed.*/
#define NERR_CantConnectRplSrvr (NERR_BASE+413) /* Cannot connect to the Remoteboot server.*/
#define NERR_CantOpenImageFile  (NERR_BASE+414) /* Cannot open image file on the Remoteboot server.*/
#define NERR_CallingRplSrvr     (NERR_BASE+415) /* Connecting to the Remoteboot server...*/
#define NERR_StartingRplBoot    (NERR_BASE+416) /* Connecting to the Remoteboot server...*/
#define NERR_RplBootServiceTerm (NERR_BASE+417) /* Remote boot service was stopped; check the error log for the cause of the problem.*/
#define NERR_RplBootStartFailed (NERR_BASE+418) /* Remote boot startup failed; check the error log for the cause of the problem.*/
#define NERR_RPL_CONNECTED	(NERR_BASE+419)	/* A second connection to a Remoteboot resource is not allowed.*/

/*
 *  FTADMIN API error codes
 *
 *       NERR_BASE + (425-434)
 *
 */
#define NERR_FTNotInstalled     (NERR_BASE+425) /* DISKFT.SYS is not installed. */
#define NERR_FTMONITNotRunning  (NERR_BASE+426) /* FTMONIT is not running */
#define NERR_FTDiskNotLocked    (NERR_BASE+427) /* FTADMIN has not locked the disk. */
#define NERR_FTDiskNotAvailable (NERR_BASE+428) /* Some other process has locked the disk. */
#define NERR_FTUnableToStart    (NERR_BASE+429) /* The verifier/correcter cannot be started. */
#define NERR_FTNotInProgress    (NERR_BASE+430) /* The verifier/correcter can't be aborted because it isn't started. */
#define NERR_FTUnableToAbort    (NERR_BASE+431) /* The verifier/correcter can't be aborted. */
#define NERR_FTUnabletoChange   (NERR_BASE+432) /* The disk could not be locked/unlocked. */
#define NERR_FTInvalidErrHandle (NERR_BASE+433) /* The error handle was not recognized. */
#define NERR_FTDriveNotMirrored (NERR_BASE+434) /* The drive is not mirrored. */


#define MAX_NERR		(NERR_BASE+899) /* This is the last error in NERR range. */

/*
 * end of list
 *
 *    WARNING:  Do not exceed MAX_NERR; values above this are used by
 *		other error code ranges (errlog.h, service.h, apperr.h).
 */


#endif /* NETERR_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\use.h ===
/********************************************************************/

/**                     Microsoft LAN Manager                      **/

/** Copyright (c) 1987-2001 Microsoft Corporation, All Rights Reserved **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  USE.H					    *
 *								    *
 *  This file contains information about the NetUse APIs.	    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 ********************************************************************/

#ifndef NETUSE_INCLUDED

#define NETUSE_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetUseAdd ( const char far * pszServer,
              short            sLevel,
              const char far * pbBuffer,
              unsigned short   cbBuffer );

extern API_FUNCTION
  NetUseDel ( const char far * pszServer,
              const char far * pszDeviceName,
              unsigned short   usForce );

extern API_FUNCTION
  NetUseEnum ( const char far *     pszServer,
               short                sLevel,
               char far *           pbBuffer,
               unsigned short       cbBuffer,
               unsigned short far * pcEntriesRead,
               unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetUseGetInfo ( const char far *     pszServer,
                  const char far *     pszUseName,
                  short                sLevel,
                  char far *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short far * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates			*
 *								*
 ****************************************************************/


struct use_info_0 {
    char	   ui0_local[DEVLEN+1];
    char	   ui0_pad_1;
    char far *	   ui0_remote;
};	/* use_info_0 */

struct use_info_1 {
    char	   ui1_local[DEVLEN+1];
    char	   ui1_pad_1;
    char far *	   ui1_remote;
    char far *	   ui1_password;
    unsigned short ui1_status;
    short 	   ui1_asg_type;
    unsigned short ui1_refcount;
    unsigned short ui1_usecount;
};	/* use_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants			*
 *								*
 ****************************************************************/


/*
 *  	Definitions for NetUseDel's last parameter
 */

#define USE_NOFORCE         	0
#define USE_FORCE           	1
#define USE_LOTS_OF_FORCE   	2


/*
 *	Values appearing in the ui1_status field of use_info_1 structure.
 *	Note that USE_SESSLOST and USE_DISCONN are synonyms.
 */

#define USE_OK			0
#define USE_PAUSED		1
#define USE_SESSLOST		2
#define USE_DISCONN		2
#define USE_NETERR		3
#define	USE_CONN		4
#define USE_RECONN		5


/*
 *	Values of the ui1_asg_type field of use_info_1 structure
 */

#define USE_WILDCARD  		-1
#define USE_DISKDEV   		0
#define USE_SPOOLDEV  		1
#define USE_CHARDEV   		2
#define USE_IPC 		3



#endif /* NETUSE_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\shares.h ===
/*****************************************************************/

/**		     Microsoft LAN Manager			**/

/** Copyright (c) 1987-2001 Microsoft Corporation, All Rights Reserved **/
/*****************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  SHARES.H				    *
 *								    *
 *  This file contains information about the NetShare, NetSession,  *
 *  NetFile, and NetConnection APIs.  For each API class there is   *
 *  a section on:						    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 *	   This file is always included by LAN.H.		    *
 *								    *
 ********************************************************************/


/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

#if (defined( INCL_NETSHARE ) || !defined( LAN_INCLUDED )) \
    && !defined( NETSHARE_INCLUDED )

#define NETSHARE_INCLUDED

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetShareAdd ( const char far * pszServer,
                short            sLevel,
                const char far * pbBuffer,
                unsigned short   cbBuffer );

extern API_FUNCTION
  NetShareCheck ( const char far *     pszServer,
                  const char far *     pszDeviceName,
                  unsigned short far * pusType );

extern API_FUNCTION
  NetShareDel ( const char far * pszServer,
                const char far * pszNetName,
                unsigned short   usReserved );

extern API_FUNCTION
  NetShareEnum ( const char far *     pszServer,
                 short                sLevel,
                 char far *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short far * pcEntriesRead,
                 unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetShareGetInfo ( const char far *     pszServer,
                    const char far *     pszNetName,
                    short                sLevel,
                    char far *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetShareSetInfo ( const char far * pszServer,
                    const char far * pszNetName,
                    short            sLevel,
                    const char far * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *								*
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char far *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char far *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char far *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types (shi1_type and shi2_type fields).
 */

#define STYPE_DISKTREE 			0
#define STYPE_PRINTQ   			1
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1

#endif /* NETSHARE_INCLUDED */


/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

#if (defined( INCL_NETSESSION ) || !defined( LAN_INCLUDED )) \
    && !defined( NETSESSION_INCLUDED )

#define NETSESSION_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSessionDel ( const char far * pszServer,
                  const char far * pszClientName,
                  short            sReserved );

extern API_FUNCTION
  NetSessionEnum ( const char far *     pszServer,
                   short                sLevel,
                   char far *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short far * pcEntriesRead,
                   unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetSessionGetInfo ( const char far *     pszServer,
                      const char far *     pszClientName,
                      short                sLevel,
                      char far *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short far * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char far *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char far *		sesi1_cname;
    char far *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char far *		 sesi2_cname;
    char far *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char far *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char far *     sesi10_cname;
        char far *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */





/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9

#endif /* NETSESSION_INCLUDED */


/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

#if (defined( INCL_NETCONNECTION ) || !defined( LAN_INCLUDED )) \
    && !defined( NETCONNECTION_INCLUDED )

#define NETCONNECTION_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetConnectionEnum ( const char far *     pszServer,
                      const char far *     pszQualifier,
                      short                sLevel,
                      char far *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short far * pcEntriesRead,
                      unsigned short far * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char far *		coni1_username;
    char far *		coni1_netname;
};  /* connection_info_1 */

#endif /* NETCONNECTION_INCLUDED */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/

#if (defined( INCL_NETFILE ) || !defined( LAN_INCLUDED )) \
    && !defined( NETFILE_INCLUDED )

#define NETFILE_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetFileClose ( const char far * pszServer,
                 unsigned short   usFileId );

extern API_FUNCTION
  NetFileClose2 ( const char far * pszServer,
                  unsigned long    ulFileId );

extern API_FUNCTION
  NetFileEnum ( const char far *     pszServer,
                const char far *     pszBasePath,
                short                sLevel,
                char far *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short far * pcEntriesRead,
                unsigned short far * pcTotalAvail );

extern API_FUNCTION
  NetFileEnum2 ( const char far *     pszServer,
                 const char far *     pszBasePath,
                 const char far *     pszUserName,
                 short                sLevel,
                 char far *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short far * pcEntriesRead,
                 unsigned short far * pcEntriesRemaining,
                 void far *           pResumeKey );

extern API_FUNCTION
  NetFileGetInfo ( const char far *     pszServer,
                   unsigned short       usFileId,
                   short                sLevel,
                   char far *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetFileGetInfo2 ( const char far *     pszServer,
                    unsigned long        ulFileId,
                    short                sLevel,
                    char far *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short far * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char far *		fi1_pathname;
    char far *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char far *		fi3_pathname;
    char far *		fi3_username;
};  /* file_info_3 */


struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}


#endif /* NETFILE_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\vmm.h ===
/****************************************************************************

*                                                                           *

* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *

* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *

* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *

* PURPOSE.                                                                  *

*                                                                           *

* Copyright (c) 1993-2001 Microsoft Corporation, All Rights Reserved
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:   1.00
 *
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.  Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE       0       // False
#define VMM_TRUE    (~FALSE)    // The opposite of False!

#define DEBLEVELRETAIL  0
#define DEBLEVELNORMAL  1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef  NEWSTRUCTS      ; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *          EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID       0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID       0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID       0x0000A
#define VSD_DEVICE_ID       0x0000B
#define VMD_DEVICE_ID       0x0000C
#define VKD_DEVICE_ID       0x0000D
#define VCD_DEVICE_ID       0x0000E
#define VPD_DEVICE_ID       0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID       0x0001B
#define VDD2_DEVICE_ID      0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID      0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID       0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID      0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID        0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID         0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID       0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID      0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID   0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS     */
/* #define VNB_DEVICE_ID           0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID        0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID      */

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID      0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID       0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F  /* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID       0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID      0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */

#define AWREDIR_DEVICE_ID   0x00049 /* AtWork Network FSD */

/*
 *   Far East DOS support VxD ID
 */

#define ETEN_Device_ID      0x00060 /* ETEN DOS (Taiwan) driver */
#define CHBIOS_Device_ID    0x00061 /* CHBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */
#define VIME_Device_ID      0x00064 /* Virtual DOS IME */
#define VHBIOSD_Device_ID   0x00065 /* HBIOS (Korean) for HWin31 driver */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */ 
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.  Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER      0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER     0x000000000 /*  but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER          0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER      0x014000000
#define VXDLDR_INIT_ORDER   0x016000000

#define ENUMERATOR_INIT_ORDER   0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER      ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define CONFIGMG_INIT_ORDER ENUMERATOR_INIT_ORDER+0xFFFF    /* After all enumerators */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER      0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER      0x028000000
#define VSD_INIT_ORDER      0x02C000000

#define VCD_INIT_ORDER      0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER      0x034000000
#define VKD_INIT_ORDER      0x038000000
#define VPD_INIT_ORDER      0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER   0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER    0x080000000
#define WIN32_INIT_ORDER    UNDEFINED_INIT_ORDER
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order      0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER      0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;          /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;           /* Client's EDI */
    ULONG Pushad_ESI;           /* Client's ESI */
    ULONG Pushad_EBP;           /* Client's EBP */
    ULONG Pushad_ESP;           /* ESP before pushad */
    ULONG Pushad_EBX;           /* Client's EBX */
    ULONG Pushad_EDX;           /* Client's EDX */
    ULONG Pushad_ECX;           /* Client's ECX */
    ULONG Pushad_EAX;           /* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)  // turn off redefinition warning

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;

#pragma warning (default:4209)  // turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)   __##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG       code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG       data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG   code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG   data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DBOCODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DBODATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG    code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG   code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG  code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG   code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG  code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG  code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG   code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG   code_seg("LOCKABLE", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =   1
??_ICODE    =   2
??_PCODE    =   3
??_SCODE    =   4
??_DBOCODE  =   5
??_16ICODE  =   6
??_RCODE    =   7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE  equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF   MASM6
_FLAT   EQU FLAT
ELSE
_FLAT   EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT      ENDS

_TEXT       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT       ENDS

;*  32 bit pageable code
_PTEXT      SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT      ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB    <classname>
    segname     SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname     SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
        ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB    <grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM                ;; End for each segment

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***    DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***    DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***    CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
        extrn   name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***    MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***    MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or  ??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT      ENDS

;*  32 bit locked data
_LDATA      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA      ENDS

_DATA       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA       ENDS

;*  32 bit pageable data
_PDATA      SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA      ENDS

;*  32 Bit initialization data
_IDATA      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA      ENDS

;*  Created by C8
_BSS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS        ENDS

CONST       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST       ENDS

_TLS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS        ENDS

;*  32 Bit static code for DL-VxDs
_STEXT      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT      ENDS

;*  32 Bit static data for DL-VxDs
_SDATA      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA      ENDS

;*      dummy segment for IsDebugOnlyLoaded
_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS

;*      32 bit debug only code; loaded only if debugger is present
_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS

;*      32 bit debug only data; loaded only if debugger is present
_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL
;*	Start of 32 bit path coverage data
_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS

;*	32 bit path coverage data
_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS

;*	End of 32 bit path coverage data
_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE      SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE      ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP	  GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;       . . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1           ; Only in module where table is
;   INCLUDE     VxD.INC         ; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF   Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID    = 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName  Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName   MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table

Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&Procedure

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
    EXTRN   Procedure:NEAR
      ELSE
    dd  OFFSET32 Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
        IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
        ENDIF
        IFNB <Condition>
    $$&&Procedure extern
       ELSE
    EXTRN   Procedure:NEAR
        ENDIF
        IFNB <Local_Seg>
Local_Seg&&_ENDS
        ELSE
Def_Segment&_CODE_ENDS
        ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
    dd  OFFSET32 Procedure
      ENDIF

          IFDEF Device_Name&_Name_Based
        @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
          ELSE
        @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
          ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF   Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ENDIF

ENDIF

    ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal    macro   reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress    macro   reg,service
    mov reg,OFFSET32 service
    endm


;***    Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.  If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName     - the name of the VxD; it is assumed
;                 that a corresponding Device_ID is
;                 also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;       accepts a service name as its only parameter.
;       This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd  csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
        .erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
        dd  OFFSET32 Name,cparm&&Name
    endif
        @32&&Name equ   ((VxDName&_Device_ID SHL 16) + ??w32svcno)
        ??w32svcno = ??w32svcno + 1
        ENDM
    ENDM


;***    End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName     - the same name passed to
;                 Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***    Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name        - the service name
;       cParms      - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***    Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service     - the name of the service
;       CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)   service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp  VxDJmp

#define SERVICE     __cdecl
#define ASYNC_SERVICE   __cdecl
#define WIN32_SERVICE   void __stdcall
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
        ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status;         /* VM status flags */
    ULONG CB_High_Linear;       /* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56      /* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT    0x00    /* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE        (1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT   0x01    /* VM runs in background */
#define VMSTAT_BACKGROUND       (1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING         (1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT    0x03    /* VM not scheduled */
#define VMSTAT_SUSPENDED        (1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE  (1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC          (1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP           (1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32         (1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC         (1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09   /* High pri background */
#define VMSTAT_HIGH_PRI_BACK    (1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED          (1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT    0x0B    /* Woke up after blocked */
#define VMSTAT_AWAKENING        (1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT   0x0C    /* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT  VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86      (1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D    /* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED    (1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E    /* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT     (1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT         0x0F    /* VM has released time slice */
#define VMSTAT_IDLE             (1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING          (1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11    /* VM suspended by */
#define VMSTAT_TS_SUSPENDED     (1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT    0x12    /* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI        (1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;          /* Thread status flags */
    ULONG   TCB_Reserved1;      /* Used internally by VMM */
    ULONG   TCB_Reserved2;      /* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;      /* Client registers of thread */
    ULONG   TCB_VMHandle;       /* VM that thread is part of */
    USHORT  TCB_ThreadId;       /* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;       /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;      /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;     /* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;           /* reusable; for dword align */
    UCHAR   TCB_pad2;           /* reusable; for dword align */
    UCHAR   TCB_extErrLocus;        /* extended error Locus */
    USHORT  TCB_extErr;         /* extended error Code */
    UCHAR   TCB_extErrAction;       /*      "   "   Action */
    UCHAR   TCB_extErrClass;        /*      "   "   Class */
    ULONG   TCB_extErrPtr;      /*      "   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD         0x42434854    // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT        0x03   // Thread not scheduled
#define THFLAG_SUSPENDED                   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE             (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION             (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED              (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_RING0_THREAD_BIT     0x1C   // thread runs only at ring 0
#define THFLAG_RING0_THREAD	           (1L << THFLAG_RING0_THREAD_BIT)
#define THFLAG_CHARSET_BITS     0x10   // Default character set
#define THFLAG_CHARSET_MASK        (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI            (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM             (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE             (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED            (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES            (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.  
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13   // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE            (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;             // faulting EIP
    WORD  VMFI_CS;              // faulting CS
    WORD  VMFI_Ints;            // interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *              V M M   S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)    // MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define HEAPZEROINIT    0x00000001
#define HEAPZEROREINIT  0x00000002
#define HEAPNOCOPY  0x00000004
#define HEAPLOCKEDIFDP  0x00000100
#define HEAPSWAP    0x00000200
#define HEAPINIT        0x00000400
#define HEAPCLEAN   0x00000800

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT        0x00000001
#define PAGEUSEALIGN        0x00000002
#define PAGECONTIG      0x00000004
#define PAGEFIXED       0x00000008
#define PAGEDEBUGNULFAULT   0x00000010
#define PAGEZEROREINIT      0x00000020
#define PAGENOCOPY      0x00000040
#define PAGELOCKED      0x00000080
#define PAGELOCKEDIFDP      0x00000100
#define PAGESETV86PAGEABLE  0x00000200
#define PAGECLEARV86PAGEABLE    0x00000400
#define PAGESETV86INTSLOCKED    0x00000800
#define PAGECLEARV86INTSLOCKED  0x00001000
#define PAGEMARKPAGEOUT     0x00002000
#define PAGEPDPSETBASE      0x00004000
#define PAGEPDPCLEARBASE    0x00008000
#define PAGEDISCARD     0x00010000
#define PAGEPDPQUERYDIRTY   0x00020000
#define PAGEMAPFREEPHYSREG  0x00040000
#define PAGENOMOVE      0x10000000
#define PAGEMAPGLOBAL       0x40000000
#define PAGEMARKDIRTY       0x80000000

/****************************************************
 *
 *      Flags for _PhysIntoV86,
 *      _MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP       0x00000001


// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL  0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE   0x00000002
#define MMGRHMADISABLE  0x00000004
#define MMGRHMAQUERY    0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT        0
#define LF_ASYNC        (1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP     (1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR      (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP         (LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area, VMM_ICODE)
VMM_Service (_Free_Temp_V86_Data_Area, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign       0x00000001
#define GVDADWordAlign      0x00000002
#define GVDAParaAlign       0x00000004
#define GVDAPageAlign       0x00000008
#define GVDAInstance        0x00000100
#define GVDAZeroInit        0x00000200
#define GVDAReclaim	    0x00000400
#define GVDAInquire	    0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE       260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT  0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT   0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT    0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT   0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT  0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (Set_System_Exit_Code)

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *          D E B U G G I N G   E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)      // Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)       // for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz  @@Test_DBCS_Lead_Byte - 100D1h   ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
#define AFPP_SWAPOUT     0x0001 // physical memory that must be swapped out
                                // and subsequently restored at system exit
/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY      0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS    0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001  /* Privledged instruction */
#define GSDVME_INVALINST    0x00010002  /* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003  /* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004  /* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005  /* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006  /* User requested NUKE of VM */
#define GSDVME_DEVNUKE      0x00010007  /* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008  /* Device specific problem:
                         *   invalid hardware fiddling
                         *   by VM (invalid I/O)
                         */
#define GSDVME_NUKENOMSG    0x00010009  /* Supress standard messages:
                         *   SHELL_Message used for
                         *   custom msg.
                         */
#define GSDVME_OKNUKEMASK   0x80000000  /* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001  /* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002  /* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003  /* XMS Kb Req      - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004  /* EMS Kb Req      - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005  /* Hi DOS V86 mem   - DOSMGR
                         *           V86MMGR
                         */
#define GSDVME_INSMEMVID    0x00020006  /* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007  /* Base VM mem     - VMM
                         *   CB, Inst Buffer
                         */
#define GSDVME_INSMEMDEV    0x00020008  /* Couldn't alloc base VM
                         * memory for device.
                         */
#define GSDVME_CRTNOMSG     0x00020009  /* Supress standard messages:
                         *   SHELL_Message used for
                         *   custom msg.
                         */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001  /* Page directory entry not-present */
#define IPF_V86PG   0x00000002  /* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004  /* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008  /* page has invalid not present type */
#define IPF_PGERR   0x00000010  /* pageswap device failure */
#define IPF_REFLT   0x00000020  /* re-entrant page fault */
#define IPF_VMM     0x00000040  /* Page fault caused by a VxD */
#define IPF_PM      0x00000080  /* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100  /* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (Set_Delete_On_Exit_File)

VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT   0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)      // Debugging only
VMM_Service (Disable_Touch_1st_Meg)     // Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz   @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT         0
#define DFS_LOG             (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT         1
#define DFS_PROFILE         (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT        2
#define DFS_TEST_CLD            (1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT       3
#define DFS_NEVER_REENTER       (1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT        4
#define DFS_TEST_REENTER        (1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT        5
#define DFS_NOT_SWAPPING        (1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT      6
#define DFS_TEST_BLOCK          (1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES	0xFFFFFF80

#define DFS_EXIT_NOBLOCK        (DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK       (DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC	(DFS_RARE_SERVICES+1)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service (Test_VM_Ints_Enabled)
VMM_Service (_BlockOnID)

VMM_Service (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define	MUTEX_MUST_COMPLETE		1L
#define	MUTEX_NO_CLEANUP_THREAD_STATE	2L

/*MACROS*/
VMM_Service (_CreateMutex)

VMM_Service (_DestroyMutex)
VMM_Service (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service (VMMCreateThread)
VMM_Service (_GetThreadExecTime)
VMM_Service (VMMTerminateThread)

VMM_Service (Get_Cur_Thread_Handle)
VMM_Service (Test_Cur_Thread_Handle)
VMM_Service (Get_Sys_Thread_Handle)
VMM_Service (Test_Sys_Thread_Handle)
VMM_Service (Validate_Thread_Handle)
VMM_Service (Get_Initial_Thread_Handle)
VMM_Service (Test_Initial_Thread_Handle)
VMM_Service (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service (Cancel_Call_When_Thread_Switched)
VMM_Service (Get_Next_Thread_Handle)
VMM_Service (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service (_EnterMutex)
VMM_Service (_LeaveMutex)
VMM_Service (Simulate_VM_IO)
VMM_Service (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service (_EnterMustComplete)
VMM_Service (_LeaveMustComplete)
VMM_Service (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND       1L
#define THREAD_TERM_STATUS_NUKE_PEND        2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service (_GetThreadTerminationStatus)
VMM_Service (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE   0       /* no data instanced in range */
#define INSTINFO_SOME   1       /* some data instanced in range */
#define INSTINFO_ALL    2       /* all data instanced in range */

/*MACROS*/
VMM_Service (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service (Call_Priority_Thread_Event)
VMM_Service (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ      // define only if not there already

#define REG_SZ      0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT       0x80000000
#define HKEY_CURRENT_USER       0x80000001
#define HKEY_LOCAL_MACHINE      0x80000002
#define HKEY_USERS          	0x80000003
#define HKEY_PERFORMANCE_DATA   0x80000004
#define HKEY_CURRENT_CONFIG     0x80000005
#define HKEY_DYN_DATA       	0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service (_LocalizeSprintf)
VMM_Service (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE   0       /* no pages in the specified range exist */
#define PHYSINFO_SOME   1       /* some pages in the specified range exist */
#define PHYSINFO_ALL    2       /* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service (Time_Slice_Sys_VM_Idle)
VMM_Service (Time_Slice_Sleep)
VMM_Service (Boost_With_Decay)
VMM_Service (Set_Inversion_Pri)
VMM_Service (Reset_Inversion_Pri)
VMM_Service (Release_Inversion_Pri)
VMM_Service (Get_Thread_Win32_Pri)
VMM_Service (Set_Thread_Win32_Pri)
VMM_Service (Set_Thread_Static_Boost)
VMM_Service (Set_VM_Static_Boost)
VMM_Service (Release_Inversion_Pri_ID)
VMM_Service (Attach_Thread_To_Group)
VMM_Service (Detach_Thread_From_Group)
VMM_Service (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM    0
#define REGTYPE_CLASS   1
#define REGTYPE_VXD     2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN                 0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD   0x00000000
#define ASSERT_RANGE_NULL_OK    0x00000001
#define ASSERT_RANGE_NO_DEBUG   0x80000000
#define ASSERT_RANGE_BITS       0x80000001

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQueryMultipleValues)

// Additional timeslicer services
VMM_Service (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN              0x00000001
#define BOOT_DOSCLEAN           0x00000002
#define BOOT_NETCLEAN           0x00000004
#define BOOT_INTERACTIVE        0x00000008

/*MACROS*/
VMM_Service (Get_Boot_Flags)
VMM_Service (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service (_AddReclaimableItem)
VMM_Service (_SetReclaimableItem)
VMM_Service (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service (Time_Slice_Wake_Sys_VM)
VMM_Service (VMM_Replace_Global_Environment)
VMM_Service (Begin_Non_Serial_Nest_V86_Exec)
VMM_Service (Get_Nest_Exec_Status)
/*ENDMACROS*/

// Bootlogging services

/*MACROS*/
VMM_Service (Open_Boot_Log)
VMM_Service (Write_Boot_Log)
VMM_Service (Close_Boot_Log)
VMM_Service (EnableDisable_Boot_Log)
VMM_Service (_Call_On_My_Stack)
/*ENDMACROS*/

// Another instance data service

/*MACROS*/
VMM_Service (Get_Inst_V86_Int_Vec_Base)
/*ENDMACROS*/

// Case insensitive functions -- SEE WARNINGS IN DOCS BEFORE USING!
/*MACROS*/
VMM_Service (_lstrcmpi)
VMM_Service (_strupr)
/*ENDMACROS*/

/*MACROS*/
VMM_Service (Log_Fault_Call_Out)
VMM_Service (_AtEventTime)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)          // turn on not enough params warning
/*XLATON*/

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM              0x00000001
#define RS_RESTORE              0x00000002
#define RS_DOSARENA             0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;                  // low (< 1meg) address of item
    ULONG   RS_Bytes;                   // size of item in bytes
    ULONG   RS_CallBack;                // callback, if any (zero if none)
    ULONG   RS_RefData;                 // reference data for callback, if any
    ULONG   RS_HookTable;               // real-mode hook table (zero if none)
    ULONG   RS_Flags;                   // 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
struct DemandInfoStruc {
    ULONG DILin_Total_Count;    /* # pages in linear address space */
    ULONG DIPhys_Count;         /* Count of phys pages */
    ULONG DIFree_Count;         /* Count of free phys pages */
    ULONG DIUnlock_Count;       /* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;   /* Base of pageable address space */
    ULONG DILin_Total_Free;     /* Total Count of free linear pages */

    /*
     *  The following 5 fields are all running totals, kept from the time
     *  the system was started
     */
    ULONG DIPage_Faults;        /* total page faults */
    ULONG DIPage_Ins;           /* calls to pagers to page in a page */
    ULONG DIPage_Outs;          /* calls to pagers to page out a page*/
    ULONG DIPage_Discards;      /* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;    /* instance page faults */

    ULONG DIPagingFileMax;      /* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;    /* # of pages of paging file currently in use */

    ULONG DICommit_Count;       /* Total committed memory, in pages */

    ULONG DIReserved[2];        /* Reserved for expansion */
};

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;        /* INIT <0> RESERVED */
    ULONG InstLinkB;        /* INIT <0> RESERVED */
    ULONG InstLinAddr;      /* Linear address of start of block */
    ULONG InstSize;         /* Size of block in bytes */
    ULONG InstType;         /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD     0x100   /* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD    0x200   /* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD  0x400   /* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;      /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;        /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400  /* anywhere in private arena */
#define PR_SHARED   0x80060000  /* anywhere in shared arena */
#define PR_SYSTEM   0x80080000  /* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008  /* don't move during PageReAllocate */
#define PR_4MEG     0x00000001  /* allocate on 4mb boundary */
#define PR_STATIC   0x00000010  /* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001  /* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002  /* swappable uninitialized pages */
#define PD_FIXEDZERO    0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004  /* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008  /* pages are permanently locked */
#define PC_LOCKED   0x00000080  /* pages are made present and locked*/
#define PC_LOCKEDIFDP   0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE    0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000  /* make the pages ring 3 accessible */
#define PC_INCR     0x40000000  /* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000  /* make pages initially present */
#define PC_STATIC   0x20000000  /* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000  /* make pages initially dirty */

/* PageCommitContig additional flags */
#define PCC_ZEROINIT    0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000  /* don't map to any linear address */

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *      clean - page has not been written to since its last page out
 *      dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *      virgin - page has never been written to since it was committed
 *      tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *      For 32-bit EXE code or read-only data:
 *
 *        pd_virginin = routine to load page from an exe file
 *        pd_taintedin = 0
 *        pd_cleanout = 0
 *        pd_dirtyout = 0
 *        pd_virginfree = 0
 *	  pd_taintedfree = 0
 *	  pd_dirty = 0
 *        pd_type = PD_PAGERONLY
 *
 *      For 32-bit EXE writeable data:
 *
 *        pd_virginin = routine to load page from an exe file
 *        pd_taintedin = routine to load page from swap file
 *        pd_cleanout = 0
 *        pd_dirtyout = routine to write a page out to the swap file
 *        pd_virginfree = 0
 *        pd_taintedfree = routine to free page from the swap file
 *        pd_dirty = routine to free page from the swap file
 *        pd_type = PD_SWAPPER
 *
 *      For zero-initialized swappable data:
 *
 *        pd_virginin = routine to zero-fill a page
 *        pd_taintedin = routine to load page from swap file
 *        pd_cleanout = 0
 *        pd_dirtyout = routine to write a page out to the swap file
 *        pd_virginfree = 0
 *        pd_taintedfree = routine to free page from the swap file
 *        pd_dirty = routine to free page from the swap file
 *        pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *  The following four fields are entry points in the pager which
     *  we call to page in or page out a page.  The following parameters
     *  are passed to the pager during these calls:
     *
     *  ppagerdata - pointer to the pager-specific dword of data
     *           stored with the virtual page.  The pager is
     *           free to modify the contents of this dword
     *           DURING the page in or out, but not afterwards.
     *
     *  ppage - pointer to page going in or out (a ring 0 alias
     *      to the physical page).  The pager should use this
     *      address to access the contents of the page.
     *
     *  faultpage - faulting linear page number for page-ins, -1 for
     *          page-outs.  This address should not be accessed
     *          by the pager.  It is provided for information
     *          only.  Note that a single page can be mapped at
     *          more than one linear address because of the
     *          MapIntoV86 and LinMapIntoV86 services.
     *
     *  The pager should return non-0 if the page was successfully
     *  paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *  The pd_*free routines are used to inform the pager when the last
     *  reference to a virtual page controlled by the pager is
     *  decommitted.  A common use of this notification is to
     *  free space in a backing file, or write the page contents
     *  into the backing file.
     *
     *  These calls take the same parameters as the page-out and -in
     *  functions, but no return value is recognized.  The "ppage"
     *  and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *  The pd_dirty routine is used to inform the pager when the
     *  memory manager detects that a page has been written to.  The memory
     *  manager does not detect the write at the instant it occurs, so
     *  the pager should not depend upon prompt notification.  A common
     *  use of this notification might be to invalidate cached data.
     *  If the page was dirtied in more than one memory context,
     *  the pager's pd_dirty routine will be called once for each
     *  context.
     *
     *  These calls take the same parameters as the page-out and -in
     *  functions except that the "ppage" parameter isn't valid and
     *  no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *  The pd_type field gives the sytem information about the
     *  overcommit characteristics of pages controlled by this pager.
     *  The following are allowable values for the field:
     *
     *  PD_SWAPPER - under some conditions, pages of this type
     *		may be paged out into the swap file
     *  PD_PAGERONLY - pages controlled by this pager will never
     *		be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *		functions perform nested excecution or block using the
     *		BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *		specified if the pager does any sort of file i/o to anything
     *		other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER	0   /* pages need direct accounting in swap file */
#define PD_PAGERONLY    1   /* pages will never be swapped */
#define PD_NESTEXEC	2   /* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR      ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR      ((ULONG) 0xc0000000)    /* 3 gig */
#define MAXSHAREDLADDR      ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR      ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR     ((ULONG) 0x003fffff)
#define MINDOSLADDR     ((ULONG) 0x00000000)

#define MAXSYSTEMPAGE       (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE       (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE       (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE       (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE      (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE      (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE      (MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE      (MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE       (1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED        (1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM        (1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS           (1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE      (1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED       (1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM       (1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS          (1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC      (max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC     (max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar  EQU NEAR PTR
ELSE
DebFar  EQU SHORT
ENDIF
*/

#ifndef Not_VxD

/******************************************************************************
 *
 *           EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.  Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000      /* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT     0x0001      /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.  Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE       0x0002      /* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT     0x0003      /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */   
#define SYS_VM_TERMINATE    0x0004      /* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT     0x0005      /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.  SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006      /* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM       0x0007

/*
 *  Second phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT         0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE        0x000A      /* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B      /* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.  EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM      0x000C      /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00        /* VM was crashed */
#define VNE_CRASHED     (1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT       0x01        /* VM was destroyed while active */
#define VNE_NUKED       (1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02        /* Some device failed Create_VM */
#define VNE_CREATEFAIL      (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03        /* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL      (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04        /* Some device failed VM_Init */
#define VNE_INITFAIL        (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT      0x05
#define VNE_CLOSED      (1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND      0x000D      /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME       0x000E      /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.  Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012      /* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY       0x0013      /* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY     0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP        0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT      0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP      0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY    0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *        CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT     0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD  0x001D

/*
 *  Second phase of creating a thread.  EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT    0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 * BUGBUG: need more doc here, describing the interface
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN       DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2        0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2       0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2     0x0029
#define VM_SUSPEND2     0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2     0x002C
#define DEVICE_REBOOT_NOTIFY2   0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER  0x0030

#define KERNEL32_INITIALIZED    0x0031

#define KERNEL32_SHUTDOWN       0x0032

#define MAX_SYSTEM_CONTROL  0x0032

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL	0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

                    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
                    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT      0x10000000
                    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
                    /* INIT_COMPLETE is broadcast */
                    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
                    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
                    /* All initialization completed */
                    /* System running normally */
                    /* System shutdown initiated */
                    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
                    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
                    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT      0xE0000000
                    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
                    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
                    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
                    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
                    /* Return to real mode */
                    /* Alternate path: CAD reboot */
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
                    /* DEVICE_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PRECRITREBOOT      0xFFFFF000
                    /* CRIT_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PREREBOOTCPU       0xFFFFFF00
                    /* REBOOT_PROCESSOR is broadcast */
                    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC              ; Used outside this module (default)
;   LOCAL               ; Local to this module
;   HIGH_FREQ           ; DWORD align procedure
;   SERVICE             ; Routine is called via VxDCall
;   ASYNC_SERVICE           ; Same as "SERVICE" plus routine can
;                   ;   be called under interrupt.
;   HOOK_PROC           ; Proc is a handler installed with
;                   ;   with a call to Hook_xxx_Fault
;                   ;   or Hook_Device_Service.  The
;                   ;   following parameter must be
;                   ;   the label of a DWORD location
;                   ;   which will hold the ptr to next
;                   ;   hook proc. e.g.
;
;                  ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG              ; Disable Queue_Out call logging
;   NO_PROFILE          ; Disable DynaLink profile counts
;   NO_TEST_CLD         ; Disable direction flag check
;
;   TEST_BLOCK          ; Trap if in NOBLOCK state
;                   ;  (default if in pageable code seg)
;   TEST_REENTER            ; Trap if Get_VMM_Reenter_Count != 0
;                   ;  (default for non-async services)
;   NEVER_REENTER           ; Trap if VMM has been reentered
;   NOT_SWAPPING            ; Trap if this thread is swapping
;
;   NO_PROLOG           ; Disable all prolog tests
;
;   ESP             ; Use ESP instead of EBP for stack
;                   ;  frame base
;   PCALL               ; pascal calling convention
;   SCALL               ; stdcall calling convention
;   CCALL               ; "C" calling convention
;   ICALL               ; default calling convention
;   W32SVC              ; Win32 service
;
;   segment type            ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type            ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1       ;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed  equ 2       ;; ArgVars were used
??_pf_Entered   equ 4       ;; EnterProc performed
??_pf_Left  equ 8       ;; LeaveProc performed
??_pf_Returned  equ    16               ;; Return performed

??_pushed       =       0               ;; For WIN31COMPAT
??_align    =   0       ;; For WIN31COMPAT
??_ends     equ <>      ;; BeginProc segment

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0            ;; local frame base
    ??_aframe = 0           ;; argument frame base
    ??_initaframe = 0       ;; initial aframe value
    ??_numargs = 0          ;; number of argvars
    ??_numlocals = 0        ;; number of localvars
    ??_numlocalsymbols = 0      ;; number of local symbols
    ??_procflags = 0        ;; misc. Enter/LeaveProc flags
    ??_esp = 0          ;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0           ;; number of bytes pushed
    ??_align = 0            ;; set if proc should be dword aligned
    ??_hook = 0         ;; set if proc is a Hook_Proc
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG        ;; logging on by default
    ??_profile = DFS_PROFILE    ;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD  ;; test that direction is clear
ELSE
    ??_log = 0          ;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE    ;; service profiling on by default
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
    ??_test_cld = 0         ;; test that direction is clear
ENDIF
    ??_might_block = 0      ;; entering fn might cause VM to block
    ??_test_reenter = 0     ;; don't test for VMM reentry
    ??_never_reenter = 0        ;; don't test for genuine VMM reentry
    ??_not_swapping = 0     ;; don't test that we're not swapping
    ??_prolog_disabled = 0      ;; use a prolog by default
    ??_public = 1           ;; everything's public by default
    ??_cleanoff = 0         ;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0          ;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
        if ??_hookarg
        ??_hookarg = 0
        ??_hookvar equ <arg>
        elseifdef ?&&arg&&_BeginProc
            ?&&arg&&_BeginProc
        elseifdef VxD_&&arg&&_CODE_SEG
        ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
        VxD_&&arg&&_CODE_SEG
        else
        .err <Bad param "&arg" to BeginProc>
        endif
    endm

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
	ife ??_service
	    ifndef profileall
	      ??_profile = 0      ;; only services can be profiled
	    endif
	    ifdef VMMSYS
		??_prolog_disabled = 1
	    endif
	else
	    ??_test_cld = DFS_TEST_CLD
	endif       ; ife ??_service

	ife ?_16ICODE
	    ??_prolog_disabled = 1
	else
	ife ?_RCODE             ;; if real-mode code segment
	    ??_prolog_disabled = 1  ;; don't do anything odd
	else                ;; else protected mode code segment
	    ife ?_PCODE     ;; if swappable code
		??_might_block = DFS_TEST_BLOCK
	    endif
	    if ??_service
		ife ??_async_service
		    ??_test_reenter = DFS_TEST_REENTER
		endif
	    endif
    endif       ; ife ?_RCODE
    endif       ; ife ?_16ICODE
    endif	; Not_VxD

    if ??_esp
	;; just return address on stack
	??_basereg equ <esp+??_pushed>
	??_initaframe = 4
    else
	;; ret addr and EBP on stack
	??_basereg equ <ebp>
	??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
         ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
        ??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

	if ??_hook
	    if ??_align
	    Dword_Align
	    endif
	    prelabeldata:
	    ifndef ??_hookvar
	    .err <HOOK_PROC requires next arg to be name of dword location>
	    endif
	    jmp short Name
	    jmp [??_hookvar]
	    ifdef DEBUG
	    Profile_Data dd  0
	    endif
	    if ??_align
	    .errnz ($ - prelabeldata) mod 4
	    endif
	endif

	ifdef DEBUG
	    ?prolog_&Name label near
	    if (??_service OR ??_profile) AND (??_hook EQ 0)
	    jmp short Name
	    if ??_align
		Dword_Align     ; This also aligns the proc
	    endif           ;   since Profile_Data is a dd

	    IF ?_ICODE
	    ifdef profileall
	      ?ProfileHeader_BeginProc Profile_Data, %@filename
	    else
	      Profile_Data dd 0
	    endif
	    ELSE
	      Profile_Data dd 0
	    ENDIF

	    endif
	endif

	if ??_align
	    Dword_Align
	endif

    endif	; Not_VxD

    Name proc near		;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;       Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall    ;; if no munging
        if ??_public
            public Name
        else
            ifdef DEBUG
                % ?merge @FileName,$,Name,:
                % ?merge public,,,,,@FileName,$,Name
            endif
        endif
    endif
    if ??_ccall
        if ??_public
            _&Name equ Name
	    ifdef Not_VxD
		 public C Name
	    else
                 public _&Name
	    endif
        endif
    endif
    if ??_pcall
        if ??_public
            ?toupper Name
            ?merge  public,,,,%?upper
        endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;       DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service
    ifndef Not_VxD
	ifdef DEBUG
	    if ??_dfs EQ DFS_LOG
		VMMCall Log_Proc_Call   ;; no test, just log
	    else
	    if ??_dfs EQ DFS_TEST_REENTER
		VMMCall Test_Reenter    ;; no log, just reenter
	    else
	    if ??_dfs or ?_LOCKABLECODE eq 0
		ifdef WIN31COMPAT
		    if ??_dfs AND DFS_LOG
			VMMCall Log_Proc_Call
		    endif
		    if ??_dfs AND DFS_TEST_REENTER
			VMMCall Test_Reenter
		    endif
		else
		    ife ?_LOCKABLECODE
		    ifdef ??_debug_flags
			push    ??_debug_flags
			if ??_dfs
			pushfd
			or  dword ptr [esp+4],??_dfs
			popfd
			endif
			VMMCall _Debug_Flags_Service
		    elseif ??_dfs
			push    ??_dfs
			VMMCall _Debug_Flags_Service
		    endif
		    else
		    push    ??_dfs
		    VMMCall _Debug_Flags_Service
		    endif
		endif
	    else
	      ifdef profileall
		IncProfileCount
	      endif
	    endif           ;if ??_dfs
	    endif           ; if ??_dfs EQ DFS_TEST_REENTER
	    endif           ; if ??_dfs EQ DFS_LOG
	endif ; DEBUG
    endif ; Not_VxD

    ;; Phase 7:  Post-label code
    ;;       <none>
endm

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
	.erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
	.erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
        inc dword ptr [??_name-4]
    else
        ifndef profileall
        .err <IncProfileCount can be used only in services.>
        endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***    ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;        of the argument.  The symbols BYTE, WORD, and DWORD
;        are synonyms for 1, 2, and 4 respectively.
;        NB!  All arguments sizes are rounded up to the nearest
;        multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;        to indicate that the argument will not be used
;        by the procedure.
;

ArgVar  macro   name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
        ?mkarg  <name>, <length>, <used>, %??_numargs
    else
        ?argvar <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg  macro   name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
        ?argvar <name>, <length>, <used>
        &endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro   name,length,used
    local   a
    ifidni  <length>,<BYTE>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
        ?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
        a = ??_aframe
        ??_aframe =  ??_aframe + ((length + 3)/4)*4
        ?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

;***    ?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
        name equ _inaccessible_NOTUSED_
    else
        name equ value
        ??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***    LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;        of the argument.  The symbols BYTE, WORD, and DWORD
;        are synonyms for 1, 2, and 4 respectively.
;        NB!  All arguments sizes are rounded up to the nearest
;        multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;        to suppress the usual padding and aligning of variables
;        PACK is typically used when declaring a bunch of
;        byte or word variables.  Make sure that the total
;        size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
        ??_pad = 0
    endif
    ifidni  <length>,<BYTE>
        ??_frame = ??_frame + 1 + 3 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
        ??_frame =  ??_frame + 2 + 2 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
        ??_frame = ??_frame + 4
        a = ??_frame
        ?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
        name equ dword ptr [??_basereg-a]
        name&l equ word ptr [??_basereg-a]
        name&ll equ byte ptr [??_basereg-a]
        name&lh equ byte ptr [??_basereg-a+1]
        name&h equ word ptr [??_basereg-a+2]
        name&hl equ byte ptr [??_basereg-a+2]
        name&hh equ byte ptr [??_basereg-a+3]
    else
        ??_frame =  ??_frame + ((length + 3)/4)*4
        a = ??_frame
        ?deflocal <name>
        name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
        ??_numlocalsymbols = ??_numlocalsymbols + 1
        ?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
        name    equ <__inaccessible__NOTINSCOPE__>
        &endm
    endm
    .xcref  ?dodeflocal

;***    EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
        if ??_public
	    ifdef Not_VxD
                ?merge  %??_name,@,%(??_aframe),,label,near
                ?merge  public,,,,C,%??_name,@,%(??_aframe)
	    else
                ?merge  _,%??_name,@,%(??_aframe),label,near
                ?merge  public,,,,,_,%??_name,@,%(??_aframe)
	    endif
        endif
    endif
    if ??_pcall
        ??_aframe = 0
        ?count = ??_numargs
        rept    ??_numargs
            ?invprg <?MKA>,%?count
            ?count = ?count - 1
        endm
    endif
    ??_fleave = FALSE
    if ??_esp
        if  ??_frame
            sub esp, ??_frame
            ??_pushed = ??_pushed + ??_frame
            ??_fleave = VMM_TRUE
        endif
    else
        if  ??_frame eq 0
            if (??_aframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
                ifdef DEBUG
                    push    ebp
                    mov ebp,esp
                    ??_fleave = VMM_TRUE
                endif
            else
                push    ebp
                mov ebp,esp
                ??_fleave = VMM_TRUE
            endif
        else
            enter   ??_frame, 0
            ??_fleave = VMM_TRUE
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***    LeaveProc - removes stack frame on exit
;
;	NOTE:	If there are localvar and ESP kind of stack frame
;		LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;		flag is given.  PRESERVE_FLAGS generates bigger, slower
;		code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;        the internal stack depth for the local frame.  This is
;        to allow jumping around the LeaveProc/Return to code
;        after the LeaveProc/Return to use args/local variables,
;        but code that uses the stack frame executed after the
;        LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
        if ??_esp
            ifidni <flags>,<PRESERVE_FLAGS>
                lea esp,[esp + ??_frame]
            else
                add esp,??_frame
            endif
        else
            leave
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***    Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return  macro
    if  ??_cleanoff OR ??_w32svc
        if  ??_w32svc AND (??_aframe LT 8)
            ret 8
        else
            ret ??_aframe
        endif
    else
        ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***    EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp           ;; Masm will provide error msg for us
if ??_w32svc
    if ??_aframe lt 8
        cparm&Name equ 0
    else
        cparm&Name equ (??_aframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi  <Flag>,<NOCHECK>
    if ??_pushed ne 0
        %out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
        ife ??_procflags AND ??_pf_Entered
            %out Warning: ArgVar/LocalVar without EnterProc in Name
        endif
        ife ??_procflags AND ??_pf_Left
            %out Warning: ArgVar/LocalVar without LeaveProc in Name
        endif
        ife ??_procflags AND ??_pf_Returned
            %out Warning: ArgVar/LocalVar without Return in Name
        endif
    endif
endif
ifdifi  <Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
        ?count = ?count + 1
        ?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm

;***    cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall   macro   name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <flags>
    call    name
    ClearCParams
    endm
    .xcref  cCall

;***    pCall - pascal call
;
;   Arguments pushed in pascal order, callie cleans stack
;

pCall   macro   name, arglst
    local   ??saved
    ife .TYPE name
        ?toupper name
    else
        ?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
        push    x
        ??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***    sCall - standard call
;
;   Arguments pushed in "C" order, callie cleans stack,
;   @argc appended to name
;

sCall   macro   name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***    iCall - internal routine call
;
;   Set to what every type we what to use as a default.

iCall   equ <sCall>

;***    PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;       the word FAST if we should prefer speed over size
;
;       The default flag is SMALL, unless the current procedure
;       is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF  STANDARD_CCALL
NONSTANDARD_CCALL = 1           ;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    ??_argc = 0         ;; number of dwords on stack (global)
IFDEF   NONSTANDARD_CCALL
    ??_popargs = 0          ;; establish default
ELSE
    ??_popargs = ??_align EQ 0  ;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
        ??_popargs = 1      ;; size, not speed
    elseifidni <flags>, <FAST>
        ??_popargs = 0      ;; speed, not size
    endif

    irp x,<arglst>
        ??_argc = ??_argc + 1
        ?marg   <x>,%??_argc
    endm
    ?count = ??_argc
    rept    ??_argc
        ?invprg <?AM>,%?count
        ?count = ?count - 1
    endm
    endm

;***    ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;	If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;	This will generate bigger, slower code, so use it only when
;	necessary.

ClearCParams macro fPreserveFlags
	if	??_argc ne 0
	    if (??_popargs) AND (??_argc LE 2)
	      rept ??_argc
		pop	ecx
	      endm
	    else
	      ifidni <fPreserveFlags>, <PRESERVE_FLAGS>
		lea	esp, [esp][??_argc * 4]
	      else
		add	esp,??_argc * 4
	      endif
	    endif
	endif
	??_pushed = ??_pushed - (??_argc * 4)
	endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg   macro   name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
        push    name
        ??_pushed = ??_pushed + 4
        &endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro   name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall  macro   name1, name2
    CondExtern _&name1&@&name2, near
    call    _&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge  macro   l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
        if '&x' GE 'a'
          if '&x' LE 'z'
        ?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
        ?upper catstr ?upper,?t1
          else
        ?upper catstr ?upper,<&x>
          endif
        else
          ?upper catstr ?upper,<&x>
        endif
      endm
    endm
    .xcref

;***    CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
        ifndef name
        externdef name:dist
        endif
    else
        if2
        ifndef name
            extrn name:dist
        endif
        endif
    endif
endm

;***    SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro   reglist         ;; push those registers
    irp reg,<reglist>
        ifidni <reg>, <fd>
            pushfd
            ??_pushed = ??_pushed + 4
        else
        ifidni <reg>, <ad>
            pushad
            ??_pushed = ??_pushed + SIZE Pushad_Struc
        else
            push    reg
            ??_pushed = ??_pushed + 4
        endif
        endif
    endm
endm

;***    RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist    ;; pop those registers
    irp reg,<reglist>
        ifidni <reg>, <fd>
            popfd
            ??_pushed = ??_pushed - 4
        else
        ifidni <reg>, <ad>
            popad
            ??_pushed = ??_pushed - SIZE Pushad_Struc
        else
            pop reg
            ??_pushed = ??_pushed - 4
        endif
        endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.  Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db  'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd  OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd  0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *         S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST    0x00000010
#define HIGH_PRI_DEVICE_BOOST   0x00001000
#define CRITICAL_SECTION_BOOST  0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT        0
#define PEF_WAIT_FOR_STI        (1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT       1
#define PEF_WAIT_NOT_CRIT       (1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT        2
#define PEF_DONT_UNBOOST        (1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT        3
#define PEF_ALWAYS_SCHED        (1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT        4
#define PEF_TIME_OUT            (1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT     (1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT    6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT      7
#define PEF_WAIT_IN_PM          (1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT        8
#define PEF_THREAD_EVENT        (1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT         10
#define PEF_RING0_EVENT         (1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	    11
#define PEF_WAIT_CRIT		(1 << PEF_WAIT_CRIT_BIT)

#define PEF_WAIT_CRIT_VM_BIT	    12
#define PEF_WAIT_CRIT_VM	(1 << PEF_WAIT_CRIT_VM_BIT)

#define PEF_PROCESS_LAST_BIT	    13
#define PEF_PROCESS_LAST	(1 << PEF_PROCESS_LAST_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT       PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK     PEF_WAIT_NOT_NESTED_EXEC


/******************************************************************************
 *       F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *                           E N T E R _ M U T E X
 *             A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT      0
#define BLOCK_SVC_INTS          (1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT    1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT       2
#define BLOCK_ENABLE_INTS       (1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT          3
#define BLOCK_POLL          (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT           4
#define BLOCK_THREAD_IDLE               (1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT        5
#define BLOCK_FORCE_SVC_INTS		(1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;           /* Client's EDI */
    ULONG Client_ESI;           /* Client's ESI */
    ULONG Client_EBP;           /* Client's EBP */
    ULONG Client_res0;          /* ESP at pushall */
    ULONG Client_EBX;           /* Client's EBX */
    ULONG Client_EDX;           /* Client's EDX */
    ULONG Client_ECX;           /* Client's ECX */
    ULONG Client_EAX;           /* Client's EAX */
    ULONG Client_Error;         /* Dword error code */
    ULONG Client_EIP;           /* EIP */
    USHORT Client_CS;           /* CS */
    USHORT Client_res1;         /*   (padding) */
    ULONG Client_EFlags;        /* EFLAGS */
    ULONG Client_ESP;           /* ESP */
    USHORT Client_SS;           /* SS */
    USHORT Client_res2;         /*   (padding) */
    USHORT Client_ES;           /* ES */
    USHORT Client_res3;         /*   (padding) */
    USHORT Client_DS;           /* DS */
    USHORT Client_res4;         /*   (padding) */
    USHORT Client_FS;           /* FS */
    USHORT Client_res5;         /*   (padding) */
    USHORT Client_GS;           /* GS */
    USHORT Client_res6;         /*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;           /* Client's DI */
    USHORT Client_res13;        /*   (padding) */
    USHORT Client_SI;           /* Client's SI */
    USHORT Client_res14;        /*   (padding) */
    USHORT Client_BP;           /* Client's BP */
    USHORT Client_res15;        /*   (padding) */
    ULONG Client_res16;         /* ESP at pushall */
    USHORT Client_BX;           /* Client's BX */
    USHORT Client_res17;        /*   (padding) */
    USHORT Client_DX;           /* Client's DX */
    USHORT Client_res18;        /*   (padding) */
    USHORT Client_CX;           /* Client's CX */
    USHORT Client_res19;        /*   (padding) */
    USHORT Client_AX;           /* Client's AX */
    USHORT Client_res20;        /*   (padding) */
    ULONG Client_res21;         /* Dword error code */
    USHORT Client_IP;           /* Client's IP */
    USHORT Client_res22;        /*   (padding) */
    ULONG Client_res23;         /* CS */
    USHORT Client_Flags;        /* Client's flags (low) */
    USHORT Client_res24;        /*   (padding) */
    USHORT Client_SP;           /* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];      /* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;            /* Client's BL */
    UCHAR Client_BH;            /* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;            /* Client's DL */
    UCHAR Client_DH;            /* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;            /* Client's CL */
    UCHAR Client_CH;            /* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;            /* Client's AL */
    UCHAR Client_AH;            /* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc       CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0   /* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT   0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;	Declare services as conforming to the C calling convention
;	for parameter-passing, but *not* conforming to the C calling
;	convention for register usage.
;
;	Services which do not use the C calling convention for
;	parameter-passing need not be declared as nonstandard.
;
;	arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
	irp	x,<arglst>
	    ??_nonstandardccall_&x = 1
	endm
endm

;
; The following VMM services are nonstandard:
;       _BlockOnID and _LocalizeSprintf modify no registers except flags.
;       _SetLastV86Page modifies no registers except EAX and flags.
;       _Assert_Range returns information in flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page, _Assert_Range>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints      ; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd  OFFSET32 vt[sn+jf]
ENDM

GenDD   MACRO   P, vid, snum, jflag
    LOCAL   vtable
IFDEF   @@VxDName&vid
    Deftable    vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd  @@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_nonstandardccall_&P
    PushCParams <Param>, <FAST>
    else
    PushCParams <Param>, <flags>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
    else
	ClearCParams
    endif
    ENDM

VxDJmp  MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG   defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG    defines start of always present code segment
;VxD_CODE_ENDS   defines end of always present code segment
;VxD_DATA_SEG    defines start of always present data segment
;VxD_DATA_ENDS   defines end of always present data segment
;VxD_LOCKED_CODE_SEG    defines start of always present code segment
;VxD_LOCKED_CODE_ENDS   defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG  defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG    EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS   EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT   ENDS
        ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT   ENDS
        ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
        ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
        ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT  ENDS
        ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG    EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS   EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA   ENDS
        ENDM


;   Protected mode initialization data

VxD_IDATA_SEG   MACRO
_IDATA  SEGMENT
        ENDM
VxD_IDATA_ENDS  MACRO
_IDATA  ENDS
        ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA   ENDS
        ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT   ENDS
        ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA   ENDS
        ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
        ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
          ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
           ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
          ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
           ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A           /* 3.10 */
#else  /* WIN31COMPAT */
#define DDK_VERSION 0x400           /* 4.00 */
#endif

#endif

struct VxD_Desc_Block {
    ULONG DDB_Next;         /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;     /* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;           /* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];          /* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;       /* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;     /* Offset of control procedure */
    ULONG DDB_V86_API_Proc;     /* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;      /* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;     /* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;      /* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;       /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;         /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Size;		/* INIT <SIZE(VxD_Desc_Block)> Reserved */
    ULONG DDB_Reserved1;        /* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;        /* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;        /* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block       *PVMMDDB;
typedef PVMMDDB             *PPVMMDDB;

#ifndef Not_VxD

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE      (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE        (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT      14
#define DDB_HAS_WIN32_SVCS      (1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT     15
#define DDB_DYNAMIC_VXD         (1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED       (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB    <Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
        Ref_Data_Offset EQU 0
ELSE
        Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db  0dh, 0ah, 'D_E_B_U_G===>'
        db      "&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
             OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
             ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,   MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd  OFFSET32 ??_cd_&&num
ELSE
    dd  OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc             ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz  Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT    0x014

#define OUTPUT_BIT  2
#define OUTPUT      (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT    4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT   5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO      (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT  7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT  8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT    0x10            /* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je  Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb  In_Proc
ELSE
    je  Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw  Table_Name&_Entries
ELSE
    dw  ?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw  Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6    ; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw  Port
    dd  OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
        ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;          If compiled with debugging then this will generate a call
;          followed by a return.  If non-debugging version then the
;          specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF   DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint  MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
        VMMCall _ExecVxDIntMustComplete
    ENDM


*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0   /* loaded */
#define DUPLICATE_DEVICE_ID     (1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1   /* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F        (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT      2   /* in the INT 2F device list */
#define LOADING_FROM_INT2F      (1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK      0   /* load protected mode portion */
#define ABORT_DEVICE_LOAD   1   /* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2   /* fatal-error: abort load of Win386 */



#define NO_FAIL_MESSAGE_BIT 15  /* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0   /* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING  1   /* search for next string */
#define LDRSRV_RESERVED         2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3   /* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT  4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5   /* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6   /* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO      7   /* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey       0x100
#define LDRSRV_RegCreateKey     0x101
#define LDRSRV_RegCloseKey      0x102
#define LDRSRV_RegDeleteKey     0x103
#define LDRSRV_RegSetValue      0x104
#define LDRSRV_RegQueryValue        0x105
#define LDRSRV_RegEnumKey       0x106
#define LDRSRV_RegDeleteValue       0x107
#define LDRSRV_RegEnumValue     0x108
#define LDRSRV_RegQueryValueEx      0x109
#define LDRSRV_RegSetValueEx        0x10A
#define LDRSRV_RegFlushKey      0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT        1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED      2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE        3   /* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*           Also Init type objects should be added to the second part of the
*           list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ       -1

#define LCODE_OBJ       0x01
#define LDATA_OBJ       0x02
#define PCODE_OBJ       0x03
#define PDATA_OBJ       0x04
#define SCODE_OBJ       0x05
#define SDATA_OBJ       0x06
#define CODE16_OBJ      0x07
#define LMSG_OBJ        0x08
#define PMSG_OBJ        0x09

#define	DBOC_OBJ	0x0B
#define	DBOD_OBJ	0x0C

#define ICODE_OBJ       0x11
#define IDATA_OBJ       0x12
#define ICODE16_OBJ     0x13
#define IMSG_OBJ        0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  25

/*****************************************************************************
 *
 *      Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT      0   /* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT      1   /* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT      2   /* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT      3   /* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT      4   /* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT      31  /* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT      0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT      2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT      4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT      6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT      7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT      8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT      9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT      10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT      11  /* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT      14  /* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT      16  /* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT      17  /* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT      18  /* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19  /* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20  /* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *              PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE      0x1000      /* page size */

/******************************************************************************
 *
 *              PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES      (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER      (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC       (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM       0
#define PG_SYS      1
#define PG_RESERVED1    2
#define PG_PRIVATE  3
#define PG_RESERVED2    4
#define PG_RELOCK   5       /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES      0x080       /* present in memory */
#define D_NOTPRES   0       /* not present in memory */

#define D_DPL0      0       /* Ring 0 */
#define D_DPL1      0x020       /* Ring 1 */
#define D_DPL2      0x040       /* Ring 2 */
#define D_DPL3      0x060       /* Ring 3 */

#define D_SEG       0x010       /* Segment descriptor */
#define D_CTRL      0       /* Control descriptor */

#define D_GRAN_BYTE 0x000       /* Segment length is byte granular */
#define D_GRAN_PAGE 0x080       /* Segment length is page granular */
#define D_DEF16     0x000       /* Default operation size is 16 bits */
#define D_DEF32     0x040       /* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE      0x08        /* code */
#define D_DATA      0       /* data */

#define D_X     0       /* if code, exec only */
#define D_RX        0x02        /* if code, readable */
#define D_C     0x04        /* if code, conforming */

#define D_R     0       /* if data, read only */
#define D_W     0x02        /* if data, writable */
#define D_ED        0x04        /* if data, expand down */

#define D_ACCESSED  1       /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE    (D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK   0xFFF8      /* selector index */
#define SEL_LOW_MASK    0xF8        /* mask for low byte of sel indx */
#define TABLE_MASK  0x04        /* table bit */
#define RPL_MASK    0x03        /* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()    {__asm cli}

#define SAVE_FLAGS(flags) \
    __asm pushfd \
    __asm pop flags

#define RESTORE_FLAGS(flags) \
    __asm push flags \
    __asm popfd

#define IO_Delay() \
    __asm _emit 0xeb \
    __asm _emit 0x00

#define Touch_Register(Register) _asm xor Register, Register

typedef DWORD   HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)  // turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;      // count of milliseconds

#pragma warning (default:4209)  // turn on redefine warning (with basedef.h)

typedef DWORD   VMM_SEMAPHORE;

#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win\vmmreg.h ===
/****************************************************************************

*                                                                           *

* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *

* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *

* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *

* PURPOSE.                                                                  *

*                                                                           *

* Copyright (c) 1993-2001 Microsoft Corporation, All Rights Reserved
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *   Title:	VMMREG.H - Include file for VMM/Loader Registry Services
 *
 *   Version:	1.00
 *
 ******************************************************************************
 */

#ifndef	_VMMREG_H
#define _VMMREG_H

typedef DWORD	VMMHKEY;
typedef	VMMHKEY	*PVMMHKEY;
typedef DWORD	VMMREGRET;			// return type for the REG Functions

#define	MAX_VMM_REG_KEY_LEN	256	// includes the \0 terminator

#ifndef REG_SZ		// define only if not there already

#define REG_SZ		0x0001
#define REG_BINARY	0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE	// define only if not there already

#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA			0x80000006

#endif


// ERROR CODES returned by Registry
// NOTE THAT THESE ARE ALSO DEFINED IN WINERROR.H 
// and so VMMREG.H should be included after WINERROR.H

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND             2L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

// END ERROR CODES

/*XLATOFF*/
#ifndef Not_VxD

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

struct val_context {
    int valuelen;		// the total length of this value
    PVOID value_context;	// provider's context
    PVOID val_buff_ptr;	// where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalue {		      // Provider supplied value/context.
    PCHAR pv_valuename;          // The value name pointer
    DWORD pv_valuelen;
    PVOID pv_value_context;
    DWORD pv_type;
}PVALUE;

typedef struct pvalue *PPVALUE;

typedef VMMREGRET (_cdecl *PQUERYHANDLER)(PVOID pvKeyContext, PVALCONTEXT pvalcontextValues, DWORD cvalcontextValues, PVOID pbData, DWORD * pcbData, DWORD dwReserved);

#define PROVIDER_KEEPS_VALUE_LENGTH	0x1
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;		// Only PROVIDER_KEEPS_VALUE_LENGTH for now.
}PROVIDER;

typedef PROVIDER *PPROVIDER;

struct value_ent {
    PCHAR ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
};

typedef struct value_ent VALENT;
typedef VALENT *PVALENT;

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#ifndef WIN31COMPAT

#pragma warning (disable:4035)		// turn off no return code warning

#ifndef	WANTVXDWRAPS



VMMREGRET VXDINLINE
VMM_RegOpenKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegOpenKey);
    _asm add  esp, 3*4
}

VMMREGRET VXDINLINE
VMM_RegCloseKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCloseKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegCreateKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateKey);
    _asm add  esp, 3*4
}


VMMREGRET VXDINLINE
VMM_RegCreateDynKey(PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push cpvalueValueInfo
    _asm push ppvalueValueInfo
    _asm push pprovHandlerInfo
    _asm push pvKeyContext
    _asm push lpszSubKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateDynKey);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegQueryMultipleValues (VMMHKEY hKey, PVOID val_list, DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize)
{
    _asm push ldwTotsize
    _asm push lpValueBuf
    _asm push num_vals
    _asm push val_list
    _asm push hKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryMultipleValues);
    _asm add  esp, 5*4
}

VMMREGRET VXDINLINE
VMM_RegDeleteKey(VMMHKEY hkey, PCHAR lpszSubKey)
{
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteKey);
    _asm add  esp, 2*4
}

VMMREGRET VXDINLINE
VMM_RegEnumKey(VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName)
{
    _asm push cchName
    _asm push lpszName
    _asm push iSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumKey);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValue(VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue)
{
    _asm push lpcbValue
    _asm push lpszValue
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValue);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValue(VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData)
{
    _asm push cbData
    _asm push lpszData
    _asm push fdwType
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValue);
    _asm add  esp, 5*4 
}

VMMREGRET VXDINLINE
VMM_RegDeleteValue(VMMHKEY hkey, PCHAR lpszValue)
{
    _asm push lpszValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteValue);
    _asm add  esp, 2*4 
}

VMMREGRET VXDINLINE
VMM_RegEnumValue(VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpcbValue
    _asm push lpszValue
    _asm push iValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumValue);
    _asm add  esp, 8*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValueEx(VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValueEx);
    _asm add  esp, 6*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValueEx(VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PBYTE lpbData, DWORD cbData)
{
    _asm push cbData
    _asm push lpbData
    _asm push fdwType
    _asm push dwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValueEx);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegFlushKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegFlushKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryInfoKey(VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, 
PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime)
{
    _asm push lpftLastWriteTime
    _asm push lpcbSecurityDesc
    _asm push lpcbMaxValueData
    _asm push lpcchMaxValueName
    _asm push lpcValues
    _asm push lpcchMaxClass
    _asm push lpcchMaxSubKey
    _asm push lpcSubKeys
    _asm push lpdwReserved
    _asm push lpcchClass
    _asm push lpszClass
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryInfoKey);
    _asm add  esp, 12*4 
}

#endif	// WANTVXDWRAPS

#pragma warning (default:4035)		// turn on no return code warning

#endif // WIN31COMPAT

#endif // Not_VxD

/*XLATON*/

/* ASM
;**************************************************************
; Macros for Realmode loader registry Services
;
;**************************************************************
LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue		; lpszValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4		; for 8 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
*/
#endif		/* _VMMREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\thunk\win95\cim32net.c ===
//////////////////////////////////////////////////////////////////////////////

//

// Module:      thunk32.c

//

// Part of:     thunk32.dll

//

// Description:

//

//   This module contains the entry and exit functions for windows DLL

//   initialization.

//

//////////////////////////////////////////////////////////////////////////////

//

// History:

//

//  jennymc     8/2/95      Initial version

//  jennymc     1/8/98      Modified for Wbem

//

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////////////

#define WIN32_LEAN_AND_MEAN 1
#include <pshpack1.h>
#include <windows.h>
#include <win32thk.h>


///////////////////////////////////////////////////////////////////////////
// thunk startup handshake (code in .asm module generated by thunk compiler)
///////////////////////////////////////////////////////////////////////////
BOOL WINAPI win32thk_ThunkConnect32(LPSTR pszDll16,   LPSTR pszDll32,
                				 HINSTANCE  hInst, DWORD dwReason);

//////////////////////////////////////////////////////////////////////////
//
// Function:    DllMain
//
///////////////////////////////////////////////////////////////////////////
//
// Description: The main entry point for the DLL.  This is where we
//              set up the thunk connection.  Nothing else special is
//              done at this point.
//
///////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(HANDLE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    DWORD dwOffset;
    DWORD dwData;

    if (!(win32thk_ThunkConnect32(CIM16NET_DLL, CIM32NET_DLL, hDLL, dwReason))){
        #ifdef DEBUG
    	    MessageBox( NULL, "Thunk Error","ERROR",MB_OK);
        #endif
	    return FALSE;
    }

    switch( dwReason ) {
    	case DLL_PROCESS_ATTACH:
//            dwOffset = *((&thk_ThunkData32) + 7);
//            dwData = *(DWORD *)((char *)(&thk_ThunkData32) + dwOffset);
//            if (dwData == 0xCCCCCCCC)
//            {
//                return FALSE;
//            }

	        break;

	    case DLL_PROCESS_DETACH:
	        break;
    }

    return TRUE;
}

//***********************************************************************
//***********************************************************************
ULONG WINAPI CIM16GetUserInfo1(LPSTR Name, LPSTR Comment, LPSTR HomeDirectory,
			                  LPSTR ScriptPath, unsigned long * PasswordAge,
			                  unsigned short * Privilges, unsigned short * Flags);

ULONG WINAPI CIM16GetUserInfo2(LPSTR Name, LPSTR FullName,
		       LPSTR UserComment, LPSTR Parameters,
		       LPSTR Workstations, LPSTR LogonServer,
               LPLOGONDETAILS LogonDetails );

ULONG WINAPI CIM16GetUserInfo1Ex(LPSTR Domain, LPSTR Name, DWORD fGetDC, LPSTR Comment, LPSTR HomeDirectory,
			                  LPSTR ScriptPath, unsigned long * PasswordAge,
			                  unsigned short * Privilges, unsigned short * Flags);

ULONG WINAPI CIM16GetUserInfo2Ex(LPSTR Domain, LPSTR Name, DWORD fGetDC, LPSTR FullName,
		       LPSTR UserComment, LPSTR Parameters,
		       LPSTR Workstations, LPSTR LogonServer,
               LPLOGONDETAILS LogonDetails );

ULONG WINAPI CIM16GetConfigManagerStatus(LPSTR HardwareKey);

BYTE WINAPI CIM16GetDrivePartitions(BYTE cDrive, pMasterBootSector MBR);
BYTE WINAPI CIM16GetDriveParams(BYTE cDrive, pInt13DriveParams pParams);
WORD WINAPI CIM16GetBiosUnit(LPSTR);

ULONG WINAPI CIM16GetUseInfo1(
    LPSTR Name,
    LPSTR Local,
    LPSTR Remote,
    LPSTR Password,
    LPULONG pdwStatus,
    LPULONG pdwType,
    LPULONG pdwRefCount,
    LPULONG pdwUseCount);

ULONG WINAPI CIM16NetUseEnum(
    LPCSTR pszServer,
    short sLevel,
    LPSTR pbBuffer,
    use_info_1Out *pBuffer2,
    unsigned short cbBuffer,
    unsigned short far *pcEntriesRead,
    unsigned short far *pcTotalAvail
);

// Config manager exports
WORD WINAPI CIM16_CM_Locate_DevNode( PDEVNODE pdn, LPSTR HardwareKey, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Parent( PDEVNODE pdn, DEVNODE dnChild, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Child( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Sibling( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags );
WORD WINAPI CIM16_CM_Read_Registry_Value( DEVNODE dnDevNode, LPSTR pszSubKey, LPSTR pszValueName, ULONG ulExpectedType, LPVOID Buffer, LPULONG pulLength, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_DevNode_Status( LPULONG pulStatus, LPULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Device_ID( DEVNODE dnDevNode, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Device_ID_Size( LPULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Res_Des_Data_Size( LPULONG pulSize, RES_DES rdResDes, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Res_Des_Data( RES_DES rdResDes, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags );
WORD WINAPI CIM16_CM_Get_Bus_Info(DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags);

WORD WINAPI CIM16_CM_Query_Arbitrator_Free_Data(LPVOID pData, ULONG DataLen, DEVNODE dnDevInst, RESOURCEID ResourceID, ULONG ulFlags);
WORD WINAPI CIM16_CM_Delete_Range(ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags);
WORD WINAPI CIM16_CM_First_Range(RANGE_LIST rlh, LPULONG pulStart, LPULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags);
WORD WINAPI CIM16_CM_Next_Range(PRANGE_ELEMENT preElement, LPULONG pulStart, LPULONG pullEnd, ULONG ulFlags);
WORD WINAPI CIM16_CM_Free_Range_List(RANGE_LIST rlh, ULONG ulFlags);
DWORD WINAPI CIM16GetFreeSpace ( UINT option ) ;

//////////////////////////////////////////////////////////////////////////////
// Function:
//
//   gGetAllUserGroups
//
// Comments:
//   Calls the gGetLoggedOnUsersGroups in the 16 bit dll via thunk
//////////////////////////////////////////////////////////////////////////////
ULONG WINAPI GetWin9XUserInfo1(LPSTR Name,	LPSTR HomeDirectory,
					   LPSTR Comment, LPSTR ScriptPath, LPULONG PasswordAge,
					   LPUSHORT Privileges, LPUSHORT Flags )
{
    return(CIM16GetUserInfo1( Name,HomeDirectory,Comment,ScriptPath,
                              PasswordAge, Privileges, Flags));
}

//////////////////////////////////////////////////////////////////////
ULONG WINAPI GetWin9XUserInfo2(LPSTR Name, LPSTR FullName,
	LPSTR UserComment, LPSTR Parameters, LPSTR Workstations,
	LPSTR LogonServer, LPLOGONDETAILS LogonDetails )

{
    return(CIM16GetUserInfo2(Name, FullName,UserComment, Parameters,
                Workstations, LogonServer, LogonDetails ));
}

//////////////////////////////////////////////////////////////////////
ULONG WINAPI GetWin9XUserInfo1Ex(LPSTR Domain, LPSTR Name, DWORD fGetDC, LPSTR HomeDirectory,
					   LPSTR Comment, LPSTR ScriptPath, LPULONG PasswordAge,
					   LPUSHORT Privileges, LPUSHORT Flags )
{
    return(CIM16GetUserInfo1Ex( Domain, Name, fGetDC, HomeDirectory, Comment, ScriptPath,
                              PasswordAge, Privileges, Flags));
}

//////////////////////////////////////////////////////////////////////
ULONG WINAPI GetWin9XUserInfo2Ex(LPSTR Domain, LPSTR Name, DWORD fGetDC, LPSTR FullName,
	LPSTR UserComment, LPSTR Parameters, LPSTR Workstations,
	LPSTR LogonServer, LPLOGONDETAILS LogonDetails )

{
    return(CIM16GetUserInfo2Ex(Domain, Name, fGetDC, FullName,UserComment, Parameters,
                Workstations, LogonServer, LogonDetails ));
}

//////////////////////////////////////////////////////////////////////
ULONG WINAPI GetWin9XConfigManagerStatus(LPSTR HardwareKey)
{
    return(CIM16GetConfigManagerStatus(HardwareKey));
}

ULONG WINAPI GetWin9XUseInfo1(
    LPSTR Name,
    LPSTR Local,
    LPSTR Remote,
    LPSTR Password,
    LPULONG pdwStatus,
    LPULONG pdwType,
    LPULONG pdwRefCount,
    LPULONG pdwUseCount)
{
    return
        CIM16GetUseInfo1(
            Name,
            Local,
            Remote,
            Password,
            pdwStatus,
            pdwType,
            pdwRefCount,
            pdwUseCount);
}

ULONG WINAPI GetWin9XNetUseEnum(
    LPCSTR pszServer,
    short sLevel,
    LPSTR pbBuffer,
    use_info_1Out *pBuffer2,
    unsigned short cbBuffer,
    unsigned short *pcEntriesRead,
    unsigned short *pcTotalAvail
)
{
    return
        CIM16NetUseEnum(
            pszServer,
            sLevel,
            pbBuffer,
            pBuffer2,
            cbBuffer,
            pcEntriesRead,
            pcTotalAvail);

}

// Config Manager API call-thrus
DWORD WINAPI CIM32THK_CM_Locate_DevNode( PDEVNODE pdn, LPSTR HardwareKey, ULONG ulFlags )
{
	return( CIM16_CM_Locate_DevNode( pdn, HardwareKey, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Parent( PDEVNODE pdn, DEVNODE dnChild, ULONG ulFlags )
{
	return( CIM16_CM_Get_Parent( pdn, dnChild, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Child( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags )
{
	return( CIM16_CM_Get_Child( pdn, dnParent, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Sibling( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags )
{
	return( CIM16_CM_Get_Sibling( pdn, dnParent, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Read_Registry_Value( DEVNODE dnDevNode, LPSTR pszSubKey, LPSTR pszValueName, ULONG ulExpectedType, LPVOID Buffer, LPULONG pulLength, ULONG ulFlags )
{
	return( CIM16_CM_Read_Registry_Value( dnDevNode, pszSubKey, pszValueName, ulExpectedType, Buffer, pulLength, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_DevNode_Status( LPULONG pulStatus, LPULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags )
{
	return( CIM16_CM_Get_DevNode_Status( pulStatus, pulProblemNumber, dnDevNode, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Device_ID( DEVNODE dnDevNode, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags )
{
	return( CIM16_CM_Get_Device_ID( dnDevNode, Buffer, BufferLen, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Device_ID_Size( LPULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags )
{
	return( CIM16_CM_Get_Device_ID_Size( pulLen, dnDevNode, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags )
{
	return( CIM16_CM_Get_First_Log_Conf( plcLogConf, dnDevNode, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags )
{
	return( CIM16_CM_Get_Next_Res_Des( prdResDes, rdResDes, ForResource, pResourceID, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Res_Des_Data_Size( LPULONG pulSize, RES_DES rdResDes, ULONG ulFlags )
{
	return( CIM16_CM_Get_Res_Des_Data_Size( pulSize, rdResDes, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Res_Des_Data( RES_DES rdResDes, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags )
{
	return( CIM16_CM_Get_Res_Des_Data( rdResDes, Buffer, BufferLen, ulFlags ) );
}

DWORD WINAPI CIM32THK_CM_Get_Bus_Info(DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags)
{
	return( CIM16_CM_Get_Bus_Info( dnDevNode, pbtBusType, pulSizeOfInfo, pInfo, ulFlags ) );
}

WORD WINAPI CIM32THK_CM_Query_Arbitrator_Free_Data(LPVOID pData, ULONG DataLen, DEVNODE dnDevInst, RESOURCEID ResourceID, ULONG ulFlags)
{
    return CIM16_CM_Query_Arbitrator_Free_Data(pData, DataLen, dnDevInst, ResourceID, ulFlags);
}

WORD WINAPI CIM32THK_CM_Delete_Range(ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags)
{
    return CIM16_CM_Delete_Range(ulStartValue, ulEndValue, rlh, ulFlags);
}

WORD WINAPI CIM32THK_CM_First_Range(RANGE_LIST rlh, LPULONG pulStart, LPULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags)
{
    return CIM16_CM_First_Range(rlh, pulStart, pulEnd, preElement, ulFlags);
}

WORD WINAPI CIM32THK_CM_Next_Range(PRANGE_ELEMENT preElement, LPULONG pulStart, LPULONG pullEnd, ULONG ulFlags)
{
    return CIM16_CM_Next_Range(preElement, pulStart, pullEnd, ulFlags);
}

WORD WINAPI CIM32THK_CM_Free_Range_List(RANGE_LIST rlh, ULONG ulFlags)
{
    return CIM16_CM_Free_Range_List(rlh, ulFlags);
}


BYTE WINAPI GetWin9XPartitionTable(BYTE cDrive, pMasterBootSector pMBR)
{
    return(CIM16GetDrivePartitions(cDrive, pMBR));
}

BYTE WINAPI GetWin9XDriveParams(BYTE cDrive, pInt13DriveParams pParams)
{
    return(CIM16GetDriveParams(cDrive, pParams));
}

WORD WINAPI GetWin9XBiosUnit(LPSTR lpDeviceID)
{
    return(CIM16GetBiosUnit(lpDeviceID));
}

DWORD WINAPI GetWin9XFreeSpace ( DWORD option )
{
	return CIM16GetFreeSpace ( option ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\cmdump\cmdump.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
/*
cmdump.exe - Dumps all the info from config manager that is currently available through our mapping
                of the config manager api's.

*/

#include <fwcommon.h>
#include <dllwrapperbase.h>
#include <cim32netapi.h>
#include <confgmgr.h>
#include <stdio.h>
#include <strings.h>

void ShowResources(CConfigMgrDevice* pDevice);
void ShowBaseInfo(CConfigMgrDevice* pDevice);

#ifdef UNICODE
void wmain(void)
#else
void main(void)
#endif
{

    CConfigManager cfgManager;
    CDeviceCollection deviceList;

    if ( cfgManager.GetDeviceList( deviceList ) ) 
    {
        REFPTR_POSITION pos;
    
        if ( deviceList.BeginEnum( pos ) ) 
        {
            CConfigMgrDevice* pDevice = NULL;
        
            // Walk the list
            while ( (NULL != ( pDevice = deviceList.GetNext( pos ) ) ) )
            {
                ShowBaseInfo(pDevice);
                ShowResources(pDevice);

                // GetNext() AddRefs
                pDevice->Release();
            }
        
            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    _exit(0);
}

void ShowBaseInfo(CConfigMgrDevice* pDevice)
{
    CHString sDeviceID;
    CHStringArray saDevices;
    DWORD dwStatus, dwProblem, x;
    CConfigMgrDevice* pParentDevice = NULL;
    
    if (pDevice->GetDeviceID(sDeviceID))
        printf("PNPID: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetStatus(&dwStatus, &dwProblem))
    {
        _tprintf(_T("ConfigManagerErrorCode: %d\n"), dwProblem);
        _tprintf(_T("ConfigManagerStatusCode: %x\n"), dwStatus);
    }
    
    if (pDevice->GetConfigFlags( dwStatus ))
        _tprintf(_T("ConfigFlags: %d\n"), dwStatus);
    
    if (pDevice->GetCapabilities( dwStatus ))
        _tprintf(_T("GetCapabilities: %d\n"), dwStatus);
    
    if (pDevice->GetUINumber( dwStatus ))
        _tprintf(_T("GetUINumber: %d\n"), dwStatus);
    
    _tprintf(_T("IsUsingForcedConfig: %d\n"), pDevice->IsUsingForcedConfig());
    
    if (pDevice->GetDeviceDesc(sDeviceID))
        printf("Description: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetService(sDeviceID))
        printf("Service: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetClass(sDeviceID))
        printf("Class: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetClassGUID(sDeviceID))
        printf("GetClassGUID: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetDriver(sDeviceID))
        printf("GetDriver: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetMfg(sDeviceID))
        printf("GetMfg: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetFriendlyName(sDeviceID))
        printf("GetFriendlyName: %\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetLocationInformation(sDeviceID))
        printf("GetLocationInformation: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetPhysicalDeviceObjectName(sDeviceID))
        printf("GetPhysicalDeviceObjectName: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetEnumeratorName(sDeviceID))
        printf("GetEnumeratorName: %S\n", (LPCWSTR)sDeviceID);
    
    if (pDevice->GetHardwareID( saDevices ))
    {
        for (x=0; x < saDevices.GetSize(); x++)
        {
            printf("GetHardwareID(%d): %S\n", x, (LPCWSTR)saDevices[x]);
        }
    }
    
    INTERFACE_TYPE itBusType;
    DWORD dwBusNumber;
	if (pDevice->GetBusInfo( &itBusType, &dwBusNumber))
    {
        printf("Bus: %S #%d\n", szBusType[itBusType], dwBusNumber);
    }

    pParentDevice = NULL;
    if (pDevice->GetParent(&pParentDevice))
    {
        if (pParentDevice->GetDeviceID(sDeviceID))
            printf("Parent PNPID: %S\n", (LPCWSTR)sDeviceID);
        
        pParentDevice->Release();
    }
    
    printf("\n");
}

void ShowResources(CConfigMgrDevice* pDevice)
{
    
    CIRQCollection irqList;
    CDMACollection dmaList;
    CDeviceMemoryCollection DevMemList;
    CIOCollection ioList;
    REFPTR_POSITION pos2;
    
    // Get the IRQs
    pDevice->GetIRQResources( irqList );
    
    if ( irqList.BeginEnum( pos2 ) ) {
        CIRQDescriptor *pIRQ = NULL;
        
        // Walk the irq's
        while (( NULL != ( pIRQ = irqList.GetNext( pos2 ) ) )) {
            
            _tprintf(_T("\tIRQ: %u\n"), pIRQ->GetInterrupt());
            _tprintf(_T("\tAffinity: %u\n"), pIRQ->GetAffinity());
            _tprintf(_T("\tIsShareable: %d\n"), pIRQ->IsShareable());
            _tprintf(_T("\tGetFlags: %u\n"), pIRQ->GetFlags());
            _tprintf(_T("\n"));
            
            pIRQ->Release();
        }
    }
    
    // Get DMAChannel
    pDevice->GetDMAResources( dmaList );
    
    if ( dmaList.BeginEnum( pos2 ) ) {
        CDMADescriptor *pDMA = NULL;
        
        // Walk the Channels (or is that surf?)
        while (( NULL != ( pDMA = dmaList.GetNext( pos2 ) ) )) {

            _tprintf(_T("\tDMA: %u\n"), pDMA->GetChannel());
            _tprintf(_T("\tGetFlags: %u\n"), pDMA->GetFlags());
            _tprintf(_T("\n"));
            
            pDMA->Release();
        }
    }
    
    // Get DeviceMemory
    pDevice->GetDeviceMemoryResources( DevMemList );
    
    if ( DevMemList.BeginEnum( pos2 ) ) {
        CDeviceMemoryDescriptor *pDeviceMemory = NULL;
        
        // Walk the memory resource 
        while ( ( NULL != ( pDeviceMemory = DevMemList.GetNext( pos2 ) ) )) {
            
            _tprintf(_T("\tDevice Memory Base: %I64x\n"), pDeviceMemory->GetBaseAddress());
            _tprintf(_T("\tDevice Memory End: %I64x\n"), pDeviceMemory->GetEndAddress());
            _tprintf(_T("\tGetFlags: %u\n"), pDeviceMemory->GetFlags());
            _tprintf(_T("\n"));
            
            pDeviceMemory->Release();
        }
    }
    
    // Get IO Ports
    pDevice->GetIOResources( ioList );
    
    if ( ioList.BeginEnum( pos2 ) ) {
        CIODescriptor *pIO = NULL;
        
        // Walk the ports
        while ( ( NULL != ( pIO = ioList.GetNext( pos2 ) ) )) {

            _tprintf(_T("\tIOPort Base: %I64x\n"), pIO->GetBaseAddress());
            _tprintf(_T("\tIOPort End: %I64x\n"), pIO->GetEndAddress());
            _tprintf(_T("\tGetFlags: %x\n"), pIO->GetFlags());
            _tprintf(_T("\tAlias: %d\n"), pIO->GetAlias());
            _tprintf(_T("\tDecode: %d\n"), pIO->GetDecode());
            _tprintf(_T("\n"));
            
            pIO->Release();
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\cfgmgr32.h ===
/*++



Copyright (c) 1989-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    cfgmgr32.h

Abstract:

    This module contains the user APIs for the Configuration Manager,
    along with any public data structures needed to call these APIs.

--*/

#ifndef _CFGMGR32_
#define _CFGMGR32_

#include <cfg.h>


#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif



#if !defined (_CFGMGR32_)
#define CMAPI     DECLSPEC_IMPORT
#else
#define CMAPI
#endif

typedef  CONST VOID *PCVOID;



//--------------------------------------------------------------
// General size definitions
//--------------------------------------------------------------

#define MAX_DEVICE_ID_LEN     200
#define MAX_DEVNODE_ID_LEN    MAX_DEVICE_ID_LEN

#define MAX_GUID_STRING_LEN   39          // 38 chars + terminator null
#define MAX_CLASS_NAME_LEN    32
#define MAX_PROFILE_LEN       80

#define MAX_CONFIG_VALUE      9999
#define MAX_INSTANCE_VALUE    9999

#define MAX_MEM_REGISTERS     9     // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_IO_PORTS          20    // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_IRQS              7     // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_DMA_CHANNELS      7     // Win95 compatibility--not applicable to 32-bit ConfigMgr

#define DWORD_MAX             0xFFFFFFFF
#define DWORDLONG_MAX         0xFFFFFFFFFFFFFFFF

#define CONFIGMG_VERSION      0x0400


//--------------------------------------------------------------
// Data types
//--------------------------------------------------------------


//
// Work around weirdness with Win32 typedef...
//
#ifdef NT_INCLUDED

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//
#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef unsigned __int64 DWORDLONG;
#else
typedef double DWORDLONG;
#endif
typedef DWORDLONG *PDWORDLONG;

#endif /* NT_INCLUDED */


//
// Standardized Return Value data type
//
typedef DWORD        RETURN_TYPE;
typedef RETURN_TYPE  CONFIGRET;

//
// Device Instance Handle data type
//
typedef DWORD       DEVNODE, DEVINST;
typedef DEVNODE    *PDEVNODE, *PDEVINST;

//
// Device Instance Identifier data type
// The device instance ID specifies the registry path, relative to the
// Enum key , for a device instance.  For example:  \Root\*PNP0500\0000.
//
typedef CHAR          *DEVNODEID_A, *DEVINSTID_A; // Device ID ANSI name.
typedef WCHAR         *DEVNODEID_W, *DEVINSTID_W; // Device ID Unicode name.
#ifdef UNICODE
typedef DEVNODEID_W DEVNODEID;
typedef DEVINSTID_W DEVINSTID;
#else
typedef DEVNODEID_A DEVNODEID;
typedef DEVINSTID_A DEVINSTID;
#endif

//
// Logical Configuration Handle data type
//
typedef DWORD        LOG_CONF;
typedef LOG_CONF    *PLOG_CONF;

//
// Resource Descriptor Handle data type
//
typedef DWORD        RES_DES;
typedef RES_DES     *PRES_DES;

//
// Resource ID data type (may take any of the ResType_* values)
//
typedef ULONG        RESOURCEID;
typedef RESOURCEID  *PRESOURCEID;

//
// Priority data type (may take any of the LCPRI_* values)
//
typedef ULONG        PRIORITY;
typedef PRIORITY     *PPRIORITY;

//
// Range List Handle data type
//
typedef DWORD              RANGE_LIST;
typedef RANGE_LIST        *PRANGE_LIST;

//
// Range Element Handle data type
//
typedef DWORD              RANGE_ELEMENT;
typedef RANGE_ELEMENT     *PRANGE_ELEMENT;

typedef  HANDLE             HMACHINE;
typedef  HMACHINE          *PHMACHINE;


typedef  ULONG             REGDISPOSITION;


//
// use 1 byte packing for the data structures
//
#include "pshpack1.h"



//--------------------------------------------------------------
// Memory resource
//--------------------------------------------------------------

//
// Define the attribute flags for memory ranges.  Each bit flag is
// identified by a constant bitmask.  Following the bitmask definition,
// are the two possible values.
//
#define mMD_MemoryType              (0x1) // Bitmask, whether memory is writable
#define fMD_MemoryType              mMD_MemoryType // compatibility
#define fMD_ROM                     (0x0) // Memory range is read-only
#define fMD_RAM                     (0x1) // Memory range may be written to

#define mMD_32_24                   (0x2) // Bitmask, memory is 24 or 32-bit
#define fMD_32_24                   mMD_32_24 // compatibility
#define fMD_24                      (0x0) // Memory range is 24-bit
#define fMD_32                      (0x2) // Memory range is 32-bit

#define mMD_Prefetchable            (0x4) // Bitmask,whether memory prefetchable
#define fMD_Prefetchable            mMD_Prefetchable // compatibility
#define fMD_Pref                    mMD_Prefetchable // compatibility
#define fMD_PrefetchDisallowed      (0x0) // Memory range is not prefetchable
#define fMD_PrefetchAllowed         (0x4) // Memory range is prefetchable

#define mMD_Readable                (0x8) // Bitmask,whether memory is readable
#define fMD_Readable                mMD_Readable // compatibility
#define fMD_ReadAllowed             (0x0) // Memory range is readable
#define fMD_ReadDisallowed          (0x8) // Memory range is write-only

#define mMD_CombinedWrite           (0x10) // Bitmask,supports write-behind
#define fMD_CombinedWrite           mMD_CombinedWrite // compatibility
#define fMD_CombinedWriteDisallowed (0x0)  // no combined-write caching
#define fMD_CombinedWriteAllowed    (0x10) // supports combined-write caching

#define mMD_Cacheable               (0x20) // Bitmask,whether memory is cacheable
#define fMD_NonCacheable            (0x0)  // Memory range is non-cacheable
#define fMD_Cacheable               (0x20) // Memory range is cacheable

//
// MEM_RANGE Structure
//
typedef struct Mem_Range_s {
   DWORDLONG MR_Align;     // specifies mask for base alignment
   ULONG     MR_nBytes;    // specifies number of bytes required
   DWORDLONG MR_Min;       // specifies minimum address of the range
   DWORDLONG MR_Max;       // specifies maximum address of the range
   DWORD     MR_Flags;     // specifies flags describing range (fMD flags)
   DWORD     MR_Reserved;
} MEM_RANGE, *PMEM_RANGE;

//
// MEM_DES structure
//
typedef struct Mem_Des_s {
   DWORD     MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
   DWORD     MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
   DWORDLONG MD_Alloc_Base;   // base memory address of range allocated
   DWORDLONG MD_Alloc_End;    // end of allocated range
   DWORD     MD_Flags;        // flags describing allocated range (fMD flags)
   DWORD     MD_Reserved;
} MEM_DES, *PMEM_DES;

//
// MEM_RESOURCE structure
//
typedef struct Mem_Resource_s {
   MEM_DES   MEM_Header;               // info about memory range list
   MEM_RANGE MEM_Data[ANYSIZE_ARRAY];  // list of memory ranges
} MEM_RESOURCE, *PMEM_RESOURCE;

//
// Define the size of each range structure
//
#define MType_Range     sizeof(struct Mem_Range_s)



//--------------------------------------------------------------
// I/O Port Resource
//--------------------------------------------------------------

//
// Define the attribute flags for port resources.  Each bit flag is
// identified by a constant bitmask.  Following the bitmask definition,
// are the two possible values.
//
#define fIOD_PortType   (0x1) // Bitmask,whether port is IO or memory
#define fIOD_Memory     (0x0) // Port resource really uses memory
#define fIOD_IO         (0x1) // Port resource uses IO ports


#define IO_ALIAS_10_BIT_DECODE      (0x00000004)
#define IO_ALIAS_12_BIT_DECODE      (0x00000010)
#define IO_ALIAS_16_BIT_DECODE      (0x00000000)
#define IO_ALIAS_POSITIVE_DECODE    (0x000000FF)

//
// IO_RANGE structure
//
typedef struct IO_Range_s {
   DWORDLONG IOR_Align;      // mask for base alignment
   DWORD     IOR_nPorts;     // number of ports
   DWORDLONG IOR_Min;        // minimum port address
   DWORDLONG IOR_Max;        // maximum port address
   DWORD     IOR_RangeFlags; // flags for this port range
   DWORDLONG IOR_Alias;      // multiplier that generates aliases for port(s)
} IO_RANGE, *PIO_RANGE;

//
// IO_DES structure
//
typedef struct IO_Des_s {
   DWORD     IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
   DWORD     IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
   DWORDLONG IOD_Alloc_Base;     // base of allocated port range
   DWORDLONG IOD_Alloc_End;      // end of allocated port range
   DWORD     IOD_DesFlags;       // flags relating to allocated port range
} IO_DES, *PIO_DES;

//
// IO_RESOURCE
//
typedef struct IO_Resource_s {
   IO_DES   IO_Header;                 // info about I/O port range list
   IO_RANGE IO_Data[ANYSIZE_ARRAY];    // list of I/O port ranges
} IO_RESOURCE, *PIO_RESOURCE;

#define IOA_Local       0xff

//
// Define the size of each range structure
//
#define IOType_Range    sizeof(struct IO_Range_s)



//--------------------------------------------------------------
// DMA Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a DMA resource range.  Each bit flag is
// identified with a constant bitmask.  Following the bitmask definition
// are the possible values.
//
#define mDD_Width         (0x3)    // Bitmask, width of the DMA channel:
#define fDD_BYTE          (0x0)    //   8-bit DMA channel
#define fDD_WORD          (0x1)    //   16-bit DMA channel
#define fDD_DWORD         (0x2)    //   32-bit DMA channel
#define fDD_BYTE_AND_WORD (0x3)    //   8-bit and 16-bit DMA channel

#define mDD_BusMaster     (0x4)    // Bitmask, whether bus mastering is supported
#define fDD_NoBusMaster   (0x0)    //   no bus mastering
#define fDD_BusMaster     (0x4)    //   bus mastering

#define mDD_Type         (0x18)    // Bitmask, specifies type of DMA
#define fDD_TypeStandard (0x00)    //   standard DMA
#define fDD_TypeA        (0x08)    //   Type-A DMA
#define fDD_TypeB        (0x10)    //   Type-B DMA
#define fDD_TypeF        (0x18)    //   Type-F DMA


//
// DMA_RANGE structure
//
typedef struct DMA_Range_s {
   ULONG DR_Min;     // minimum DMA port in the range
   ULONG DR_Max;     // maximum DMA port in the range
   ULONG DR_Flags;   // flags describing the range (fDD flags)
} DMA_RANGE, *PDMA_RANGE;

//
// DMA_DES structure
//
typedef struct DMA_Des_s {
   DWORD  DD_Count;       // number of DMA_RANGE structs in DMA_RESOURCE
   DWORD  DD_Type;        // size (in bytes) of DMA_RANGE struct (DType_Range)
   DWORD  DD_Flags;       // Flags describing DMA channel (fDD flags)
   ULONG  DD_Alloc_Chan;  // Specifies the DMA channel that was allocated
} DMA_DES, *PDMA_DES;

//
// DMA_RESOURCE
//
typedef struct DMA_Resource_s {
   DMA_DES   DMA_Header;               // info about DMA channel range list
   DMA_RANGE DMA_Data[ANYSIZE_ARRAY];  // list of DMA ranges
} DMA_RESOURCE, *PDMA_RESOURCE;

//
// Define the size of each range structure
//
#define DType_Range     sizeof(struct DMA_Range_s)



//--------------------------------------------------------------
// Interrupt Resource
//--------------------------------------------------------------

//
// Define the attribute flags for an interrupt resource range.  Each bit flag
// is identified with a constant bitmask.  Following the bitmask definition
// are the possible values.
//
#define mIRQD_Share        (0x1) // Bitmask,whether the IRQ may be shared:
#define fIRQD_Exclusive    (0x0) //   The IRQ may not be shared
#define fIRQD_Share        (0x1) //   The IRQ may be shared

#define fIRQD_Share_Bit    0     // compatibility
#define fIRQD_Level_Bit    1     // compatibility

//
// ** NOTE: 16-bit ConfigMgr uses fIRQD_Level_Bit being set to indicate that the
// ** interrupt is _level-sensitive_.  For 32-bit ConfigMgr, if this bit is set,
// ** then the interrupt is _edge-sensitive_.
//
#define mIRQD_Edge_Level   (0x2) // Bitmask,whether edge or level triggered:
#define fIRQD_Level        (0x0) //   The IRQ is level-sensitive
#define fIRQD_Edge         (0x2) //   The IRQ is edge-sensitive

//
// IRQ_RANGE
//
typedef struct IRQ_Range_s {
   ULONG IRQR_Min;      // minimum IRQ in the range
   ULONG IRQR_Max;      // maximum IRQ in the range
   ULONG IRQR_Flags;    // flags describing the range (fIRQD flags)
} IRQ_RANGE, *PIRQ_RANGE;

//
// IRQ_DES structure
//
typedef struct IRQ_Des_s {
   DWORD IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
   DWORD IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
   DWORD IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
   ULONG IRQD_Alloc_Num;   // specifies the IRQ that was allocated
   ULONG IRQD_Affinity;
} IRQ_DES, *PIRQ_DES;

//
// IRQ_RESOURCE structure
//
typedef struct IRQ_Resource_s {
   IRQ_DES   IRQ_Header;               // info about IRQ range list
   IRQ_RANGE IRQ_Data[ANYSIZE_ARRAY];  // list of IRQ ranges
} IRQ_RESOURCE, *PIRQ_RESOURCE;

//
// Define the size of each range structure
//
#define IRQType_Range   sizeof(struct IRQ_Range_s)


//--------------------------------------------------------------
// Device Private Resource
//--------------------------------------------------------------

//
// DEVICEPRIVATE_RANGE structure
//

typedef struct DevPrivate_Range_s {
   DWORD    PR_Data1;     // mask for base alignment
   DWORD    PR_Data2;     // number of bytes
   DWORD    PR_Data3;     // minimum address
} DEVPRIVATE_RANGE, *PDEVPRIVATE_RANGE;

//
// DEVPRIVATE_DES structure
//
typedef struct DevPrivate_Des_s {
   DWORD     PD_Count;
   DWORD     PD_Type;
   DWORD     PD_Data1;
   DWORD     PD_Data2;
   DWORD     PD_Data3;
   DWORD     PD_Flags;
} DEVPRIVATE_DES, *PDEVPRIVATE_DES;

//
// DEVPRIVATE_RESOURCE
//
typedef struct DevPrivate_Resource_s {
   DEVPRIVATE_DES   PRV_Header;
   DEVPRIVATE_RANGE PRV_Data[ANYSIZE_ARRAY];
} DEVPRIVATE_RESOURCE, *PDEVPRIVATE_RESOURCE;

//
// Define the size of each range structure
//
#define PType_Range    sizeof(struct DevPrivate_Range_s)



//--------------------------------------------------------------
// Class-Specific Resource
//--------------------------------------------------------------

typedef struct CS_Des_s {
   DWORD    CSD_SignatureLength;
   DWORD    CSD_LegacyDataOffset;
   DWORD    CSD_LegacyDataSize;
   DWORD    CSD_Flags;
   GUID     CSD_ClassGuid;
   BYTE     CSD_Signature[ANYSIZE_ARRAY];
} CS_DES, *PCS_DES;

typedef struct CS_Resource_s {
   CS_DES   CS_Header;
} CS_RESOURCE, *PCS_RESOURCE;



//--------------------------------------------------------------
// PC Card Configuration Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a PC Card configuration resource descriptor.
// Each bit flag is identified with a constant bitmask.  Following the bitmask
// definition are the possible values.
//
#define mPCD_IO_8_16        (0x1)   // Bitmask, whether I/O is 8 or 16 bits
#define fPCD_IO_8           (0x0)   // I/O is 8-bit
#define fPCD_IO_16          (0x1)   // I/O is 16-bit
#define mPCD_MEM_8_16       (0x2)   // Bitmask, whether MEM is 8 or 16 bits
#define fPCD_MEM_8          (0x0)   // MEM is 8-bit
#define fPCD_MEM_16         (0x2)   // MEM is 16-bit


typedef struct PcCard_Des_s {
    DWORD    PCD_Flags;
    BYTE     PCD_ConfigIndex;
    BYTE     PCD_Reserved[3];
    DWORD    PCD_MemoryCardBase1;
    DWORD    PCD_MemoryCardBase2;
} PCCARD_DES, *PPCCARD_DES;

typedef struct PcCard_Resource_s {
   PCCARD_DES   PcCard_Header;
} PCCARD_RESOURCE, *PPCCARD_RESOURCE;



//--------------------------------------------------------------
// Bus Number Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a Bus Number resource descriptor.
// Each bit flag is identified with a constant bitmask.  Following the bitmask
// definition are the possible values.
//
// Currently unused.
//

//
// BUSNUMBER_RANGE
//
typedef struct BusNumber_Range_s {
   ULONG BUSR_Min;          // minimum Bus Number in the range
   ULONG BUSR_Max;          // maximum Bus Number in the range
   ULONG BUSR_nBusNumbers;  // specifies number of buses required
   ULONG BUSR_Flags;        // flags describing the range (currently unused)
} BUSNUMBER_RANGE, *PBUSNUMBER_RANGE;

//
// BUSNUMBER_DES structure
//
typedef struct BusNumber_Des_s {
   DWORD BUSD_Count;       // number of BUSNUMBER_RANGE structs in BUSNUMBER_RESOURCE
   DWORD BUSD_Type;        // size (in bytes) of BUSNUMBER_RANGE (BusNumberType_Range)
   DWORD BUSD_Flags;       // flags describing the range (currently unused)
   ULONG BUSD_Alloc_Base;  // specifies the first Bus that was allocated
   ULONG BUSD_Alloc_End;   // specifies the last Bus number that was allocated
} BUSNUMBER_DES, *PBUSNUMBER_DES;

//
// BUSNUMBER_RESOURCE structure
//
typedef struct BusNumber_Resource_s {
   BUSNUMBER_DES   BusNumber_Header;               // info about Bus Number range list
   BUSNUMBER_RANGE BusNumber_Data[ANYSIZE_ARRAY];  // list of Bus Number ranges
} BUSNUMBER_RESOURCE, *PBUSNUMBER_RESOURCE;

//
// Define the size of each range structure
//
#define BusNumberType_Range   sizeof(struct BusNumber_Range_s)



//--------------------------------------------------------------
// Hardware Profile Information
//--------------------------------------------------------------

//
// Define flags relating to hardware profiles
//
#define CM_HWPI_NOT_DOCKABLE  (0x00000000)   // machine is not dockable
#define CM_HWPI_UNDOCKED      (0x00000001)   // hw profile for docked config
#define CM_HWPI_DOCKED        (0x00000002)   // hw profile for undocked config

//
// HWPROFILEINFO structure
//
typedef struct HWProfileInfo_sA {
   ULONG  HWPI_ulHWProfile;                      // handle of hw profile
   CHAR   HWPI_szFriendlyName[MAX_PROFILE_LEN];  // friendly name of hw profile
   DWORD  HWPI_dwFlags;                          // profile flags (CM_HWPI_*)
} HWPROFILEINFO_A, *PHWPROFILEINFO_A;

typedef struct HWProfileInfo_sW {
   ULONG  HWPI_ulHWProfile;                      // handle of hw profile
   WCHAR  HWPI_szFriendlyName[MAX_PROFILE_LEN];  // friendly name of hw profile
   DWORD  HWPI_dwFlags;                          // profile flags (CM_HWPI_*)
} HWPROFILEINFO_W, *PHWPROFILEINFO_W;

#ifdef UNICODE
typedef HWPROFILEINFO_W   HWPROFILEINFO;
typedef PHWPROFILEINFO_W  PHWPROFILEINFO;
#else
typedef HWPROFILEINFO_A   HWPROFILEINFO;
typedef PHWPROFILEINFO_A  PHWPROFILEINFO;
#endif


//
// revert back to normal default packing
//
#include "poppack.h"



//--------------------------------------------------------------
// Miscellaneous
//--------------------------------------------------------------


//
// Resource types
//
#define ResType_All           (0x00000000)   // Return all resource types
#define ResType_None          (0x00000000)   // Arbitration always succeeded
#define ResType_Mem           (0x00000001)   // Physical address resource
#define ResType_IO            (0x00000002)   // Physical I/O address resource
#define ResType_DMA           (0x00000003)   // DMA channels resource
#define ResType_IRQ           (0x00000004)   // IRQ resource
#define ResType_DoNotUse      (0x00000005)   // Used as spacer to sync subsequent ResTypes w/NT
#define ResType_BusNumber     (0x00000006)   // bus number resource
#define ResType_MAX           (0x00000006)   // Maximum known (arbitrated) ResType
#define ResType_Ignored_Bit   (0x00008000)   // Ignore this resource
#define ResType_ClassSpecific (0x0000FFFF)   // class-specific resource
#define ResType_Reserved      (0x00008000)   // reserved for internal use
#define ResType_DevicePrivate (0x00008001)   // device private data
#define ResType_PcCardConfig  (0x00008002)   // PC Card configuration data


//
// Flags specifying options for ranges that conflict with ranges already in
// the range list (CM_Add_Range)
//
#define CM_ADD_RANGE_ADDIFCONFLICT        (0x00000000) // merg with conflicting range
#define CM_ADD_RANGE_DONOTADDIFCONFLICT   (0x00000001) // error if range conflicts
#define CM_ADD_RANGE_BITS                 (0x00000001)


//
// Logical Config Flags (specified in call to CM_Get_First_Log_Conf
//
#define BASIC_LOG_CONF    0x00000000  // Specifies the req list.
#define FILTERED_LOG_CONF 0x00000001  // Specifies the filtered req list.
#define ALLOC_LOG_CONF    0x00000002  // Specifies the Alloc Element.
#define BOOT_LOG_CONF     0x00000003  // Specifies the RM Alloc Element.
#define FORCED_LOG_CONF   0x00000004  // Specifies the Forced Log Conf
#define OVERRIDE_LOG_CONF 0x00000005  // Specifies the Override req list.
#define NUM_LOG_CONF      0x00000006  // Number of Log Conf type
#define LOG_CONF_BITS     0x00000007  // The bits of the log conf type.

#define PRIORITY_EQUAL_FIRST  (0x00000008) // Same priority, new one first
#define PRIORITY_EQUAL_LAST   (0x00000000) // Same priority, new one last
#define PRIORITY_BIT          (0x00000008)

//
// Registry disposition values
// (specified in call to CM_Open_DevNode_Key and CM_Open_Class_Key)
//
#define RegDisposition_OpenAlways   (0x00000000)   // open if exists else create
#define RegDisposition_OpenExisting (0x00000001)   // open key only if exists
#define RegDisposition_Bits         (0x00000001)

//
// ulFlags values for CM API routines
//

//
// Flags for CM_Add_ID
//
#define CM_ADD_ID_HARDWARE                (0x00000000)
#define CM_ADD_ID_COMPATIBLE              (0x00000001)
#define CM_ADD_ID_BITS                    (0x00000001)


//
// Device Node creation flags
//
#define CM_CREATE_DEVNODE_NORMAL          (0x00000000)   // install later
#define CM_CREATE_DEVNODE_NO_WAIT_INSTALL (0x00000001)   // NOT SUPPORTED ON NT
#define CM_CREATE_DEVNODE_PHANTOM         (0x00000002)
#define CM_CREATE_DEVNODE_GENERATE_ID     (0x00000004)
#define CM_CREATE_DEVNODE_DO_NOT_INSTALL  (0x00000008)
#define CM_CREATE_DEVNODE_BITS            (0x0000000F)

#define CM_CREATE_DEVINST_NORMAL          CM_CREATE_DEVNODE_NORMAL
#define CM_CREATE_DEVINST_NO_WAIT_INSTALL CM_CREATE_DEVNODE_NO_WAIT_INSTALL
#define CM_CREATE_DEVINST_PHANTOM         CM_CREATE_DEVNODE_PHANTOM
#define CM_CREATE_DEVINST_GENERATE_ID     CM_CREATE_DEVNODE_GENERATE_ID
#define CM_CREATE_DEVINST_DO_NOT_INSTALL  CM_CREATE_DEVNODE_DO_NOT_INSTALL
#define CM_CREATE_DEVINST_BITS            CM_CREATE_DEVNODE_BITS


//
// Flags for CM_Delete_Class_Key
//
#define CM_DELETE_CLASS_ONLY        (0x00000000)
#define CM_DELETE_CLASS_SUBKEYS     (0x00000001)
#define CM_DELETE_CLASS_BITS        (0x00000001)


//
// Detection reason flags (specified in call to CM_Run_Detection)
//
#define CM_DETECT_NEW_PROFILE       (0x00000001) // detection for new hw profile
#define CM_DETECT_CRASHED           (0x00000002) // Previous detection crashed
#define CM_DETECT_HWPROF_FIRST_BOOT (0x00000004)
#define CM_DETECT_RUN               (0x80000000)
#define CM_DETECT_BITS              (0x80000007)

#define CM_DISABLE_POLITE           (0x00000000)    // Ask the driver
#define CM_DISABLE_ABSOLUTE         (0x00000001)    // Don't ask the driver
#define CM_DISABLE_HARDWARE         (0x00000002)    // Don't ask the driver, and won't be restarteable
#define CM_DISABLE_BITS             (0x00000003)    // The bits for the disable function


//
// Flags for CM_Get_Device_ID_List, CM_Get_Device_ID_List_Size
//
#define CM_GETIDLIST_FILTER_NONE                (0x00000000)
#define CM_GETIDLIST_FILTER_ENUMERATOR          (0x00000001)
#define CM_GETIDLIST_FILTER_SERVICE             (0x00000002)
#define CM_GETIDLIST_FILTER_EJECTRELATIONS      (0x00000004)
#define CM_GETIDLIST_FILTER_REMOVALRELATIONS    (0x00000008)
#define CM_GETIDLIST_FILTER_POWERRELATIONS      (0x00000010)
#define CM_GETIDLIST_FILTER_BUSRELATIONS        (0x00000020)
#define CM_GETIDLIST_DONOTGENERATE              (0x10000040)
#define CM_GETIDLIST_FILTER_BITS                (0x1000007F)

//
// Flags for CM_Get_Device_Interface_List, CM_Get_Device_Interface_List_Size
//
#define CM_GET_DEVICE_INTERFACE_LIST_PRESENT     (0x00000000)  // only currently 'live' device interfaces
#define CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES (0x00000001)  // all registered device interfaces, live or not
#define CM_GET_DEVICE_INTERFACE_LIST_BITS        (0x00000001)

//
// Registry properties (specified in call to CM_Get_DevInst_Registry_Property,
// some are allowed in calls to CM_Set_DevInst_Registry_Property)
//
#define CM_DRP_DEVICEDESC                  (0x00000001) // DeviceDesc REG_SZ property (RW)
#define CM_DRP_HARDWAREID                  (0x00000002) // HardwareID REG_MULTI_SZ property (RW)
#define CM_DRP_COMPATIBLEIDS               (0x00000003) // CompatibleIDs REG_MULTI_SZ property (RW)
#define CM_DRP_UNUSED0                     (0x00000004) // unused
#define CM_DRP_SERVICE                     (0x00000005) // Service REG_SZ property (RW)
#define CM_DRP_UNUSED1                     (0x00000006) // unused
#define CM_DRP_UNUSED2                     (0x00000007) // unused
#define CM_DRP_CLASS                       (0x00000008) // Class REG_SZ property (RW)
#define CM_DRP_CLASSGUID                   (0x00000009) // ClassGUID REG_SZ property (RW)
#define CM_DRP_DRIVER                      (0x0000000A) // Driver REG_SZ property (RW)
#define CM_DRP_CONFIGFLAGS                 (0x0000000B) // ConfigFlags REG_DWORD property (RW)
#define CM_DRP_MFG                         (0x0000000C) // Mfg REG_SZ property (RW)
#define CM_DRP_FRIENDLYNAME                (0x0000000D) // FriendlyName REG_SZ property (RW)
#define CM_DRP_LOCATION_INFORMATION        (0x0000000E) // LocationInformation REG_SZ property (RW)
#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME (0x0000000F) // PhysicalDeviceObjectName REG_SZ property (R)
#define CM_DRP_CAPABILITIES                (0x00000010) // Capabilities REG_DWORD property (R)
#define CM_DRP_UI_NUMBER                   (0x00000011) // UiNumber REG_DWORD property (R)
#define CM_DRP_UPPERFILTERS                (0x00000012) // UpperFilters REG_MULTI_SZ property (RW)
#define CM_DRP_LOWERFILTERS                (0x00000013) // LowerFilters REG_MULTI_SZ property (RW)
#define CM_DRP_BUSTYPEGUID                 (0x00000014) // Bus Type Guid, GUID, (R)
#define CM_DRP_LEGACYBUSTYPE               (0x00000015) // Legacy bus type, INTERFACE_TYPE, (R)
#define CM_DRP_BUSNUMBER                   (0x00000016) // Bus Number, DWORD, (R)
#define CM_DRP_ENUMERATOR_NAME             (0x00000017) // Enumerator Name REG_SZ property (R)
#define CM_DRP_MIN                         (0x00000001)
#define CM_DRP_MAX                         (0x00000017)


//
// Capabilities bits (the capability value is returned from calling
// CM_Get_DevInst_Registry_Property with CM_DRP_CAPABILITIES flag)
//
#define CM_DEVCAP_LOCKSUPPORTED     (0x00000001)
#define CM_DEVCAP_EJECTSUPPORTED    (0x00000002)
#define CM_DEVCAP_REMOVABLE         (0x00000004)
#define CM_DEVCAP_DOCKDEVICE        (0x00000008)
#define CM_DEVCAP_UNIQUEID          (0x00000010)
#define CM_DEVCAP_SILENTINSTALL     (0x00000020)
#define CM_DEVCAP_RAWDEVICEOK       (0x00000040)
#define CM_DEVCAP_SURPRISEREMOVALOK (0x00000080)


//
// Flags for CM_Locate_DevNode
//
#define CM_LOCATE_DEVNODE_NORMAL       0x00000000
#define CM_LOCATE_DEVNODE_PHANTOM      0x00000001
#define CM_LOCATE_DEVNODE_CANCELREMOVE 0x00000002
#define CM_LOCATE_DEVNODE_NOVALIDATION 0x00000004
#define CM_LOCATE_DEVNODE_BITS         0x00000007

#define CM_LOCATE_DEVINST_NORMAL       CM_LOCATE_DEVNODE_NORMAL
#define CM_LOCATE_DEVINST_PHANTOM      CM_LOCATE_DEVNODE_PHANTOM
#define CM_LOCATE_DEVINST_CANCELREMOVE CM_LOCATE_DEVNODE_CANCELREMOVE
#define CM_LOCATE_DEVINST_NOVALIDATION CM_LOCATE_DEVNODE_NOVALIDATION
#define CM_LOCATE_DEVINST_BITS         CM_LOCATE_DEVNODE_BITS

//
// Flags for CM_Open_Class_Key
//
#define CM_OPEN_CLASS_KEY_INSTALLER        (0x00000000)
#define CM_OPEN_CLASS_KEY_INTERFACE        (0x00000001)
#define CM_OPEN_CLASS_KEY_BITS             (0x00000001)

//
// Remove subtree and Query remove subtree flags
//
#define CM_QUERY_REMOVE_UI_OK       0x00000000
#define CM_QUERY_REMOVE_UI_NOT_OK   0x00000001
#define CM_QUERY_REMOVE_BITS        0x00000001

#define CM_REMOVE_UI_OK             0x00000000
#define CM_REMOVE_UI_NOT_OK         0x00000001
#define CM_REMOVE_NO_RESTART        0x00000002
#define CM_REMOVE_BITS              0x00000003

//
// Flags for CM_Reenumerate_DevNode
//
#define CM_REENUMERATE_NORMAL       0x00000000
#define CM_REENUMERATE_SYNCHRONOUS  0x00000001
#define CM_REENUMERATE_BITS         0x00000001

//
// Flags for CM_Register_Device_Driver
//
#define CM_REGISTER_DEVICE_DRIVER_STATIC        (0x00000000)
#define CM_REGISTER_DEVICE_DRIVER_DISABLEABLE   (0x00000001)
#define CM_REGISTER_DEVICE_DRIVER_REMOVABLE     (0x00000002)
#define CM_REGISTER_DEVICE_DRIVER_BITS          (0x00000003)

//
// Registry Branch Locations (for CM_Open_DevNode_Key)
//
#define CM_REGISTRY_HARDWARE        (0x00000000)
#define CM_REGISTRY_SOFTWARE        (0x00000001)
#define CM_REGISTRY_USER            (0x00000100)
#define CM_REGISTRY_CONFIG          (0x00000200)
#define CM_REGISTRY_BITS            (0x00000301)

//
// Flags for CM_Set_DevNode_Problem
//
#define CM_SET_DEVNODE_PROBLEM_NORMAL    (0x00000000)  // only set problem if currently no problem
#define CM_SET_DEVNODE_PROBLEM_OVERRIDE  (0x00000001)  // override current problem with new problem
#define CM_SET_DEVNODE_PROBLEM_BITS      (0x00000001)

#define CM_SET_DEVINST_PROBLEM_NORMAL    CM_SET_DEVNODE_PROBLEM_NORMAL
#define CM_SET_DEVINST_PROBLEM_OVERRIDE  CM_SET_DEVNODE_PROBLEM_OVERRIDE
#define CM_SET_DEVINST_PROBLEM_BITS      CM_SET_DEVNODE_PROBLEM_BITS


//
// Re-enable and configuration actions (specified in call to CM_Setup_DevInst)
//
#define CM_SETUP_DEVNODE_READY   (0x00000000) // Reenable problem devinst
#define CM_SETUP_DEVINST_READY   CM_SETUP_DEVNODE_READY
#define CM_SETUP_DOWNLOAD        (0x00000001) // Get info about devinst
#define CM_SETUP_WRITE_LOG_CONFS (0x00000002)
#define CM_SETUP_PROP_CHANGE     (0x00000003)
#define CM_SETUP_BITS            (0x00000003)


//
// Flags for CM_Query_Arbitrator_Free_Data and
// CM_Query_Arbitrator_Free_Data_Size.
//
#define CM_QUERY_ARBITRATOR_RAW         (0x00000000)
#define CM_QUERY_ARBITRATOR_TRANSLATED  (0x00000001)
#define CM_QUERY_ARBITRATOR_BITS        (0x00000001)


//--------------------------------------------------------------
// Function prototypes
//--------------------------------------------------------------



CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf(
             OUT PLOG_CONF plcLogConf,
             IN  DEVINST   dnDevInst,
             IN  PRIORITY  Priority,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,
             IN  DEVINST   dnDevInst,
             IN  PRIORITY  Priority,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Add_IDA(
             IN DEVINST dnDevInst,
             IN PSTR    pszID,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_IDW(
             IN DEVINST dnDevInst,
             IN PWSTR   pszID,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_ID_ExA(
             IN DEVINST  dnDevInst,
             IN PSTR     pszID,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_ID_ExW(
             IN DEVINST  dnDevInst,
             IN PWSTR    pszID,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Add_ID             CM_Add_IDW
#define CM_Add_ID_Ex          CM_Add_ID_ExW
#else
#define CM_Add_ID             CM_Add_IDA
#define CM_Add_ID_Ex          CM_Add_ID_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Add_Range(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des(
             OUT PRES_DES  prdResDes,
             IN LOG_CONF   lcLogConf,
             IN RESOURCEID ResourceID,
             IN PCVOID     ResourceData,
             IN ULONG      ResourceLen,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des_Ex(
             OUT PRES_DES  prdResDes,
             IN LOG_CONF   lcLogConf,
             IN RESOURCEID ResourceID,
             IN PCVOID     ResourceData,
             IN ULONG      ResourceLen,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Connect_MachineA(
             IN  PCSTR     UNCServerName,
             OUT PHMACHINE phMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Connect_MachineW(
             IN  PCWSTR    UNCServerName,
             OUT PHMACHINE phMachine
             );
#ifdef UNICODE
#define CM_Connect_Machine       CM_Connect_MachineW
#else
#define CM_Connect_Machine       CM_Connect_MachineA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Create_DevNodeA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNodeW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNode_ExA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags,
             IN  HANDLE      hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNode_ExW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags,
             IN  HANDLE      hMachine
             );
#define CM_Create_DevInstW       CM_Create_DevNodeW
#define CM_Create_DevInstA       CM_Create_DevNodeA
#define CM_Create_DevInst_ExW    CM_Create_DevNode_ExW
#define CM_Create_DevInst_ExA    CM_Create_DevNode_ExA
#ifdef UNICODE
#define CM_Create_DevNode        CM_Create_DevNodeW
#define CM_Create_DevInst        CM_Create_DevNodeW
#define CM_Create_DevNode_Ex     CM_Create_DevNode_ExW
#define CM_Create_DevInst_Ex     CM_Create_DevInst_ExW
#else
#define CM_Create_DevNode        CM_Create_DevNodeA
#define CM_Create_DevInst        CM_Create_DevNodeA
#define CM_Create_DevNode_Ex     CM_Create_DevNode_ExA
#define CM_Create_DevInst_Ex     CM_Create_DevNode_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Create_Range_List(
             OUT PRANGE_LIST prlh,
             IN  ULONG       ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Delete_Class_Key(
             IN  LPGUID     ClassGuid,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Delete_Class_Key_Ex(
             IN  LPGUID     ClassGuid,
             IN  ULONG      ulFlags,
             IN  HANDLE     hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Delete_DevNode_Key(
             IN DEVNODE dnDevNode,
             IN ULONG   ulHardwareProfile,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Delete_DevNode_Key_Ex(
             IN DEVNODE dnDevNode,
             IN ULONG   ulHardwareProfile,
             IN ULONG   ulFlags,
             IN HANDLE  hMachine
             );
#define CM_Delete_DevInst_Key       CM_Delete_DevNode_Key
#define CM_Delete_DevInst_Key_Ex    CM_Delete_DevNode_Key_Ex


CMAPI
CONFIGRET
WINAPI
CM_Delete_Range(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict(
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             OUT PBOOL      pbConflictDetected,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict_Ex(
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             OUT PBOOL      pbConflictDetected,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Disable_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Disable_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Disable_DevInst       CM_Disable_DevNode
#define CM_Disable_DevInst_Ex    CM_Disable_DevNode_Ex



CMAPI
CONFIGRET
WINAPI
CM_Disconnect_Machine(
             IN HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Dup_Range_List(
             IN RANGE_LIST rlhOld,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Enable_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enable_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Enable_DevInst        CM_Enable_DevNode
#define CM_Enable_DevInst_Ex     CM_Enable_DevNode_Ex



CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Classes(
             IN  ULONG      ulClassIndex,
             OUT LPGUID     ClassGuid,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Classes_Ex(
             IN  ULONG      ulClassIndex,
             OUT LPGUID     ClassGuid,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Enumerate_EnumeratorsA(
             IN ULONG      ulEnumIndex,
             OUT PCHAR     Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_EnumeratorsW(
             IN ULONG      ulEnumIndex,
             OUT PWCHAR    Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Enumerators_ExA(
             IN ULONG      ulEnumIndex,
             OUT PCHAR     Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Enumerators_ExW(
             IN ULONG      ulEnumIndex,
             OUT PWCHAR    Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Enumerate_Enumerators       CM_Enumerate_EnumeratorsW
#define CM_Enumerate_Enumerators_Ex    CM_Enumerate_Enumerators_ExW
#else
#define CM_Enumerate_Enumerators       CM_Enumerate_EnumeratorsA
#define CM_Enumerate_Enumerators_Ex    CM_Enumerate_Enumerators_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Find_Range(
             OUT PDWORDLONG pullStart,
             IN  DWORDLONG  ullStart,
             IN  ULONG      ulLength,
             IN  DWORDLONG  ullAlignment,
             IN  DWORDLONG  ullEnd,
             IN  RANGE_LIST rlh,
             IN  ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_First_Range(
             IN  RANGE_LIST     rlh,
             OUT PDWORDLONG     pullStart,
             OUT PDWORDLONG     pullEnd,
             OUT PRANGE_ELEMENT preElement,
             IN  ULONG          ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf(
             IN LOG_CONF lcLogConfToBeFreed,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Ex(
             IN LOG_CONF lcLogConfToBeFreed,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Handle(
            IN  LOG_CONF  lcLogConf
            );


CMAPI
CONFIGRET
WINAPI
CM_Free_Range_List(
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des(
             IN PRES_DES prdResDes,
             IN RES_DES  rdResDes,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des_Ex(
             IN PRES_DES prdResDes,
             IN RES_DES  rdResDes,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des_Handle(
            IN  RES_DES    rdResDes
            );


CMAPI
CONFIGRET
WINAPI
CM_Get_Child(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Child_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Class_NameA(
             IN  LPGUID     ClassGuid,
             OUT PCHAR      Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_NameW(
             IN  LPGUID     ClassGuid,
             OUT PWCHAR     Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Name_ExA(
             IN  LPGUID     ClassGuid,
             OUT PCHAR      Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Name_ExW(
             IN  LPGUID     ClassGuid,
             OUT PWCHAR     Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Get_Class_Name        CM_Get_Class_NameW
#define CM_Get_Class_Name_Ex     CM_Get_Class_Name_ExW
#else
#define CM_Get_Class_Name        CM_Get_Class_NameA
#define CM_Get_Class_Name_Ex     CM_Get_Class_Name_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_NameA(
             IN  LPGUID     ClassGuid,
             OUT LPSTR      pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_NameW(
             IN  LPGUID     ClassGuid,
             OUT LPWSTR     pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_Name_ExA(
             IN  LPGUID     ClassGuid,
             OUT LPSTR      pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_Name_ExW(
             IN  LPGUID     ClassGuid,
             OUT LPWSTR     pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Get_Class_Key_Name        CM_Get_Class_Key_NameW
#define CM_Get_Class_Key_Name_Ex     CM_Get_Class_Key_Name_ExW
#else
#define CM_Get_Class_Key_Name        CM_Get_Class_Key_NameA
#define CM_Get_Class_Key_Name_Ex     CM_Get_Class_Key_Name_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Depth(
             OUT PULONG  pulDepth,
             IN  DEVINST dnDevInst,
             IN  ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Depth_Ex(
             OUT PULONG   pulDepth,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDA(
             IN  DEVINST  dnDevInst,
             OUT PCHAR    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExA(
             IN  DEVINST  dnDevInst,
             OUT PCHAR    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID         CM_Get_Device_IDW
#define CM_Get_Device_ID_Ex      CM_Get_Device_ID_ExW
#else
#define CM_Get_Device_ID         CM_Get_Device_IDA
#define CM_Get_Device_ID_Ex      CM_Get_Device_ID_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ListA(
             IN PCSTR    pszFilter,    OPTIONAL
             OUT PCHAR   Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ListW(
             IN PCWSTR   pszFilter,    OPTIONAL
             OUT PWCHAR  Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_ExA(
             IN PCSTR    pszFilter,    OPTIONAL
             OUT PCHAR   Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_ExW(
             IN PCWSTR   pszFilter,    OPTIONAL
             OUT PWCHAR  Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID_List       CM_Get_Device_ID_ListW
#define CM_Get_Device_ID_List_Ex    CM_Get_Device_ID_List_ExW
#else
#define CM_Get_Device_ID_List       CM_Get_Device_ID_ListA
#define CM_Get_Device_ID_List_Ex    CM_Get_Device_ID_List_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_SizeA(
             OUT PULONG  pulLen,
             IN PCSTR    pszFilter,   OPTIONAL
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_SizeW(
             OUT PULONG  pulLen,
             IN PCWSTR   pszFilter,   OPTIONAL
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_Size_ExA(
             OUT PULONG  pulLen,
             IN PCSTR    pszFilter,   OPTIONAL
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_Size_ExW(
             OUT PULONG  pulLen,
             IN PCWSTR   pszFilter,   OPTIONAL
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID_List_Size    CM_Get_Device_ID_List_SizeW
#define CM_Get_Device_ID_List_Size_Ex CM_Get_Device_ID_List_Size_ExW
#else
#define CM_Get_Device_ID_List_Size    CM_Get_Device_ID_List_SizeA
#define CM_Get_Device_ID_List_Size_Ex CM_Get_Device_ID_List_Size_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size(
             OUT PULONG   pulLen,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size_Ex(
             OUT PULONG   pulLen,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );



CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Get_DevInst_Registry_PropertyW     CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevInst_Registry_PropertyA     CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevInst_Registry_Property_ExW  CM_Get_DevNode_Registry_Property_ExW
#define CM_Get_DevInst_Registry_Property_ExA  CM_Get_DevNode_Registry_Property_ExA
#ifdef UNICODE
#define CM_Get_DevInst_Registry_Property      CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevInst_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExW
#define CM_Get_DevNode_Registry_Property      CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevNode_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExW
#else
#define CM_Get_DevInst_Registry_Property      CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevInst_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExA
#define CM_Get_DevNode_Registry_Property      CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevNode_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status_Ex(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
#define CM_Get_DevInst_Status    CM_Get_DevNode_Status
#define CM_Get_DevInst_Status_Ex CM_Get_DevNode_Status_Ex


CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  DEVINST   dnDevInst,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  DEVINST   dnDevInst,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Global_State(
             OUT PULONG pulState,
             IN  ULONG  ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Global_State_Ex(
             OUT PULONG   pulState,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_InfoA(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_A pHWProfileInfo,
             IN  ULONG            ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_Info_ExA(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_A pHWProfileInfo,
             IN  ULONG            ulFlags,
             IN  HMACHINE         hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_InfoW(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_W pHWProfileInfo,
             IN  ULONG            ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_Info_ExW(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_W pHWProfileInfo,
             IN  ULONG            ulFlags,
             IN  HMACHINE         hMachine
             );
#ifdef UNICODE
#define CM_Get_Hardware_Profile_Info      CM_Get_Hardware_Profile_InfoW
#define CM_Get_Hardware_Profile_Info_Ex   CM_Get_Hardware_Profile_Info_ExW
#else
#define CM_Get_Hardware_Profile_Info      CM_Get_Hardware_Profile_InfoA
#define CM_Get_Hardware_Profile_Info_Ex   CM_Get_Hardware_Profile_Info_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_FlagsA(
             IN  DEVINSTID_A szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_FlagsW(
             IN  DEVINSTID_W szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_Flags_ExA(
             IN  DEVINSTID_A szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_Flags_ExW(
             IN  DEVINSTID_W szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_HW_Prof_Flags     CM_Get_HW_Prof_FlagsW
#define CM_Get_HW_Prof_Flags_Ex  CM_Get_HW_Prof_Flags_ExW
#else
#define CM_Get_HW_Prof_Flags     CM_Get_HW_Prof_FlagsA
#define CM_Get_HW_Prof_Flags_Ex  CM_Get_HW_Prof_Flags_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasA(
    IN     LPCSTR  pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPSTR   pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasW(
    IN     LPCWSTR pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPWSTR  pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExA(
    IN     LPCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExW(
    IN     LPCWSTR  pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPWSTR   pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    );
#ifdef UNICODE
#define CM_Get_Device_Interface_Alias     CM_Get_Device_Interface_AliasW
#define CM_Get_Device_Interface_Alias_Ex  CM_Get_Device_Interface_Alias_ExW
#else
#define CM_Get_Device_Interface_Alias     CM_Get_Device_Interface_AliasA
#define CM_Get_Device_Interface_Alias_Ex  CM_Get_Device_Interface_Alias_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListA(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             OUT PCHAR       Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListW(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             OUT PWCHAR      Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExA(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             OUT PCHAR       Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExW(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             OUT PWCHAR      Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_Interface_List     CM_Get_Device_Interface_ListW
#define CM_Get_Device_Interface_List_Ex  CM_Get_Device_Interface_List_ExW
#else
#define CM_Get_Device_Interface_List     CM_Get_Device_Interface_ListA
#define CM_Get_Device_Interface_List_Ex  CM_Get_Device_Interface_List_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeA(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeW(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExA(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExW(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_Interface_List_Size     CM_Get_Device_Interface_List_SizeW
#define CM_Get_Device_Interface_List_Size_Ex  CM_Get_Device_Interface_List_Size_ExW
#else
#define CM_Get_Device_Interface_List_Size     CM_Get_Device_Interface_List_SizeA
#define CM_Get_Device_Interface_List_Size_Ex  CM_Get_Device_Interface_List_Size_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority(
        IN  LOG_CONF  lcLogConf,
        OUT PPRIORITY pPriority,
        IN  ULONG     ulFlags
        );
CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority_Ex(
        IN  LOG_CONF  lcLogConf,
        OUT PPRIORITY pPriority,
        IN  ULONG     ulFlags,
        IN  HMACHINE  hMachine
        );


CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf(
             OUT PLOG_CONF plcLogConf,  OPTIONAL
             IN  LOG_CONF  lcLogConf,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  LOG_CONF  lcLogConf,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Parent(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Parent_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data(
             IN  RES_DES  rdResDes,
             OUT PVOID    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Ex(
             IN  RES_DES  rdResDes,
             OUT PVOID    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size(
             OUT PULONG   pulSize,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size_Ex(
             OUT PULONG   pulSize,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );



CMAPI
WORD
WINAPI
CM_Get_Version(
             VOID
             );
CMAPI
WORD
WINAPI
CM_Get_Version_Ex(
             IN  HMACHINE    hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Intersect_Range_List(
             IN RANGE_LIST rlhOld1,
             IN RANGE_LIST rlhOld2,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Invert_Range_List(
             IN RANGE_LIST rlhOld,
             IN RANGE_LIST rlhNew,
             IN DWORDLONG  ullMaxValue,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,    OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNode_ExA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,    OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNode_ExW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Locate_DevInstA       CM_Locate_DevNodeA
#define CM_Locate_DevInstW       CM_Locate_DevNodeW
#define CM_Locate_DevInst_ExA    CM_Locate_DevNode_ExA
#define CM_Locate_DevInst_ExW    CM_Locate_DevNode_ExW
#ifdef UNICODE
#define CM_Locate_DevNode        CM_Locate_DevNodeW
#define CM_Locate_DevInst        CM_Locate_DevNodeW
#define CM_Locate_DevNode_Ex     CM_Locate_DevNode_ExW
#define CM_Locate_DevInst_Ex     CM_Locate_DevNode_ExW
#else
#define CM_Locate_DevNode        CM_Locate_DevNodeA
#define CM_Locate_DevInst        CM_Locate_DevNodeA
#define CM_Locate_DevNode_Ex     CM_Locate_DevNode_ExA
#define CM_Locate_DevInst_Ex     CM_Locate_DevNode_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Merge_Range_List(
             IN RANGE_LIST rlhOld1,
             IN RANGE_LIST rlhOld2,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Modify_Res_Des(
             OUT PRES_DES   prdResDes,
             IN  RES_DES    rdResDes,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Modify_Res_Des_Ex(
             OUT PRES_DES   prdResDes,
             IN  RES_DES    rdResDes,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Move_DevNode(
             IN DEVINST  dnFromDevInst,
             IN DEVINST  dnToDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Move_DevNode_Ex(
             IN DEVINST  dnFromDevInst,
             IN DEVINST  dnToDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Move_DevInst          CM_Move_DevNode
#define CM_Move_DevInst_Ex       CM_Move_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Next_Range(
             IN OUT PRANGE_ELEMENT preElement,
             OUT PDWORDLONG        pullStart,
             OUT PDWORDLONG        pullEnd,
             IN  ULONG             ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des(
             OUT PRES_DES    prdResDes,
             IN  RES_DES     rdResDes,
             IN  RESOURCEID  ForResource,
             OUT PRESOURCEID pResourceID,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des_Ex(
             OUT PRES_DES    prdResDes,
             IN  RES_DES     rdResDes,
             IN  RESOURCEID  ForResource,
             OUT PRESOURCEID pResourceID,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Open_Class_KeyA(
             IN  LPGUID         ClassGuid,      OPTIONAL
             IN  LPCSTR         pszClassName,   OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_KeyW(
             IN  LPGUID         ClassGuid,      OPTIONAL
             IN  LPCWSTR        pszClassName,   OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_Key_ExA(
             IN  LPGUID         pszClassGuid,      OPTIONAL
             IN  LPCSTR         pszClassName,      OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_Key_ExW(
             IN  LPGUID         pszClassGuid,      OPTIONAL
             IN  LPCWSTR        pszClassName,      OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

#ifdef UNICODE
#define CM_Open_Class_Key        CM_Open_Class_KeyW
#define CM_Open_Class_Key_Ex     CM_Open_Class_Key_ExW
#else
#define CM_Open_Class_Key        CM_Open_Class_KeyA
#define CM_Open_Class_Key_Ex     CM_Open_Class_Key_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key(
             IN  DEVINST        dnDevNode,
             IN  REGSAM         samDesired,
             IN  ULONG          ulHardwareProfile,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkDevice,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key_Ex(
             IN  DEVINST        dnDevNode,
             IN  REGSAM         samDesired,
             IN  ULONG          ulHardwareProfile,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkDevice,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );
#define CM_Open_DevInst_Key      CM_Open_DevNode_Key
#define CM_Open_DevInst_Key_Ex   CM_Open_DevNode_Key_Ex


CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Data(
             OUT PVOID      pData,
             IN  ULONG      DataLen,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Data_Ex(
             OUT PVOID      pData,
             IN  ULONG      DataLen,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Size(
             OUT PULONG     pulSize,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Size_Ex(
             OUT PULONG     pulSize,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Query_Remove_SubTree(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Remove_SubTree_Ex(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Reenumerate_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Reenumerate_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Reenumerate_DevInst      CM_Reenumerate_DevNode
#define CM_Reenumerate_DevInst_Ex   CM_Reenumerate_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceA(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCSTR    pszReference,         OPTIONAL
             OUT LPSTR     pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceW(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCWSTR   pszReference,         OPTIONAL
             OUT LPWSTR    pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExA(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCSTR    pszReference,         OPTIONAL
             OUT LPSTR     pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExW(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCWSTR   pszReference,         OPTIONAL
             OUT LPWSTR    pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );
#ifdef UNICODE
#define CM_Register_Device_Interface    CM_Register_Device_InterfaceW
#define CM_Register_Device_Interface_Ex CM_Register_Device_Interface_ExW
#else
#define CM_Register_Device_Interface    CM_Register_Device_InterfaceA
#define CM_Register_Device_Interface_Ex CM_Register_Device_Interface_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Problem(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags
    );
#define CM_Set_DevInst_Problem      CM_Set_DevNode_Problem
#define CM_Set_DevInst_Problem_Ex   CM_Set_DevNode_Problem_Ex


CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceA(
             IN LPCSTR pszDeviceInterface,
             IN ULONG  ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceW(
             IN LPCWSTR pszDeviceInterface,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExA(
             IN LPCSTR   pszDeviceInterface,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExW(
             IN LPCWSTR  pszDeviceInterface,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Unregister_Device_Interface    CM_Unregister_Device_InterfaceW
#define CM_Unregister_Device_Interface_Ex CM_Unregister_Device_Interface_ExW
#else
#define CM_Unregister_Device_Interface    CM_Unregister_Device_InterfaceA
#define CM_Unregister_Device_Interface_Ex CM_Unregister_Device_Interface_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Driver(
            IN DEVINST  dnDevInst,
            IN ULONG    ulFlags
            );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Driver_Ex(
            IN DEVINST  dnDevInst,
            IN ULONG    ulFlags,
            IN HMACHINE hMachine
            );

CMAPI
CONFIGRET
WINAPI
CM_Remove_SubTree(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Remove_SubTree_Ex(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );



CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_PropertyA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_Property_ExA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Set_DevInst_Registry_PropertyW     CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevInst_Registry_PropertyA     CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevInst_Registry_Property_ExW  CM_Set_DevNode_Registry_Property_ExW
#define CM_Set_DevInst_Registry_Property_ExA  CM_Set_DevNode_Registry_Property_ExA
#ifdef UNICODE
#define CM_Set_DevInst_Registry_Property      CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevInst_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExW
#define CM_Set_DevNode_Registry_Property      CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevNode_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExW
#else
#define CM_Set_DevInst_Registry_Property      CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevInst_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExA
#define CM_Set_DevNode_Registry_Property      CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevNode_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExA
#endif // UNICODE




CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_FlagsA(
             IN DEVINSTID_A szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_FlagsW(
             IN DEVINSTID_W szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Flags_ExA(
             IN DEVINSTID_A szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags,
             IN HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Flags_ExW(
             IN DEVINSTID_W szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags,
             IN HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Set_HW_Prof_Flags     CM_Set_HW_Prof_FlagsW
#define CM_Set_HW_Prof_Flags_Ex  CM_Set_HW_Prof_Flags_ExW
#else
#define CM_Set_HW_Prof_Flags     CM_Set_HW_Prof_FlagsA
#define CM_Set_HW_Prof_Flags_Ex  CM_Set_HW_Prof_Flags_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Setup_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Setup_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Setup_DevInst         CM_Setup_DevNode
#define CM_Setup_DevInst_EX      CM_Setup_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Test_Range_Available(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Uninstall_DevNode(
             IN DEVNODE dnPhantom,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Uninstall_DevNode_Ex(
             IN DEVNODE dnPhantom,
             IN ULONG   ulFlags,
             IN HANDLE  hMachine
             );
#define CM_Uninstall_DevInst     CM_Uninstall_DevNode
#define CM_Uninstall_DevInst_Ex  CM_Uninstall_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present(
             OUT PBOOL pbPresent
             );

CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC(
             VOID
             );

CMAPI
CONFIGRET
WINAPI
CM_Run_Detection(
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Run_Detection_Ex(
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof(
             IN ULONG    ulHardwareProfile,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Ex(
             IN ULONG    ulHardwareProfile,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


//--------------------------------------------------------------
// Configuration Manager return status codes
//--------------------------------------------------------------

#define CR_SUCCESS                  (0x00000000)
#define CR_DEFAULT                  (0x00000001)
#define CR_OUT_OF_MEMORY            (0x00000002)
#define CR_INVALID_POINTER          (0x00000003)
#define CR_INVALID_FLAG             (0x00000004)
#define CR_INVALID_DEVNODE          (0x00000005)
#define CR_INVALID_DEVINST          CR_INVALID_DEVNODE
#define CR_INVALID_RES_DES          (0x00000006)
#define CR_INVALID_LOG_CONF         (0x00000007)
#define CR_INVALID_ARBITRATOR       (0x00000008)
#define CR_INVALID_NODELIST         (0x00000009)
#define CR_DEVNODE_HAS_REQS         (0x0000000A)
#define CR_DEVINST_HAS_REQS         CR_DEVNODE_HAS_REQS
#define CR_INVALID_RESOURCEID       (0x0000000B)
#define CR_DLVXD_NOT_FOUND          (0x0000000C)   // WIN 95 ONLY
#define CR_NO_SUCH_DEVNODE          (0x0000000D)
#define CR_NO_SUCH_DEVINST          CR_NO_SUCH_DEVNODE
#define CR_NO_MORE_LOG_CONF         (0x0000000E)
#define CR_NO_MORE_RES_DES          (0x0000000F)
#define CR_ALREADY_SUCH_DEVNODE     (0x00000010)
#define CR_ALREADY_SUCH_DEVINST     CR_ALREADY_SUCH_DEVNODE
#define CR_INVALID_RANGE_LIST       (0x00000011)
#define CR_INVALID_RANGE            (0x00000012)
#define CR_FAILURE                  (0x00000013)
#define CR_NO_SUCH_LOGICAL_DEV      (0x00000014)
#define CR_CREATE_BLOCKED           (0x00000015)
#define CR_NOT_SYSTEM_VM            (0x00000016)   // WIN 95 ONLY
#define CR_REMOVE_VETOED            (0x00000017)
#define CR_APM_VETOED               (0x00000018)
#define CR_INVALID_LOAD_TYPE        (0x00000019)
#define CR_BUFFER_SMALL             (0x0000001A)
#define CR_NO_ARBITRATOR            (0x0000001B)
#define CR_NO_REGISTRY_HANDLE       (0x0000001C)
#define CR_REGISTRY_ERROR           (0x0000001D)
#define CR_INVALID_DEVICE_ID        (0x0000001E)
#define CR_INVALID_DATA             (0x0000001F)
#define CR_INVALID_API              (0x00000020)
#define CR_DEVLOADER_NOT_READY      (0x00000021)
#define CR_NEED_RESTART             (0x00000022)
#define CR_NO_MORE_HW_PROFILES      (0x00000023)
#define CR_DEVICE_NOT_THERE         (0x00000024)
#define CR_NO_SUCH_VALUE            (0x00000025)
#define CR_WRONG_TYPE               (0x00000026)
#define CR_INVALID_PRIORITY         (0x00000027)
#define CR_NOT_DISABLEABLE          (0x00000028)
#define CR_FREE_RESOURCES           (0x00000029)
#define CR_QUERY_VETOED             (0x0000002A)
#define CR_CANT_SHARE_IRQ           (0x0000002B)
#define CR_NO_DEPENDENT             (0x0000002C)
#define CR_SAME_RESOURCES           (0x0000002D)
#define CR_NO_SUCH_REGISTRY_KEY     (0x0000002E)
#define CR_INVALID_MACHINENAME      (0x0000002F)   // NT ONLY
#define CR_REMOTE_COMM_FAILURE      (0x00000030)   // NT ONLY
#define CR_MACHINE_UNAVAILABLE      (0x00000031)   // NT ONLY
#define CR_NO_CM_SERVICES           (0x00000032)   // NT ONLY
#define CR_ACCESS_DENIED            (0x00000033)   // NT ONLY
#define CR_CALL_NOT_IMPLEMENTED     (0x00000034)
#define CR_INVALID_PROPERTY         (0x00000035)
#define CR_DEVICE_INTERFACE_ACTIVE  (0x00000036)
#define CR_NO_SUCH_DEVICE_INTERFACE (0x00000037)
#define CR_INVALID_REFERENCE_STRING (0x00000038)
#define NUM_CR_RESULTS              (0x00000039)



#endif // _CFGMGR32_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\cfg.h ===
/*++



Copyright (c) 1989-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    cfg.h

Abstract:

    This module contains the common Configuration Manager definitions for
    both user mode and kernel mode code.

Author:

    Paula Tomlinson (paulat) 06/19/1995

Revision History:

--*/

#ifndef _CFG_INCLUDED_
#define _CFG_INCLUDED_

//
// The following definitions are also used by kernel mode code to
// set up the registry.
//

//
// DevInst problem values, returned by call to CM_Get_DevInst_Status
//
#define CM_PROB_NOT_CONFIGURED         (0x00000001)   // no config for device
#define CM_PROB_DEVLOADER_FAILED       (0x00000002)   // service load failed
#define CM_PROB_OUT_OF_MEMORY          (0x00000003)   // out of memory
#define CM_PROB_ENTRY_IS_WRONG_TYPE    (0x00000004)   //
#define CM_PROB_LACKED_ARBITRATOR      (0x00000005)   //
#define CM_PROB_BOOT_CONFIG_CONFLICT   (0x00000006)   // boot config conflict
#define CM_PROB_FAILED_FILTER          (0x00000007)   //
#define CM_PROB_DEVLOADER_NOT_FOUND    (0x00000008)   // Devloader not found
#define CM_PROB_INVALID_DATA           (0x00000009)   //
#define CM_PROB_FAILED_START           (0x0000000A)   //
#define CM_PROB_LIAR                   (0x0000000B)   //
#define CM_PROB_NORMAL_CONFLICT        (0x0000000C)   // config conflict
#define CM_PROB_NOT_VERIFIED           (0x0000000D)   //
#define CM_PROB_NEED_RESTART           (0x0000000E)   // requires restart
#define CM_PROB_REENUMERATION          (0x0000000F)   //
#define CM_PROB_PARTIAL_LOG_CONF       (0x00000010)   //
#define CM_PROB_UNKNOWN_RESOURCE       (0x00000011)   // unknown res type
#define CM_PROB_REINSTALL              (0x00000012)   //
#define CM_PROB_REGISTRY               (0x00000013)   //
#define CM_PROB_VXDLDR                 (0x00000014)   // WINDOWS 95 ONLY
#define CM_PROB_WILL_BE_REMOVED        (0x00000015)   // devinst will remove
#define CM_PROB_DISABLED               (0x00000016)   // devinst is disabled
#define CM_PROB_DEVLOADER_NOT_READY    (0x00000017)   // Devloader not ready
#define CM_PROB_DEVICE_NOT_THERE       (0x00000018)   // device doesn't exist
#define CM_PROB_MOVED                  (0x00000019)   //
#define CM_PROB_TOO_EARLY              (0x0000001A)   //
#define CM_PROB_NO_VALID_LOG_CONF      (0x0000001B)   // no valid log config
#define CM_PROB_FAILED_INSTALL         (0x0000001C)   // install failed
#define CM_PROB_HARDWARE_DISABLED      (0x0000001D)   // device disabled
#define CM_PROB_CANT_SHARE_IRQ         (0x0000001E)   // can't share IRQ
#define CM_PROB_FAILED_ADD             (0x0000001F)   // driver failed add
#define NUM_CM_PROB                    (0x00000020)

//
// Configuration Manager Global State Flags (returned by CM_Get_Global_State)
//
#define CM_GLOBAL_STATE_CAN_DO_UI            (0x00000001) // Can  do UI?
#define CM_GLOBAL_STATE_ON_BIG_STACK         (0x00000002) // WINDOWS 95 ONLY
#define CM_GLOBAL_STATE_SERVICES_AVAILABLE   (0x00000004) // CM APIs available?
#define CM_GLOBAL_STATE_SHUTTING_DOWN        (0x00000008) // CM shutting down
#define CM_GLOBAL_STATE_DETECTION_PENDING    (0x00000010) // detection pending

//
// Device Instance status flags, returned by call to CM_Get_DevInst_Status
//
#define DN_ROOT_ENUMERATED (0x00000001) // Was enumerated by ROOT
#define DN_DRIVER_LOADED   (0x00000002) // Has Register_Device_Driver
#define DN_ENUM_LOADED     (0x00000004) // Has Register_Enumerator
#define  DN_STARTED         (0x00000008) // Is currently configured
#define DN_MANUAL          (0x00000010) // Manually installed
#define DN_NEED_TO_ENUM    (0x00000020) // May need reenumeration
#define DN_NOT_FIRST_TIME  (0x00000040) // Has received a config
#define DN_HARDWARE_ENUM   (0x00000080) // Enum generates hardware ID
#define DN_LIAR            (0x00000100) // Lied about can reconfig once
#define DN_HAS_MARK        (0x00000200) // Not CM_Create_DevInst lately
#define DN_HAS_PROBLEM     (0x00000400) // Need device installer
#define DN_FILTERED        (0x00000800) // Is filtered
#define DN_MOVED           (0x00001000) // Has been moved
#define DN_DISABLEABLE     (0x00002000) // Can be rebalanced
#define DN_REMOVABLE       (0x00004000) // Can be removed
#define DN_PRIVATE_PROBLEM (0x00008000) // Has a private problem
#define DN_MF_PARENT       (0x00010000) // Multi function parent
#define DN_MF_CHILD        (0x00020000) // Multi function child
#define DN_WILL_BE_REMOVED (0x00040000) // DevInst is being removed

//
// Windows 4 OPK2 Flags
//
#define DN_NOT_FIRST_TIMEE  0x00080000  // S: Has received a config enumerate
#define DN_STOP_FREE_RES    0x00100000  // S: When child is stopped, free resources
#define DN_REBAL_CANDIDATE  0x00200000  // S: Don't skip during rebalance
#define DN_BAD_PARTIAL      0x00400000  // S: This devnode's log_confs do not have same resources
#define DN_NT_ENUMERATOR    0x00800000  // S: This devnode's is an NT enumerator
#define DN_NT_DRIVER        0x01000000  // S: This devnode's is an NT driver
//
// Windows 4.1 Flags
//
#define DN_NEEDS_LOCKING    0x02000000  // S: Devnode need lock resume processing
#define DN_ARM_WAKEUP       0x04000000  // S: Devnode can be the wakeup device
#define DN_APM_ENUMERATOR   0x08000000  // S: APM aware enumerator
#define DN_APM_DRIVER       0x10000000  // S: APM aware driver
#define DN_SILENT_INSTALL   0x20000000  // S: Silent install
#define DN_NO_SHOW_IN_DM    0x40000000  // S: No show in device manager
#define DN_BOOT_LOG_PROB    0x80000000  // S: Had a problem during preassignment of boot log conf

#define DN_CHANGEABLE_FLAGS (DN_NOT_FIRST_TIME+\
                DN_HARDWARE_ENUM+\
                DN_HAS_MARK+\
                DN_DISABLEABLE+\
                DN_REMOVABLE+\
                DN_MF_CHILD+\
                DN_MF_PARENT+\
                DN_NOT_FIRST_TIMEE+\
                DN_STOP_FREE_RES+\
                DN_REBAL_CANDIDATE+\
                DN_NT_ENUMERATOR+\
                DN_NT_DRIVER+\
                DN_SILENT_INSTALL+\
                DN_NO_SHOW_IN_DM)

//
// Logical configuration Priority values
//
// These priority values are used in user-mode calls to CM_Add_Empty_Log_Conf.
// Drivers may also specify priority values for a given IO_RESOURCE_LIST
// structure by including a ConfigData member union as the first
// IO_RESOURCE_DESCRIPTOR in the IO_RESOURCE_LIST. In this case, the descriptor
// type would be CmResourceTypeConfigData.
//
#define LCPRI_FORCECONFIG     (0x00000000) // Coming from a forced config
#define LCPRI_BOOTCONFIG      (0x00000001) // Coming from a boot config
#define LCPRI_DESIRED         (0x00002000) // Preferable (better performance)
#define LCPRI_NORMAL          (0x00003000) // Workable (acceptable performance)
#define LCPRI_LASTBESTCONFIG  (0x00003FFF) // CM only--do not use
#define LCPRI_SUBOPTIMAL      (0x00005000) // Not desired, but will work
#define LCPRI_LASTSOFTCONFIG  (0x00007FFF) // CM only--do not use
#define LCPRI_RESTART         (0x00008000) // Need to restart
#define LCPRI_REBOOT          (0x00009000) // Need to reboot
#define LCPRI_POWEROFF        (0x0000A000) // Need to shutdown/power-off
#define LCPRI_HARDRECONFIG    (0x0000C000) // Need to change a jumper
#define LCPRI_HARDWIRED       (0x0000E000) // Cannot be changed
#define LCPRI_IMPOSSIBLE      (0x0000F000) // Impossible configuration
#define LCPRI_DISABLED        (0x0000FFFF) // Disabled configuration
#define MAX_LCPRI             (0x0000FFFF) // Maximum known LC Priority


#endif // _CFG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\cfgmgrcomputer.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <stdafx.h>
#include "cfgmgrcomputer.h"

CConfigMgrComputer::CConfigMgrComputer( LPCTSTR pszName )
:	m_strName( pszName ),
	m_hMachine( NULL )
{
	CONFIGRET	cr = CR_SUCCESS;

	if ( CR_SUCCESS != ( cr = g_configmgr.CM_Connect_Machine( pszName, &m_hMachine ) ) )
	{
		ASSERT(0);
	}
}

CConfigMgrComputer::~CConfigMgrComputer( void )
{
	if ( NULL != m_hMachine )
	{
		g_configmgr.CM_Disconnect_Machine( m_hMachine );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\configmgr32.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <stdafx.h>
#include "configmgr32.h"

CConfigMgr32	g_configmgr;

// String array for converting between 32-bit ULONG Constants and
// corresponding registry strings in 16-bit land

char*	CConfigMgr32::s_pszRegistryStrings[]	=	{
													CM_DRP_DEVICEDESC_S,
													CM_DRP_HARDWAREID_S,
													CM_DRP_COMPATIBLEIDS_S,
													CM_DRP_NTDEVICEPATHS_S,
													CM_DRP_SERVICE_S,
													CM_DRP_CONFIGURATION_S,
													CM_DRP_CONFIGURATIONVECTOR_S,
													CM_DRP_CLASS_S,
													CM_DRP_CLASSGUID_S,
													CM_DRP_DRIVER_S,
													CM_DRP_CONFIGFLAGS_S,
													CM_DRP_MFG_S,
													CM_DRP_FRIENDLYNAME_S,
													CM_DRP_LOCATION_INFORMATION_S,
													CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S,
													CM_DRP_CAPABILITIES_S,
													CM_DRP_UI_NUMBER_S,
													CM_DRP_UPPERFILTERS_S,
													CM_DRP_LOWERFILTERS_S,
													CM_DRP_BUSTYPEGUID_S,
													CM_DRP_LEGACYBUSTYPE_S,
													CM_DRP_BUSNUMBER_S,
													CM_DRP_ENUMERATOR_NAME_S,
													CM_DRP_MAX_S
												};

ULONG	CConfigMgr32::s_pszRegistryValueTypes[]	=	{
														REG_SZ,	// CM_DRP_DEVICEDESC_S
														REG_SZ,	// CM_DRP_HARDWAREID_S
														REG_SZ,	// CM_DRP_COMPATIBLEIDS_S
														REG_SZ,	// CM_DRP_NTDEVICEPATHS_S
														REG_SZ,	// CM_DRP_SERVICE_S
														REG_SZ,	// CM_DRP_CONFIGURATION_S
														REG_SZ,	// CM_DRP_CONFIGURATIONVECTOR_S
														REG_SZ,	// CM_DRP_CLASS_S
														REG_SZ,	// CM_DRP_CLASSGUID_S
														REG_SZ,	// CM_DRP_DRIVER_S
														REG_BINARY,	// CM_DRP_CONFIGFLAGS_S
														REG_SZ,	// CM_DRP_MFG_S
														REG_SZ,	// CM_DRP_FRIENDLYNAME_S
														REG_SZ,	// CM_DRP_LOCATION_INFORMATION_S
														REG_BINARY,	// CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S
														REG_BINARY,	// CM_DRP_CAPABILITIES_S
														REG_SZ,	// CM_DRP_UI_NUMBER_S
														REG_SZ,	// CM_DRP_UPPERFILTERS_S
														REG_SZ,	// CM_DRP_LOWERFILTERS_S
														REG_SZ,	// CM_DRP_BUSTYPEGUID_S	
														REG_BINARY,	// CM_DRP_LEGACYBUSTYPE_S
														REG_BINARY,	// CM_DRP_BUSNUMBER_S
														REG_SZ,	// CM_DRP_ENUMERATOR_NAME_S
														REG_SZ	// CM_DRP_MAX_S
													};

CConfigMgr32::CConfigMgr32( void )
:	m_hConfigMgrDll( NULL ),
	m_pCM_Connect_MachineA( NULL ),
	m_pCM_Disconnect_Machine( NULL ),
	m_pCM_Locate_DevNodeA( NULL ),
	m_pCM_Get_Child( NULL ),
	m_pCM_Get_Sibling( NULL ),
	m_pCM_Get_DevNode_Registry_PropertyA( NULL ),
	m_pCM_Get_DevNode_Status( NULL ),
	m_pCM_Get_First_Log_Config( NULL ),
	m_pCM_Get_Next_Res_Des( NULL ),
	m_pCM_Get_Res_Des_Data( NULL ),
	m_pCM_Get_Res_Des_Data_Size( NULL ),
	m_pCM_Free_Log_Conf_Handle( NULL ),
	m_pCM_Free_Res_Des_Handle( NULL ),
	m_pCM_Get_Device_IDA( NULL ),
	m_pCM_Get_Device_ID_Size( NULL ),
	m_pCM16_Locate_DevNode( NULL ),
	m_pCM16_Get_Child( NULL ),
	m_pCM16_Get_Sibling( NULL ),
	m_pCM16_Read_Registry_Value( NULL ),
	m_pCM16_Get_DevNode_Status( NULL ),
	m_pCM16_Get_Device_ID( NULL ),
	m_pCM16_Get_Device_ID_Size( NULL ),
	m_pCM16_Get_First_Log_Conf( NULL ),
	m_pCM16_Get_Next_Res_Des( NULL ),
	m_pCM16_Get_Res_Des_Data_Size( NULL ),
	m_pCM16_Get_Res_Des_Data( NULL ),
	m_pCM16_Get_Bus_Info( NULL ),
	m_pCM_Get_Parent( NULL ),
	m_pCM16_Get_Parent( NULL )
{
	if ( IsWinNT() )
	{

		m_hConfigMgrDll = LoadLibrary("CFGMGR32.DLL");

		if ( NULL != m_hConfigMgrDll )
		{
			m_pCM_Connect_MachineA		=	(PCFGMGR32_CM_CONNECT_MACHINEA)		GetProcAddress( m_hConfigMgrDll, "CM_Connect_MachineA" );
			m_pCM_Disconnect_Machine	=	(PCFGMGR32_CM_DISCONNECT_MACHINE)	GetProcAddress( m_hConfigMgrDll, "CM_Disconnect_Machine" );
			m_pCM_Locate_DevNodeA		=	(PCFGMGR32_CM_LOCATE_DEVNODEA)	GetProcAddress( m_hConfigMgrDll, "CM_Locate_DevNodeA" );
			m_pCM_Get_Child				=	(PCFGMGR32_CM_GET_CHILD)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Child" );
			m_pCM_Get_Sibling			=	(PCFGMGR32_CM_GET_SIBLING)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Sibling" );
			m_pCM_Get_DevNode_Registry_PropertyA	=	(PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTYA)	GetProcAddress( m_hConfigMgrDll, "CM_Get_DevNode_Registry_PropertyA" );
			m_pCM_Get_DevNode_Status	=	(PCFGMGR32_CM_GET_DEVNODE_STATUS)	GetProcAddress( m_hConfigMgrDll, "CM_Get_DevNode_Status" );
			m_pCM_Get_First_Log_Config	=	(PCFGMGR32_CM_GET_FIRST_LOG_CONF)	GetProcAddress( m_hConfigMgrDll, "CM_Get_First_Log_Conf" );
			m_pCM_Get_Next_Res_Des		=	(PCFGMGR32_CM_GET_NEXT_RES_DES)		GetProcAddress( m_hConfigMgrDll, "CM_Get_Next_Res_Des" );
			m_pCM_Get_Res_Des_Data		=	(PCFGMGR32_CM_GET_RES_DES_DATA)		GetProcAddress( m_hConfigMgrDll, "CM_Get_Res_Des_Data" );
			m_pCM_Get_Res_Des_Data_Size	=	(PCFGMGR32_CM_GET_RES_DES_DATA_SIZE)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Res_Des_Data_Size" );
			m_pCM_Free_Log_Conf_Handle	=	(PCFGMGR32_CM_FREE_LOG_CONF_HANDLE)	GetProcAddress( m_hConfigMgrDll, "CM_Free_Log_Conf_Handle" );
			m_pCM_Free_Res_Des_Handle	=	(PCFGMGR32_CM_FREE_RES_DES_HANDLE)	GetProcAddress( m_hConfigMgrDll, "CM_Free_Res_Des_Handle" );
			m_pCM_Get_Device_IDA		=	(PCFGMGR32_CM_GET_DEVICE_IDA)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Device_IDA" );
			m_pCM_Get_Device_ID_Size	=	(PCFGMGR32_CM_GET_DEVICE_ID_SIZE)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Device_ID_Size" );
			m_pCM_Get_Parent			=	(PCFGMGR32_CM_GET_PARENT)			GetProcAddress( m_hConfigMgrDll, "CM_Get_Parent" );
		}

	}
	else
	{
		m_hConfigMgrDll = LoadLibrary( CIM32NET_DLL );

		if ( NULL != m_hConfigMgrDll )
		{
			m_pCM16_Locate_DevNode			=	(PCIM32THK_CM_LOCATE_DEVNODE)			GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Locate_DevNode" );
			m_pCM16_Get_Child				=	(PCIM32THK_CM_GET_CHILD)				GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Child" );
			m_pCM16_Get_Sibling				=	(PCIM32THK_CM_GET_SIBLING)				GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Sibling" );
			m_pCM16_Read_Registry_Value		=	(PCIM32THK_CM_READ_REGISTRY_VALUE)		GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Read_Registry_Value" );
			m_pCM16_Get_DevNode_Status		=	(PCIM32THK_CM_GET_DEVNODE_STATUS)		GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_DevNode_Status" );
			m_pCM16_Get_Device_ID			=	(PCIM32THK_CM_GET_DEVICE_ID)			GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Device_ID" );
			m_pCM16_Get_Device_ID_Size		=	(PCIM32THK_CM_GET_DEVICE_ID_SIZE)		GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Device_ID_Size" );
			m_pCM16_Get_First_Log_Conf		=	(PCIM32THK_CM_GET_FIRST_LOG_CONF)		GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_First_Log_Conf" );
			m_pCM16_Get_Next_Res_Des		=	(PCIM32THK_CM_GET_NEXT_RES_DES)			GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Next_Res_Des" );
			m_pCM16_Get_Res_Des_Data_Size	=	(PCIM32THK_CM_GET_RES_DES_DATA_SIZE)	GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Res_Des_Data_Size" );
			m_pCM16_Get_Res_Des_Data		=	(PCIM32THK_CM_GET_RES_DES_DATA)			GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Res_Des_Data" );
			m_pCM16_Get_Bus_Info			=	(PCIM32THK_CM_GET_BUS_INFO)				GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Bus_Info" );
			m_pCM16_Get_Parent				=	(PCIM32THK_CM_GET_PARENT)				GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Parent" );
		}
	}
}

CConfigMgr32::~CConfigMgr32( void )
{
	if ( NULL != m_hConfigMgrDll )
	{
		FreeLibrary( m_hConfigMgrDll );
	}
}

CONFIGRET CConfigMgr32::CM_Connect_MachineA( PCSTR UNCServerName, PHMACHINE phMachine )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( NULL != m_pCM_Connect_MachineA )
	{
		cr = m_pCM_Connect_MachineA( UNCServerName, phMachine );
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Disconnect_Machine( HMACHINE hMachine )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( NULL != m_pCM_Connect_MachineA )
	{
		cr = m_pCM_Disconnect_Machine( hMachine );
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Parent( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_Parent )
		{
			cr = m_pCM_Get_Parent( pdnDevInst, DevInst, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_Parent )
		{
			cr = m_pCM16_Get_Parent( pdnDevInst, DevInst, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Child( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_Child )
		{
			cr = m_pCM_Get_Child( pdnDevInst, DevInst, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_Child )
		{
			cr = m_pCM16_Get_Child( pdnDevInst, DevInst, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Sibling( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_Sibling )
		{
			cr = m_pCM_Get_Sibling( pdnDevInst, DevInst, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_Sibling )
		{
			cr = m_pCM16_Get_Sibling( pdnDevInst, DevInst, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Locate_DevNodeA( PDEVINST pdnDevInst, DEVINSTID_A pDeviceID, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Locate_DevNodeA )
		{
			cr = m_pCM_Locate_DevNodeA( pdnDevInst, pDeviceID, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Locate_DevNode )
		{
			cr = m_pCM16_Locate_DevNode( pdnDevInst, pDeviceID, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_DevNode_Registry_PropertyA( DEVINST dnDevInst, ULONG ulProperty, PULONG pulRegDataType,
													PVOID Buffer, PULONG pulLength, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_DevNode_Registry_PropertyA )
		{
			cr = m_pCM_Get_DevNode_Registry_PropertyA( dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags );
		}
	}
	else
	{
		if	(	NULL		!=	m_pCM16_Read_Registry_Value
			&&	CM_DRP_MIN	<=	ulProperty
			&&	CM_DRP_MAX	>	ulProperty )
		{
			cr = m_pCM16_Read_Registry_Value( dnDevInst, NULL, s_pszRegistryStrings[ulProperty-1], s_pszRegistryValueTypes[ulProperty-1], Buffer, pulLength, 0 );

			// Fake the returned type since we at least had a match
			*pulRegDataType = s_pszRegistryValueTypes[ulProperty-1];
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_DevNode_Status( PULONG pulStatus, PULONG pulProblemNumber, DEVINST dnDevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{

		if ( NULL != m_pCM_Get_DevNode_Status )
		{
			cr = m_pCM_Get_DevNode_Status( pulStatus, pulProblemNumber, dnDevInst, ulFlags );
		}

	}
	else
	{
		if ( NULL != m_pCM16_Get_DevNode_Status )
		{
			cr = m_pCM16_Get_DevNode_Status( pulStatus, pulProblemNumber, dnDevInst, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVINST dnDevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_First_Log_Config )
		{
			cr = m_pCM_Get_First_Log_Config( plcLogConf, dnDevInst, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_First_Log_Conf )
		{
			cr = m_pCM16_Get_First_Log_Conf( plcLogConf, dnDevInst, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_Next_Res_Des )
		{
			cr = m_pCM_Get_Next_Res_Des( prdResDes, rdResDes, ForResource, pResourceID, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_Next_Res_Des )
		{
			cr = m_pCM16_Get_Next_Res_Des( prdResDes, rdResDes, ForResource, pResourceID, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Res_Des_Data( RES_DES rdResDes, PVOID Buffer, ULONG BufferLen, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_Res_Des_Data )
		{
			cr = m_pCM_Get_Res_Des_Data( rdResDes, Buffer, BufferLen, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_Res_Des_Data )
		{
			cr = m_pCM16_Get_Res_Des_Data( rdResDes, Buffer, BufferLen, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Res_Des_Data_Size( PULONG pulSize, RES_DES rdResDes, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_Res_Des_Data_Size )
		{
			cr = m_pCM_Get_Res_Des_Data_Size( pulSize, rdResDes, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_Res_Des_Data_Size )
		{
			cr = m_pCM16_Get_Res_Des_Data_Size( pulSize, rdResDes, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Free_Log_Conf_Handle( LOG_CONF lcLogConf )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	// This function does NOT appear to have a 16-bit implementation or an
	// equivalent thereof.
	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Free_Log_Conf_Handle )
		{
			cr = m_pCM_Free_Log_Conf_Handle( lcLogConf );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Free_Res_Des_Handle( RES_DES rdResDes )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	// This function does NOT appear to have a 16-bit implementation or an
	// equivalent thereof.
	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Free_Res_Des_Handle )
		{
			cr = m_pCM_Free_Res_Des_Handle( rdResDes );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Device_IDA( DEVNODE dnDevNode, PCHAR Buffer, ULONG BufferLen, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_Device_IDA )
		{
			cr = m_pCM_Get_Device_IDA( dnDevNode, Buffer, BufferLen, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_Device_ID )
		{
			cr = m_pCM16_Get_Device_ID( dnDevNode, Buffer, BufferLen, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Device_ID_Size( PULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( IsWinNT() )
	{
		if ( NULL != m_pCM_Get_Device_ID_Size )
		{
			cr = m_pCM_Get_Device_ID_Size( pulLen, dnDevNode, ulFlags );
		}
	}
	else
	{
		if ( NULL != m_pCM16_Get_Device_ID_Size )
		{
			cr = m_pCM16_Get_Device_ID_Size( pulLen, dnDevNode, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgr32::CM_Get_Bus_Info( DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	if ( !IsWinNT() )
	{
		if ( NULL != m_pCM16_Get_Bus_Info )
		{
			cr = m_pCM16_Get_Bus_Info( dnDevNode, pbtBusType, pulSizeOfInfo, pInfo, ulFlags );
		}
	}

	return cr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\cfgmgrdevice.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <stdafx.h>
#include <regstr.h>
#include "cfgmgrdevice.h"
#include "poormansresource.h"

CConfigMgrDevice::CConfigMgrDevice( HMACHINE hMachine, DEVNODE dn )
:	m_strKey(),
	m_strDeviceDesc(),
	m_strClass(),
	m_strDriver(),
	m_strService(),
	m_dn( dn )
{
	GetStringProperty( CM_DRP_DEVICEDESC, m_strDeviceDesc );
	GetStringProperty( CM_DRP_CLASS, m_strClass );
	GetStringProperty( CM_DRP_DRIVER, m_strDriver );
	GetStringProperty( CM_DRP_SERVICE, m_strService );
}

CConfigMgrDevice::~CConfigMgrDevice( void )
{
}

// New functions that converse directly with the Config Manager APIs

BOOL CConfigMgrDevice::GetDeviceID( CString& strID )
{
	CConfigMgr32	configmgr;

	CONFIGRET	cr = CR_SUCCESS;

	char		szDeviceId[MAX_DEVICE_ID_LEN+1];

	ULONG		ulBuffSize = 0;

	cr = configmgr.CM_Get_Device_IDA( m_dn, szDeviceId, sizeof(szDeviceId), 0  );

	if ( CR_SUCCESS == cr )
	{
		strID = szDeviceId;
	}

	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetStatus( LPDWORD pdwStatus, LPDWORD pdwProblem )
{
	CONFIGRET	cr = g_configmgr.CM_Get_DevNode_Status( pdwStatus, pdwProblem, m_dn, 0 );

	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetIRQ( LPDWORD pdwIRQ )
{
    LOG_CONF LogConfig;
    RES_DES ResDes;
    CONFIGRET cr;

	// Get the allocated Logical Configuration.  From there, we can iterate resource descriptors
	// until we find an IRQ Descriptor.

	if ( CR_SUCCESS == ( cr = g_configmgr.CM_Get_First_Log_Conf( &LogConfig, m_dn, ALLOC_LOG_CONF ) ) )
	{
		RESOURCEID	resID;
		
		// To get the first Resource Descriptor, we pass in the logical configuration.
		// The config manager knows how to handle this (or at least that's what the
		// ahem-"documentation" sez.

		RES_DES	LastResDes = LogConfig;

		do
		{

			//cr = g_configmgr.CM_Get_Next_Res_Des( &ResDes, LastResDes, ResType_All, &resID, 0 );
			cr = g_configmgr.CM_Get_Next_Res_Des( &ResDes, LastResDes, ResType_All, &resID, 0 );

			// Clean up the prior resource descriptor handle
			if ( LastResDes != LogConfig )
			{
				g_configmgr.CM_Free_Res_Des_Handle( LastResDes );
			}

			LastResDes = ResDes;

			//ASSERT( !(resID & ResType_Ignored_Bit ) );

			resID &= 0x0000001F;

		}	while ( CR_SUCCESS == cr && ResType_IRQ != resID );

		// This means we broke out cause the Resource Type was the IRQ
		if ( CR_SUCCESS == cr )
		{
			ULONG	ulDataSize = 0;

			if ( CR_SUCCESS == ( cr = g_configmgr.CM_Get_Res_Des_Data_Size( &ulDataSize, ResDes, 0 ) ) )
			{
				ulDataSize += 10;	// Pad for 10 bytes of safety

				BYTE*	pbData = new BYTE[ulDataSize];

				if ( NULL != pbData )
				{
					cr = g_configmgr.CM_Get_Res_Des_Data( ResDes, pbData, ulDataSize, 0 );

					if ( CR_SUCCESS == cr )
					{
						// Different structures for 32/16 bit CFGMGR
						if ( IsWinNT() )
						{
							PIRQ_DES	pirqDes = (PIRQ_DES) pbData;

							// Get the IRQ out of the structure header
							*pdwIRQ = pirqDes->IRQD_Alloc_Num;

						}
						else
						{
							PIRQ_DES16	pirqDes = (PIRQ_DES16) pbData;

							// Get the IRQ out of the structure header
							*pdwIRQ = pirqDes->IRQD_Alloc_Num;
						}

					}
					
					delete [] pbData;
				}

			}

			// Clean up the Resource Descriptor Handle
			g_configmgr.CM_Free_Res_Des_Handle( ResDes );

		}

		// Clean up the logical configuration handle
		g_configmgr.CM_Free_Log_Conf_Handle( LogConfig );
    }


	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetStringProperty( ULONG ulProperty, CString& strValue )
{
    TCHAR Buffer[REGSTR_VAL_MAX_HCID_LEN+1];
    ULONG Type;
    ULONG Size = sizeof(Buffer);

	CONFIGRET	cr = CR_SUCCESS;

	CConfigMgr32	configmgr;

	if (	CR_SUCCESS == ( cr = configmgr.CM_Get_DevNode_Registry_PropertyA(	m_dn,
																				ulProperty,
																				&Type,
																				Buffer,
																				&Size,
																				0 ) ) )
	{
		if ( REG_SZ == Type )
		{
			strValue = Buffer;
		}
		else
		{
			cr = CR_WRONG_TYPE;
		}
	}

	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetDWORDProperty( ULONG ulProperty, DWORD* pdwVal )
{
	DWORD	dwVal = 0;
    ULONG Type;
    ULONG Size = sizeof(DWORD);

	CONFIGRET	cr = CR_SUCCESS;

	CConfigMgr32	configmgr;

	if (	CR_SUCCESS == ( cr = configmgr.CM_Get_DevNode_Registry_PropertyA(	m_dn,
																				ulProperty,
																				&Type,
																				&dwVal,
																				&Size,
																				0 ) ) )

	{
		if ( IsWinNT() )
		{
			if ( REG_DWORD == Type )
			{
				*pdwVal = dwVal;
			}
			else
			{
				cr = CR_WRONG_TYPE;
			}

		}
		else
		{
			if ( REG_BINARY == Type )	// Apparently Win16 doesn't do REG_DWORD
			{
				*pdwVal = dwVal;
			}
			else
			{
				cr = CR_WRONG_TYPE;
			}
		}
	}

	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetMULTISZProperty( ULONG ulProperty, CStringArray& strArray )
{
	LPSTR	pszStrings = NULL;
    ULONG	Type;
    ULONG	Size = 0;

	CONFIGRET	cr = CR_SUCCESS;

	CConfigMgr32	configmgr;

	if (	CR_SUCCESS == ( cr = configmgr.CM_Get_DevNode_Registry_PropertyA(	m_dn,
																				ulProperty,
																				&Type,
																				pszStrings,
																				&Size,
																				0 ) )
		||	CR_BUFFER_SMALL	==	cr )

	{
		// SZ or MULTI_SZ is Okay (32-bit has MULTI_SZ values that are SZ in 16-bit)
		if ( REG_SZ == Type || REG_MULTI_SZ == Type )
		{
			Size += 10;
			pszStrings = new char[Size];

			DWORD dwOldSize = Size;

			if ( NULL != pszStrings )
			{
				// Do this due to apparent beefs on NT 4, in which the double NULL
				// terminator on a single string doesn't always make it over.

				ZeroMemory( pszStrings, Size );

				if (	CR_SUCCESS == ( cr = configmgr.CM_Get_DevNode_Registry_PropertyA(	m_dn,
																							ulProperty,
																							&Type,
																							pszStrings,
																							&Size,
																							0 ) ) )
				{
					// For REG_SZ, add a single entry to the array
					if ( REG_SZ == Type )
					{
						strArray.Add( pszStrings );
					}
					else if ( REG_MULTI_SZ == Type )
					{
						// Add strings to the array, watching out for the double NULL
						// terminator for the array

						LPSTR	pszTemp = pszStrings;

						do
						{
							strArray.Add( pszTemp );
							pszTemp += ( lstrlen( pszTemp ) + 1 );
						} while ( NULL != *pszTemp );
					}
					else
					{
						cr = CR_WRONG_TYPE;
					}

				}	// If Got value
				
				delete [] pszStrings;

			}	// IF alloc pszStrings

		}	// IF REG_SZ or REG_MULTI_SZ
		else
		{
			cr = CR_WRONG_TYPE;
		}

	}	// IF got size of entry

	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetBusInfo( LPDWORD pdwBusType, LPDWORD pdwBusNumber )
{
	CConfigMgr32	configmgr;
	CMBUSTYPE		busType = 0;
	ULONG			ulSizeOfInfo = 0;
	PBYTE			pbData = NULL;
	CONFIGRET		cr;

	if ( IsWinNT() )
	{
		DWORD			dwType = 0;
		DWORD			dwBusNumber;
		DWORD/*INTERFACE_TYPE*/	BusType;
		
		ulSizeOfInfo = sizeof(DWORD);

		if (	CR_SUCCESS == ( cr = configmgr.CM_Get_DevNode_Registry_PropertyA(	m_dn,
																					CM_DRP_BUSNUMBER,
																					&dwType,
																					&dwBusNumber,
																					&ulSizeOfInfo,
																					0 ) ) )
		{
			*pdwBusNumber = dwBusNumber;
		}

		ulSizeOfInfo = sizeof(BusType);

		if (	CR_SUCCESS == ( cr = configmgr.CM_Get_DevNode_Registry_PropertyA(	m_dn,
																					CM_DRP_LEGACYBUSTYPE,
																					&dwType,
																					&BusType,
																					&ulSizeOfInfo,
																					0 ) ) )
		{
			*pdwBusType = BusType;
		}

	}
	else
	{
		// Buffer big enough for all eventualities
		BYTE		abData[255];

		ulSizeOfInfo = sizeof(abData);

		cr = configmgr.CM_Get_Bus_Info( m_dn, &busType, &ulSizeOfInfo, abData, 0 );

		if ( CR_SUCCESS == cr )
		{
			if ( BusType_PCI == busType )
			{
				if ( BusType_PCI == busType )
				{
					sPCIAccess* pPCIInfo = (sPCIAccess*) abData;
					*pdwBusNumber = pPCIInfo->bBusNumber;
				}

			}
			else
			{
				*pdwBusNumber = 0;
			}

			*pdwBusType = busType;


/*
			ulSizeOfInfo += 10;
			
			pbData = new BYTE[ulSizeOfInfo];

			if ( NULL != pbData )
			{
				if ( CR_SUCCESS == ( cr = configmgr.CM_Get_Bus_Info( m_dn, &busType, &ulSizeOfInfo, pbData, 0 ) ) )
				{

					if ( BusType_PCI == busType )
					{
						sPCIAccess* pPCIInfo = (sPCIAccess*) pbData;
						*pdwBusNumber = pPCIInfo->bBusNumber;
					}
					else
					{
						*pdwBusNumber = 0;
					}

					*pdwBusType = busType;
				}

				delete [] pbData;
			}

*/
		}

	}

	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetParent( CConfigMgrDevice** ppParentDevice )
{
	CConfigMgr32	configmgr;
	DEVNODE			dn;

	CONFIGRET	cr = configmgr.CM_Get_Parent( &dn, m_dn, 0 );

	if ( CR_SUCCESS == cr )
	{
		CConfigMgrDevice*	pDevice	=	new CConfigMgrDevice( NULL, dn );

		if ( NULL != pDevice )
		{
			*ppParentDevice = pDevice;
		}
		else
		{
			cr = CR_OUT_OF_MEMORY;
		}
	}

	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetChild( CConfigMgrDevice** ppChildDevice )
{
	CConfigMgr32	configmgr;
	DEVNODE			dn;

	CONFIGRET	cr = configmgr.CM_Get_Child( &dn, m_dn, 0 );

	if ( CR_SUCCESS == cr )
	{
		CConfigMgrDevice*	pDevice	=	new CConfigMgrDevice( NULL, dn );

		if ( NULL != pDevice )
		{
			*ppChildDevice = pDevice;
		}
		else
		{
			cr = CR_OUT_OF_MEMORY;
		}
	}

	return ( CR_SUCCESS == cr );
}

BOOL CConfigMgrDevice::GetSibling( CConfigMgrDevice** ppSiblingDevice )
{
	CConfigMgr32	configmgr;
	DEVNODE			dn;

	CONFIGRET	cr = configmgr.CM_Get_Sibling( &dn, m_dn, 0 );

	if ( CR_SUCCESS == cr )
	{
		CConfigMgrDevice*	pDevice	=	new CConfigMgrDevice( NULL, dn );

		if ( NULL != pDevice )
		{
			*ppSiblingDevice = pDevice;
		}
		else
		{
			cr = CR_OUT_OF_MEMORY;
		}
	}

	return ( CR_SUCCESS == cr );
}

LONG CConfigMgrDevice::GetRegistryStringValue( LPCTSTR pszValueName, CString& strValue )
{
	TCHAR	szBuff[256];
	DWORD	dwBuffSize	=	sizeof(szBuff);
	DWORD	dwType		=	NULL;

	LONG	lError = GetRegistryValue( pszValueName, (LPBYTE) szBuff, &dwBuffSize, &dwType );

	if ( ERROR_SUCCESS == lError )
	{
		if ( REG_SZ == dwType )
		{
			strValue = szBuff;
		}
	}
	else
	{
		lError = ERROR_PATH_NOT_FOUND;
	}

	return lError;
}

LONG CConfigMgrDevice::GetRegistryValue( LPCTSTR pszValueName, LPBYTE pBuffer, LPDWORD pdwBufferSize, LPDWORD pdwType )
{
	LONG		lError = ERROR_PATH_NOT_FOUND;

	CString	strDeviceID;

	if ( GetDeviceID( strDeviceID ) )
	{
		HKEY		hKey = NULL;
		CString	strKey;

		// Build the correct key
		if ( IsWinNT() )
		{
			strKey = _T("SYSTEM\\CurrentControlSet\\Enum\\");
		}
		else
		{
			strKey = _T("Enum\\");
		}

		strKey += strDeviceID;

		// Open key -- Grab value -- Mongo Like
		if ( ( lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, strKey, 0L, KEY_READ, &hKey ) ) == ERROR_SUCCESS )
		{

			lError = RegQueryValueEx( hKey, pszValueName, NULL, pdwType, pBuffer, pdwBufferSize );

			// Clean up this here town
			RegCloseKey( hKey );

		}	// RegOpenKey

	}	// GetDeviceID

	return lError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\cfgmgrcomputer.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef	__CFGMGRCOMPUTER_H__
#define	__CFGMGRCOMPUTER_H__

#include "configmgr32.h"

class CConfigMgrComputer
{
public:

	CConfigMgrComputer( LPCTSTR pszName = NULL );
	~CConfigMgrComputer();

	LPCTSTR		GetName( void );

    operator HMACHINE()
    {
		return m_hMachine;
    }

private:

	HMACHINE	m_hMachine;
	CString		m_strName;
};

#endif //__CFGMGRCOMPUTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\cfgmgrdevice.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef	__CFGMGRDEVICE_H__
#define	__CFGMGRDEVICE_H__

#include "configmgr32.h"

class CConfigMgrDevice
{
public:

	CConfigMgrDevice( HMACHINE hMachine = NULL, DEVNODE dn = 0 );
	~CConfigMgrDevice();

	// New functions that use config manager APIs directly

	// String Values
	BOOL GetDeviceDesc( CString& strVal );
	BOOL GetService( CString& strVal );
	BOOL GetClass( CString& strVal );
	BOOL GetClassGUID( CString& strVal );
	BOOL GetDriver( CString& strVal );
	BOOL GetMfg( CString& strVal );
	BOOL GetFriendlyName( CString& strVal );
	BOOL GetLocationInformation( CString& strVal );
	BOOL GetPhysicalDeviceObjectName( CString& strVal );
	BOOL GetEnumeratorName( CString& strVal );

	// DWORD Values
	BOOL GetConfigFlags( DWORD& dwVal );
	BOOL GetCapabilities( DWORD& dwVal );
	BOOL GetUINumber( DWORD& dwVal );

	// MULTI_SZ Values
	BOOL GetHardwareID( CStringArray& strArray );
	BOOL GetCompatibleIDS( CStringArray& strArray );
	BOOL GetUpperFilters( CStringArray& strArray );
	BOOL GetLowerFilters( CStringArray& strArray );

	BOOL GetDeviceID( CString& strID );

	BOOL GetStatus( LPDWORD pdwStatus, LPDWORD pdwProblem );

	// Use Config Manager APIs directly
	BOOL GetStringProperty( ULONG ulProperty, CString& strValue );
	BOOL GetDWORDProperty( ULONG ulProperty, DWORD* pdwVal );
	BOOL GetMULTISZProperty( ULONG ulProperty, CStringArray& strArray );

	// Device Relationship functions
	BOOL GetParent( CConfigMgrDevice** pParentDevice );
	BOOL GetChild( CConfigMgrDevice** pChildDevice );
	BOOL GetSibling( CConfigMgrDevice** pSiblingDevice );

	BOOL GetIRQ( LPDWORD pdwIRQ );

	BOOL GetBusInfo( LPDWORD pdwBusType, LPDWORD pdwBusNumber );

	LONG GetRegistryStringValue( LPCTSTR pszValueName, CString& strValue );
	LONG GetRegistryValue( LPCTSTR pszValueName, LPBYTE pBuffer, LPDWORD pdwBufferSize, LPDWORD pdwType = NULL );

private:

	CString		m_strKey;
	CString		m_strDeviceDesc;
	CString		m_strClass;
	CString		m_strDriver;
	CString		m_strService;

	DEVNODE		m_dn;
};

// REG_SZ Properties
inline BOOL CConfigMgrDevice::GetDeviceDesc( CString& strVal )
{
	return GetStringProperty( CM_DRP_DEVICEDESC, strVal );
}

inline BOOL CConfigMgrDevice::GetService( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_SERVICE, strVal );
}

inline BOOL CConfigMgrDevice::GetClass( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_CLASS, strVal );
}

inline BOOL CConfigMgrDevice::GetClassGUID( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_CLASSGUID, strVal );
}

inline BOOL CConfigMgrDevice::GetDriver( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_DRIVER, strVal );
}

inline BOOL CConfigMgrDevice::GetMfg( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_MFG, strVal );
}

inline BOOL CConfigMgrDevice::GetFriendlyName( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_FRIENDLYNAME, strVal );
}

inline BOOL CConfigMgrDevice::GetLocationInformation( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_LOCATION_INFORMATION, strVal );
}

inline BOOL CConfigMgrDevice::GetPhysicalDeviceObjectName( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME, strVal );
}

inline BOOL CConfigMgrDevice::GetEnumeratorName( CString& strVal )
{
	return 	GetStringProperty( CM_DRP_ENUMERATOR_NAME, strVal );
}

// DWORD functions
inline BOOL CConfigMgrDevice::GetConfigFlags( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_CONFIGFLAGS, &dwVal );
}

inline BOOL CConfigMgrDevice::GetCapabilities( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_CAPABILITIES, &dwVal );
}

inline BOOL CConfigMgrDevice::GetUINumber( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_UI_NUMBER, &dwVal );
}

// MULTI_SZ properties
inline BOOL CConfigMgrDevice::GetHardwareID( CStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_HARDWAREID, strArray );
}

inline BOOL CConfigMgrDevice::GetCompatibleIDS( CStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_COMPATIBLEIDS, strArray );
}

inline BOOL CConfigMgrDevice::GetUpperFilters( CStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_UPPERFILTERS, strArray );
}

inline BOOL CConfigMgrDevice::GetLowerFilters( CStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_LOWERFILTERS, strArray );
}


#endif //__CFGMGRCOMPUTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\ntdevicetest.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// NTDEVICETEST.h : main header file for the NTDEVICETEST application
//

#if !defined(AFX_NTDEVICETEST_H__25764CA6_F1B7_11D1_B166_00A0C905A445__INCLUDED_)
#define AFX_NTDEVICETEST_H__25764CA6_F1B7_11D1_B166_00A0C905A445__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CNTDEVICETESTApp:
// See NTDEVICETEST.cpp for the implementation of this class
//

class CNTDEVICETESTApp : public CWinApp
{
public:
	CNTDEVICETESTApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNTDEVICETESTApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CNTDEVICETESTApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NTDEVICETEST_H__25764CA6_F1B7_11D1_B166_00A0C905A445__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\poppack.h ===
/*++



// Copyright (c) 1990-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\ntdevicetestdlg.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// NTDEVICETESTDlg.cpp : implementation file
//

#include "stdafx.h"
#include "NTDEVICETEST.h"
#include "NTDEVICETESTDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNTDEVICETESTDlg dialog

CNTDEVICETESTDlg::CNTDEVICETESTDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNTDEVICETESTDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNTDEVICETESTDlg)
	m_nDeviceList = -1;
	m_strClassType = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CNTDEVICETESTDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNTDEVICETESTDlg)
	DDX_Control(pDX, IDC_SIBLING, m_wndSibling);
	DDX_Control(pDX, IDC_CHILD, m_wndChild);
	DDX_Control(pDX, IDC_PARENT, m_wndParent);
	DDX_Control(pDX, IDC_BUSNUMBER, m_wndBusNumber);
	DDX_Control(pDX, IDC_BUSTYPE, m_wndBusType);
	DDX_Control(pDX, IDC_HARDWAREID, m_wndHardwareIDList);
	DDX_Control(pDX, IDC_CONFIGFLAGS, m_wndConfigFlags);
	DDX_Control(pDX, IDC_DEVICEID, m_wndDeviceID);
	DDX_Control(pDX, IDC_IRQ, m_wndIRQ);
	DDX_Control(pDX, IDC_PROBLEM, m_wndProblem);
	DDX_Control(pDX, IDC_STATUS, m_wndStatus);
	DDX_Control(pDX, IDC_SERVICE, m_wndService);
	DDX_Control(pDX, IDC_CLASS, m_wndClass);
	DDX_Control(pDX, IDC_DRIVER, m_wndDriver);
	DDX_Control(pDX, IDC_DEVICELIST, m_wndDeviceList);
	DDX_LBIndex(pDX, IDC_DEVICELIST, m_nDeviceList);
	DDX_Text(pDX, IDC_CLASSTYPE, m_strClassType);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CNTDEVICETESTDlg, CDialog)
	//{{AFX_MSG_MAP(CNTDEVICETESTDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
	ON_CONTROL( LBN_SELCHANGE, IDC_DEVICELIST, OnDeviceListSelChange )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNTDEVICETESTDlg message handlers

BOOL CNTDEVICETESTDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	FillDeviceList( NULL, NULL );

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CNTDEVICETESTDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CNTDEVICETESTDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CNTDEVICETESTDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CNTDEVICETESTDlg::FillDeviceList( LPCTSTR pszClassType, LPCTSTR pszDeviceID )
{

	// Dump the list first
	ClearDeviceList();

	// Clear out the list
	m_wndDeviceList.ResetContent();

	DEVNODE dnRoot;

	if ( CR_SUCCESS == g_configmgr.CM_Locate_DevNode(&dnRoot, (LPSTR) pszDeviceID, 0) )
	{
		if ( NULL == pszDeviceID )
		{
			DEVNODE dnFirst;
			if ( CR_SUCCESS == g_configmgr.CM_Get_Child(&dnFirst, dnRoot, 0) )
			{
				CreateSubtree( NULL, NULL, dnFirst, pszClassType );
			}

		}
		else
		{
			CreateSubtree( NULL, NULL, dnRoot, pszClassType );
		}
	}

}

void CNTDEVICETESTDlg::ClearDeviceList( void )
{
	// Dump the list first

	CConfigMgrDevice*	pDevice = NULL;

	while ( !m_DeviceList.IsEmpty() )
	{
		if ( NULL != ( pDevice = (CConfigMgrDevice*) m_DeviceList.RemoveHead() ) )
		{
			delete pDevice;
		}
	}
}

BOOL
CNTDEVICETESTDlg::CreateSubtree(
    CConfigMgrDevice* pParent,
    CConfigMgrDevice* pSibling,
    DEVNODE  dn,
	LPCTSTR pszClassType
    )
{
    CConfigMgrDevice* pDevice;
    DEVNODE dnSibling, dnChild;
	CString				strDeviceDesc,
						strClass;

    do
    {
		if (CR_SUCCESS != g_configmgr.CM_Get_Sibling(&dnSibling, dn, 0))
			dnSibling = NULL;
		pDevice = new CConfigMgrDevice( NULL, dn );

		BOOL	fGotDeviceDesc	=	pDevice->GetDeviceDesc( strDeviceDesc ),
				fGotClass		=	pDevice->GetClass( strClass );

		if	(	( fGotDeviceDesc && !strDeviceDesc.IsEmpty() )
			&&	(	NULL	==	pszClassType
				||	0 == strClass.CompareNoCase( pszClassType )
				)
			)
		{
			m_wndDeviceList.AddString( strDeviceDesc );
			m_DeviceList.AddTail( pDevice );
		}
		else
		{
			delete pDevice;
		}

/*
	pDevice->Create(*m_pComputer, dn);
	pDevice->SetParent(pParent);
	if (pSibling)
	    pSibling->SetSibling(pDevice);
	else if (pParent)
	    pParent->SetChild(pDevice);

	TCHAR GuidString[MAX_GUID_STRING_LEN];
	ULONG Size = sizeof(GuidString);
	if (CR_SUCCESS == CM_Get_DevNode_Registry_Property_Ex(dn,
					CM_DRP_CLASSGUID, NULL,
					GuidString, &Size, 0,  *m_pComputer) &&
	    _T('{') == GuidString[0] && _T('}') == GuidString[MAX_GUID_STRING_LEN - 2])
	{
	    GUID Guid;
	    GuidString[MAX_GUID_STRING_LEN - 2] = _T('\0');
	    UuidFromString(&GuidString[1], &Guid);
	    pDevice->SetClassGuid(&Guid);
	    int Index;
	    if (SetupDiGetClassImageIndex(&m_ImageListData, &Guid, &Index))
		pDevice->SetImageIndex(Index);
	}
*/

		if (CR_SUCCESS == g_configmgr.CM_Get_Child(&dnChild, dn, 0))
		{
			CreateSubtree(pDevice, NULL, dnChild, pszClassType);
		}

		dn = dnSibling;

		pSibling = pDevice;

    } while (NULL != dn);

    return TRUE;
}

void CNTDEVICETESTDlg::OnOK()
{
	UpdateData( TRUE );

	FillDeviceList( ( m_strClassType.IsEmpty() ? (LPCTSTR) NULL : (LPCTSTR) m_strClassType ), NULL );
}

void CNTDEVICETESTDlg::OnCancel()
{
	ClearDeviceList();
	CDialog::OnCancel();
}

void CNTDEVICETESTDlg::OnDeviceListSelChange()
{
	UpdateData( TRUE );

	m_wndHardwareIDList.ResetContent();

	POSITION	pos = m_DeviceList.FindIndex( m_nDeviceList );

	if ( NULL != pos )
	{
		CString				strDeviceID;
		CConfigMgrDevice*	pDevice = (CConfigMgrDevice*) m_DeviceList.GetAt( pos );

		if ( NULL != pDevice )
		{
			CString	strTemp;

			pDevice->GetClass( strTemp );
			m_wndClass.SetWindowText( strTemp );

			pDevice->GetDriver( strTemp );
			m_wndDriver.SetWindowText( strTemp );

			pDevice->GetService( strTemp );
			m_wndService.SetWindowText( strTemp );

			DWORD	dwStatus = 0, dwProblem = 0,
					dwIRQ = 0, dwConfigFlags;

			pDevice->GetStatus( &dwStatus, &dwProblem );

			strTemp.Format( "0x%x", dwStatus );
			m_wndStatus.SetWindowText( strTemp );

			strTemp.Format( "0x%x", dwProblem );
			m_wndProblem.SetWindowText( strTemp );

			// Do the IRQ Dance, BABY!
			strTemp.Empty();
			if ( pDevice->GetIRQ( &dwIRQ ) )
			{
				strTemp.Format( "%d", dwIRQ );
			}
			m_wndIRQ.SetWindowText( strTemp );

			strTemp.Empty();
			if ( pDevice->GetConfigFlags( dwConfigFlags ) )
			{
				strTemp.Format( "%d", dwConfigFlags );
			}
			m_wndConfigFlags.SetWindowText( strTemp );

			pDevice->GetDeviceID( strDeviceID );
			m_wndDeviceID.SetWindowText( strDeviceID );
		
			CStringArray	strArray;

			if ( pDevice->GetHardwareID( strArray ) )
			{
				DWORD	dwNumElements = strArray.GetSize();

				for ( DWORD x = 0; x < dwNumElements; x++ )
				{
					m_wndHardwareIDList.AddString( strArray.GetAt(x) );
				}
			}

			DWORD	dwBusType = 0, dwBusNumber = 0;
			strTemp.Empty();

			if ( pDevice->GetBusInfo( &dwBusType, &dwBusNumber ) )
			{
				strTemp.Format( "%d", dwBusType );
				m_wndBusType.SetWindowText( strTemp );
				strTemp.Format( "%d", dwBusNumber );
				m_wndBusNumber.SetWindowText( strTemp );
			}
			else
			{
				m_wndBusType.SetWindowText( strTemp );
				m_wndBusNumber.SetWindowText( strTemp );
			}

			CConfigMgrDevice*	pRelative = NULL;
			strTemp.Empty();

			if ( pDevice->GetParent( &pRelative ) )
			{
				pRelative->GetDeviceDesc( strTemp );
				delete pRelative;
			}
			m_wndParent.SetWindowText( strTemp );

			strTemp.Empty();

			if ( pDevice->GetSibling( &pRelative ) )
			{
				pRelative->GetDeviceDesc( strTemp );
				delete pRelative;
			}
			m_wndSibling.SetWindowText( strTemp );

			strTemp.Empty();

			if ( pDevice->GetChild( &pRelative ) )
			{
				pRelative->GetDeviceDesc( strTemp );
				delete pRelative;
			}
			m_wndChild.SetWindowText( strTemp );

			pDevice->GetRegistryStringValue( "Fred", strTemp );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\configmgr32.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef	__CFGMGR32_H__
#define	__CFGMGR32_H__

extern "C"
{
#include <cfgmgr32.h>
}

#include "util.h"
#include "sms95lanexp.h"

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_CONNECT_MACHINEA)	(	PCSTR		UNCServerName,
																	PHMACHINE	phMachine
																);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_DISCONNECT_MACHINE)	(	HMACHINE	hMachine
																	);
typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_LOCATE_DEVNODEA)	(	PDEVINST	pdnDevInst,
																	DEVINSTID_A	pDeviceID,
																	ULONG		ulFlags
																	);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_PARENT)		(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);


typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_CHILD)			(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_SIBLING)		(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);


typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTYA)		(	DEVINST	dnDevInst,
																						ULONG	ulProperty,
																						PULONG	pulRegDataType,
																						PVOID	Buffer,
																						PULONG	pulLength,
																						ULONG	ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVNODE_STATUS)					(	PULONG	pulStatus,
																						PULONG	pulProblemNumber,
																						DEVINST	dnDevInst,
																						ULONG	ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_FIRST_LOG_CONF)					(	PLOG_CONF plcLogConf,
																						DEVINST   dnDevInst,
																						ULONG     ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_NEXT_RES_DES)						(	PRES_DES    prdResDes,
																						RES_DES     rdResDes,
																						RESOURCEID  ForResource,
																						PRESOURCEID pResourceID,
																						ULONG       ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_RES_DES_DATA)						(	RES_DES  rdResDes,
																						PVOID    Buffer,
																						ULONG    BufferLen,
																						ULONG    ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_RES_DES_DATA_SIZE)					(	PULONG   pulSize,
																						RES_DES  rdResDes,
																						ULONG    ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_FREE_LOG_CONF_HANDLE)					(	LOG_CONF  lcLogConf
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_FREE_RES_DES_HANDLE)					(	RES_DES    rdResDes
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVICE_IDA)						(	DEVNODE		dnDevNode,
																						PCHAR		Buffer,
																						ULONG		BufferLen,
																						ULONG		ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVICE_ID_SIZE)					(	PULONG		pulLen,
																						DEVNODE		dnDevNode,
																						ULONG		ulFlags
																					);

class CConfigMgr32
{
public:

	CConfigMgr32();
	~CConfigMgr32();

	CONFIGRET	CM_Connect_MachineA( PCSTR UNCServerName, PHMACHINE phMachine );
	CONFIGRET	CM_Disconnect_Machine( HMACHINE hMachine );
	CONFIGRET	CM_Get_Parent( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Child( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Sibling( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Locate_DevNodeA( PDEVINST pdnDevInst, DEVINSTID_A pDeviceID, ULONG ulFlags );
	CONFIGRET	CM_Get_DevNode_Registry_PropertyA( DEVINST dnDevInst, ULONG ulProperty, PULONG pulRegDataType,
													PVOID Buffer, PULONG pulLength, ULONG ulFlags );
	CONFIGRET	CM_Get_DevNode_Status( PULONG pulStatus, PULONG pulProblemNumber, DEVINST dnDevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVINST dnDevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags );
	CONFIGRET	CM_Get_Res_Des_Data( RES_DES rdResDes, PVOID Buffer, ULONG BufferLen, ULONG ulFlags );
	CONFIGRET	CM_Get_Res_Des_Data_Size( PULONG pulSize, RES_DES rdResDes, ULONG ulFlags );
	CONFIGRET	CM_Free_Log_Conf_Handle( LOG_CONF lcLogConf );
	CONFIGRET	CM_Free_Res_Des_Handle( RES_DES rdResDes );
	CONFIGRET	CM_Get_Device_IDA(	DEVNODE dnDevNode, PCHAR Buffer, ULONG BufferLen, ULONG ulFlags );
	CONFIGRET	CM_Get_Device_ID_Size( PULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags );

	// Win 95/98 only
	CONFIGRET	CM_Get_Bus_Info( DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags );

private:

	HINSTANCE	m_hConfigMgrDll;

	// 32-bit Config Manager pointers
	PCFGMGR32_CM_CONNECT_MACHINEA		m_pCM_Connect_MachineA;
	PCFGMGR32_CM_DISCONNECT_MACHINE		m_pCM_Disconnect_Machine;
	PCFGMGR32_CM_LOCATE_DEVNODEA		m_pCM_Locate_DevNodeA;
	PCFGMGR32_CM_GET_CHILD				m_pCM_Get_Child;
	PCFGMGR32_CM_GET_SIBLING			m_pCM_Get_Sibling;
	PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTYA		m_pCM_Get_DevNode_Registry_PropertyA;
	PCFGMGR32_CM_GET_DEVNODE_STATUS		m_pCM_Get_DevNode_Status;
	PCFGMGR32_CM_GET_FIRST_LOG_CONF		m_pCM_Get_First_Log_Config;
	PCFGMGR32_CM_GET_NEXT_RES_DES		m_pCM_Get_Next_Res_Des;
	PCFGMGR32_CM_GET_RES_DES_DATA		m_pCM_Get_Res_Des_Data;
	PCFGMGR32_CM_GET_RES_DES_DATA_SIZE	m_pCM_Get_Res_Des_Data_Size;
	PCFGMGR32_CM_FREE_LOG_CONF_HANDLE	m_pCM_Free_Log_Conf_Handle;
	PCFGMGR32_CM_FREE_RES_DES_HANDLE	m_pCM_Free_Res_Des_Handle;
	PCFGMGR32_CM_GET_DEVICE_IDA			m_pCM_Get_Device_IDA;
	PCFGMGR32_CM_GET_DEVICE_ID_SIZE		m_pCM_Get_Device_ID_Size;
	PCFGMGR32_CM_GET_PARENT				m_pCM_Get_Parent;

	// 16-bit Config Manager Thunking Pass-Thrus
	PCIM32THK_CM_LOCATE_DEVNODE			m_pCM16_Locate_DevNode;
	PCIM32THK_CM_GET_CHILD				m_pCM16_Get_Child;
	PCIM32THK_CM_GET_SIBLING			m_pCM16_Get_Sibling;
	PCIM32THK_CM_READ_REGISTRY_VALUE	m_pCM16_Read_Registry_Value;
	PCIM32THK_CM_GET_DEVNODE_STATUS		m_pCM16_Get_DevNode_Status;
	PCIM32THK_CM_GET_DEVICE_ID			m_pCM16_Get_Device_ID;
	PCIM32THK_CM_GET_DEVICE_ID_SIZE		m_pCM16_Get_Device_ID_Size;
	PCIM32THK_CM_GET_FIRST_LOG_CONF		m_pCM16_Get_First_Log_Conf;
	PCIM32THK_CM_GET_NEXT_RES_DES		m_pCM16_Get_Next_Res_Des;
	PCIM32THK_CM_GET_RES_DES_DATA_SIZE	m_pCM16_Get_Res_Des_Data_Size;
	PCIM32THK_CM_GET_RES_DES_DATA		m_pCM16_Get_Res_Des_Data;
	PCIM32THK_CM_GET_BUS_INFO			m_pCM16_Get_Bus_Info;
	PCIM32THK_CM_GET_PARENT				m_pCM16_Get_Parent;

	static char*						s_pszRegistryStrings[];
	static ULONG						s_pszRegistryValueTypes[];
};

// CIM16 registry ULONG to Str conversions
#define CM_DRP_DEVICEDESC_S						"DeviceDesc" // DeviceDesc REG_SZ property (RW)
#define CM_DRP_HARDWAREID_S						"HardwareID" // HardwareID REG_MULTI_SZ property (RW)
#define CM_DRP_COMPATIBLEIDS_S					"CompatibleIDs" // CompatibleIDs REG_MULTI_SZ property (RW)
#define CM_DRP_NTDEVICEPATHS_S					"NtDevicePaths" // NTDevicePaths (NT4)
#define CM_DRP_SERVICE_S 						"Service" // Service REG_SZ property (RW)
#define CM_DRP_CONFIGURATION_S					"Configuration" // Configuration (NT4)
#define CM_DRP_CONFIGURATIONVECTOR_S			"ConfigurationVector" // ConfigurationVector(NT4)
#define CM_DRP_CLASS_S							"Class" // Class REG_SZ property (RW)
#define CM_DRP_CLASSGUID_S						"ClassGUID" // ClassGUID REG_SZ property (RW)
#define CM_DRP_DRIVER_S							"Driver" // Driver REG_SZ property (RW)
#define CM_DRP_CONFIGFLAGS_S					"ConfigFlags" // ConfigFlags REG_DWORD property (RW)
#define CM_DRP_MFG_S							"Mfg" // Mfg REG_SZ property (RW)
#define CM_DRP_FRIENDLYNAME_S					"FriendlyName" // FriendlyName REG_SZ property (RW)
#define CM_DRP_LOCATION_INFORMATION_S			"LocationInformation" // LocationInformation REG_SZ property (RW)
#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S	"PhysicalDeviceObjectName" // PhysicalDeviceObjectName REG_SZ property (R)
#define CM_DRP_CAPABILITIES_S					"Capabilities" // Capabilities REG_DWORD property (R)
#define CM_DRP_UI_NUMBER_S						"UiNumber" // UiNumber REG_DWORD property (R)
#define CM_DRP_UPPERFILTERS_S					"UpperFilters" // UpperFilters REG_MULTI_SZ property (RW)
#define CM_DRP_LOWERFILTERS_S					"LowerFilters" // LowerFilters REG_MULTI_SZ property (RW)
#define CM_DRP_BUSTYPEGUID_S					"BusTypeGuid" // Bus Type Guid, GUID, (R)
#define CM_DRP_LEGACYBUSTYPE_S					"LegacyBusType" // Legacy bus type, INTERFACE_TYPE, (R)
#define CM_DRP_BUSNUMBER_S						"BusNumber" // Bus Number, DWORD, (R)
#define CM_DRP_ENUMERATOR_NAME_S				"Enumerator" // Enumerator Name REG_SZ property (R)
#define CM_DRP_MIN_S							""			// Min
#define CM_DRP_MAX_S							""			// Max

extern CConfigMgr32		g_configmgr;

#endif //__CFGMGRCOMPUTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\ntdevicetest.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// NTDEVICETEST.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "NTDEVICETEST.h"
#include "NTDEVICETESTDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNTDEVICETESTApp

BEGIN_MESSAGE_MAP(CNTDEVICETESTApp, CWinApp)
	//{{AFX_MSG_MAP(CNTDEVICETESTApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNTDEVICETESTApp construction

CNTDEVICETESTApp::CNTDEVICETESTApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CNTDEVICETESTApp object

CNTDEVICETESTApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CNTDEVICETESTApp initialization

BOOL CNTDEVICETESTApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CNTDEVICETESTDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\ntdevicetestdlg.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// NTDEVICETESTDlg.h : header file
//

#if !defined(AFX_NTDEVICETESTDLG_H__25764CA8_F1B7_11D1_B166_00A0C905A445__INCLUDED_)
#define AFX_NTDEVICETESTDLG_H__25764CA8_F1B7_11D1_B166_00A0C905A445__INCLUDED_

#include "cfgmgrcomputer.h"
#include "cfgmgrdevice.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CNTDEVICETESTDlg dialog

class CNTDEVICETESTDlg : public CDialog
{
// Construction
public:
	CNTDEVICETESTDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CNTDEVICETESTDlg)
	enum { IDD = IDD_NTDEVICETEST_DIALOG };
	CStatic	m_wndSibling;
	CStatic	m_wndChild;
	CStatic	m_wndParent;
	CStatic	m_wndBusNumber;
	CStatic	m_wndBusType;
	CListBox	m_wndHardwareIDList;
	CStatic	m_wndConfigFlags;
	CStatic	m_wndDeviceID;
	CStatic	m_wndIRQ;
	CStatic	m_wndProblem;
	CStatic	m_wndStatus;
	CStatic	m_wndService;
	CStatic	m_wndClass;
	CStatic	m_wndDriver;
	CListBox	m_wndDeviceList;
	int		m_nDeviceList;
	CString	m_strClassType;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNTDEVICETESTDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual void OnOK( void );	// DDX/DDV support
	virtual void OnCancel( void );	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CNTDEVICETESTDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	afx_msg void OnDeviceListSelChange();
	DECLARE_MESSAGE_MAP()

private:

	void FillDeviceList( LPCTSTR pszClassType, LPCTSTR pszDeviceID );
	void ClearDeviceList( void );
	BOOL CreateSubtree( CConfigMgrDevice* pParent, CConfigMgrDevice* pSibling, DEVNODE dn, LPCTSTR pszClassType );

	CPtrList	m_DeviceList;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NTDEVICETESTDLG_H__25764CA8_F1B7_11D1_B166_00A0C905A445__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\pshpack1.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\poormansresource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __POORMANSRESOURCE_H__
#define __POORMANSRESOURCE_H__

#include "cfgmgr32.h"

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

struct	Mem_Des16_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des16_s 	MEM_DES16;

struct	IO_Des16_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des16_s 	IO_DES16;

struct	DMA_Des16_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des16_s 	DMA_DES16;

struct	IRQ_Des16_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des16_s 	IRQ_DES16;

typedef	MEM_DES16			*PMEM_DES16;
typedef	IO_DES16			*PIO_DES16;
typedef	DMA_DES16			*PDMA_DES16;
typedef	IRQ_DES16			*PIRQ_DES16;

// BUS Info structs from KBASE
typedef struct PnPAccess_s    {
       BYTE    bCSN;   // card slot number
       BYTE    bLogicalDevNumber;      // Logical Device #
       WORD    wReadDataPort;          // Read data port
} sPnPAccess;

typedef struct  PCIAccess_s     {
       BYTE    bBusNumber;     // Bus no 0-255
       BYTE    bDevFuncNumber; // Device # in bits 7:3 and
                               // Function # in bits 2:0
       WORD    wPCIReserved;   //
} sPCIAccess;

typedef struct EISAAccess_s     {
       BYTE    bSlotNumber;    // EISA board slot number
       BYTE    bFunctionNumber;
       WORD    wEisaReserved;
} sEISAAccess;

typedef struct PCMCIAAccess_s   {
       WORD    wLogicalSocket;     // Card socket #
       WORD    wPCMCIAReserved;    // Reserved
} sPCMCIAAccess;

typedef struct BIOSAccess_s     {
       BYTE    bBIOSNode;          // Node number
} sBIOSAccess;

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040

/*********************************************************************

  The following information was not copied, it is information I pieced
  together on my own.  It probably exists somewhere but I was too
  lazy to find it, so I pieced it together myself.

**********************************************************************/

// OKAY, Here's my definition of the header that precedes each and every resource
// descriptor as far as I can tell.

// This is the size (as far as I can tell) of the resource header that precedes
// each resource descriptor.  The header consists of a DWORD indicating the total
// size of the resource (including the header), a WORD which is the 16-bit Resource
// Id being described, and a byte of padding.

#pragma pack (1)
struct	POORMAN_RESDESC_HDR		// Hacked out with much pain and frustration
{
	DWORD	dwResourceSize;		// Size of resource including header
	DWORD	dwResourceId;		// Resource Id
};
#pragma pack()

typedef POORMAN_RESDESC_HDR*	PPOORMAN_RESDESC_HDR;

#define	SIZEOF_RESDESC_HDR		sizeof(POORMAN_RESDESC_HDR)

#define	FIRST_RESOURCE_OFFSET	8	// Offset off first resource

// Use to mask out all values other than Resource Type (first 5 bits)
#define	RESOURCE_TYPE_MASK		0x0000001F

// Use to mask out all values other than OEM Number
#define	OEM_NUMBER_MASK		0x00007FE0

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\sms95lanexp.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SMS95LANEXP_H__
#define __SMS95LANEXP_H__

#define CIM32NET_DLL	"CIM32NET.DLL"
typedef ULONG* LPULONG;
typedef DWORD CMBUSTYPE;
typedef CMBUSTYPE* PCMBUSTYPE;

// Function prototypes for dynamic linking
typedef DWORD (WINAPI* PCIM32THK_CM_LOCATE_DEVNODE) ( PDEVNODE pdn, LPSTR HardwareKey, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_CHILD) ( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_SIBLING) ( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_READ_REGISTRY_VALUE) ( DEVNODE dnDevNode, LPSTR pszSubKey, LPSTR pszValueName, ULONG ulExpectedType, LPVOID Buffer, LPULONG pulLength, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVNODE_STATUS) ( LPULONG pulStatus, LPULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVICE_ID) ( DEVNODE dnDevNode, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVICE_ID_SIZE) ( LPULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_FIRST_LOG_CONF) ( PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_NEXT_RES_DES) ( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_RES_DES_DATA_SIZE) ( LPULONG pulSize, RES_DES rdResDes, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_RES_DES_DATA) ( RES_DES rdResDes, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_BUS_INFO) (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags);
typedef DWORD (WINAPI* PCIM32THK_CM_GET_PARENT) ( PDEVNODE pdn, DEVNODE dnChild, ULONG ulFlags );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\stdafx.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__25764CAA_F1B7_11D1_B166_00A0C905A445__INCLUDED_)
#define AFX_STDAFX_H__25764CAA_F1B7_11D1_B166_00A0C905A445__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__25764CAA_F1B7_11D1_B166_00A0C905A445__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\resource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NTDEVICETEST.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_NTDEVICETEST_DIALOG         102
#define IDR_MAINFRAME                   128
#define IDC_DEVICELIST                  1000
#define IDC_CLASS                       1001
#define IDC_DRIVER                      1002
#define IDC_SERVICE                     1003
#define IDC_STATUS                      1004
#define IDC_PROBLEM                     1005
#define IDC_CLASSTYPE                   1006
#define IDC_IRQ                         1007
#define IDC_DEVICEID                    1008
#define IDC_CONFIGFLAGS                 1009
#define IDC_HARDWAREID                  1010
#define IDC_BUSTYPE                     1011
#define IDC_BUSNUMBER                   1012
#define IDC_PARENT                      1013
#define IDC_CHILD                       1016
#define IDC_SIBLING                     1017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\stdafx.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	NTDEVICETEST.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\util.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <stdafx.h>
#include "util.h"

BOOL IsWinNT( void )
{
	OSVERSIONINFO	os;

	os.dwOSVersionInfoSize = sizeof(os);

	GetVersionEx( &os );

	return ( VER_PLATFORM_WIN32_NT == os.dwPlatformId );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\util.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef __UTIL_H__
#define __UTIL_H__

BOOL IsWinNT( void );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\context.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  CONTEXT.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemNamedValueSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemNamedValueSet::CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemNamedValueSet::CSWbemNamedValueSet()
	: m_pCWbemPathCracker (NULL),
	  m_bMutable (true),
	  m_cRef (0),
	  m_pIWbemContext (NULL),
	  m_pSWbemServices (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemNamedValueSet, 
						CLSID_SWbemNamedValueSet, L"SWbemNamedValueSet");
    
	// Create a context
	CoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemContext, (LPVOID *) &m_pIWbemContext);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemNamedValueSet::CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemNamedValueSet::CSWbemNamedValueSet(
	CSWbemServices	*pService, 
	IWbemContext	*pContext
)
	: m_pCWbemPathCracker (NULL),
	  m_bMutable (true),
	  m_cRef (0),
	  m_pIWbemContext (pContext),
	  m_pSWbemServices (pService)
{
	m_Dispatch.SetObj (this, IID_ISWbemNamedValueSet, 
						CLSID_SWbemNamedValueSet,  L"SWbemNamedValueSet");
	
	if (m_pIWbemContext)
		m_pIWbemContext->AddRef ();
	
	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemNamedValueSet::CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemNamedValueSet::CSWbemNamedValueSet(
	CWbemPathCracker *pCWbemPathCracker,
	bool			bMutable
)
	: m_pCWbemPathCracker (pCWbemPathCracker),
	  m_bMutable (bMutable),
	  m_cRef (0),
	  m_pIWbemContext (NULL),
	  m_pSWbemServices (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemNamedValueSet, 
						CLSID_SWbemNamedValueSet,  L"SWbemNamedValueSet");
    
	// Create a context
	CoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemContext, (LPVOID *) &m_pIWbemContext);

	if (m_pCWbemPathCracker)
	{
		m_pCWbemPathCracker->AddRef ();

		// Artificial refcount hike as the following may do an AddRef/Release 
		// pair on this
		m_cRef++;
		BuildContextFromKeyList ();
		m_cRef--;
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemNamedValueSet::~CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemNamedValueSet::~CSWbemNamedValueSet(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemContext)
	{
		m_pIWbemContext->EndEnumeration ();
		m_pIWbemContext->Release ();
		m_pIWbemContext = NULL;
	}

	RELEASEANDNULL(m_pSWbemServices)
	RELEASEANDNULL(m_pCWbemPathCracker)
}

//***************************************************************************
// HRESULT CSWbemNamedValueSet::QueryInterface
// long CSWbemNamedValueSet::AddRef
// long CSWbemNamedValueSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValueSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISWbemNamedValueSet==riid)
		*ppv = (ISWbemNamedValueSet *)this;
	else if (IID_ISWbemInternalContext==riid)
        *ppv = (ISWbemInternalContext *) this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *) this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *) this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemNamedValueSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemNamedValueSet::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemNamedValueSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValueSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemNamedValueSet == riid) ? S_OK : S_FALSE;
}

void CSWbemNamedValueSet::BuildContextFromKeyList ()
{
	if (m_pCWbemPathCracker)
	{
		ULONG lKeyCount = 0;

		if (m_pCWbemPathCracker->GetKeyCount (lKeyCount))
		{
			for (ULONG i = 0; i <lKeyCount; i++)
			{
				VARIANT var;
				VariantInit (&var);
				CComBSTR bsName;
				WbemCimtypeEnum cimType;
				
				if (m_pCWbemPathCracker->GetKey (i, bsName, var, cimType))
				{
					SetValueIntoContext (bsName, &var, 0);
				}

				VariantClear (&var);
			}
		}
	}
}

//***************************************************************************
//
//  CSWbemNamedValueSet::GetIWbemContext
//
//  DESCRIPTION:
//
//  Return the IWbemContext interface corresponding to this scriptable wrapper.
//
//  PARAMETERS:
//		ppContext		holds the IWbemContext pointer on return
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValueSet::GetIWbemContext (IWbemContext **ppContext)
{
	HRESULT hr = S_OK;  // By default if we have no context to copy

	if (ppContext)
	{
		*ppContext = NULL;

		if (m_pIWbemContext)
		{
			/*
			 * Before returning a context, we ensure that coercion is performed
			 * to render the type down to either an IUnknown or a Qualifier
			 * type.  This is done for the benefit of imposing a fixed typing
			 * system for provider context, rather than have providers take
			 * the burden of using VariantChangeType etc. themselves.
			 */

			if (SUCCEEDED (hr = m_pIWbemContext->Clone (ppContext)))
			{
				if (SUCCEEDED (hr = (*ppContext)->BeginEnumeration (0)))
				{
					BSTR	bsName = NULL;
					VARIANT	var;
					VariantInit (&var);

					while (WBEM_S_NO_ERROR == (*ppContext)->Next(0, &bsName, &var))
					{
						VARIANT vTemp;
						VariantInit (&vTemp);

						// Stage 1 of transformation involves homogenisation of 
						// arrays, transformation of JScript arrays, and weedling 
						// out of IWbemClassObject's
						//
						// If successful hr will be a a success code and vTemp will
						// hold the value, which will either be a VT_UNKNOWN or a 
						// "simple" (non-object) type, or array thereof.

						if((VT_ARRAY | VT_VARIANT) == V_VT(&var))
						{
							// A classical dispatch-style array of variants - map them
							// down to a homogeneous array of primitive values
						
							if (SUCCEEDED(hr = ConvertArray(&vTemp, &var)))
							{
								// Now check if we should map any VT_DISPATCH's inside 
								// the array
								hr = MapToCIMOMObject(&vTemp);
							}
						}
						else if (VT_DISPATCH == V_VT(&var))
						{
							// First try a JScript array - if this succeeds it
							// will map to a regular SAFEARRAY.  If not, we try
							// to map to an IWbem interface
							if (FAILED(ConvertDispatchToArray (&vTemp, &var)))
							{
								if (SUCCEEDED (hr = VariantCopy (&vTemp, &var)))
									hr = MapToCIMOMObject(&vTemp);
							}
						}
						else
						{
							// Just copy so we have the result in vTemp in all cases
							hr = VariantCopy (&vTemp, &var);
						}

						// Stage 2 of the transformation involves casting of simple
						// (non-VT_UNKNOWN) types to a qualifier type.

						if (SUCCEEDED (hr))
						{
							if (VT_UNKNOWN != (V_VT(&vTemp) & ~(VT_ARRAY|VT_BYREF)))
							{
								// Not a VT_UNKNOWN so try to cast to a qualifier type
				
								VARIANT vFinal;
								VariantInit (&vFinal);

								VARTYPE vtOK = GetAcceptableQualType(V_VT(&vTemp));

 								if (vtOK != V_VT(&vTemp))
								{
									// Need to coerce
									if (SUCCEEDED(hr = QualifierVariantChangeType (&vFinal, &vTemp, vtOK)))
										hr = (*ppContext)->SetValue (bsName, 0, &vFinal);
								}
								else
									hr = (*ppContext)->SetValue (bsName, 0, &vTemp);

								VariantClear (&vFinal);
							}
							else
								hr = (*ppContext)->SetValue (bsName, 0, &vTemp);
						}

						VariantClear (&vTemp);
						SysFreeString (bsName);
						bsName = NULL;
						VariantClear (&var);
					}

					(*ppContext)->EndEnumeration ();
				}
			}
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Clone
//
//  DESCRIPTION:
//
//  Clone object
//
//  PARAMETERS:
//		ppCopy		On successful return addresses the copy
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Clone (
	ISWbemNamedValueSet **ppCopy
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppCopy)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemContext)
	{
		IWbemContext *pWObject = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemContext->Clone (&pWObject)))
		{
			// NB: the cloned set is always mutable
			CSWbemNamedValueSet *pCopy = 
					new CSWbemNamedValueSet (m_pSWbemServices, pWObject);

			if (!pCopy)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pCopy->QueryInterface (IID_ISWbemNamedValueSet, 
										(PPVOID) ppCopy)))
				delete pCopy;

			pWObject->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::BeginEnumeration
//
//  DESCRIPTION:
//
//  Kick off a value enumeration
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::BeginEnumeration (
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemContext)
	{
		// Preface with an end enumeration just in case
		hr = m_pIWbemContext->EndEnumeration ();
		hr = m_pIWbemContext->BeginEnumeration (0);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Next
//
//  DESCRIPTION:
//
//  Iterate through value enumeration
//
//  PARAMETERS:
//		lFlags				Flags
//		ppNamedValue		The next named value (or NULL if at end)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Next (
	long lFlags,
	ISWbemNamedValue	**ppNamedValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNamedValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppNamedValue = NULL;

		if (m_pIWbemContext)
		{
			BSTR	name = NULL;
			VARIANT	var;
			VariantInit (&var);
			
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemContext->Next (lFlags, 
											&name, &var)))
			{
				*ppNamedValue = new CSWbemNamedValue (m_pSWbemServices, 
										this, name, m_bMutable);

				if (!(*ppNamedValue))
					hr = WBEM_E_OUT_OF_MEMORY;

				SysFreeString (name);
			}

			VariantClear (&var);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Add
//
//  DESCRIPTION:
//
//  Add named value to set
//
//  PARAMETERS:
//
//		bsName			The property to update/create
//		pVal			The value
//		lFlags			Flags
//		ppNamedValue	The named value created
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Add (
	BSTR bsName,
	VARIANT *pVal,
	long lFlags,
	ISWbemNamedValue **ppNamedValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppNamedValue) || (NULL == bsName) || (NULL == pVal))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pIWbemContext)
	{
		*ppNamedValue = NULL;

		if (VT_BYREF & V_VT(pVal))
		{
			// We must dereference all byref's
			VARIANT var;
			VariantInit (&var);

			if (VT_ARRAY & V_VT(pVal))
			{
				var.vt = V_VT(pVal) & ~VT_BYREF;
				hr = SafeArrayCopy (*(pVal->pparray), &(var.parray));
			}
			else
				hr = VariantChangeType(&var, pVal, 0, V_VT(pVal) & ~VT_BYREF);

			if (SUCCEEDED(hr))
					hr = m_pIWbemContext->SetValue (bsName, lFlags, &var);
			
			VariantClear (&var);
		}
		else if ((VT_ERROR == V_VT(pVal)) && (DISP_E_PARAMNOTFOUND == pVal->scode))
		{
			// Treat as NULL assignment
			pVal->vt = VT_NULL;
			hr = m_pIWbemContext->SetValue (bsName, lFlags, pVal);
		}
		else
			hr = m_pIWbemContext->SetValue (bsName, lFlags, pVal);

		if (SUCCEEDED (hr))
		{
			WbemCimtypeEnum cimtype = MapVariantTypeToCimType(pVal);
			
			// Add to the path key list if we have one - note this MAY fail
			if (m_pCWbemPathCracker)
			{
				if (!m_pCWbemPathCracker->SetKey (bsName, cimtype, *pVal))
				{
					// Rats - delete it
					m_pIWbemContext->DeleteValue (bsName, 0);
					hr = WBEM_E_FAILED;
				}
			}

			if (SUCCEEDED(hr))
			{
				*ppNamedValue = new CSWbemNamedValue (m_pSWbemServices, 
										this, bsName);

				if (!(*ppNamedValue))
					hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
		
	return hr;
}


HRESULT CSWbemNamedValueSet::SetValueIntoContext (
	BSTR		bsName,
	VARIANT		*pVal,
	ULONG		lFlags
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pIWbemContext)
	{
		if (VT_BYREF & V_VT(pVal))
		{
			// We must dereference all byref's
			VARIANT var;
			VariantInit (&var);

			if (VT_ARRAY & V_VT(pVal))
			{
				var.vt = V_VT(pVal) & ~VT_BYREF;
				hr = SafeArrayCopy (*(pVal->pparray), &(var.parray));
			}
			else
				hr = VariantChangeType(&var, pVal, 0, V_VT(pVal) & ~VT_BYREF);

			if (SUCCEEDED(hr))
					hr = m_pIWbemContext->SetValue (bsName, lFlags, &var);
			
			VariantClear (&var);
		}
		else if ((VT_ERROR == V_VT(pVal)) && (DISP_E_PARAMNOTFOUND == pVal->scode))
		{
			// Treat as NULL assignment
			pVal->vt = VT_NULL;
			hr = m_pIWbemContext->SetValue (bsName, lFlags, pVal);
		}
		else
			hr = m_pIWbemContext->SetValue (bsName, lFlags, pVal);
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Item
//
//  DESCRIPTION:
//
//  Get named value
//
//  PARAMETERS:
//
//		bsName			The value to retrieve
//		lFlags			Flags
//		ppNamedValue	On successful return addresses the value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Item (
	BSTR bsName,
	long lFlags,
    ISWbemNamedValue **ppNamedValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNamedValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemContext)
	{
		VARIANT var;
		VariantInit (&var);

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemContext->GetValue (bsName, lFlags, &var)))
		{
			*ppNamedValue = new CSWbemNamedValue (m_pSWbemServices, 
									this, bsName, m_bMutable);

			if (!(*ppNamedValue))
				hr = WBEM_E_OUT_OF_MEMORY;
		}

		VariantClear (&var);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Remove
//
//  DESCRIPTION:
//
//  Delete named value
//
//  PARAMETERS:
//
//		bsName		The value to delete
//		lFlags		Flags
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Remove (
	BSTR bsName,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pIWbemContext)
		hr = m_pIWbemContext->DeleteValue (bsName, lFlags);

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Remove from our key list if we have one
		if (m_pCWbemPathCracker)
			hr = m_pCWbemPathCracker->RemoveKey (bsName);
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::DeleteAll
//
//  DESCRIPTION:
//
//  Empty the bag
//
//  PARAMETERS:
//		None
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::DeleteAll (
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pIWbemContext)
		hr = m_pIWbemContext->DeleteAll ();

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Empty the key list
		if (m_pCWbemPathCracker)
			m_pCWbemPathCracker->RemoveAllKeys ();	
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CContextEnumVar *pEnum = new CContextEnumVar (this, 0);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = 0;

		if (m_pIWbemContext)
		{
			/*
			 * This is not the most efficient way of obtaining the count,
			 * but it is the on