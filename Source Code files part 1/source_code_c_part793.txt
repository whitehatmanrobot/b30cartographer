
	DWORD cbBytesRead;
	bool fContinueReading = true;

	// Read the Output Type
	if (!ReadFileLine())
		 return false;

	while (fContinueReading)
	{
		// If this is the second iteration (or more) we may not be at the
		// start of our buffer (causing the read of the output type to fail)
		ResetBufferPointerToStart();

		// Read the Output Type line...
		cbBytesRead = ReadString(szTemporaryBuffer, BUFFER_SIZE);

		// We gotta read something?
		if (0 == cbBytesRead)
			return true;
		
		// I hate to do this... but we read this stuff as ASCII... may need to
		// convert to a TCHAR format to be neutral...
		CUtilityFunctions::CopyAnsiStringToTSTR(szTemporaryBuffer, tszTemporaryBuffer, cbBytesRead+1);

		// Printout the section we're attempting to read...
		if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
			_tprintf(TEXT("  Reading %s data...\n"), tszTemporaryBuffer);

		if ( _tcsicmp(g_tszCollectionArray[Processes].tszCSVLabel, tszTemporaryBuffer) == 0 )
		{
			/*
				[PROCESSES]
			*/

			// Read to the end of the line
			if (!ReadFileLine())
				return false;

			// Yup, it is... let's create a Processes Object
			if (*lplpProcesses == NULL)
			{
				// Allocate a structure for our Processes Object.
				*lplpProcesses = new CProcesses();
				
				if (!*lplpProcesses)
				{
					_tprintf(TEXT("Unable to allocate memory for the processes object!\n"));
					goto cleanup;
				}

				// The Processes Object will init differently depending on what
				// Command-Line arguments have been provided... 
				if (!(*lplpProcesses)->Initialize(lpModuleInfoCache, this, lpOutputFile))
				{
					_tprintf(TEXT("Unable to initialize Processes Object!\n"));
					goto cleanup;
				}
			}

			// Okay, go get the Process Data...
			(*lplpProcesses)->GetProcessesData();

		} else
		if ( _tcsicmp(g_tszCollectionArray[Process].tszCSVLabel, tszTemporaryBuffer) == 0 )
		{
			/*
				[PROCESS]
			*/
			// Read to the end of the line
			if (!ReadFileLine())
				return false;

			// Yup, it is... let's create a ProcessInfo Object
			if (*lplpProcess== NULL)
			{
				// Allocate a structure for our ProcessInfo Object.
				*lplpProcess = new CProcessInfo();
				
				if (!*lplpProcess)
				{
					_tprintf(TEXT("Unable to allocate memory for the processinfo object!\n"));
					goto cleanup;
				}

				// The Modules Object will init differently depending on what
				// Command-Line arguments have been provided... 
				if (!(*lplpProcess)->Initialize(lpModuleInfoCache, this, lpOutputFile, NULL))
				{
					_tprintf(TEXT("Unable to initialize Modules Object!\n"));
					goto cleanup;
				}
			}

			// Okay, go get the Process Data
			(*lplpProcess)->GetProcessData();
		} else
		if ( _tcsicmp(g_tszCollectionArray[Modules].tszCSVLabel, tszTemporaryBuffer) == 0 )
		{
			/*
				[MODULES]
			*/
			// Read to the end of the line
			if (!ReadFileLine())
				return false;

			// Yup, it is... let's create a Modules Object
			if (*lplpModules == NULL)
			{
				// Allocate a structure for our Modules Object.
				*lplpModules = new CModules();
				
				if (!*lplpModules)
				{
					_tprintf(TEXT("Unable to allocate memory for the modules object!\n"));
					goto cleanup;
				}

				// The Modules Object will init differently depending on what
				// Command-Line arguments have been provided... 
				if (!(*lplpModules)->Initialize(lpModuleInfoCache, this, lpOutputFile, NULL))
				{
					_tprintf(TEXT("Unable to initialize Modules Object!\n"));
					goto cleanup;
				}
			}

			// Okay, go get the Modules Data (collected from the filesystem)
			(*lplpModules)->GetModulesData(CProgramOptions::InputModulesDataFromFileSystemMode, true);
		} else
		if ( _tcsicmp(g_tszCollectionArray[KernelModeDrivers].tszCSVLabel, tszTemporaryBuffer) == 0 )
		{
			/*
				[KERNEL-MODE DRIVERS]
			*/
			// Read to the end of the line
			if (!ReadFileLine())
				return false;

			// Yup, it is... let's create a Modules Object
			if (*lplpKernelModeDrivers == NULL)
			{
				// Allocate a structure for our Modules Object.
				*lplpKernelModeDrivers = new CModules();
				
				if (!*lplpKernelModeDrivers)
				{
					_tprintf(TEXT("Unable to allocate memory for the modules object!\n"));
					goto cleanup;
				}

				// The Modules Object will init differently depending on what
				// Command-Line arguments have been provided... 
				if (!(*lplpKernelModeDrivers)->Initialize(lpModuleInfoCache, this, lpOutputFile, NULL))
				{
					_tprintf(TEXT("Unable to initialize Modules Object!\n"));
					goto cleanup;
				}
			}

			// Okay, go get the Modules Data (collected from the filesystem)
			(*lplpKernelModeDrivers)->GetModulesData(CProgramOptions::InputDriversFromLiveSystemMode, true);
		} else
		{
			_tprintf(TEXT("Unrecognized section %s found!\n"), tszTemporaryBuffer);
			return false;
		}
	}

cleanup:
	return false;
}

bool CFileData::ReadDWORD(LPDWORD lpDWORD)
{
	char szTempBuffer[10+1]; // 0xFFFFFFFF == 4294967295 (10 characters) + 1 for the \0

	if (!ReadString(szTempBuffer, 10+1))
		return false;

	// Convert it... baby...
	*lpDWORD = atoi(szTempBuffer);

	return true;
}

bool CFileData::CopyCharIfRoom(DWORD iStringBufferSize, LPSTR szStringBuffer, LPDWORD piBytesCopied, bool *pfFinished)
{
	if (iStringBufferSize)
	{
		// If we have room to copy the data... let's do it...
		if (*piBytesCopied < iStringBufferSize)
		{
			szStringBuffer[(*piBytesCopied)++] = *(m_lpCurrentLocationInLINEBUFFER++);
		} else
		{
			// No room... we're done.
			*pfFinished = true;
		}
	} else
	{
		// Just advance the pointer... we have no buffer to copy to...
		m_lpCurrentLocationInLINEBUFFER++;
	}

	return true;
}

bool CFileData::ResetBufferPointerToStart()
{
	// Reset the Pointer with our line buffer to the start of this buffer
	m_lpCurrentLocationInLINEBUFFER = m_szLINEBUFFER;

	return true;
}

bool CFileData::EndOfFile()
{
	//return (*m_lpCurrentFilePointer == '\0');
	return (*m_lpCurrentLocationInLINEBUFFER == '\0');
}

bool CFileData::WriteFileTimeString(FILETIME ftFileTime)
{
	enum {BUFFERSIZE = 128};

	TCHAR tszBuffer[BUFFERSIZE];
	FILETIME ftLocalFileTime;
	SYSTEMTIME lpSystemTime;
	int cch = 0;

	// Let's convert this to a local file time first...
	if (!FileTimeToLocalFileTime(&ftFileTime, &ftLocalFileTime))
		return false;

	FileTimeToSystemTime( &ftLocalFileTime, &lpSystemTime );

	
	cch = GetDateFormat( LOCALE_USER_DEFAULT,
						 0,
						 &lpSystemTime,
						 TEXT("MMMM d',' yyyy"),
						 tszBuffer,
						 BUFFERSIZE );

	if (!cch)
		return false;

	tszBuffer[cch-1] = TEXT(' '); 

	// 
    // Get time and format to characters 
    // 
 
    GetTimeFormat( LOCALE_USER_DEFAULT, 
				   0, 
				   &lpSystemTime,   // use current time 
				   NULL,   // use default format 
				   tszBuffer + cch, 
				   BUFFERSIZE - cch ); 
 

	// <Full Month Name> <day>, <Year with Century> <Hour>:<Minute>:<Second>
	//_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%B %d, %Y %H:%M:%S"), localtime(&Time));
	//_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%c"), localtime(&Time));

	if (!WriteString(tszBuffer, true))
		return false;

	return true;
}

// Exception Monitor prefers a MM/DD/YYYY HH:MM:SS format...
bool CFileData::WriteTimeDateString2(time_t Time)
{
	enum {BUFFERSIZE = 128};

	TCHAR tszBuffer[BUFFERSIZE];

	// This top version seems to be better Y2K friendly as I spit out the full year...
	_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%m/%d/%Y %H:%M:%S"), localtime(&Time));
	//_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%c"), localtime(&Time));

	if (!WriteString(tszBuffer, true))
		return false;

	return true;
}

// Exception Monitor prefers a MM/DD/YYYY HH:MM:SS format...
bool CFileData::WriteFileTimeString2(FILETIME ftFileTime)
{
	enum {BUFFERSIZE = 128};

	TCHAR tszBuffer[BUFFERSIZE];
	FILETIME ftLocalFileTime;
	SYSTEMTIME lpSystemTime;
	int cch = 0;

	// Let's convert this to a local file time first...
	if (!FileTimeToLocalFileTime(&ftFileTime, &ftLocalFileTime))
		return false;

	FileTimeToSystemTime( &ftLocalFileTime, &lpSystemTime );

	
	cch = GetDateFormat( LOCALE_USER_DEFAULT,
						 0,
						 &lpSystemTime,
						 TEXT("MM/dd/yyyy"),
						 tszBuffer,
						 BUFFERSIZE );

	if (!cch)
		return false;

	tszBuffer[cch-1] = TEXT(' '); 

	// 
    // Get time and format to characters 
    // 
 
    GetTimeFormat( LOCALE_USER_DEFAULT, 
				   0, 
				   &lpSystemTime,   // use current time 
				   TEXT("HH:mm:ss"),   // use default format 
				   tszBuffer + cch, 
				   BUFFERSIZE - cch ); 

	if (!WriteString(tszBuffer, true))
		return false;

	return true;
}

//#endif

bool CFileData::WriteGUID(GUID & Guid)
{
	TCHAR tszGUID[39];
	WCHAR wszGUID[39];
 
	if (StringFromGUID2(Guid, wszGUID, 39) == 0)
		return false;

	CUtilityFunctions::CopyUnicodeStringToTSTR(wszGUID, tszGUID, 39);

	if (!WriteString(tszGUID))
		return false;

	return true;
}

unsigned int CFileData::LengthOfString()
{
	unsigned int length = 0;

	LPSTR lpCurrentPosition = m_lpCurrentLocationInLINEBUFFER;

	if (lpCurrentPosition)
	{
		while (*lpCurrentPosition)
		{
			length++;
			lpCurrentPosition++;
		}
	}

	return length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\dmpfile.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       dmpfile.h
//
//--------------------------------------------------------------------------

// DmpFile.h: interface for the CDmpFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DMPFILE_H__8BCD59C6_0CEA_11D3_84F0_000000000000__INCLUDED_)
#define AFX_DMPFILE_H__8BCD59C6_0CEA_11D3_84F0_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
//#include <windows.h>
//#include <tchar.h>
#include "globals.h"

#pragma warning (push)
#pragma warning ( disable : 4100 4201 4710)
#include <dbgeng.h>
#pragma warning (pop)

// Forward Declarations
class CProcessInfo;
class CModules;
class CModuleInfoCache;
class CFileData;

// Let's implement the DebugOutputCallback for the DBGENG... it'll be cool to have the debugger
// spit out info to us when it is running...

class OutputCallbacks : public IDebugOutputCallbacks
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    
    // This method is only called if the supplied mask
    // is allowed by the clients output control.
    // The return value is ignored.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

class CDmpFile  
{
public:
	CDmpFile();
	virtual ~CDmpFile();
	bool Initialize(CFileData * lpOutputFile);
	bool CollectData(CProcessInfo ** lplpProcessInfo, CModules ** lplpModules, CModuleInfoCache * lpModuleInfoCache); 

	inline bool IsUserDmpFile() {
		return (m_DumpClass == DEBUG_CLASS_USER_WINDOWS);
		};

	IDebugSymbols2 * m_pIDebugSymbols2;
	IDebugDataSpaces * m_pIDebugDataSpaces;

protected:
	bool			m_fDmpInitialized;
	CFileData *	m_lpOutputFile;

	LPSTR		m_szDmpFilePath;
	LPSTR		m_szSymbolPath;
	LPSTR		m_szExePath;

	IDebugControl * m_pIDebugControl;
	IDebugClient * m_pIDebugClient;
	ULONG m_DumpClass;
	ULONG m_DumpClassQualifier;

	bool EumerateModulesFromDmp(CModuleInfoCache * lpModuleInfoCache, CProcessInfo * lpProcessInfo, CModules * lpModules);
};

#endif // !defined(AFX_DMPFILE_H__8BCD59C6_0CEA_11D3_84F0_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\filedata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       filedata.h
//
//--------------------------------------------------------------------------

// FileData.h: interface for the CFileData class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILEDATA_H__A7830023_AF56_11D2_83E6_000000000000__INCLUDED_)
#define AFX_FILEDATA_H__A7830023_AF56_11D2_83E6_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif
#include <windows.h>
#include <tchar.h>
#include <time.h>

// Forward Declarations
class CProcesses;
class CProcessInfo;
class CModules;
class CModuleInfoCache;


class CFileData  
{
public:
	unsigned int LengthOfString();
	CFileData();
	virtual ~CFileData();

	bool OpenFile(DWORD dwCreateOption = CREATE_NEW, bool fReadOnlyMode = false);
	bool CreateFileMapping();
	bool CloseFile();
	bool EndOfFile();

	void PrintLastError();

	// Filepath methods
	bool SetFilePath(LPTSTR tszFilePath);
	LPTSTR GetFilePath();
	bool VerifyFileDirectory();
	
	// Checksym output methods...
	bool WriteFileHeader();
	bool WriteTimeDateString(time_t Time);
	bool WriteFileTimeString(FILETIME ftFileTime);

	bool WriteTimeDateString2(time_t Time);
	bool WriteFileTimeString2(FILETIME ftFileTime);

	bool WriteString(LPTSTR tszString, bool fHandleQuotes = false);
	bool WriteDWORD(DWORD dwNumber);
	bool WriteGUID(GUID & Guid);

	// Checksym input methods...
	bool ReadFileHeader();
	bool ReadFileLine();
	DWORD ReadString(LPSTR szStringBuffer = NULL, DWORD iStringBufferSize = 0);
	bool ResetBufferPointerToStart();
	bool ReadDWORD(LPDWORD lpDWORD);
	
	bool DispatchCollectionObject(CProcesses ** lplpProcesses, CProcessInfo ** lplpProcess, CModules ** lplpModules, CModules ** lplpKernelModeDrivers, CModuleInfoCache * lpModuleInfoCache, CFileData * lpOutputFile);

	// Define a constant for our "private" buffer...
	enum {LINE_BUFFER_SIZE = 65536};		  // 64K is the maximum line length (for now)
	char m_szLINEBUFFER[LINE_BUFFER_SIZE]; // This saves us tons of create/free stuff...
	
protected:
	bool CopyCharIfRoom(DWORD iStringBufferSize, LPSTR szStringBuffer, LPDWORD piBytesCopied, bool * pfFinished);

	LPSTR m_lpCurrentLocationInLINEBUFFER;
	LPSTR m_lpCurrentFilePointer;
	LPVOID m_lpBaseAddress;
	HANDLE m_hFileMappingObject;
	 
	// Error methods
	inline DWORD GetLastError() { return m_dwGetLastError; };
	inline void SetLastError() { m_dwGetLastError = ::GetLastError(); };

	LPTSTR m_tszFilePath;
	HANDLE m_hFileHandle;
	DWORD m_dwGetLastError;
};

#endif // !defined(AFX_FILEDATA_H__A7830023_AF56_11D2_83E6_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\globals.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       Globals.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"

// This is necessary to allocate the GUIDS used by the DBGENG.DLL interfaces
#define INITGUID

#pragma warning (push)
#pragma warning ( disable : 4100 4201 4710)
#include <dbgeng.h>
#pragma warning (pop)

CDelayLoad * g_lpDelayLoad;
CProgramOptions * g_lpProgramOptions;
CSymbolVerification * g_lpSymbolVerification;

// Global String Structure
CollectionStruct g_tszCollectionArray[] = {

	// PROCESSES (used for -P)
	TEXT("System Process(es)"), 
	TEXT("CSV System Process(es)"),
	TEXT("[PROCESSES]"),
	TEXT(",Process Name,Process ID,Module Path,Symbol Status,Checksum,Time/Date Stamp,Time/Date String,Size Of Image,DBG Pointer,PDB Pointer,PDB Signature,PDB Age,Product Version,File Version,Company Name,File Description,File Size,File Time/Date Stamp (High),File Time/Date Stamp (Low),File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n"),

	// PROCESS (used for -Z USER.DMP file)
	TEXT("Process"),
	TEXT("CSV Process"),
	TEXT("[PROCESS]"),
	TEXT(",Process Name,Process ID,Module Path,Symbol Status,Checksum,Time/Date Stamp,Time/Date String,Size Of Image,DBG Pointer,PDB Pointer,PDB Signature,PDB Age,Product Version,File Version,Company Name,File Description,File Size,File Time/Date Stamp (High),File Time/Date Stamp (Low),File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n"),
	
	// MODULES (used for -F <filespec>)
	TEXT("Filesystem Modules"),
	TEXT("CSV Filesystem Modules"),
	TEXT("[FILESYSTEM MODULES]"),
	TEXT(",,,Module Path,Symbol Status,Checksum,Time/Date Stamp,Time/Date String,Size Of Image,DBG Pointer,PDB Pointer,PDB Signature,PDB Age,Product Version,File Version,Company Name,File Description,File Size,File Time/Date Stamp (High),File Time/Date Stamp (Low),File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n"),

	// DEVICE DRIVERS (used for both -Z MEMORY.DMP files, and -D option)
	TEXT("Kernel-Mode Driver(s)"),
	TEXT("CSV Kernel-Mode Driver(s)"),
	TEXT("[KERNEL-MODE DRIVERS]"),
	TEXT(",,,Module Path,Symbol Status,Checksum,Time/Date Stamp,Time/Date String,Size Of Image,DBG Pointer,PDB Pointer,PDB Signature,PDB Age,Product Version,File Version,Company Name,File Description,File Size,File Time/Date Stamp (High),File Time/Date Stamp (Low),File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n")
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\main.h ===
// Main.h

#if !defined(AFX_MAIN_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_)
#define AFX_MAIN_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef __cplusplus
extern "C" {
#endif

#ifndef CHECKSYM_TEST
// Normal startup!
int _cdecl _tmain(int argc, TCHAR *argv[]);
#else
// Test main startup!
int _cdecl testmain(int argc, TCHAR *argv[]);
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\main.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       main.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"

#include <dbghelp.h>

#include "DelayLoad.h"
#include "Processes.h"
#include "ProcessInfo.h"
#include "SymbolVerification.h"
#include "ModuleInfoCache.h"
#include "FileData.h"
#include "Modules.h"
#include "DmpFile.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef CHECKSYM_TEST
// Normal startup!
int _cdecl _tmain(int argc, TCHAR *argv[])
#else
// Test main startup!
int _cdecl testmain(int argc, TCHAR *argv[])
#endif
{
	int iReturnCode = EXIT_FAILURE;
	HRESULT hr = S_OK;

	// Initialize our object pointers...
		
	// Processes/Modules data collected on this machine
	CProcesses * lpLocalSystemProcesses = NULL;			// -P Option
	CModules * lpLocalFileSystemModules = NULL;			// -F Option
	CModules * lpKernelModeDrivers = NULL;				// -D Option

	// CSV File Support
	CFileData * lpCSVInputFile = NULL;					// -I Option
	CFileData * lpCSVOutputFile = NULL;					// -O Option

	CProcesses * lpCSVProcesses = NULL;					// [PROCESSES]
	CProcessInfo * lpCSVProcess = NULL;					// [PROCESS]
	CModules *	 lpCSVModulesFromFileSystem = NULL;		// [FILESYSTEM MODULES]
	CModules *	 lpCSVKernelModeDrivers = NULL;			// [KERNEL-MODE DRIVERS]

	//
	// Module Caches (these implement separate name spaces for the modules collected)
	//
	// It is important that we separate the modules in these caches because a module
	// from a CSV file should not be assumed to be the same module if you also happen
	// to collect it from a DMP file... or your local system...
	
	CModuleInfoCache * lpLocalSystemModuleInfoCache = NULL; // Contains Local System modules
	CModuleInfoCache * lpCSVModuleInfoCache = NULL;			// Contains CSV modules
	CModuleInfoCache * lpDmpModuleInfoCache = NULL;			// Contains user.dmp & kernel.dmp modules
	
	long lTotalNumberOfModulesVerified = 0;
	long lTotalNumberOfVerifyErrors = 0;
	unsigned int iNumberOfFailures = 0;

	// Support for Dmp Files...
	CDmpFile * lpDmpFile = NULL;	// This object allows a Dump file (user/kernel) to be manipulated
	CProcessInfo * lpDmpFileUserModeProcess = NULL; // User.dmp files use this object to contain modules
	CModules   * lpDmpFileKernelModeDrivers = NULL; // Memory.dmp files use this object to contain modules

	// Allocate local values
	bool fQuietMode = false;

	// Let's populate our Globals!
	g_lpDelayLoad = new CDelayLoad();
	g_lpProgramOptions = new CProgramOptions();

	if (!g_lpDelayLoad && !g_lpProgramOptions)
		goto cleanup;

	// Initialize Options to their defaults...
	if (!g_lpProgramOptions->Initialize())
	{
		_tprintf(TEXT("Unable to initialize Program Options!\n"));
		goto cleanup;
	}

	// Take care of the commandline...
	if (!g_lpProgramOptions->ProcessCommandLineArguments(argc, argv))
	{
		// An error occurred, simply comment about how to get more assistance
		_tprintf(TEXT("\n"));
		_tprintf(TEXT("For simple help, type:   CHECKSYM -?\n"));
		_tprintf(TEXT("For extended help, type: CHECKSYM -???\n"));
		goto cleanup;
	}

	// Do we need to display help?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::HelpMode) ) 
	{
		g_lpProgramOptions->DisplayHelp();
		goto cleanup;
	}

	// Do we need to display simple help?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::SimpleHelpMode) )
	{
		g_lpProgramOptions->DisplaySimpleHelp();
		goto cleanup;
	}
	
#ifdef _UNICODE
	// It's unsupported running the UNICODE version on a Windows Platform
	if (g_lpProgramOptions->IsRunningWindows())
	{
		_tprintf(TEXT("The UNICODE version of CHECKSYM does not work on a Windows platform!\n"));
		_tprintf(TEXT("You require the ANSI version.\n"));
		goto cleanup;
	}
#endif

	// Let's suppress nasty critical errors (like... there's no
	// disk in the cd-rom drive, etc...)
	SetErrorMode(SEM_FAILCRITICALERRORS);

	// Let's save this for ease of access...
	fQuietMode = g_lpProgramOptions->GetMode(CProgramOptions::QuietMode);

	// Dump the program arguments (so it's obvious what we're going to do)
	g_lpProgramOptions->DisplayProgramArguments();

	if ( g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
	{
		// Now, we need to build the symbol tree root...
		char szSymbolTreeToBuild[_MAX_PATH];
		CUtilityFunctions::CopyTSTRStringToAnsi(g_lpProgramOptions->GetSymbolTreeToBuild(), szSymbolTreeToBuild, _MAX_PATH);

		if ( !MakeSureDirectoryPathExists(szSymbolTreeToBuild) )		
		{
			_tprintf(TEXT("ERROR: Unable to create symbol tree root [%s]\n"), g_lpProgramOptions->GetSymbolTreeToBuild() );
			CUtilityFunctions::PrintMessageString(GetLastError());
			goto cleanup;
		}
	}
	
	//  VERIFICATION OPTION: -V (verification)?
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		// Allocate a structure for our symbol verification object.
		g_lpSymbolVerification = new CSymbolVerification();

		if (!g_lpSymbolVerification)
		{
			_tprintf(TEXT("Unable to allocate memory for a verification symbol object!\n"));
			goto cleanup;
		}

		// Initialize Symbol Verification (if necessary)
		if (!g_lpSymbolVerification->Initialize())
		{
			_tprintf(TEXT("Unable to initialize Symbol Verification object!\n"));
			goto cleanup;
		}

		// Attempt to initialize MSDIA20.DLL support
		hr = g_lpSymbolVerification->InitializeDIASupport();

		if (SUCCEEDED(hr) && !fQuietMode)
		{
			_tprintf(TEXT("DIA Support found and initialized for PDB Verification.\n"));
		}

		// For now, let's defer complaints until we actually know we need VC7 PDB Support
		if (FAILED(hr))
		{
			_tprintf(TEXT("MSDIA20.DLL has not been properly registered (hr = 0x%0x).\n"), hr);
			_tprintf(TEXT("This may result in failures evaluating PDB files properly.\n"));
			_tprintf(TEXT("\n"));
			_tprintf(TEXT("Please ensure that MSDIA20.DLL is located in the same directory\n"));
			_tprintf(TEXT("as Checksym, or has been properly registered with the system using\n"));
			_tprintf(TEXT("\"REGSVR32 MSDIA20.DLL\" to correct.  You do not need to register\n"));
			_tprintf(TEXT("the DLL if it is located in the same directory as CheckSym.\n"));
			goto cleanup;
		}
	}

	//
	// Allocate a structure for our ModuleInfoCache if we're getting anything from the local system
	//
	if ( g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode) ||
		 g_lpProgramOptions->GetMode(CProgramOptions::InputDriversFromLiveSystemMode) ||
		 g_lpProgramOptions->GetMode(CProgramOptions::InputModulesDataFromFileSystemMode) )
	{
		lpLocalSystemModuleInfoCache= new CModuleInfoCache();

		// Check for out of memory condition...
		if ( lpLocalSystemModuleInfoCache == NULL )
		{
			_tprintf(TEXT("Unable to allocate memory for the ModuleInfoCache object!\n"));
			goto cleanup;
		}

		// Initialize Options to their defaults...
		if (!lpLocalSystemModuleInfoCache->Initialize())
		{
			_tprintf(TEXT("Unable to initialize ModuleInfoCache!\n"));
			goto cleanup;
		}
	}

	//
	// Allocate a structure for our CSVModuleInfoCache (if needed)... we need a separate
	// ModuleInfoCache space because the location of files on a remote system
	// files and we don't want to clash...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
	{
		// We need a Module Info Cache for these CSV data (it all was collected from
		// the same system (supposedly)
		lpCSVModuleInfoCache= new CModuleInfoCache();

		// Check for out of memory condition...
		if ( lpCSVModuleInfoCache == NULL )
		{
			_tprintf(TEXT("Unable to allocate memory for the CSVModuleInfoCache object!\n"));
			goto cleanup;
		}

		// Initialize Options to their defaults...
		if (!lpCSVModuleInfoCache->Initialize())
		{
			_tprintf(TEXT("Unable to initialize CSVModuleInfoCache!\n"));
			goto cleanup;
		}
	}

	//
	// Since we're going to read in a file... try and open it now...
	// This has the advantage of detecting problems accessing the file
	// when we've spent tons of time collecting data...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
	{
		// Create the file object
		lpCSVInputFile = new CFileData();

		if (!lpCSVInputFile)
		{
			_tprintf(TEXT("Unable to allocate memory for an input file object!\n"));
			goto cleanup;
		}

		// Set the input file path
		if (!lpCSVInputFile->SetFilePath(g_lpProgramOptions->GetInputFilePath()))
		{
			_tprintf(TEXT("Unable set input file path in the file data object!  Out of memory?\n"));
			goto cleanup;
		}

		// If we are going to produce an input file... try to do that now...
		if (!lpCSVInputFile->OpenFile(OPEN_EXISTING, true)) // Must exist, read only mode...
		{
			_tprintf(TEXT("Unable to open the input file %s.\n"), lpCSVInputFile->GetFilePath());
			lpCSVInputFile->PrintLastError();
			goto cleanup;
		}

		// Reading is so much easier in memory mapped mode...
		if (!lpCSVInputFile->CreateFileMapping())
		{
			_tprintf(TEXT("Unable to CreateFileMapping of the input file %s.\n"), lpCSVInputFile->GetFilePath());
			lpCSVInputFile->PrintLastError();
			goto cleanup;
		}

		// Go ahead and read in the header of the file (validate it).
		// Reading is so much easier in memory mapped mode...
		if (!lpCSVInputFile->ReadFileHeader())
		{
			_tprintf(TEXT("Invalid header found on input file %s.\n"), lpCSVInputFile->GetFilePath());
			lpCSVInputFile->PrintLastError();
			goto cleanup;
		}
	}

	// If we specified an output file, this is where we go ahead and allocate memory 
	// for the object
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Allocate a structure for our output fileData Object...
		lpCSVOutputFile = new CFileData();

		if (!lpCSVOutputFile )
		{
			_tprintf(TEXT("Unable to allocate memory for an output file object!\n"));
			goto cleanup;
		}
	}

	// INPUT METHOD: -Z Option?  (Dump files?)
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputDmpFileMode))
	{
		if (!fQuietMode)
			_tprintf(TEXT("\nReading Data from DMP File...\n"));

		// Create a Module Info Cache namespace to contain any modules found...
		lpDmpModuleInfoCache = new CModuleInfoCache();

		// Check for out of memory condition...
		if ( lpDmpModuleInfoCache == NULL )
		{
			_tprintf(TEXT("Unable to allocate memory for the DmpModuleInfoCache object!\n"));
			goto cleanup;
		}

		// Initialize Options to their defaults...
		if (!lpDmpModuleInfoCache->Initialize())
		{
			_tprintf(TEXT("Unable to initialize DmpModuleInfoCache!\n"));
			goto cleanup;
		}
		// Create the DMP File object
		lpDmpFile = new CDmpFile();

		if (!lpDmpFile)
		{
			_tprintf(TEXT("Unable to allocate memory for a DMP file object!\n"));
			goto cleanup;
		}

		// Initialize the DMP File
		if (!lpDmpFile->Initialize(lpCSVOutputFile))
		{
			_tprintf(TEXT("ERROR: Unable to initialize DMP file!\n"));
			goto cleanup;
		}
	
		// Header is good... so let's go ahead and get some data...
		if (!lpDmpFile->CollectData(&lpDmpFileUserModeProcess, &lpDmpFileKernelModeDrivers, lpDmpModuleInfoCache) )
		{
			_tprintf(TEXT("ERROR: Unable to collect data from the DMP file!\n"));
		}
	}
	
	// INPUT METHOD: -i Option?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
	{
		if (!fQuietMode)
			_tprintf(TEXT("\nReading Data from Input File...\n"));

		// Header is good... so let's go ahead and dispatch
		if (!lpCSVInputFile->DispatchCollectionObject(&lpCSVProcesses, &lpCSVProcess, &lpCSVModulesFromFileSystem, &lpCSVKernelModeDrivers, lpCSVModuleInfoCache, lpCSVOutputFile))
		{
			_tprintf(TEXT("Failure reading data collection from input file %s.\n"), lpCSVInputFile->GetFilePath());
			lpCSVInputFile->PrintLastError();
			goto cleanup;
		}
	}

	// INPUT METHOD: -p Option?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode) )
	{
		// Allocate a structure for our Processes Object.
		lpLocalSystemProcesses = new CProcesses();
		
		if (!lpLocalSystemProcesses)
		{
			_tprintf(TEXT("Unable to allocate memory for the processes object!\n"));
			goto cleanup;
		}

		// The Processes Object will init differently depending on what
		// Command-Line arguments have been provided... 
		if (!lpLocalSystemProcesses->Initialize(lpLocalSystemModuleInfoCache, NULL, lpCSVOutputFile))
		{
			_tprintf(TEXT("Unable to initialize Processes Object!\n"));
			goto cleanup;
		}

		// Mention the delay...
		if (!( fQuietMode || 
			   g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode)
           ) )
			_tprintf(TEXT("\nCollecting Process Data.... (this may take a few minutes)\n"));
		
		// Get the goods from the local system!
		lpLocalSystemProcesses->GetProcessesData();
	}

	// INPUT METHOD: -f OPTION?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::InputModulesDataFromFileSystemMode) )
	{
		// Allocate a structure for our CModules collection (a generic collection of
		// files from the filesystem)

		// Allocate a structure for our Processes Object.
		lpLocalFileSystemModules = new CModules();
		
		if (!lpLocalFileSystemModules)
		{
			_tprintf(TEXT("Unable to allocate memory for the CModules object!\n"));
			goto cleanup;
		}

		if (!lpLocalFileSystemModules->Initialize(lpLocalSystemModuleInfoCache, NULL, lpCSVOutputFile, NULL))
		{
			_tprintf(TEXT("Unable to initialize FileSystemModules Object!\n"));
			goto cleanup;
		}

		if (!fQuietMode)
			_tprintf(TEXT("\nCollecting Modules Data from file path.... (this may take a few minutes)\n"));
		
		iNumberOfFailures = lpLocalFileSystemModules->GetModulesData(CProgramOptions::InputModulesDataFromFileSystemMode);

		// Let's track the number of files we fail to open also...
		lTotalNumberOfModulesVerified += iNumberOfFailures;
		lTotalNumberOfVerifyErrors += iNumberOfFailures;

	}

	// INPUT METHOD: -d OPTION?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::InputDriversFromLiveSystemMode) )
	{
		// Allocate a structure for our CModules collection (a generic collection of
		// files from the filesystem)

		// Allocate a structure for our Processes Object.
		lpKernelModeDrivers = new CModules();
		
		if (!lpKernelModeDrivers)
		{
			_tprintf(TEXT("Unable to allocate memory for the CModules object!\n"));
			goto cleanup;
		}

		if (!lpKernelModeDrivers->Initialize(lpLocalSystemModuleInfoCache, NULL, lpCSVOutputFile, NULL))
		{
			_tprintf(TEXT("Unable to initialize Modules Object!\n"));
			goto cleanup;
		}

		if (!fQuietMode)
			_tprintf(TEXT("\nCollecting Device Driver Data.... (this may take a few minutes)\n"));
		
		lpKernelModeDrivers->GetModulesData(CProgramOptions::InputDriversFromLiveSystemMode);
	}

	// If we specified an output file, this is where we go ahead and allocate memory 
	// for the object
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Do we have any data to output?  If we have any data in cache... we should...
		if ( ( lpLocalSystemModuleInfoCache && lpLocalSystemModuleInfoCache->GetNumberOfModulesInCache() ) ||
			 ( lpCSVModuleInfoCache && lpCSVModuleInfoCache->GetNumberOfModulesInCache() ) ||
			 ( lpDmpModuleInfoCache && lpDmpModuleInfoCache->GetNumberOfModulesInCache() )
		   )
		{
			// Set the output file path
			if (!lpCSVOutputFile->SetFilePath(g_lpProgramOptions->GetOutputFilePath()))
			{
				_tprintf(TEXT("Unable set output file path in the file data object!  Out of memory?\n"));
				goto cleanup;
			}

			// Verify the output file directory...
			if (!lpCSVOutputFile ->VerifyFileDirectory())
			{
				_tprintf(TEXT("Directory provided is invalid!\n"));
				lpCSVOutputFile->PrintLastError();
				goto cleanup;
			}

			// If we are going to produce an output file... try to do that now...
			if ( !lpCSVOutputFile->OpenFile(g_lpProgramOptions->GetMode(CProgramOptions::OverwriteOutputFileMode) ? CREATE_ALWAYS : CREATE_NEW) )
			{
				_tprintf(TEXT("Unable to create the output file %s.\n"), lpCSVOutputFile->GetFilePath());
				lpCSVOutputFile->PrintLastError();
				goto cleanup;
			}

			// We skip output of the file header if -E was specified...
			if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
			{
				// Write the file header!
				if (!lpCSVOutputFile->WriteFileHeader())
				{
					_tprintf(TEXT("Unable to write the output file header.\n"));
					lpCSVOutputFile->PrintLastError();
					goto cleanup;
				}
			}
		} else
		{
			// Nothing to output... do not enable this mode...
			g_lpProgramOptions->SetMode(CProgramOptions::OutputCSVFileMode, false);
		}
	}

	// Do we verify symbols on this machine?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode) && 
		 ( lpLocalSystemModuleInfoCache || lpCSVModuleInfoCache || lpDmpModuleInfoCache) )
	{
		// If there is any data in any of our caches... we need to verify them...

		// Do a Verify on the ModuleCache... (We'll be quiet in QuietMode or when Building a Symbol Tree)
		if (lpLocalSystemModuleInfoCache)
		{
			if (!fQuietMode)
				_tprintf(TEXT("\nVerifying %d Modules from this System...\n"), lpLocalSystemModuleInfoCache->GetNumberOfModulesInCache());

			lpLocalSystemModuleInfoCache->VerifySymbols( fQuietMode ||
											  g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode)
											 );

			// Update our stats...
			lTotalNumberOfModulesVerified += lpLocalSystemModuleInfoCache->GetNumberOfModulesVerified();
			lTotalNumberOfVerifyErrors += lpLocalSystemModuleInfoCache->GetNumberOfVerifyErrors();
		}

		// Do a Verify on the ModuleCache... (We'll be quiet in QuietMode or when Building a Symbol Tree)
		if (lpCSVModuleInfoCache)
		{
			if (!fQuietMode)
				_tprintf(TEXT("\nVerifying %d Modules from the CSV file...\n"), lpCSVModuleInfoCache->GetNumberOfModulesInCache());

			lpCSVModuleInfoCache->VerifySymbols( fQuietMode ||
										  g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode)
										 );

			// Update our stats...
			lTotalNumberOfModulesVerified += lpCSVModuleInfoCache->GetNumberOfModulesVerified();
			lTotalNumberOfVerifyErrors += lpCSVModuleInfoCache->GetNumberOfVerifyErrors();
		}

		// Do a Verify on the ModuleCache... (We'll be quiet in QuietMode or when Building a Symbol Tree)
		if (lpDmpModuleInfoCache)
		{
			if (!fQuietMode)
				_tprintf(TEXT("\nVerifying %d Modules from the DMP file...\n"), lpDmpModuleInfoCache->GetNumberOfModulesInCache());

			lpDmpModuleInfoCache->VerifySymbols( fQuietMode ||
										  g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode)
										 );

			// Update our stats...
			lTotalNumberOfModulesVerified += lpDmpModuleInfoCache->GetNumberOfModulesVerified();
			lTotalNumberOfVerifyErrors += lpDmpModuleInfoCache->GetNumberOfVerifyErrors();
		}

	}

	// OUTPUT Phase!

	//
	// PROCESS COLLECTIONS FIRST!!!!
	//

	// Let's output local system processes first!
	if (lpLocalSystemProcesses)
		lpLocalSystemProcesses->OutputProcessesData(Processes, false);

	// Let's output CSV Processes next...
	if (lpCSVProcesses)
		lpCSVProcesses->OutputProcessesData(Processes, true);
	
	// If we're going to Dump to a USER.DMP file... do it...

	// Dump the data from a USER.DMP file... if we have one...
	if (lpDmpFileUserModeProcess)
		lpDmpFileUserModeProcess->OutputProcessData(Process, false, true);

	// let's output CSV Process next...
	if (lpCSVProcess)
		lpCSVProcess->OutputProcessData(Processes, true);

	//
	// MODULE COLLECTIONS SECOND!!!!
	//
	
	// Dump modules we found from our local file system first...
	if (lpLocalFileSystemModules)
		lpLocalFileSystemModules->OutputModulesData(Modules, false);
	
	// Dump modules from the CSV file second...
	if (lpCSVModulesFromFileSystem)
		lpCSVModulesFromFileSystem->OutputModulesData(Modules, true);
	
	// Dump device drivers from our local system first
	if (lpKernelModeDrivers)
		lpKernelModeDrivers->OutputModulesData(KernelModeDrivers, false);
	
	if (lpDmpFileKernelModeDrivers)
		lpDmpFileKernelModeDrivers->OutputModulesData(KernelModeDrivers, false);
	
	if (lpCSVKernelModeDrivers)
		lpCSVKernelModeDrivers->OutputModulesData(KernelModeDrivers, true);

	// DISPLAY RESULTS (IF VERIFICATION WAS USED)
	//

	// Dump the verification results...
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		long lPercentageSuccessfullyVerified = 0;

		if (lTotalNumberOfModulesVerified)
			lPercentageSuccessfullyVerified = (lTotalNumberOfModulesVerified - lTotalNumberOfVerifyErrors) * 100 / lTotalNumberOfModulesVerified;

		if (!fQuietMode)
		{
			_tprintf(TEXT("RESULTS: %d Total Files Checked, Total %d Verification Errors Found\n"), lTotalNumberOfModulesVerified , lTotalNumberOfVerifyErrors );
			_tprintf(TEXT("RESULTS: Percentage Verified Successfully = %d%%\n"), lPercentageSuccessfullyVerified);
		}

		// Return an error level equal to the number of errors found (0 == EXIT_SUCCESS)
		iReturnCode = lTotalNumberOfVerifyErrors;

	} else
	{
		// Success!
		iReturnCode = EXIT_SUCCESS;
	}


cleanup:

	// If we specified an output file, this is where we close it...
	if (lpCSVOutputFile)
	{
		// Try and close the file this object is bound to...
		lpCSVOutputFile->CloseFile();

		// Free the memory...
		delete lpCSVOutputFile;
		lpCSVOutputFile = NULL;
	}

	// If we specified an input file, this is where we close it...
	if (lpCSVInputFile)
	{
		// Try and close the file this object is bound to...
		lpCSVInputFile->CloseFile();

		// Free the memory...
		delete lpCSVInputFile;
		lpCSVInputFile = NULL;
	}

	if (g_lpDelayLoad)
	{
		delete g_lpDelayLoad;
		g_lpDelayLoad = NULL;
	}

	if (g_lpProgramOptions)
	{
		delete g_lpProgramOptions;
		g_lpProgramOptions = NULL;
	}

	if (g_lpSymbolVerification)
	{
		delete g_lpSymbolVerification;
		g_lpSymbolVerification = NULL;
	}

	if (lpLocalSystemProcesses)
	{
		delete lpLocalSystemProcesses;
		lpLocalSystemProcesses = NULL;
	}

	if (lpCSVKernelModeDrivers)
	{
		delete lpCSVKernelModeDrivers;
		lpCSVKernelModeDrivers = NULL;
	}

	if (lpCSVProcesses)
	{
		delete lpCSVProcesses;
		lpCSVProcesses = NULL;
	}

	if (lpCSVProcess)
	{
		delete lpCSVProcess;
		lpCSVProcess = NULL;
	}

	if (lpCSVModulesFromFileSystem)
	{
		delete lpCSVModulesFromFileSystem;
		lpCSVModulesFromFileSystem = NULL;
	}

	if (lpLocalSystemModuleInfoCache)
	{
		delete lpLocalSystemModuleInfoCache;
		lpLocalSystemModuleInfoCache = NULL;
	}

	if (lpCSVModuleInfoCache)
	{
		delete lpCSVModuleInfoCache;
		lpCSVModuleInfoCache = NULL;
	}

	if (lpDmpModuleInfoCache)
	{
		delete lpDmpModuleInfoCache;
		lpDmpModuleInfoCache = NULL;
	}

	if (lpLocalFileSystemModules)
	{
		delete lpLocalFileSystemModules;
		lpLocalFileSystemModules = NULL;
	}

	if (lpKernelModeDrivers)
	{
		delete lpKernelModeDrivers;
		lpKernelModeDrivers = NULL;
	}

	if (lpDmpFile)
	{
		delete lpDmpFile;
		lpDmpFile = NULL;
	}

	if (lpDmpFileUserModeProcess)
	{
		delete lpDmpFileUserModeProcess;
		lpDmpFileUserModeProcess = NULL;
	}

	if (lpDmpFileKernelModeDrivers)
	{
		delete lpDmpFileKernelModeDrivers;
		lpDmpFileKernelModeDrivers = NULL;
	}

	return iReturnCode;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\globals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       Globals.h
//
//--------------------------------------------------------------------------
#if !defined(GLOBALS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_)
#define GLOBALS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

//
// Speculating as to what the _VC_VER value should be... should this be _MSC_VER
//
#ifndef _VC_VER_INC
#define _VC_VER_INC
#ifndef _VC_VER
#define _VC_VER 620
#endif
#endif

//#include "DelayLoad.h"
//#include "ProgramOptions.h"
//#include "SymbolVerification.h"

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif
#include <WINDOWS.H>

// Used for transparent ANSI/UNICODE suppport...
#include <TCHAR.H>

// Used for cool macros (mostly for UNREFERENCED_PARM(x))
#include <DEBNOT.H>

// Forward declarations
class CDelayLoad;
class CProgramOptions;
class CSymbolVerification;

// Implement a few objects as globals to greatly simplify access to the objects...
// When we multi-thread ourselves with different user-contexts... we'll likely
// need to use _cdecl (thread) to provide per-user/thread global contexts...

enum CollectionTypes { Processes, Process, Modules, KernelModeDrivers };

struct CollectionStruct
{
	LPTSTR tszLocalContext;		// When collected locally, what should we say...
	LPTSTR tszCSVContext;		// When collected from a CSV file, what should we say...
	LPTSTR tszCSVLabel;			// CSV file label, what should we look for...
	LPTSTR tszCSVColumnHeaders;	// CSV file headers...
}; 

extern CDelayLoad * g_lpDelayLoad;
extern CProgramOptions * g_lpProgramOptions;
extern CSymbolVerification * g_lpSymbolVerification;

// Global String Structure
extern CollectionStruct g_tszCollectionArray[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\moduleinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfo.cpp
//
//--------------------------------------------------------------------------

// ModuleInfo.cpp: implementation of the CModuleInfo class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include <dia2.h>
#include <dbghelp.h>

#include "ModuleInfo.h"
#include "SymbolVerification.h"
#include "FileData.h"
#include "DmpFile.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModuleInfo::CModuleInfo()
{
	m_dwRefCount = 1;
	m_dwCurrentReadPosition = 0;

	m_lpInputFile = NULL;
	m_lpOutputFile = NULL;
	m_lpDmpFile = NULL;

	// File version information
	m_fPEImageFileVersionInfo = false;
	m_tszPEImageFileVersionDescription = NULL;
	m_tszPEImageFileVersionCompanyName = NULL;
	
	m_tszPEImageFileVersionString = NULL;
	m_dwPEImageFileVersionMS = 0;
	m_dwPEImageFileVersionLS = 0;
	
	m_tszPEImageProductVersionString = NULL;
	m_dwPEImageProductVersionMS = 0;
	m_dwPEImageProductVersionLS = 0;

	// PE Image Properties
	m_tszPEImageModuleName = NULL;			// Module name (eg. notepad.exe)
	m_tszPEImageModuleFileSystemPath = NULL;			// Full path to module (eg. C:\winnt\system32\notepad.exe)
	m_dwPEImageFileSize = 0;
	m_ftPEImageFileTimeDateStamp.dwLowDateTime  = 0;
	m_ftPEImageFileTimeDateStamp.dwHighDateTime = 0;
	m_dwPEImageCheckSum = 0;
	m_dwPEImageTimeDateStamp = 0;
	m_dwPEImageSizeOfImage = 0;
	m_enumPEImageType = PEImageTypeUnknown;	// We need to track what ImageType we have (PE32/PE64/???)
	m_dw64PreferredLoadAddress = 0;
	m_dw64BaseAddressOfLoadedImage = 0;

	m_wPEImageMachineArchitecture = 0;
	m_wCharacteristics = 0;						// These are the PE image characteristics

	// PE Image has a reference to DBG file
	m_enumPEImageSymbolStatus = SYMBOLS_NO;	// Assume there are no symbols for this module
	m_tszPEImageDebugDirectoryDBGPath = NULL;			// Path to DBG (found in PE Image)
	
	// PE Image has internal symbols
	m_dwPEImageDebugDirectoryCoffSize = 0;
	m_dwPEImageDebugDirectoryFPOSize = 0;
	m_dwPEImageDebugDirectoryCVSize = 0;
	m_dwPEImageDebugDirectoryOMAPtoSRCSize = 0;
	m_dwPEImageDebugDirectoryOMAPfromSRCSize = 0;
	
	// PE Image has a reference to PDB file...
	m_tszPEImageDebugDirectoryPDBPath = NULL;
	m_dwPEImageDebugDirectoryPDBFormatSpecifier = 0;
	m_dwPEImageDebugDirectoryPDBSignature = 0;				// PDB Signature (unique (across PDB instances) signature)
	m_dwPEImageDebugDirectoryPDBAge = 0;					// PDB Age (Number of times this instance has been updated)
	::ZeroMemory(&m_guidPEImageDebugDirectoryPDBGuid, sizeof(m_guidPEImageDebugDirectoryPDBGuid));

	// DBG Symbol information
	m_enumDBGModuleStatus = SYMBOL_NOT_FOUND;	// Status of the DBG file
	m_tszDBGModuleFileSystemPath = NULL;					// Path to the DBG file (after searching)
	m_dwDBGTimeDateStamp = 0;
	m_dwDBGCheckSum = 0;
	m_dwDBGSizeOfImage = 0;
	m_dwDBGImageDebugDirectoryCoffSize = 0;
	m_dwDBGImageDebugDirectoryFPOSize = 0;
	m_dwDBGImageDebugDirectoryCVSize = 0;
	m_dwDBGImageDebugDirectoryOMAPtoSRCSize = 0;
	m_dwDBGImageDebugDirectoryOMAPfromSRCSize = 0;
	
	// DBG File has a reference to a PDB file...
	m_tszDBGDebugDirectoryPDBPath = NULL;
	m_dwDBGDebugDirectoryPDBFormatSpecifier = 0;		// NB10, RSDS, etc...
	m_dwDBGDebugDirectoryPDBAge = 0;
	m_dwDBGDebugDirectoryPDBSignature = 0;
	ZeroMemory(&m_guidDBGDebugDirectoryPDBGuid, sizeof(m_guidDBGDebugDirectoryPDBGuid));

	// PDB File Information
	m_enumPDBModuleStatus = SYMBOL_NOT_FOUND; // Status of the PDB file
	m_tszPDBModuleFileSystemPath = NULL;		// Path to the PDB file (after searching)
	m_dwPDBFormatSpecifier = sigUNKNOWN;
	m_dwPDBSignature = 0;
	m_dwPDBAge = 0;
	memset(&m_guidPDBGuid, 0, sizeof(GUID));

	// Source Information
	m_fPDBSourceEnabled = false;
	m_fPDBSourceEnabledMismatch = false;

	// Source Information - MSDBI.LIB
	m_dwPDBTotalBytesOfLineInformation = 0;
	m_dwPDBTotalBytesOfSymbolInformation = 0;
	m_dwPDBTotalSymbolTypesRange = 0;

	// Source Information - MSDIA20.DLL
	m_dwPDBTotalSourceFiles = 0;
}

CModuleInfo::~CModuleInfo()
{
	// Let's cleanup a bit...
	if (m_tszPEImageFileVersionDescription)
		delete [] m_tszPEImageFileVersionDescription;

	if (m_tszPEImageFileVersionCompanyName)
		delete [] m_tszPEImageFileVersionCompanyName;
	
	if (m_tszPEImageFileVersionString)
		delete [] m_tszPEImageFileVersionString;
		
	if (m_tszPEImageProductVersionString)
		delete [] m_tszPEImageProductVersionString;

	if (m_tszPEImageModuleName)
		delete [] m_tszPEImageModuleName;

	if (m_tszPEImageModuleFileSystemPath)
		delete [] m_tszPEImageModuleFileSystemPath;

	if (m_tszPEImageDebugDirectoryDBGPath)
		delete [] m_tszPEImageDebugDirectoryDBGPath;

	if (m_tszPEImageDebugDirectoryPDBPath)
		delete [] m_tszPEImageDebugDirectoryPDBPath;

	if (m_tszDBGModuleFileSystemPath)
		delete [] m_tszDBGModuleFileSystemPath;

	if (m_tszDBGDebugDirectoryPDBPath)
		delete [] m_tszDBGDebugDirectoryPDBPath;

	if (m_tszPDBModuleFileSystemPath)
		delete [] m_tszPDBModuleFileSystemPath;

}

bool CModuleInfo::Initialize(CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile)
{
	// Let's save off the Program Options so we don't have to pass it to every method...
	m_lpInputFile =  lpInputFile;
	m_lpOutputFile = lpOutputFile;
	m_lpDmpFile = lpDmpFile;

	return true;
}

bool CModuleInfo::GetModuleInfo(LPTSTR tszModulePath, bool fDmpFile, DWORD64 dw64ModAddress, bool fGetDataFromCSVFile)
{
	bool fReturn = false;
	HANDLE hModuleHandle = INVALID_HANDLE_VALUE;

	if (fGetDataFromCSVFile)
	{
		fReturn = GetModuleInfoFromCSVFile(tszModulePath);
	} else
	{
		if (!fDmpFile)
		{
			TCHAR tszFileName[_MAX_FNAME];
			TCHAR tszFileExtension[_MAX_EXT];
		
			// Copy the Module Name to the ModuleInfo Object...
			_tsplitpath(m_tszPEImageModuleFileSystemPath, NULL, NULL, tszFileName, tszFileExtension);

			if (tszFileName && tszFileExtension)
			{
				// Compose the module name...
				m_tszPEImageModuleName = new TCHAR[_tcsclen(tszFileName)+_tcsclen(tszFileExtension)+1];
				
				if (!m_tszPEImageModuleName)
					goto cleanup;

				_tcscpy(m_tszPEImageModuleName, tszFileName);
				_tcscat(m_tszPEImageModuleName, tszFileExtension);
			}

			// Avoid opening a file at all if we're not using -R -S or -V
			if (g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode) ||
				g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode) ||
				g_lpProgramOptions->GetMode(CProgramOptions::CollectVersionInfoMode))
			{
				// Let's open the file... we use this for both Version Info and PE Image collection
				hModuleHandle = CreateFile(	tszModulePath,
											GENERIC_READ ,
											FILE_SHARE_READ,
											NULL,
											OPEN_EXISTING,
											0,
											0);

				if (hModuleHandle == INVALID_HANDLE_VALUE)
				{
					goto cleanup;
				}
			}
		}

		// Save the base address so that all DmpFile reads become relative to this...
		m_dw64BaseAddressOfLoadedImage = dw64ModAddress;
	
		// Even if we don't use -S, -V, or -R consider this successful (we have a filename)
		fReturn = true;

		// Are we to collected PE Information from this module?
		if (	g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode) ||
			g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
		{
			fReturn = GetPEImageInfoFromModule(hModuleHandle, fDmpFile);
		}
		
		// Do we need to collect Version Information?
		if (g_lpProgramOptions->GetMode(CProgramOptions::CollectVersionInfoMode))
		{
			fReturn = GetVersionInfoFromModule(hModuleHandle, fDmpFile);
		}
	}

cleanup:

		if (hModuleHandle != INVALID_HANDLE_VALUE)
			CloseHandle(hModuleHandle);

	return fReturn;
}

LPTSTR CModuleInfo::GetModulePath()
{
	return m_tszPEImageModuleFileSystemPath;
}

bool CModuleInfo::OutputData(LPTSTR tszProcessName, DWORD iProcessID, unsigned int dwModuleNumber)
{
	// Output to STDOUT?
	if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
	{
		if (!OutputDataToStdout(dwModuleNumber))
			return false;
	}	

	// Output to file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Try and output to file...
		if (!OutputDataToFile(tszProcessName, iProcessID))
			return false;
	}	

	return true;
}

bool CModuleInfo::fCheckPDBSignature(bool fDmpFile, HANDLE hModuleHandle, OMFSignature *pSig, PDB_INFO *ppdb)
{
	if (!DoRead(fDmpFile, hModuleHandle, pSig, sizeof(*pSig)))
		return false;

	if ( (pSig->Signature[0] != 'N') ||
         (pSig->Signature[1] != 'B') ||
         (!isdigit(pSig->Signature[2])) ||
         (!isdigit(pSig->Signature[3]))) 

	{
         //
         // If this is a DMP file (fDmpFile), odds are good that this was not compiled with
         // a linker 6.20 or higher (which marks the PDB path in the PE image such
         // that it gets mapped into the virtual address space (and will be in the user.dmp
         // file).
         //
         
        return false;
    }

	// This switch statement is reminiscent of some windbg code...don't shoot me
	// (I modified it slightly since the NB signature isn't super important to me)...
    switch (*(LONG UNALIGNED *)(pSig->Signature))
	{
        case sigNB10:	// OMF Signature, and hopefully some PDB INFO
			{
				if (!DoRead(fDmpFile, hModuleHandle, ppdb, sizeof(PDB_INFO)))
					break;
			}

		default:
            break;
    }

	// Before returning true (since we have some form of NB## symbols), we'll save this...
/*
#ifdef _UNICODE
			// Source is in ANSI, dest is in _UNICODE... need to convert...
			MultiByteToWideChar(CP_ACP,
								MB_PRECOMPOSED,
								pSig->Signature,
								4,
								m_tszPEImageDebugDirectoryNBInfo,
								4);
#else
			// Copy the ANSI string over...
			strncpy(m_tszPEImageDebugDirectoryNBInfo, pSig->Signature, 4);
#endif

	m_tszPEImageDebugDirectoryNBInfo[4] = '\0';
*/
	return true;
}

bool CModuleInfo::VerifySymbols()
{
	bool fReturn = false;

	if (!m_tszPEImageModuleName)
		goto cleanup;

	// Find/Verify a DBG file...
	if (m_enumPEImageSymbolStatus == SYMBOLS_DBG)
	{
		if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPath) )
		{
			fReturn = GetDBGModuleFileUsingSymbolPath(g_lpProgramOptions->GetSymbolPath());
		}

		// Do we want to try an alternate method to find symbols?
		if ( m_enumDBGModuleStatus != SYMBOL_MATCH )
		{
			// Try SQL server next...
			if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSQLServer) )
			{
				fReturn = GetDBGModuleFileUsingSQLServer();
			}
			// Try SQL2 server next ... mjl 12/14/99			
			if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSQLServer2) )
			{
				fReturn = GetDBGModuleFileUsingSQLServer2();
			}
		}
	}
	
	// Note, it is possible that the m_enumPEImageSymbolStatus will have changed from SYMBOLS_DBG
	// to SYMBOLS_DBG_AND_PDB after the DBG file is found above...
	if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) ||
		 (m_enumPEImageSymbolStatus == SYMBOLS_PDB) )
	{
		// This gets populated with the PDB filename (obtained from the DBG or PE Image)
		if (GetDebugDirectoryPDBPath())
		{
			if (!g_lpSymbolVerification)
			{
				m_enumPDBModuleStatus = SYMBOL_NO_HELPER_DLL;
				goto cleanup;
			}

			fReturn = GetPDBModuleFileUsingSymbolPath(g_lpProgramOptions->GetSymbolPath());

			// Do we want to try an alternate method to find symbols?
			if ( m_enumPDBModuleStatus != SYMBOL_MATCH )
			{
				// Search for PDB in SQL2 if enabled - mjl 12/14/99
				if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSQLServer2) )
				{
					fReturn = GetPDBModuleFileUsingSQLServer2();
				}
			}

		}
	}

cleanup:

	return fReturn;
}

bool CModuleInfo::GetDBGModuleFileUsingSymbolPath(LPTSTR tszSymbolPath)
{
	HANDLE hModuleHandle = INVALID_HANDLE_VALUE;
	TCHAR tszDebugModulePath[_MAX_PATH+1];				// Returned by FindFile* functions with path to DBG file

	TCHAR tszDrive[_MAX_DRIVE];							// Contains the Drove path (temporary)
	TCHAR tszDir[_MAX_DIR];								// Contains the Directory path (temporary)
	TCHAR tszFname[_MAX_FNAME];						// Contains the Filename (temporary)
	TCHAR tszPEImageExt[_MAX_EXT];						// Contains the extension of the PE image

	TCHAR tszDBGModuleName[_MAX_DIR+_MAX_FNAME+_MAX_EXT]; // Contains the DBG filename to search for (EXE\BADAPP.DBG)

	TCHAR tszDBGModuleNamePath[_MAX_PATH+1];			// Symbol path to search for DBG

	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();
	bool fRecursiveSearch = g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathRecursion);

	// Let's allocate enough storage for the complete symbol path and the module path
	LPTSTR tszSymbolPathWithModulePathPrepended = new TCHAR[_tcslen(tszSymbolPath) + _MAX_PATH + 1];

	if (tszSymbolPathWithModulePathPrepended == NULL)
		goto cleanup;

	// FIRST, BREAK THE PE IMAGE PATH TO ITS COMPONENT PARTS, BUILD PATH TO MODULE
	::_tsplitpath(m_tszPEImageModuleFileSystemPath, tszDrive, tszDir, tszFname, tszPEImageExt);

	// We may not have a path... (like from a user.dmp file)
	::_tcscpy(tszDBGModuleNamePath, tszDrive);
	::_tcscat(tszDBGModuleNamePath, tszDir);

	// SECOND, COMPUTE THE DBG FILENAME WE WILL BE USING
	//
	// The FindDebugInfoFileEx() really prefers the form of <EXT>\<FILE>.DBG
	//
	// We have two options on the name of the DBG file...
	//
	// We compose the name of the DBG file we're searching for and pass that as the
	// first parameter
	//
	// or
	//
	// We actually grab the MISC section and pull the name from there... 
	// (The debuggers have apparently changed and use the MISC section now... so we will)
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeNotUsingDBGInMISCSection))
	{
		// -Y4 Option

		// Compose the DBG filename from the PE Image Name
		if (fRecursiveSearch)
		{
			// Just initialize it to NULL
			tszDBGModuleName[0] = _T('\0');	
		} else
		{
			// Prepend the <EXT>\ to the front...
			::_tcscpy(tszDBGModuleName, tszPEImageExt+1);
			::_tcscat(tszDBGModuleName, _T("\\"));
		}
		::_tcscat(tszDBGModuleName, tszFname);
		::_tcscat(tszDBGModuleName, TEXT(".DBG"));
	} else
	{
		TCHAR tszExtModuleName[_MAX_EXT];					// Contains the module extension

		// If we're told to grab the DBG name from the MISC section... and there isn't one...
		// bail!
		if (!m_tszPEImageDebugDirectoryDBGPath)
			goto cleanup;

		// Okay, the user wants us to look in the MISC section of the Debug Directories
		// to figure out the DBG file location... though the FindDebugInfoFileEx() takes
		// as an argument the name of the DBG file... if you provide the PE Image name
		// instead, it performs a search that is more "broad"...

		// Split the DBG file info found in the MISC section into components...
		::_tsplitpath(m_tszPEImageDebugDirectoryDBGPath, NULL, tszDir, tszFname, tszExtModuleName);

		if (fRecursiveSearch)
		{
			// Just initialize it to NULL
			tszDBGModuleName[0] = _T('\0');	
		} else
		{
			// Prepend the <EXT>\ to the front...

			// Re-compose the MISC path...
			if (*tszDir == _T('\0'))
			{
				// Files do not tend to preserve the original extension in the MISC section like PE images...
				::_tcscpy(tszDBGModuleName, tszPEImageExt+1);
			} else
			{
				// Hopefully we have a good directory from the PE image
				::_tcscpy(tszDBGModuleName, tszDir);
			}

			CUtilityFunctions::EnsureTrailingBackslash(tszDBGModuleName);
		}

		// Tack on the rest...
		::_tcscat(tszDBGModuleName, tszFname);
		::_tcscat(tszDBGModuleName, tszExtModuleName);
	}

	if (fDebugSearchPaths)
	{
		::_tprintf(TEXT("DBG Search - Looking for [%s] Using Symbol Path...\n"), tszDBGModuleName);
	};

	//
	// If we're copying symbols to images, search adject to image first...
	// The DBG name should be present in the tszDBGModuleName...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::CopySymbolsToImage) )
	{
		if (fDebugSearchPaths)
		{
			::_tprintf(TEXT("DBG Search - SEARCH Adjacent to Image for Symbol!\n"));
		};

		// Compose a DBG path that is adjacent to our image...
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx(tszDBGModuleName, tszDBGModuleNamePath, tszDebugModulePath, VerifyDBGFile, this);

		// Close handle if one is returned...
		if (hModuleHandle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hModuleHandle);
			hModuleHandle = INVALID_HANDLE_VALUE;
		}

		// Hey, if we found it, we're done...
		if (GetDBGSymbolModuleStatus() == SYMBOL_MATCH)
		{
			goto cleanup;
		}
	}

	//
	// If we're building a symbol tree... look there first for our symbol
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
	{
		if (fDebugSearchPaths)
		{
			::_tprintf(TEXT("DBG Search - SEARCH in Symbol Tree We're Building!\n"));
		};

		// When we are constructing a build symbol tree... we should first
		// search there to see if our symbol is already present...
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx(tszDBGModuleName, g_lpProgramOptions->GetSymbolTreeToBuild(), tszDebugModulePath, VerifyDBGFile, this);

		// Close handle if one is returned...
		if (hModuleHandle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hModuleHandle);
			hModuleHandle = INVALID_HANDLE_VALUE;
		}

		// Hey, if we found it, we're done...
		if (GetDBGSymbolModuleStatus() == SYMBOL_MATCH)
		{
			goto cleanup;
		}
	}

	// Okay, we're not building a symbol tree... or we didn't find our symbol match in
	// the symbol tree... keep looking...
	
	// Well... let's search the SymbolPath provided for the DBG file...
	if (fRecursiveSearch)
	{
		// Do we use recursion???
		if (fDebugSearchPaths)
		{
			::_tprintf(TEXT("DBG Search - SEARCH Symbol path with recursion!\n"));
			// ISSUE-2000/07/24-GREGWI: Does FindDebugInfoFileEx2 support SYMSRV?
		};
	
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx2(tszDBGModuleName, tszSymbolPath, VerifyDBGFile, this);

		// Close handle if one is returned...
		if (hModuleHandle)
		{
			::CloseHandle(hModuleHandle);
			hModuleHandle = INVALID_HANDLE_VALUE;
		}

	} else
	{
		// Only do this if we're doing the standard file search mechanism...
		if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly))
		{
			// Don't do this block here if VerifySymbolsModeWithSymbolPathOnly option has been set...

			// Hmm... Windbg changed behavior and now prepends the module path to the
			// front of the symbolpath before called FindDebugInfoFileEx()...
			::_tcscpy(tszSymbolPathWithModulePathPrepended, tszDBGModuleNamePath);
			::_tcscat(tszSymbolPathWithModulePathPrepended, TEXT(";"));
		} else
		{
			tszSymbolPathWithModulePathPrepended[0] = '\0'; // Fast way to empty this string ;)
		}
		
		::_tcscat(tszSymbolPathWithModulePathPrepended, tszSymbolPath);

		if (fDebugSearchPaths)
		{
			::_tprintf(TEXT("DBG Search - SEARCH Symbol path!\n"));
		};

		// Do we do the standard thing?
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx(tszDBGModuleName, tszSymbolPathWithModulePathPrepended, tszDebugModulePath, VerifyDBGFile, this);

		// Close handle if one is returned...
		if (hModuleHandle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hModuleHandle);
			hModuleHandle = INVALID_HANDLE_VALUE;
		}
	}

cleanup:
	// If we have a hModuleHandle... free it now..
	if (hModuleHandle != INVALID_HANDLE_VALUE)
	{
		::CloseHandle(hModuleHandle);
		hModuleHandle = INVALID_HANDLE_VALUE;
	}

	// We found the following path
	if (m_tszDBGModuleFileSystemPath)
	{
		// Okay, let's clean up any "strangeness" added by FindDebugInfoFileEx()
		// If a symbol is found in the same directory as the module, it will be
		// returned with an extra \.\ combination (which is superfluous normally)...
		LPTSTR tszLocationOfExtraJunk = _tcsstr(m_tszDBGModuleFileSystemPath, TEXT("\\.\\"));

		if ( tszLocationOfExtraJunk )
		{
			// Remember where we were...
			LPTSTR tszPreviousLocation = tszLocationOfExtraJunk;

			// Skip the junk...
			tszLocationOfExtraJunk = CharNext(tszLocationOfExtraJunk);  // '\\'
			tszLocationOfExtraJunk = CharNext(tszLocationOfExtraJunk);  // '.'

			// While we have data... copy to the old location...
			while (*tszLocationOfExtraJunk)
			{
				*tszPreviousLocation = *tszLocationOfExtraJunk;
				tszLocationOfExtraJunk = CharNext(tszLocationOfExtraJunk);
				tszPreviousLocation    = CharNext(tszPreviousLocation);
			}

			// Null terminate the module path...
			*tszPreviousLocation = '\0';
		}

	}

	if (tszSymbolPathWithModulePathPrepended)
	{
		delete [] tszSymbolPathWithModulePathPrepended;
		tszSymbolPathWithModulePathPrepended = NULL;
	}
	
	if (fDebugSearchPaths)
	{
		if (GetDBGSymbolModuleStatus() == SYMBOL_MATCH)
		{
			::_tprintf(TEXT("DBG Search - Debug Module Found at [%s]\n\n"), m_tszDBGModuleFileSystemPath);
		} else
		{
			::_tprintf(TEXT("DBG Search - Debug Module Not Found.\n\n"));
		}
	}

	return true;
}

bool CModuleInfo::GetDBGModuleFileUsingSQLServer()
{
	// Do we need to initialize the SQL Server Connection?
	if (!g_lpSymbolVerification->SQLServerConnectionInitialized() &&
		!g_lpSymbolVerification->SQLServerConnectionAttempted())
	{
		if (!g_lpSymbolVerification->InitializeSQLServerConnection( g_lpProgramOptions->GetSQLServerName() ) )
			return false;
	}

	// Let's only use the SQL Server if it was initialized properly...
	if ( g_lpSymbolVerification->SQLServerConnectionInitialized() )
	{
		if (!g_lpSymbolVerification->SearchForDBGFileUsingSQLServer(m_tszPEImageModuleName, m_dwPEImageTimeDateStamp, this))
			return false;
	}
	return true;
}

// begin SQL2 - mjl 12/14/99
bool CModuleInfo::GetDBGModuleFileUsingSQLServer2()
{
	// Do we need to initialize the SQL Server Connection?
	if (!g_lpSymbolVerification->SQLServerConnectionInitialized2() &&
		!g_lpSymbolVerification->SQLServerConnectionAttempted2())
	{
		if (!g_lpSymbolVerification->InitializeSQLServerConnection2( g_lpProgramOptions->GetSQLServerName2() ) )
			return false;
	}

	// Let's only use the SQL Server if it was initialized properly...
	if ( g_lpSymbolVerification->SQLServerConnectionInitialized2() )
	{
		if (!g_lpSymbolVerification->SearchForDBGFileUsingSQLServer2(m_tszPEImageModuleName, m_dwPEImageTimeDateStamp, this))
			return false;
	}
	return true;
}

bool CModuleInfo::GetPDBModuleFileUsingSQLServer2()
{
	// Do we need to initialize the SQL Server Connection?
	if (!g_lpSymbolVerification->SQLServerConnectionInitialized2() &&
		!g_lpSymbolVerification->SQLServerConnectionAttempted2())
	{
		if (!g_lpSymbolVerification->InitializeSQLServerConnection2( g_lpProgramOptions->GetSQLServerName2() ) )
			return false;
	}

	// Let's only use the SQL Server if it was initialized properly...
	if ( g_lpSymbolVerification->SQLServerConnectionInitialized2() )
	{
		if (!g_lpSymbolVerification->SearchForPDBFileUsingSQLServer2(m_tszPEImageModuleName, m_dwPEImageDebugDirectoryPDBSignature, this))
			return false;
	}
	return true;
}
// end SQL2 - mjl 12/14/99

bool CModuleInfo::fValidDBGCheckSum()
{
	if (m_enumDBGModuleStatus == SYMBOL_MATCH)
		return true;

	if ((g_lpProgramOptions->GetVerificationLevel() == 1) && fValidDBGTimeDateStamp())
		return true;

	if (m_enumDBGModuleStatus == SYMBOL_POSSIBLE_MISMATCH)
		return ( (m_dwPEImageCheckSum == m_dwDBGCheckSum) && 
				(m_dwPEImageSizeOfImage == m_dwDBGSizeOfImage));

	return false;
}

bool CModuleInfo::fValidDBGTimeDateStamp()
{
	return ( (m_enumDBGModuleStatus == SYMBOL_POSSIBLE_MISMATCH) ||
			 (m_enumDBGModuleStatus == SYMBOL_MATCH) )
			? (m_dwPEImageTimeDateStamp == m_dwDBGTimeDateStamp ) : false;
}

bool CModuleInfo::GetPDBModuleFileUsingSymbolPath(LPTSTR tszSymbolPath)
{
	enum {
		niNil        = 0,
		PDB_MAX_PATH = 260,
		cbErrMax     = 1024,
	};

	HANDLE hModuleHandle = NULL;
	bool fSuccess = false;
	TCHAR tszRefPath[_MAX_PATH];
	TCHAR tszImageExt[_MAX_EXT] = {0}; 	// In case there is no extension we need to null terminate now...
	char szPDBOut[cbErrMax];
	TCHAR tszPDBModuleName[_MAX_FNAME];
	LPTSTR pcEndOfPath = NULL;
	tszPDBModuleName[0] = '\0';
	LPTSTR lptszPointerToPDBName = NULL;
	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();
	bool fDiaDataSourcePresent = g_lpSymbolVerification->DiaDataSourcePresent();
	HRESULT hr = S_OK;

	// Let's allocate enough storage for the complete symbol path and the module path
	unsigned int iSymbolPathWithModulePathPrependedBufferLength = _tcslen(tszSymbolPath) + _MAX_PATH + 1;
	LPTSTR tszSymbolPathWithModulePathPrepended = new TCHAR[iSymbolPathWithModulePathPrependedBufferLength];

	if (tszSymbolPathWithModulePathPrepended == NULL)
		goto cleanup;

	tszSymbolPathWithModulePathPrepended[0] = '\0';

	_tsplitpath(m_tszPEImageModuleFileSystemPath, NULL, NULL, NULL, tszImageExt);

	// Copy the symbol name we're searching for from the Debug Directories
	lptszPointerToPDBName = _tcsrchr(GetDebugDirectoryPDBPath(), '\\');

	// If we don't find a \ char, then go ahead and copy the PDBPath directly...
	if (lptszPointerToPDBName == NULL)
	{
		//_tcscpy(tszPDBModuleName, m_tszDebugDirectoryPDBPath);
		_tcscpy(tszPDBModuleName, GetDebugDirectoryPDBPath());
	} else
	{
		// Advance past the \ char...
		lptszPointerToPDBName = CharNext(lptszPointerToPDBName);
		_tcscpy(tszPDBModuleName, lptszPointerToPDBName);
	}

	if (fDebugSearchPaths)
	{
		_tprintf(TEXT("PDB Search - Looking for [%s] Using Symbol Path...\n"), g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : GetDebugDirectoryPDBPath());
	};

	if (g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
	{
		// When we are constructing a build symbol tree... we should first
		// search there to see if our symbol is already present...
		
		// Do we do the standard thing?
		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("PDB Search - SEARCH in Symbol Tree We're Building!\n"));
		};

		// Use diaLocatePdb() here when there is support for DIA...
		if (fDiaDataSourcePresent)
		{
			hr = diaLocatePdb( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : GetDebugDirectoryPDBPath(), 
							 GetDebugDirectoryPDBGuid(), 
							 GetDebugDirectoryPDBSignature(), 
							 GetDebugDirectoryPDBAge(), 
							 g_lpProgramOptions->GetSymbolTreeToBuild(),
							 &tszImageExt[1], 
							 ipNone);

			fSuccess = SUCCEEDED(hr);

		} else
		{
			_tprintf(TEXT("MSDIA20.DLL is required!\n"));
			fSuccess = false;
		}

		// Hey, if we found it, we're done...
		if (fSuccess)
		{
			goto cleanup;
		}
	}

	if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly))
	{
		// Hey, we better have one or the other...
		if (!m_tszDBGModuleFileSystemPath && !m_tszPEImageModuleFileSystemPath)
			goto cleanup;

		// figure out the home directory of the EXE/DLL or DBG file - pass that along to
		_tfullpath(tszRefPath, m_tszDBGModuleFileSystemPath ? m_tszDBGModuleFileSystemPath : m_tszPEImageModuleFileSystemPath, sizeof(tszRefPath)/sizeof(TCHAR));
		pcEndOfPath = _tcsrchr(tszRefPath, '\\');
		*pcEndOfPath = '\0';        // null terminate it
		*szPDBOut = '\0';

		if (iSymbolPathWithModulePathPrependedBufferLength < (_tcsclen(tszRefPath) + _tcsclen(g_lpProgramOptions->GetSymbolPath())+2))
			goto cleanup;	// Buffer isn't big enough... sigh...

		_tcscat(tszSymbolPathWithModulePathPrepended, tszRefPath);
		_tcscat(tszSymbolPathWithModulePathPrepended, TEXT(";"));
	}

    _tcscat(tszSymbolPathWithModulePathPrepended, tszSymbolPath);

	// Well... let's search the SymbolPath provided for the PDB file...
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathRecursion))
	{
		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("PDB Search - SEARCH Symbol path with recursion!\n"));
			// ISSUE-2000/07/24-GREGWI: Does FindDebugInfoFileEx2 support SYMSRV?
		};

		// Do we use recursion??? 
		// ISSUE-2000/07/24-GREGWI - Are we passing the right first arg?  Is this supported?
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx2(tszPDBModuleName, tszSymbolPathWithModulePathPrepended, VerifyPDBFile, this);

		if (hModuleHandle)
		{
			// We'll assume that a filehandle indicates success...
			CloseHandle(hModuleHandle);
			fSuccess = true;
		}

		// Hey, if we found it, we're done...
		if (fSuccess)
		{
			goto cleanup;
		}

	} else
	{
		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("PDB Search - SEARCH Symbol path!\n"));
		};

		// Use diaLocatePdb() here when there is support for DIA...
		if (fDiaDataSourcePresent)
		{
			hr = diaLocatePdb( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : GetDebugDirectoryPDBPath(), 
								GetDebugDirectoryPDBGuid(), 
								GetDebugDirectoryPDBSignature(), 
								GetDebugDirectoryPDBAge(), 
								tszSymbolPathWithModulePathPrepended, 
								&tszImageExt[1], 
								ipNone);

			fSuccess = SUCCEEDED(hr);

		} else
		{
			_tprintf(TEXT("MSDIA20.DLL is required!\n"));
			fSuccess = false;
		}
	}

cleanup:

	if (tszSymbolPathWithModulePathPrepended)
	{
		delete [] tszSymbolPathWithModulePathPrepended;
		tszSymbolPathWithModulePathPrepended = NULL;
	}

	if (fDebugSearchPaths)
	{
		if (GetPDBSymbolModuleStatus() == SYMBOL_MATCH)
		{
			_tprintf(TEXT("PDB Search - Debug Module Found at [%s]\n\n"), m_tszPDBModuleFileSystemPath);
		} else
		{
			_tprintf(TEXT("PDB Search - Debug Module Not Found.\n\n"));
		}
	}

//    if (pdia) {
//			diaRelease(pdia);
//        pdia = NULL;
//}

	return fSuccess;
}

BOOL CModuleInfo::VerifyPDBFile(HANDLE hFileHandle, LPTSTR tszFileName, PVOID CallerData)
{
	bool fSuccess = false;
	TCHAR tszPathToSearch[_MAX_PATH];
	TCHAR tszModulePath[_MAX_DIR];
	TCHAR tszImageExt[_MAX_EXT] = {0}; 	// In case there is no extension we need to null terminate now...
	bool fDiaDataSourcePresent = g_lpSymbolVerification->DiaDataSourcePresent();
	HRESULT hr = E_FAIL;
	UNREFERENCED_PARM(hFileHandle);

	// Let's grab the data passed to us...
	CModuleInfo * lpModuleInfo = (CModuleInfo *) CallerData;		// mjl
	_tsplitpath(tszFileName, tszPathToSearch, tszModulePath, NULL, tszImageExt);
	_tcscat(tszPathToSearch, tszModulePath);
		
	// Use diaLocatePdb() here when there is support for DIA...
	if (fDiaDataSourcePresent)
	{
		hr = lpModuleInfo->diaLocatePdb(	tszFileName, 
											lpModuleInfo->GetDebugDirectoryPDBGuid(), 
											lpModuleInfo->GetDebugDirectoryPDBSignature(), 
											lpModuleInfo->GetDebugDirectoryPDBAge(), 
											tszPathToSearch,
											&tszImageExt[1], 
											ipFirst);

		fSuccess = SUCCEEDED(hr);
		
	} else
	{
		_tprintf(TEXT("MSDIA20.DLL is required!\n"));
		fSuccess = false;
 	}
	
	return fSuccess;
}

// Okay, at this point we need to decide if we're going to save the PDB file we're pointing
// at based on a number of factors...
//
// 1. Is it a match, and does it match any SourceSymbol criteria (-SOURCEONLY, -NOSOURCE etc...)
// 2. Is it better than what we currently have?  (Source enabled better than no source enabled?)

bool CModuleInfo::fCopyNewPDBInformation(bool fSymbolMatch, bool fSourceEnabled)
{
	bool fRetValue = false;
	
	// If this doesn't match, and we already have a symbol... bail
	if ( (m_enumPDBModuleStatus != SYMBOL_NOT_FOUND) && (!fSymbolMatch))
		goto cleanup;
		
	// If we already have a match, is this a better match?  (If not, bail...)
	if (m_enumPDBModuleStatus == SYMBOL_MATCH)
	{
		switch (g_lpProgramOptions->GetSymbolSourceModes())
		{
			// -SOURCE
			case CProgramOptions::enumVerifySymbolsModeSourceSymbolsPreferred:

				// They want Source Enabled but we're already Source Enabled
				// Or the new file is not Source Enabled (so our existing one is just as good)
				if (m_fPDBSourceEnabled || !fSourceEnabled)
					goto cleanup;
				break;

			// -SOURCEONLY
			case CProgramOptions::enumVerifySymbolsModeSourceSymbolsOnly:
				if (m_fPDBSourceEnabled || !fSourceEnabled)
					goto cleanup;
				break;

			// -NOSOURCE
			case CProgramOptions::enumVerifySymbolsModeSourceSymbolsNotAllowed:
				if (!m_fPDBSourceEnabled || fSourceEnabled)
					goto cleanup;
				break;

			// No source preference provided... bail... (we already have a good symbol then)
			case CProgramOptions::enumVerifySymbolsModeSourceSymbolsNoPreference:
				goto cleanup;
				break;
		}
	}

	fRetValue = true;

cleanup:
	
	return fRetValue;

}

//
// Borrowed from dia.c (from sdktools\imagehlp\dia.c) transformed to be TCHAR compatible
//
HRESULT
CModuleInfo::diaLocatePdb(
					LPTSTR  tszPDB,
					GUID *PdbGUID,
					DWORD PdbSignature,
					DWORD PdbAge,
					LPTSTR tszSymbolPath,
					LPTSTR tszImageExt,
					int   ip
					)
{
	HRESULT hr = E_FAIL;

	TCHAR	tszPDBSansPath[_MAX_FNAME];
	TCHAR	tszPDBExt[_MAX_EXT];
	TCHAR	tszPDBLocal[_MAX_PATH];
	LPTSTR	lptszSemiColon;
	DWORD	pass;
	//    EC		hrcode = E_PDB_NOT_FOUND;
	bool	symsrv = true;
	TCHAR	tszPDBName[_MAX_PATH];
	LPTSTR	lptszSavedSymbolPath = tszSymbolPath;
	GUID	guid = {0};
	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();

	// We're going to add our Dia Interfaces here as appropriate...
	CComPtr<IDiaDataSource> pSource = NULL;

	bool	ssfile;
	bool	refpath;
	bool	first;

	if (!PdbSignature && !g_lpSymbolVerification->ValidGUID(PdbGUID))
	{
		return E_PDB_INVALID_SIG;
	}

	// SymbolPath is a semicolon delimited path (reference path first)
	_tcscpy (tszPDBLocal, tszPDB);
	_tsplitpath(tszPDBLocal, NULL, NULL, tszPDBSansPath, tszPDBExt);

	first = true;

	do 
	{
		lptszSemiColon = _tcsstr(tszSymbolPath, TEXT(";"));

		if (lptszSemiColon) 
		{
			*lptszSemiColon = '\0';
		}

		if (first) 
		{
			refpath = (ip == ipFirst);
			first = false;
		} else if (!lptszSemiColon) 
		{
			refpath = (ip == ipLast);
		} else 
		{
			refpath = false;
		}

		if (refpath) 
		{
			pass = 2;
			ip = ipNone;
		} else 
		{
			pass = 0;
		}

		if (tszSymbolPath) 
		{
do_again:
			ssfile = false;

			// Let's create a DIA Session interface pointer if necessary...
			hr = diaGetDiaDataSource(pSource);

			if (FAILED(hr))
			{
				goto cleanup;
			}

			if (!_tcsncicmp(tszSymbolPath, TEXT("SYMSRV*"), 7)) 
			{
				*tszPDBLocal = 0;
				_stprintf(tszPDBName, TEXT("%s%s"), tszPDBSansPath, TEXT(".pdb"));

				if (symsrv)
				{
					ssfile = true;
					if (PdbSignature)
						guid.Data1 = PdbSignature;
					else if (PdbGUID)
						memcpy(&guid, PdbGUID, sizeof(GUID));

					// Let's invoke DBGHELP.DLL's SymFindFileInPath to query the symbol server
					{
						char szSymbolPath[_MAX_PATH];
						char szPDBLocal[_MAX_PATH];
						char szPDBName[_MAX_FNAME];

						if (fDebugSearchPaths)
						{
							wchar_t wszPDBGuid[39];
							TCHAR	tszPDBGuid[39];

							// We're going to convert the binary GUID format to a string for easier printing
							StringFromGUID2(guid, wszPDBGuid, sizeof(wszPDBGuid)/sizeof(wchar_t));
							CUtilityFunctions::CopyUnicodeStringToTSTR(wszPDBGuid, tszPDBGuid, 39);

							_tprintf(TEXT("PDB Search - SYMSRV [%s,%s,%s,0x%x]\n"),
							tszSymbolPath,
							tszPDBName,
							tszPDBGuid,
							PdbAge);
						}

						CUtilityFunctions::CopyTSTRStringToAnsi(tszSymbolPath, szSymbolPath, _MAX_PATH);
						CUtilityFunctions::CopyTSTRStringToAnsi(tszPDBName, szPDBName, _MAX_FNAME);

						if (SymFindFileInPath(
									NULL,
									szSymbolPath,
									szPDBName,
									&guid,
									PdbAge,
									0,
									SSRVOPT_GUIDPTR,	//Flags
									szPDBLocal,
									NULL,
									NULL))
						{
							// Copy the string back...
							CUtilityFunctions::CopyAnsiStringToTSTR(szPDBLocal, tszPDBLocal, _MAX_PATH);
						}
					}
					symsrv = false;
				}
			} else {

			_tcscpy(tszPDBLocal, tszSymbolPath);
			CUtilityFunctions::EnsureTrailingBackslash(tszPDBLocal);

			// search order is ...
			//
			//   %dir%\symbols\%ext%\%file%
			//   %dir%\%ext%\%file%
			//   %dir%\%file%

			switch (pass)
			{
				case 0:
					_tcscat(tszPDBLocal, TEXT("symbols"));
					CUtilityFunctions::EnsureTrailingBackslash(tszPDBLocal);
					// pass through
				case 1:
					_tcscat(tszPDBLocal, tszImageExt);
					// pass through
				default:
					CUtilityFunctions::EnsureTrailingBackslash(tszPDBLocal);
				break;
			}

			_tcscat(tszPDBLocal, tszPDBSansPath);
			_tcscat(tszPDBLocal, tszPDBExt);

			}

			if (*tszPDBLocal) 
			{
				if (fDebugSearchPaths)
				{
					_tprintf(TEXT("PDB Search - Search here [%s]\n"), tszPDBLocal);
				}

				// Probe for file (it's lame but we want to see if you have connectivity
				hr = CUtilityFunctions::VerifyFileExists(TEXT("PDB Search - Failed to open [%s]!  "), tszPDBLocal);

				// Search only if we know we can see the file... save an expensive call
				if (hr == S_OK)
				{
					hr = diaGetPdbInfo(pSource, tszPDBLocal, g_lpSymbolVerification->ValidGUID(PdbGUID) ? PdbGUID : NULL, PdbSignature, PdbAge);
				}

				if (hr == S_OK) 
				{
					break;
				} else 
				{
					if (pass < 2) 
					{
						pass++;
						goto do_again;
					}
				}
				refpath = false;
				}
			}

			if (lptszSemiColon) 
			{
				*lptszSemiColon = ';';
				lptszSemiColon++;
				symsrv = true;
			}

			tszSymbolPath = lptszSemiColon;
	} while (lptszSemiColon);

	if (hr != S_OK) 
	{
		_tcscpy(tszPDBLocal, tszPDB);

		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("PDB Search - Search here [%s]\n"), tszPDBLocal);
		}

		// Let's create a DIA Session interface pointer if necessary...
		hr = diaGetDiaDataSource(pSource);

		if (FAILED(hr))
		{
			goto cleanup;
		}

		// Probe for file (it's lame but we want to see if you have connectivity
		hr = CUtilityFunctions::VerifyFileExists(TEXT("PDB Search - Failed to open [%s]!  "), tszPDBLocal);

		// Search only if we know we can see the file... save an expensive call
		if (hr == S_OK)
		{
			hr = diaGetPdbInfo(pSource, tszPDBLocal, g_lpSymbolVerification->ValidGUID(PdbGUID) ? PdbGUID : NULL, PdbSignature, PdbAge);
		}
	}

	// TODO: Why is this here???
	/*
	if (hr == S_OK) {
	// Store the name of the PDB we actually opened for later reference.
	//		_tcscpy(tszPDB, tszPDBLocal);
	_tcscpy(tszPDBLocal, tszPDB);
	}
	*/

	// Only try this last check if we're not bound to our Symbol Path Only
	if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly))
	{
		if (hr != S_OK && (PdbSignature || g_lpSymbolVerification->ValidGUID(PdbGUID)))
		{
			// Release as necessary...
			if (pSource)
			pSource = NULL;

			return diaLocatePdb(/*pIDD, */ tszPDB, NULL, 0, 0, lptszSavedSymbolPath, tszImageExt, ipNone);
		}
	}

cleanup:

	// Release as necessary...
	if (pSource)
		pSource = NULL;

	return hr;
}

HRESULT CModuleInfo::diaGetPdbInfo(CComPtr<IDiaDataSource> & pSource, LPTSTR tszPdbPath, GUID *PdbGUIDToMatch, DWORD PdbSignatureToMatch, DWORD PdbAgeToMatch)
{
	CComPtr<IDiaSession> pSession = NULL;
	CComPtr<IDiaSymbol> pSymbols = NULL;

	// Used when examining PDB files...
	DWORD dwSourceFiles = 0;
	bool fSourceEnabled = false;
	HRESULT hr = S_OK;
	HRESULT hr_retval = S_OK;
	bool fSymbolFileOpened = false;
	bool fSymbolMatch = false;

	WCHAR wszPDBPath[_MAX_PATH + 1];
	CUtilityFunctions::CopyTSTRStringToUnicode(tszPdbPath, wszPDBPath, _MAX_PATH + 1);

	//
	// First, let's just try and validate that we've got the right PDB file!
	//
	hr_retval = pSource->loadAndValidateDataFromPdb(wszPDBPath, g_lpSymbolVerification->ValidGUID(PdbGUIDToMatch) ? PdbGUIDToMatch : NULL, PdbSignatureToMatch, PdbAgeToMatch);

	fSymbolMatch = (hr_retval == S_OK);

	switch (hr_retval)
	{
		// We can work with these returns...
		case S_OK:
			fSymbolFileOpened = true;
			break;

		case E_PDB_INVALID_SIG:
		case E_PDB_INVALID_AGE:
			
			if (FAILED(hr = pSource->loadDataFromPdb(wszPDBPath)))
			{
				_tprintf(TEXT("Unable to open [%s] pdb file!  hr=0x%x\r\n"), tszPdbPath, hr);
				hr_retval = hr;
				goto cleanup;
			} else
			{
				fSymbolFileOpened = true;
			}
				

			break;

		// All else are fatal for us...			

#ifdef _DEBUG
//		case E_PDB_NOT_FOUND:
//			_tprintf(TEXT("PDB Not Found!  hr=0x%x\r\n"), hr);
//			goto cleanup;
//
//		case E_PDB_FORMAT:
//			_tprintf(TEXT("PDB Format Not Recognized!  hr=0x%x\r\n"), hr);
//			goto cleanup;
//
//		case E_UNEXPECTED:
//			_tprintf(TEXT("PDB Data Source already prepared!  hr=0x%x\r\n"), hr);
//			goto cleanup;
#endif

		default:
			goto cleanup;
	}

	// Get a Session Interface
	if (FAILED(hr = pSource->openSession(&pSession)))
	{
		_tprintf(TEXT("Unable to get PDB Session [%s] hr = 0x%x\r\n"), tszPdbPath, hr);
		hr_retval = hr;
		goto cleanup;
	}

	// Get a Symbols Interface
	if (FAILED(hr = pSession->get_globalScope(&pSymbols)))
	{
		_tprintf(TEXT("Unable to get PDB globalScope [%s] hr = 0x%x\r\n"), tszPdbPath, hr);
		hr_retval = hr;
		goto cleanup;
	}

	// Collect Source Info from PDB (if any) -- errors are tolerated for this call
	hr = diaPdbSourceEnabled(pSession, fSourceEnabled, dwSourceFiles);

	// With the New PDB found, do we want to record it into our ModuleInfo Object?
	if (!fCopyNewPDBInformation(fSymbolMatch, fSourceEnabled))
	{
		hr_retval = E_FAIL;	// This ensures we continue searching for a better hit...
		goto cleanup;
	}
	
	// On a match, let's populate what we know to be true
	if (fSymbolMatch)
	{
		// Did we get what we really wanted...		
		if ( (fSourceEnabled && (g_lpProgramOptions->GetSymbolSourceModes() == CProgramOptions::enumVerifySymbolsModeSourceSymbolsNotAllowed)) ||
			 (!fSourceEnabled && (g_lpProgramOptions->GetSymbolSourceModes() == CProgramOptions::enumVerifySymbolsModeSourceSymbolsOnly)) )
		{
			// Not perfect... we don't want this... even though it matches...
			m_enumPDBModuleStatus = SYMBOL_POSSIBLE_MISMATCH;
			m_fPDBSourceEnabledMismatch = true;
			hr_retval = E_FAIL;	// This ensures we continue searching for a better hit...
		} else
		{
			// Perfect...
			m_enumPDBModuleStatus = SYMBOL_MATCH;
			m_fPDBSourceEnabledMismatch = false;
			
			// If this is not source enabled... and -SOURCE was specified... continue searching
			// for a better hit!!!
			if (!fSourceEnabled && (g_lpProgramOptions->GetSymbolSourceModes() == CProgramOptions::enumVerifySymbolsModeSourceSymbolsPreferred))
			{
				hr_retval = E_FAIL;	// This ensures we continue searching for a better hit...
			}
		}

		// For now, save the results...
		m_fPDBSourceEnabled = fSourceEnabled;
		m_dwPDBTotalSourceFiles = dwSourceFiles;

		// On a perfect match, these must be equal...
		m_dwPDBSignature 		= PdbSignatureToMatch;
		m_dwPDBAge 				= PdbAgeToMatch;
		m_dwPDBFormatSpecifier 	= GetDebugDirectoryPDBFormatSpecifier(); // Assumed
		
		if (g_lpSymbolVerification->ValidGUID(PdbGUIDToMatch))
		{
			memcpy(&m_guidPDBGuid, &PdbGUIDToMatch, sizeof(m_guidPDBGuid));
		}

		m_tszPDBModuleFileSystemPath = CUtilityFunctions::CopyString(tszPdbPath, m_tszPDBModuleFileSystemPath);

		if (!m_tszPDBModuleFileSystemPath)
			return false;

		// Now that we're done verifying the module... do we save the symbol in
		// our tree?
		if ( g_lpProgramOptions->GetMode(CProgramOptions::CopySymbolsToImage) )
		{
			// Though we matched the PDB... we may not have correct PDB (source enabled, etc...)
			if (m_enumPDBModuleStatus == SYMBOL_MATCH)
			{
				// Yup...
				CUtilityFunctions::CopySymbolFileToImagePath(m_tszPEImageModuleFileSystemPath, &m_tszPDBModuleFileSystemPath);
			}
		}
		if ( g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
		{
			// Though we matched the PDB... we may not have correct PDB (source enabled, etc...)
			if (m_enumPDBModuleStatus == SYMBOL_MATCH)
			{
				// Yup...
				CUtilityFunctions::CopySymbolFileToSymbolTree(m_tszPEImageModuleName, &m_tszPDBModuleFileSystemPath, g_lpProgramOptions->GetSymbolTreeToBuild());
			}
		}

	}else
	{
		// We only record the first mismatch...
		if (m_enumPDBModuleStatus == SYMBOL_NOT_FOUND)
		{
			// Let's record this PDB file as a "hit" though not perfect...
			m_enumPDBModuleStatus = SYMBOL_POSSIBLE_MISMATCH;

			m_tszPDBModuleFileSystemPath = CUtilityFunctions::CopyString(tszPdbPath, m_tszPDBModuleFileSystemPath);

			if (!m_tszPDBModuleFileSystemPath)
				return false;

			// First, let's try the PDB Signature...
			if (FAILED(hr = pSymbols->get_signature(&m_dwPDBSignature)))
			{
				_tprintf(TEXT("Unable to get PDB signature from PDB file [%s] hr = 0x%x\r\n"), tszPdbPath, hr);
				hr_retval = hr;
				goto cleanup;
			}

			// Second, the PDB Guid...
			if (FAILED(hr = pSymbols->get_guid(&m_guidPDBGuid)))
			{
				_tprintf(TEXT("Unable to get PDB Guid from PDB file [%s] hr = 0x%x\r\n"), tszPdbPath, hr);
				hr_retval = hr;
				goto cleanup;
			}

			// Third, the PDB Age...
			if (FAILED(hr = pSymbols->get_age(&m_dwPDBAge)))
			{
				_tprintf(TEXT("Unable to get PDB Age from PDB file [%s] hr = 0x%x\r\n"), tszPdbPath, hr);
				hr_retval = hr;
				goto cleanup;
			}

			// Fourth... we need to identify if this is a sigNB10 or sigRSDS format...

			// One simple test is to look at the GUID itself... DIA returns the signature in
			// the first DWORD of the GUID, and the rest of the members are 0.

			if (g_lpSymbolVerification->diaOldPdbFormatFound(&m_guidPDBGuid, m_dwPDBSignature))
			{
				m_dwPDBFormatSpecifier = sigNB10;
			} else
			{
				m_dwPDBFormatSpecifier = sigRSDS;
			}

 			// For now, save the results...
			m_fPDBSourceEnabled = fSourceEnabled;
			m_dwPDBTotalSourceFiles = dwSourceFiles;

		} else
		{
			// We have to bail since this PDB doesn't match, and we found another already...
			goto cleanup;
		}
	}

cleanup:

	if (fSymbolFileOpened)
	{
		// Free this resource to allow for a new one on the next PDB file
		if (pSource)
			pSource = NULL;
	}
	if (pSession)
		pSession = NULL;

	if (pSymbols)
		pSymbols = NULL;

	return hr_retval;
}

HRESULT CModuleInfo::diaPdbSourceEnabled(CComPtr<IDiaSession> & pSession, bool & fSourceEnabled, DWORD & dwSourceFiles)
{
	CComPtr<IDiaEnumTables> pTables = NULL;
	CComPtr<IDiaTable > pTable = NULL;
	CComPtr<IDiaSourceFile> pSourceFile = NULL;
	CComPtr<IDiaEnumSourceFiles> pSourceFiles = NULL;

	LONG TotalCountOfSourceFiles = 0;
	ULONG celt = 0;
	HRESULT hr = S_OK;
	fSourceEnabled = false;
	dwSourceFiles = 0;

	// First, query for tables in the PDB file...
	if ( FAILED( pSession->getEnumTables( &pTables ) ) )
	{
        goto cleanup;
	}

	// Second, loop through each table and get a pointer to the table itself
    while ( SUCCEEDED( hr = pTables->Next( 1, &pTable, &celt ) ) && celt == 1 ) 
	{

//		Tablenum++;

/*		// Print the name of the table...
		if (SUCCEEDED(hr = pTable->get_name( &name )))
		{
			printf("Table[%d] = %ws\n", Tablenum, name);
			SysFreeString( name );
		}
*/
		// Check to see if this table has an interface to SourceFiles
		if ( SUCCEEDED( pTable->QueryInterface( IID_IDiaEnumSourceFiles, (void**)&pSourceFiles ) ) ) 
		{
			LONG CountOfSourceFiles;

			if (SUCCEEDED( hr = pSourceFiles->get_Count(&CountOfSourceFiles)))
			{
				TotalCountOfSourceFiles =+ CountOfSourceFiles;
/*
#ifdef _DEBUG
				_tprintf(TEXT("Number of source files = %d\n"), CountOfSourceFiles);
#endif
*/
			}
/*
            while ( SUCCEEDED( hr = pSourceFiles->Next( 1, &pSourceFile, &celt ) ) && celt == 1 ) 
			{
				BSTR name;
				fSourceEnabled = true;

				// Get the filename itself...
                pSourceFile->get_fileName( &name );

                if ( name != NULL ) 
				{
                    printf( "  File Name: %ws\n", name );
                    SysFreeString( name );
                }

                pSourceFile = NULL;
            }
*/
			pSourceFiles = NULL;
		}

        pTable = NULL;
	}

	// If we actually found source files in the PDB, then we're source enabled...
	if (TotalCountOfSourceFiles)
	{
		fSourceEnabled = true;
		dwSourceFiles = TotalCountOfSourceFiles;
	}


cleanup:

	if (pTables)
		pTables = NULL;

	if (pTable)
		pTable = NULL;

	if (pSourceFile)
		pSourceFile = NULL;

	if (pSourceFiles)
		pSourceFiles = NULL;

	return hr;
}

HRESULT CModuleInfo::diaGetDiaDataSource(CComPtr<IDiaDataSource> & pSource)
{
	HRESULT hr = S_OK;

	// Let's create a DIA Session interface pointer if necessary...
	if (pSource == NULL)
	{
		hr = g_lpSymbolVerification->diaGetDataSource(pSource);

		if (FAILED(hr))
		{
			_tprintf(TEXT("Unable to acquire DiaSource (hr=0x%x)\n"), hr);
			goto cleanup;
		}
	}

cleanup:

	return hr;
}
BOOL CModuleInfo::VerifyDBGFile(HANDLE hFileHandle, LPTSTR tszFileName, PVOID CallerData)
{
	CModuleInfo * lpModuleInfo = (CModuleInfo * )CallerData;
	WORD wMagic;				// Read to identify a DBG file...
	bool fPerfectMatch = false;	// Assume we don't have a good DBG match...

	// DBG Image Locals
	IMAGE_SEPARATE_DEBUG_HEADER ImageSeparateDebugHeader;

	// Start at the top of the image...
	lpModuleInfo->SetReadPointer(false, hFileHandle, 0, FILE_BEGIN);

	// Read in a signature word... is this a DBG file?
	if ( !lpModuleInfo->DoRead(false, hFileHandle, &wMagic, sizeof(wMagic) ) )
		goto cleanup;

	// No sense in going further since we're expecting a DBG image file...
	if (wMagic != IMAGE_SEPARATE_DEBUG_SIGNATURE)
		goto cleanup;

	// Start at the top of the image...
	lpModuleInfo->SetReadPointer(false, hFileHandle, 0, FILE_BEGIN);

	// Read in the full Separate Debug Header
	if ( !lpModuleInfo->DoRead(false, hFileHandle, &ImageSeparateDebugHeader, sizeof(ImageSeparateDebugHeader) ) )
		goto cleanup;

	//
	// We have a more stringent requirement for matching the checksum if the verification level is set...
	//
	if ( lpModuleInfo->m_dwPEImageTimeDateStamp == ImageSeparateDebugHeader.TimeDateStamp)
	{
		// For localized builds... these get altered... enforce this check here?
		if (g_lpProgramOptions->GetVerificationLevel() == 2)
		{
			if (	lpModuleInfo->m_dwPEImageCheckSum == ImageSeparateDebugHeader.CheckSum &&
				lpModuleInfo->m_dwPEImageSizeOfImage == ImageSeparateDebugHeader.SizeOfImage)
			{
				fPerfectMatch = true;
			}
		} else
		{
			fPerfectMatch = true;
		}
	}

	//
	// We're going to perform some action below unless this is not a perfect match
	// and we've already picked up a "bad" DBG file reference...
	//
	if (!fPerfectMatch && lpModuleInfo->m_tszDBGModuleFileSystemPath)
		goto cleanup;

	//
	// Take action based on our results...
	// 1. If we have a perfect match... save our stuff!
	// 2. If we don't already have a DBG, go ahead and save (even if wrong)
	//

	// Save off the checksum/linker information...
	lpModuleInfo->m_dwDBGTimeDateStamp = ImageSeparateDebugHeader.TimeDateStamp;
	lpModuleInfo->m_dwDBGCheckSum = ImageSeparateDebugHeader.CheckSum;
	lpModuleInfo->m_dwDBGSizeOfImage = ImageSeparateDebugHeader.SizeOfImage;

	lpModuleInfo->m_tszDBGModuleFileSystemPath = CUtilityFunctions::CopyString(tszFileName, lpModuleInfo->m_tszDBGModuleFileSystemPath);

	// Delete any PDB reference we may have found in our last DBG file (if any)...
	if (lpModuleInfo->m_tszDBGDebugDirectoryPDBPath)
	{
		delete [] lpModuleInfo->m_tszDBGDebugDirectoryPDBPath;
		lpModuleInfo->m_tszDBGDebugDirectoryPDBPath = NULL;
	}

	//
	// At this point, we only continue on if we've made a perfect "hit"
	//
	if (!fPerfectMatch)
	{
		// Not a perfect symbol.. record the status and exit...
		lpModuleInfo->m_enumDBGModuleStatus = SYMBOL_POSSIBLE_MISMATCH;

		goto cleanup;
	}

	// Good symbol.. record this...
	lpModuleInfo->m_enumDBGModuleStatus = SYMBOL_MATCH;

	// Now that we're done verifying the module... do we save the symbol in...
	if ( g_lpProgramOptions->GetMode(CProgramOptions::CopySymbolsToImage) )
	{
		// Our module path?
		CUtilityFunctions::CopySymbolFileToImagePath(lpModuleInfo->m_tszPEImageModuleFileSystemPath, &lpModuleInfo->m_tszDBGModuleFileSystemPath);
	} else
	if ( g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
	{
		// Out Symbol Tree?
		CUtilityFunctions::CopySymbolFileToSymbolTree(lpModuleInfo->m_tszPEImageModuleName, &lpModuleInfo->m_tszDBGModuleFileSystemPath, g_lpProgramOptions->GetSymbolTreeToBuild());
	}

	//
	// Okay, now with a good symbol let's extract the goods...
	//

	// If there's no debug info, we can't continue further.
	if (ImageSeparateDebugHeader.DebugDirectorySize == 0)
	{
		goto cleanup;
	}

	// Okay, we need to advance by the IMAGE_SECTION_HEADER...
	lpModuleInfo->SetReadPointer(false, hFileHandle, (ImageSeparateDebugHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)), FILE_CURRENT);

	// Skip over the exported names.
	if (ImageSeparateDebugHeader.ExportedNamesSize)
	{
		lpModuleInfo->SetReadPointer(false, hFileHandle, ImageSeparateDebugHeader.ExportedNamesSize, FILE_CURRENT);
	}
		
	if (!lpModuleInfo->ProcessDebugDirectory(false, false, hFileHandle, ImageSeparateDebugHeader.DebugDirectorySize, lpModuleInfo->GetReadPointer()))
		goto cleanup;

cleanup:

	return (fPerfectMatch ? TRUE : FALSE);
}

bool CModuleInfo::OutputDataToFile(LPTSTR tszProcessName, DWORD iProcessID)
{

	LPTSTR tszString = NULL;

	bool fReturn = false;

	// We remove the first three columns if -E was specified...
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		// Let's skip the first column to make room for the tag in the first column...
		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		// Process Name
		//
		if (tszProcessName)
		{
			if (!m_lpOutputFile->WriteString(tszProcessName, true))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		if (tszProcessName) 
		{
			// Let's only emit the PID if there is a process name...
			if (!m_lpOutputFile->WriteDWORD(iProcessID))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

	}

	// if -E is specified, we only spit out if the module has a problem
	if ( g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode) )
	{

		switch (m_enumPEImageSymbolStatus)
		{
			case SYMBOLS_DBG:
				if ( m_enumDBGModuleStatus == SYMBOL_MATCH)
				{
					// Don't print this out.. it matches...
					fReturn = true;
					goto cleanup;
				}
				break;

			case SYMBOLS_DBG_AND_PDB:
				if ( m_enumDBGModuleStatus == SYMBOL_MATCH &&
					 m_enumPDBModuleStatus == SYMBOL_MATCH )
				{
					// Don't print this out.. it matches...
					fReturn = true;
					goto cleanup;
				}
				
				break;

			case SYMBOLS_PDB:
				if ( m_enumPDBModuleStatus == SYMBOL_MATCH)
				{
					// Don't print this out.. it matches...
					fReturn = true;
					goto cleanup;
				}
				break;
		}
	}

	//
	//  Module Path
	//
	if (m_tszPEImageModuleFileSystemPath)
	{
		if (!m_lpOutputFile->WriteString(m_tszPEImageModuleFileSystemPath, true))
			goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	//
	// Symbol Status
	//
	if (m_enumPEImageSymbolStatus != SYMBOL_INFORMATION_UNKNOWN)
	{
		tszString = SymbolInformationString(m_enumPEImageSymbolStatus);

		if (tszString)
		{
			if (!m_lpOutputFile->WriteString(tszString))
				goto cleanup;
		}
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	// We remove this column if -E is specified
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		//
		//  Checksum
		//
		if ( m_enumPEImageSymbolStatus != SYMBOL_INFORMATION_UNKNOWN )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageCheckSum))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;
		
		//
		//  Time/Date Stamp
		//
		if ( m_enumPEImageSymbolStatus != SYMBOL_INFORMATION_UNKNOWN )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageTimeDateStamp))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

	}

	//
	//  Time/Date String
	//
	// If -E is specified we'll use version2 of the output format...
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		if ( m_enumPEImageSymbolStatus != SYMBOL_INFORMATION_UNKNOWN )
		{
			if (!m_lpOutputFile->WriteTimeDateString(m_dwPEImageTimeDateStamp))
				goto cleanup;
		}
	} else
	{
			if (!m_lpOutputFile->WriteTimeDateString2(m_dwPEImageTimeDateStamp))
				goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	// We remove these columns if -E is specified
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		//
		// Size Of Image (internal PE value) - used for SYMSRV support
		//
		if (!m_lpOutputFile->WriteDWORD(m_dwPEImageSizeOfImage))
			goto cleanup;

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  DBG Pointer
		//
		if ( m_enumPEImageSymbolStatus == SYMBOLS_DBG ||
			 m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB )
		{
			// Output the Path	
			if (m_tszPEImageDebugDirectoryDBGPath)
			{
				if (!m_lpOutputFile->WriteString(m_tszPEImageDebugDirectoryDBGPath, true))
					goto cleanup;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  PDB Pointer
		//
		if ( m_enumPEImageSymbolStatus == SYMBOLS_PDB )
		{
			// Output the Path	
			if (GetDebugDirectoryPDBPath())
			{
				if (!m_lpOutputFile->WriteString(GetDebugDirectoryPDBPath(), true))
					goto cleanup;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  PDB Signature
		//
		if ( m_enumPEImageSymbolStatus == SYMBOLS_PDB )
		{
			switch (m_dwPEImageDebugDirectoryPDBFormatSpecifier)
			{
				case sigNB10:
					// Output the Signature		
					if (!m_lpOutputFile->WriteDWORD(m_dwPEImageDebugDirectoryPDBSignature))
						goto cleanup;
					break;

				case sigRSDS:
					// Output the GUID
					if (!m_lpOutputFile->WriteGUID(m_guidPEImageDebugDirectoryPDBGuid))
						goto cleanup;
					
					break;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  PDB Age
		//
		if ( m_enumPEImageSymbolStatus == SYMBOLS_PDB )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageDebugDirectoryPDBAge))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

	}

	//
	//  Product Version
	//
	// We remove these columns if -E is specified
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		if (m_fPEImageFileVersionInfo && m_tszPEImageProductVersionString)
		{
			if (!m_lpOutputFile->WriteString(m_tszPEImageProductVersionString))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;
	}

	//
	//  File Version
	//
	if (m_fPEImageFileVersionInfo && m_tszPEImageFileVersionString)
	{
		if (!m_lpOutputFile->WriteString(m_tszPEImageFileVersionString))
			goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;
	
	//
	//  Company Name
	//
	if (m_fPEImageFileVersionInfo && m_tszPEImageFileVersionCompanyName)
	{
		if (!m_lpOutputFile->WriteString(m_tszPEImageFileVersionCompanyName, true))
				goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	//
	//   File Description
	//
	if (m_fPEImageFileVersionInfo && m_tszPEImageFileVersionDescription)
	{
		if (!m_lpOutputFile->WriteString(m_tszPEImageFileVersionDescription, true))
				goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	// We remove these columns if -E is specified
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		//
		// File Size (in bytes)
		//
		if ( m_dwPEImageFileSize )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageFileSize))
					goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		// File Date High Word
		if ( m_ftPEImageFileTimeDateStamp.dwLowDateTime ||
			 m_ftPEImageFileTimeDateStamp.dwHighDateTime )
		{
			if (!m_lpOutputFile->WriteDWORD(m_ftPEImageFileTimeDateStamp.dwHighDateTime))
					goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		// File Date Low Word
		if ( m_ftPEImageFileTimeDateStamp.dwLowDateTime ||
			 m_ftPEImageFileTimeDateStamp.dwHighDateTime )
		{
			if (!m_lpOutputFile->WriteDWORD(m_ftPEImageFileTimeDateStamp.dwLowDateTime))
					goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

	}

	// File Date String
	if ( m_ftPEImageFileTimeDateStamp.dwLowDateTime ||
		 m_ftPEImageFileTimeDateStamp.dwHighDateTime )
	{
		// If -E is specified we'll use version2 of the output format...
		if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
		{
			if (!m_lpOutputFile->WriteFileTimeString(m_ftPEImageFileTimeDateStamp))
				goto cleanup;
		} else
		{
			if (!m_lpOutputFile->WriteFileTimeString2(m_ftPEImageFileTimeDateStamp))
				goto cleanup;
		}
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		//
		//  Local DBG Status
		//
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG) || (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) )
		{

			tszString = SymbolModuleStatusString(m_enumDBGModuleStatus);

			if (tszString)
			{
				if (!m_lpOutputFile->WriteString(tszString))
					goto cleanup;
			}

		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  Local DBG
		//
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG) || (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) )
		{
			if (m_tszDBGModuleFileSystemPath)
			{
				if (!m_lpOutputFile->WriteString(m_tszDBGModuleFileSystemPath, true))
					goto cleanup;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  Local PDB Status
		//
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) || (m_enumPEImageSymbolStatus == SYMBOLS_PDB) )
		{
			tszString = SymbolModuleStatusString(m_enumPDBModuleStatus);
		
			if (tszString)
			{
				if (!m_lpOutputFile->WriteString(tszString))
					goto cleanup;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  Local PDB
		//
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) || (m_enumPEImageSymbolStatus == SYMBOLS_PDB) )
		{
			if (m_tszPDBModuleFileSystemPath)
			{
				if (!m_lpOutputFile->WriteString(m_tszPDBModuleFileSystemPath, true))
					goto cleanup;
			}
		}
	}
	// Write the carriage-return line-feed at the end of the line...
	if (!m_lpOutputFile->WriteString(TEXT("\r\n")))
		goto cleanup;

	fReturn = true; // Success

cleanup:

	if (!fReturn)
	{
		_tprintf(TEXT("Error: Failure writing module data!\n"));
		m_lpOutputFile->PrintLastError();
	}
		
	return fReturn;
}

bool CModuleInfo::OutputDataToStdout(DWORD dwModuleNumber)
{
	//
	// Do we output this module?
	//
	if (!OutputDataToStdoutThisModule())
		return false;
	
	//
	// First, Output Module Info
	//
	OutputDataToStdoutModuleInfo(dwModuleNumber);

	bool fPrintCarriageReturn = false;

	// Provide -PERF output if requested...
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputModulePerf))
	{
		if (m_dw64BaseAddressOfLoadedImage != m_dw64PreferredLoadAddress)
		{
			_tprintf(TEXT("  PERFORMANCE ISSUE DUE TO RELOCATION\n"));
			_tprintf(TEXT("  Module Load Address    = 0x%08I64x\n"), m_dw64BaseAddressOfLoadedImage);
			_tprintf(TEXT("  Preferred Load Address = 0x%08I64x\n"), m_dw64PreferredLoadAddress);
		}
	}

	//
	// Second, if we were to collect symbol info, but NOT verify... dump out what we
	// discovered about the symbol info...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode) &&
	   !g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		fPrintCarriageReturn = true;

		switch (m_enumPEImageSymbolStatus)
		{
			case SYMBOL_INFORMATION_UNKNOWN:
				_tprintf(TEXT("  Module symbol information was not collected!\n"));
				break;

			case SYMBOLS_NO:
				_tprintf(TEXT("  Module has NO symbols!\n"));
				break;

			case SYMBOLS_LOCAL:
				//
				// This module has ONLY local symbols...
				//
				_tprintf(TEXT("  Module has internal symbols only! %s\n"), SourceEnabledPEImage());
				OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
				break;

			case SYMBOLS_DBG:

				//
				// This module may have Internal Symbols but has a DBG file...
				//
				OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);

				//
				// Output the DBG Symbol Information
				//
				OutputDataToStdoutDbgSymbolInfo(m_tszPEImageDebugDirectoryDBGPath, m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);

				//
				// Output the DBG Internal Symbol Information
				//
				OutputDataToStdoutInternalSymbolInfo(m_dwDBGImageDebugDirectoryCoffSize, m_dwDBGImageDebugDirectoryFPOSize, m_dwDBGImageDebugDirectoryCVSize, m_dwDBGImageDebugDirectoryOMAPtoSRCSize, m_dwDBGImageDebugDirectoryOMAPfromSRCSize);
				break;

			case SYMBOLS_PDB:
				//
				// Output any internal symbols (that should be "splitsym'ed out")
				//
				OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);

				//
				// In this case, we have a PE Image with a PDB file...
				//
				OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, &m_guidPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
				break;
		}
	}

	//
	// Third, if we were to verify symbol info, display the results...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		fPrintCarriageReturn = true;

		switch (m_enumPEImageSymbolStatus)
		{
			case SYMBOL_INFORMATION_UNKNOWN:
				_tprintf(TEXT("  Module symbol information was not collected!\n"));
				break;

			case SYMBOLS_NO:
				_tprintf(TEXT("  Module has NO symbols\n"));
				break;

			case SYMBOLS_LOCAL:
				_tprintf(TEXT("  Module has internal symbols only! %s\n"), SourceEnabledPEImage());
				OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
				break;

			case SYMBOLS_DBG:
			case SYMBOLS_DBG_AND_PDB:
				switch (m_enumDBGModuleStatus)
				{
					case SYMBOL_MATCH:
						
						// Did they want the debug/symbol info for the PE image itself?
						if(g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode))
						{
							OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
						}

						if(m_tszDBGModuleFileSystemPath )
						{
							_tprintf(TEXT("  DBG File = %s [VERIFIED] %s\n"), m_tszDBGModuleFileSystemPath, SourceEnabledDBGImage());
						}
						
						if(g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode))
						{
							OutputDataToStdoutInternalSymbolInfo(m_dwDBGImageDebugDirectoryCoffSize, m_dwDBGImageDebugDirectoryFPOSize, m_dwDBGImageDebugDirectoryCVSize, m_dwDBGImageDebugDirectoryOMAPtoSRCSize, m_dwDBGImageDebugDirectoryOMAPfromSRCSize);
						}
						break;

					case SYMBOL_NOT_FOUND:
						OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
						OutputDataToStdoutDbgSymbolInfo(m_tszPEImageDebugDirectoryDBGPath, m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);
						_tprintf(TEXT("  DBG File NOT FOUND!\n"));
						break; // If we didn't find the DBG file... we don't bother with the PDB...

					case SYMBOL_POSSIBLE_MISMATCH:
						OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);

						OutputDataToStdoutDbgSymbolInfo(m_tszPEImageDebugDirectoryDBGPath, m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);
						OutputDataToStdoutDbgSymbolInfo(m_tszDBGModuleFileSystemPath, m_dwDBGTimeDateStamp, m_dwDBGCheckSum, m_dwDBGSizeOfImage, TEXT("DISCREPANCY"), m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);
						OutputDataToStdoutInternalSymbolInfo(m_dwDBGImageDebugDirectoryCoffSize, m_dwDBGImageDebugDirectoryFPOSize, m_dwDBGImageDebugDirectoryCVSize, m_dwDBGImageDebugDirectoryOMAPtoSRCSize, m_dwDBGImageDebugDirectoryOMAPfromSRCSize);
						break;
				};

				//
				// Intentional fall through to SYMBOLS_PDB (we might have one)
				//

			case SYMBOLS_PDB:

				// These two cases should have a PDB file... if we can find it...
				//
				if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) ||
					 (m_enumPEImageSymbolStatus == SYMBOLS_PDB) )
				{
					//
					// If we have a DebugDirectoryPDBPath... then display the goods...
					//
					if (GetDebugDirectoryPDBPath())
					{
						switch(m_enumPDBModuleStatus)
						{
							case SYMBOL_NOT_FOUND:
								OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);

								// Output PDB info as appropriate
								if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
								{
									OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, &m_guidPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
								}
								else
								{
									OutputDataToStdoutPdbSymbolInfo(m_dwDBGDebugDirectoryPDBFormatSpecifier, m_tszDBGDebugDirectoryPDBPath, m_dwDBGDebugDirectoryPDBSignature, &m_guidDBGDebugDirectoryPDBGuid, m_dwDBGDebugDirectoryPDBAge);
								}

								_tprintf(TEXT("  NO PDB FILE FOUND!!\n"));
								break;

							case SYMBOL_MATCH:
								// Did they want the debug/symbol info for the PE image itself?
								if(m_tszPDBModuleFileSystemPath )
									_tprintf(TEXT("  PDB File = %s [VERIFIED] %s\n"), m_tszPDBModuleFileSystemPath, SourceEnabledPDB());

								// NEWCODE: Testing...
								if (g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode))
								{
									if (m_dwPDBTotalSourceFiles)
									{
										// DIA Symbol information first...
										_tprintf(TEXT("    Module PDB Source Files = 0x%x\n"), m_dwPDBTotalSourceFiles);
									} else
									{
										// MSDBI Symbol information second...
										if (m_dwPDBTotalBytesOfLineInformation)
											_tprintf(TEXT("    Module PDB Bytes of Lines     = 0x%x\n"), m_dwPDBTotalBytesOfLineInformation);

										if (m_dwPDBTotalBytesOfSymbolInformation)
											_tprintf(TEXT("    Module PDB Bytes of Symbols   = 0x%x\n"), m_dwPDBTotalBytesOfSymbolInformation);

										if (m_dwPDBTotalSymbolTypesRange)
											_tprintf(TEXT("    Module PDB Symbol Types Range = 0x%x\n"), m_dwPDBTotalSymbolTypesRange);
									}
								
								}
									
								break;

							case SYMBOL_POSSIBLE_MISMATCH:
								if(m_tszPDBModuleFileSystemPath )
								{
									// Output PDB info as appropriate
									if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, &m_guidPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
									}
									else
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwDBGDebugDirectoryPDBFormatSpecifier, m_tszDBGDebugDirectoryPDBPath, m_dwDBGDebugDirectoryPDBSignature, &m_guidDBGDebugDirectoryPDBGuid, m_dwDBGDebugDirectoryPDBAge);
									}

									//
									// Output the PDB data itself...
									//
									OutputDataToStdoutPdbSymbolInfo(m_dwPDBFormatSpecifier, m_tszPDBModuleFileSystemPath, m_dwPDBSignature, &m_guidPDBGuid, m_dwPDBAge, TEXT("DISCREPANCY"));
								}
								break;

							case SYMBOL_INVALID_FORMAT:
								if(m_tszPDBModuleFileSystemPath )
								{
									// Output PDB info as appropriate
									if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, &m_guidPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
									}
									else
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwDBGDebugDirectoryPDBFormatSpecifier, m_tszDBGDebugDirectoryPDBPath, m_dwDBGDebugDirectoryPDBSignature, &m_guidDBGDebugDirectoryPDBGuid, m_dwDBGDebugDirectoryPDBAge);
									}
								
									_tprintf(TEXT("  PDB File = %s [INVALID_FORMAT]\n"), m_tszPDBModuleFileSystemPath );
								}
								break;

							case SYMBOL_NO_HELPER_DLL:
								if(m_tszPDBModuleFileSystemPath )
								{
									// Output PDB info as appropriate
									if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, &m_guidPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
									}
									else
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwDBGDebugDirectoryPDBFormatSpecifier, m_tszDBGDebugDirectoryPDBPath, m_dwDBGDebugDirectoryPDBSignature, &m_guidDBGDebugDirectoryPDBGuid, m_dwDBGDebugDirectoryPDBAge);
									}
								
									_tprintf(TEXT("  PDB File = %s [Unable to Validate]\n"), m_tszPDBModuleFileSystemPath );
								}
								break;
						}
					} else
					{
						OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
						OutputDataToStdoutDbgSymbolInfo(m_tszPEImageDebugDirectoryDBGPath, m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);
						_tprintf(TEXT("  Module has PDB File\n"));
						_tprintf(TEXT("  Module Pointer to PDB = [UNKNOWN] (Could not find in PE Image)\n"));
					};
				};
			}
	}

	// Should we tack an extra carriage-return?
	if ( fPrintCarriageReturn )
		_tprintf(TEXT("\n"));

	return true;
}

LPTSTR CModuleInfo::SymbolModuleStatusString(enum SymbolModuleStatus enumModuleStatus)
{
	LPTSTR tszStringPointer = NULL;

	// Output the Symbol Information for the PE module
	switch (enumModuleStatus)
	{
		case SYMBOL_NOT_FOUND:
			tszStringPointer = TEXT("SYMBOL_NOT_FOUND");
			break;

		case SYMBOL_MATCH:
			tszStringPointer = TEXT("SYMBOL_MATCH");
			break;

		case SYMBOL_POSSIBLE_MISMATCH:
			tszStringPointer = TEXT("SYMBOL_POSSIBLE_MISMATCH");
			break;

		case SYMBOL_INVALID_FORMAT:
			tszStringPointer = TEXT("SYMBOL_INVALID_FORMAT");
			break;

		case SYMBOL_NO_HELPER_DLL:
			tszStringPointer = TEXT("SYMBOL_NO_HELPER_DLL");
			break;

		default:
			tszStringPointer = NULL;
	}

	return tszStringPointer;
}

LPTSTR CModuleInfo::SymbolInformationString(enum SymbolInformationForPEImage enumSymbolInformationForPEImage)
{
	LPTSTR tszStringPointer = NULL;

	// Ouput the Symbol Information for the PE module
	switch (enumSymbolInformationForPEImage)
	{
		case SYMBOL_INFORMATION_UNKNOWN:
			tszStringPointer = TEXT("SYMBOL_INFORMATION_UNKNOWN");
			break;

		case SYMBOLS_NO:
			tszStringPointer = TEXT("SYMBOLS_NO");
			break;

		case SYMBOLS_LOCAL:
			tszStringPointer = TEXT("SYMBOLS_LOCAL");
			break;
		
		case SYMBOLS_DBG:
			tszStringPointer = TEXT("SYMBOLS_DBG");
			break;
		
		case SYMBOLS_DBG_AND_PDB:
			tszStringPointer = TEXT("SYMBOLS_DBG_AND_PDB");
			break;

		case SYMBOLS_PDB:
			tszStringPointer = TEXT("SYMBOLS_PDB");
			break;

		default:
			tszStringPointer = NULL;
	}

	return tszStringPointer;
}

bool CModuleInfo::GetPEImageInfoFromModule(HANDLE hModuleHandle, const bool fDmpFile)
{
	bool fReturn = false;

	// PE Image Locals
	IMAGE_DOS_HEADER    		ImageDosHeader;
	DWORD 				  		dwMagic;
	IMAGE_FILE_HEADER    		ImageFileHeader;
	IMAGE_DATA_DIRECTORY 		DebugImageDataDirectory;
	IMAGE_OPTIONAL_HEADER64 	ImageOptionalHeader64;
	PIMAGE_OPTIONAL_HEADER32 	lpImageOptionalHeader32 = NULL;
	PIMAGE_SECTION_HEADER 		lpImageSectionHeader = NULL;
	ULONG				 		OffsetImageDebugDirectory;
	unsigned long				ul;
	
	// We don't know anything about symbols yet... (we may not when we exit if the user
	// didn't ask us to look...)
	m_enumPEImageSymbolStatus = SYMBOL_INFORMATION_UNKNOWN;
	
	// Start at the top of the image...
	SetReadPointer(fDmpFile, hModuleHandle, 0, FILE_BEGIN);

	// Read in a dos exe header
	if ( !DoRead(fDmpFile, hModuleHandle, &ImageDosHeader, sizeof(ImageDosHeader) ) )
		goto cleanup;
	
	if (ImageDosHeader.e_magic != IMAGE_DOS_SIGNATURE)
	{	// No sense in going further since we're expecting a PE image file...
		goto cleanup;
	}

	if (ImageDosHeader.e_lfanew == 0)
	{ // This is a DOS program... very odd...
		goto cleanup;
	}

	// Great, we have a valid DOS_SIGNATURE... now read in the NT_SIGNATURE?!
	SetReadPointer(fDmpFile, hModuleHandle, ImageDosHeader.e_lfanew, FILE_BEGIN);

	// Read in a DWORD to see if this is an image worth looking at...
	if ( !DoRead(fDmpFile, hModuleHandle, &dwMagic, sizeof(DWORD)) )
		goto cleanup;

	// Probe to see if this is a valid image... we only handle NT images (PE/PE64)
	if (dwMagic != IMAGE_NT_SIGNATURE)
		goto cleanup;

	// Now read the ImageFileHeader...
	if ( !DoRead(fDmpFile, hModuleHandle, &ImageFileHeader, sizeof(IMAGE_FILE_HEADER)) )
		goto cleanup;	

	// Okay, we have a PE Image!!!!

	// Save the Time Date Stamp
	m_dwPEImageTimeDateStamp = ImageFileHeader.TimeDateStamp;

	// Save the Machine Architecture
	m_wPEImageMachineArchitecture = ImageFileHeader.Machine;

	// Save the PE Image Characteristics
	m_wCharacteristics = ImageFileHeader.Characteristics;

	// The OptionalHeader is necessary to get the SizeOfImage and to find the DebugDirectoryInfo.
	if (ImageFileHeader.SizeOfOptionalHeader == 0)
		goto cleanup;

	// Now... the size of the Optional Header is DIFFERENT between PE32 and PE64...
	// The only items we need from the option header are:
	//
	// ULONG CheckSum
	// ULONG SizeOfImage
	// IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG]
	//
	// We'll read as a PE64 (since it's larger) and cast to PE32 if required...
	if ( !DoRead(fDmpFile, hModuleHandle, &ImageOptionalHeader64, sizeof(IMAGE_OPTIONAL_HEADER64)) )
		goto cleanup;

	switch (ImageOptionalHeader64.Magic)
	{
		case IMAGE_NT_OPTIONAL_HDR32_MAGIC:

			m_enumPEImageType = PE32;

			lpImageOptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&ImageOptionalHeader64;

			// Save the Checksum info (though it's not very relavent to identifying symbols)
			m_dwPEImageCheckSum = lpImageOptionalHeader32->CheckSum;

			// Save the SizeOfImage info...
			m_dwPEImageSizeOfImage = lpImageOptionalHeader32->SizeOfImage;

			// Get the preferred load address
			m_dw64PreferredLoadAddress = lpImageOptionalHeader32->ImageBase;
			
			// In the absence of a an actual Load Address, use the preferred load address
			if (!m_dw64BaseAddressOfLoadedImage)
				m_dw64BaseAddressOfLoadedImage = m_dw64PreferredLoadAddress;
			
			DebugImageDataDirectory.Size = lpImageOptionalHeader32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
			DebugImageDataDirectory.VirtualAddress = lpImageOptionalHeader32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
			
			break;

		case IMAGE_NT_OPTIONAL_HDR64_MAGIC:

			m_enumPEImageType = PE64;

			// Save the Checksum info (though it's not very relavent to identifying symbols)
			m_dwPEImageCheckSum = ImageOptionalHeader64.CheckSum;

			// Save the SizeOfImage info...
			m_dwPEImageSizeOfImage = ImageOptionalHeader64.SizeOfImage;

			// Get the preferred load address
			m_dw64PreferredLoadAddress = ImageOptionalHeader64.ImageBase;

			// In the absence of a an actual Load Address, use the preferred load address
			if (!m_dw64BaseAddressOfLoadedImage)
				m_dw64BaseAddressOfLoadedImage = m_dw64PreferredLoadAddress;
			
			DebugImageDataDirectory.Size = ImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
			DebugImageDataDirectory.VirtualAddress = ImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
				
			break;

		default:
			goto cleanup;

	}

	// Let's quickly look to see if there is even a Debug Directory in the PE image!
	if (DebugImageDataDirectory.Size == 0)
	{
		m_enumPEImageSymbolStatus = SYMBOLS_NO;
		fReturn = true;
		goto cleanup; // No Debug Directory found...
	}

	// Now, go ahead and allocate the storage...
	lpImageSectionHeader = (PIMAGE_SECTION_HEADER) new IMAGE_SECTION_HEADER[ImageFileHeader.NumberOfSections];

	if (lpImageSectionHeader == NULL)
		goto cleanup;

 	// Set the pointer to the start of the Section Headers... (we may need to back up if we  read
	// PE64 Optional Headers and this is a PE32 image...
	if (m_enumPEImageType == PE32)
	{
		SetReadPointer(fDmpFile, hModuleHandle, (LONG)(sizeof(IMAGE_OPTIONAL_HEADER32)-sizeof(IMAGE_OPTIONAL_HEADER64)), FILE_CURRENT);
	}

	// Read in the Section Headers...
	if (!DoRead(fDmpFile, hModuleHandle, lpImageSectionHeader, (ImageFileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER))))
		goto cleanup;

	// Let's walk through these Section Headers...

	// For PE images, walk the section headers looking for the
	// one that's got the debug directory.
	for (ul=0; ul < ImageFileHeader.NumberOfSections; ul++) {

		// If the virtual address for the Debug Entry falls into this section header, then we've found it!
		if ( DebugImageDataDirectory.VirtualAddress >= lpImageSectionHeader[ul].VirtualAddress &&
			 DebugImageDataDirectory.VirtualAddress < lpImageSectionHeader[ul].VirtualAddress + lpImageSectionHeader[ul].SizeOfRawData )
		{
			break;
		}
	}

	// Assuming we haven't exhausted the list of section headers, we should have the debug directory now.
	if (ul >= ImageFileHeader.NumberOfSections)
	{
		m_enumPEImageSymbolStatus = SYMBOLS_NO;
		fReturn = true;
		goto cleanup; // No Debug Directory found...
	}

	// For a DmpFile, the address is based on the Section Header's Virtual Address, not PointerToRawData
	if (fDmpFile)
	{
		OffsetImageDebugDirectory = ((DebugImageDataDirectory.VirtualAddress - lpImageSectionHeader[ul].VirtualAddress) + lpImageSectionHeader[ul].VirtualAddress);

	} else
	{
		OffsetImageDebugDirectory = ((DebugImageDataDirectory.VirtualAddress - lpImageSectionHeader[ul].VirtualAddress) + lpImageSectionHeader[ul].PointerToRawData);
	}
	
	if (!ProcessDebugDirectory(true, fDmpFile, hModuleHandle, DebugImageDataDirectory.Size, OffsetImageDebugDirectory))
		goto cleanup;

	fReturn = true;

	/**
	**
	**	What type of symbols were found to be present...
	**
	**	NO SYMBOLS
	**	=============
	**	No Debug Directory
	**	NO Debug information stripped
	**	Symbols stripped
	**
	**	LOCAL SYMBOLS
	**	=============
	**	Debug Directory
	**	NO Debug information stripped
	**	NO Symbols stripped
	**
	**	PDB SYMBOL
	**	=============
	**	Debug Directory
	**	NO Debug information stripped
	**	Symbols stripped
	**
	**	DBG SYMBOL
	**	=============
	**	Debug Directory (assumed)
	**	BOTH - YES/NO Debug information stripped
	**	NO Symbols stripped
	**
	 **/

	if ((ImageFileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) == IMAGE_FILE_DEBUG_STRIPPED)
	{ // Debug Information Stripped!  (A DBG file is assumed)
		m_enumPEImageSymbolStatus = SYMBOLS_DBG;
	} else
	{ 
		// Debug Information NOT stripped! (Either a PDB exists, or symbols are local, or both...)
		if ( m_tszPEImageDebugDirectoryPDBPath || 
			(fDmpFile && (m_dwPEImageDebugDirectoryPDBFormatSpecifier == sigNOTMAPPED))
		  )
		{	// If we find PDB data, a PDB file is assumed...
			// Starting with LINK.EXE 6.2 and higher, we'll find PDB data in USER.DMP files....
			m_enumPEImageSymbolStatus = SYMBOLS_PDB;
		} else
		{ // Symbols NOT stripped (Symbols appear to be local to the PE Image)
			m_enumPEImageSymbolStatus = SYMBOLS_LOCAL;
		}
	}

cleanup:

	if (lpImageSectionHeader)
		delete [] lpImageSectionHeader;

	return fReturn;

}

bool CModuleInfo::GetVersionInfoFromModule(HANDLE hModuleHandle, const bool fDmpFile)
{
	bool fReturn = true;
	HRESULT Hr = S_OK;

	DWORD dwHandle = 0;

	struct LANGANDCODEPAGE 
	{
		WORD wLanguage;
		WORD wCodePage;
	} * pTranslate;

	// - No \VarFileInfo\Translation, assuming 00000409
	DWORD dwDefaultLanguageAndCodePage = 0x00000409;

	// Okay, we're ready to get the goods...
	VS_FIXEDFILEINFO * lpFixedFileInfo = NULL;
	VS_FIXEDFILEINFO  FixedFileInfo = {0};

	DWORD * lpdwLang = NULL;
	DWORD	dwLang = 0;
	
	TCHAR	tszSubBlock[256];
	LPTSTR	lptszBuffer = NULL;
	TCHAR	tszBuffer[_MAX_PATH];


	// Well, we can't get the filesystem information from a dmp file... no big surprise here...
	if (!fDmpFile)
	{
		// Now, get CheckSum, TimeDateStamp, and other Image properties...
		BY_HANDLE_FILE_INFORMATION lpFileInformation;

		if ( GetFileInformationByHandle(hModuleHandle, &lpFileInformation) )
		{
			// Get the file size... (hmm... we only get the low DWORD... but what EXE/DLL exceeds 2 Gig in size?)
			m_dwPEImageFileSize = lpFileInformation.nFileSizeLow;
			m_ftPEImageFileTimeDateStamp = lpFileInformation.ftLastWriteTime;
		}
	}

	// Now let's go after the version information...

	//
	// If we are calling the file version API directly, then we create a buffer that's used to return all
	// of the data...
	//
	// If we are calling the dbgeng.dll to get th file version, we provide the base address of the
	// module and a structure to return the data into (we need to allocate storage for this ourselves)
	//
	LPBYTE lpBuffer = NULL;
	DWORD dwVersionInfoSize = 0;

	if (fDmpFile)
	{
		// The DBGENG.DLL expects the buffers to be allocated already... let's hook them up...
		lpFixedFileInfo = &FixedFileInfo;
		lpdwLang = &dwLang;
		lptszBuffer = tszBuffer;

	} else
	{
		// First, is there any FileVersionInfo at all?
		dwVersionInfoSize = GetFileVersionInfoSize(m_tszPEImageModuleFileSystemPath, &dwHandle);

		if (!dwVersionInfoSize)
		{
			goto cleanup;
		}

		// Allocate a buffer to read into...
		lpBuffer = new BYTE[dwVersionInfoSize];
		
		if (!lpBuffer)
		{
			goto cleanup;
		}

		// Okay... query to get this version info...
		if (!GetFileVersionInfo(m_tszPEImageModuleFileSystemPath, dwHandle, dwVersionInfoSize, (void *)lpBuffer))
		{
			goto cleanup;
		}
	}

	//
	// Get the VS_FIXEDFILEINFO structure which carries version info...
	//
	if (SUCCEEDED(Hr = VersionQueryValue((ULONG_PTR)lpBuffer, fDmpFile, TEXT("\\"), (LPVOID *)&lpFixedFileInfo,  sizeof(FixedFileInfo))))
	{
		m_fPEImageFileVersionInfo = true;
		
		m_dwPEImageFileVersionMS = lpFixedFileInfo->dwFileVersionMS;
		m_dwPEImageFileVersionLS = lpFixedFileInfo->dwFileVersionLS;

		m_dwPEImageProductVersionMS = lpFixedFileInfo->dwProductVersionMS;
		m_dwPEImageProductVersionLS = lpFixedFileInfo->dwProductVersionLS;

		// Okay, before we go allocating a version string... let's ensure
		// we actually have a version number worth reporting...
		if ( m_dwPEImageFileVersionMS || m_dwPEImageFileVersionLS )
		{
			m_tszPEImageFileVersionString = new TCHAR[1+5+1+5+1+5+1+5+1+1]; // Format will be (#.#:#.#) where each # is a word

			if (m_tszPEImageFileVersionString) // Okay, blitz the data into place...
				_stprintf( m_tszPEImageFileVersionString, TEXT("(%d.%d:%d.%d)"), HIWORD(m_dwPEImageFileVersionMS), LOWORD(m_dwPEImageFileVersionMS), HIWORD(m_dwPEImageFileVersionLS), LOWORD(m_dwPEImageFileVersionLS) );
		}

		// Okay, before we go allocating a version string... let's ensure
		// we actually have a version number worth reporting...
		if ( m_dwPEImageProductVersionMS || m_dwPEImageProductVersionLS )
		{
			m_tszPEImageProductVersionString = new TCHAR[1+5+1+5+1+5+1+5+1+1]; // Format will be (#.#:#.#) where each # is a word

			if (m_tszPEImageProductVersionString) // Okay, blitz the data into place...
				_stprintf( m_tszPEImageProductVersionString, TEXT("(%d.%d:%d.%d)"), HIWORD(m_dwPEImageProductVersionMS), LOWORD(m_dwPEImageProductVersionMS), HIWORD(m_dwPEImageProductVersionLS), LOWORD(m_dwPEImageProductVersionLS) );
		}


	}

	// Get the language and codepage information for the CompanyName and
	// FileDescription string table resources...

	// Get the CompanyName!
	if (SUCCEEDED(Hr = VersionQueryValue((ULONG_PTR)lpBuffer, fDmpFile, TEXT("\\VarFileInfo\\Translation"), (LPVOID *)&lpdwLang,  sizeof(dwLang))))
	{
		pTranslate = (struct LANGANDCODEPAGE *)lpdwLang;
	} else
	{
		pTranslate = (struct LANGANDCODEPAGE *)&dwDefaultLanguageAndCodePage;
	}

// We may not get a value back... check for it...
//
//	if (!pTranslate) // Firewall code... just to be certain...
//	{
//		pTranslate = (struct LANGANDCODEPAGE *)&dwDefaultLanguageAndCodePage;
//	}

	_stprintf(tszSubBlock,TEXT("\\StringFileInfo\\%04x%04x\\CompanyName"), 
			pTranslate->wLanguage, 
			pTranslate->wCodePage);

	if (SUCCEEDED(Hr = VersionQueryValue((ULONG_PTR)lpBuffer, fDmpFile, tszSubBlock, (LPVOID *)&lptszBuffer ,  sizeof(tszBuffer))))
	{
		if (!fDmpFile)
		{
			// Cool, we have a Company Name...
			if (lptszBuffer && *lptszBuffer)
			{
				m_tszPEImageFileVersionCompanyName = CUtilityFunctions::CopyUnicodeStringToTSTR((LPWSTR)lptszBuffer, m_tszPEImageFileVersionCompanyName);
			}
		} else
		{
			// Cool, we have a Company Name...
			// Unfortunately, DBGENG.DLL returns all strings as ANSI
			if ((LPSTR)lptszBuffer && (char)*lptszBuffer)
			{
				m_tszPEImageFileVersionCompanyName = CUtilityFunctions::CopyAnsiStringToTSTR((LPSTR)lptszBuffer, m_tszPEImageFileVersionCompanyName);
			}
		}
	}

	_stprintf(tszSubBlock,TEXT("\\StringFileInfo\\%04x%04x\\FileDescription"),
			pTranslate->wLanguage, 
			pTranslate->wCodePage);

	if (SUCCEEDED(Hr = VersionQueryValue((ULONG_PTR)lpBuffer, fDmpFile, tszSubBlock, (LPVOID *)&lptszBuffer ,  sizeof(tszBuffer))))
	{
		if (!fDmpFile)
		{
			// Cool, we have a Description
			if (lptszBuffer && *lptszBuffer)
			{
				m_tszPEImageFileVersionDescription = CUtilityFunctions::CopyUnicodeStringToTSTR((LPWSTR)lptszBuffer, m_tszPEImageFileVersionDescription);
			}
		} else
		{
			// Cool, we have a Description
			// Unfortunately, DBGENG.DLL returns all strings as ANSI
			if ((LPSTR)lptszBuffer && (char)*lptszBuffer)
			{
				m_tszPEImageFileVersionDescription = CUtilityFunctions::CopyAnsiStringToTSTR((LPSTR)lptszBuffer, m_tszPEImageFileVersionDescription);
			}
		}
	}

	// If we still don't have a proper file version... just try
	// and grab the FileVersion string and hope it's good...
	if ( !m_dwPEImageFileVersionMS && !m_dwPEImageFileVersionLS )
	{
		_stprintf(tszSubBlock,TEXT("\\StringFileInfo\\%04x%04x\\FileVersion"),
			pTranslate->wLanguage, 
			pTranslate->wCodePage);

		if (SUCCEEDED(Hr = VersionQueryValue((ULONG_PTR)lpBuffer, fDmpFile, tszSubBlock, (LPVOID *)&lptszBuffer ,  sizeof(tszBuffer))))
		{
			if (!fDmpFile)
			{
				// Cool, we have a FileVersion String...
				if (lptszBuffer && *lptszBuffer)
				{
					m_tszPEImageFileVersionString = CUtilityFunctions::CopyUnicodeStringToTSTR((LPWSTR)lptszBuffer, m_tszPEImageFileVersionString);
				}
			} else
			{
				// Cool, we have a FileVersion String...
				// Unfortunately, DBGENG.DLL returns all strings as ANSI
				if ((LPSTR)lptszBuffer && (char)*lptszBuffer)
				{
					m_tszPEImageFileVersionString = CUtilityFunctions::CopyAnsiStringToTSTR((LPSTR)lptszBuffer, m_tszPEImageFileVersionString);
				}
			}
		}
	}
	
	// If we still don't have a proper file version... just try
	// and grab the ProductVersion string and hope it's good...
	if ( !m_dwPEImageProductVersionMS && !m_dwPEImageProductVersionLS )
	{
		_stprintf(tszSubBlock,TEXT("\\StringFileInfo\\%04x%04x\\ProductVersion"),
			pTranslate->wLanguage, 
			pTranslate->wCodePage);

		if (SUCCEEDED(Hr = VersionQueryValue((ULONG_PTR)lpBuffer, fDmpFile, tszSubBlock, (LPVOID *)&lptszBuffer ,  sizeof(tszBuffer))))
		{
			if (!fDmpFile)
			{
				// Cool, we have a ProductVersion String...
				if (lptszBuffer && *lptszBuffer)
				{
					m_tszPEImageProductVersionString = CUtilityFunctions::CopyUnicodeStringToTSTR((LPWSTR)lptszBuffer, m_tszPEImageProductVersionString);
				}
			} else
			{
				// Cool, we have a ProductVersion  String...
				// Unfortunately, DBGENG.DLL returns all strings as ANSI
				if ((LPSTR)lptszBuffer && (char)*lptszBuffer)
				{
					m_tszPEImageProductVersionString = CUtilityFunctions::CopyAnsiStringToTSTR((LPSTR)lptszBuffer, m_tszPEImageProductVersionString);
				}
			}
		}
	}

	fReturn = true;

cleanup:

	if (lpBuffer) 
	{
		delete [] lpBuffer;
		lpBuffer = NULL;
	};
	
	return fReturn;
}

HRESULT CModuleInfo::VersionQueryValue(ULONG_PTR lpAddress, bool fDmpFile, LPTSTR tszSubBlock, LPVOID * lplpBuffer, unsigned int cbSizeOfBuffer)
{
	HRESULT Hr = E_FAIL;
	unsigned int SizeRead;
	
	if (fDmpFile)
	{
		char	szSubBlock[256];

		CUtilityFunctions::CopyTSTRStringToAnsi(tszSubBlock, szSubBlock, 256);

		Hr = m_lpDmpFile->m_pIDebugSymbols2->GetModuleVersionInformation(DEBUG_ANY_ID,
				  m_dw64BaseAddressOfLoadedImage, 
				  szSubBlock,
				  (PVOID)(* lplpBuffer),
				  cbSizeOfBuffer,
				  (ULONG *)&SizeRead) ;
		
	
	} else
	{
		if (VerQueryValue((LPVOID)lpAddress, tszSubBlock, lplpBuffer, &SizeRead))
		{
			Hr = S_OK;
		}
	}


	return Hr;
}

bool CModuleInfo::GetModuleInfoFromCSVFile(LPTSTR tszModulePath)
{
	TCHAR tszFileName[_MAX_FNAME];
	TCHAR tszFileExtension[_MAX_EXT];
	char * lpstrOpenParenthesis = NULL;

	// Copy the Module Name to the ModuleInfo Object...
	_tsplitpath(tszModulePath, NULL, NULL, tszFileName, tszFileExtension);

	if (tszFileName && tszFileExtension)
	{
		// Compose the module name...
		m_tszPEImageModuleName = new TCHAR[_tcsclen(tszFileName)+_tcsclen(tszFileExtension)+1];
		
		if (!m_tszPEImageModuleName)
			return false;

		_tcscpy(m_tszPEImageModuleName, tszFileName);
		_tcscat(m_tszPEImageModuleName, tszFileExtension);
	}

	// Get the symbol status
	enum {BUFFER_SIZE = 32};
	char szSymbolStatus[BUFFER_SIZE];

	m_lpInputFile->ReadString(szSymbolStatus, BUFFER_SIZE);

	// Get the enum value for this string...
	m_enumPEImageSymbolStatus = SymbolInformation(szSymbolStatus);
	
	// Reset the symbol status if it is DBG/PDB (that may have
	// applied on the other machine where the data was captured,
	// but on this machine we'll have to find the DBG file
	// first, then see if a PDB file exists...
	if (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB)
		m_enumPEImageSymbolStatus = SYMBOLS_DBG;

	m_lpInputFile->ReadDWORD(&m_dwPEImageCheckSum);

	m_lpInputFile->ReadDWORD((LPDWORD)&m_dwPEImageTimeDateStamp);

	// Skip the time/date string...
	m_lpInputFile->ReadString();

	m_lpInputFile->ReadDWORD(&m_dwPEImageSizeOfImage);

	char szBuffer[_MAX_PATH+1];

	DWORD dwStringLength;

	// Read in the DBG Module Path
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good path... allocate space for it...

		m_tszPEImageDebugDirectoryDBGPath = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if (!m_tszPEImageDebugDirectoryDBGPath)
			return false;
	}

	// Read in the PDB Module Path
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good path... allocate space for it...
		m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if (!m_tszPEImageDebugDirectoryPDBPath)
			return false; // Failure allocating...
	}

	// We need to probe the PDB Signature to see if it is a GUID or not...
	m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	// Look for open parenthesis...
	lpstrOpenParenthesis = strstr(szBuffer, "{");

	if (lpstrOpenParenthesis)
	{
		// It's a GUID!
#ifdef _UNICODE

		WCHAR tszBuffer[_MAX_PATH+1];
#else
		unsigned char tszBuffer[_MAX_PATH+1];
#endif

		m_dwPEImageDebugDirectoryPDBFormatSpecifier = sigRSDS;
		
		// Advance beyond the "{" brace...
		lpstrOpenParenthesis = CharNextA(lpstrOpenParenthesis);

		int len = strlen(lpstrOpenParenthesis);

		if (len)
		{
			lpstrOpenParenthesis[len-1] = '\0';

			CUtilityFunctions::CopyAnsiStringToTSTR(lpstrOpenParenthesis, (LPTSTR)tszBuffer, _MAX_PATH+1);
	
			if(RPC_S_OK != ::UuidFromString(tszBuffer, &m_guidPEImageDebugDirectoryPDBGuid))
			{
				// Couldn't convert, ensure the guid is Zero then...
				::ZeroMemory(&m_guidPEImageDebugDirectoryPDBGuid, sizeof(m_guidPEImageDebugDirectoryPDBGuid));
			}
		}
	} else
	{
		// It's not a GUID, it's a DWORD
		m_dwPEImageDebugDirectoryPDBSignature = atoi(szBuffer);
		m_dwPEImageDebugDirectoryPDBFormatSpecifier = sigNB10;
	}
	
	m_lpInputFile->ReadDWORD(&m_dwPEImageDebugDirectoryPDBAge);

	// Read in the Product Version String
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good version... allocate space for it...
		m_tszPEImageProductVersionString = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if (!m_tszPEImageProductVersionString )
			return false; // Failure allocating...
	}

	// Read in the File Version String
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good version... allocate space for it...
		m_tszPEImageFileVersionString = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if (!m_tszPEImageFileVersionString )
			return false; // Failure allocating...
	}
	
	// Read in the File Version Company String
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good version... allocate space for it...
		m_tszPEImageFileVersionCompanyName = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if ( !m_tszPEImageFileVersionCompanyName )
			return false; // Failure allocating...
	}
	
	// Read in the File Version Description String
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good version... allocate space for it...
		m_tszPEImageFileVersionDescription = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if ( !m_tszPEImageFileVersionDescription )
			return false; // Failure allocating...
	}
	
	m_lpInputFile->ReadDWORD(&m_dwPEImageFileSize);
	
	m_lpInputFile->ReadDWORD(&m_ftPEImageFileTimeDateStamp.dwHighDateTime);

	m_lpInputFile->ReadDWORD(&m_ftPEImageFileTimeDateStamp.dwLowDateTime);

	// Okay... read to the start of the next line...
	m_lpInputFile->ReadFileLine();

	return true;
}

// This function is for ANSI strings explicitly because we only need to map these from
// ANSI strings read from a file, to an enum...
CModuleInfo::SymbolInformationForPEImage CModuleInfo::SymbolInformation(LPSTR szSymbolInformationString)
{
	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_DBG"))
		return SYMBOLS_DBG;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_PDB"))
		return SYMBOLS_PDB;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_DBG_AND_PDB"))
		return SYMBOLS_DBG_AND_PDB;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_NO"))
		return SYMBOLS_NO;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_LOCAL"))
		return SYMBOLS_LOCAL;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOL_INFORMATION_UNKNOWN"))
		return SYMBOL_INFORMATION_UNKNOWN;

	return SYMBOL_INFORMATION_UNKNOWN;
}

bool CModuleInfo::OutputFileTime(FILETIME ftFileTime, LPTSTR tszFileTime, int iFileTimeBufferSize)
{

	// Thu Oct 08 15:37:22 1998

	FILETIME ftLocalFileTime;
	SYSTEMTIME lpSystemTime;
	int cch = 0, cch2 = 0;

	// Let's convert this to a local file time first...
	if (!FileTimeToLocalFileTime(&ftFileTime, &ftLocalFileTime))
		return false;

	FileTimeToSystemTime( &ftLocalFileTime, &lpSystemTime );
	
	cch = GetDateFormat( LOCALE_USER_DEFAULT,
						 0,
						 &lpSystemTime,
						 TEXT("ddd MMM dd"),
						 tszFileTime,
						 iFileTimeBufferSize );

	if (!cch)
		return false;

	// Let's keep going...
	tszFileTime[cch-1] = TEXT(' ');

	//
    // Get time and format to characters
    //
     cch2 = GetTimeFormat( LOCALE_USER_DEFAULT,
						   NULL,
						   &lpSystemTime,
						   TEXT("HH':'mm':'ss"),
						   tszFileTime + cch,
						   iFileTimeBufferSize - cch );

	// Let's keep going... we have to tack on the year...
	tszFileTime[cch + cch2 - 1] = TEXT(' ');

	GetDateFormat( LOCALE_USER_DEFAULT,
					 0,
					 &lpSystemTime,
					 TEXT("yyyy"),
					 tszFileTime + cch + cch2,
					 iFileTimeBufferSize - cch - cch2);
	return true;
}

bool CModuleInfo::SetModulePath(LPTSTR tszModulePath)
{
	// Copy the Module Path to the ModuleInfo Object...
	if (!tszModulePath) {
		return false;
	}

	if (m_tszPEImageModuleFileSystemPath)
		delete [] m_tszPEImageModuleFileSystemPath;

	m_tszPEImageModuleFileSystemPath = new TCHAR[(_tcsclen(tszModulePath)+1)];

	if (!m_tszPEImageModuleFileSystemPath)
		return false;

	_tcscpy(m_tszPEImageModuleFileSystemPath, tszModulePath);
	return true;
}

ULONG CModuleInfo::SetReadPointer(bool fDmpFile, HANDLE hModuleHandle, LONG cbOffset, int iFrom)
{
    if (fDmpFile)
	{
        switch( iFrom )
		{
			case FILE_BEGIN:
				m_dwCurrentReadPosition = cbOffset;
				break;

			case FILE_CURRENT:
				m_dwCurrentReadPosition += cbOffset;
				break;

			default:
				break;
        }
	} else
	{
        m_dwCurrentReadPosition = SetFilePointer(hModuleHandle, cbOffset, NULL, iFrom);
    }

    return m_dwCurrentReadPosition;
}

bool CModuleInfo::DoRead(bool fDmpFile, HANDLE hModuleHandle, LPVOID lpBuffer, DWORD cbNumberOfBytesToRead)
{
    DWORD       cbActuallyRead;
	bool fReturn = false;

    if (fDmpFile)
	{
		if (m_lpDmpFile)
		{
			HRESULT Hr;

			if (FAILED(Hr = m_lpDmpFile->m_pIDebugDataSpaces->ReadVirtual(m_dw64BaseAddressOfLoadedImage+(DWORD64)m_dwCurrentReadPosition,
				lpBuffer,
				cbNumberOfBytesToRead,
				&cbActuallyRead)))
			{
				goto exit;
			}

			if (cbActuallyRead != cbNumberOfBytesToRead)
			{
				goto exit;
			}

		} else
		{
			goto exit;
		}

		m_dwCurrentReadPosition += cbActuallyRead;

    } else if ( (ReadFile(hModuleHandle, lpBuffer, cbNumberOfBytesToRead, &cbActuallyRead, NULL) == 0) ||
                (cbNumberOfBytesToRead != cbActuallyRead) )
	{
        goto exit;
    }

	fReturn = true;

exit:
    return fReturn;
}

bool CModuleInfo::SetDebugDirectoryDBGPath(LPTSTR tszNewDebugDirectoryDBGPath)
{
	m_tszPEImageDebugDirectoryDBGPath = CUtilityFunctions::CopyString(tszNewDebugDirectoryDBGPath, m_tszPEImageDebugDirectoryDBGPath);

	return true;
}

bool CModuleInfo::SetPEDebugDirectoryPDBPath(LPTSTR tszNewDebugDirectoryPDBPath)
{
	m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyString(tszNewDebugDirectoryPDBPath, m_tszPEImageDebugDirectoryPDBPath );

	return true;
}

bool CModuleInfo::SetPEImageModulePath(LPTSTR tszNewPEImageModulePath)
{
	m_tszPEImageModuleFileSystemPath = CUtilityFunctions::CopyString(tszNewPEImageModulePath, m_tszPEImageModuleFileSystemPath);

	_tcsupr(m_tszPEImageModuleFileSystemPath);

	return true;
}

bool CModuleInfo::SetPEImageModuleName(LPTSTR tszNewModuleName)
{
	m_tszPEImageModuleName = CUtilityFunctions::CopyString(tszNewModuleName, m_tszPEImageModuleName);

	_tcsupr(m_tszPEImageModuleName);

	return true;
}


// Evaluate whether we've found the symbolic information for this module
// that the user is looking for.
bool CModuleInfo::GoodSymbolNotFound()
{
	bool fBadSymbol = true;

	// Well, we evaluate success based on the type of symbol we're looking for 
	// and whether it was successfully found.
	switch (GetPESymbolInformation())
	{
		// This is bad... consider this fatal...
		case SYMBOL_INFORMATION_UNKNOWN:
			break;

		// Is this bad?  I think so... but if you inherit a module as an import should you
		// be punished for the ills of another?  Hmm....  For now we'll say it's okay...
		case SYMBOLS_NO:
			fBadSymbol = false;
			break;

		// While this is wasteful, we have symbolic info... so that's cool
		case SYMBOLS_LOCAL:
			fBadSymbol = false;
			break;

		case SYMBOLS_DBG:
			fBadSymbol = SYMBOL_MATCH == GetDBGSymbolModuleStatus();
			break;

		case SYMBOLS_DBG_AND_PDB:
			fBadSymbol = (SYMBOL_MATCH == GetDBGSymbolModuleStatus()) &&
						 (SYMBOL_MATCH == GetPDBSymbolModuleStatus());
			break;
		
		case SYMBOLS_PDB:
			fBadSymbol = SYMBOL_MATCH == GetPDBSymbolModuleStatus();
			break;

		default:
			break;
	}
	return fBadSymbol;
}

//
// Process the DebugDirectory data for a PE image (or a DBG file)
//
bool CModuleInfo::ProcessDebugDirectory(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, unsigned int iDebugDirectorySize, ULONG OffsetImageDebugDirectory)
{
	unsigned int iNumberOfDebugDirectoryEntries = iDebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY);
	
	//
	// Let's loop through the debug directories and collect the relavent info...
	//
    while (iNumberOfDebugDirectoryEntries--) 
    {
        IMAGE_DEBUG_DIRECTORY ImageDebugDirectory;

 		// Set the pointer to the DebugDirectories entry
		SetReadPointer(fDmpFile, hModuleHandle, OffsetImageDebugDirectory, FILE_BEGIN);

		// Read the DebugDirectoryImage
		if (!DoRead(fDmpFile, hModuleHandle, &ImageDebugDirectory, sizeof(IMAGE_DEBUG_DIRECTORY)))
			goto cleanup;

		//
		// Processing of the Debug Directory is dependent on the type
		//
		switch (ImageDebugDirectory.Type)
		{
			//
			// This is our preferred debug format as it offers full source level debugging (typically)
			//
			case IMAGE_DEBUG_TYPE_CODEVIEW:
				ProcessDebugTypeCVDirectoryEntry(fPEImage, fDmpFile, hModuleHandle, &ImageDebugDirectory);
				break;

			//
			// COFF symbols are okay... CV is better :)
			//
			case IMAGE_DEBUG_TYPE_COFF:
				ProcessDebugTypeCoffDirectoryEntry(fPEImage, &ImageDebugDirectory);
				break;
				
			//
			// MISC implies that a DBG file is created...
			//
			case IMAGE_DEBUG_TYPE_MISC:
				ProcessDebugTypeMiscDirectoryEntry(fPEImage, fDmpFile, hModuleHandle, &ImageDebugDirectory);
				break;
				
			//
			// FPO info is important for working with functions with FPO
			//
			case IMAGE_DEBUG_TYPE_FPO:
				ProcessDebugTypeFPODirectoryEntry(fPEImage, &ImageDebugDirectory);
				break;
				
			case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
			case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
				ProcessDebugTypeOMAPDirectoryEntry(fPEImage, &ImageDebugDirectory);
				break;
				
			case IMAGE_DEBUG_TYPE_UNKNOWN:
			case IMAGE_DEBUG_TYPE_EXCEPTION:
			case IMAGE_DEBUG_TYPE_FIXUP:
			case IMAGE_DEBUG_TYPE_BORLAND:
			case IMAGE_DEBUG_TYPE_RESERVED10:
			case IMAGE_DEBUG_TYPE_CLSID:
				break;

			default:
				break;
		}

        OffsetImageDebugDirectory += sizeof(IMAGE_DEBUG_DIRECTORY);
    }
	
cleanup:

	return true;
}


bool CModuleInfo::ProcessDebugTypeMiscDirectoryEntry(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	bool				fReturnValue = false;
	PIMAGE_DEBUG_MISC 	lpImageDebugMisc = NULL, lpCurrentImageDebugMiscPointer = NULL;
	ULONG	 			OffsetImageDebugDirectory = NULL;
	unsigned long 		ulSizeOfMiscDirectoryEntry = lpImageDebugDirectory->SizeOfData;

	//
	// DBG files tend to store the EXE name here... not too useful for now...
	//
	if (!fPEImage)
	{
		fReturnValue = true;
		goto cleanup;
	}

	//
	// Allocate storage for the MISC data...
	//
	lpImageDebugMisc = (PIMAGE_DEBUG_MISC) new BYTE[ulSizeOfMiscDirectoryEntry];

	if (lpImageDebugMisc == NULL)
		goto cleanup;
	
	// Calculate the location/size so we can load it.
	if (fDmpFile)
	{
		OffsetImageDebugDirectory = lpImageDebugDirectory->AddressOfRawData;
	} else
	{
		OffsetImageDebugDirectory = lpImageDebugDirectory->PointerToRawData;
	}

	// Advance to the location of the Debug Info
	SetReadPointer(fDmpFile, hModuleHandle, OffsetImageDebugDirectory, FILE_BEGIN);

	// Read the data...
	if (!DoRead(fDmpFile, hModuleHandle, lpImageDebugMisc, ulSizeOfMiscDirectoryEntry))
		goto cleanup;

	// Set our pointer to the start of our data...
	lpCurrentImageDebugMiscPointer = lpImageDebugMisc;
	
	//
	// The logic of this routine will skip past bad sections of the MISC datastream...
	//
	while(ulSizeOfMiscDirectoryEntry > 0)
	{
		//
		// Hopefully we have a string here...
		//
		if (lpCurrentImageDebugMiscPointer->DataType == IMAGE_DEBUG_MISC_EXENAME)
		{
			LPSTR lpszExeName;

            lpszExeName = (LPSTR)&lpCurrentImageDebugMiscPointer->Data[ 0 ];
					
			// Save off the DBG Path...
			if (m_tszPEImageDebugDirectoryDBGPath)
				delete [] m_tszPEImageDebugDirectoryDBGPath;

			if (lpCurrentImageDebugMiscPointer->Unicode)
			{
				// Is this a Unicode string?
				m_tszPEImageDebugDirectoryDBGPath = CUtilityFunctions::CopyUnicodeStringToTSTR((LPWSTR)lpszExeName);
			} else
			{
				// Is this an ANSI string?
				m_tszPEImageDebugDirectoryDBGPath = CUtilityFunctions::CopyAnsiStringToTSTR(lpszExeName);
			}

			if (!m_tszPEImageDebugDirectoryDBGPath)
				goto cleanup;

				break;
		
	
		} else
		{
			// Beware of corrupt images
			if (lpCurrentImageDebugMiscPointer->Length == 0)
			{
				break;
			}

			// Decrement the ulSizeOfMiscDirectoryEntry by the length of this "stuff"
    		ulSizeOfMiscDirectoryEntry -= lpCurrentImageDebugMiscPointer->Length;

			// If our new value exceeds the SizeOfData we need to bail...
            if (ulSizeOfMiscDirectoryEntry > lpImageDebugDirectory->SizeOfData)
			{
				ulSizeOfMiscDirectoryEntry = 0; // Avoid AV on bad exe
            	break;
            }
            
            lpCurrentImageDebugMiscPointer = (PIMAGE_DEBUG_MISC) (lpCurrentImageDebugMiscPointer + lpCurrentImageDebugMiscPointer->Length);
			
		}
	
	}

	fReturnValue = true;

cleanup:
	
	if (lpImageDebugMisc)
	{
		delete [] lpImageDebugMisc;
		lpImageDebugMisc = NULL;
	}
	
	return fReturnValue;
}

bool CModuleInfo::ProcessDebugTypeCoffDirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	//
	// The only thing we really care about is the size right now...
	//
	if (fPEImage)
	{
		m_dwPEImageDebugDirectoryCoffSize = lpImageDebugDirectory->SizeOfData;
	} else
	{
		m_dwDBGImageDebugDirectoryCoffSize = lpImageDebugDirectory->SizeOfData;
	}

	return true;
}

bool CModuleInfo::ProcessDebugTypeFPODirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	//
	// The only thing we really care about is the size right now...
	//
	if (fPEImage)
	{
		m_dwPEImageDebugDirectoryFPOSize = lpImageDebugDirectory->SizeOfData;
	} else
	{
		m_dwDBGImageDebugDirectoryFPOSize = lpImageDebugDirectory->SizeOfData;
	}

	return true;

}

bool CModuleInfo::ProcessDebugTypeCVDirectoryEntry(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	bool		fReturnValue = false;
	ULONG		OffsetImageDebugDirectory;
	DWORD 		dwCVFormatSpecifier;
	char		szPdb[_MAX_PATH * 3];	// Must this be so large?
	bool 		fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();
	LPSTR		pszPEImageModuleName = NULL;
	LPSTR		pszSymbolPath = NULL;
	HRESULT		hr = S_OK;
	HANDLE		hProcess = ::GetCurrentProcess();
	CModuleInfo * lpModuleInfo = NULL;

	// Calculate the location/size so we can load it.
	if (fDmpFile)
	{
		OffsetImageDebugDirectory = lpImageDebugDirectory->AddressOfRawData;

		// Check the offset returned... if it is zero then it is not mapped
		// record this with our own "CVFormatSpecifier" of sigNOTMAPPED
		if (0 == OffsetImageDebugDirectory)
		{
			// Before we give up, let's search the EXEPATH to see if we can find a matching
			// binary for this PE image... and from that we can extract the data?
			if (fDebugSearchPaths)
			{
				_tprintf(TEXT("PE Image Search - SEARCH for matching PE image to extract CV Data!\n"));
			};

			pszPEImageModuleName = CUtilityFunctions::CopyTSTRStringToAnsi(m_tszPEImageModuleFileSystemPath);
			pszSymbolPath = CUtilityFunctions::CopyTSTRStringToAnsi(g_lpProgramOptions->GetExePath());

			if (!pszPEImageModuleName || !pszSymbolPath)
			{
				fReturnValue = false;
				goto cleanup;
			}

			// Use the DBGHELP APIs to find our matching PE image
			if (::SymInitialize(hProcess, pszSymbolPath, FALSE))
			{

				// Here we go!
				CHAR szImagePath[_MAX_PATH+1];
				TCHAR tszImagePath[_MAX_PATH+1];

				// Attempt the search path!!!
				if (::SymFindFileInPath(		hProcess,
											pszSymbolPath,
											pszPEImageModuleName,
											ULongToPtr(GetPEImageTimeDateStamp()), // Cast to make compiler happy
											GetPEImageSizeOfImage(),
											0,
											SSRVOPT_DWORD,	//Flags
											szImagePath,
											NULL,
											NULL))
				{
					CHAR szImageFullPath[_MAX_DRIVE+_MAX_DIR+1];
					CHAR szImageDir[_MAX_DIR+1];
					::_splitpath(szImagePath, szImageFullPath, szImageDir, NULL, NULL);
					::strcat(szImageFullPath, szImageDir);

					// On Success copy the string back...
					CUtilityFunctions::CopyAnsiStringToTSTR(szImagePath, tszImagePath, _MAX_PATH+1);

					if (fDebugSearchPaths)
					{
						_tprintf(TEXT("PE Image Search - Looking for [%s]\r\n"), tszImagePath);
					}

					// Probe for file (it's lame but we want to see if you have connectivity
					hr = CUtilityFunctions::VerifyFileExists(TEXT("PE Image Search - Failed to open [%s]!  "), tszImagePath);

					// Search only if we know we can see the file... save an expensive call
					if (hr != S_OK)
						goto NotMapped;

					// Let's allocate a new module info to query this module!
					lpModuleInfo = new CModuleInfo();

					if (NULL == lpModuleInfo)
						goto NotMapped;

					// Must initialize the module (even one this short-lived)...
					if (!lpModuleInfo->Initialize(NULL, NULL, NULL))
						goto NotMapped;

					// Set our Module Path
					if (!lpModuleInfo->SetModulePath(tszImagePath))
						goto NotMapped;

					//
					// Okay, get the module info from the file...
					//
					if (!lpModuleInfo->GetModuleInfo(tszImagePath) )
						goto NotMapped;

					// Yahoo... now, copy the data over from our new PE image...

					// PDB Path
					if (NULL != lpModuleInfo->GetDebugDirectoryPDBPath())
					{
						m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyString(lpModuleInfo->GetDebugDirectoryPDBPath());
					}

					// PDB Format Specifier
					m_dwPEImageDebugDirectoryPDBFormatSpecifier	= lpModuleInfo->GetDebugDirectoryPDBFormatSpecifier();

					// RSDS images should not require this work-around... only sigNB10 with older linkers...
					Assert(m_dwPEImageDebugDirectoryPDBFormatSpecifier == sigNB10);

					m_dwPEImageDebugDirectoryPDBAge	= lpModuleInfo->GetDebugDirectoryPDBAge();
					m_dwPEImageDebugDirectoryPDBSignature = lpModuleInfo->GetDebugDirectoryPDBSignature();
				}

				::SymCleanup(hProcess);
			}
			fReturnValue = true;
			goto cleanup;
			// Couldn't find a matching image... we have no choice but to mark it as not-mapped

NotMapped:
			m_dwPEImageDebugDirectoryPDBFormatSpecifier = sigNOTMAPPED;
			fReturnValue = true;
			goto cleanup;
		}
	} else
	{
		OffsetImageDebugDirectory = lpImageDebugDirectory->PointerToRawData;
	}

	// Advance to the location of the Debug Info
	SetReadPointer(fDmpFile, hModuleHandle, OffsetImageDebugDirectory, FILE_BEGIN);

	// Read the data...
	if (!DoRead(fDmpFile, hModuleHandle, &dwCVFormatSpecifier, sizeof(DWORD)))
		goto cleanup;

	if (fPEImage)
	{
		m_dwPEImageDebugDirectoryPDBFormatSpecifier = dwCVFormatSpecifier;
	} else
	{
		m_dwDBGDebugDirectoryPDBFormatSpecifier = dwCVFormatSpecifier;
	}

	switch (dwCVFormatSpecifier)
	{
		case sigNB09:
		case sigNB11:
			//
			// The only thing we really care about is the size right now...
			//
			m_dwPDBFormatSpecifier = dwCVFormatSpecifier;

			if (fPEImage)
			{
				m_dwPEImageDebugDirectoryCVSize = lpImageDebugDirectory->SizeOfData;
			} else
			{
				m_dwDBGImageDebugDirectoryCVSize = lpImageDebugDirectory->SizeOfData;
			}

			break;
			
		case sigNB10:

            NB10I nb10i;
			m_dwPDBFormatSpecifier = sigNB10;

			// Read the data...
			if (!DoRead(fDmpFile, hModuleHandle, &nb10i.off, sizeof(NB10I) - sizeof(DWORD)))
				goto cleanup;

			if (fPEImage)
			{
				// Save away the PDB Signature...
				m_dwPEImageDebugDirectoryPDBSignature = nb10i.sig;

				// Save away the PDB Age...
				m_dwPEImageDebugDirectoryPDBAge = nb10i.age;
			} else
			{
				// Save away the PDB Signature...
				m_dwDBGDebugDirectoryPDBSignature = nb10i.sig;

				// Save away the PDB Age...
				m_dwDBGDebugDirectoryPDBAge = nb10i.age;
			}

 			// Read the data...
			if (!DoRead(fDmpFile, hModuleHandle, szPdb, (lpImageDebugDirectory->SizeOfData) - sizeof(NB10I)))
				goto cleanup;

			if (szPdb[0] != '\0')
			{
				// Save the data (as appropriate)
				if (fPEImage)
				{
					// Copy the PDB path away...
					m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyAnsiStringToTSTR(szPdb);

					if (!m_tszPEImageDebugDirectoryPDBPath)
						goto cleanup;
				} else 
				{
					// Copy the PDB path away...
					m_tszDBGDebugDirectoryPDBPath = CUtilityFunctions::CopyAnsiStringToTSTR(szPdb);

					if (!m_tszDBGDebugDirectoryPDBPath)
						goto cleanup;

					// We now know that we have a DBG/PDB combination...
					m_enumPEImageSymbolStatus = SYMBOLS_DBG_AND_PDB;
				}
			}
			break;

		case sigRSDS:
			
            RSDSI rsdsi;
			m_dwPDBFormatSpecifier = sigRSDS;

            // Read the RSDSI structure (except for the rsds DWORD at the beginning).
			if (!DoRead(fDmpFile, hModuleHandle, &rsdsi.guidSig, sizeof(RSDSI) - sizeof(DWORD)))
				goto cleanup;

			if (fPEImage)
			{
				// Save away the PDB Age...
				m_dwPEImageDebugDirectoryPDBAge = rsdsi.age;

				// Copy the GUID....
				memcpy(&m_guidPEImageDebugDirectoryPDBGuid, &rsdsi.guidSig, sizeof(m_guidPEImageDebugDirectoryPDBGuid));
			} else
			{
				// Save away the PDB Age...
				m_dwDBGDebugDirectoryPDBAge = rsdsi.age;

				// Copy the GUID....
				memcpy(&m_guidDBGDebugDirectoryPDBGuid, &rsdsi.guidSig, sizeof(m_guidDBGDebugDirectoryPDBGuid));
			}

			// Now, read in the PDB path... apparently it's in UTF8 format...
			if (!DoRead(fDmpFile, hModuleHandle, szPdb, (lpImageDebugDirectory->SizeOfData) - sizeof(RSDSI)))
				goto cleanup;
			
			if (szPdb[0] != '\0')
			{
				// Save the data (as appropriate)
				if (fPEImage)
				{
					wchar_t wszPdb[_MAX_PATH];
					CUtilityFunctions::UTF8ToUnicode(szPdb, wszPdb, sizeof(wszPdb)/sizeof(wszPdb[0]));

					// Copy the PDB path away...
					m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyUnicodeStringToTSTR(wszPdb);
					
					if (!m_tszPEImageDebugDirectoryPDBPath)
						goto cleanup;
				} else
				{
					wchar_t wszPdb[_MAX_PATH];
					CUtilityFunctions::UTF8ToUnicode(szPdb, wszPdb, sizeof(wszPdb)/sizeof(wszPdb[0]));

					// Copy the PDB path away...
					m_tszDBGDebugDirectoryPDBPath = CUtilityFunctions::CopyUnicodeStringToTSTR(wszPdb);
					
					if (!m_tszDBGDebugDirectoryPDBPath)
						goto cleanup;
				}
			}
            break;

		// Unknown CV format...
		default:
			m_dwPDBFormatSpecifier = sigUNKNOWN;
			break;
	}

	fReturnValue = true;

cleanup:
	if (pszPEImageModuleName)
	{
		delete [] pszPEImageModuleName;
		pszPEImageModuleName  = NULL;
	}
	
	if (pszSymbolPath)
	{
		delete [] pszSymbolPath;
		pszSymbolPath = NULL;
	}

	if (NULL != lpModuleInfo)
	{
		delete lpModuleInfo;
		lpModuleInfo = NULL;
	}
	return fReturnValue;
}

bool CModuleInfo::ProcessDebugTypeOMAPDirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	DWORD dwSize = lpImageDebugDirectory->SizeOfData;
	
	//
	// The only thing we really care about is the size right now...
	//
	switch (lpImageDebugDirectory->Type)
	{
		case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
			if (fPEImage)
			{
				m_dwPEImageDebugDirectoryOMAPtoSRCSize = dwSize;
			} else
			{
				m_dwDBGImageDebugDirectoryOMAPtoSRCSize = dwSize;
			}
			
			break;
			
		case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
			if (fPEImage)
			{
				m_dwPEImageDebugDirectoryOMAPfromSRCSize = dwSize;
			} else
			{
				m_dwDBGImageDebugDirectoryOMAPfromSRCSize = dwSize;
			}
			break;
	}

	return true;
}

bool CModuleInfo::OutputDataToStdoutInternalSymbolInfo(DWORD dwCoffSize, DWORD dwFPOSize, DWORD dwCVSize, DWORD dwOMAPtoSRC, DWORD dwOMAPfromSRC)
{
	if (dwCoffSize)
	{
		_tprintf(TEXT("    Internal COFF   Symbols - Size 0x%08x bytes\n"), dwCoffSize);
	}

	if (dwFPOSize)
	{
		_tprintf(TEXT("    Internal FPO    Symbols - Size 0x%08x bytes\n"), dwFPOSize);
	}

	if (dwCVSize)
	{
		_tprintf(TEXT("    Internal CV     Symbols - Size 0x%08x bytes\n"), dwCVSize);
	}

	if (dwOMAPtoSRC)
	{
		_tprintf(TEXT("    Internal -> SRC Symbols - Size 0x%08x bytes\n"), dwOMAPtoSRC);
	}

	if (dwOMAPfromSRC)
	{
		_tprintf(TEXT("    Internal SRC -> Symbols - Size 0x%08x bytes\n"), dwOMAPfromSRC);
	}

	
	return true;
}

//
// Dump DBG information
//
bool CModuleInfo::OutputDataToStdoutDbgSymbolInfo(LPCTSTR tszModulePointerToDbg, DWORD dwTimeDateStamp, DWORD dwChecksum, DWORD dwSizeOfImage, LPCTSTR tszDbgComment, DWORD dwExpectedTimeDateStamp, DWORD dwExpectedChecksum, DWORD dwExpectedSizeOfImage)
{
	if (!tszDbgComment)
	{
		// Dump out the pointer to the DBG file from the PE Image
		if (tszModulePointerToDbg)
		{
			_tprintf(TEXT("  Module Pointer to DBG = [%s]\n"), tszModulePointerToDbg);
		} else
		{
			_tprintf(TEXT("  Module had DBG File stripped from it.\n"));
		}

		time_t time = dwTimeDateStamp;
		_tprintf(TEXT("    Module TimeDateStamp = 0x%08x - %s"), dwTimeDateStamp, _tctime(&time));
		_tprintf(TEXT("    Module Checksum      = 0x%08x\n"), dwChecksum);
		_tprintf(TEXT("    Module SizeOfImage   = 0x%08x\n"), dwSizeOfImage);

	} else
	{
		TCHAR tszBuffer[2*_MAX_PATH]; // This should be large enough ;)
		size_t tszStringLength;

		// Is this discrepancy stuff...
		if (tszModulePointerToDbg)
		{
			_tprintf(TEXT("  DBG File = [%s] [%s]\n"), tszModulePointerToDbg, tszDbgComment);
		}

		time_t time = dwTimeDateStamp;
		_stprintf(tszBuffer, TEXT("    DBG TimeDateStamp    = 0x%08x - %s"), dwTimeDateStamp, _tctime(&time));

		// If our TimeDateStamps don't match... we have some fixup to do...
		if (dwTimeDateStamp != dwExpectedTimeDateStamp)
		{
			tszStringLength = _tcslen(tszBuffer);
			if (tszBuffer[tszStringLength-1] == '\n')
				tszBuffer[tszStringLength-1] = '\0';
		}
		
		_tprintf(tszBuffer);
		
		// If our TimeDateStamps don't match... we have some fixup to do...
		if (dwTimeDateStamp != dwExpectedTimeDateStamp)
		{
			_tprintf(TEXT(" [%s]!\n"), (dwTimeDateStamp > dwExpectedTimeDateStamp) ? TEXT("NEWER") : TEXT("OLDER"));
		}

		_tprintf(TEXT("    DBG Checksum         = 0x%08x [%s]\n"), dwChecksum, ( (dwChecksum == dwExpectedChecksum) ? TEXT("MATCHED"):TEXT("UNMATCHED")) );
		_tprintf(TEXT("    DBG SizeOfImage      = 0x%08x [%s]\n"), dwSizeOfImage, ( ( dwSizeOfImage == dwExpectedSizeOfImage) ? TEXT("MATCHED"):TEXT("UNMATCHED")) );
	}


	return true;
}

bool CModuleInfo::OutputDataToStdoutPdbSymbolInfo(DWORD dwPDBFormatSpecifier, LPTSTR tszModulePointerToPDB, DWORD dwPDBSignature, GUID * guidPDBGuid, DWORD dwPDBAge, LPCTSTR tszPdbComment)
{
	if (tszModulePointerToPDB)
	{
		if (!tszPdbComment)
		{
			_tprintf(TEXT("  Module Pointer to PDB = [%s]\n"), tszModulePointerToPDB);
		} else
		{
			_tprintf(TEXT("  PDB File = [%s] [%s]\n"), tszModulePointerToPDB, tszPdbComment);
		}
		switch (dwPDBFormatSpecifier)
		{
			case sigNB10:
				_tprintf(TEXT("    Module PDB Signature = 0x%x\n"), dwPDBSignature);
				break;
				
			case sigRSDS:
				wchar_t wszPDBGuid[39];
				TCHAR	tszPDBGuid[39];

				// We're going to convert the binary GUID format to a string for easier printing
				StringFromGUID2(*guidPDBGuid, wszPDBGuid, sizeof(wszPDBGuid)/sizeof(wchar_t));
				CUtilityFunctions::CopyUnicodeStringToTSTR(wszPDBGuid, tszPDBGuid, 39);

				_tprintf(TEXT("    Module PDB Guid = %s\n"), tszPDBGuid);
				break;
			
			case sigNOTMAPPED:
				_tprintf(TEXT("    Module PDB Signature = [Data Not Mapped into DMP file]\n"));
				break;

			default:
				_tprintf(TEXT("    UNKNOWN PDB Format!\n"));
				break;
		}
		
		if(dwPDBFormatSpecifier != sigNOTMAPPED)
		{
			_tprintf(TEXT("    Module PDB Age = 0x%x\n"), dwPDBAge);
		}

		// Do we have a problem because		
		if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode) && 
			m_enumPDBModuleStatus == SYMBOL_POSSIBLE_MISMATCH &&
			tszPdbComment)
		{
			if (m_fPDBSourceEnabled && (g_lpProgramOptions->GetSymbolSourceModes() == CProgramOptions::enumVerifySymbolsModeSourceSymbolsNotAllowed))
			{
				_tprintf(TEXT("    PDB Source Enabled (-NOSOURCE requested)\n"));
			} else
			if (!m_fPDBSourceEnabled && (g_lpProgramOptions->GetSymbolSourceModes() == CProgramOptions::enumVerifySymbolsModeSourceSymbolsOnly))
			{
				_tprintf(TEXT("    PDB Not Source Enabled (-SOURCEONLY requested)\n"));
			}
		}

	} else
	{
		_tprintf(TEXT("  Module has PDB File\n"));
		_tprintf(TEXT("  Module Pointer to PDB = [UNKNOWN] (Could not find in PE Image)\n"));
	}

	return true;
}

bool CModuleInfo::OutputDataToStdoutModuleInfo(DWORD dwModuleNumber)
{
	_tprintf(TEXT("Module[%3d] [%s] %s\n"), dwModuleNumber, m_tszPEImageModuleFileSystemPath, (m_dwPEImageDebugDirectoryCVSize ? TEXT("(Source Enabled)") : TEXT("")));

//	LPTSTR lpMachineArchitecture;
//
//	switch(m_wPEImageMachineArchitecture)
//	{
//		case IMAGE_FILE_MACHINE_I386:
//			lpMachineArchitecture = TEXT("Binary Image for Intel Machines");
//			break;
//
//		case IMAGE_FILE_MACHINE_ALPHA64:
//			lpMachineArchitecture = TEXT("Binary Image for Alpha Machines");
//			break;
//
//		default:
//			lpMachineArchitecture = TEXT("Binary Image for Unknown Machine Architecture");
//	}
//
//	if (m_wPEImageMachineArchitecture) _tprintf(TEXT("  %s\n"), lpMachineArchitecture);

	//
	// First, let's output version information if requested
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::CollectVersionInfoMode) )
	{
		// Version Information
		if (m_tszPEImageFileVersionCompanyName)	_tprintf(TEXT("  Company Name:      %s\n"), m_tszPEImageFileVersionCompanyName);
		if (m_tszPEImageFileVersionDescription)	_tprintf(TEXT("  File Description:  %s\n"), m_tszPEImageFileVersionDescription);
		if (m_tszPEImageProductVersionString)	_tprintf(TEXT("  Product Version:   %s\n"), m_tszPEImageProductVersionString);
		if (m_tszPEImageFileVersionString)	    _tprintf(TEXT("  File Version:      %s\n"), m_tszPEImageFileVersionString);
		if (m_dwPEImageFileSize)				_tprintf(TEXT("  File Size (bytes): %d\n"), m_dwPEImageFileSize);
		
		if ( m_ftPEImageFileTimeDateStamp.dwHighDateTime || m_ftPEImageFileTimeDateStamp.dwLowDateTime)
		{
			enum { FILETIME_BUFFERSIZE = 128 };
			TCHAR tszFileTime[FILETIME_BUFFERSIZE];
			
			if (OutputFileTime(m_ftPEImageFileTimeDateStamp, tszFileTime, FILETIME_BUFFERSIZE))
				_tprintf(TEXT("  File Date:         %s\n"), tszFileTime);
		}
	}

	return true;
}

bool CModuleInfo::OutputDataToStdoutThisModule()
{
	//
	// If we're not doing "Discrepancies Only" then we output this module unconditionally...
	//
	if (!g_lpProgramOptions->GetMode(CProgramOptions::OutputDiscrepanciesOnly))
		return true;

	//
	// If we're not in verification mode, then we output everything...
	//
	if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
		return true;
	
	//
	// This is "Discrepancy Only" mode, so check for discrepancies...
	//
	bool fAnyDiscrepancies = false;

	// Hey, if they only want to dump out modules with discrepancies... check to see
	// if this qualifies...
	switch (m_enumPEImageSymbolStatus)
	{
		// Consider these normal status codes...
		case SYMBOLS_DBG:
		case SYMBOLS_DBG_AND_PDB:
		case SYMBOLS_PDB:
		case SYMBOLS_LOCAL:
			break;

		// Anything else is worth reporting...
		default:
			fAnyDiscrepancies = true;
	}

	// If we don't have a discrepancy yet... let's look further...
	if (!fAnyDiscrepancies)
	{
		// Is there a DBG file?
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG) ||
			 (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) )
		{
			// Does it match?
			if ( m_enumDBGModuleStatus != SYMBOL_MATCH )
				fAnyDiscrepancies = true;
		}

		// Is there a PDB file?
		if ( GetDebugDirectoryPDBPath() )
		{
			if (m_enumPDBModuleStatus != SYMBOL_MATCH )
				fAnyDiscrepancies = true;
		}
	}

	return fAnyDiscrepancies;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\moduleinfonode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfonode.h
//
//--------------------------------------------------------------------------

// ModuleInfoNode.h: interface for the CModuleInfoNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MODULEINFONODE_H__1F4C77B3_A085_11D2_83AB_000000000000__INCLUDED_)
#define AFX_MODULEINFONODE_H__1F4C77B3_A085_11D2_83AB_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>

class CModuleInfo;	// Forward Declarations

class CModuleInfoNode  
{
public:
	CModuleInfoNode(CModuleInfo * lpModuleInfo);
	virtual ~CModuleInfoNode();
	
	bool AddModuleInfoNodeToTail(CModuleInfoNode ** lplpModuleInfoNode);

	CModuleInfo * m_lpModuleInfo;
	CModuleInfoNode * m_lpNextModuleInfoNode;
};

#endif // !defined(AFX_MODULEINFONODE_H__1F4C77B3_A085_11D2_83AB_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\moduleinfonode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfonode.cpp
//
//--------------------------------------------------------------------------

// ModuleInfoNode.cpp: implementation of the CModuleInfoNode class.
//
//////////////////////////////////////////////////////////////////////

#include "ModuleInfoNode.h"
#include "ModuleInfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModuleInfoNode::CModuleInfoNode(CModuleInfo * lpModuleInfo)
{
	// Save the Module Info object in our node...
	m_lpModuleInfo = lpModuleInfo;
	m_lpNextModuleInfoNode = NULL;
}

CModuleInfoNode::~CModuleInfoNode()
{
}

/***
** CModuleInfoNode::AddModuleInfoNodeToTail()
**
** This routine takes the current ModuleInfoNode, and adds it to the end of a linked
** list of these objects provided with an initial ModuleInfoNode (the head)
*/
bool CModuleInfoNode::AddModuleInfoNodeToTail(CModuleInfoNode ** lplpModuleInfoNode)
{
	if (NULL == *lplpModuleInfoNode)
	{
		*lplpModuleInfoNode = this;
		return true;
	}

	CModuleInfoNode * lpModuleInfoNodePointer = *lplpModuleInfoNode;

	// Add to the cache...

	// Traverse the linked list to the end..
	while (lpModuleInfoNodePointer->m_lpNextModuleInfoNode)
	{	// Keep looking for the end...
		lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
	}
	
	lpModuleInfoNodePointer->m_lpNextModuleInfoNode = this;

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\moduleinfocache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfocache.h
//
//--------------------------------------------------------------------------

// ModuleInfoCache.h: interface for the CModuleInfoCache class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MODULEINFOCACHE_H__2D4FCE63_C369_11D2_842B_0010A4F1B732__INCLUDED_)
#define AFX_MODULEINFOCACHE_H__2D4FCE63_C369_11D2_842B_0010A4F1B732__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif
#include <windows.h>

// Forward declarations
class CModuleInfo;
class CModuleInfoNode;
class CSymbolVerification;

class CModuleInfoCache  
{
public:
	CModuleInfoCache();
	virtual ~CModuleInfoCache();

	bool Initialize();
	CModuleInfo * AddNewModuleInfoObject(LPTSTR tszModulePath, bool * pfNew);
	bool RemoveModuleInfoObject(LPTSTR tszModulePath);

	bool VerifySymbols(bool fQuietMode);

	inline DWORD GetNumberOfModulesInCache() { return m_iModulesInCache; };
	inline long GetNumberOfVerifyErrors() { return m_iNumberOfErrors; };
	inline long GetNumberOfModulesVerified() { return m_iTotalNumberOfModulesVerified; };

protected:
	HANDLE m_hModuleInfoCacheMutex;
	long m_iModulesInCache;
	long m_iTotalNumberOfModulesVerified;
	CModuleInfoNode * m_lpModuleInfoNodeHead;
	long m_iNumberOfErrors;  // Used to return error level...

	CModuleInfo * SearchForModuleInfoObject(LPTSTR tszModulePath);
};

#endif // !defined(AFX_MODULEINFOCACHE_H__2D4FCE63_C369_11D2_842B_0010A4F1B732__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\modules.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       modules.cpp
//
//--------------------------------------------------------------------------

// Modules.cpp: implementation of the CModules class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include "Modules.h"
#include "ModuleInfo.h"
#include "ModuleInfoNode.h"
#include "ModuleInfoCache.h"
#include "DelayLoad.h"
#include "FileData.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModules::CModules()
{
	m_lpModuleInfoHead = NULL;
	m_hModuleInfoHeadMutex = NULL;
	m_lpDmpFile = NULL;

	m_fInitialized = false;
	m_iNumberOfModules = 0;
}

CModules::~CModules()
{
	WaitForSingleObject(m_hModuleInfoHeadMutex, INFINITE);

	// If we have Module Info Objects... nuke them now...
	if (m_lpModuleInfoHead)
	{

		CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoHead;
		CModuleInfoNode * lpModuleInfoNodePointerToDelete = m_lpModuleInfoHead;

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer)
		{	// Keep looking for the end...
			// Advance our pointer to the next node...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
			
			// Delete the one behind us...
			delete lpModuleInfoNodePointerToDelete;

			// Set the node to delete to the current...
			lpModuleInfoNodePointerToDelete = lpModuleInfoNodePointer;
		}
			
		// Now, clear out the Head pointer...
		m_lpModuleInfoHead = NULL;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoHeadMutex);

	// Now, close the Mutex
	if (m_hModuleInfoHeadMutex)
	{
		CloseHandle(m_hModuleInfoHeadMutex);
		m_hModuleInfoHeadMutex = NULL;
	}
}

bool CModules::Initialize(CModuleInfoCache *lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile)
{
	// We need the following objects to do business...
	if ( lpModuleInfoCache == NULL)
		return false;

	m_lpModuleInfoCache = lpModuleInfoCache;
	m_lpInputFile =  lpInputFile;
	m_lpOutputFile = lpOutputFile;
	m_lpDmpFile = lpDmpFile;

	m_hModuleInfoHeadMutex = CreateMutex(NULL, FALSE, NULL);

	if (m_hModuleInfoHeadMutex == NULL)
		return false;

	m_fInitialized = true;
	return true;
}

unsigned int CModules::GetModulesData(CProgramOptions::ProgramModes enumProgramModes, bool fGetDataFromCSVFile)
{
	// These represent modules we didn't even get to add to our cache (they didn't exist or they
	// are locked so we can't open them, etc...)
	unsigned int iNumberOfFailures = 0;
		
	switch (enumProgramModes)
	{
		case CProgramOptions::InputModulesDataFromFileSystemMode:

			if (fGetDataFromCSVFile)
			{
				GetModulesDataFromFile();
			} else
			{
				iNumberOfFailures = GetModulesDataFromFileSystem();
			}
			break;

		case CProgramOptions::InputDriversFromLiveSystemMode:

			if (fGetDataFromCSVFile)
			{
				GetModulesDataFromFile();	// ISSUE-2000/07/24-GREGWI: I think we can use the same method as above ????
			} else
			{
				GetModulesDataFromDeviceDrivers();
			}
			break;

		default:
			break;
	}

	return iNumberOfFailures;
}

unsigned int CModules::GetModulesDataFromFileSystem()
{
	unsigned int iNumberOfFailures = 0;
	bool fProcessPath = true;

	// Okay... here we go...
//#ifdef _DEBUG
//	_tprintf(TEXT("Processing the path [%s]\n"), m_lpProgramOptions->GetInputModulesDataFromFileSystemPath());
//#endif

	LPTSTR tszExpandedSymbolPath= NULL, tszSymbolPathStart, tszSymbolPathEnd;

	// Mark the start of the path to process
	tszSymbolPathStart = g_lpProgramOptions->GetInputModulesDataFromFileSystemPath();

	// Find the end of the path
	tszSymbolPathEnd = _tcschr( tszSymbolPathStart, ';' );

	// If tszSymbolPathEnd is non-zero, then there is another path following...
	if (tszSymbolPathEnd) 
		*tszSymbolPathEnd = '\0'; // Change the ';' to a Null temporarily...
	
	while (fProcessPath)
	{
//#ifdef _DEBUG
//		_tprintf(TEXT("\n\nProcessing Path [%s]\n"), tszSymbolPathStart);
//#endif

		// Begin the "madness"... ;)
		iNumberOfFailures += ScavengeForFiles(tszSymbolPathStart, 1, g_lpProgramOptions->fFileSystemRecursion() ? MAX_RECURSE_DEPTH : 1 );

		// Post processing... replace the null if necessary, and advance to next string
		if (tszSymbolPathEnd) 
		{
			*tszSymbolPathEnd = ';';
			tszSymbolPathStart = tszSymbolPathEnd + 1;
			
			tszSymbolPathEnd = _tcschr( tszSymbolPathStart, ';' );

			if (tszSymbolPathEnd) {
				*tszSymbolPathEnd = '\0';
			}
		} else
			fProcessPath = false;
	}

    if (tszExpandedSymbolPath) 
	{
        delete [] tszExpandedSymbolPath;
    }
	return iNumberOfFailures;
}

/*
** CModules::ScavengeForFiles()
** 
** This routine recursively (if requested) searches for a module, or module(s) in the specified directory location
**
** Algorithm works like this:
**
** ==================================
** Wild-Card character exists
** ==================================
**
** Look in current directory for files matching wild-chars
**   Success - is it file, if so process and exit
**           - is it a directory, if ignore
**   Failure - exit
**
** If recursion specified, append *.* wild-card and look for directories, if found recurse
**
** Using preserved wild-card characters, research path looking for files
** ==================================
** Wild-Card character does NOT exist
** ==================================
** - Open path provided
**   Success - is it file, if so process and exit
**           - is it a directory, if so add wild-card *.* and recurse (even if recursion was not specified)
**   Failure - exit
**
*/
unsigned int CModules::ScavengeForFiles(LPCTSTR tszSymbolPathStart, int iRecurseDepth, int iMaxRecursionDepth /* = 1 */)
{
	// Let's track the number of failures seen by ScavengeForFiles()!
	unsigned int iNumberOfFailures = 0;

	// Bale if we're in too deep...
	if (iRecurseDepth > iMaxRecursionDepth)
		return true;

	TCHAR tszFileBuffer[MAX_PATH+1];
	TCHAR drive[_MAX_DRIVE];
	TCHAR dir[_MAX_DIR];
	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];
	bool fNew;
	CModuleInfo * lpModuleInfo;
	WIN32_FIND_DATA lpFindFileData;

	// Search for files in current directory (ignore directories for now)...
	// Okay, search for sub-directories... (FindFirstEx would be more efficient)
	HANDLE hFileOrDirectoryHandle = FindFirstFile(tszSymbolPathStart, &lpFindFileData);

	// Save off the file-spec
	_tsplitpath(tszSymbolPathStart, drive, dir, fname, ext);

	// Keep looping as needed
	while (hFileOrDirectoryHandle != INVALID_HANDLE_VALUE)
	{
		// Check for this first... a directory provided with no wild-card
		if (!CUtilityFunctions::ContainsWildCardCharacter(tszSymbolPathStart))
		{
			// No wild-cards... either the user has specified a direct file, or a directory
			// the former is fine, and on the latter we'll simply append *.*
			if (lpFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				// Compose the path to the file or directory...
				_tcscpy(tszFileBuffer, tszSymbolPathStart);
				CUtilityFunctions::EnsureTrailingBackslash(tszFileBuffer);
				_tcscat(tszFileBuffer, TEXT("*.*"));

				// Recurse... don't charge them for doing this (don't add to recursion depth)
				iNumberOfFailures += ScavengeForFiles(tszFileBuffer, iRecurseDepth, iMaxRecursionDepth);

				// Okay, after we return - close this out and exit
				if ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
				{
					FindClose(hFileOrDirectoryHandle);
					hFileOrDirectoryHandle = INVALID_HANDLE_VALUE;
				}

				break;
			} else
			{
				// Okay, we have found a file and no wild-card was provided... let's process this one
				_tcscpy(tszFileBuffer, tszSymbolPathStart);
				goto processfile;
			}
		}else
		{
			// Okay, we have wild-cards... that's fine, let's process only the files right now...
			if (lpFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				goto getnextmodule;
			} else
			{
				// Found a file... let's process!
				TCHAR tszFullFileBuffer[_MAX_PATH+1];
				LPTSTR tszFileNamePointer;

				// Rebuilds this path
				_tmakepath(tszFileBuffer, drive, dir, lpFindFileData.cFileName, NULL);
				
processfile:
				// By this point we should have a full tszFileBuffer provided
				fNew = false;
				DWORD cbBytesCopied = GetFullPathName(tszFileBuffer , _MAX_PATH+1, tszFullFileBuffer, &tszFileNamePointer);

				if (cbBytesCopied)
				{
					// If "-MATCH" was specified, look to see if this filename meets our criteria
					// before we save this away in our module cache...
					if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszFullFileBuffer))
						goto getnextmodule;

					// Okay, let's go ahead and get a ModuleInfo Object from our cache...
					// If pfNew returns TRUE, then this object is new and we'll need
					// to populate it with data...
					lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszFullFileBuffer, &fNew);

					if (false == fNew)
					{
						// We may have the object in the cache... now we need to
						// save a pointer to this object in our Process Info list
						AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...

						// We save having to get the module info again for this module...
						goto getnextmodule;
					}

					// Not in the cache... so we need to init it, and get the module info...

					// Okay, let's create a ModuleInfo object and pass this down
					// routines that will populate it full of data...
					if (lpModuleInfo->Initialize(NULL, m_lpOutputFile, NULL))
					{

						// Let's do it!! Populate the ModuleInfo object with data!!!!
						if (lpModuleInfo->GetModuleInfo(tszFullFileBuffer))
						{
								// Start obtaining information about the modules...

								// We may have the object in the cache... now we need to
								// save a pointer to this object in our Process Info list
								if (AddNewModuleInfoObject(lpModuleInfo))
								{   
								}
						} else
						{
							// We failed to get useful information from this...
							// Remove this from the cache...
							m_lpModuleInfoCache->RemoveModuleInfoObject(tszFullFileBuffer);
						}
					}
				}
			}
		}

getnextmodule:
		// Keep Searching for the next one
		if (!FindNextFile(hFileOrDirectoryHandle, &lpFindFileData))
			break;				
	}

	// Cleanup from our fun!
	if ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
	{
		FindClose(hFileOrDirectoryHandle);
		hFileOrDirectoryHandle = INVALID_HANDLE_VALUE;
	}

	// Okay, do we have directories to recurse into?

	// Do we have room for a depth search?
	if ( (iRecurseDepth < iMaxRecursionDepth) && 
		 CUtilityFunctions::ContainsWildCardCharacter(tszSymbolPathStart))
	{
		// Search for directories
		
		// Compose the path to the file or directory...
		_tmakepath(tszFileBuffer, drive, dir, TEXT("*"), TEXT("*"));

		// Okay, search for sub-directories... (FindFirstEx would be more efficient)
		hFileOrDirectoryHandle = FindFirstFile(tszFileBuffer, &lpFindFileData);

		while ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
		{
			if (lpFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				// Check to see if we've got the . or .. directories!
				if ( ( 0 != _tcscmp(lpFindFileData.cFileName, TEXT(".")) ) &&
					 ( 0 != _tcscmp(lpFindFileData.cFileName, TEXT("..")) )
				   )
				{
					// We found a directory and it's not "." or ".."
					// Okay, found a directory... let's recurse into it
					
					// Compose the path to the file or directory... add back the wild-cards and invoke
					_tmakepath(tszFileBuffer, drive, dir, NULL, NULL);
					_tcscat(tszFileBuffer, lpFindFileData.cFileName);
					_tcscat(tszFileBuffer, TEXT("\\"));
					_tcscat(tszFileBuffer, fname);
					_tcscat(tszFileBuffer, ext);
					iNumberOfFailures += ScavengeForFiles(tszFileBuffer, iRecurseDepth+1, iMaxRecursionDepth);
				}
			}

			// Keep Searching
			if (!FindNextFile(hFileOrDirectoryHandle, &lpFindFileData))
				break;				
		}

		// Okay, we've completed and there are no more directories
		if ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
			FindClose(hFileOrDirectoryHandle);
	}
	
	return iNumberOfFailures;
}

bool CModules::AddNewModuleInfoObject(CModuleInfo *lpModuleInfo)
{
	if (!m_fInitialized)
	return false;

	// First, create a ModuleInfoNode object and then attach it to the bottom of the
	// linked list of nodes...
	CModuleInfoNode * lpModuleInfoNode = new CModuleInfoNode(lpModuleInfo);

//#ifdef _DEBUG
//	_tprintf(TEXT("Adding Module Info Object for [%s]\n"), lpModuleInfo->GetModulePath());
//#endif

	if (lpModuleInfoNode == NULL)
		return false; // Couldn't allocate memory..

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoHeadMutex, INFINITE);

	CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoHead;

	if (lpModuleInfoNodePointer) {

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer->m_lpNextModuleInfoNode)
		{	// Keep looking for the end...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
		}
		
		lpModuleInfoNodePointer->m_lpNextModuleInfoNode = lpModuleInfoNode;

	}
	else
	{ // First time through, the Process Info Head pointer is null...
		m_lpModuleInfoHead = lpModuleInfoNode;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoHeadMutex);

	InterlockedIncrement(&m_iNumberOfModules);

	return true;
}

//bool CModules::OutputModulesData(LPCTSTR tszOutputContext)
bool CModules::OutputModulesData(CollectionTypes enumCollectionType, bool fCSVFileContext)
{
	// Are we in quiet mode?
	if ( !g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) )
	{
		// Output to Stdout?
		if (!OutputModulesDataToStdout(enumCollectionType, fCSVFileContext))
			return false;
	}	

	// Output to file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Try and output to file...
		if (!OutputModulesDataToFile(enumCollectionType))
			return false;
	}	

	if (m_lpModuleInfoHead) {
		CModuleInfoNode * lpCurrentModuleInfoNode = m_lpModuleInfoHead;
		
		DWORD dwModuleNumber = 1;

		while (lpCurrentModuleInfoNode)
		{
			// We have a node... print out Module Info for it, then the Modules Data...
			if (lpCurrentModuleInfoNode->m_lpModuleInfo)
			{
				lpCurrentModuleInfoNode->m_lpModuleInfo->OutputData(NULL, 0, dwModuleNumber);
				dwModuleNumber++;
			}

			lpCurrentModuleInfoNode = lpCurrentModuleInfoNode->m_lpNextModuleInfoNode;
		}

	}
	return true;

}

bool CModules::OutputModulesDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext)
{
	_tprintf(TEXT("\n"));
	CUtilityFunctions::OutputLineOfStars();

	// Output to stdout...
	if (m_iNumberOfModules)
	{
		_tprintf(TEXT("%s - Printing Module Information for %d Modules.\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, m_iNumberOfModules);
		_tprintf(TEXT("%s - Context: %s\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, fCSVFileContext ? g_tszCollectionArray[enumCollectionType].tszCSVContext : g_tszCollectionArray[enumCollectionType].tszLocalContext);

	} else
	{
		_tprintf(TEXT("\n%s - No modules were found!\n\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel);
	}

	CUtilityFunctions::OutputLineOfStars();
	_tprintf(TEXT("\n"));

	return true;

}

bool CModules::OutputModulesDataToFile(CollectionTypes enumCollectionType)
{	
	// Don't write anything if there are no processes to report...
	if (0 == m_iNumberOfModules)
		return true;

	// Write out the Modules tag so I can detect this output format...
	if (!m_lpOutputFile->WriteString(TEXT("\r\n")) ||
		!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVLabel) ||
		!m_lpOutputFile->WriteString(TEXT("\r\n"))
	   )
	{
		_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
		m_lpOutputFile->PrintLastError();
		return false;
	}

	// Write out the [Modules] header...
	if (!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVColumnHeaders))
	{
		_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
		m_lpOutputFile->PrintLastError();
		return false;
	}

	return true;

}

bool CModules::GetModulesDataFromFile()
{
	CModuleInfo * lpModuleInfo;

	// Read the Modules Header Line
	if (!m_lpInputFile->ReadFileLine())
		return false;

	// I need these near the end when I probe to see if the next module
	// is for this process...
	enum { BUFFER_SIZE = 128};

	// Unfortunately, when reading from the CSV file, the data is MBCS... so I need
	// to convert...

	// Read the first field (should be blank, unless this is a new collection type
	if (m_lpInputFile->ReadString())
		return true;

	// Read the second field (should be blank)
	if (m_lpInputFile->ReadString())
		return true;

	// Read the second field (should be blank)
	if (m_lpInputFile->ReadString())
		return true;

	// Local buffer for reading data...
	char szModulePath[_MAX_PATH+1];
	TCHAR tszModulePath[_MAX_PATH+1];
	bool fDone = false;
	bool fNew = false;

	while (!fDone)
	{
		// Read in the Module Path
		if (!m_lpInputFile->ReadString(szModulePath, _MAX_PATH+1))
			return true;

		CUtilityFunctions::CopyAnsiStringToTSTR(szModulePath, tszModulePath, _MAX_PATH+1);

		// If "-MATCH" was specified, look to see if this filename meets our criteria
		// before we save this away in our module cache...
		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszModulePath))
		{
			// Okay... read to the start of the next line...
			if (!m_lpInputFile->ReadFileLine())
				goto cleanup;

			goto probe_line; // We save having to get the module info again for this module...
		}

		// Okay, let's go ahead and get a ModuleInfo Object from our cache...
		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszModulePath, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...

			// Okay... read to the start of the next line...
			if ( !m_lpInputFile->ReadFileLine() )
				goto cleanup;

			goto probe_line; // We save having to get the module info again for this module...
		}

		// Not in the cache... so we need to init it, and get the module info...
		if (!lpModuleInfo->Initialize(m_lpInputFile, m_lpOutputFile, NULL))
		{
			return false; // Hmmm... memory error?
		}

		// Let's do it!! Populate the ModuleInfo object with data!!!!
		if (!lpModuleInfo->GetModuleInfo(tszModulePath, false, 0, true))
		{
			// Well, we tried and failed... 
			return false;
		}

		// Start obtaining information about the modules...
		if (!AddNewModuleInfoObject(lpModuleInfo))
		{   // Failure adding the node.... This is pretty serious...
			return false;
		}
		
		// Okay, let's go ahead and probe to see what's coming...

probe_line:
		if ( m_lpInputFile->EndOfFile() )
			goto cleanup;

		// Read the first field (should be blank, unless this is a new collection type
		if (m_lpInputFile->ReadString())
			goto cleanup;

		// Read the second field (should be blank)
		if (m_lpInputFile->ReadString())
			return true;

		// Read the second field (should be blank)
		if (m_lpInputFile->ReadString())
			return true;
	}

cleanup:
	// We need to reset out pointer so the functions above us can re-read
	// them (they expect to)...
	m_lpInputFile->ResetBufferPointerToStart();
	return true;
}

// We need to enumerate device drivers on this system
bool CModules::GetModulesDataFromDeviceDrivers()
{
	LPVOID * lpImageBaseArray = NULL;
	DWORD    dwImageBaseArraySizeUsed, dwImageBaseArraySize, dwNumberOfDeviceDrivers, dwIndex;
	TCHAR    tszModulePath[_MAX_PATH];
	CModuleInfo * lpModuleInfo = NULL;
	bool	 fReturn = false, fNew = false;

	// NOTE: In the documentation, the third parameter of
	// EnumProcesses is named cbNeeded, which implies that you
	// can call the function once to find out how much space to
	// allocate for a buffer and again to fill the buffer.
	// This is not the case. The cbNeeded parameter returns
	// the number of PIDs returned, so if your buffer size is
	// zero cbNeeded returns zero.

	dwImageBaseArraySize = 256 * sizeof( LPVOID ) ;

	do
	{
		if( lpImageBaseArray )
		{ 	// Hmm.. we've been through this loop already, double the HeapSize and try again.

			delete [] lpImageBaseArray;
			dwImageBaseArraySize *= 2 ;
		}

		lpImageBaseArray = (LPVOID *) new DWORD[dwImageBaseArraySize];
		
		if( lpImageBaseArray == NULL )
		{
			goto error_cleanup;
		}

		// Query the system for the total number of processes
		if( !g_lpDelayLoad->EnumDeviceDrivers(lpImageBaseArray, dwImageBaseArraySize, &dwImageBaseArraySizeUsed ) )
		{
			// It's bad if we can't enum device drivers... no place to go but to bail out...
			goto error_cleanup;
		}
	} while( dwImageBaseArraySizeUsed == dwImageBaseArraySize );

	// How many DeviceDrivers did we get?
	dwNumberOfDeviceDrivers = dwImageBaseArraySizeUsed / sizeof( LPVOID ) ;

	// Loop through each Device Drivers
	for(dwIndex = 0 ; dwIndex < dwNumberOfDeviceDrivers; dwIndex++ )
	{
		// Spin until we get a device driver filename!
		if (!g_lpDelayLoad->GetDeviceDriverFileName(lpImageBaseArray[dwIndex], tszModulePath, _MAX_PATH))
			continue;

		CUtilityFunctions::UnMungePathIfNecessary(tszModulePath);

		// For some reason, even though GetDeviceDriverFileName() is supposed to return the fullpath to the device
		// driver... it don't always... sometimes it returns only the base file name...
		CUtilityFunctions::FixupDeviceDriverPathIfNecessary(tszModulePath, _MAX_PATH);

		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszModulePath))
			continue;

		// Okay, let's go ahead and get a ModuleInfo Object from our cache...
		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszModulePath, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			continue; // We save having to get the module info again for this module...
		}

		// Not in the cache... so we need to init it, and get the module info...
		if (!lpModuleInfo->Initialize(m_lpInputFile, m_lpOutputFile, NULL))
		{
			continue;
		}

		// Let's do it!! Populate the ModuleInfo object with data!!!!
		if (!lpModuleInfo->GetModuleInfo(tszModulePath, false, 0, false))
		{
			// Well, we tried and failed... 
			continue;
		}

		// We may have the object in the cache... now we need to
		// save a pointer to this object in our Process Info list
		if (!AddNewModuleInfoObject(lpModuleInfo))
		{   // Failure adding the node.... This is pretty serious...
			continue;
		}
	}

	fReturn = true;
	goto cleanup;

error_cleanup:


cleanup:

	if (lpImageBaseArray)
	{
		delete [] lpImageBaseArray;
	}

	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\modules.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       modules.h
//
//--------------------------------------------------------------------------

// Modules.h: interface for the CModules class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MODULES_H__04AC8803_D1FA_11D2_8454_0010A4F1B732__INCLUDED_)
#define AFX_MODULES_H__04AC8803_D1FA_11D2_8454_0010A4F1B732__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include "DmpFile.h"
#include "ProgramOptions.h"

// Forward Declarations
class CModuleInfoCache;
class CModuleInfoNode;
class CFileData;
class CModuleInfo;

class CModules  
{

public:

	CModules();
	virtual ~CModules();

	bool Initialize(CModuleInfoCache *lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile);
	bool OutputModulesData(CollectionTypes enumCollectionType, bool fCSVFileContext);
	unsigned int GetModulesData(CProgramOptions::ProgramModes enumProgramModes, bool fGetDataFromCSVFile = false);
//	bool EnumerateModulesFromMemoryDmpFile();
	bool AddNewModuleInfoObject(CModuleInfo *lpModuleInfo);

protected:

	HANDLE m_hModuleInfoHeadMutex;
	enum { MAX_RECURSE_DEPTH = 30 };
	long m_iNumberOfModules;
	bool m_fInitialized;

	CModuleInfoCache * m_lpModuleInfoCache;
	CFileData * m_lpInputFile;
	CFileData * m_lpOutputFile;
	CModuleInfoNode * m_lpModuleInfoHead;
	CDmpFile * m_lpDmpFile;

	bool GetModulesDataFromDeviceDrivers();
	bool GetModulesDataFromFile();
	unsigned int ScavengeForFiles(LPCTSTR tszSymbolPathStart, int iRecurseDepth, int iMaxRecursionDepth = 1);
	unsigned int GetModulesDataFromFileSystem();
	bool OutputModulesDataToFile(CollectionTypes enumCollectionType);
	bool OutputModulesDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext);

};

#endif // !defined(AFX_MODULES_H__04AC8803_D1FA_11D2_8454_0010A4F1B732__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\moduleinfocache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfocache.cpp
//
//--------------------------------------------------------------------------

// ModuleInfoCache.cpp: implementation of the CModuleInfoCache class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include "ModuleInfoCache.h"
#include "ModuleInfo.h"
#include "ModuleInfoNode.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModuleInfoCache::CModuleInfoCache()
{
	m_iModulesInCache = 0;
	m_iNumberOfErrors = 0;
	m_iTotalNumberOfModulesVerified = 0;
	m_lpModuleInfoNodeHead = NULL;
}

CModuleInfoCache::~CModuleInfoCache()
{
	// Delete all the Module Info Objects...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	if (m_lpModuleInfoNodeHead)
	{
		CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoNodeHead;
		CModuleInfoNode * lpModuleInfoNodePointerToDelete = m_lpModuleInfoNodeHead;

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer)
		{	// Keep looking for the end...
			// Advance our pointer to the next node...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
			
			// Delete the Module Info Object we have...
			delete lpModuleInfoNodePointerToDelete->m_lpModuleInfo;

			// Delete the Module Info Node Object behind us...
			delete lpModuleInfoNodePointerToDelete;

			// Set the node to delete to the current...
			lpModuleInfoNodePointerToDelete = lpModuleInfoNodePointer;
		}
			
		// Now, clear out the Head pointer...
		m_lpModuleInfoNodeHead = NULL;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoCacheMutex);

	// Now, close the Mutex
	if (m_hModuleInfoCacheMutex)
	{
		CloseHandle(m_hModuleInfoCacheMutex);
		m_hModuleInfoCacheMutex = NULL;
	}
}

// Search for the provided module path, return a pointer to the
// ModuleInfo object if we find it...
CModuleInfo * CModuleInfoCache::SearchForModuleInfoObject(LPTSTR tszModulePath)
{
	if (tszModulePath == NULL)
		return NULL;

	CModuleInfo * lpModuleInfoObjectToReturn = NULL;

	// Search all the Module Info Objects...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	if (m_lpModuleInfoNodeHead)
	{

		CModuleInfoNode * lpCurrentModuleInfoNodePointer = m_lpModuleInfoNodeHead;
		CModuleInfoNode * lpParentModuleInfoNodePointer = NULL;

		DWORD dwParentModuleInfoRefCount = 0;
		DWORD dwModuleInfoRefCount = 0;

		// Traverse the linked list to the end..
		while (lpCurrentModuleInfoNodePointer )
		{	
			// Do we have a match?
			if ( 0 == _tcscmp(tszModulePath, lpCurrentModuleInfoNodePointer->m_lpModuleInfo->GetModulePath()) )
			{
				// Yee haa... We have a match!!!
				lpModuleInfoObjectToReturn = lpCurrentModuleInfoNodePointer->m_lpModuleInfo;

				// Increment the refcount... of the new Object...
				dwModuleInfoRefCount = lpModuleInfoObjectToReturn->AddRef();

#ifdef _DEBUG_MODCACHE
				_tprintf(TEXT("MODULE CACHE: Module FOUND in Cache [%s] (New Ref Count = %d)\n"), tszModulePath, dwModuleInfoRefCount);
#endif
				// If we have a parent... and we find that it's refcount is below ours
				// we'll want to move ourself into the correct position...
				if ( lpParentModuleInfoNodePointer && 
					( dwParentModuleInfoRefCount < dwModuleInfoRefCount ) 
				   )
				{
					// First... pop us off the list...
					lpParentModuleInfoNodePointer->m_lpNextModuleInfoNode = 
						lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode;

					// Set the Parent Node pointer to NULL (so we can tell if there is a parent)
					lpParentModuleInfoNodePointer = NULL;

					// Now, starting from the top of the list... figure out where to stuff us...
					CModuleInfoNode * lpTempModuleInfoNodePointer = m_lpModuleInfoNodeHead;

					// Keep looking...
					while (lpTempModuleInfoNodePointer)
					{
						// We're looking for a place where our ref count is greater than
						// the node we're pointing at...
						if ( dwModuleInfoRefCount >
							lpTempModuleInfoNodePointer->m_lpModuleInfo->GetRefCount())
						{
							// Bingo...

							// Do we have the highest refcount?
							if (lpParentModuleInfoNodePointer == NULL)
							{
								// We are to become the head...

								// Make our node point to where the head currently points.
								lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode = m_lpModuleInfoNodeHead;

								// Set the current NodeHead to ours...
								m_lpModuleInfoNodeHead = lpCurrentModuleInfoNodePointer;

							} else
							{
								// We're not the head...

								// Save where the parent currently points...
								lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode = lpParentModuleInfoNodePointer->m_lpNextModuleInfoNode;

								// Set the parent to point to us...
								lpParentModuleInfoNodePointer->m_lpNextModuleInfoNode = lpCurrentModuleInfoNodePointer;
							}
							goto cleanup;
						}

						// Save the old pointer (it's now the parent)
						lpParentModuleInfoNodePointer = lpTempModuleInfoNodePointer;

						// Let's try the next one...
						lpTempModuleInfoNodePointer = lpTempModuleInfoNodePointer->m_lpNextModuleInfoNode;
					}
				}
				break;
			}

			// Save parent location (we need it for popping our object from the list)
			lpParentModuleInfoNodePointer = lpCurrentModuleInfoNodePointer ; 
			
			// Save our parent's ref count...
			dwParentModuleInfoRefCount = lpCurrentModuleInfoNodePointer->m_lpModuleInfo->GetRefCount();
			
			// Advance to the next object...
			lpCurrentModuleInfoNodePointer  = lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode;
		}
	}

cleanup:
	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoCacheMutex);

#ifdef _DEBUG_MODCACHE
		if (!lpModuleInfoObjectToReturn)
			_tprintf(TEXT("MODULE CACHE: Module not found in Cache [%s]\n"), tszModulePath);
#endif

	return lpModuleInfoObjectToReturn;
}

/***
** CModuleInfoCache::AddNewModuleInfoObject()
**
** This routine accepts a path to the module, and either returns the 
** Module Info object from the cache, or creates a new object that needs
** to be populated.
*/

CModuleInfo * CModuleInfoCache::AddNewModuleInfoObject(LPTSTR tszModulePath, bool * pfNew)
{
	if (tszModulePath == NULL)
		return NULL;

	CModuleInfo * lpModuleInfoObjectToReturn = NULL;
	CModuleInfoNode * lpModuleInfoNode = NULL;
	*pfNew = false;

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	_tcsupr(tszModulePath); // Upper case the module path... makes it faster on search...

	lpModuleInfoObjectToReturn = SearchForModuleInfoObject(tszModulePath);

	if (lpModuleInfoObjectToReturn)
	{
		// Success... since it already exists, we just return this object...
		goto cleanup;		
	}

	// We need to create a new object then...
	lpModuleInfoObjectToReturn = new CModuleInfo();

	if (NULL == lpModuleInfoObjectToReturn)
		goto error_cleanup;		// This is bad... get out...

	// Set the module path (that's the only thing we have to set at this exact moment
	if (!lpModuleInfoObjectToReturn->SetModulePath(tszModulePath))
		goto cleanup;
	
	*pfNew = true;

	// Now, create a new ModuleInfoNode, and add this new object to it...
	lpModuleInfoNode = new CModuleInfoNode(lpModuleInfoObjectToReturn);

	if (NULL == lpModuleInfoNode)
		goto error_cleanup;

	if (!lpModuleInfoNode->AddModuleInfoNodeToTail(&m_lpModuleInfoNodeHead))
		goto error_cleanup;

#ifdef _DEBUG_MODCACHE
	_tprintf(TEXT("MODULE CACHE: Module ADDED to Cache [%s] (RefCount = %d)\n"), tszModulePath, lpModuleInfoNode->m_lpModuleInfo->GetRefCount());
#endif

	InterlockedIncrement(&m_iModulesInCache);
	// Success...
	goto cleanup;

error_cleanup:
	if (lpModuleInfoObjectToReturn)
	{
		delete lpModuleInfoObjectToReturn;
		lpModuleInfoObjectToReturn = NULL;
	}



cleanup:
	// Release the Mutex...
	ReleaseMutex(m_hModuleInfoCacheMutex);

	return lpModuleInfoObjectToReturn;
}

bool CModuleInfoCache::Initialize()
{
	// Let's save the symbol verification object here...
//	m_lpSymbolVerification = lpSymbolVerification;

	m_hModuleInfoCacheMutex = CreateMutex(NULL, FALSE, NULL);

	if (m_hModuleInfoCacheMutex == NULL)
		return false;

	return true;
}

bool CModuleInfoCache::VerifySymbols(bool fQuietMode)
{
	enum { iTotalNumberOfDotsToPrint = 79 };
	unsigned int iDotsPrinted = 0;
	unsigned int iDotsToPrint;
	long iTotalNumberOfModulesProcessed = 0;
	unsigned int iTotalNumberOfModules = GetNumberOfModulesInCache();
	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();
	bool fBadSymbol = true;

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	if (m_lpModuleInfoNodeHead) 
	{
		CModuleInfoNode * lpCurrentModuleInfoNode = m_lpModuleInfoNodeHead;

		while (lpCurrentModuleInfoNode)
		{
			fBadSymbol = true;

			// We have a node... verify the Module Info for it...
			if (lpCurrentModuleInfoNode->m_lpModuleInfo)
			{
#ifdef _DEBUG_MODCACHE
				_tprintf(TEXT("MODULE CACHE: Verifying Symbols for [%s] (Refcount=%d)\n"), 
						lpCurrentModuleInfoNode->m_lpModuleInfo->GetModulePath(),
						lpCurrentModuleInfoNode->m_lpModuleInfo->GetRefCount() );
#endif
				if (fDebugSearchPaths && lpCurrentModuleInfoNode->m_lpModuleInfo->GetPESymbolInformation() != CModuleInfo::SYMBOL_INFORMATION_UNKNOWN)
				{
					CUtilityFunctions::OutputLineOfDashes();
					_tprintf(TEXT("Verifying Symbols for [%s]\n"), lpCurrentModuleInfoNode->m_lpModuleInfo->GetModulePath());
					CUtilityFunctions::OutputLineOfDashes();
				}

				// Invoke the ModuleInfo's VerifySymbols method... the cache doesn't know
				// how to verify symbols, but the ModuleInfo knows how to get this done...
				fBadSymbol = !lpCurrentModuleInfoNode->m_lpModuleInfo->VerifySymbols() || !lpCurrentModuleInfoNode->m_lpModuleInfo->GoodSymbolNotFound();

				// Increment total number of modules verified
				iTotalNumberOfModulesProcessed++;

				// Increment total number of modules verified for actual PE images... only...
				if (lpCurrentModuleInfoNode->m_lpModuleInfo->GetPESymbolInformation() != CModuleInfo::SYMBOL_INFORMATION_UNKNOWN)
				{						
					InterlockedIncrement(&m_iTotalNumberOfModulesVerified);

					if (fBadSymbol)
						InterlockedIncrement(&m_iNumberOfErrors);
				}

				if (!fQuietMode && !fDebugSearchPaths)
				{
					// Let's see if we should print a status dot... there will be room for 80 dots
					// but we'll just print 60 for now...
					
					iDotsToPrint = (iTotalNumberOfDotsToPrint * iTotalNumberOfModulesProcessed) / iTotalNumberOfModules;

					// Print out any dots if we need to...
					while (iDotsToPrint > iDotsPrinted)
					{
						_tprintf(TEXT("."));
						iDotsPrinted++;
					}
				}
			}

			lpCurrentModuleInfoNode = lpCurrentModuleInfoNode->m_lpNextModuleInfoNode;
		}

		if (!fQuietMode && iDotsPrinted && !fDebugSearchPaths)
			_tprintf(TEXT("\n\n"));
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoCacheMutex);

	return true;
}

bool CModuleInfoCache::RemoveModuleInfoObject(LPTSTR tszModulePath)
{
	bool fRetVal = false;
	DWORD	dwModuleInfoRefCount = 0;
	
	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	if (m_lpModuleInfoNodeHead)
	{
		// Okay, the Parent node starts at the top...
		CModuleInfoNode * lpParentInfoNodePointer = NULL;  // This implies we're at the top of the linked list...
		CModuleInfoNode * lpCurrentModuleInfoNodePointer = m_lpModuleInfoNodeHead;

		// Traverse the linked list to the end..
		while (lpCurrentModuleInfoNodePointer )
		{	
#ifdef _DEBUG_MODCACHE
				_tprintf(TEXT("MODULE CACHE: Comparing [%s] to [%s]\n"), tszModulePath, lpCurrentModuleInfoNodePointer->m_lpModuleInfo->GetModulePath());
#endif
			// Do we have a match?
			if ( 0 == _tcsicmp(tszModulePath, lpCurrentModuleInfoNodePointer->m_lpModuleInfo->GetModulePath()) )
			{
				// Yee haa... We have a match!!!

				// Drop the refcount... if it's zero... we delete the object...
				dwModuleInfoRefCount = lpCurrentModuleInfoNodePointer->m_lpModuleInfo->Release();

#ifdef _DEBUG_MODCACHE
				_tprintf(TEXT("MODULE CACHE: Module FOUND in Cache [%s] (RefCount = %d)\n"), tszModulePath, dwModuleInfoRefCount);
#endif
				
				if (dwModuleInfoRefCount == 0)
				{
#ifdef _DEBUG_MODCACHE
					_tprintf(TEXT("MODULE CACHE: Module [%s] refcount is 0, DELETING\n"), tszModulePath);
#endif

					// If we're unlinking the first module (the node-head)...update it here...
					if (lpParentInfoNodePointer == NULL)
					{
#ifdef _DEBUG_MODCACHE
						_tprintf(TEXT("MODULE CACHE: Module [%s] is NODE Head!\n"), tszModulePath);
#endif
						// Link the ModuleInfoNode Head to the child node... we're delete the head itself!
						m_lpModuleInfoNodeHead = lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode;
					} else
					{
						// Link the parent node to the child node... we're deleting this node...
						lpParentInfoNodePointer->m_lpNextModuleInfoNode = lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode;
					}

					InterlockedDecrement(&m_iModulesInCache);

					// Now we're free to delete this node (and it's attached module)

					// Delete the current module...
					delete lpCurrentModuleInfoNodePointer->m_lpModuleInfo;
					lpCurrentModuleInfoNodePointer->m_lpModuleInfo = NULL;
					
					// Delete the module info node itself...
					delete lpCurrentModuleInfoNodePointer;
					lpCurrentModuleInfoNodePointer = NULL;
				}

				fRetVal = true;

				// We're done looking through the linked list...
				break;
			}

			// Advance to the next object...
			lpParentInfoNodePointer = lpCurrentModuleInfoNodePointer;
			lpCurrentModuleInfoNodePointer  = lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode;
		}

	}
	
	// Release the Mutex...
	ReleaseMutex(m_hModuleInfoCacheMutex);

	return fRetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\newtypes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       newtypes.h
//
//--------------------------------------------------------------------------

#if !defined(__midl) && defined(_X86_) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
#if ( 501 < __midl )

//    typedef [public] __int3264 INT_PTR, *PINT_PTR;
//    typedef [public] unsigned __int3264 UINT_PTR, *PUINT_PTR;

    typedef [public] __int3264 LONG_PTR, *PLONG_PTR;
    typedef [public] unsigned __int3264 ULONG_PTR, *PULONG_PTR;

#else  // midl64
// old midl and C++ compiler

#if defined(_WIN64)
//    typedef __int64 INT_PTR, *PINT_PTR;
//    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int64

#else
//    typedef _W64 int INT_PTR, *PINT_PTR;
//    typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

    typedef _W64 long LONG_PTR, *PLONG_PTR;
    typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int32

#endif
#endif // midl64

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt


#ifdef VC_DEV

typedef struct LIST_ENTRY32 {
    ULONG Flink;
    ULONG Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;

#endif

typedef struct _STRING32 {
    USHORT   Length;
    USHORT   MaximumLength;
    ULONG  Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;
typedef UNICODE_STRING32 *PUNICODE_STRING32;



typedef struct _STRING64 {
    USHORT   Length;
    USHORT   MaximumLength;
    ULONGLONG  Buffer;
} STRING64;
typedef STRING64 *PSTRING64;

typedef STRING64 UNICODE_STRING64;
typedef UNICODE_STRING64 *PUNICODE_STRING64;

typedef STRING64 ANSI_STRING64;
typedef ANSI_STRING64 *PANSI_STRING64;

// begin_winnt begin_ntndis

#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NTAPI __stdcall
#else
#define _cdecl
#define NTAPI
#endif

typedef LONG NTSTATUS;
/*lint -e624 */  // Don't complain about different typedefs.   // winnt
typedef NTSTATUS *PNTSTATUS;
/*lint +e624 */  // Resume checking for different typedefs.    // winnt

// begin_ntndis
//
// Counted String
//

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength), length_is(Length) ]
#endif // MIDL_PASS
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\moduleinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfo.h
//
//--------------------------------------------------------------------------

// ModuleInfo.h: interface for the CModuleInfo class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MODULEINFO_H__0D2E8509_A01A_11D2_83A8_000000000000__INCLUDED_)
#define AFX_MODULEINFO_H__0D2E8509_A01A_11D2_83A8_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include "globals.h"
#include <time.h>
#include <stdlib.h>

//
//#include "oemdbi.h"
//
// Bug MSINFO V4.1:655
#define PDB_LIBRARY
#pragma warning( push )
#pragma warning( disable : 4201 )		// Disable "nonstandard extension used : nameless struct/union" warning
#include "pdb.h"
#pragma warning( pop )					// Enable
#include <atlbase.h>
#include <dia2.h>

const ULONG sigRSDS 		= 'SDSR';
const ULONG sigNB09 		= '90BN';
const ULONG sigNB10 		= '01BN';
const ULONG sigNB11 		= '11BN';
const ULONG sigNOTMAPPED 	= 'MISS';
const ULONG sigUNKNOWN 		= 'UNKN';
	
// Forward declarations
//class CProgramOptions;
class CSymbolVerification;
class CFileData;
class CDmpFile;

class CModuleInfo
{
	// Definition of Class Constants
	enum { MAX_SEARCH_PATH_LEN=512 };

	enum { ipNone = 0, ipFirst, ipLast }; // Used by diaLocatePdb

	//  CodeView Debug OMF signature.  The signature at the end of the file is
	//  a negative offset from the end of the file to another signature.  At
	//  the negative offset (base address) is another signature whose filepos
	//  field points to the first OMFDirHeader in a chain of directories.
	//  The NB05 signature is used by the link utility to indicated a completely
	//  unpacked file.  The NB06 signature is used by ilink to indicate that the
	//  executable has had CodeView information from an incremental link appended
	//  to the executable.  The NB08 signature is used by cvpack to indicate that
	//  the CodeView Debug OMF has been packed.  CodeView will only process
	//  executables with the NB08 signature.

	typedef struct OMFSignature
	{
		char Signature[4];   // "NBxx"
		long filepos;        // offset in file
	};

	typedef struct PDB_INFO
	{
		unsigned long sig;
		unsigned long age;
		char sz[_MAX_PATH];
	};

	//
	// These types are likely to be defined in a header file I include later for the latest
	// OEMDBI toolkit...
	//
	struct NB10I                           // NB10 debug info
	{
		DWORD   nb10;                      // NB10
		DWORD   off;                       // offset, always 0
		DWORD   sig;
		DWORD   age;
	};

	struct RSDSI                           // RSDS debug info
	{
		DWORD   rsds;                      // RSDS
		GUID    guidSig;
		DWORD   age;
	};
	
public:
	CModuleInfo();
	virtual ~CModuleInfo();

	bool GoodSymbolNotFound();
	bool SetPEImageModuleName(LPTSTR tszNewModuleName);
	bool SetPEImageModulePath(LPTSTR tszNewPEImageModulePath);
	bool SetDebugDirectoryDBGPath(LPTSTR tszNewDebugDirectoryDBGPath);
	bool SetPEDebugDirectoryPDBPath(LPTSTR tszNewDebugDirectoryPDBPath);

	bool Initialize(CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile);

	bool SetModulePath(LPTSTR tszModulePath);
	
	bool VerifySymbols();
	static BOOL VerifyDBGFile(HANDLE hFileHandle, LPTSTR tszFileName, PVOID CallerData);
	static BOOL VerifyPDBFile(HANDLE hFileHandle, LPTSTR tszFileName, PVOID CallerData);
	
	bool OutputData(LPTSTR tszProcessName, DWORD iProcessID, unsigned int dwModuleNumber);
	bool GetModuleInfo(LPTSTR tszModulePath, bool fDmpFile = false, DWORD64 dw64ModAddress = 0, bool fGetDataFromCSVFile = false);
	LPTSTR GetModulePath();

	enum SymbolModuleStatus { SYMBOL_NOT_FOUND, SYMBOL_MATCH, SYMBOL_POSSIBLE_MISMATCH, SYMBOL_INVALID_FORMAT, SYMBOL_NO_HELPER_DLL };
	enum SymbolInformationForPEImage {SYMBOL_INFORMATION_UNKNOWN, SYMBOLS_NO, SYMBOLS_LOCAL, SYMBOLS_DBG, SYMBOLS_DBG_AND_PDB, SYMBOLS_PDB};
	
	// INLINE Methods!
	inline enum SymbolInformationForPEImage GetPESymbolInformation() { return m_enumPEImageSymbolStatus; };
	inline enum SymbolModuleStatus GetDBGSymbolModuleStatus() { return m_enumDBGModuleStatus; };
	inline enum SymbolModuleStatus GetPDBSymbolModuleStatus() { return m_enumPDBModuleStatus; };
	inline DWORD GetRefCount() { return m_dwRefCount; };
	inline DWORD AddRef() { return InterlockedIncrement((long *)&m_dwRefCount); };
	inline DWORD Release() { return InterlockedDecrement((long *)&m_dwRefCount); };
	inline bool IsDLL() { return (m_wCharacteristics & IMAGE_FILE_DLL) == IMAGE_FILE_DLL; };
	inline DWORD GetPEImageTimeDateStamp() { return m_dwPEImageTimeDateStamp; };
	inline DWORD GetPEImageSizeOfImage() { return m_dwPEImageSizeOfImage; };
	inline LPTSTR GetPDBModulePath() { return m_tszPDBModuleFileSystemPath; };
	inline LPTSTR GetDebugDirectoryPDBPath() { return (m_tszPEImageDebugDirectoryPDBPath == NULL) ? m_tszDBGDebugDirectoryPDBPath : m_tszPEImageDebugDirectoryPDBPath; };
	inline DWORD GetReadPointer() { return m_dwCurrentReadPosition; };
	inline LPTSTR SourceEnabledPEImage() { return ( (m_dwPEImageDebugDirectoryPDBFormatSpecifier == sigNB09) || (m_dwPEImageDebugDirectoryPDBFormatSpecifier == sigNB11) )  ? TEXT("(Source Enabled)") : TEXT(""); };
	inline LPTSTR SourceEnabledDBGImage() { return ( (m_dwDBGDebugDirectoryPDBFormatSpecifier == sigNB09) || (m_dwDBGDebugDirectoryPDBFormatSpecifier == sigNB11) )  ? TEXT("(Source Enabled?)") : TEXT(""); };
	inline LPTSTR SourceEnabledPDB() { return m_fPDBSourceEnabled ? TEXT("(Source Enabled)") : TEXT("");};
	inline DWORD GetDebugDirectoryPDBAge() { return (m_enumPEImageSymbolStatus == SYMBOLS_PDB) ? m_dwPEImageDebugDirectoryPDBAge : m_dwDBGDebugDirectoryPDBAge;};
	inline DWORD GetDebugDirectoryPDBSignature() { return (m_enumPEImageSymbolStatus == SYMBOLS_PDB) ? m_dwPEImageDebugDirectoryPDBSignature : m_dwDBGDebugDirectoryPDBSignature;};
	inline DWORD GetDebugDirectoryPDBFormatSpecifier() { return (m_enumPEImageSymbolStatus == SYMBOLS_PDB) ? m_dwPEImageDebugDirectoryPDBFormatSpecifier: m_dwDBGDebugDirectoryPDBFormatSpecifier;};
	inline GUID * GetDebugDirectoryPDBGuid() { return (m_enumPEImageSymbolStatus == SYMBOLS_PDB) ? &m_guidPEImageDebugDirectoryPDBGuid : &m_guidDBGDebugDirectoryPDBGuid;};

protected:
	enum VerificationLevels {IGNORE_BAD_CHECKSUM, IGNORE_NOTHING};
	enum PEImageType {PEImageTypeUnknown, PE32, PE64};

	DWORD	m_dwCurrentReadPosition;
	DWORD m_dwRefCount;
	
	CFileData * m_lpInputFile;
	CFileData *	m_lpOutputFile;
	CDmpFile * m_lpDmpFile;
	
	// PE Image File Version Information
	bool	m_fPEImageFileVersionInfo;
	LPTSTR	m_tszPEImageFileVersionDescription;
	LPTSTR	m_tszPEImageFileVersionCompanyName;
	
	LPTSTR	m_tszPEImageFileVersionString;
	DWORD	m_dwPEImageFileVersionMS;
	DWORD	m_dwPEImageFileVersionLS;

	LPTSTR	m_tszPEImageProductVersionString;
	DWORD	m_dwPEImageProductVersionMS;
	DWORD	m_dwPEImageProductVersionLS;

	// PE Image Properties
	LPTSTR	m_tszPEImageModuleName;
	LPTSTR	m_tszPEImageModuleFileSystemPath;
	DWORD	m_dwPEImageFileSize;
	FILETIME m_ftPEImageFileTimeDateStamp;
	DWORD	m_dwPEImageCheckSum;
	DWORD	m_dwPEImageTimeDateStamp;
	DWORD	m_dwPEImageSizeOfImage;	// New for SYMSRV support
	PEImageType m_enumPEImageType;	
	DWORD64	m_dw64PreferredLoadAddress;
	DWORD64	m_dw64BaseAddressOfLoadedImage;

	WORD	m_wPEImageMachineArchitecture;
	WORD	m_wCharacteristics;
	
	// PE Image has a reference to DBG file
	SymbolInformationForPEImage m_enumPEImageSymbolStatus;
	LPTSTR	m_tszPEImageDebugDirectoryDBGPath;

	// PE Image has internal symbols
	DWORD	m_dwPEImageDebugDirectoryCoffSize;
	DWORD	m_dwPEImageDebugDirectoryFPOSize;
	DWORD	m_dwPEImageDebugDirectoryCVSize;
	DWORD	m_dwPEImageDebugDirectoryOMAPtoSRCSize;
	DWORD	m_dwPEImageDebugDirectoryOMAPfromSRCSize;
	
	// PE Image has a reference to PDB file...
	LPTSTR	m_tszPEImageDebugDirectoryPDBPath;
	DWORD	m_dwPEImageDebugDirectoryPDBFormatSpecifier;		// NB10, RSDS, etc...
	DWORD	m_dwPEImageDebugDirectoryPDBAge;
	DWORD	m_dwPEImageDebugDirectoryPDBSignature;
	GUID	m_guidPEImageDebugDirectoryPDBGuid;			// Actual GUID in binary form

	// DBG File Information
	SymbolModuleStatus m_enumDBGModuleStatus;
	LPTSTR	m_tszDBGModuleFileSystemPath;									// Actual path
	DWORD	m_dwDBGTimeDateStamp;
	DWORD	m_dwDBGCheckSum;
	DWORD	m_dwDBGSizeOfImage;
	DWORD	m_dwDBGImageDebugDirectoryCoffSize;
	DWORD	m_dwDBGImageDebugDirectoryFPOSize;
	DWORD	m_dwDBGImageDebugDirectoryCVSize;
	DWORD	m_dwDBGImageDebugDirectoryOMAPtoSRCSize;
	DWORD	m_dwDBGImageDebugDirectoryOMAPfromSRCSize;
	
	// DBG File has a reference to a PDB file...
	LPTSTR	m_tszDBGDebugDirectoryPDBPath;
	DWORD	m_dwDBGDebugDirectoryPDBFormatSpecifier;		// NB10, RSDS, etc...
	DWORD	m_dwDBGDebugDirectoryPDBAge;
	DWORD	m_dwDBGDebugDirectoryPDBSignature;
	GUID	m_guidDBGDebugDirectoryPDBGuid;			// Actual GUID in binary form
	
	// PDB File Information
	SymbolModuleStatus m_enumPDBModuleStatus;
	LPTSTR	m_tszPDBModuleFileSystemPath;
	DWORD	m_dwPDBFormatSpecifier;
	DWORD	m_dwPDBSignature;
	DWORD	m_dwPDBAge;
	GUID	m_guidPDBGuid;

	// Source Information
	bool	m_fPDBSourceEnabled;
	bool	m_fPDBSourceEnabledMismatch;

	// Source Information - MSDBI.LIB
	DWORD	m_dwPDBTotalBytesOfLineInformation;
	DWORD	m_dwPDBTotalBytesOfSymbolInformation;
	DWORD	m_dwPDBTotalSymbolTypesRange;

	// Source Information - MSDIA20.DLL
	DWORD	m_dwPDBTotalSourceFiles;

	// Conversion routines...
	LPTSTR SymbolInformationString(enum SymbolInformationForPEImage enumSymbolInformationForPEImage);
	LPTSTR SymbolModuleStatusString(enum SymbolModuleStatus enumModuleStatus);
	SymbolInformationForPEImage SymbolInformation(LPSTR szSymbolInformationString);

	bool DoRead(bool fDmpFile, HANDLE hModuleHandle, LPVOID lpBuffer, DWORD cNumberOfBytesToRead);
	ULONG SetReadPointer(bool fDmpFile, HANDLE hModuleHandle, LONG cbOffset, int iFrom);
	bool GetModuleInfoFromCSVFile(LPTSTR tszModulePath);
	bool GetPEImageInfoFromModule(HANDLE hModuleHandle, const bool fDmpFile);
	bool GetVersionInfoFromModule(HANDLE hModuleHandle, const bool fDmpFile);
	HRESULT VersionQueryValue(const ULONG_PTR lpAddress, const bool fDmpFile, const LPTSTR tszSubBlock, LPVOID * lplpBuffer, unsigned int cbSizeOfBuffer);

	//
	// Output Methods
	//
	bool OutputDataToStdout(DWORD dwModuleNumber);
	bool OutputDataToStdoutThisModule();
	bool OutputDataToStdoutModuleInfo(DWORD dwModuleNumber);
	bool OutputDataToStdoutInternalSymbolInfo(DWORD dwCoffSize, DWORD dwFPOSize, DWORD dwCVSize, DWORD dwOMAPtoSRC, DWORD dwOMAPfromSRC);
	bool OutputDataToStdoutDbgSymbolInfo(LPCTSTR tszModulePointerToDbg, DWORD dwTimeDateStamp, DWORD dwChecksum, DWORD dwSizeOfImage, LPCTSTR tszDbgComment = NULL, DWORD dwExpectedTimeDateStamp = 0, DWORD dwExpectedChecksum = 0, DWORD dwExpectedSizeOfImage = 0);
	bool OutputDataToStdoutPdbSymbolInfo(DWORD dwPDBFormatSpecifier, LPTSTR tszModulePointerToPDB, DWORD dwPDBSignature, GUID * guidPDBGuid, DWORD dwPDBAge, LPCTSTR tszPdbComment = NULL);
	bool OutputDataToFile(LPTSTR tszProcessName, DWORD iProcessID);
	bool OutputFileTime(FILETIME ftFileTime,  LPTSTR tszFileTime, int iFileTimeBufferSize);

	bool fCheckPDBSignature(bool fDmpFile, HANDLE hModuleHandle, OMFSignature *pSig, PDB_INFO *ppdb);

	// Dia protected functions
	HRESULT	diaLocatePdb(LPTSTR  tszPDB, GUID *PdbGUID, DWORD PdbSignature, DWORD PdbAge, LPTSTR tszSymbolPath, LPTSTR tszImageExt, int ip);
	HRESULT diaGetPdbInfo(CComPtr<IDiaDataSource> & pSource, LPTSTR tszPdbPath, GUID *PdbGUIDToMatch, DWORD PdbSignatureToMatch, DWORD PdbAgeToMatch);
	static	HRESULT diaPdbSourceEnabled(CComPtr<IDiaSession> & pSession, bool & fSourceEnabled, DWORD & dwSourceFiles);
	static	HRESULT diaGetDiaDataSource(CComPtr<IDiaDataSource> & pSource);

	// MSDIBLib protected functions
//	EC		dbiLocatePdb(LPTSTR tszPDB, ULONG PdbSignature, ULONG PdbAge, LPTSTR tszSymbolPath, LPTSTR tszImageExt, bool fImagePathPassed);
//	EC		dbiGetPdbInfo(LPTSTR tszPdbPath, DWORD PdbSignatureToMatch, DWORD PdbAgeToMatch);
//	static	bool dbiPdbSourceEnabled(PDB *lpPdb, bool & fPDBSourceEnabled, DWORD & dwPDBTotalBytesOfLineInformation, DWORD & dwPDBTotalBytesOfSymbolInformation, DWORD & dwPDBTotalSymbolTypesRange);

	bool ProcessDebugDirectory(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, unsigned int iDebugDirectorySize, ULONG OffsetImageDebugDirectory);
	bool ProcessDebugTypeCVDirectoryEntry(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessDebugTypeFPODirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessDebugTypeCoffDirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessDebugTypeMiscDirectoryEntry(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessDebugTypeOMAPDirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	

	bool fValidDBGTimeDateStamp();
	bool fValidDBGCheckSum();
	bool fCopyNewPDBInformation(bool fSymbolMatch, bool fSourceEnabled);

	bool GetDBGModuleFileUsingSymbolPath(LPTSTR tszSymbolPath);
	bool GetDBGModuleFileUsingSQLServer();
	bool GetDBGModuleFileUsingSQLServer2();
	bool GetPDBModuleFileUsingSymbolPath(LPTSTR tszSymbolPath);
	bool GetPDBModuleFileUsingSQLServer2();
};

#endif // !defined(AFX_MODULEINFO_H__0D2E8509_A01A_11D2_83A8_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\pch.cpp ===
// PCH.CPP
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\pch.h ===
// PCH.H
// Pre-compiled header file!
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

// Provide these for everyone!
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "Globals.h"
#include "UtilityFunctions.h"
#include "ProgramOptions.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\processes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processes.h
//
//--------------------------------------------------------------------------

// Processes.h: interface for the CProcesses class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROCESSES_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_)
#define AFX_PROCESSES_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include "globals.h"

//#include "ProgramOptions.h"

// Forward Declarations
//class CProgramOptions;
class CProcessInfo;
class CProcessInfoNode;
class CFileData;
class CModuleInfoCache;

class CProcesses  
{
public:
	CProcesses();
	virtual ~CProcesses();

	bool Initialize(CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile); 

//	bool OutputProcessesData(LPCTSTR tszOutputContext, bool fDumpHeader = true);
	bool OutputProcessesData(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader = true);
	bool GetProcessesData();
	
	// Public functions for exporting functions in dynamically loaded DLLs...
	enum ProcessCollectionMethod { NO_METHOD, TOOLHELP32_METHOD, PSAPI_METHOD };
	inline ProcessCollectionMethod GetProcessCollectionMethod() { return m_enumProcessCollectionMethod;};

	inline long GetNumberOfProcesses() {
		return m_iNumberOfProcesses; 
	};

protected:
	bool GetProcessesDataFromFile();
	bool GetProcessesDataForRunningProcessesUsingTOOLHELP32();
	bool GetProcessesDataForRunningProcessesUsingPSAPI();
	bool OutputProcessesDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader = true);
	bool OutputProcessesDataToFile(CollectionTypes enumCollectionType, bool fDumpHeader = true);

	CFileData * m_lpOutputFile;
	CFileData * m_lpInputFile;
	CModuleInfoCache * m_lpModuleInfoCache;
	CProcessInfoNode * m_lpProcessInfoHead;

	HANDLE m_ProcessInfoHeadMutex;

	long m_iNumberOfProcesses;
	bool m_fInitialized; // We need to ensure initialization since a mutex is involved...

	// Protected Methods
	bool AddNewProcessInfoObject(CProcessInfo * lpProcessInfo);
	bool SetPrivilege(HANDLE hToken, LPCTSTR Privilege, bool bEnablePrivilege);

	ProcessCollectionMethod m_enumProcessCollectionMethod;

	static bool fPidAlreadyProvided(unsigned int iPid);
};

#endif // !defined(AFX_PROCESSES_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\processinfonode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processinfonode.cpp
//
//--------------------------------------------------------------------------

// ProcessInfoNode.cpp: implementation of the CProcessInfoNode class.
//
//////////////////////////////////////////////////////////////////////

#include "ProcessInfoNode.h"
#include "ProcessInfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProcessInfoNode::CProcessInfoNode(CProcessInfo * lpProcessInfo)
{
	// Save the Process Info object in our node...
	m_lpProcessInfo = lpProcessInfo;
	m_lpNextProcessInfoNode = NULL;
}

CProcessInfoNode::~CProcessInfoNode()
{
	//  Cleanup our process info object if necessary...
	if (m_lpProcessInfo)
		delete m_lpProcessInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\processinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processinfo.cpp
//
//--------------------------------------------------------------------------

// ProcessInfo.cpp: implementation of the CProcessInfo class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include "DelayLoad.h"
#include "ProcessInfo.h"
#include "ProcessInfoNode.h"
#include "Processes.h"
#include "ModuleInfo.h"
#include "ModuleInfoNode.h"
#include "ModuleInfoCache.h"
#include "FileData.h"
#include "DmpFile.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProcessInfo::CProcessInfo()
{
	m_fInitialized = false;
	m_tszProcessName= NULL;
	m_iProcessID = 0;
	m_lpModuleInfoHead = NULL;
	m_hModuleInfoHeadMutex = NULL;
	m_iNumberOfModules = 0;
	m_lpInputFile = NULL;
	m_lpOutputFile = NULL;
	m_lpModuleInfoCache = NULL;
	m_hModuleInfoHeadMutex = NULL;
	m_lpDmpFile = NULL;
}

CProcessInfo::~CProcessInfo()
{
	if (m_tszProcessName)
		delete [] m_tszProcessName;

	WaitForSingleObject(m_hModuleInfoHeadMutex, INFINITE);

	// If we have Module Info Objects... nuke them now...
	if (m_lpModuleInfoHead)
	{

		CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoHead;
		CModuleInfoNode * lpModuleInfoNodePointerToDelete = m_lpModuleInfoHead;

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer)
		{	// Keep looking for the end...
			// Advance our pointer to the next node...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
			
			// Delete the one behind us...
			delete lpModuleInfoNodePointerToDelete;

			// Set the node to delete to the current...
			lpModuleInfoNodePointerToDelete = lpModuleInfoNodePointer;
		}
			
		// Now, clear out the Head pointer...
		m_lpModuleInfoHead = NULL;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoHeadMutex);

	// Now, close the Mutex
	if (m_hModuleInfoHeadMutex)
	{
		CloseHandle(m_hModuleInfoHeadMutex);
		m_hModuleInfoHeadMutex = NULL;
	}

}

//bool CProcessInfo::Initialize(CProgramOptions *lpProgramOptions, CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile)
bool CProcessInfo::Initialize(CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile)
{
	if (lpModuleInfoCache == NULL)
		return false;

	// Let's save off big objects so we don't have to keep passing this to
	// our methods...
	m_lpInputFile = lpInputFile;
	m_lpOutputFile = lpOutputFile;
	m_lpModuleInfoCache = lpModuleInfoCache;
	m_lpDmpFile = lpDmpFile;
	m_hModuleInfoHeadMutex = CreateMutex(NULL, FALSE, NULL);

	if (m_hModuleInfoHeadMutex == NULL)
		return false;

	m_fInitialized = true;
	return true;
}

bool CProcessInfo::EnumerateModules(DWORD iProcessID, CProcesses * lpProcesses, LPTSTR tszProcessName, bool fPidSearch)
{
	bool fReturn = true;

	// Is this being collected interactively?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode))
	{
		// Invoke the correct Process Collection Method
		if (lpProcesses->GetProcessCollectionMethod() == CProcesses::TOOLHELP32_METHOD)
		{
			fReturn = EnumerateModulesForRunningProcessUsingTOOLHELP32(iProcessID, tszProcessName, fPidSearch); 
		}
		else if (lpProcesses->GetProcessCollectionMethod() == CProcesses::PSAPI_METHOD)
		{
			fReturn = EnumerateModulesForRunningProcessUsingPSAPI(iProcessID, fPidSearch);
		}
	}

	// Is this being collected from a file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
	{
		fReturn = EnumerateModulesFromFile(iProcessID, tszProcessName);
	}

	return fReturn;
}

bool CProcessInfo::EnumerateModulesForRunningProcessUsingPSAPI(DWORD iProcessID, bool fPidSearch)
{
	HMODULE        hMod[1024] ;
	HANDLE         hProcess = NULL;
	TCHAR          tszFileName[_MAX_PATH] ;
	DWORD cbNeeded;
	bool fReturn = true; // Optimisim ;)
	tszFileName[0] = 0 ;
	CModuleInfo * lpModuleInfo = NULL;
	MODULEINFO ModuleInfo;
	
	// Open the process (if we can... security does not
	// permit every process in the system).

	if (iProcessID)
	{
		// Only try to open a Process ID if it's not 0
		hProcess = OpenProcess(
			PROCESS_QUERY_INFORMATION| PROCESS_VM_READ,
			FALSE, 
			iProcessID ) ;
	}
	
	if( hProcess != NULL )
	{
		// Save off our PID (in case we need it later?)
		m_iProcessID = iProcessID;

		// Now, get a handle to each of the modules
		// in our target process...

		// Here we call EnumProcessModules to get only the
		// first module in the process this is important,
		// because this will be the .EXE module for which we
		// will retrieve the full path name in a second.
		if( g_lpDelayLoad->EnumProcessModules( hProcess, hMod, sizeof( hMod ), &cbNeeded ) )
		{
			int iNumberOfModules = cbNeeded / sizeof(HMODULE);
			bool fProcessNameFound = false;
			bool fNew = false;
			
			for(int i=0; i<iNumberOfModules; i++)
			{
				// Get Full pathname!
				if( !g_lpDelayLoad->GetModuleFileNameEx( hProcess, hMod[i], tszFileName, sizeof( tszFileName ) ) )
				{
					tszFileName[0] = 0 ;
				} else	{

					CUtilityFunctions::UnMungePathIfNecessary(tszFileName);

					// We need a full path to the module to do anything useful with it...
					// At this point, let's ... party...
					if (!fProcessNameFound)
						fProcessNameFound = fIsProcessName(tszFileName);
					
					// First, if we were provided a Process name on the commandline, we
					// need to look for a match on the 1st module...
					if (i == 0  && g_lpProgramOptions->cProcessNames() && !fPidSearch)
					{
						if (!fModuleNameMatches(tszFileName))
						{
							// Bail if this is not a match, and we requested one...
							fReturn = false;
							goto cleanup;
						}
					}

					// Are we ONLY interested in the process list?  
					if (g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode))
					{	
						// All we want is process name.. bail before collecting module info...
						fReturn = true;
						goto cleanup;
					}

					// If "-MATCH" was specified, look to see if this filename meets our criteria
					// before we save this away in our module cache...
					if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszFileName))
						continue;

					// Okay, let's go ahead and get a ModuleInfo Object from our cache...
					// If pfNew returns TRUE, then this object is new and we'll need
					// to populate it with data...
					lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszFileName, &fNew);

					if (false == fNew)
					{
						// We may have the object in the cache... now we need to
						// save a pointer to this object in our Process Info list
						AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
						continue; // We save having to get the module info again for this module...
					}

					// Not in the cache... so we need to init it, and get the module info...

					// Okay, let's create a ModuleInfo object and pass this down
					// routines that will populate it full of data...
					if (!lpModuleInfo->Initialize(NULL, m_lpOutputFile, NULL))
					{
						continue; // Hmmm... memory error?
					}

					//
					// Let's collect this information...
					//
					if( !g_lpDelayLoad->GetModuleInformation(hProcess, hMod[i], &ModuleInfo, sizeof(ModuleInfo) ) )
					{
						continue;
					}

					// Let's do it!! Populate the ModuleInfo object with data!!!!
					if (!lpModuleInfo->GetModuleInfo(tszFileName, false, (DWORD64)ModuleInfo.lpBaseOfDll))
					{
						// Well, for now we've at least got the path to the module...
						// Go ahead and get another module..
						// Let's go ahead and add this to the ModuleInfoObject as well... even if we're "not successful"
						// continue;
					}

					// Start obtaining information about the modules...

					// We may have the object in the cache... now we need to
					// save a pointer to this object in our Process Info list
					if (!AddNewModuleInfoObject(lpModuleInfo))
					{   // Failure adding the node.... This is pretty serious...
						continue;
					}

				}
			}
			
			fReturn = true;	// Looks good...
		}
		else
		{
			fReturn = false;

			if (!g_lpProgramOptions->cProcessNames())
			{
				// Let's not be so hasty... we couldn't enum modules, but to be friendly we can probably put a name
				// to the Process (based on the Process ID)...
				//
				// This Process ID tends to be "System"
				//
				// On Windows 2000, the Process ID tends to be 8
				//
				// On Windows NT 4.0, this Process ID tends to be 2
				switch (m_iProcessID)
				{
					case 2:
					case 8:
						SetProcessName(TEXT("SYSTEM"));
						fReturn = true;
						break;

					default:
						// Couldn't enumerate modules...
						fReturn = false;
				}
			}
		}
cleanup:
		CloseHandle( hProcess ) ;
	
	} else
	{  // Gotta be able to open the process to look at it...

		fReturn = false;

		if (fPidSearch)
		{
			// Let's not be so hasty... we couldn't enum modules, but to be friendly we can probably put a name
			// to the Process (based on the Process ID)...
			//
			// On Windows 2000, the only Process ID we can't open at all tends to be the "System Idle Process"
			switch (iProcessID)
			{
				case 0:
					SetProcessName(TEXT("System Process"));
					m_iProcessID = iProcessID;

					fReturn = true;
					break;

				default:
					// Couldn't enumerate modules...
					fReturn = false;
			}
		}
	}

	return fReturn;
}

bool CProcessInfo::EnumerateModulesForRunningProcessUsingTOOLHELP32(DWORD iProcessID, LPTSTR tszProcessName, bool fPidSearch)
{
	BOOL bFlag;
	MODULEENTRY32 modentry;
	TCHAR tszFileName[_MAX_PATH];
	bool fProcessNameFound = false;
	bool fProcessNameProvided = false;
	bool fReturn = false;
	bool fNew = false;
	int iNumberOfModules = 0;
	HANDLE hSnapShot = INVALID_HANDLE_VALUE;
	CModuleInfo * lpModuleInfo = NULL;

	// Save off our PID (in case we need it later?)
	m_iProcessID = iProcessID;

	if (tszProcessName && SetProcessName(tszProcessName))
	{	
		fProcessNameProvided = true;
	}

	// If we were provided a process name to match, we can do it here...
	if ( fProcessNameProvided && g_lpProgramOptions->cProcessNames() && !fPidSearch)
	{
		// Let's go ahead and look to see if this is a module name match
		fProcessNameFound = fModuleNameMatches(GetProcessName());

		// Quit now if we can...
		if (fProcessNameFound == false)
			goto cleanup;
	}

	// If we're doing this for TLIST output... then we already have the process name...
	// We're done!
	if (g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode))
	{
		fReturn = true;
		goto cleanup;
	}

	// Get a handle to a Toolhelp snapshot of the systems processes.
    hSnapShot = g_lpDelayLoad->CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, iProcessID);

    if( hSnapShot == INVALID_HANDLE_VALUE )
    {
		goto cleanup;
	}

	// Get the first process' information.
	modentry.dwSize = sizeof(MODULEENTRY32) ;
	bFlag = g_lpDelayLoad->Module32First( hSnapShot, &modentry ) ;

	// While there are modules, keep looping.
	while( bFlag )
	{
		// We have a new module for this process!
		iNumberOfModules++;

		// Copy the path!
		_tcscpy(tszFileName, modentry.szExePath);

//#ifdef _DEBUG
//		_tprintf(TEXT("[%d] Module = %s\n"), iNumberOfModules, tszFileName);
//#endif

		CUtilityFunctions::UnMungePathIfNecessary(tszFileName);

		// If "-MATCH" was specified, look to see if this filename meets our criteria
		// before we save this away in our module cache...
		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszFileName))
			goto getnextmodule;
		
		// Okay, let's go ahead and get a ModuleInfo Object from our cache...
		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszFileName, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...

			// We save having to get the module info again for this module...
			goto getnextmodule;
		}

		// Not in the cache... so we need to init it, and get the module info...

		// Okay, let's create a ModuleInfo object and pass this down
		// routines that will populate it full of data...
		if (lpModuleInfo->Initialize(NULL, m_lpOutputFile, NULL))
		{
			goto getnextmodule;
		}

		// Let's do it!! Populate the ModuleInfo object with data!!!!
		if (lpModuleInfo->GetModuleInfo(tszFileName, false, DWORD64(modentry.modBaseAddr)))
		{
			// Let's go ahead and add this to the ModuleInfoObject as well... even if we're "not successful"
		}

		// Start obtaining information about the modules...

		// We may have the object in the cache... now we need to
		// save a pointer to this object in our Process Info list
		if (AddNewModuleInfoObject(lpModuleInfo))
		{   
			goto getnextmodule;
		}
	
getnextmodule:
		// Get the next Module...
		modentry.dwSize = sizeof(MODULEENTRY32) ;
		bFlag = g_lpDelayLoad->Module32Next( hSnapShot, &modentry );
	}

	fReturn = true;
	
cleanup:
	if (hSnapShot != INVALID_HANDLE_VALUE)
		CloseHandle(hSnapShot);

return fReturn;
}

bool CProcessInfo::EnumerateModulesFromFile(DWORD iProcessID, LPTSTR tszProcessName)
{
	CModuleInfo * lpModuleInfo;

	// I need these near the end when I probe to see if the next module
	// is for this process...
	enum { BUFFER_SIZE = 128};
	char szTempProcessName[BUFFER_SIZE];
	char szProcessName[BUFFER_SIZE];
	DWORD iTempProcessID;

	// Let's save away the Process Name...

	// Unfortunately, when reading from the CSV file, the data is MBCS... so I need
	// to convert...
	CUtilityFunctions::CopyTSTRStringToAnsi(tszProcessName, szProcessName, BUFFER_SIZE);

	// Copy the Process ID
	m_iProcessID = iProcessID;

	// Local buffer for reading data...
	char szModulePath[_MAX_PATH+1];
	TCHAR tszModulePath[_MAX_PATH+1];
	bool fDone = false;
	bool fNew = false;

	while (!fDone)
	{
		// Read in the Module Path
		if (!m_lpInputFile->ReadString(szModulePath, _MAX_PATH+1))
			return true;

		CUtilityFunctions::CopyAnsiStringToTSTR(szModulePath, tszModulePath, _MAX_PATH+1);

		// If "-MATCH" was specified, look to see if this filename meets our criteria
		// before we save this away in our module cache...
		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszModulePath))
		{
			// Okay... read to the start of the next line...
			if (!m_lpInputFile->ReadFileLine())
				goto cleanup;

			goto probe_line; // We save having to get the module info again for this module...
		}

		// Okay, let's go ahead and get a ModuleInfo Object from our cache...
		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszModulePath, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...

			// Okay... read to the start of the next line...
			if (!m_lpInputFile->ReadFileLine())
				goto cleanup;

			goto probe_line; // We save having to get the module info again for this module...
		}

		// Not in the cache... so we need to init it, and get the module info...
		if (!lpModuleInfo->Initialize(m_lpInputFile, m_lpOutputFile, NULL))
		{
			return false; // Hmmm... memory error?
		}

		// Let's do it!! Populate the ModuleInfo object with data!!!!
		if (!lpModuleInfo->GetModuleInfo(tszModulePath, false, 0, true) )
		{
			// Well, we tried and failed... 
			return false;
		}

		// Start obtaining information about the modules...
		if (!AddNewModuleInfoObject(lpModuleInfo))
		{   // Failure adding the node.... This is pretty serious...
			return false;
		}
		
		// Okay, let's go ahead and probe to see what's coming...

probe_line:
		// Read the first field (should be blank, unless this is a new collection type
		if (m_lpInputFile->ReadString())
			goto cleanup;

		// Read the Process Name...
		if (!m_lpInputFile->ReadString(szTempProcessName, BUFFER_SIZE))
			goto cleanup;

		// Compare the process name to the current process...
		if (_stricmp(szTempProcessName, szProcessName))
			goto cleanup;

		// Read the Process ID
		if (!m_lpInputFile->ReadDWORD(&iTempProcessID))
			goto cleanup;

		// Compare the process ID to the current process ID
		if (iTempProcessID != iProcessID)
			goto cleanup;
	}

cleanup:
	// We need to reset out pointer so the functions above us can re-read
	// them (they expect to)...
	m_lpInputFile->ResetBufferPointerToStart();
	return true;
}

//
// Check the provided module against our list of modules
//
bool CProcessInfo::fModuleNameMatches(LPTSTR tszModulePath)
{
	TCHAR fname1[_MAX_FNAME], fname2[_MAX_FNAME];
	TCHAR ext1[_MAX_EXT], ext2[_MAX_EXT];
	unsigned int i;

	bool fReturnValue = false;

	if (!tszModulePath || !g_lpProgramOptions->cProcessNames())
		goto cleanup;

	_tsplitpath( tszModulePath,  NULL, NULL, fname2, ext2 );

	for (i = 0; i < g_lpProgramOptions->cProcessNames(); i++)
	{

// #ifdef _DEBUG
//	_tprintf(TEXT("Comparing [%s] to [%s]\n"), tszModulePath, g_lpProgramOptions->GetProcessName(i)); 
// #endif
		_tsplitpath( g_lpProgramOptions->GetProcessName(i), NULL, NULL, fname1, ext1 );

		// Check for a match in the extensions...
		if (!ext1 && _tcsicmp(ext1, ext2))
			continue; // Extensions must match (if provided on process name)
		
		if (_tcsicmp(fname1, fname2))
			continue; // Filename must match

		fReturnValue = true;
		break;
	}

cleanup:

	return fReturnValue;
}

//
// This function takes a provided tszFileName, and looks to see if it has an
// extension of EXE.  If it does, it's saved off...
bool CProcessInfo::fIsProcessName(LPTSTR tszFileName)
{
	if (!tszFileName)
		return false;

	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];

	_tsplitpath( tszFileName,  NULL, NULL, fname, ext );

	// Executibles		(*.EXE)
	// Screen-savers	(*.SCR)
	if (!ext || (!_tcsicmp(ext, TEXT(".EXE")) && !_tcsicmp(ext, TEXT(".SCR"))))
		return false; // Extensions must match (if provided on process name)
	
	// Let's save off the process name...
	m_tszProcessName = new TCHAR[_tcsclen(fname)+_tcsclen(ext)+1]; 

	if (m_tszProcessName == NULL)
		return false;

	_stprintf(m_tszProcessName, TEXT("%s%s"), _tcsupr(fname), _tcsupr(ext));

	// Yup! It's the Process Name...
	return true;
}

bool CProcessInfo::AddNewModuleInfoObject(CModuleInfo *lpModuleInfo)
{
	if (!m_fInitialized)
	return false;

	// First, create a ModuleInfoNode object and then attach it to the bottom of the
	// linked list of nodes...
	CModuleInfoNode * lpModuleInfoNode = new CModuleInfoNode(lpModuleInfo);

	if (lpModuleInfoNode == NULL)
		return false; // Couldn't allocate memory..

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoHeadMutex, INFINITE);

	CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoHead;

	if (lpModuleInfoNodePointer) {

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer->m_lpNextModuleInfoNode)
		{	// Keep looking for the end...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
		}
		
		lpModuleInfoNodePointer->m_lpNextModuleInfoNode = lpModuleInfoNode;

	}
	else
	{ // First time through, the Process Info Head pointer is null...
		m_lpModuleInfoHead = lpModuleInfoNode;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoHeadMutex);

	InterlockedIncrement(&m_iNumberOfModules);

	return true;
}

bool CProcessInfo::OutputProcessData(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader)
{
	if (g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode))
	{	
		if ( g_lpProgramOptions->IsRunningWindowsNT() )
		{
			// Provide TLIST like output (though no window text info)
			_tprintf(TEXT("%4d %s\n"), m_iProcessID, m_tszProcessName);
		} else
		{
			// Provide TLIST like output (though no window text info)
			_tprintf(TEXT("%9d %s\n"), m_iProcessID, m_tszProcessName);
		}
		return true;
	}

	// Output to STDOUT?
	if ( !g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) )
	{
		// Output to Stdout?
		if (!OutputProcessDataToStdout(enumCollectionType, fCSVFileContext, fDumpHeader))
			return false;
	}	

	if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
	{
		CUtilityFunctions::OutputLineOfDashes();
		// Output to STDOUT
		_tprintf(TEXT("\nProcess Name [%s] - PID=%d (0x%x) - "), m_tszProcessName, m_iProcessID, m_iProcessID);
	}

	// Output to file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Try and output to file...
		if (!OutputProcessDataToFile(enumCollectionType, fDumpHeader))
			return false;
	}	

	if (m_lpModuleInfoHead) {
		if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
		{
			_tprintf(TEXT("%d modules recorded\n\n"), m_iNumberOfModules);
			CUtilityFunctions::OutputLineOfDashes();
			_tprintf(TEXT("\n"));
		}

		CModuleInfoNode * lpCurrentModuleInfoNode = m_lpModuleInfoHead;

		unsigned int dwModuleNumber = 1;

		while (lpCurrentModuleInfoNode)
		{
			// We have a node... print out Module Info for it...
			if (lpCurrentModuleInfoNode->m_lpModuleInfo)
			{
				lpCurrentModuleInfoNode->m_lpModuleInfo->OutputData(m_tszProcessName, m_iProcessID, dwModuleNumber);
				dwModuleNumber++;
			}

			lpCurrentModuleInfoNode = lpCurrentModuleInfoNode->m_lpNextModuleInfoNode;
		}

	}
	else
	{
		if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) /*&& fDumpHeader */)
		{
			_tprintf(TEXT("no recorded modules\n\n"));
			CUtilityFunctions::OutputLineOfDashes();
			_tprintf(TEXT("\n"));
		}
	}
		
	return true;
}

//bool CProcessInfo::OutputProcessDataToStdout(LPCTSTR tszOutputContext, bool fDumpHeader)
bool CProcessInfo::OutputProcessDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader)
{
	if (fDumpHeader)
	{
		CUtilityFunctions::OutputLineOfStars();
		_tprintf(TEXT("%s - Printing Process Information for 1 Process.\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel);
		_tprintf(TEXT("%s - Context: %s\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, fCSVFileContext ? g_tszCollectionArray[enumCollectionType].tszCSVContext : g_tszCollectionArray[enumCollectionType].tszLocalContext);
		CUtilityFunctions::OutputLineOfStars();
	}

	return true;
}

bool CProcessInfo::OutputProcessDataToFile(CollectionTypes enumCollectionType, bool fDumpHeader)
{
	// We skip output of the [processes ]header if -E was specified...
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode) && fDumpHeader)
	{
		// Write out the Process tag so I can detect this output format...
		if (!m_lpOutputFile->WriteString(TEXT("\r\n")) ||
			!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVLabel) ||
			!m_lpOutputFile->WriteString(TEXT("\r\n"))
		   )
		{
			_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
			m_lpOutputFile->PrintLastError();
			return false;
		}
	}

	// We skip output of the [processes ]header if -E was specified...
	if (g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode) && fDumpHeader)
	{
		// Write out the header... for the -E option...
		if (!m_lpOutputFile->WriteString(TEXT("Module Path,Symbol Status,Time/Date String,File Version,Company Name,File Description,File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n")))
		{
			_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
			m_lpOutputFile->PrintLastError();
			return false;
		}

	} else
	{
		if (fDumpHeader)
		{
			// Write out the Process Header
			if (!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVColumnHeaders))
			{
				_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
				m_lpOutputFile->PrintLastError();
				return false;
			}
		}
	}

	return true;
}

bool CProcessInfo::SetProcessName(LPTSTR tszFileName)
{
	// Confirm we were given a process name...
	if (!tszFileName)
		return false;

	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];
	TCHAR tszTempFileName[_MAX_FNAME+_MAX_EXT+1];

	// Let's extract the filename from the module path
	_tsplitpath( tszFileName,  NULL, NULL, fname, ext );

	// Reconstruct the filename...
	_stprintf(tszTempFileName, TEXT("%s%s"), _tcsupr(fname), _tcsupr(ext));

	// Let's free anything that's already here...
	if (m_tszProcessName)
		delete [] m_tszProcessName;

	// No conversion necessary... copy over...
	m_tszProcessName = new TCHAR[_tcslen(tszTempFileName)+1];
				
	if (!m_tszProcessName)
		return false;

	_tcscpy(m_tszProcessName, tszTempFileName);

	return true;
}

LPTSTR CProcessInfo::GetProcessName()
{
	return m_tszProcessName;
}

bool CProcessInfo::GetProcessData()
{
	// Is this being collected from a file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
		GetProcessDataFromFile();

	return true;
}

bool CProcessInfo::GetProcessDataFromFile()
{
	// Read the Process Header Line
	if (!m_lpInputFile->ReadFileLine())
		return false;

	// Currently, we don't actually read the data...

	enum { BUFFER_SIZE = 128};
	char szProcessName[BUFFER_SIZE];

	TCHAR tszProcessName[BUFFER_SIZE];	

	DWORD iProcessID;

	// Read the first field (should be blank, unless this is a new collection type
	if (m_lpInputFile->ReadString())
		return true;

	bool fReturn = true;
	while (fReturn == true)
	{
		// Read the process name...
		if (0 == m_lpInputFile->ReadString(szProcessName, BUFFER_SIZE))
			break;

		if (!m_lpInputFile->ReadDWORD(&iProcessID))
		{
			fReturn = false;
			break;
		}

		// We need to convert this to Unicode possibly... (it will be copied in EnumModules())
		CUtilityFunctions::CopyAnsiStringToTSTR(szProcessName, tszProcessName, BUFFER_SIZE);

		// Save the process name...
		SetProcessName(tszProcessName);

		// Enumerate the modules for the process
		if (!EnumerateModules(iProcessID, NULL, tszProcessName, false))
		{
			fReturn = false;
			break;
		}

		// Before we read a new line... are we already pointing to the end?
		if (m_lpInputFile->EndOfFile())
		{
			break;
		}

		// Read the first field (should be blank, unless this is a new collection type
		if (m_lpInputFile->ReadString())
			break;
	}
	// We don't expect to find anything...

	return fReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\processinfonode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processinfonode.h
//
//--------------------------------------------------------------------------

// ProcessInfoNode.h: interface for the CProcessInfoNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROCESSINFONODE_H__0D2E8503_A01A_11D2_83A8_000000000000__INCLUDED_)
#define AFX_PROCESSINFONODE_H__0D2E8503_A01A_11D2_83A8_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>

class CProcessInfo;	// Forward Declarations

class CProcessInfoNode  
{
public:
	CProcessInfoNode(CProcessInfo * lpProcessInfo);
	virtual ~CProcessInfoNode();

	CProcessInfoNode * m_lpNextProcessInfoNode;
	CProcessInfo * m_lpProcessInfo;

};

#endif // !defined(AFX_PROCESSINFONODE_H__0D2E8503_A01A_11D2_83A8_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\processes.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processes.cpp
//
//--------------------------------------------------------------------------

// Processes.cpp: implementation of the CProcesses class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include <stdlib.h>

#include "DelayLoad.h"
#include "Processes.h"
#include "ProcessInfo.h"
#include "ProcessInfoNode.h"
#include "FileData.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProcesses::CProcesses()
{
	m_fInitialized = false;
	m_iNumberOfProcesses = 0;

	m_enumProcessCollectionMethod = NO_METHOD;

	// Contained Objects
	m_lpProcessInfoHead = NULL;
	m_ProcessInfoHeadMutex = NULL;
//	m_lpProgramOptions = NULL;
	m_lpModuleInfoCache = NULL;
	m_lpOutputFile = NULL;
	m_lpInputFile = NULL;
}

CProcesses::~CProcesses()
{
	WaitForSingleObject(m_ProcessInfoHeadMutex, INFINITE);

	// If we have Process Info Objects... nuke them now...
	if (m_lpProcessInfoHead)
	{

		CProcessInfoNode * lpProcessInfoNodePointer = m_lpProcessInfoHead;
		CProcessInfoNode * lpProcessInfoNodePointerToDelete = m_lpProcessInfoHead;

		// Traverse the linked list to the end..
		while (lpProcessInfoNodePointer)
		{	// Keep looking for the end...
			// Advance our pointer to the next node...
			lpProcessInfoNodePointer = lpProcessInfoNodePointer->m_lpNextProcessInfoNode;
			
			// Delete the one behind us...
			delete lpProcessInfoNodePointerToDelete;

			// Set the node to delete to the current...
			lpProcessInfoNodePointerToDelete = lpProcessInfoNodePointer;
		}
			
		// Now, clear out the Head pointer...

		m_lpProcessInfoHead = NULL;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_ProcessInfoHeadMutex);

	// Now, close the Mutex
	if (m_ProcessInfoHeadMutex)
	{
		CloseHandle(m_ProcessInfoHeadMutex);
		m_ProcessInfoHeadMutex = NULL;
	}
}

//bool CProcesses::Initialize(CProgramOptions * lpProgramOptions, CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile)
bool CProcesses::Initialize(CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile)
{
	// We need the following objects to do business...
//	if ( lpProgramOptions == NULL || lpModuleInfoCache == NULL)
	if ( lpModuleInfoCache == NULL)
		return false;

	// Let's save away our program options (beats passing it as an
	// argument to every method...)
//	m_lpProgramOptions = lpProgramOptions;
	m_lpInputFile = lpInputFile;
	m_lpOutputFile = lpOutputFile;
	m_lpModuleInfoCache = lpModuleInfoCache;

	m_ProcessInfoHeadMutex = CreateMutex(NULL, FALSE, NULL);

	if (m_ProcessInfoHeadMutex == NULL)
		return false;

	// We only need to grab these exported functions if we intend to
	// actively query our local machine's processes directly...
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode))
	{
		// PSAPI.DLL API's ARE NOW PREFERRED!!
		// It doesn't tend to hang when enumerating modules for a process that is being debugged.
		// The Toolhelp32 APIs seem to hang occasionally taking a snapshot of a process being debugged
		// and this impacts Exception Monitor (which runs from a script against a process under
		// windbg)

		if ( g_lpProgramOptions->IsRunningWindowsNT() )
		{
			// Get the functions for Windows NT 4.0/2000

			// Load library and get the procedures explicitly. We do
			// this so that we don't have to worry about modules using
			// this code failing to load under Windows 95, because
			// it can't resolve references to the PSAPI.DLL.

			if (g_lpDelayLoad->Initialize_PSAPI())
			{
				m_enumProcessCollectionMethod = PSAPI_METHOD;
			} else
			{
				_tprintf(TEXT("Unable to load PSAPI.DLL, which may be required for enumeration of processes.\n"));
			}
		}

		if ( m_enumProcessCollectionMethod == NO_METHOD )
		{
			if (g_lpDelayLoad->Initialize_TOOLHELP32())
			{
				m_enumProcessCollectionMethod = TOOLHELP32_METHOD;
			} else
			{
				_tprintf(TEXT("KERNEL32.DLL is missing required function entry points!!\n"));
			}

		}

		// On Windows NT, we need to enable SeDebugPrivilege to open some processes...
		if ( ( m_enumProcessCollectionMethod != NO_METHOD ) &&
			   g_lpProgramOptions->IsRunningWindowsNT() )
		{
			HANDLE		hOurProcessToken = 0;
			bool		fPrivilegeSet = false;
			
			// To permit as much access to obtain a process handle as possible,
			// we need to set the SeDebugPrivilege on our process handle, we can
			// then open nearly any process...

			if(OpenProcessToken(	GetCurrentProcess(),
									TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,            
									&hOurProcessToken))
			{
				// We got our Process Token...

	 			if(SetPrivilege(hOurProcessToken, SE_DEBUG_NAME, TRUE))    
				{
					fPrivilegeSet = true;
				}
			}
			
			if (!fPrivilegeSet)
			{
				_tprintf(TEXT("\nWARNING: A required privilege (SeDebugPrivilege) is not held by the user\n"));
				_tprintf(TEXT("running this program.  Due to security, some processes running on this\n"));
				_tprintf(TEXT("system may not be accessible.  An administrator of this machine can grant\n"));
				_tprintf(TEXT("you this privilege by using User Manager to enable the advanced User Right\n"));
				_tprintf(TEXT("\"Debug Programs\" to enable complete access to this system.\n"));
			}

			if (hOurProcessToken)
				CloseHandle(hOurProcessToken);
		}

		// We are initialized if we were able to enable a Process Collection Method
		m_fInitialized = ( m_enumProcessCollectionMethod != NO_METHOD );

	} else
	{
		m_fInitialized = true;
	}

	
	return m_fInitialized;
}

bool CProcesses::SetPrivilege(HANDLE hToken, LPCTSTR Privilege, bool bEnablePrivilege)
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious = {0};
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return false;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return false;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return false;

    return true;
}


bool CProcesses::GetProcessesData()
{
	// Is this being collected interactively?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode))
	{
		// Invoke the correct Process Collection Method
		if (GetProcessCollectionMethod() == TOOLHELP32_METHOD)
		{
			GetProcessesDataForRunningProcessesUsingTOOLHELP32();
		}
		else if (GetProcessCollectionMethod() == PSAPI_METHOD)
		{
			GetProcessesDataForRunningProcessesUsingPSAPI();
		}
	}

	// Is this being collected from a file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
		GetProcessesDataFromFile();

	return true;
}

bool CProcesses::GetProcessesDataForRunningProcessesUsingPSAPI()
{
	LPDWORD        lpdwPIDs = NULL;
	DWORD          dwProcessIDHeapSizeUsed, dwProcessIDHeapSize, dwIndex ;
	CProcessInfo * lpProcessInfo = NULL;
	bool fRetval = false;

	if (!m_fInitialized)
		return false;

	// If there are any PIDs provided, query for these first...
	if (g_lpProgramOptions->cProcessID())
	{
		for (unsigned int i=0; i < g_lpProgramOptions->cProcessID(); i++)
		{
			// It's possible the user provided a PID directly... if so,
			// we can circumvent the whole search of PIDs on the system...

			// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()
			lpProcessInfo = new CProcessInfo();
			if (lpProcessInfo == NULL)
				goto error_cleanup;

			if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, NULL, m_lpOutputFile, NULL))
			{
				goto error_cleanup;
			}

			if (lpProcessInfo->EnumerateModules(g_lpProgramOptions->GetProcessID(i), this, NULL, true))
			{
				// Success... add this to the Processes Object...
				if (!AddNewProcessInfoObject(lpProcessInfo))
				{ // Failure adding the node...
					goto error_cleanup; // For now, let's just error on out...
				}

			} else
			{
				// Failure enumerating modules on a PID of interest... very bad... try a new one...
				continue;
			}
		}
	}

	// Do we have a wild-card or process match search to make?  If either are true,
	// we must enumerate all the procesess
	if ( g_lpProgramOptions->cProcessNames() || 
		 g_lpProgramOptions->fWildCardMatch() ||
		 g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode) )
	{
		// Nope, we brute force this baby...

		// Call the PSAPI function EnumProcesses to get all of the
		// ProcID's currently in the system.

		// NOTE: In the documentation, the third parameter of
		// EnumProcesses is named cbNeeded, which implies that you
		// can call the function once to find out how much space to
		// allocate for a buffer and again to fill the buffer.
		// This is not the case. The cbNeeded parameter returns
		// the number of PIDs returned, so if your buffer size is
		// zero cbNeeded returns zero.

		// NOTE: The loop here ensures that we
		// actually allocate a buffer large enough for all the
		// PIDs in the system.
		dwProcessIDHeapSize = 256 * sizeof( DWORD ) ;
		lpdwPIDs = NULL ;

		do
		{
			if( lpdwPIDs )
			{ // Hmm.. we've been through this loop already, double the HeapSize and try again.
				delete [] lpdwPIDs;
				dwProcessIDHeapSize *= 2 ;
			}

			lpdwPIDs = (LPDWORD) new DWORD[dwProcessIDHeapSize];
			
			if( lpdwPIDs == NULL )
			{
				goto error_cleanup;
			}

			// Query the system for the total number of processes
			if( !g_lpDelayLoad->EnumProcesses( lpdwPIDs, dwProcessIDHeapSize, &dwProcessIDHeapSizeUsed ) )
			{
				// It's bad if we can't enum processes... no place to go but to bail out...
				goto error_cleanup;
			}
		} while( dwProcessIDHeapSizeUsed == dwProcessIDHeapSize );

		// How many ProcID's did we get?
		DWORD dwNumberOfPIDs = dwProcessIDHeapSizeUsed / sizeof( DWORD ) ;

		// Loop through each ProcID.
		for( dwIndex = 0 ; dwIndex < dwNumberOfPIDs; dwIndex++ )
		{
			// Skip this if we already have it...
			if (fPidAlreadyProvided(lpdwPIDs[dwIndex]))
				continue;

			// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()
			// Each Process gets its own 
			lpProcessInfo = new CProcessInfo();
			if (lpProcessInfo == NULL)
				goto error_cleanup;

			if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, NULL, m_lpOutputFile, NULL))
			{	// Failure initializing the ProcessInfo object?!?
				delete lpProcessInfo;
				lpProcessInfo = NULL;
				continue;
			}

			if (lpProcessInfo->EnumerateModules(lpdwPIDs[dwIndex], this, NULL, false))
			{
				// Success... add this to the Processes Object...
				if (!AddNewProcessInfoObject(lpProcessInfo))
				{ // Failure adding the node...
					delete lpProcessInfo;
					lpProcessInfo = NULL;
					continue;
				}
				// For now, let's error out...

			} else
			{
				// An error enumerating modules might be normal...
				delete lpProcessInfo;
				lpProcessInfo = NULL;
				continue;
			}
		}
	}

	fRetval = true;

cleanup:

	if (lpdwPIDs)
	{
		delete [] lpdwPIDs;
	}

	return fRetval;

error_cleanup:

	if (lpProcessInfo)
		delete lpProcessInfo;

	goto cleanup;
}

// ISSUE-2001/04/28-GREGWI - NEW CODE
bool CProcesses::GetProcessesDataForRunningProcessesUsingTOOLHELP32()
{
	CProcessInfo * lpProcessInfo = NULL;
	HANDLE hSnapShot = NULL;
	bool fReturn = false;

	if (!m_fInitialized)
		return false;

	// If there are any PIDs provided, query for these first...
	if (g_lpProgramOptions->cProcessID())
	{
		for (unsigned int i=0; i < g_lpProgramOptions->cProcessID(); i++)
		{
			// It's possible the user provided a PID directly... if so,
			// we can circumvent the whole search of PIDs on the system...

			// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()

			lpProcessInfo = new CProcessInfo();
			if (lpProcessInfo == NULL)
				goto error_cleanup;

			if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, NULL, m_lpOutputFile, NULL))
			{
				goto error_cleanup;
			}

			if (lpProcessInfo->EnumerateModules(g_lpProgramOptions->GetProcessID(i), this, NULL, true))
			{
				// Success... add this to the Processes Object...
				if (!AddNewProcessInfoObject(lpProcessInfo))
				{ // Failure adding the node...
					goto error_cleanup; // For now, let's just error on out...
				}
			} else
			{
				// Failure enumerating modules on the PID of interest... very bad... try another...
				continue;
			}
		}		
	}


	// Do we have a wild-card or process match search to make?  If either are true,
	// we must enumerate all the procesess
	if (	g_lpProgramOptions->cProcessNames() || 
		g_lpProgramOptions->fWildCardMatch() ||
		g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode) )
	{
		PROCESSENTRY32 procentry;
		BOOL bFlag;

	       // Get a handle to a Toolhelp snapshot of the systems processes.
       	hSnapShot = g_lpDelayLoad->CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

		if( hSnapShot == INVALID_HANDLE_VALUE )
		{
				goto error_cleanup ;
		}

		// Clear this structure
		memset(&procentry, 0, sizeof(procentry));

		// Get the first process' information.
		procentry.dwSize = sizeof(PROCESSENTRY32) ;
		bFlag = g_lpDelayLoad->Process32First( hSnapShot, &procentry ) ;

		// While there are processes, keep looping.
		while( bFlag )
		{
			// Skip this if we already have it...
			if (fPidAlreadyProvided(procentry.th32ProcessID))
				goto NextProcess;
		
			// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()
			// Each Process gets its own 
			lpProcessInfo = new CProcessInfo();
			if (lpProcessInfo == NULL)
				goto error_cleanup;

			if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, NULL, m_lpOutputFile, NULL))
			{	
				// Failure initializing the ProcessInfo object?!?
				goto ClearProcessInfo;
			}

			// Enumerate the modules for this process...
			if (lpProcessInfo->EnumerateModules(procentry.th32ProcessID, this, procentry.szExeFile, false))
			{
				// Success... add this to the Processes Object...
				if (!AddNewProcessInfoObject(lpProcessInfo))
				{ 
					// Failure adding the node...
					goto ClearProcessInfo;
				}

			} else
			{
				// An error enumerating modules might be normal...
				goto ClearProcessInfo;
			}

			goto NextProcess;

ClearProcessInfo:

			delete lpProcessInfo;
			lpProcessInfo = NULL;

NextProcess:
			// Clear this structure
			memset(&procentry, 0, sizeof(procentry));

			// Get the next Process...
			procentry.dwSize = sizeof(PROCESSENTRY32) ;
			bFlag = g_lpDelayLoad->Process32Next( hSnapShot, &procentry );
		}
	}

	fReturn =  true;
	goto cleanup;

error_cleanup:
	if (lpProcessInfo)
		delete lpProcessInfo;

cleanup:
	if (hSnapShot != INVALID_HANDLE_VALUE)
		CloseHandle(hSnapShot);

	return fReturn;
}


bool CProcesses::AddNewProcessInfoObject(CProcessInfo * lpProcessInfo)
{
	if (!m_fInitialized)
		return false;

	// First, create a ProcessInfoNode object and then attach it to the bottom of the
	// linked list of nodes...
	CProcessInfoNode * lpProcessInfoNode = new CProcessInfoNode(lpProcessInfo);
/*
#ifdef _DEBUG
	_tprintf(TEXT("Adding Process Info Object for [%s]\n"), lpProcessInfo->m_tszProcessName);
#endif
*/
	if (lpProcessInfoNode == NULL)
		return false; // Couldn't allocate memory..

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_ProcessInfoHeadMutex, INFINITE);

	CProcessInfoNode * lpProcessInfoNodePointer = m_lpProcessInfoHead;

	if (lpProcessInfoNodePointer) {

		// Traverse the linked list to the end..
		while (lpProcessInfoNodePointer->m_lpNextProcessInfoNode)
		{	// Keep looking for the end...
			lpProcessInfoNodePointer = lpProcessInfoNodePointer->m_lpNextProcessInfoNode;
		}
		
		lpProcessInfoNodePointer->m_lpNextProcessInfoNode = lpProcessInfoNode;

	}
	else
	{ // First time through, the Process Info Head pointer is null...
		m_lpProcessInfoHead = lpProcessInfoNode;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_ProcessInfoHeadMutex);

	InterlockedIncrement(&m_iNumberOfProcesses);

	return true;
}

bool CProcesses::OutputProcessesData(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader)
{
	// Output to file?
	if ( !g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) &&
		 !g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode) )
	{
		// Output to Stdout?
		if (!OutputProcessesDataToStdout(enumCollectionType, fCSVFileContext, fDumpHeader))
			return false;
	}	

	// Output to file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Try and output to file...
		if (!OutputProcessesDataToFile(enumCollectionType, fDumpHeader))
			return false;
	}	

	if (m_lpProcessInfoHead) {
		CProcessInfoNode * lpCurrentProcessInfoNode = m_lpProcessInfoHead;

		while (lpCurrentProcessInfoNode)
		{
			// We have a node... print out Process Info for it, then the Modules Data...
			if (lpCurrentProcessInfoNode->m_lpProcessInfo)
			{
				lpCurrentProcessInfoNode->m_lpProcessInfo->OutputProcessData(enumCollectionType, fCSVFileContext, false);
			}

			lpCurrentProcessInfoNode = lpCurrentProcessInfoNode->m_lpNextProcessInfoNode;
		}

	}
	return true;
}

bool CProcesses::OutputProcessesDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader)
{
	if (fDumpHeader)
	{
		// Output to stdout...
		_tprintf(TEXT("\n"));
		CUtilityFunctions::OutputLineOfStars();
		_tprintf(TEXT("%s - Printing Process Information for %d Processes.\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, m_iNumberOfProcesses);
		_tprintf(TEXT("%s - Context: %s\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, fCSVFileContext ? g_tszCollectionArray[enumCollectionType].tszCSVContext : g_tszCollectionArray[enumCollectionType].tszLocalContext);
		CUtilityFunctions::OutputLineOfStars();
	}
	return true;
}

bool CProcesses::OutputProcessesDataToFile(CollectionTypes enumCollectionType, bool fDumpHeader)
{
	// Don't write anything if there are no processes to report...
	if (0 == m_iNumberOfProcesses)
		return true;

	if (fDumpHeader)
	{
		// We skip output of the [PROCESSES] header if -E was specified...
		if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
		{
			// Write out the Processes tag so I can detect this output format...
			if (!m_lpOutputFile->WriteString(TEXT("\r\n")) ||
				!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVLabel) ||
				!m_lpOutputFile->WriteString(TEXT("\r\n"))
			   )
			{
				_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
				m_lpOutputFile->PrintLastError();
				return false;
			}
		}

		// We have different output for -E
		if (g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
		{
			// Write out the header... for the -E option...
			if (!m_lpOutputFile->WriteString(TEXT("Module Path,Symbol Status,Time/Date String,File Version,Company Name,File Description,File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n")))
			{
				_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
				m_lpOutputFile->PrintLastError();
				return false;
			}

		} else
		{
			// Write out the Processes Header
			if (!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVColumnHeaders))
			{
				_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
				m_lpOutputFile->PrintLastError();
				return false;
			}
		}
	}
	return true;
}

bool CProcesses::GetProcessesDataFromFile()
{
	CProcessInfo * lpProcessInfo = NULL;
	unsigned int i;

	// Read the Process Header Line
	if (!m_lpInputFile->ReadFileLine())
		return false;

	// Currently, we don't actually read the data...

	enum { BUFFER_SIZE = 128};
	char szProcessName[BUFFER_SIZE];

	TCHAR tszProcessName[BUFFER_SIZE];	

	DWORD iProcessID;

	// Read the first field (should be blank, unless this is a new collection type
	if (m_lpInputFile->ReadString())
		return true;

	bool fReturn = true;
	while (fReturn == true)
	{
		// Read the process name...
		if (0 == m_lpInputFile->ReadString(szProcessName, BUFFER_SIZE))
			break;

		if (!m_lpInputFile->ReadDWORD(&iProcessID))
		{
			fReturn = false;
			break;
		}

		// We've read the PID and the Process Name... if the user specified any with -P, search
		// for matches...
		if (g_lpProgramOptions->cProcessID() || g_lpProgramOptions->cProcessNames())
		{
			bool fMatchFound = false;

			// Search the PIDs first (if any)...
			if (g_lpProgramOptions->cProcessID())
			{
				for (i = 0; i < g_lpProgramOptions->cProcessID(); i++)
				{
					if (iProcessID == g_lpProgramOptions->GetProcessID(i))
					{
						fMatchFound = true;
						break;
					}
				}
			}

			// Search the Process Names second (if any)...
			if (g_lpProgramOptions->cProcessNames() && !fMatchFound)
			{
				// Convert our ANSI Process name...
				CUtilityFunctions::CopyAnsiStringToTSTR(szProcessName, tszProcessName, _MAX_FNAME+1);
			
				for (i = 0; i < g_lpProgramOptions->cProcessNames(); i++)
				{
					if  (_tcsicmp(tszProcessName, g_lpProgramOptions->GetProcessName(i)) == 0)
					{
						fMatchFound = true;
						break;
					}
				}
			}

			// Okay, did we get a match?
			if (!fMatchFound)
			{
				// Nope... well then, we should nuke this line...
				m_lpInputFile->ReadFileLine();

				// Then, jump to the next line processing...
				goto ReadNewLine;			
			}
		}

		// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()
		// Each Process gets its own 
		lpProcessInfo = new CProcessInfo();

		if (lpProcessInfo == NULL)
		{
			fReturn = false;
			break;
		}

		if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, m_lpInputFile, m_lpOutputFile, NULL))
		{	// Failure initializing the ProcessInfo object?!?
			delete lpProcessInfo;
			lpProcessInfo = NULL;
			fReturn = false;
			break;
		}

		// We need to convert this to Unicode possibly... (it will be copied in EnumModules())
		CUtilityFunctions::CopyAnsiStringToTSTR(szProcessName, tszProcessName, BUFFER_SIZE);

		// Save the process name...
		lpProcessInfo->SetProcessName(tszProcessName);

		// Enumerate the modules for the process
		if (!lpProcessInfo->EnumerateModules(iProcessID, this, tszProcessName, false))
		{
			fReturn = false;
			break;
		}

		// Success... add this to the Processes Object...
		if (!AddNewProcessInfoObject(lpProcessInfo))
		{ // Failure adding the node...
			delete lpProcessInfo;
			lpProcessInfo = NULL;
			return false;
		}

ReadNewLine:
		
		// Before we read a new line... are we already pointing to the end?
		if (m_lpInputFile->EndOfFile())
		{
			break;
		}

		// Read the first field (should be blank, unless this is a new collection type
		if (m_lpInputFile->ReadString())
			break;
	}
	// We don't expect to find anything...

	return fReturn;
}

bool CProcesses::fPidAlreadyProvided(unsigned int iPid)
{
	bool fFound= false;
			
	// If we were provided Process ID's also... make sure this PID doesn't exist
	// in that list (if it does, then we already picked it up above)...
	if (g_lpProgramOptions->cProcessID())
	{
		for (unsigned int i=0; i < g_lpProgramOptions->cProcessID(); i++)
		{
			if (iPid == g_lpProgramOptions->GetProcessID(i))
			{
				fFound = true;
				break;
			}
		}
	}

	return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\processinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processinfo.h
//
//--------------------------------------------------------------------------

// ProcessInfo.h: interface for the CProcessInfo class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROCESSINFO_H__213C3A76_9FBB_11D2_83A7_000000000000__INCLUDED_)
#define AFX_PROCESSINFO_H__213C3A76_9FBB_11D2_83A7_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include "globals.h"

// Forward declarations
class CProcesses;
class CModuleInfo;
class CModuleInfoNode;
class CModuleInfoCache;
class CFileData;
class CDmpFile;

class CProcessInfo  
{
public:
	bool GetProcessData();
//	bool EnumerateModulesFromUserDmpFile();
	CProcessInfo();
	virtual ~CProcessInfo();

	bool Initialize(CModuleInfoCache *lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile);

	LPTSTR GetProcessName();
	bool EnumerateModules(DWORD iProcessID, CProcesses * lpProcesses, LPTSTR tszProcessName, bool fPidSearch);
	
	bool OutputProcessData(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader = true);

	bool SetProcessName(LPTSTR tszFileName);
	bool AddNewModuleInfoObject(CModuleInfo * lpModuleInfo);

protected:
	bool GetProcessDataFromFile();
	// Process Info Objects Required
	CFileData * m_lpInputFile;
	CFileData * m_lpOutputFile;
	CDmpFile * m_lpDmpFile;
	CModuleInfoNode * m_lpModuleInfoHead;
	CModuleInfoCache * m_lpModuleInfoCache;

	// Process Info Data
	LPTSTR m_tszProcessName;
	HANDLE m_hModuleInfoHeadMutex;
	DWORD m_iProcessID;
	long m_iNumberOfModules;
	bool m_fInitialized;

	// Process Info Methods
	bool EnumerateModulesFromFile(DWORD iProcessID, LPTSTR tszProcessName);
	bool EnumerateModulesForRunningProcessUsingPSAPI(DWORD iProcessID, bool fPidSearch);
	bool EnumerateModulesForRunningProcessUsingTOOLHELP32(DWORD iProcessID, LPTSTR tszProcessName, bool fPidSearch);
	bool fIsProcessName(LPTSTR tszFileName);
//	bool fModuleNameMatches(LPTSTR tszProcessName, LPTSTR tszModulePath);
	bool fModuleNameMatches(LPTSTR tszModulePath);
	bool OutputProcessDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader);
	bool OutputProcessDataToFile(CollectionTypes enumCollectionType, bool fDumpHeader);
};

#endif // !defined(AFX_PROCESSINFO_H__213C3A76_9FBB_11D2_83A7_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\programoptions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       programoptions.cpp
//
//--------------------------------------------------------------------------

// ProgramOptions.cpp: implementation of the CProgramOptions class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include <stdlib.h>
#include <dbghelp.h>
#include "filedata.h"

#include "Version.h"

const LPTSTR CProgramOptions::g_DefaultSymbolPath = TEXT("%systemroot%\\symbols");

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProgramOptions::CProgramOptions()
{
	// Initialize default modes
	m_fSimpleHelpMode = false;
	m_fHelpMode = false;

	m_fInputProcessesFromLiveSystemMode = false;
	m_fInputDriversFromLiveSystemMode = false;
	m_fInputProcessesWithMatchingNameOrPID = false;
	m_fInputModulesDataFromFileSystemMode = false;
	m_fInputDmpFileMode = false;

	m_fMatchModuleMode = false;
	
	m_fPrintTaskListMode = false;
	m_fOutputSymbolInformationMode = false;
	m_fOutputModulePerf = false;
	m_fCollectVersionInfoMode = false;

	m_fVerifySymbolsMode = false;
	m_fVerifySymbolsModeWithSymbolPath = false;
	m_fVerifySymbolsModeWithSymbolPathOnly = false;
	m_fVerifySymbolsModeWithSymbolPathRecursion = false;
	m_fVerifySymbolsModeUsingDBGInMISCSection = false;
	m_fVerifySymbolsModeWithSQLServer = false;
	m_fVerifySymbolsModeWithSQLServer2 = false;		// SQL2 - mjl 12/14/99
	m_iVerificationLevel = 1;
	m_fFileSystemRecursion = false;

	// Initially there is no preference defined...
	m_enumSymbolSourcePreference = enumVerifySymbolsModeSourceSymbolsNoPreference;
	
	m_fSymbolTreeToBuildMode = false;
	m_fCopySymbolsToImage = false;
	m_fInputCSVFileMode = false;
	m_fOutputCSVFileMode = false;
	m_fOutputDiscrepanciesOnly = false;
	m_fOverwriteOutputFileMode = false;
	m_fQuietMode = false;

	m_tszSymbolTreeToBuild = NULL;
	m_tszSymbolPath = NULL;
	m_tszExePath = NULL;
	m_tszModuleToMatch = NULL;
	m_tszOutputCSVFilePath = NULL;
	m_tszInputCSVFilePath = NULL;
	m_tszInputDmpFilePath = NULL;

	m_tszInputModulesDataFromFileSystemPath = NULL;
	m_tszSQLServer = NULL;

	m_dwDebugLevel = 0;

	// Create an array of process IDs and/or Process Names
	m_tszProcessPidString = NULL;
	m_fWildCardMatch = false;
	m_rgProcessIDs = NULL;
	m_cProcessIDs = 0;
	m_rgtszProcessNames = NULL;
	m_cProcessNames = 0;

	m_fExceptionMonitorMode = false;
}

CProgramOptions::~CProgramOptions()
{
	if (m_tszSymbolPath)
		delete [] m_tszSymbolPath;

	if (m_tszExePath)
		delete [] m_tszExePath;
	
	if (m_tszProcessPidString)
		delete [] m_tszProcessPidString;

	if (m_rgProcessIDs)
		delete [] m_rgProcessIDs;

	if (m_rgtszProcessNames)
		delete [] m_rgtszProcessNames;

	if (m_tszModuleToMatch)
		delete [] m_tszModuleToMatch;

	if (m_tszOutputCSVFilePath)
		delete [] m_tszOutputCSVFilePath;

	if (m_tszInputCSVFilePath)
		delete [] m_tszInputCSVFilePath;

	if (m_tszInputDmpFilePath)
		delete [] m_tszInputDmpFilePath;

	if (m_tszInputModulesDataFromFileSystemPath)
		delete [] m_tszInputModulesDataFromFileSystemPath;

	if (m_tszSymbolTreeToBuild)
		delete [] m_tszSymbolTreeToBuild;

	if (m_tszSQLServer)
		delete [] m_tszSQLServer;
}

// Intialize members that have to dynamically allocate memory...
bool CProgramOptions::Initialize()
{
	// Copy expanded default symbol search path (%systemroot%\symbols)
	m_tszSymbolPath = CUtilityFunctions::ExpandPath(g_DefaultSymbolPath);

	if (!m_tszSymbolPath)
		return false;

#ifdef _DEBUG
	_tprintf(TEXT("Default Symbol Path = [%s]\n"), m_tszSymbolPath);
#endif

	// Get the OS Version Info Stuff
	m_osver.dwOSVersionInfoSize = sizeof( m_osver ) ;

	if( !GetVersionExA( &m_osver ) )
	{
		_tprintf(TEXT("Couldn't figure out what version of Windows is running.\n"));
		return false ;
	}

	return true;
}

// This sets the mode requested, and returns the value it was set to (which is provided as input)
bool CProgramOptions::SetMode(enum ProgramModes mode, bool fState)
{
	switch (mode)
	{
		case HelpMode:
			m_fHelpMode = fState;
			break;

		case SimpleHelpMode:
			m_fSimpleHelpMode = fState;
			break;

		case InputProcessesFromLiveSystemMode:
			m_fInputProcessesFromLiveSystemMode = fState;
			break;

		case InputDriversFromLiveSystemMode:
			m_fInputDriversFromLiveSystemMode = fState;
			break;

		case InputProcessesWithMatchingNameOrPID:
			m_fInputProcessesWithMatchingNameOrPID = fState;
			break;

		case MatchModuleMode:
			m_fMatchModuleMode = fState;
			break;

		case InputModulesDataFromFileSystemMode:
			m_fInputModulesDataFromFileSystemMode = fState;
			break;

		case InputDmpFileMode:
			m_fInputDmpFileMode = fState;
			break;

		case PrintTaskListMode:
			m_fPrintTaskListMode = fState;
			break;

		case QuietMode:
			m_fQuietMode = fState;
			break;

		case OutputSymbolInformationMode:
			m_fOutputSymbolInformationMode = fState;
			break;

		case OutputModulePerf:
			m_fOutputModulePerf = fState;
			break;
			
		case CollectVersionInfoMode:
			m_fCollectVersionInfoMode = fState;
			break;

		case VerifySymbolsMode:
			m_fVerifySymbolsMode = fState;
			break;

		case VerifySymbolsModeWithSymbolPath:
			m_fVerifySymbolsModeWithSymbolPath = fState;
			break;

		case VerifySymbolsModeWithSymbolPathOnly:
			m_fVerifySymbolsModeWithSymbolPathOnly = fState;
			break;

		case VerifySymbolsModeWithSymbolPathRecursion:
			m_fVerifySymbolsModeWithSymbolPathRecursion = fState;
			break;

		case VerifySymbolsModeNotUsingDBGInMISCSection:
			m_fVerifySymbolsModeUsingDBGInMISCSection = fState;
			break;
/*
		case VerifySymbolsModeSourceSymbolsPreferred:
			m_fVerifySymbolsModeSourceSymbolsPreferred = fState;
			break;
			
		case VerifySymbolsModeSourceSymbolsOnly:
			m_fVerifySymbolsModeSourceSymbolsOnly = fState;
			break;

		case VerifySymbolsModeSourceSymbolsNotAllowed:
			m_fVerifySymbolsModeSourceSymbolsNotAllowed= fState;
			break;
*/
		case VerifySymbolsModeWithSQLServer:
			m_fVerifySymbolsModeWithSQLServer = fState;
			break;

		case VerifySymbolsModeWithSQLServer2:
			m_fVerifySymbolsModeWithSQLServer2 = fState;
			break;

		case CopySymbolsToImage:
			m_fCopySymbolsToImage = fState;
			break;
			
		case BuildSymbolTreeMode:
			m_fSymbolTreeToBuildMode = fState;
			break;

		case OutputCSVFileMode:
			m_fOutputCSVFileMode = fState;
			break;

		case OutputDiscrepanciesOnly:
			m_fOutputDiscrepanciesOnly = fState;
			break;

		case OverwriteOutputFileMode:
			m_fOverwriteOutputFileMode = fState;
			break;

		case InputCSVFileMode:
			m_fInputCSVFileMode = fState;
			break;

		case ExceptionMonitorMode:
			m_fExceptionMonitorMode = fState;
			break;
	}

	return fState;
}

bool CProgramOptions::GetMode(enum ProgramModes mode)
{
	switch (mode)
	{
		case HelpMode:
			return m_fHelpMode;

		case SimpleHelpMode:
			return m_fSimpleHelpMode;

		case InputProcessesFromLiveSystemMode:
			return m_fInputProcessesFromLiveSystemMode;

		case InputDriversFromLiveSystemMode:
			return m_fInputDriversFromLiveSystemMode;

		case InputProcessesWithMatchingNameOrPID:
			return m_fInputProcessesWithMatchingNameOrPID;

		case MatchModuleMode:
			return m_fMatchModuleMode;

		case InputModulesDataFromFileSystemMode:
			return m_fInputModulesDataFromFileSystemMode;

		case InputDmpFileMode:
			return m_fInputDmpFileMode;

		case BuildSymbolTreeMode:
			return m_fSymbolTreeToBuildMode;

		case CopySymbolsToImage:
			return m_fCopySymbolsToImage;
		
		case PrintTaskListMode:
			return m_fPrintTaskListMode;
		
		case QuietMode:
			return m_fQuietMode;

		case OutputSymbolInformationMode:
			return m_fOutputSymbolInformationMode;

		case OutputModulePerf:
			return m_fOutputModulePerf;
			
		case CollectVersionInfoMode:
			return m_fCollectVersionInfoMode;
		
		case VerifySymbolsMode:
			return m_fVerifySymbolsMode;

		case VerifySymbolsModeWithSymbolPath:
			return m_fVerifySymbolsModeWithSymbolPath;

		case VerifySymbolsModeWithSymbolPathOnly:
			return m_fVerifySymbolsModeWithSymbolPathOnly;

		case VerifySymbolsModeWithSymbolPathRecursion:
			return m_fVerifySymbolsModeWithSymbolPathRecursion;

		case VerifySymbolsModeNotUsingDBGInMISCSection:
			return m_fVerifySymbolsModeUsingDBGInMISCSection;

		case VerifySymbolsModeWithSQLServer:
			return m_fVerifySymbolsModeWithSQLServer;
		
		case VerifySymbolsModeWithSQLServer2:
			return m_fVerifySymbolsModeWithSQLServer2;
		
		case OutputCSVFileMode:
			return m_fOutputCSVFileMode;

		case OutputDiscrepanciesOnly:
			return m_fOutputDiscrepanciesOnly;
		
		case OverwriteOutputFileMode:
			return m_fOverwriteOutputFileMode;

		case InputCSVFileMode:
			return m_fInputCSVFileMode;

		case ExceptionMonitorMode:
			return m_fExceptionMonitorMode;
	}

	// Should never get here...
#ifdef _DEBUG
	_tprintf(TEXT("ERROR! GetMode() - Unknown mode provided! %d"), mode);
#endif
	return false;
}
/*
bool CProgramOptions::SetProcessID(DWORD iPID)
{
	m_iProcessID = iPID;
	return true;
}
*/
bool CProgramOptions::ProcessCommandLineArguments(int argc, TCHAR *argv[])
{
	// Skip past the executible filename
	int iArgumentNumber = 1;
	bool fSOURCE		= false;
	bool fSOURCEONLY 	= false;
	bool fNOSOURCE 		= false;
	bool fSuccess		= false;
	// Open the file provided!
	CFileData * lpSymbolPathsFile = NULL;										
	LPSTR szTempBuffer = NULL;
	LPTSTR tszTempBuffer = NULL;

	if (argc == 1)
	{
		// Change default behavior from stuff below, to simple help
		SetMode(SimpleHelpMode, true);
		fSuccess = true;
		goto cleanup;
	}
	
	// Iterate through the arguments...
	while (iArgumentNumber < argc)
	{
#ifdef _DEBUG
		_tprintf(TEXT("Arg%d = %s\n"), iArgumentNumber+1, argv[iArgumentNumber]);
#endif
		if (argv[iArgumentNumber][0] == TEXT('-') || argv[iArgumentNumber][0] == TEXT('/'))
		{
			// Look for string matches first!
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("NOSOURCE")) == 0)
			{
				// This changes our search behavior to require non source-enabled symbols
#ifdef _DEBUG
				_tprintf(TEXT("NOSOURCE argument provided!\n"));
#endif
				m_enumSymbolSourcePreference = enumVerifySymbolsModeSourceSymbolsNotAllowed;
				fNOSOURCE = true;
			} else 
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("SOURCEONLY")) == 0)
			{
				// This changes our search behavior to require source-enabled symbols
#ifdef _DEBUG
				_tprintf(TEXT("SOURCEONLY argument provided!\n"));
#endif
				m_enumSymbolSourcePreference = enumVerifySymbolsModeSourceSymbolsOnly;
				fSOURCEONLY = true;
			} else 
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("SOURCE")) == 0)
			{
				// This changes our search behavior to favor source-enabled symbols
#ifdef _DEBUG
				_tprintf(TEXT("SOURCE argument provided!\n"));
#endif
				m_enumSymbolSourcePreference = enumVerifySymbolsModeSourceSymbolsPreferred;
				fSOURCE = true;
			} else 
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("NOISY")) == 0)
			{
				// Get MATCH argument (the module to match against)
#ifdef _DEBUG
				_tprintf(TEXT("NOISY argument provided!\n"));
#endif
				m_dwDebugLevel = enumDebugSearchPaths;
				SymSetOptions(SYMOPT_DEBUG);
			} else 
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("PERF")) == 0)
			{
				// Get PERF 
#ifdef _DEBUG
				_tprintf(TEXT("PERF argument provided!\n"));
#endif
				SetMode(OutputModulePerf, true);
			} else 
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("MATCH")) == 0)
			{
				// Get MATCH argument (the module to match against)
#ifdef _DEBUG
				_tprintf(TEXT("MATCH argument provided!\n"));
#endif
				iArgumentNumber++;

				if (iArgumentNumber < argc)
				{
					m_tszModuleToMatch = CUtilityFunctions::CopyString(argv[iArgumentNumber]);

					// Let's force upper-case matches for simplicity
					_tcsupr(m_tszModuleToMatch);
					
					if (!m_tszModuleToMatch)
						goto cleanup;

					SetMode(MatchModuleMode, true);
#ifdef _DEBUG
					_tprintf(TEXT("Module to match set to [%s]\n"), m_tszModuleToMatch);
#endif
				}
				else
				{ 
					_tprintf(TEXT("\nArgument Missing!  -MATCH option requires module to match against!\n"));
					// Not enough arguments...
					goto cleanup;
				}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("BYIMAGE")) == 0)
			{
				// Copy Symbols adjacent to the image
#ifdef _DEBUG
				_tprintf(TEXT("-BYIMAGE argument provided!\n"));
#endif
				SetMode(CopySymbolsToImage, true);
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("SQL2")) == 0)
			{
				// Get the SQL2 server name
#ifdef _DEBUG
				_tprintf(TEXT("SQL2 Server name provided!\n"));
#endif
				iArgumentNumber++;

				if (iArgumentNumber < argc)
				{
					m_tszSQLServer2 = CUtilityFunctions::CopyString(argv[iArgumentNumber]);
					if (!m_tszSQLServer2)
						goto cleanup;

					SetMode(VerifySymbolsMode, true);
					SetMode(VerifySymbolsModeWithSQLServer2, true);
#ifdef _DEBUG
					_tprintf(TEXT("SQL2 Server set to [%s]\n"), m_tszSQLServer2);
#endif
				}
				else
				{ 
					_tprintf(TEXT("\nArgument Missing!  -SQL2 option requires SQL Server Name value!\n"));
					// Not enough arguments...
					goto cleanup;
				}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("SQL")) == 0)
			{
				// Get the SQL server name
#ifdef _DEBUG
					_tprintf(TEXT("SQL Server name provided!\n"));
#endif
					iArgumentNumber++;

					if (iArgumentNumber < argc)
					{
						m_tszSQLServer = CUtilityFunctions::CopyString(argv[iArgumentNumber]);

						if (!m_tszSQLServer)
							goto cleanup;

						SetMode(VerifySymbolsMode, true);
						SetMode(VerifySymbolsModeWithSQLServer, true);
#ifdef _DEBUG
						_tprintf(TEXT("SQL Server set to [%s]\n"), m_tszSQLServer);
#endif
					}
					else
					{ 
						_tprintf(TEXT("\nArgument Missing!  -SQL option requires SQL Server Name value!\n"));
						// Not enough arguments...
						goto cleanup;
					}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("EXEPATH")) == 0)
			{
				// Get the SQL server name
#ifdef _DEBUG
					_tprintf(TEXT("EXEPATH name provided!\n"));
#endif
					iArgumentNumber++;

					if (iArgumentNumber < argc)
					{
						m_tszExePath = CUtilityFunctions::CopyString(argv[iArgumentNumber]);

						if (!m_tszExePath)
							goto cleanup;

#ifdef _DEBUG
						_tprintf(TEXT("EXEPATH set to [%s]\n"), m_tszExePath);
#endif
					}
					else
					{ 
						_tprintf(TEXT("\nArgument Missing!  -EXEPATH option requires Executable Path value!\n"));
						// Not enough arguments...
						goto cleanup;
					}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("DEBUG")) == 0)
			{
				// Okay, we have the DEBUG switch... see what Debug Level is requested
				iArgumentNumber++;

				if (iArgumentNumber < argc)
				{
					// Save away the Debug Level
					m_dwDebugLevel = _ttoi(argv[iArgumentNumber]);
				}
				else
				{ 
					_tprintf(TEXT("\nArgument Missing!  -DEBUG option requires Debug Level!\n"));
					// Not enough arguments...
					goto cleanup;
				}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("???")) == 0)
			{
				SetMode(HelpMode, true);
				fSuccess = true;
				goto cleanup;
			} else

			{
				// We found a command directive..
				switch (argv[iArgumentNumber][1])
				{
					case TEXT('?'):
					case TEXT('h'):
					case TEXT('H'):
						SetMode(SimpleHelpMode, true);
						iArgumentNumber = argc;
						fSuccess = true;
						goto cleanup;

					case TEXT('t'):
					case TEXT('T'):
						SetMode(PrintTaskListMode, true);
						SetMode(InputProcessesFromLiveSystemMode, true);
						break;

					case TEXT('s'):
					case TEXT('S'):
						SetMode(OutputSymbolInformationMode, true);
						break;

					case TEXT('i'):
					case TEXT('I'):
#ifdef _DEBUG
						_tprintf(TEXT("Input File path provided\n"));
#endif
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							m_tszInputCSVFilePath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);

							SetMode(InputCSVFileMode, true);
						}
						else
						{   // Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -I option requires an input file!\n"));
							goto cleanup;
						}
						break;

						// This special version supports a new mode...
					case TEXT('e'):
					case TEXT('E'):
						SetMode(ExceptionMonitorMode, true);
						break;

					case TEXT('o'):
					case TEXT('O'):
						// Check to see if they want to overwrite the file if it exists?
						if (argv[iArgumentNumber][2])
						{
							if ( 2 == _ttoi(&argv[iArgumentNumber][2]) )
							{
#ifdef _DEBUG
								_tprintf(TEXT("Overwrite Mode enabled!\n"));
#endif
								SetMode(OverwriteOutputFileMode, true);
							}
						}

#ifdef _DEBUG
						_tprintf(TEXT("Output File path provided\n"));
#endif
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							m_tszOutputCSVFilePath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
#ifdef _DEBUG
							_tprintf(TEXT("Output File Path set to [%s]\n"), GetOutputFilePath());
#endif
							// Enable OutputCSVFileMode
							SetMode(OutputCSVFileMode, true);
						}
						else
						{   // Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -O option requires an output file!\n"));
							goto cleanup;
						}
						break;

					case TEXT('q'):
					case TEXT('Q'):

						// Check to see if they only want to suppress matches?
						if (argv[iArgumentNumber][2])
						{
							if ( 2 == _ttoi(&argv[iArgumentNumber][2]) )
							{
								SetMode(OutputDiscrepanciesOnly, true);
							} else
							{
								SetMode(QuietMode, true);
							}
						} else
						{
							SetMode(QuietMode, true);
						}
						break;

					case TEXT('r'):
					case TEXT('R'):
						SetMode(CollectVersionInfoMode, true);
						break;
					
					case TEXT('v'):
					case TEXT('V'):

						SetMode(VerifySymbolsMode, true);

						if (argv[iArgumentNumber][2])
						{
							m_iVerificationLevel = _ttoi(&argv[iArgumentNumber][2]);

							if (m_iVerificationLevel == 0)
							{
								SetMode(HelpMode, true);
								iArgumentNumber = argc;
							}
						}
						break;

					case TEXT('f'):
					case TEXT('F'):

						// Check to see if recursion is requested
						if (argv[iArgumentNumber][2])
						{
							m_fFileSystemRecursion = (2 == _ttoi(&argv[iArgumentNumber][2]));
						}
						
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							m_tszInputModulesDataFromFileSystemPath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
							if (VerifySemiColonSeparatedPath(m_tszInputModulesDataFromFileSystemPath))
							{
								SetMode(InputModulesDataFromFileSystemMode, true);
							}
							else
							{
								_tprintf(TEXT("\nFile Path specified to search is too long\n"));
								goto cleanup;
							}

						}
						else
						{ 
							// Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -F option requires a directory/file path!\n"));
							goto cleanup;
						}
						break;

					// BUILD A SYMBOL TREE
					case TEXT('b'):
					case TEXT('B'):
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							SetMode(BuildSymbolTreeMode, true);

							// Okay, we have some string gymnastics below because we
							// want to expand any environment variables, and ensure
							// that we have a backslash appended...
							TCHAR tszPathBuffer[_MAX_PATH];
							LPTSTR tszExpandedPathBuffer = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
							_tcscpy(tszPathBuffer, tszExpandedPathBuffer);
							delete [] tszExpandedPathBuffer;

							int cbLength = _tcsclen(tszPathBuffer);

							if (cbLength && tszPathBuffer[cbLength-1] != '\\')
							{
								_tcscat(tszPathBuffer, TEXT("\\"));
							}

							m_tszSymbolTreeToBuild = CUtilityFunctions::CopyString(tszPathBuffer);

							if (!m_tszSymbolTreeToBuild)
								goto cleanup;

							if (VerifySemiColonSeparatedPath(m_tszSymbolTreeToBuild))
							{
#ifdef _DEBUG
								_tprintf(TEXT("Building a Symbol Path Requested at [%s]\n"), m_tszSymbolTreeToBuild);
#endif
							}
							else
							{
								_tprintf(TEXT("\nPath provided to build symbol path is too long!\n"));
								goto cleanup;
							}

						}
						else
						{ 
							// Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -B option requires a directory symbol path\n"));
							goto cleanup;
						}
						break;

					case TEXT('p'):
					case TEXT('P'):
#ifdef _DEBUG
						_tprintf(TEXT("Specific Process name (or PID) requested\n"));
#endif
						iArgumentNumber++;

						// Do we have another argument (we should)...
						if (iArgumentNumber < argc)
						{
							// Well... we know that we have been asked to query processes...
							SetMode(InputProcessesFromLiveSystemMode, true);

							// Copy the string so we can write NULLs on delims if necessary...
							m_tszProcessPidString = new TCHAR[_tcslen(argv[iArgumentNumber])+1];

							if (!m_tszProcessPidString)
								goto cleanup;

							m_tszProcessPidString = _tcscpy(m_tszProcessPidString, argv[iArgumentNumber]);


							// First, we need to scan the string counting the PIDs and/or Names provided
							LPTSTR lptszCurrentPosition = m_tszProcessPidString;
							
							while (lptszCurrentPosition)
							{
								bool fDelimOverwritten = false;

								LPTSTR lptszNextDelim = _tcsstr(lptszCurrentPosition, _T(";"));

								if (lptszNextDelim)
								{
									(*lptszNextDelim) = NULL;
									fDelimOverwritten = true;
								}

								// Now, test the current argument for either a wildcard, number, or process name
								if ((*lptszCurrentPosition) == _T('*'))
								{
									// No need to search for anything else... this overrides everything
									m_fWildCardMatch = true;
									m_cProcessNames = 0;
									m_cProcessIDs = 0;
									break;
								} else
								if (_ttoi(lptszCurrentPosition) == 0)
								{
									// This must be a process name...
									m_cProcessNames++;

								} else
								{
									m_cProcessIDs++;
								}

								// Restore the delim if necesary
								if (fDelimOverwritten)
								{
									(*lptszNextDelim) = _T(';');

									// Advance to next position...
									lptszCurrentPosition = CharNext(lptszNextDelim);
								} else
								{
									lptszCurrentPosition = NULL;
								}
							}

							// If there are Process Names, PIDs do this again
							// but allocate storage first...
							if (m_cProcessNames || m_cProcessIDs)
							{
								if (m_cProcessIDs)
								{
									m_rgProcessIDs = new DWORD[m_cProcessIDs];

									if (!m_rgProcessIDs)
										goto cleanup;
								}

								if (m_cProcessNames)
								{
									m_rgtszProcessNames = new LPTSTR[m_cProcessNames];

									if (!m_rgtszProcessNames)
										goto cleanup;
								}

								// Okay, now pass over the input and populate our arrays...
								unsigned int iProcessIDs = 0;
								unsigned int iProcessNames = 0;

								// Second, we need to scan the string and assign PIDs and Names
								lptszCurrentPosition = m_tszProcessPidString;
								
								while (lptszCurrentPosition)
								{
									bool fDelimOverwritten = false;

									LPTSTR lptszNextDelim = _tcsstr(lptszCurrentPosition, _T(";"));

									if (lptszNextDelim)
									{
										(*lptszNextDelim) = NULL;
										fDelimOverwritten = true;
									}

									// Now, test the current argument for either a wildcard, number, or process name
									if (_ttoi(lptszCurrentPosition) == 0)
									{
										// This must be a process name...
										m_rgtszProcessNames[iProcessNames] = lptszCurrentPosition;
#ifdef _DEBUG
										_tprintf(TEXT("Process name: [%s]\n"), m_rgtszProcessNames[iProcessNames]);
#endif
										iProcessNames++;

									} else
									{
										m_rgProcessIDs[iProcessIDs] = _ttoi(lptszCurrentPosition);
#ifdef _DEBUG
										_tprintf(TEXT("Process ID: [%d]\n"), m_rgProcessIDs[iProcessIDs]);
#endif
										iProcessIDs++;
									}

									// Don't restore the delim (it separates our strings)
									// Restore it only long enough to advance past it with CharNext
									if (fDelimOverwritten)
									{
										(*lptszNextDelim) = _T(';');
										// Advance to next position...
										lptszCurrentPosition = CharNext(lptszNextDelim);
										(*lptszNextDelim) = NULL;

									} else
									{
										lptszCurrentPosition = NULL;
									}
								}
							}

						}
						else
						{ 
							// Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -P option requires *, a Process ID, or a Process Name!\n"));
							goto cleanup;
						}

						break;

					case TEXT('d'):
					case TEXT('D'):
						// Do we have another argument (we should)...
						// Well... we know that we have been asked to query device drivers...
						SetMode(InputDriversFromLiveSystemMode, true);

						break;

					case TEXT('y'):
					case TEXT('Y'):
#ifdef _DEBUG
						_tprintf(TEXT("Symbol path provided\n"));
#endif
						{
							TCHAR chSymbolArgument = argv[iArgumentNumber][2];
							bool fSymbolPathFileSpecified = false;

							// Check to see if they want some flavor of symbol searching...
							if (chSymbolArgument)
							{
								if (chSymbolArgument == TEXT('I') || 
									chSymbolArgument == TEXT('i'))
								{
									fSymbolPathFileSpecified = true;
									chSymbolArgument = argv[iArgumentNumber][3]; // Try the next char
								}
								
								if (chSymbolArgument)
								{
									DWORD dwSymbolPathSearchOptions = _ttoi(&chSymbolArgument);

									if (dwSymbolPathSearchOptions & enumSymbolPathOnly)
									{
#ifdef _DEBUG
										_tprintf(TEXT("Symbol Path Searching ONLY mode enabled!\n"));
#endif
										SetMode(VerifySymbolsModeWithSymbolPathOnly, true);
									}

									if (dwSymbolPathSearchOptions & enumSymbolPathRecursion)
									{
#ifdef _DEBUG
										_tprintf(TEXT("Recursive Symbol Searching Mode enabled!\n"));
#endif
										SetMode(VerifySymbolsModeWithSymbolPathRecursion, true);
									}

									if (dwSymbolPathSearchOptions & enumSymbolsModeNotUsingDBGInMISCSection)
									{
										_tprintf(TEXT("Verify Symbols Using DBG files found in MISC Section of PE Image!\n"));

										SetMode(VerifySymbolsModeNotUsingDBGInMISCSection, true);
									}
								}
							}
							iArgumentNumber++;

							if (iArgumentNumber < argc)
							{
								if (fSymbolPathFileSpecified)
								{
									// Open the file provided!
									lpSymbolPathsFile = new CFileData();

									if (!lpSymbolPathsFile)
									{
										_tprintf(TEXT("Unable to allocate memory for an input file object!\n"));
										goto cleanup;
									}
#ifdef _DEBUG
									_tprintf(TEXT("Symbol path file [%s] provided!\n"), argv[iArgumentNumber]);
#endif

									// Set the input file path
									if (!lpSymbolPathsFile->SetFilePath(argv[iArgumentNumber]))
									{
										_tprintf(TEXT("Unable set input file path in the file data object!  Out of memory?\n"));
										goto cleanup;
									}

									// If we are going to produce an input file... try to do that now...
									if (!lpSymbolPathsFile->OpenFile(OPEN_EXISTING, true)) // Must exist, read only mode...
									{
										_tprintf(TEXT("Unable to open the input file %s.\n"), lpSymbolPathsFile->GetFilePath());
										lpSymbolPathsFile->PrintLastError();
										goto cleanup;
									}

									// Reading is so much easier in memory mapped mode...
									if (!lpSymbolPathsFile->CreateFileMapping())
									{
										_tprintf(TEXT("Unable to CreateFileMapping of the input file %s.\n"), lpSymbolPathsFile->GetFilePath());
										lpSymbolPathsFile->PrintLastError();
										goto cleanup;
									}

									// Okay, now read the path
									if (!lpSymbolPathsFile->ReadFileLine())
									     return false;

									DWORD dwLineLength = lpSymbolPathsFile->LengthOfString();
									
									szTempBuffer = new char[dwLineLength+1];

									if (szTempBuffer == NULL)
									{
										_tprintf(TEXT("Unable to allocate memory for temporary buffer\n"));
										goto cleanup;
									}

									// Read the value (in ANSI form)
									if (lpSymbolPathsFile->ReadString(szTempBuffer, dwLineLength+1))
									{
										tszTempBuffer = CUtilityFunctions::CopyAnsiStringToTSTR(szTempBuffer);

										if (!tszTempBuffer)
											goto cleanup;
									}

									if (m_tszSymbolPath)
									{
										delete [] m_tszSymbolPath;
										m_tszSymbolPath = NULL;
									}

									m_tszSymbolPath = CUtilityFunctions::ExpandPath(tszTempBuffer, true);
								} else
								{
									if (m_tszSymbolPath)
									{
										delete [] m_tszSymbolPath;
										m_tszSymbolPath = NULL;
									}

									m_tszSymbolPath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber], true);
								}

								if (VerifySemiColonSeparatedPath(m_tszSymbolPath))
								{
									SetMode(VerifySymbolsModeWithSymbolPath, true);
#ifdef _DEBUG
									_tprintf(TEXT("Symbol Path set to [%s]\n"), GetSymbolPath());
#endif
								}
								else
								{
									_tprintf(TEXT("\nBad Symbol Path Provided!  Multiple paths are semi-colon delimited!\n"));
									goto cleanup;
								}
							}
							else
							{ 
								// Not enough arguments...
								_tprintf(TEXT("\nArgument Missing!  -Y option requires a symbol path!\n"));
								goto cleanup;
							}
						}
						break;

					case TEXT('z'):
					case TEXT('Z'):
#ifdef _DEBUG
						_tprintf(TEXT("DMP file provided!\n"));
#endif
						iArgumentNumber++;
						if (iArgumentNumber < argc)
						{
							m_tszInputDmpFilePath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
							
							SetMode(InputDmpFileMode, true);

#ifdef _DEBUG
							_tprintf(TEXT("Dmp File Path set to [%s]\n"), GetDmpFilePath());
#endif
						}
						else
						{   // Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -DMP option requires a DMP file!\n"));
							goto cleanup;
					}
						break;

					default:
						_tprintf(TEXT("\nUnknown command specified! [%s]\n"), argv[iArgumentNumber]);
						iArgumentNumber = argc;
						goto cleanup;
				}
			}
		} else
		{
			_tprintf(TEXT("\nUnknown option specified! [%s]\n"), argv[iArgumentNumber]);
			goto cleanup;
		}

		// Increment to the next argument...
		iArgumentNumber++;
	}

	if ( !GetMode(InputCSVFileMode) && 
		 !GetMode(InputProcessesFromLiveSystemMode) &&
		 !GetMode(InputDriversFromLiveSystemMode) &&
		 !GetMode(InputModulesDataFromFileSystemMode) &&
		 !GetMode(InputDmpFileMode) )
	{
		_tprintf(TEXT("\nAt least one input method must be specified!\n"));
		goto cleanup;
	}

	//
	// Can we use -BYIMAGE?  Only if we collected from the local machine...
	//
	if (GetMode(CopySymbolsToImage) && (GetMode(InputCSVFileMode) || GetMode(InputDmpFileMode)) )
	{
		_tprintf(TEXT("-BYIMAGE is not compatible with -I or -Z!\n"));
		goto cleanup;
	}

	// Enforce Overrides if necessary...
	if (fNOSOURCE && fSOURCEONLY)
	{
		_tprintf(TEXT("\n-NOSOURCE and -SOURCEONLY are incompatible options\n"));
		goto cleanup;
	}

	if (fNOSOURCE && fSOURCE)
	{
		_tprintf(TEXT("\n-NOSOURCE and -SOURCE are incompatible options\n"));
		goto cleanup;
	}

	// Silently upgrade a -SOURCE to -SOURCEONLY when both are implied
	if (fSOURCE && fSOURCEONLY)
	{
		m_enumSymbolSourcePreference = enumVerifySymbolsModeSourceSymbolsOnly;
	}

	// If you specify one of the Copy Symbol options, then verification is implied...
	if (GetMode(CopySymbolsToImage) || GetMode(BuildSymbolTreeMode))
	{
		SetMode(VerifySymbolsMode, true);
	}

	// If the user provided both a -I and a -P option, then silently ignore querying locally
	// for active processes... this will leave the possibility, however, of matching on
	// process ID or process name in the -I data...
	if ( GetMode(InputCSVFileMode) && ( GetMode(InputProcessesFromLiveSystemMode)))
	{
		SetMode(InputProcessesFromLiveSystemMode, false);
	}

	// If you've requested to output a CSV file, then default to full version and symbol collection by default...
	if (GetMode(OutputCSVFileMode) && (!GetMode(CollectVersionInfoMode) && !GetMode(OutputSymbolInformationMode) )
	    )
	{
		// Set them both...
		SetMode(CollectVersionInfoMode, true);
		SetMode(OutputSymbolInformationMode, true);
	}
	
	// Ensure that the input and output files aren't the same...
	if ( GetMode(InputCSVFileMode) && GetMode(OutputCSVFileMode) )
	{
		if (_tcscmp(m_tszInputCSVFilePath, m_tszOutputCSVFilePath) == 0)
		{
			_tprintf(TEXT("\nInput file and output file must be different!\n"));
			goto cleanup;
		}
	}

	// When user provides a symbol path explicitly, assume they also want to
	// verify symbols...
	if ( !GetMode(VerifySymbolsMode) && 
		  (
			 GetMode(VerifySymbolsModeWithSymbolPath) ||
			 GetMode(VerifySymbolsModeWithSymbolPathOnly) ||
			 GetMode(VerifySymbolsModeWithSymbolPathRecursion) ||
			 GetMode(VerifySymbolsModeWithSymbolPathRecursion) ||
			 GetMode(VerifySymbolsModeNotUsingDBGInMISCSection) ||
			 GetMode(VerifySymbolsModeWithSQLServer) ||
			 GetMode(VerifySymbolsModeWithSQLServer2)
		  )
		)
	{
		SetMode(VerifySymbolsMode, true);
	}
	// Inspect commandline options (for changes to these defaults)
	if ( GetMode(PrintTaskListMode) )
	{
		// Task list mode requires that you obtain process data, and print it...
		SetMode(InputProcessesFromLiveSystemMode, true);
		SetMode(QuietMode, false);
		SetMode(CollectVersionInfoMode, false);
		SetMode(VerifySymbolsModeWithSymbolPath, false);
		SetMode(InputCSVFileMode, false);
		SetMode(OutputCSVFileMode, false); 
		SetMode(OutputSymbolInformationMode, false);
	}

	// We can't build a symbol tree without verifying symbols...
	if ( GetMode(BuildSymbolTreeMode) && !GetMode(VerifySymbolsMode) )
	{
		SetMode(VerifySymbolsMode, true);
	}

	// If we're reading a dump file, we should collect symbol information (and we do not
	// want to read from a CSV file at the same time...
	if ( GetMode(InputDmpFileMode) )
	{
		// If the user didn't specify -V, then we should specify -S
		if (!GetMode(VerifySymbolsMode))
		{
			SetMode(OutputSymbolInformationMode, true);
		}
		SetMode(InputCSVFileMode, false);
	}

	// If we've enabled Symbol Verification, then we default to VerifySymbolsModeWithSymbolPath
	// if neither method were specified...
	if ( GetMode(VerifySymbolsMode) && 
		!GetMode(VerifySymbolsModeWithSymbolPath)  &&
		!GetMode(VerifySymbolsModeWithSQLServer) )
	{
		SetMode(VerifySymbolsModeWithSymbolPath, true);
	}

	fSuccess = true;

cleanup:

	if (lpSymbolPathsFile )
	{
		// Try and close the file this object is bound to...
		lpSymbolPathsFile->CloseFile();

		delete lpSymbolPathsFile;
		lpSymbolPathsFile = NULL;
	}

	if (tszTempBuffer)
	{
		delete [] tszTempBuffer;
		tszTempBuffer = NULL;
	}

	if (szTempBuffer)
	{
		delete [] szTempBuffer;
		szTempBuffer = NULL;
	}
	return fSuccess;
}


bool CProgramOptions::VerifySemiColonSeparatedPath(LPTSTR tszPath)
{
	enum { MAX_PATH_ELEMENT_LENGTH = MAX_PATH-12 }; // We append \SYMBOLS\EXT to the end of the symbol path
	if (!tszPath)
		return false;

	TCHAR chTemp;
	int iLength;
	LPTSTR tszPointerToDelimiter;
	LPTSTR tszStartOfPathElement = tszPath;
	tszPointerToDelimiter = _tcschr(tszStartOfPathElement, ';');

	if (tszPointerToDelimiter == NULL)
	{
		iLength = _tcslen(tszStartOfPathElement);
#ifdef DEBUG
		_tprintf(TEXT("DEBUG: Path provided = %s\n"), tszStartOfPathElement);
		_tprintf(TEXT("DEBUG: Path length = %d\n"), iLength);
#endif
		return ( iLength <= MAX_PATH_ELEMENT_LENGTH ); 
	}

	while (tszPointerToDelimiter)
	{
		// Okay, we found a delimiter
		chTemp = *tszPointerToDelimiter;	// Save the char away...
		*tszPointerToDelimiter = '\0';		// Null terminate the path element

		iLength = _tcslen(tszStartOfPathElement);

#ifdef DEBUG
		_tprintf(TEXT("DEBUG: Path provided = %s\n"), tszStartOfPathElement);
		_tprintf(TEXT("DEBUG: Path length = %d\n"), iLength);
#endif
		if( iLength > MAX_PATH_ELEMENT_LENGTH )
		{
			_tprintf(TEXT("Path is too long for element [%s]\n"), tszStartOfPathElement);
			*tszPointerToDelimiter = chTemp;
			return false;
		}

		*tszPointerToDelimiter = chTemp;	// Restore the char...

		tszStartOfPathElement = CharNext(tszPointerToDelimiter); // Set new start of path element

		tszPointerToDelimiter = _tcschr(tszStartOfPathElement, ';'); // Look for next delimiter

	}
	
	// We will always have some part left to look at...
	iLength = _tcslen(tszStartOfPathElement);

#ifdef DEBUG
	_tprintf(TEXT("DEBUG: Path provided = %s\n"), tszStartOfPathElement);
	_tprintf(TEXT("DEBUG: Path length = %d\n"), iLength);
#endif

	return ( iLength <= MAX_PATH_ELEMENT_LENGTH );
}

bool CProgramOptions::fDoesModuleMatchOurSearch(LPCTSTR tszModulePathToTest)
{
	// If "-MATCH" was specified, look to see if this filename meets our criteria
	if (!GetMode(MatchModuleMode))
		return true;

	TCHAR tszTestBuffer[_MAX_PATH];

	// Before we copy to our string
	if (_tcslen(tszModulePathToTest) > _MAX_PATH)
		return false;

	// Copy to a read/write buffer...
	_tcscpy(tszTestBuffer, tszModulePathToTest);

	// Upper case for our test...
	_tcsupr(tszTestBuffer);

	return (_tcsstr(tszTestBuffer, GetModuleToMatch()) != NULL);
}

bool CProgramOptions::DisplayProgramArguments()
{
	if (GetMode(QuietMode) || GetMode(PrintTaskListMode))
		return false;

	CUtilityFunctions::OutputLineOfStars();
#ifdef _UNICODE
	_tprintf(TEXT("CHECKSYM V%S - Symbol Verification Program\n"), VERSION_FILEVERSIONSTRING);
#else
	_tprintf(TEXT("CHECKSYM V%s - Symbol Verification Program\n"), VERSION_FILEVERSIONSTRING);
#endif
	CUtilityFunctions::OutputLineOfStars();

	_tprintf(TEXT("\n***** COLLECTION OPTIONS *****\n"));
	
	// INPUT - FIRST, IF WE'RE LOOKING FOR LOCAL PROCESS DATA ON THIS MACHINE!
	if (GetMode(InputProcessesFromLiveSystemMode))
	{
		_tprintf(TEXT("\nCollect Information From Running Processes\n"));

		if (m_fWildCardMatch)
		{
			_tprintf(TEXT("\t-P *\t\t(Query all local processes)\n"));
		} else
		{
			if (m_cProcessIDs)
			{
				for (unsigned int i=0; i< m_cProcessIDs; i++)
				{
					_tprintf(TEXT("\t-P %d\t\t(Query for specific process ID)\n"), m_rgProcessIDs[i]);
				}
			}

			if (m_cProcessNames)
			{
				for (unsigned int i=0; i< m_cProcessNames; i++)
				{
					_tprintf(TEXT("\t-P %s\t\t(Query for specific process by name)\n"), m_rgtszProcessNames[i]);
				}
			}
		}
	}

	if (GetMode(InputDriversFromLiveSystemMode))
	{
		_tprintf(TEXT("\t-D\t\t(Query all local device drivers)\n"));
	}
	// INPUT - SECOND, IF WE'RE SCAVENGING ON THE LOCAL FILE SYSTEM...
	if (GetMode(InputModulesDataFromFileSystemMode))
	{
		_tprintf(TEXT("\nCollect Information From File(s) Specified by the User\n"));
		_tprintf(TEXT("\t-F %s\n"), m_tszInputModulesDataFromFileSystemPath);

		if (m_fFileSystemRecursion)
		{
			_tprintf(TEXT("\t   (Search for Files with Recursion Specified)\n"));
		}
	}

	// INPUT - THIRD, CSV FILE
	if (GetMode(InputCSVFileMode))
	{
		_tprintf(TEXT("\nCollect Information from a Saved Checksym Generated CSV File\n"));
		_tprintf(TEXT("\t-I %s\n"), m_tszInputCSVFilePath);
	}

	// INPUT - FOURTH, DMP FILE
	if (GetMode(InputDmpFileMode))
	{
		_tprintf(TEXT("\nCollect Information from a User.Dmp or Memory.Dmp File\n"));
		_tprintf(TEXT("\t-Z %s\n"), m_tszInputDmpFilePath);
	}

	// MATCH - OPTIONS?
	if (GetMode(MatchModuleMode))
	{
		_tprintf(TEXT("\n***** MATCHING OPTIONS *****\n"));
		_tprintf(TEXT("\n"));
		_tprintf(TEXT("\nLook for Modules that Match the Provided Text\n"));
		_tprintf(TEXT("\t-MATCH %s\n"), m_tszModuleToMatch);
	}
	
	_tprintf(TEXT("\n***** INFORMATION CHECKING OPTIONS *****\n"));

	// INFO - FIRST, SYMBOL INFO
	if (GetMode(OutputSymbolInformationMode))
	{
		_tprintf(TEXT("\nOutput Symbol Information From Modules\n"));
		_tprintf(TEXT("\t-S\n"));
	}

	// INFO - FIRST, SYMBOL INFO
	if (GetMode(VerifySymbolsMode))
	{
		_tprintf(TEXT("\nVerify Symbols Locally Using Collected Symbol Information\n"));
		_tprintf(TEXT("\t-V\n"));
	}

	// INFO - SECOND, VERSION INFO
	if (GetMode(CollectVersionInfoMode))
	{
		_tprintf(TEXT("\nCollect Version and File-System Information From Modules\n"));
		_tprintf(TEXT("\t-R\n"));
	}

	// INFO - THIRD, VERIFY MODE (WITH SYMBOL PATH AND/OR SQL SERVER)
	if (GetMode(VerifySymbolsMode))
	{
		if (GetMode(VerifySymbolsModeWithSymbolPath))
		{
			_tprintf(TEXT("\nVerify Symbols for Modules Using Symbol Path\n"));
			_tprintf(TEXT("\t-Y %s\n"), m_tszSymbolPath);

			if (GetMode(VerifySymbolsModeWithSymbolPathOnly))
			{
				_tprintf(TEXT("\t   (Verify Symbols from Symbol Path Only Specified)\n"));
			}

			if (GetMode(VerifySymbolsModeWithSymbolPathRecursion))
			{
				_tprintf(TEXT("\t   (Verify Symbols With Recursion Specified)\n"));
			}
			
			if (GetMode(VerifySymbolsModeNotUsingDBGInMISCSection))
			{
				_tprintf(TEXT("\t   (Verify Symbols With No Regard to MISC section for DBG files)\n"));
			}

		}

		// If EXEPATH provided, use it!
		if (m_tszExePath)
		{
			_tprintf(TEXT("\nVerify Symbols for Modules Using EXEPATH Path\n"));
			_tprintf(TEXT("\t-EXEPATH %s\n"), m_tszExePath);
		}

		if (GetMode(VerifySymbolsModeWithSQLServer))
		{
			_tprintf(TEXT("\nVerify Symbols for Modules Using SQL Server\n"));
			_tprintf(TEXT("\t-SQL %s\n"), m_tszSQLServer);
		}
		
		if (GetMode(VerifySymbolsModeWithSQLServer2))
		{
			_tprintf(TEXT("\nVerify Symbols for Modules Using SQL Server\n"));
			_tprintf(TEXT("\t-SQL2 %s\n"), m_tszSQLServer2);
		}
	}

	// Check for -NOISY
	if (m_dwDebugLevel == enumDebugSearchPaths)
	{
		_tprintf(TEXT("\nOutput internal paths used during search for symbols\n"));
		_tprintf(TEXT("\t-NOISY\n"));
	}

	// Check for -SOURCE
	if (GetSymbolSourceModes() == enumVerifySymbolsModeSourceSymbolsPreferred)
	{
		_tprintf(TEXT("\nSymbols with Source are preferred (search behavior change)\n"));
		_tprintf(TEXT("\t-SOURCE\n"));
	}

	// Check for -SOURCEONLY
	if (GetSymbolSourceModes() == enumVerifySymbolsModeSourceSymbolsOnly)
	{
		_tprintf(TEXT("\nSymbols with Source are REQUIRED (search behavior change)\n"));
		_tprintf(TEXT("\t-SOURCEONLY\n"));
	}
	// Check for -NOSOURCE
	if (GetSymbolSourceModes() == enumVerifySymbolsModeSourceSymbolsNotAllowed)
	{
		_tprintf(TEXT("\nSymbols with Source are NOT ALLOWED (search behavior change)\n"));
		_tprintf(TEXT("\t-NOSOURCE\n"));
	}

	if (!GetMode(OutputSymbolInformationMode) &&
		!GetMode(CollectVersionInfoMode) &&
		!GetMode(VerifySymbolsMode)
	   )
	{
		_tprintf(TEXT("\nDump Module Paths\n"));
	}

	_tprintf(TEXT("\n***** OUTPUT OPTIONS *****\n"));

	if (!GetMode(QuietMode))
	{
		_tprintf(TEXT("\nOutput Results to STDOUT\n"));
	}

	if (GetMode(BuildSymbolTreeMode))
	{
		_tprintf(TEXT("\nBuild a Symbol Tree of Matching Symbols\n"));
		_tprintf(TEXT("\t-B %s\n"), m_tszSymbolTreeToBuild);
	}

	if (GetMode(CopySymbolsToImage))
	{
		_tprintf(TEXT("\nCopy Matching Symbols Beside the Module\n"));
		_tprintf(TEXT("\t-BYIMAGE\n"));
	}

	if (GetMode(OutputCSVFileMode))
	{
		if (GetMode(ExceptionMonitorMode))
		{
			_tprintf(TEXT("\nOutput Collected Module Information To a CSV File In Exception Monitor Format\n"));
		} else
		{
			_tprintf(TEXT("\nOutput Collected Module Information To a CSV File\n"));
		}

		_tprintf(TEXT("\t-O %s\n"), m_tszOutputCSVFilePath);
	}

	CUtilityFunctions::OutputLineOfDashes();
	return true;
}


void CProgramOptions::DisplayHelp()
{
	CUtilityFunctions::OutputLineOfStars();
#ifdef _UNICODE
	_tprintf(TEXT("CHECKSYM V%S - Symbol Verification Program\n"), VERSION_FILEVERSIONSTRING);
#else
	_tprintf(TEXT("CHECKSYM V%s - Symbol Verification Program\n"), VERSION_FILEVERSIONSTRING);
#endif
	CUtilityFunctions::OutputLineOfStars();
	_tprintf(TEXT("\n"));
#ifdef _UNICODE
	_tprintf(TEXT("This version is supported for Windows NT 4.0, Windows 2000 and Windows XP\n"));
#else
	_tprintf(TEXT("This version is supported for Windows 98/ME, Windows NT 4.0, Windows 2000 and Windows XP\n"));
#endif
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("DESCRIPTION:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("This program can be used to verify that you have proper symbol files\n"));
	_tprintf(TEXT("(*.DBG and/or *.PDB) on your system for the processes you have running, and\n"));
	_tprintf(TEXT("for symbol files on your filesystem.  This program can also be used to\n"));
	_tprintf(TEXT("collect information regarding these modules and output this to a file.\n"));
	_tprintf(TEXT("The output file can then be given to another party (Microsoft Product\n"));
	_tprintf(TEXT("Support Services) where they can use the file to verify that they have\n"));
	_tprintf(TEXT("proper symbols for debugging your environment.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Obtaining online help:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM -?      : Simple help usage\n"));
	_tprintf(TEXT("CHECKSYM -???    : Complete help usage (this screen)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Usage:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM [COLLECTION OPTIONS] [INFORMATION CHECKING OPTIONS] [OUTPUT OPTIONS]\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** COLLECTION OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("At least one collection option must be specified.  The following options are\n"));
	_tprintf(TEXT("currently supported.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("   -P <Argument> : Collect Information From Running Processes\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   When used in conjunction with -O the output file will\n"));
	_tprintf(TEXT("                   contain information about your running system.  This\n"));
	_tprintf(TEXT("                   operation should not interfere with the operation of\n"));
	_tprintf(TEXT("                   running processes.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   <Argument> = [ * | Process ID (pid) | Process Name ]\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   Multiple arguments can be combined together to query\n"));
	_tprintf(TEXT("                   multiple PIDs or processes.  Separate each argument with\n"));
	_tprintf(TEXT("                   a semi-colon.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   For example,\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -P 123;234;NOTEPAD.EXE;CMD.EXE\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   would return only these four process matches.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   To query all running processes, specify the wildcard\n"));
	_tprintf(TEXT("                   character '*'.  To specify a specific process, you can\n"));
	_tprintf(TEXT("                   provide the Process ID (as a decimal value), or the Process\n"));
	_tprintf(TEXT("                   Name (eg. notepad.exe).  If you use the Process Name as the\n"));
	_tprintf(TEXT("                   argument, and multiple instances of that process are\n"));
	_tprintf(TEXT("                   running they will all be inspected.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -D : Collect Information from Running Device Drivers\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option will obtain information for all device drivers\n"));
	_tprintf(TEXT("                   (*.SYS files) running on the current system.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("-F[<blank>|1|2] <File/Dir Path>: Collect Information From File System\n"));	
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option will allow you to obtain module information\n"));
	_tprintf(TEXT("                   for modules on the specified path.  Multiple paths may be\n"));
	_tprintf(TEXT("                   provided, separated by semicolons.  This input method is\n"));
	_tprintf(TEXT("                   useful for situations where the module(s) is not loaded by\n"));
	_tprintf(TEXT("                   an active process.  (Eg. Perhaps a process is unable to start\n"));
	_tprintf(TEXT("                   or perhaps you simply want to collect information.)\n"));
	_tprintf(TEXT("                   about files from a particular directory location.)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -F or -F1 : (Default) A file or directory may be provided.  If \n"));
	_tprintf(TEXT("                               a file is specified, it is evaluted.  If a directory\n"));
	_tprintf(TEXT("                               is provided then the files matching any provided wild-\n"));
	_tprintf(TEXT("                               cards are searched.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -F2       : Same as -F except recursion will be used.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   PSEUDO-ENVIRONMENT VARIABLES\n"));
	_tprintf(TEXT("                   Checksym supports environment variables used where ever paths\n"));
	_tprintf(TEXT("                   are provided (i.e. %%systemroot%% is a valid environment variable).\n"));
	_tprintf(TEXT("                   Checksym also supports a limited set of \"pseudo-environment\"\n"));
	_tprintf(TEXT("                   variables which you can provide in an location a normal environment\n"));
	_tprintf(TEXT("                   variable is allowed.  These pseudo-environment variables expand\n"));
	_tprintf(TEXT("                   into the appropriate installation directory for the product they\n"));
	_tprintf(TEXT("                   are associated with.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   Here are all the pseudo-environment variables currently supported:\n"));
	_tprintf(TEXT("\n"));

	for (int i = 0; g_tszEnvironmentVariables[i].tszEnvironmentVariable; i++)
	{
		_tprintf(TEXT("                   %%%s%%\t= %s\n"), g_tszEnvironmentVariables[i].tszEnvironmentVariable, g_tszEnvironmentVariables[i].tszFriendlyProductName);
	}

	_tprintf(TEXT("\n"));
	_tprintf(TEXT("  -I <File Path> : Collect Information from a Saved Checksym Generated CSV File\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This input method is useful when you want to evaluate\n"));
	_tprintf(TEXT("                   whether you have proper symbols for modules on a different\n"));
	_tprintf(TEXT("                   system.  Most commonly this is useful for preparing to do a\n"));
	_tprintf(TEXT("                   remote debug of a remote system.  The use of -I prohibits\n"));
	_tprintf(TEXT("                   the use of other collection options.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("  -Z <File Path> : Collect Information from a DMP File\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This input method is useful when you have a DMP file and\n"));
	_tprintf(TEXT("                   to ensure that you have matching symbols for it.  Checksym\n"));
	_tprintf(TEXT("                   tries to determine as much information as possible to\n"));
	_tprintf(TEXT("                   in finding good symbols.  If a module name can not be\n"));
	_tprintf(TEXT("                   determined (mostly with modules that only use PDB files),\n"));
	_tprintf(TEXT("                   the module will be listed as \"IMAGE<Virtual Address>\".\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("   -MATCH <Text> : Collect Modules that match text only\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option allows you to restrict searching/collection to\n"));
	_tprintf(TEXT("                   include only those modules that match the provided text.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** INFORMATION CHECKING OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -S : Collect/Display Symbol Information From Modules\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option is used to indicate that symbol information\n"));
	_tprintf(TEXT("                   should be collected and displayed from every module analyzed.\n"));
	_tprintf(TEXT("                   In order to verify proper symbols, symbol information must\n"));
	_tprintf(TEXT("                   be gathered.  It is possible to collect symbol information\n"));
	_tprintf(TEXT("                   without verifying it.  This case is usually used with the -O\n"));
	_tprintf(TEXT("                   option to produce a saved CheckSym generated CSV file.\n"));
	_tprintf(TEXT("                   Omitting -S and -V could direct CheckSym to collect only\n"));
	_tprintf(TEXT("                   version information (if -R is specified), or no information\n"));
	_tprintf(TEXT("                   (if no information checking options are specified.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -R : Collect Version and File-System Information From Modules\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option requests checksym to collect the following\n"));
	_tprintf(TEXT("                   information from the file-system and version information\n"));
	_tprintf(TEXT("                   structure (if any):\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                        File Version\n"));
	_tprintf(TEXT("                        Company Name\n"));
	_tprintf(TEXT("                        File Description\n"));
	_tprintf(TEXT("                        File Size (bytes)\n"));
	_tprintf(TEXT("                        File Date/Time\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT(" -V[<blank>|1|2] : Verify Symbols for Modules\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option uses the symbol information gathered (-S option)\n"));
	_tprintf(TEXT("                   to verify that proper symbols exist (as found along the\n"));
	_tprintf(TEXT("                   symbol path.  Use of -V implies -S when module collection is\n"));
	_tprintf(TEXT("                   initiated.  There are different levels of symbol\n"));
	_tprintf(TEXT("                   verification:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -V or -V1 : (Default) This treats symbol files that match\n"));
	_tprintf(TEXT("                               the module's time/date stamp, but have an wrong\n"));
	_tprintf(TEXT("                               checksum or size of image as valid symbols.  This\n"));
	_tprintf(TEXT("                               is the default behavior and these symbols are\n"));
	_tprintf(TEXT("                               typically valid.  (Localization processes often\n"));
	_tprintf(TEXT("                               cause the size of image and/or checksum to be altered\n"));
	_tprintf(TEXT("                               but the symbol file is still valid.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -V2       : Only if checksum, size of image AND time/date stamp\n"));
	_tprintf(TEXT("                               match is the symbol considered valid.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("-Y[I][<blank>|1|2] <Symbol Path> : Verify Symbols Using This Symbol Path\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This is a semi-colon separated search path for looking for\n"));
	_tprintf(TEXT("                   symbols.  This path is searched with the -V option.  -Y now\n"));
	_tprintf(TEXT("                   supports the use of SYMSRV for symbol searching.  An\n"));
	_tprintf(TEXT("                   example usage would be a symbol path that resembles:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Y SYMSRV*SYMSRV.DLL*\\\\SYMBOLS\\SYMBOLS\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   Or this more compact form which expands to the one above:\n"));
	_tprintf(TEXT("                   -Y SRV*\\\\SYMBOLS\\SYMBOLS\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   The default value is %%systemroot%%\\symbols\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -YI       : This option allows you to specify a text file\n"));
	_tprintf(TEXT("                               which contains the symbol paths you would like\n"));
	_tprintf(TEXT("                               to use.  Many people create a text file of their\n"));
	_tprintf(TEXT("                               favorite symbol paths, use this option to specify\n"));
	_tprintf(TEXT("                               that file.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                               Example:\n"));
	_tprintf(TEXT("                               -YI C:\\temp\\MySymbolPaths.txt\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                               You can specify modifers to -YI but they must follow\n"));
	_tprintf(TEXT("                               the -YI option (i.e. -YI2 for recursion of all the\n"));
	_tprintf(TEXT("                               paths specified by the symbol path file).\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Y        : (Default) This searches for symbols in the\n"));
	_tprintf(TEXT("                               symbol paths using the behavior typical of the\n"));
	_tprintf(TEXT("                               debuggers.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   NOTE: For the options below you can add the numbers together\n"));
	_tprintf(TEXT("                         to specify combinations of options.  -Y7 would be all of\n"));
	_tprintf(TEXT("                         the combinations for example.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Y1       : This searches for symbols using only the provided\n"));
	_tprintf(TEXT("                               symbol path and does not use other locations found\n"));
	_tprintf(TEXT("                               such as those found in the Debug Directories section\n"));
	_tprintf(TEXT("                               of the PE image.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Y2       : This searches for symbols in the symbol paths\n"));
	_tprintf(TEXT("                               provided using a recursive search algorithm.\n"));
	_tprintf(TEXT("                               This option is most useful when used with -B to\n"));
	_tprintf(TEXT("                               build a symbol tree.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Y4       : This searches for symbols in the symbol paths\n"));
	_tprintf(TEXT("                               but for DBG files does NOT use the entry in\n"));
	_tprintf(TEXT("                               the MISC section of the image.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("-EXEPATH <Exe Path> : Verify Symbols for Modules Using Executable Path\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   Minidump files require that the actual matching binary images\n"));
	_tprintf(TEXT("                   are present.  If a dumpfile is being opened and an EXEPATH is\n"));
	_tprintf(TEXT("                   is not specified, Checksym will default the EXEPATH to the\n"));
	_tprintf(TEXT("                   symbol path.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("          -NOISY : Output internal paths used during search for symbols\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("         -SOURCE : Symbols with Source are PREFERRED (search behavior change)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option directs CheckSym to continue searching until a\n"));
	_tprintf(TEXT("                   symbol is found with Source Info if possible.  Normally,\n"));
	_tprintf(TEXT("                   CheckSym terminates searching when any matching symbol is\n"));
	_tprintf(TEXT("                   found.  This option forces CheckSym to continue searching\n"));
	_tprintf(TEXT("                   for source enabled symbols which can result in longer\n"));
	_tprintf(TEXT("                   searches potentially.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     -SOURCEONLY : Symbols with Source are REQUIRED (search behavior change)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option directs CheckSym to continue searching until a\n"));
	_tprintf(TEXT("                   symbol is found with Source Info.  A symbol is considered\n"));
	_tprintf(TEXT("                   a match only if it also contains Source Info.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("       -NOSOURCE : Symbols with Source are NOT ALLOWED (search behavior change)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option directs CheckSym to continue searching until a\n"));
	_tprintf(TEXT("                   symbol is found with no Source Info.  A symbol is considered\n"));
	_tprintf(TEXT("                   a match only if it does NOT contain Source Info.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   Using this option with -B can be a useful way to create a symbol\n"));
	_tprintf(TEXT("                   tree for customers since it would limit the symbols to those\n"));
	_tprintf(TEXT("                   without Source Info (proprietary information).\n"));
	_tprintf(TEXT("\n"));
/*	
	// We're going to hide this option in the help text since this may go out to the public...

	_tprintf(TEXT("-SQL <servername>: Collect symbol file location from the provided SQL\n"));
	_tprintf(TEXT("                   servername.  A hardcoded username/password is currently\n"));
	_tprintf(TEXT("                   being used.  A SQL server you can point to is \"BPSYMBOLS\"\n"));
	_tprintf(TEXT("                   though this can change at anytime.\n"));
	_tprintf(TEXT("\n"));
*/
	_tprintf(TEXT("***** OUTPUT OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT(" -B <Symbol Dir> : Build a Symbol Tree of Matching Symbols\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option will create a new symbol tree for ALL matching\n"));
	_tprintf(TEXT("                   symbols that are found through the verification process\n"));
	_tprintf(TEXT("                   (-v option). This option is particularly useful when used\n"));
	_tprintf(TEXT("                   with the -Y option when many symbol paths are specified\n"));
	_tprintf(TEXT("                   and you want to build a single tree for a debug.\n"));
	_tprintf(TEXT("\n"));

	_tprintf(TEXT("        -BYIMAGE : Copy Matching Symbols Adjacent to Modules\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option will copy matching symbols next to the module\n"));
	_tprintf(TEXT("                   it matches.  This can be useful for interoperability with some\n"));
	_tprintf(TEXT("                   debuggers that have difficulties finding matching symbols\n"));
	_tprintf(TEXT("                   using a symbol tree or symbol path.\n"));
	_tprintf(TEXT("\n"));
	
	_tprintf(TEXT("           -PERF : Display Preferred Load Address vs Actual Load Address\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   There is a performance penalty when a module does not load\n"));
	_tprintf(TEXT("                   at it's preferred load address.  Tools like REBASE.EXE can\n"));
	_tprintf(TEXT("                   be used to change the preferred load address.  After using\n"));
	_tprintf(TEXT("                   REBASE.EXE, BIND.EXE can be used to fixup import tables for\n"));
	_tprintf(TEXT("                   more performance improvements.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("   -Q[<blank>|2] : Quiet modes (no screen output, or minimal screen output)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   The default behavior is to print out the data to the\n"));
	_tprintf(TEXT("                   console window (stdout).  If the process terminates with an\n"));
	_tprintf(TEXT("                   error, it will print out these (overriding -Q).\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Q2       : This option prints out a module ONLY if a symbol\n"));
	_tprintf(TEXT("                               problem exists.  (Not completely quiet mode!)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("-O[<blank>|1|2] <File Path> : Output Collected Module Information To a CSV File\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   For this file to to be used as input (-I) to verify good\n"));
	_tprintf(TEXT("                   symbols for this system, the -S option should also be used.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -O or -O1 : (Default)  This output mode requires that the\n"));
	_tprintf(TEXT("                               file does not exist.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -O2       : Specifying a -O2 will allow the output file\n"));
	_tprintf(TEXT("                               to be OVERWRITTEN if it exists.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -T : Task List Output\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   Prints out a task list on the local machine (similar to the\n"));
	_tprintf(TEXT("                   TLIST utility).  This option implies the use of -P (querying\n"));
	_tprintf(TEXT("                   the local system for active processes.  You can provide the\n"));
	_tprintf(TEXT("                   -P command explicitly (if you want to provide an argument,\n"));
	_tprintf(TEXT("                   for instance).  If -P is not specified explicitly, then it\n"));
	_tprintf(TEXT("                   defaults to -P *.  Also, -T overrides -Q since TLIST\n"));
	_tprintf(TEXT("                   behavior is to print to the console window.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** TYPICAL USAGE EXAMPLES *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to verify the symbols for files in a directory (%%SYSTEMROOT%%\\SYSTEM32)\n"));
	_tprintf(TEXT("in the default symbol directory (%%SYSTEMROOT%%\\SYMBOLS)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -F %%SYSTEMROOT%%\\SYSTEM32 -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to do the same search, but for only executables...\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -F %%SYSTEMROOT%%\\SYSTEM32\\*.EXE -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to search a directory using multiple symbol paths...\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -F %%SYSTEMROOT%%\\SYSTEM32\\ -V -Y V:\\nt40sp4;V:\\nt40rtm\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to know what modules are loaded for a process (and the path to each)\n"));
	_tprintf(TEXT("Start NOTEPAD.EXE, and then type:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P NOTEPAD.EXE\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to know if you have good symbols for a process (notepad.exe).\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P NOTEPAD.EXE -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to know the file version for every module loaded by a process.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P NOTEPAD.EXE -R\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to know if you have good symbols for ALL processes on your machine.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P * -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** ADVANCED USAGE EXAMPLES *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You are going to prepare to debug a remote system, and you want to ensure\n"));
	_tprintf(TEXT("that you have good symbols locally for debugging the remote system.  You want\n"));
	_tprintf(TEXT("to verify this prior to initiating the debug session.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Use checksym twice, once on the remote system to gather information and create\n"));
	_tprintf(TEXT("an output file, and then once on your system using the output file created\n"));
	_tprintf(TEXT("as an input argument.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("For example, run this on the remote system\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P * -S -R -O C:\\TEMP\\PROCESSES.CSV\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("The C:\\TEMP\\PROCESSES.CSV file will contain a wealth of information about\n"));
	_tprintf(TEXT("the processes that were running, and the modules loaded by every process.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Now, get the output file from the remote system, and copy it locally.  Then\n\n"));
	_tprintf(TEXT("run CHECKSYM again, using the file as an input argument...\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -I C:\\TEMP\\PROCESSES.CSV -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Another useful option is -B (build a symbol tree).  It allows you to update\n"));
	_tprintf(TEXT("or create a symbol tree that contains matching symbols.  If you have to use\n"));
	_tprintf(TEXT("many symbol paths in order to have correct symbols available to a debugger,\n"));
	_tprintf(TEXT("can use the -B option to build a single symbol tree to simplify debugging.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P * -B C:\\MySymbols -V -Y V:\\Nt4;V:\\Nt4Sp6a;V:\\NtHotfixes\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** DEFAULT BEHAVIOR *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("The default behavior of CHECKSYM when no arguments are provided is:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM -?    (Display simple help)\n"));
}

void CProgramOptions::DisplaySimpleHelp()
{
	CUtilityFunctions::OutputLineOfStars();
#ifdef _UNICODE
	_tprintf(TEXT("CHECKSYM V%S - Symbol Verification Program\n"), VERSION_FILEVERSIONSTRING);
#else
	_tprintf(TEXT("CHECKSYM V%s - Symbol Verification Program\n"), VERSION_FILEVERSIONSTRING);
#endif
	CUtilityFunctions::OutputLineOfStars();
	_tprintf(TEXT("\n"));
#ifdef _UNICODE
	_tprintf(TEXT("This version supports Windows NT 4.0 and Windows 2000\n"));
#else
	_tprintf(TEXT("This version supports Windows 98, Windows NT 4.0 and Windows 2000\n"));
#endif
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Obtaining online help:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM -?      : Simple help usage (this screen)\n"));
	_tprintf(TEXT("CHECKSYM -???    : Complete help usage\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Usage:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM [COLLECTION OPTIONS] [INFORMATION CHECKING OPTIONS] [OUTPUT OPTIONS]\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** COLLECTION OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("At least one collection option must be specified.  The following options are\n"));
	_tprintf(TEXT("currently supported.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("   -P <Argument> : Collect Information From Running Processes\n"));
	_tprintf(TEXT("              -D : Collect Information from Running Device Drivers\n"));
	_tprintf(TEXT("-F[<blank>|1|2] <File/Dir Path>: Collect Information From File System\n"));
	_tprintf(TEXT("  -I <File Path> : Collect Information from a Saved Checksym Generated CSV File\n"));
	_tprintf(TEXT("  -Z <File Path> : Collect Information from a DMP File\n"));
	_tprintf(TEXT("   -MATCH <Text> : Collect Modules that match text only\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** INFORMATION CHECKING OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -S : Collect Symbol Information From Modules\n"));
	_tprintf(TEXT("              -R : Collect Version and File-System Information From Modules\n"));
	_tprintf(TEXT(" -V[<blank>|1|2] : Verify Symbols for Modules\n"));
	_tprintf(TEXT("-Y[I][<blank>|1|2] <Symbol Path> : Verify Symbols Using This Symbol Path\n"));
	_tprintf(TEXT("-EXEPATH <Exe Path> : Verify Symbols for Modules Using Executable Path\n"));
	_tprintf(TEXT("          -NOISY : Output internal paths used during search for symbols\n"));
	_tprintf(TEXT("         -SOURCE : Symbols with Source are preferred (search behavior change)\n"));
	_tprintf(TEXT("     -SOURCEONLY : Symbols with Source are REQUIRED (search behavior change)\n"));
	_tprintf(TEXT("       -NOSOURCE : Symbols with Source are NOT ALLOWED (search behavior change)\n"));
	_tprintf(TEXT("\n"));
/*	
	// We're going to hide this option in the help text since this may go out to the public...

	_tprintf(TEXT("-SQL <servername>: Collect symbol file location from the provided SQL\n"));
	_tprintf(TEXT("\n"));
*/
	_tprintf(TEXT("***** OUTPUT OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT(" -B <Symbol Dir> : Build a Symbol Tree of Matching Symbols\n"));
	_tprintf(TEXT("        -BYIMAGE : Copy Matching Symbols Adjacent to Modules\n"));
	_tprintf(TEXT("           -PERF : Display Preferred Load Address vs Actual Load Address\n"));
	_tprintf(TEXT("   -Q[<blank>|2] : Quiet modes (no screen output, or minimal screen output)\n"));
/*
	// We're going to hide this option in the help text since this may go out to the public...
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -E : This modifier abreviates the output from this program\n"));
*/
	_tprintf(TEXT("-O[<blank>|1|2] <File Path> : Output Collected Module Information To a CSV File\n"));
	_tprintf(TEXT("              -T : Task List Output\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** DEFAULT BEHAVIOR *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("The default behavior of CHECKSYM when no arguments are provided is:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM -?    (Display simple help)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("For more usage information run CHECKSYM -???\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CheckSym.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\symbolverification.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       symbolverification.h
//
//--------------------------------------------------------------------------

// SymbolVerification.h: interface for the CSymbolVerification class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYMBOLVERIFICATION_H__1643E486_AD71_11D2_83DE_0010A4F1B732__INCLUDED_)
#define AFX_SYMBOLVERIFICATION_H__1643E486_AD71_11D2_83DE_0010A4F1B732__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include <comdef.h>

// Support for new MSDIA20.DLL Symbol Handling (Supports VC 7.0 PDB formats)
#include <atlbase.h>
#include "dia2.h"
#include "diacreate.h"

//
//#include "oemdbi.h"
//
// Bug MSINFO V4.1:655 - Link to static msdbi60l.lib
#define PDB_LIBRARY
#pragma warning( push )
#pragma warning( disable : 4201 )		// Disable "nonstandard extension used : nameless struct/union" warning
#include "PDB.H"
#pragma warning( pop )

typedef char *          SZ;

// ADO Import
// #define INITGUID
// #import "C:\temp\msado15.dll" no_namespace rename("EOF", "EndOfFile")
#include "msado15.tlh"

//
// Q177939 - INFO: Changes in ADO 1.5 That Affect Visual C++/J++ Programmers[adobj]
//
// #include <initguid.h>    // Newly Required for ADO 1.5.
// #include <adoid.h>
// #include <adoint.h>

// Forward Declarations
class CModuleInfo;

class CSymbolVerification  
{
public:
	CSymbolVerification();
	virtual ~CSymbolVerification();

	bool Initialize();

	bool InitializeSQLServerConnection(LPTSTR tszSQLServerName);
	bool InitializeSQLServerConnection2(LPTSTR tszSQLServerName);  // mjl

	inline bool SQLServerConnectionInitialized() {
		return m_fSQLServerConnectionInitialized;
		};
	
	inline bool SQLServerConnectionInitialized2() {
		return m_fSQLServerConnectionInitialized2;
		};

	inline bool SQLServerConnectionAttempted() {
		return m_fSQLServerConnectionAttempted;
		};

	inline bool SQLServerConnectionAttempted2() {
		return m_fSQLServerConnectionAttempted2;
		};

	inline bool DiaDataSourcePresent() {
		return m_fDiaDataSourcePresent;
	};

	HRESULT InitializeDIASupport();
	
//	inline CComPtr<IDiaDataSource> GetDiaDataSource() {
//		return m_lpDiaDataSource;
//	};

	static HRESULT diaGetDataSource(CComPtr<IDiaDataSource> & source);
	static bool diaOldPdbFormatFound(GUID * guid, DWORD sig);
	static bool ValidGUID(GUID * guid);
	//static bool ValidSig(DWORD sig, GUID * guid);
	
	bool SearchForDBGFileUsingSQLServer(LPTSTR tszPEImageModuleName, DWORD dwPEImageTimeDateStamp, CModuleInfo * lpModuleInfo);
	bool SearchForDBGFileUsingSQLServer2(LPTSTR tszPEImageModuleName, DWORD dwPEImageTimeDateStamp, CModuleInfo * lpModuleInfo);
	bool SearchForPDBFileUsingSQLServer2(LPTSTR tszPEImageModuleName, DWORD dwPDBSignature, CModuleInfo * lpModuleInfo);
	bool TerminateSQLServerConnection();
	bool TerminateSQLServerConnection2();

protected:
	bool m_fComInitialized;
	bool m_fSQLServerConnectionAttempted;
	bool m_fSQLServerConnectionAttempted2;  // SQL2 - mjl 12/14/99

	void DumpCOMException(_com_error &e);

	bool m_fSQLServerConnectionInitialized;
	bool m_fSQLServerConnectionInitialized2;	// SQL2 - mjl 12/14/99

	_ConnectionPtr m_lpConnectionPointer;
	_RecordsetPtr  m_lpRecordSetPointer;

	_ConnectionPtr m_lpConnectionPointer2;		// SQL2 - mjl 12/14/99
	_RecordsetPtr  m_lpRecordSetPointer2;		// SQL2 - mjl 12/14/99

	CComPtr<IDiaDataSource> m_lpDiaDataSource;

	bool m_fDiaDataSourcePresent;

};

#endif // !defined(AFX_SYMBOLVERIFICATION_H__1643E486_AD71_11D2_83DE_0010A4F1B732__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\programoptions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       programoptions.h
//
//--------------------------------------------------------------------------

// ProgramOptions.h: interface for the CProgramOptions class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROGRAMOPTIONS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_)
#define AFX_PROGRAMOPTIONS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>

class CProgramOptions  
{
	static const LPTSTR g_DefaultSymbolPath;

public:
	bool fDoesModuleMatchOurSearch(LPCTSTR tszModulePathToTest);
	void DisplaySimpleHelp();
	void DisplayHelp();
	CProgramOptions();
	virtual ~CProgramOptions();

	bool Initialize();
	
	bool ProcessCommandLineArguments(int argc, TCHAR *argv[]);

	// We're going to perform bitwise operations on any number after the -Y switch
	// to determine what type of symbol path searching is desired...
	enum SymbolPathSearchAlgorithms
	{
		enumSymbolPathNormal							= 0x0,
		enumSymbolPathOnly 								= 0x1,
		enumSymbolPathRecursion							= 0x2,
		enumSymbolsModeNotUsingDBGInMISCSection			= 0x4,
	};

	enum DebugLevel
	{
		enumDebugSearchPaths = 0x1
	};

	enum SymbolSourceModes 
	{
		enumVerifySymbolsModeSourceSymbolsNoPreference,	// Not preference given...
		enumVerifySymbolsModeSourceSymbolsPreferred,	// -SOURCE
		enumVerifySymbolsModeSourceSymbolsOnly,			// -SOURCEONLY
		enumVerifySymbolsModeSourceSymbolsNotAllowed	// -NOSOURCE
	};

	enum ProgramModes 
	{
		// Help Modes
		SimpleHelpMode,
		HelpMode,

		// Input Methods
		InputProcessesFromLiveSystemMode, 			// Querying live processes
		InputDriversFromLiveSystemMode, 				// Querying live processes
		InputProcessesWithMatchingNameOrPID,			// Did the user provide a PID or Process Name?
		InputModulesDataFromFileSystemMode,			// Input Modules Data from File System
		InputCSVFileMode,								// Input Data from CSV File
		InputDmpFileMode,								// Input Data from DMP File

		// Collection Options
		CollectVersionInfoMode, 

		// Matching Options
		MatchModuleMode,

		// Verification Modes
		VerifySymbolsMode,
		VerifySymbolsModeWithSymbolPath,
		VerifySymbolsModeWithSymbolPathOnly,
		VerifySymbolsModeWithSymbolPathRecursion,
		VerifySymbolsModeNotUsingDBGInMISCSection,
		VerifySymbolsModeWithSQLServer,					// These don't really seem to work anymore
		VerifySymbolsModeWithSQLServer2,				// These don't really seem to work anymore

		// Output Methods
		OutputSymbolInformationMode,
		OutputModulePerf,
		BuildSymbolTreeMode,							// Building a symbol tree
		CopySymbolsToImage,
		PrintTaskListMode,
		QuietMode,										// No output to stdout... 
		OutputCSVFileMode,
		OverwriteOutputFileMode,
		OutputDiscrepanciesOnly,

		ExceptionMonitorMode
	}; 

	bool GetMode(enum ProgramModes mode);
	bool SetMode(enum ProgramModes mode, bool fState);
	bool DisplayProgramArguments();

	// INLINE Methods!

#ifdef _UNICODE
	inline bool IsRunningWindows() { // If Windows 9x
		return (m_osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
		};
#endif

	inline bool IsRunningWindowsNT() { // If Windows NT
		return (m_osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
		};

//	inline LPTSTR GetProcessName() {
//		return m_tszProcessName;
//		};

	inline LPTSTR GetModuleToMatch() {
		return m_tszModuleToMatch;
		};

	inline LPTSTR GetOutputFilePath() {
		return m_tszOutputCSVFilePath;
		};

	inline LPTSTR GetSQLServerName() {
		return m_tszSQLServer;
		};

	inline LPTSTR GetSQLServerName2() {
		return m_tszSQLServer2;
		};

	inline LPTSTR GetSymbolPath() {
		return m_tszSymbolPath;
		};

	// Return the exepath if it exists, or the symbol path otherwise...
	inline LPTSTR GetExePath() {
		return (NULL != m_tszExePath) ? m_tszExePath : m_tszSymbolPath;
		};
	
	inline LPTSTR GetInputFilePath() {
		return m_tszInputCSVFilePath;
		};

	inline LPTSTR GetDmpFilePath() {
		return m_tszInputDmpFilePath;
	};

	inline LPTSTR GetSymbolTreeToBuild() {
		return m_tszSymbolTreeToBuild;
	};

	inline LPTSTR GetInputModulesDataFromFileSystemPath() {
		return m_tszInputModulesDataFromFileSystemPath;
		};

//	inline DWORD GetProcessID() {
//		return m_iProcessID;
//		};

	inline enum SymbolSourceModes GetSymbolSourceModes() {
		return m_enumSymbolSourcePreference;
		};
	
	inline bool fDebugSearchPaths()
	{
		return (m_dwDebugLevel & enumDebugSearchPaths) == enumDebugSearchPaths;
	};

	inline unsigned int GetVerificationLevel() {
		return m_iVerificationLevel;
		};

	inline DWORD cProcessID() {
		return m_cProcessIDs;
		};

	inline DWORD GetProcessID(unsigned int i) {
		return m_rgProcessIDs[i];
		};

	inline DWORD cProcessNames() {
		return m_cProcessNames;
		};

	inline LPTSTR GetProcessName(unsigned int i) {
		return m_rgtszProcessNames[i];
		};

	inline bool fWildCardMatch() {
		return m_fWildCardMatch;
		}

	inline bool fFileSystemRecursion() {
		return m_fFileSystemRecursion;
		}
	
protected:
	OSVERSIONINFOA m_osver;
	bool VerifySemiColonSeparatedPath(LPTSTR tszPath);
	bool SetProcessID(DWORD iPID);

	unsigned int m_iVerificationLevel;
	bool m_fFileSystemRecursion;

	// -P Option - Create an array of process IDs and/or Process Names
	LPTSTR		m_tszProcessPidString;
	bool			m_fWildCardMatch;

	DWORD		m_cProcessIDs;
	DWORD *	m_rgProcessIDs;

	DWORD		m_cProcessNames;
	LPTSTR *		m_rgtszProcessNames;
	
	DWORD m_dwDebugLevel;

	LPTSTR m_tszInputCSVFilePath;
	LPTSTR m_tszInputDmpFilePath;

	LPTSTR m_tszOutputCSVFilePath;
	LPTSTR m_tszModuleToMatch;
	LPTSTR m_tszSymbolPath;
	LPTSTR m_tszExePath;
	LPTSTR m_tszSymbolTreeToBuild;
	LPTSTR m_tszInputModulesDataFromFileSystemPath;
	LPTSTR m_tszSQLServer;
	LPTSTR m_tszSQLServer2;	// SQL2 - mjl 12/14/99

	bool m_fSimpleHelpMode;
	bool m_fHelpMode;

	bool m_fInputProcessesFromLiveSystemMode;
	bool m_fInputDriversFromLiveSystemMode;
	bool m_fInputProcessesWithMatchingNameOrPID;
	bool m_fInputCSVFileMode;
	bool m_fInputDmpFileMode;

	bool m_fInputModulesDataFromFileSystemMode;
	bool m_fMatchModuleMode;
	bool m_fOutputSymbolInformationMode;
	bool m_fOutputModulePerf;
	bool m_fCollectVersionInfoMode;
	
	bool m_fVerifySymbolsMode;
	bool m_fVerifySymbolsModeWithSymbolPath;
	bool m_fVerifySymbolsModeWithSymbolPathOnly;
	bool m_fVerifySymbolsModeWithSymbolPathRecursion;
	bool m_fVerifySymbolsModeUsingDBGInMISCSection;
	bool m_fVerifySymbolsModeWithSQLServer;
	bool m_fVerifySymbolsModeWithSQLServer2; // SQL2 - mjl 12/14/99

	enum SymbolSourceModes m_enumSymbolSourcePreference;
	
	bool m_fSymbolTreeToBuildMode;
	bool m_fCopySymbolsToImage;
	bool m_fPrintTaskListMode;
	bool m_fQuietMode;
	bool m_fOutputCSVFileMode;
	bool m_fOutputDiscrepanciesOnly;
	bool m_fOverwriteOutputFileMode;

	bool m_fExceptionMonitorMode;
};

#endif // !defined(AFX_PROGRAMOPTIONS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       version.h
//
//--------------------------------------------------------------------------

// Version Information

#define VERSION_FILEVERSION 		2,2,2,0
#define VERSION_FILEVERSIONSTRING 	"2.2.2\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\utilityfunctions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       utilityfunctions.cpp
//
//--------------------------------------------------------------------------

// UtilityFunctions.cpp: implementation of the CUtilityFunctions class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include <dbghelp.h>

#include "ModuleInfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

ENVBLOCK g_tszEnvironmentVariables[] = 
	{
		// Support for Exchange Server
		TEXT("EXCHSRVR"),	
		TEXT("SOFTWARE\\Microsoft\\Exchange\\Setup"), 
		TEXT("Services"),
		TEXT("Microsoft Exchange Server"),
		
		// Support for Internet Explorer
		TEXT("IE"),
		TEXT("SOFTWARE\\Microsoft\\IE Setup\\Setup"),
		TEXT("Path"),
		TEXT("Microsoft Internet Explorer"),

		// Support for INETSRV Server
		TEXT("INETSRV"),
		TEXT("SOFTWARE\\Microsoft\\INetStp"),
		TEXT("InstallPath"),
		TEXT("Microsoft Internet Information Services"),

		// Support for Office XP
		TEXT("OFFICE2000"),
		TEXT("SOFTWARE\\Microsoft\\Office\\9.0\\Common\\InstallRoot"),
		TEXT("Path"),
		TEXT("Microsoft Office 2000"),

		// Support for Office XP
		TEXT("OFFICEXP"),
		TEXT("SOFTWARE\\Microsoft\\Office\\10.0\\Common\\InstallRoot"),
		TEXT("Path"),
		TEXT("Microsoft Office XP"),

		// Support for SMS Server
		TEXT("SMSSERVER"),
		TEXT("SOFTWARE\\Microsoft\\SMS\\Identification"),
		TEXT("Installation Directory"),
		TEXT("Microsoft SMS Server"),

		// Support for SNA Server
		TEXT("SNASERVER"),
		TEXT("SOFTWARE\\Microsoft\\Sna Server\\CurrentVersion"),
		TEXT("PathName"),
		TEXT("Microsoft SNA Server"),

		// Support for SQL Server
		TEXT("SQLSERVER"),
		TEXT("SOFTWARE\\Microsoft\\MSSQLServer\\Setup"),
		TEXT("SQLPath"),
		TEXT("Microsoft SQL Server"),

		// Support for WSPSRV Server
		TEXT("WSPSRV"),
		TEXT("SYSTEM\\CurrentControlSet\\Services\\WSPSrv\\Parameters"),
		TEXT("InstallRoot"),
		TEXT("Microsoft Winsock Proxy Server"),
		
		NULL,				
		NULL,											
		NULL,
		NULL
	};

#define SRV_STRING		TEXT("SRV*")
#define SRV_EXPANDED	TEXT("SYMSRV*SYMSRV.DLL*")

CUtilityFunctions::CUtilityFunctions()
{
}

CUtilityFunctions::~CUtilityFunctions()
{
}

/*++
Function Name

	LPTSTR CUtilityFunctions::ExpandPath(LPCTSTR tszInputPath)

Routine Description:
	
	This routine copies the provided tszInputPath to a new
	buffer which is returned to the caller.  Any environment variables (or
	pseudo-environment variables) included in the tszInputPath are expanded
	before being copied to the destination string.
	
	This routine allocates storage for the return string, it is the responsibility
	of the caller to release it.

	2001-07-17	GREGWI - Added support for SRV*

Arguments:
	
	[IN]		LPCTSTR tszInputString - Input string

Return Value:

	[OUT ]		LPTSTR	Returns the new string

--*/

LPTSTR CUtilityFunctions::ExpandPath(LPCTSTR tszInputPath, bool fExpandSymSrv /* = false */)
{
	// Pointer to our input path buffer
	LPCTSTR ptszInputPathPointer;
    
	// Buffer to hold pre-translated Environment Variable
    TCHAR   tszEnvironmentVariableBuffer[MAX_PATH];

    // Buffer to hold translated environment variables
	TCHAR   tszTranslatedEnvironmentVariable[MAX_PATH];
	LPTSTR	ptszTranslatedEnvironmentVariablePointer;
    
	// Generic counter variable
	ULONG iCharIndex;

	// Buffer to hold Output Path
	LPTSTR  tszOutputPathBuffer, ptszOutputPathPointer;
	ULONG   iOutputPathBufferSize;

    bool fStartOfPathComponent = true;
	
	if (!tszInputPath) {
        return(NULL);
    }

	// Setup our pointer to our input buffer
    ptszInputPathPointer = tszInputPath;

#ifdef _DEBUG
	// This puts stress on the re-alloc code...
	iOutputPathBufferSize = MAX_PATH; // We need less stress here (numega has probs)
#else
	iOutputPathBufferSize = _tcslen(tszInputPath) + MAX_PATH + 1;
#endif
	
	// Create our output buffer...
//#ifdef _DEBUG
//	_tprintf(TEXT("ExpandPath() - Output Buffer created\n"));
//#endif

    ptszOutputPathPointer = tszOutputPathBuffer = new TCHAR[iOutputPathBufferSize];

    if (!tszOutputPathBuffer) 
	{
        return(NULL);
    }

	DWORD iTranslatedCharacters = 0;

	// Loop through our input buffer until we're done...
    while( ptszInputPathPointer && *ptszInputPathPointer) 
	{
		if (fExpandSymSrv)
		{
			// Added support for SRV* expansion (added to 3.0.0016 of Windbg/cdb)
			if (fStartOfPathComponent && !_tcsnicmp(ptszInputPathPointer, SRV_STRING, _tcslen(SRV_STRING)))
			{
				LPTSTR ptszSRVStringPointer = SRV_EXPANDED;
				
				// Iterate through the Translated Env. Variable Buffer, and copy to the output buffer
				while (ptszSRVStringPointer  && *ptszSRVStringPointer) 
				{
					// Copy a char
					*(ptszOutputPathPointer++) = *(ptszSRVStringPointer++);

					// If our output buffer is full, we need to allocate a new buffer...
					if (ptszOutputPathPointer >= tszOutputPathBuffer + iOutputPathBufferSize) 
					{
						// Bump up our new size by MAX_PATH
						iOutputPathBufferSize += MAX_PATH;

						// We need to enlarge the buffer our string is in...
						tszOutputPathBuffer = ReAlloc(tszOutputPathBuffer, &ptszOutputPathPointer, iOutputPathBufferSize);

						if (tszOutputPathBuffer == NULL)
							return NULL;
					}
				}

				// Advance beyond the SRV* string
				ptszInputPathPointer = ptszInputPathPointer+_tcslen(SRV_STRING);
				fStartOfPathComponent = false;
				continue;
			}
		}

		// We're searching for % to designate the start of an env. var...
        if (*ptszInputPathPointer == '%') 
		{
            iCharIndex = 0;

			// Advance to just beyond the % character
            ptszInputPathPointer++;

			// While we have more environment variable chars...
            while (ptszInputPathPointer && *ptszInputPathPointer && *ptszInputPathPointer != '%') 
			{
				// Copy the environment variable into our buffer
                tszEnvironmentVariableBuffer[iCharIndex++] = *ptszInputPathPointer++;
            }

			// Advanced to just beyond the closing % character
            ptszInputPathPointer++;

			// Null terminate our Environment Variable Buffer
            tszEnvironmentVariableBuffer[iCharIndex] = '\0';

			// Setup the Translated Env. Variable Buffer
		    ptszTranslatedEnvironmentVariablePointer = tszTranslatedEnvironmentVariable;
            *ptszTranslatedEnvironmentVariablePointer = 0;

            // Translate the Environment Variables!
			iTranslatedCharacters = GetEnvironmentVariable( tszEnvironmentVariableBuffer, ptszTranslatedEnvironmentVariablePointer, MAX_PATH );
            
			// If we didn't translate anything... we need to look for this as a special env. variable...
			if (iTranslatedCharacters == 0)
			{

				bool fSpecialEnvironmentVariable = false;

				// Scan our special variables...
				for (int i = 0; g_tszEnvironmentVariables[i].tszEnvironmentVariable && !fSpecialEnvironmentVariable; i++)
				{
					if (!_tcsicmp(g_tszEnvironmentVariables[i].tszEnvironmentVariable,
						          tszEnvironmentVariableBuffer) )
					{
						// MATCHES!!!!

						HKEY hKey;
						DWORD lpType = 0;
						LONG Results = ERROR_SUCCESS;
						DWORD lpcbData = MAX_PATH;
						BYTE outBuf[MAX_PATH];

						Results = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
												g_tszEnvironmentVariables[i].tszRegistryKey,
												0,
												KEY_READ || KEY_QUERY_VALUE,
												&hKey);

						fSpecialEnvironmentVariable = (Results == ERROR_SUCCESS);

						if (Results != ERROR_SUCCESS)
						{
							_tprintf(TEXT("ERROR: Unable to open registry key [%s]\n"), g_tszEnvironmentVariables[i].tszRegistryKey);
							_tprintf(TEXT("ERROR: Unable to open registry key - Error = 0x%x\n"), Results);
						}

						if (fSpecialEnvironmentVariable)
						{
							// Now, read the value that has our install path...
							Results = RegQueryValueEx(
												hKey,	// handle of key to query 
												g_tszEnvironmentVariables[i].tszRegistryValue,	// address of name of value to query 
												NULL,					// reserved 
												&lpType,	// address of buffer for value type 
												outBuf,		// address of data buffer 
												&lpcbData); 	// address of data buffer size 

							// Is it still succesful?
							fSpecialEnvironmentVariable = ( (Results == ERROR_SUCCESS) && 
															(lpType == REG_SZ) ||
															(lpType == REG_EXPAND_SZ) );

							if (Results != ERROR_SUCCESS)
							{
								_tprintf(TEXT("ERROR: Registry key opened [%s]\n"), g_tszEnvironmentVariables[i].tszRegistryKey);
								_tprintf(TEXT("ERROR: Unable to query registry value [%s]\n"), g_tszEnvironmentVariables[i].tszRegistryValue);
								_tprintf(TEXT("ERROR: Unable to query registry value - Error = 0x%x\n"), Results);
							}
							// Copy only if we got something?
							RegCloseKey(hKey);
						}


						if (fSpecialEnvironmentVariable)
						{
							LPTSTR tszPathToUse = NULL;
							LPTSTR tszExpandedPath = NULL;

							switch (lpType)
							{
								case REG_SZ:
									tszPathToUse = (LPTSTR)outBuf;
									break;

								// If the type was REG_EXPAND_SZ, then we need call ourselves to expand (one last time I hope)...
								case REG_EXPAND_SZ:
									tszPathToUse = tszExpandedPath = ExpandPath((LPTSTR)outBuf);
									break;

								default:
									break;
							}

							if (tszPathToUse)
							{
								// Copy the new data!!!
								_tcscpy(tszTranslatedEnvironmentVariable, tszPathToUse);

								// Remove a trailing backslash if it exists
								RemoveTrailingBackslash(tszTranslatedEnvironmentVariable);
							}

							if (tszExpandedPath)
							{
								delete [] tszExpandedPath;
								tszExpandedPath = NULL;
							}
						}
					}

				}

				if (!fSpecialEnvironmentVariable)
				{
#ifdef _DEBUG
					_tprintf(TEXT("Unrecognized Environment variable found! [%%%s%%]\n"), tszEnvironmentVariableBuffer);
#endif
					// Error copy the original environment variable provided back to the "translated env
					// buffer to be copied back below...
					_tcscpy(tszTranslatedEnvironmentVariable, TEXT("%"));
					_tcscat(tszTranslatedEnvironmentVariable, tszEnvironmentVariableBuffer);
					_tcscat(tszTranslatedEnvironmentVariable, TEXT("%"));
				}
			}

			// Iterate through the Translated Env. Variable Buffer, and copy to the output buffer
			while (ptszTranslatedEnvironmentVariablePointer && *ptszTranslatedEnvironmentVariablePointer) 
			{
				// Copy a char
				*(ptszOutputPathPointer++) = *(ptszTranslatedEnvironmentVariablePointer++);

				// If our output buffer is full, we need to allocate a new buffer...
				if (ptszOutputPathPointer >= tszOutputPathBuffer + iOutputPathBufferSize) 
				{
					// Bump up our new size by MAX_PATH
					iOutputPathBufferSize += MAX_PATH;

					// We need to enlarge the buffer our string is in...
					tszOutputPathBuffer = ReAlloc(tszOutputPathBuffer, &ptszOutputPathPointer, iOutputPathBufferSize);

					if (tszOutputPathBuffer == NULL)
						return NULL;
				}
			}

			fStartOfPathComponent = false;
        }

		// Probe to see if we're pointing at a NULL... this can happen if we've just completed
		// environment variable expansion...
		if ( *ptszInputPathPointer == '\0')
			continue;

		// If we're at a semi-colon, then following the copying of it (below), we'll be at a new
		// Path Component
		if (*ptszInputPathPointer == ';')
		{
			fStartOfPathComponent = true;
		}
		else
		{
			fStartOfPathComponent = false;
		}

		// Before we copy the char we're looking at... we need to test
		// for a trailing backslash (\) on the end (which we'll silently remove)...
		if ( (*ptszInputPathPointer == '\\') &&												  // Do we have a slash
			 ( (*(ptszInputPathPointer+1) == ';') || (*(ptszInputPathPointer+1) == '\0') ) && // and the next char is a NULL or semi-colon?
			 ( ptszInputPathPointer != tszInputPath ) &&							  // and we're not on the first char
			 (  *(ptszInputPathPointer-1) != ':' )											  // and the previous char is not a colon...
		   )
		{
			// Advance the pointer only... (remove the trailing slash)
			ptszInputPathPointer++;
		}
		else
		{
			// Copy a char from the input path, to the output path
			*(ptszOutputPathPointer++) = *(ptszInputPathPointer++);
		}

		// If our output buffer is full, we need to allocate a new buffer...
		if (ptszOutputPathPointer >= tszOutputPathBuffer + iOutputPathBufferSize) 
		{
			// Bump up our new size by MAX_PATH
            iOutputPathBufferSize += MAX_PATH;

			// We need to enlarge the buffer our string is in...
			tszOutputPathBuffer = ReAlloc(tszOutputPathBuffer, &ptszOutputPathPointer, iOutputPathBufferSize);

			if (tszOutputPathBuffer == NULL)
				return NULL;
        }
    }

	// Null terminate our output buffer
    *ptszOutputPathPointer = '\0';

	// Return our results...
    return tszOutputPathBuffer;
}

bool CUtilityFunctions::ContainsWildCardCharacter(LPCTSTR tszPathToSearch)
{
	if (!tszPathToSearch)
		return false;

	LPCTSTR ptszPointer = tszPathToSearch;

	while (*ptszPointer)
	{
		switch (*ptszPointer)
		{
		case '*':
		case '?':
			return true;
		}

		ptszPointer++;
	}

	return false;
}

/*
bool CUtilityFunctions::IsDirectoryPath(LPCTSTR tszFilePath)
{
	if (!tszFilePath)
		return false;

	WIN32_FIND_DATA lpFindFileData;

	HANDLE hFileOrDirectory = FindFirstFile(tszFilePath, &lpFindFileData);

	if (INVALID_HANDLE_VALUE == hFileOrDirectory)
		return false;

	FindClose(hFileOrDirectory);
	
	if (lpFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		return true;

	return false;
}
*/

void CUtilityFunctions::PrintMessageString(DWORD dwMessageId)
{
	// Define a constant for our "private" buffer...
	enum {MESSAGE_BUFFER_SIZE = 1024};

	TCHAR tszMessageBuffer[MESSAGE_BUFFER_SIZE];

	DWORD dwBytes =	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
								  NULL,
								  dwMessageId,
								  0,
								  tszMessageBuffer,
								  MESSAGE_BUFFER_SIZE,
								  NULL);

	if (dwBytes)
	{
		// We got something!

		// Should we null terminate?
		if ( (dwBytes > 2)  &&
			 (tszMessageBuffer[dwBytes-2] == '\r') &&
			 (tszMessageBuffer[dwBytes-1] == '\n') )
		{
			tszMessageBuffer[dwBytes-2] = 0; // Null terminate this puppy...
		}

		_tprintf(TEXT("Error = %d (0x%x)\n[%s]\n"), dwMessageId, dwMessageId, tszMessageBuffer);
	}

}

bool CUtilityFunctions::CopySymbolFileToImagePath(LPCTSTR tszImageModulePath, LPTSTR * lplptszOriginalPathToSymbolFile)
{
	BOOL fCancel = FALSE;
	DWORD dwStatusDots = 0;
	TCHAR tszDrive[_MAX_DRIVE];							// Contains the drive of the PE image
	TCHAR tszDir[_MAX_DIR];								// Contains the path to the PE image
	TCHAR tszSymbolModuleName[_MAX_FNAME];			// Contains the symbol module filename (BADAPP)
	TCHAR tszSymbolModuleExt[_MAX_EXT];				// Contains the symbol extension (.DBG || .PDB)
	TCHAR tszSymbolModuleNamePath[_MAX_PATH+1];		// Symbol path where symbol will reside ultimately

	// Compute the Symbol Path adjacent to the module...
	_tsplitpath(tszImageModulePath, tszDrive, tszDir, NULL, NULL);
	_tsplitpath(*lplptszOriginalPathToSymbolFile, NULL, NULL, tszSymbolModuleName, tszSymbolModuleExt);

	// Now, combine them...
	_tcscpy(tszSymbolModuleNamePath, tszDrive);
	_tcscat(tszSymbolModuleNamePath, tszDir);
	_tcscat(tszSymbolModuleNamePath, tszSymbolModuleName);
	_tcscat(tszSymbolModuleNamePath, tszSymbolModuleExt);

	// Let's save this for ease of access...
	bool fQuietMode = g_lpProgramOptions->GetMode(CProgramOptions::QuietMode);

	// Before we start to copying... is the source location already at module path location?
	// If the paths are not the same, then we copy... simple as that...
	if (_tcsicmp(*lplptszOriginalPathToSymbolFile, 
				  tszSymbolModuleNamePath) )
	{
		// We don't know if the destination file exists.. but if it does, we'll change
		// the attributes (to remove the read-only bit at least

		DWORD dwFileAttributes = GetFileAttributes(tszSymbolModuleNamePath);

		if (dwFileAttributes != 0xFFFFFFFF)
		{
			if (dwFileAttributes & FILE_ATTRIBUTE_READONLY)
			{
				// The read-only attribute is set... we must remove it...
				dwFileAttributes = dwFileAttributes & (~FILE_ATTRIBUTE_READONLY);
				SetFileAttributes(tszSymbolModuleNamePath, dwFileAttributes);
			}
		}

		// Indicate start of copy (some PDB files are HUGE)!!!!
		if (!fQuietMode)
		{
			_tprintf(TEXT("VERIFIED: [%s] Copying Symbol Adjacent to Image\n"), *lplptszOriginalPathToSymbolFile);
		}

		// If we're in quiet mode let's have no callbacks (since progress dots would be suppressed)
		if ( CopyFileEx(*lplptszOriginalPathToSymbolFile, 
						tszSymbolModuleNamePath, 
						fQuietMode ? NULL : CUtilityFunctions::CopySymbolFileCallback,
						&dwStatusDots,
						&fCancel,
						COPY_FILE_RESTARTABLE) )
		{
			// Success!!!  Let's go ahead and give a visual indicator as to where we copied
			// the file from...
			_tprintf(TEXT("\n"));

			// Okay, since we've copied this to our symbol tree... we should update
			// our modulepath...
			*lplptszOriginalPathToSymbolFile = CopyString(tszSymbolModuleNamePath, *lplptszOriginalPathToSymbolFile);
			
			if (!*lplptszOriginalPathToSymbolFile)
				return false;
		} else
		{
			if (!fQuietMode)
			{
				_tprintf(TEXT("ERROR: Unable to copy symbol file to [%s]\n"), tszSymbolModuleNamePath );
				PrintMessageString(GetLastError());
			}
		}
	}
	
	return true;
}


bool CUtilityFunctions::CopySymbolFileToSymbolTree(LPCTSTR tszImageModuleName, LPTSTR * lplptszOriginalPathToSymbolFile, LPCTSTR tszSymbolTreePath)
{
	// Before we start to copying... is the source location already in the symbol tree we're going to build?
	int iLengthOfFileName = _tcslen(*lplptszOriginalPathToSymbolFile);
	int iLengthOfSymbolTreeToBuild = _tcslen(tszSymbolTreePath);
	BOOL fCancel = FALSE;
	DWORD dwStatusDots = 0;

	// Let's save this for ease of access...
	bool fQuietMode = g_lpProgramOptions->GetMode(CProgramOptions::QuietMode);

	if (_tcsnicmp(*lplptszOriginalPathToSymbolFile, 
				  tszSymbolTreePath, 
				  iLengthOfFileName < iLengthOfSymbolTreeToBuild ?
				  iLengthOfFileName : iLengthOfSymbolTreeToBuild) )
	{
		// Okay, we need to take the original module name, and get the extension...
		TCHAR tszExtension[_MAX_EXT];
		TCHAR tszPathToCopySymbolFileTo[_MAX_PATH];

		_tsplitpath(tszImageModuleName, NULL, NULL, NULL, tszExtension);
		_tcscpy( tszPathToCopySymbolFileTo, tszSymbolTreePath);

		// This directory should exist already... let's tag on the extension directory (if one exists)...
		if (_tcsclen(tszExtension) > 1)
		{
			// Copy the extension (skipping the period)
			_tcscat( tszPathToCopySymbolFileTo, &tszExtension[1] );
			_tcscat( tszPathToCopySymbolFileTo, TEXT("\\") );

			// Now, we need to ensure this directory exists (we'll cache these checks so we don't need to
			// keep checking the same directory over and over...
			//if (!g_lpDelayLoad->MakeSureDirectoryPathExists(tszPathToCopySymbolFileTo) )

				// This API normally takes ASCII strings only...
			char szPathToCopySymbolFileTo[_MAX_PATH];
			CUtilityFunctions::CopyTSTRStringToAnsi(tszPathToCopySymbolFileTo, szPathToCopySymbolFileTo, _MAX_PATH);

			if (!MakeSureDirectoryPathExists(szPathToCopySymbolFileTo) )
			{
				if (!fQuietMode)
				{
					_tprintf(TEXT("ERROR: Unable to create symbol subdirectory [%s]\n"), tszPathToCopySymbolFileTo );
					PrintMessageString(GetLastError());
				}
			}
		}

		TCHAR tszSymbolFileName[_MAX_FNAME];
		TCHAR tszSymbolFileExt[_MAX_EXT];

		_tsplitpath(*lplptszOriginalPathToSymbolFile, NULL, NULL, tszSymbolFileName, tszSymbolFileExt);

		// Okay... it's time to copy the file!!!
		_tcscat( tszPathToCopySymbolFileTo, tszSymbolFileName );
		_tcscat( tszPathToCopySymbolFileTo, tszSymbolFileExt );

		// We don't know if the destination file exists.. but if it does, we'll change
		// the attributes (to remove the read-only bit at least

		DWORD dwFileAttributes = GetFileAttributes(tszPathToCopySymbolFileTo);

		if (dwFileAttributes != 0xFFFFFFFF)
		{
			if (dwFileAttributes & FILE_ATTRIBUTE_READONLY)
			{
				// The read-only attribute is set... we must remove it...
				dwFileAttributes = dwFileAttributes & (~FILE_ATTRIBUTE_READONLY);
				SetFileAttributes(tszPathToCopySymbolFileTo, dwFileAttributes);
			}
		}

		// Indicate start of copy (some PDB files are HUGE)!!!!
		if (!fQuietMode)
		{
			_tprintf(TEXT("VERIFIED: [%s] copying to Symbol Tree\n"), *lplptszOriginalPathToSymbolFile);
		}

		// If we're in quiet mode let's have no callbacks (since progress dots would be suppressed)
		if ( CopyFileEx(*lplptszOriginalPathToSymbolFile, 
						tszPathToCopySymbolFileTo, 
						fQuietMode ? NULL : CUtilityFunctions::CopySymbolFileCallback,
						&dwStatusDots,
						&fCancel,
						COPY_FILE_RESTARTABLE) )
		{
			// Success!!!  Let's go ahead and give a visual indicator as to where we copied
			// the file from...
			_tprintf(TEXT("\n"));

			// Okay, since we've copied this to our symbol tree... we should update
			// our modulepath...
			*lplptszOriginalPathToSymbolFile = CopyString(tszPathToCopySymbolFileTo, *lplptszOriginalPathToSymbolFile);
			
			if (!*lplptszOriginalPathToSymbolFile)
				return false;
		} else
		{
			if (!fQuietMode)
			{
				_tprintf(TEXT("ERROR: Unable to copy symbol file to [%s]\n"), tszPathToCopySymbolFileTo );
				PrintMessageString(GetLastError());
			}
		}
	}

	return true;
}

/*++
Function Name

DWORD CALLBACK CUtilityFunctions::CopySymbolCallback(
							LARGE_INTEGER TotalFileSize,          // file size
							LARGE_INTEGER TotalBytesTransferred,  // bytes transferred
							LARGE_INTEGER StreamSize,             // bytes in stream
							LARGE_INTEGER StreamBytesTransferred, // bytes transferred for stream
							DWORD dwStreamNumber,                 // current stream
							DWORD dwCallbackReason,               // callback reason
							HANDLE hSourceFile,                   // handle to source file
							HANDLE hDestinationFile,              // handle to destination file
							LPVOID lpData                         // from CopyFileEx
							)

Routine Description:

	This routine is the Callback for the CopyFileEx method used in CopySymbolFileToSymbolTree()
	
Arguments:
	
	[IN]		(Consult MSDN for this function prototype)

Return Value:

	[OUT]	We always return PROGRESS_CONTINUE


--*/

DWORD CALLBACK CUtilityFunctions::CopySymbolFileCallback(
							LARGE_INTEGER TotalFileSize,          // file size
							LARGE_INTEGER TotalBytesTransferred,  // bytes transferred
							LARGE_INTEGER StreamSize,             // bytes in stream
							LARGE_INTEGER StreamBytesTransferred, // bytes transferred for stream
							DWORD dwStreamNumber,                 // current stream
							DWORD dwCallbackReason,               // callback reason
							HANDLE hSourceFile,                   // handle to source file
							HANDLE hDestinationFile,              // handle to destination file
							LPVOID lpData                         // from CopyFileEx
							)
{
	UNREFERENCED_PARM(StreamSize);
	UNREFERENCED_PARM(StreamBytesTransferred);
	UNREFERENCED_PARM(dwStreamNumber);
	UNREFERENCED_PARM(dwCallbackReason);
	UNREFERENCED_PARM(hSourceFile);
	UNREFERENCED_PARM(hDestinationFile);
	UNREFERENCED_PARM(lpData);

	enum { iTotalNumberOfDotsToPrint = 79 };

	// We keep track of how many dots we've copied... this is based on the
	// percentage of the file we've copied...
	DWORD * lpdwStatusDots = (DWORD *)lpData;

	LONGLONG CalculatedDots = (LONGLONG)iTotalNumberOfDotsToPrint  * TotalBytesTransferred.QuadPart / TotalFileSize.QuadPart;

	// This should "never" be negative... but just in case...
	signed int iDotsToPrint = (DWORD)CalculatedDots - *lpdwStatusDots;

	if (iDotsToPrint > 0)
	{
		for (int i=0; i < iDotsToPrint; i++)
		{
			_tprintf(TEXT("."));
		}

		(*lpdwStatusDots)+=iDotsToPrint;
	}

	return PROGRESS_CONTINUE;
}


/*++
Function Name

	LPTSTR CUtilityFunctions::CopyStringWithDelete(LPCTSTR tszInputString)

Routine Description:

	This routine deletes the string provided
	This routine copies the provided tszInputString to the destination address.
	This routine allocates storage for the string, it is the responsibility
	of the caller to release it.

Arguments:
	
	[IN]		LPCTSTR tszInputString - Input string

Return Value:

	Returns the new string

--*/
/*
LPTSTR CUtilityFunctions::CopyStringWithDelete(LPCTSTR tszInputString, LPTSTR & tszDestinationString)
{
	// Did we get a proper input string?
	if (!tszInputString)
		return NULL;

	if (tszDestinationString)
		delete [] tszDestinationString;

	tszDestinationString = new TCHAR[(_tcsclen(tszInputString)+1)];

	if (!tszDestinationString )
		return NULL;

	_tcscpy(tszDestinationString, tszInputString);

	return tszDestinationString;
}
*/
/*++
Function Name

	LPTSTR CUtilityFunctions::CopyString(LPCTSTR tszInputString)

Routine Description:
	
	This routine copies the provided tszInputString to the destination address.
	This routine deletes the destination string if one is provided, and it is non-NULL
	This routine allocates storage for the string, it is the responsibility
	of the caller to release it.

Arguments:
	
	[IN]		LPCTSTR tszInputString - Input string

Return Value:

	Returns the new string

--*/
LPTSTR CUtilityFunctions::CopyString(LPCTSTR tszInputString, LPTSTR tszDestinationString)
{
	// Did we get a proper input string?
	if (!tszInputString)
		return NULL;

	// Did we get a DestinationString as input?
	if (tszDestinationString)
	{
		delete [] tszDestinationString;
	}
		
	tszDestinationString = new TCHAR[(_tcsclen(tszInputString)+1)];

	if (!tszDestinationString)
		return NULL;

	_tcscpy(tszDestinationString, tszInputString);

	return tszDestinationString;
}

LPTSTR CUtilityFunctions::CopyAnsiStringToTSTR(LPCSTR szInputString, LPTSTR tszOutputBuffer, unsigned int iBufferLength)
{
	// Did we get a proper input string?
	if (!szInputString)
		return NULL;

	if (iBufferLength && !tszOutputBuffer)
		return NULL;

	LPTSTR tszDestinationString;

#ifdef _UNICODE

	// Get the size of the source of the Ansi string...
	// Saving the value keeps MultiByteToWideChar from having to
	// calculate it twice...
	unsigned int cbMultiByte = strlen(szInputString);

	DWORD cbStringLength = MultiByteToWideChar(	CP_ACP,
												MB_PRECOMPOSED,
												szInputString,
												cbMultiByte,
												NULL,
												0);

	if (!cbStringLength)
		return NULL;

	// Do we need to allocate storage???
	if (iBufferLength == 0)
	{
		// Did we get a DestinationString as input?
		if (tszOutputBuffer)
		{
			delete [] tszOutputBuffer;
			tszOutputBuffer = NULL;
		}

		// Allocate storage
		tszDestinationString = new TCHAR[cbStringLength+1];

		if (!tszDestinationString)
			return NULL;
	} else
	{
		if ( cbStringLength+1 > iBufferLength )
			return NULL;

		// Set the two strings to the same buffer...
		tszDestinationString = tszOutputBuffer;
	}
	
	// Do the actual conversion
	cbStringLength = MultiByteToWideChar(	CP_ACP,
											MB_PRECOMPOSED,
											szInputString,
											cbMultiByte,
											tszDestinationString,
											(iBufferLength == 0) ? cbStringLength+1 : iBufferLength);

	if (!cbStringLength)
		return NULL;

	tszDestinationString[cbStringLength] = '\0';

#else
	
	unsigned int cbMultiByte = strlen(szInputString);
	
	if (iBufferLength == 0)
	{
		iBufferLength = strlen(szInputString)+1;
		
		tszDestinationString = new TCHAR[iBufferLength];
		
		if (!tszDestinationString)
			return NULL;

	} else
	{
		if (cbMultiByte+1 > iBufferLength)
			return NULL;

		// Set the two strings to the same buffer...
		tszDestinationString = tszOutputBuffer;
	}

	strncpy(tszDestinationString, szInputString, iBufferLength);

#endif
	
	return tszDestinationString;

}

LPTSTR CUtilityFunctions::CopyUnicodeStringToTSTR(LPCWSTR wszInputString, LPTSTR tszOutputBuffer, unsigned int iBufferLength)
{
	// Did we get a proper input string?
	if (!wszInputString)
		return NULL;

	// Check for proper buffers and lengths if provided...
	if (iBufferLength && !tszOutputBuffer)
		return NULL;

	LPTSTR tszDestinationString;

#ifdef _UNICODE

	unsigned int cbMultiByte = wcslen(wszInputString);

	if (iBufferLength == 0)
	{
		// Did we get a DestinationString as input?
		if (tszOutputBuffer)
		{
			delete [] tszOutputBuffer;
			tszOutputBuffer = NULL;
		}

		tszDestinationString = new TCHAR[wcslen(wszInputString)+1];
	
		if (!tszDestinationString)
			return NULL;
	} else
	{
		if (cbMultiByte+1 > iBufferLength)
			return NULL;

		// Set the two strings to the same buffer...
		tszDestinationString = tszOutputBuffer;
	}

	wcscpy(tszDestinationString, wszInputString);

#else
	
	int cchWideChar = wcslen(wszInputString);

	DWORD cbStringLength = WideCharToMultiByte( CP_ACP,
												0,
												wszInputString,
												cchWideChar,
												NULL,
												0,
												NULL,
												NULL);

	if (!cbStringLength)
		return NULL;

	// Do we need to allocate storage???
	if (iBufferLength == 0)
	{
		tszDestinationString = new TCHAR[cbStringLength+1];

		if (!tszDestinationString)
			return NULL;
	} else
	{
		if ( cbStringLength+1 > iBufferLength )
			return NULL;

		// Set the two strings to the same buffer...
		tszDestinationString = tszOutputBuffer;
	}

	// Do the actual conversion...
	cbStringLength = WideCharToMultiByte(	CP_ACP, 
											0,
											wszInputString,
											cchWideChar,
											tszDestinationString,
											(iBufferLength == 0) ? cbStringLength+1 : iBufferLength,
										    NULL,
											NULL);

	if (!cbStringLength)
		return NULL;

	tszDestinationString[cbStringLength] = '\0';

#endif
	
	return tszDestinationString;
}

//
// CUtilityFunctions::CopyTSTRStringToAnsi()
//
// This routine copies from a TSTR source to an ANSI destination with optional allocation
// of the destination buffer... the default is to allocate storage, but if you provide
// a buffer length, we will assume it's available...
//

LPSTR CUtilityFunctions::CopyTSTRStringToAnsi(LPCTSTR tszInputString, LPSTR szOutputBuffer, unsigned int iBufferLength)
{
	// Did we get a proper input string?
	if (!tszInputString)
		return NULL;

	if (iBufferLength && !szOutputBuffer)
		return NULL;

	LPSTR szDestinationString;

#ifdef _UNICODE

	// Get the size of the source of the Unicode string...
	// Saving the value keeps WideCharToMultiByte from having to
	// calculate it twice...
	unsigned int cchWideChar = wcslen(tszInputString);
	
	// This is a probe to see how much we'll be copying...
	DWORD	cbStringLength = WideCharToMultiByte(	CP_ACP,
													0,
													tszInputString,
													cchWideChar,
													NULL,
													0,
													NULL,
													NULL);
	if (!cbStringLength)
		return NULL;

	// Do we need to allocate storage???
	if (iBufferLength == 0)
	{
		// Allocate storage
		szDestinationString = new char[cbStringLength+1];

		if (!szDestinationString)
			return NULL;
	} else
	{
		if ( cbStringLength+1 > iBufferLength )
			return NULL;

		// Set the two strings to the same buffer...
		szDestinationString = szOutputBuffer;
	}
	
	// Do the actual conversion
	cbStringLength = WideCharToMultiByte(	CP_ACP, 
											0,
											tszInputString,
											cchWideChar,
											szDestinationString,
											(iBufferLength == 0) ? cbStringLength+1 : iBufferLength,
										    NULL,
											NULL);

	if (!cbStringLength)
		return NULL;

	szDestinationString[cbStringLength] = '\0';

#else

	unsigned int cchAnsiChar = strlen(tszInputString);
	
	if (iBufferLength == 0)
	{
		szDestinationString = new char[cchAnsiChar+1]; // One extra for the NULL

		if (!szDestinationString)
			return NULL;
	} else
	{
		if (cchAnsiChar+1 > iBufferLength)
			return NULL;

		// Set the two strings to the same buffer...
		szDestinationString = szOutputBuffer;
	}

	strcpy(szDestinationString, tszInputString);

#endif

	return szDestinationString;
}

LPWSTR 	CUtilityFunctions::CopyTSTRStringToUnicode(LPCTSTR tszInputString, LPWSTR wszOutputBuffer, unsigned int iBufferLength)
{
	// Did we get a proper input string?
	if (!tszInputString)
		return NULL;

	if (iBufferLength && !wszOutputBuffer)
		return NULL;
	
	LPWSTR wszDestinationString;

#ifdef _UNICODE

	unsigned int cchWideChar = wcslen(tszInputString);

	if (iBufferLength == 0)
	{
		wszDestinationString = new WCHAR[cchWideChar+1]; // One extra for the NULL

		if (!wszDestinationString)
			return NULL;
	} else
	{
		if (cchWideChar+1 > iBufferLength)
			return NULL;

		// Set the two strings to the same buffer...
		wszDestinationString = wszOutputBuffer;
	}

	wcscpy(wszDestinationString, tszInputString);

#else
	
	int cbMultiByte = strlen(tszInputString);

	DWORD cbStringLength = MultiByteToWideChar(	CP_ACP,
												MB_PRECOMPOSED,
												tszInputString,
												cbMultiByte,
												NULL,
												0);

	if (!cbStringLength)
		return NULL;

	// Do we need to allocate storage???
	if (iBufferLength == 0)
	{
		// Allocate storage
		wszDestinationString = new WCHAR[cbStringLength+1];

		if (!wszDestinationString)
			return NULL;
	} else
	{
		if ( cbStringLength+1 > iBufferLength )
			return NULL;

		// Set the two strings to the same buffer...
		wszDestinationString = wszOutputBuffer;
	}

	cbStringLength = MultiByteToWideChar(	CP_ACP,
											MB_PRECOMPOSED,
											tszInputString,
											cbMultiByte,
											wszDestinationString,
											cbStringLength+1);

	if (!cbStringLength)
		return NULL;

	wszDestinationString[cbStringLength] = '\0';

#endif
	
	return wszDestinationString;
}

/*++

  HANDLE CUtilityFunctions::FindDebugInfoFileEx2(
			[IN] LPTSTR tszFileName, 
			[IN] LPTSTR SymbolPath, 
			[IN] PFIND_DEBUG_FILE_CALLBACK Callback, 
			[IN] PVOID CallerData

Routine Description:

 The rules are, the name of the DBG/PDB file being searched for is provided,
 and when found the routine returns a file handle to it... if a callback is
 provided then the callback is invoked and a decision is made to return the
 file handle based on the callback response...

 Arguments:
    tszFileName - Supplies a symbol name to search for.
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns TRUE if the Symbol file is valid, or FALSE if the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

Return Value:

  The handle for the DBG/PDB file if any...
  In an effort to emulate File(), this function will return 0 on failure or
  the handle to the file othFindDebugInfoerwise...

--*/

HANDLE CUtilityFunctions::FindDebugInfoFileEx2(LPTSTR tszFileName, LPTSTR SymbolPath, /* LPTSTR DebugFilePath, */ PFIND_DEBUG_FILE_CALLBACK_T Callback, PVOID CallerData)
{
/*    DWORD flag;

    if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathRecursion))
        flag = fdifRECURSIVE;
    else
        flag = 0;
//    if (flag)
//        dprint("RECURSIVE %s\n", FileName);

    return fnFindDebugInfoFileEx(tszFileName,
                                 SymbolPath,
                                 DebugFilePath,
                                 Callback,
                                 CallerData,
                                 flag);
*/
	HANDLE FileHandle = INVALID_HANDLE_VALUE;
	bool fProcessPath = true;
	bool fScavengeSuccessful = false;

	LPTSTR tszSymbolPathStart, tszSymbolPathEnd;

	tszSymbolPathStart = SymbolPath;

	// Find the end of the path
	tszSymbolPathEnd = _tcschr( tszSymbolPathStart, ';' );

	// If tszSymbolPathEnd is non-zero, then there is another path following...
	if (tszSymbolPathEnd) 
		*tszSymbolPathEnd = '\0'; // Change the ';' to a Null temporarily...
	
	while (fProcessPath)
	{
//#ifdef _DEBUG
//		_tprintf(TEXT("\n\nProcessing Path [%s]\n"), tszSymbolPathStart);
//#endif
		// Begin the "madness"... ;)

		// Search until we make a perfect hit... construct the directory path...
		TCHAR tszSymbolPath[_MAX_PATH];

		// Copy what we have...
		_tcscpy(tszSymbolPath, tszSymbolPathStart);

		// We should have at least a few chars to search on...
		if (_tcslen(tszSymbolPath) < 2)
		{
			// Repair the search string if needed...
			if (tszSymbolPathEnd) 
			{
				*tszSymbolPathEnd = ';';
			}
			break;
		};

		fScavengeSuccessful = ScavengeForSymbolFiles(tszSymbolPath, tszFileName, Callback, CallerData, &FileHandle, 1);

		// Repair the search string now!
		if (tszSymbolPathEnd) 
		{
			*tszSymbolPathEnd = ';';
		}

		// If were successful on our hunt or there is no symbol path left to search... break...
		if (fScavengeSuccessful || !tszSymbolPathEnd)
		{
			break;
		} else
		{
			// Advance to next string
			tszSymbolPathStart = tszSymbolPathEnd + 1;
				
			tszSymbolPathEnd = _tcschr( tszSymbolPathStart, ';' );

			if (tszSymbolPathEnd) 
			{
				*tszSymbolPathEnd = '\0';
			};
		}
	}

    return ( (FileHandle == INVALID_HANDLE_VALUE) ? 0 : FileHandle);


}

/*++

	bool CUtilityFunctions::ScavengeForSymbolFiles(
			[IN] LPCTSTR tszSymbolPathStart, 
			[IN] LPCTSTR tszSymbolToSearchFor, 
			[IN] PFIND_DEBUG_FILE_CALLBACK Callback, 
			[IN] PVOID CallerData, 
			[OUT] LPHANDLE lpFileHandle, 
			[IN] int iRecurseDepth )

Routine Description:

  This routine is used to perform a recursive search for a Symbol File
  (tszSymbolToSearchFor).  The routine will do a depth search, looking
  for the symbol at a current depth before going into sub-directories...
  If a Callback function is provided, then it will be invoked when the
  file we're looking for (by name) has been successfully opened.  It is
  unknown to this routine, however, if the file we found is actually the
  correct one... the callback function's responsibility is to perform this
  evaluation and return to use success/failure.  If failure (then we continue
  searching), if success (or no callback) then we return the filehandle
  associated with the file we found.

  It is the responsibility of the caller of this function to close any file
  handle returned.

 Arguments:
    tszSymbolPathStart - This is the directory to search
    tszSymbolToSearchFor - This is the symbol we're searching for
	Callback - May be NULL.  This is a function used to evaluate if the symbol found is correct.
	CallerData - May be NULL.  This data is passed to the callback (it is typically a CModuleInfo *)
	lpfileHandle - This is the file handle for the file found (if any)
	iRecurseDepth - This is the current depth of our search (defaults to 0)

Return Value:

  The handle for the DBG/PDB file if any...

--*/
bool CUtilityFunctions::ScavengeForSymbolFiles(LPCTSTR tszSymbolPathStart, LPCTSTR tszSymbolToSearchFor, PFIND_DEBUG_FILE_CALLBACK_T Callback, PVOID CallerData, LPHANDLE lpFileHandle, int iRecurseDepth )
{
	bool fSuccess = false;
	HANDLE hFileOrDirectoryHandle = INVALID_HANDLE_VALUE;

	// Bale if we're in too deep...
	if (iRecurseDepth > MAX_RECURSE_DEPTH)
		return fSuccess;

	TCHAR tszFileBuffer[MAX_PATH+1];

	//
	// First, we'll look to see if we can open the file we're looking for AT this directory location
	//
	if (_tcslen(tszSymbolPathStart) > MAX_PATH)
		goto cleanup;

	_tcscpy(tszFileBuffer, tszSymbolPathStart);
	
	if (tszFileBuffer[_tcslen(tszFileBuffer)] != '\\') // Do we need a backslash separator?
		_tcscat(tszFileBuffer, TEXT("\\"));

	_tcscat(tszFileBuffer, tszSymbolToSearchFor);

	if (g_lpProgramOptions->fDebugSearchPaths())
	{
		_tprintf(TEXT("DBG/PDB Search - Search here [%s]\n"), tszFileBuffer);
	}

	// Attempt to open the file...
    *lpFileHandle = CreateFile( tszFileBuffer,
								GENERIC_READ,
								(FILE_SHARE_READ | FILE_SHARE_WRITE),
								NULL,
								OPEN_EXISTING,
								0,
								NULL
								);

	// Did we open it?
	if (*lpFileHandle != INVALID_HANDLE_VALUE)
	{
		// Yes!
//#ifdef _DEBUG
//	_tprintf(TEXT("File [%s] opened, handle = 0x%x\n"), tszFileBuffer, *lpFileHandle);
//#endif
		// If no callback... then we need to exit on out...
		if (!Callback)
		{
			// Assume success (well... we found a symbol file you asked for)
			fSuccess = true;
		} else
		{
				fSuccess = (TRUE == Callback(*lpFileHandle, tszFileBuffer, CallerData));
		}

		// Return from here only on success!
		if (fSuccess)
			goto cleanup;
	}

	// We either did NOT find the file, or we found a file but it was not the right one...
	
	// Let's close the handle we were using...
	CloseHandle(*lpFileHandle);
	*lpFileHandle = INVALID_HANDLE_VALUE;
    
	//
	// Second, we search for sub-directories, invoking this function for each sub-dir we find...
	//
	TCHAR drive[_MAX_DRIVE];
	TCHAR dir[_MAX_DIR];
	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];

	//
	// Compose the path to search...
	//
	_tcscpy(tszFileBuffer, tszSymbolPathStart);
	
	if (tszFileBuffer[_tcslen(tszFileBuffer)-1] != '\\') // Do we need a backslash separator?
		_tcscat(tszFileBuffer, TEXT("\\"));

	_tcscat(tszFileBuffer, TEXT("*.*"));

	// We want the component parts for later (so we can compose the full path)
	_tsplitpath(tszFileBuffer, drive, dir, fname, ext);

	WIN32_FIND_DATA lpFindFileData;

	// Okay, begin the search...
	hFileOrDirectoryHandle = FindFirstFile(tszFileBuffer, &lpFindFileData);

	while ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
	{
		if (lpFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			// Check to see if we've got the . or .. directories!
			if ( ( 0 == _tcscmp(lpFindFileData.cFileName, TEXT(".")) ) ||
				 ( 0 == _tcscmp(lpFindFileData.cFileName, TEXT("..")) )
			   )
			{
					goto getnextmodule;
			}

			// Compose the path to the directory...
			_tmakepath(tszFileBuffer, drive, dir, NULL, NULL);
			_tcscat(tszFileBuffer, lpFindFileData.cFileName);

			// Look to see if we can find the file we're after!
			fSuccess = ScavengeForSymbolFiles(tszFileBuffer, tszSymbolToSearchFor, Callback, CallerData, lpFileHandle, iRecurseDepth+1 );

			// On success from ScavengeForSymbolFiles, we have a file handle (hopefully the right one).
			// We want to terminate our recursive search
			if (fSuccess)
				break;
		};

getnextmodule:

		if (!FindNextFile(hFileOrDirectoryHandle, &lpFindFileData))
			break;
	}

cleanup:

	if ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
		FindClose(hFileOrDirectoryHandle);

	return fSuccess;
}

LPTSTR CUtilityFunctions::ReAlloc(LPTSTR tszOutputPathBuffer, LPTSTR * ptszOutputPathPointer, size_t size)
{
	// Save our old size... and position in the buffer...
//	UINT iOldOutputPathBufferSize = (*ptszOutputPathPointer)-tszOutputPathBuffer;
	__int64 iOldOutputPathBufferSize = (*ptszOutputPathPointer)-tszOutputPathBuffer;

	// Allocate our new bigger buffer...
	LPTSTR ptszNewOutputPathBuffer = new TCHAR[size];

	// Did we fail to allocate the new buffer?
	if (ptszNewOutputPathBuffer == NULL) 
		return(NULL);

#ifdef _DEBUG
	// This bogus code is here to protect a string copy which should always work...
	// but Numega Bounds Checker will sometimes AV in here... and we have to protect
	// ourselves or else it will appear we're leaking way above...
	__try 
	{
#endif

		// Now, we should copy from the old to the new buffer...
	_tcsncpy(ptszNewOutputPathBuffer, tszOutputPathBuffer, (UINT)iOldOutputPathBufferSize);

#ifdef _DEBUG
    } __except(EXCEPTION_EXECUTE_HANDLER) 
	{
		_tprintf(TEXT("ReAlloc() - Exception Hit during stringcopy!!!\n"));
    }
#endif

	// Calculate our position in our new buffer
	*ptszOutputPathPointer = ptszNewOutputPathBuffer + iOldOutputPathBufferSize;

	// Delete the old buffer
	delete [] tszOutputPathBuffer;

	return ptszNewOutputPathBuffer;
}

bool CUtilityFunctions::UnMungePathIfNecessary(LPTSTR tszPossibleBizarrePath)
{
	/*
	// We have three known odd-ball cases...

		\SystemRoot\System32\smss.exe
		\??\C:\WINNT\system32\winlogon.exe
		\WINNT\System32\ntoskrnl.exe
	*/

	if (tszPossibleBizarrePath[0] != '\\')
		return false; // Isn't a bizarre path (one we know about anyway)...

	// Setup Variables to Use
	TCHAR tszTempPath[_MAX_PATH], tszExpandedSystemRoot[_MAX_PATH];

	const TCHAR tszSystemRoot[] = TEXT("\\SystemRoot");
	const unsigned int iSystemRootLength = _tcslen(tszSystemRoot);

	const TCHAR tszNameSpace[] = TEXT("\\??\\");
	const unsigned int iNameSpaceLength = _tcslen(tszNameSpace);

	ExpandEnvironmentStrings(TEXT("%systemroot%"), tszExpandedSystemRoot, _MAX_PATH);
	const unsigned int iExpandedSystemRoot = _tcslen(tszExpandedSystemRoot);

/*
#ifdef _DEBUG
	_tprintf(TEXT("Bizarre module path found!  [%s]\n"), tszPossibleBizarrePath);
#endif
*/
	if ( _tcsnicmp(tszPossibleBizarrePath, tszSystemRoot, iSystemRootLength) == 0)
	{ // We have a match...
/*
#ifdef _DEBUG
	_tprintf(TEXT("Matches [%s] sequence...\n"), tszSystemRoot);
#endif
*/
		// We simply replace \systemroot with %systemroot% and expand the
		// environement variables
		LPTSTR tszPointer = tszPossibleBizarrePath;

		for (unsigned int i = 0; i < iSystemRootLength; i++)
		{
			// Advance by the name space length...
			tszPointer = CharNext(tszPointer);
		}

		_tcscpy(tszTempPath, TEXT("%systemroot%"));
		_tcscat(tszTempPath, tszPointer);
		
		ExpandEnvironmentStrings(tszTempPath, tszPossibleBizarrePath, _MAX_PATH);
/*
#ifdef _DEBUG
	_tprintf(TEXT("Bizarre module path changed to [%s]\n"), tszPossibleBizarrePath);
#endif
*/
	} else
	if (_tcsnicmp(tszPossibleBizarrePath, tszNameSpace, iNameSpaceLength) == 0)
	{ // We have a match...
/*
#ifdef _DEBUG
	_tprintf(TEXT("Matches [%s] sequence...\n"), tszNameSpace);
#endif
*/
		// We simply remove the \??\ sequence from the namespace...
		LPTSTR tszPointer = tszPossibleBizarrePath;

		for (unsigned int i = 0; i < iNameSpaceLength; i++)
		{
			// Advance by the name space length...
			tszPointer = CharNext(tszPointer);
		}

		// We have to do this double copy since the strings would overlap
		_tcscpy(tszTempPath, tszPointer);
		_tcscpy(tszPossibleBizarrePath, tszTempPath);

/*
#ifdef _DEBUG
	_tprintf(TEXT("Bizarre module path changed to [%s]\n"), tszPossibleBizarrePath);
#endif
*/
	} else
	if (( iExpandedSystemRoot > 2) && _tcsnicmp(tszPossibleBizarrePath, &tszExpandedSystemRoot[2], iExpandedSystemRoot-2) == 0)
	{ // We need to match on the SystemRoot (without the SystemDrive)
/*
#ifdef _DEBUG
	_tprintf(TEXT("Matches [%s] sequence...\n"), tszSystemRoot);
#endif
*/
		// This little algorithm assumes that the Drive Letter is a single char...
		_tcscpy(tszTempPath, tszExpandedSystemRoot);
		_tcscat(tszTempPath, &tszPossibleBizarrePath[iExpandedSystemRoot-2]);
		_tcscpy(tszPossibleBizarrePath, tszTempPath);
/*
#ifdef _DEBUG
	_tprintf(TEXT("Bizarre module path changed to [%s]\n"), tszPossibleBizarrePath);
#endif
*/
	}
	return true;
}


bool CUtilityFunctions::FixupDeviceDriverPathIfNecessary(LPTSTR tszPossibleBaseDeviceDriverName, unsigned int iBufferLength)
{
    TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];

	// First, split the device driver name up into it's component parts...
	_tsplitpath(tszPossibleBaseDeviceDriverName, drive, dir, fname, ext);

	// Second, look to see if it's missing the drive and dir...
	if ( _tcsicmp(drive, TEXT("")) || _tcsicmp(dir, TEXT("")) )
		return true;

	// Third, create a new path... assuming that we'll find device drivers in the %systemroot%\system32\drivers directory
	TCHAR tszTempBuffer[_MAX_PATH];

	_tcscpy(tszTempBuffer, TEXT("%systemroot%\\system32\\drivers\\"));
	_tcscat(tszTempBuffer, tszPossibleBaseDeviceDriverName);

	ExpandEnvironmentStrings(tszTempBuffer, tszPossibleBaseDeviceDriverName, iBufferLength);

	return true;
}

// This function is provided in a Windows 2000 (NT 5.0) Version of DBGHELP.DLL.  By adding
// this function manually, I should run fine on NT 4.0 (and possibly Win9x)

/*++

Routine Description:

 The rules are:
  if Filename doesn't have a .dbg extension
   Look for
     1. <SymbolPath>\Symbols\<ext>\<filename>.dbg
     2. <SymbolPath>\Symbols\<ext>\<filename>.sym
     3. <SymbolPath>\<ext>\<filename>.dbg
     4. <SymbolPath>\<ext>\<filename>.sym
     5. <SymbolPath>\<filename>.dbg
     6. <SymbolPath>\<filename>.sym
     7. <FileNamePath>\<filename>.dbg
     8. <FileNamePath>\<filename>.sym
  if it does, skip the .sym lookup.

Arguments:
    tszFileName - Supplies a file name in one of three forms: fully qualified,
                <ext>\<filename>.dbg, or just filename.dbg
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns TRUE if the Symbol file is valid, or FALSE if the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

Return Value:

  The name of the Symbol file (either .dbg or .sym) and a handle to that file.

--*/

HANDLE CUtilityFunctions::FindDebugInfoFileEx(LPTSTR tszFileName, LPTSTR SymbolPath, LPTSTR DebugFilePath, PFIND_DEBUG_FILE_CALLBACK_T Callback, PVOID CallerData)
{

    return fnFindDebugInfoFileEx(tszFileName,
                                 SymbolPath,
                                 DebugFilePath,
                                 Callback,
                                 CallerData,
                                 0);
}

/*++

Routine Description:

 The rules are:
   Look for
     1. <SymbolPath>\Symbols\<ext>\<filename>.dbg
     3. <SymbolPath>\<ext>\<filename>.dbg
     5. <SymbolPath>\<filename>.dbg
     7. <FileNamePath>\<filename>.dbg

Arguments:
    tszFileName - Supplies a file name in one of three forms: fully qualified,
                <ext>\<filename>.dbg, or just filename.dbg
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file 
is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns TRUE if the Symbol file is valid, or FALSE if 
the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

    Flag - indicates that PDBs shouldn't be searched for

Return Value:

  The name of the Symbol file (either .dbg or .sym) and a handle to that file.

--*/
HANDLE 
CUtilityFunctions::fnFindDebugInfoFileEx(
					IN  LPTSTR tszFileName,
					IN  LPTSTR SymbolPath,
					OUT LPTSTR DebugFilePath,
					IN  PFIND_DEBUG_FILE_CALLBACK_T Callback,
					IN  PVOID CallerData,
					IN  DWORD flag
    )
{
	HRESULT hr = E_FAIL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    LPTSTR ExpSymbolPath = NULL, SymPathStart, PathEnd;
    DWORD ShareAttributes, cnt;
    LPTSTR InitialPath = NULL, Sub1 = NULL, Sub2 = NULL;
    TCHAR FilePath[_MAX_PATH + 1];
    TCHAR Drive[_MAX_DRIVE], Dir[_MAX_DIR], FilePart[_MAX_FNAME], Ext[_MAX_EXT];
    TCHAR *ExtDir;
	GUID  guid = {0};

    BOOL  found = FALSE;

	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();

	if (g_lpProgramOptions->IsRunningWindowsNT()) 
    {
        ShareAttributes = (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE);
    } else {
        ShareAttributes = (FILE_SHARE_READ | FILE_SHARE_WRITE);
    }

    __try {
        *DebugFilePath = _T('\0');

        // Step 1.  What do we have?
        _tsplitpath(tszFileName, Drive, Dir, FilePart, Ext);

        if (!_tcsicmp(Ext, TEXT(".dbg"))) {
            // We got a filename of the form: ext\filename.dbg.  Dir holds the extension already.
            ExtDir = Dir;
        } else {
            // Otherwise, skip the period and null out the Dir.
            ExtDir = CharNext(Ext);
        }

        ExpSymbolPath = ExpandPath(SymbolPath);
        SymPathStart = ExpSymbolPath;
        cnt = 0;

        do {
	
			PathEnd = _tcschr( SymPathStart, ';' );

            if (PathEnd) {
                *PathEnd = '\0';
            }

            if (!_tcsnicmp(SymPathStart, TEXT("SYMSRV*"), 7)) {

                *DebugFilePath = 0;
                if (!cnt && CallerData) 
		{
                    _tcscpy(FilePath, FilePart);
                    _tcscat(FilePath, TEXT(".dbg"));
                    
					CModuleInfo * lpModuleInfo = (CModuleInfo *)CallerData;

					if (fDebugSearchPaths)
					{
						_tprintf(TEXT("DBG Search - SYMSRV [%s,0x%x,0x%x]\n"),
								 SymPathStart, 
								 lpModuleInfo->GetPEImageTimeDateStamp(),
								 lpModuleInfo->GetPEImageSizeOfImage());
					}

					guid.Data1 = lpModuleInfo->GetPEImageTimeDateStamp();

					{
						char szSymPathStart[_MAX_PATH];
						char szDebugFilePath[_MAX_PATH];
						char szFilePath[_MAX_FNAME];
						
						CUtilityFunctions::CopyTSTRStringToAnsi(SymPathStart, szSymPathStart, _MAX_PATH);
						CUtilityFunctions::CopyTSTRStringToAnsi(FilePath, szFilePath, _MAX_FNAME);

						// Attempt the symbol server!!!
						if (SymFindFileInPath(	NULL,
												szSymPathStart,
												szFilePath,
												ULongToPtr(lpModuleInfo->GetPEImageTimeDateStamp()), // Cast to make compiler happy
												lpModuleInfo->GetPEImageSizeOfImage(),
												0,
												SSRVOPT_DWORD,	//Flags
												szDebugFilePath,
												NULL,
												NULL))
						{
							// On Success copy the string back...
							CUtilityFunctions::CopyAnsiStringToTSTR(szDebugFilePath, DebugFilePath, _MAX_PATH);
						}
					}
                }

            } else {

                switch (cnt) {

                case 0: // <SymbolPath>\symbols\<ext>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = TEXT("symbols");
                    Sub2 = ExtDir;
                    break;

                case 1: // <SymbolPath>\<ext>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = TEXT("");
                    Sub2 = ExtDir;
                    break;

                case 2: // <SymbolPath>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = TEXT("");
                    Sub2 = TEXT("");
                    break;

                case 3: // <FileNamePath>\<filename>.ext - A.K.A. what was passed to us
                    InitialPath = Drive;
                    Sub1 = TEXT("");
                    Sub2 = Dir;
                    // this stops us from checking out everything in the sympath
                    cnt++;
                    break;
                }

               // build fully-qualified filepath to look for

                _tcscpy(FilePath, InitialPath);
                EnsureTrailingBackslash(FilePath);
                _tcscat(FilePath, Sub1);
                EnsureTrailingBackslash(FilePath);
                _tcscat(FilePath, Sub2);
                EnsureTrailingBackslash(FilePath);
                _tcscat(FilePath, FilePart);

                _tcscpy(DebugFilePath, FilePath);
                _tcscat(DebugFilePath, TEXT(".dbg"));
            }

            // try to open the file

		if (*DebugFilePath) 
		{
				if (fDebugSearchPaths)
				{
					_tprintf(TEXT("DBG Search - Search here [%s]\n"), DebugFilePath);
				}
                FileHandle = CreateFile(DebugFilePath,
                                        GENERIC_READ,
                                        ShareAttributes,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL);

		// Probe for file (it's lame but we want to see if you have connectivity
		hr = CUtilityFunctions::ReportFailure(FileHandle, TEXT("DBG Search - Failed to open [%s]!  "), DebugFilePath);

                // if the file opens, bail from this loop

                if (FileHandle != INVALID_HANDLE_VALUE) 
                {
                    found = TRUE;

                    // If a callback exists... call it...
                    if (!Callback) 
                    {
                        break;
                    } else if (Callback(FileHandle, DebugFilePath, CallerData)) 
					{
                        break;
                    } else {
//#ifdef _DEBUG            
//                      _tprintf(TEXT("mismatched timestamp\n"));
//#endif
						CloseHandle(FileHandle);
                        FileHandle = INVALID_HANDLE_VALUE;
                    }
                }
                // if file is open, bail from this loop too - else continue
                if (FileHandle != INVALID_HANDLE_VALUE)
                    break;
            }

            // go to next item in the sympath

            if (PathEnd) {
                *PathEnd = _T(';');
                SymPathStart = PathEnd + 1;
            } else {
                SymPathStart = ExpSymbolPath;
                cnt++;
            }
        } while (cnt < 4);

    } __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(FileHandle);
        }
        
        FileHandle = INVALID_HANDLE_VALUE;
    }

	if (ExpSymbolPath) 
	{
        delete [] ExpSymbolPath;
		ExpSymbolPath = NULL;
    }

    if (FileHandle == INVALID_HANDLE_VALUE) 
    {
        FileHandle = NULL;
        DebugFilePath[0] = '\0';
    }
    
    if (!FileHandle                 // if we didn't get the right file...
        && found                    // but we found some file...
        && (flag & fdifRECURSIVE))  // and we were told to run recursively...
    {
        // try again without timestamp checking
        FileHandle = fnFindDebugInfoFileEx(tszFileName,
                                           SymbolPath,
                                           FilePath,
                                           NULL,
                                           0,
                                           flag);
        if (FileHandle && FileHandle != INVALID_HANDLE_VALUE)
           _tcscpy(DebugFilePath, FilePath);
    }

    return FileHandle;
}

void
CUtilityFunctions::EnsureTrailingBackslash(
    LPTSTR tsz
    )
{
    int i;

    i = _tcslen(tsz);
    if (!i)
        return;

    if (tsz[i - 1] == TEXT('\\'))
        return;

    tsz[i] = TEXT('\\');
    tsz[i + 1] = TEXT('\0');
}

void
CUtilityFunctions::RemoveTrailingBackslash(
    LPTSTR tsz
    )
{
    int i;

    i = _tcslen(tsz);
    if (!i)
        return;

    if (tsz[i - 1] == TEXT('\\'))
    {
    	tsz[i - 1] = TEXT('\0');
    }

	return;
}
HRESULT CUtilityFunctions::ReportFailure(HANDLE hHandle, LPCTSTR tszFormatSpecifier, LPCTSTR tszFilePathToTest)
{
	HRESULT hr = E_FAIL;
	DWORD dwGetLastError = ERROR_SUCCESS; // Assume success
	bool fQuietMode = g_lpProgramOptions->GetMode(CProgramOptions::QuietMode);

	if (hHandle == INVALID_HANDLE_VALUE)
	{
		dwGetLastError = GetLastError();

		switch (dwGetLastError)
		{
			// These are pretty typical and do not require output...
			case ERROR_FILE_NOT_FOUND:
			case ERROR_PATH_NOT_FOUND:
			case ERROR_NOT_READY:
//			case ERROR_BAD_NETPATH: - Maybe you want to know the server is down?
				break;

			default:
				// We failed... what is the reason?
				if (!fQuietMode)
				{
					_tprintf(TEXT("\n"));
					_tprintf(tszFormatSpecifier, tszFilePathToTest);
					CUtilityFunctions::PrintMessageString(dwGetLastError);
				}
				break;
		}
	}else
	{
		hr = S_OK;
	}

	return hr;
}

HRESULT CUtilityFunctions::VerifyFileExists(LPCTSTR tszFormatSpecifier, LPCTSTR tszFilePathToTest)
{
	WIN32_FIND_DATA FindFileData;

	HANDLE hFind;
	HRESULT hr = E_FAIL;

	hFind = FindFirstFile(tszFilePathToTest, &FindFileData);

	hr = ReportFailure(hFind, tszFormatSpecifier, tszFilePathToTest);

	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
		hFind = INVALID_HANDLE_VALUE;
	}
	return hr;
}

//
// Taken from UTF8.CPP (from the VC Linker code)
// 

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)
#define LOWER_6_BIT(u)        ((u) & 0x003f)
#define HIGH_SURROGATE_START  0xd800
#define LOW_SURROGATE_START   0xdc00

////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////
size_t CUtilityFunctions::UTF8ToUnicode(
    LPCSTR lpSrcStr,
    LPWSTR lpDestStr,
    size_t cchDest)
{
    return UTF8ToUnicodeCch(lpSrcStr, strlen(lpSrcStr) + 1, lpDestStr, cchDest);
}

#pragma warning( push )
#pragma warning( disable : 4244 )		// conversion from 'int' to 'unsigned short', possible loss of data

size_t CUtilityFunctions::UTF8ToUnicodeCch(
    LPCSTR lpSrcStr,
    size_t cchSrc,
    LPWSTR lpDestStr,
    size_t cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    size_t cchWC = 0;              // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar = 0;         // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    char UTF8;

    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            bSurrogatePair = FALSE;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                // error - not expecting a trail byte
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // If this is a surrogate unicode pair
                //
                if (nTB == 4)
                {
                    dwSurrogateChar = UTF8 >> nTB;
                    bSurrogatePair = TRUE;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest &&  cchSrc != (size_t)-1)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return 0;
    }

    //
    //  Return the number of Unicode characters written.
    //
    return cchWC;
}

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\symbolverification.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       symbolverification.cpp
//
//--------------------------------------------------------------------------

// SymbolVerification.cpp: implementation of the CSymbolVerification class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include "SymbolVerification.h"
#include "ModuleInfo.h"

#pragma warning (push)
#pragma warning ( disable : 4710)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSymbolVerification::CSymbolVerification()
{
	m_fComInitialized = false;

	m_fSQLServerConnectionAttempted = false;
	m_fSQLServerConnectionInitialized = false;

	// SQL2 - mjl 12/14/99
	m_fSQLServerConnectionAttempted2   = false;
	m_fSQLServerConnectionInitialized2 = false;

	// Initialize ADO Connection Object to NULL
	m_lpConnectionPointer  = NULL;
	m_lpConnectionPointer2 = NULL;	// SQL2 - mjl 12/14/99

	// Initialize MSDIA20.DLL Support
	m_lpDiaDataSource = NULL;
	m_fDiaDataSourcePresent = false;
}

CSymbolVerification::~CSymbolVerification()
{
	if (SQLServerConnectionInitialized())
	{
		TerminateSQLServerConnection();
	}

	if (SQLServerConnectionInitialized2())
	{
		TerminateSQLServerConnection2();
	}

	// Release our object if we have one
	if (m_lpDiaDataSource)
		m_lpDiaDataSource = NULL;

	if (m_fComInitialized)
		::CoUninitialize();
}

bool CSymbolVerification::Initialize()
{
	HRESULT hr = S_OK;

	// Initialize COM
	hr = ::CoInitialize(NULL); 

	if (FAILED(hr))
	{
		_tprintf(TEXT("Failed Initializing COM!\n"));
		return false;
	}

	// Com is initialized!
	m_fComInitialized = true;

	return true; 
}

bool CSymbolVerification::InitializeSQLServerConnection(LPTSTR tszSQLServerName)
{
	HRESULT hr = S_OK;
	TCHAR tszConnectionString[256];
	
	m_fSQLServerConnectionAttempted = true;

	_tprintf(TEXT("\nAttempting connection to SQL Server [%s]..."), tszSQLServerName);
	
	// Compose the Connection String
	// ie. "driver={SQL Server};server=<servername>;database=Symbols"
	_tcscpy(tszConnectionString, TEXT("driver={SQL Server};server="));
	_tcscat(tszConnectionString, tszSQLServerName);
	_tcscat(tszConnectionString, TEXT(";uid=Symbol_user;pwd=;database=Symbols"));

	try 
	{
		// Okay, we need a BSTR
		_bstr_t bstrConnectionString( tszConnectionString );

   		// Okay, let's try and actually create this Connection Pointer...
		hr = m_lpConnectionPointer.CreateInstance( __uuidof( Connection ) );

		if (FAILED(hr))
			goto error;

		// Now, let's use the Connection Pointer object to actually get connected...
		hr = m_lpConnectionPointer->Open( bstrConnectionString, "", "", -1);

		if (FAILED(hr))
			goto error;

		
		// Now, let's create a RecordSet for use later...
		hr = m_lpRecordSetPointer.CreateInstance( __uuidof( Recordset ) );

		if (FAILED(hr))
			goto error;

		m_fSQLServerConnectionInitialized = true;

		_tprintf(TEXT("SUCCESS!\n\n"));

	}	

	catch (_com_error &e )
	{
		_tprintf( TEXT("FAILURE!\n\n") );
		DumpCOMException(e);
		goto error;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE!\n\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto error;
	}
	
	goto cleanup;

error:
	if (m_lpConnectionPointer)
		m_lpConnectionPointer = NULL;

	_tprintf(TEXT("\nFAILURE Attempting SQL Server Connection!  Error = 0x%x\n"), hr);

	switch (hr)
	{
		case E_NOINTERFACE:
		case REGDB_E_CLASSNOTREG:
			_tprintf(TEXT("\nThe most likely reason for this is that your system does not have\n"));
			_tprintf(TEXT("the necessary ADO components installed.  You should install the\n"));
			_tprintf(TEXT("latest Microsoft Data Access Component (MDAC) release available on\n"));
			_tprintf(TEXT("http://www.microsoft.com/data/download.htm\n"));

			break;
	}


cleanup:
	return 	m_fSQLServerConnectionInitialized;
}

void CSymbolVerification::DumpCOMException(_com_error &e)
{
	_tprintf( TEXT("\tCode = %08lx\n"), e.Error());
	_tprintf( TEXT("\tCode meaning = %s\n"), e.ErrorMessage());

	_bstr_t bstrSource(e.Source());
	_bstr_t bstrDescription(e.Description());

	_tprintf( TEXT("\tSource = %s\n"), (LPCTSTR) bstrSource);
	_tprintf( TEXT("\tDescription = %s\n"), (LPCTSTR) bstrDescription);
}

bool CSymbolVerification::TerminateSQLServerConnection()
{
	// Free the Connection
	if (m_lpConnectionPointer)
		m_lpConnectionPointer = NULL;

	if (m_lpRecordSetPointer)
		m_lpRecordSetPointer = NULL;

	m_fSQLServerConnectionInitialized = false;

	return true;	
}

bool CSymbolVerification::SearchForDBGFileUsingSQLServer(LPTSTR tszPEImageModuleName, DWORD dwPEImageTimeDateStamp, CModuleInfo *lpModuleInfo)
{
	HRESULT hr = S_OK;
	FieldPtr		lpFieldSymbolPath = NULL;
	_variant_t		vSymbolPath;

	wchar_t			wszSymbolPath[_MAX_PATH+1];
	wchar_t			wszReturnedDBGFile[_MAX_FNAME];
	wchar_t			wszReturnedDBGFileExtension[_MAX_EXT];
	
	TCHAR			tszCommandText[256];
	TCHAR			tszLinkerDate[64]; // Plenty big...
	TCHAR			tszDBGFileName[_MAX_FNAME];
	
	HANDLE			hFileHandle;

	_tsplitpath(tszPEImageModuleName, NULL, NULL, tszDBGFileName, NULL);

#ifdef _UNICODE
	
	LPTSTR wszDBGFileName = tszDBGFileName;

#else

	wchar_t wszDBGFileName[_MAX_FNAME];

	MultiByteToWideChar(	CP_ACP,
							MB_PRECOMPOSED,
							tszDBGFileName,
							-1,
							wszDBGFileName,
							_MAX_FNAME);
#endif

	// Compose the Connection String
	// ie. "driver={SQL Server};server=<servername>;database=Symbols"
	_tcscpy(tszCommandText, TEXT("SELECT FILENAME FROM Symbols WHERE TIMESTAMP = '"));

	_stprintf(tszLinkerDate, TEXT("%x"), dwPEImageTimeDateStamp);
	_tcscat(tszCommandText, tszLinkerDate);

	_tcscat(tszCommandText, TEXT("'"));

	try {
		_bstr_t bstrCommandText( tszCommandText );

		m_lpRecordSetPointer = m_lpConnectionPointer->Execute(bstrCommandText, NULL, adCmdText);

		lpFieldSymbolPath = m_lpRecordSetPointer->Fields->GetItem(_variant_t( "FILENAME" ));

#ifdef _DEBUG
		_tprintf(TEXT("Searching SQL Server for matching symbol for [%s]\n"), tszPEImageModuleName);
#endif

		while (VARIANT_FALSE == m_lpRecordSetPointer->EndOfFile)
		{
			vSymbolPath.Clear();

			vSymbolPath = lpFieldSymbolPath->Value;

			wcscpy(wszSymbolPath, vSymbolPath.bstrVal);

			_wsplitpath(wszSymbolPath, NULL, NULL, wszReturnedDBGFile, wszReturnedDBGFileExtension);

			// 
			if ( (_wcsicmp(wszReturnedDBGFile, wszDBGFileName) == 0 ) &&
				 (_wcsicmp(wszReturnedDBGFileExtension, L".DBG") == 0 )
			   )
			{
#ifdef _DEBUG
				wprintf(L"Module path = %s\n", wszSymbolPath);
#endif
#ifdef _UNICODE
				wchar_t * tszSymbolPath = wszSymbolPath;
#else
				char   tszSymbolPath[_MAX_PATH+1];

				WideCharToMultiByte(CP_ACP,
						0,
						wszSymbolPath,
						-1,
						tszSymbolPath,
						_MAX_PATH+1,
					    NULL,
						NULL);
#endif
				// Okay, let's validate the DBG file we are pointing to...
				hFileHandle = CreateFile(	tszSymbolPath,
											GENERIC_READ,
											(FILE_SHARE_READ | FILE_SHARE_WRITE),
											NULL,
											OPEN_EXISTING,
											0,
											NULL);

				// Does the returned handle look good?
				if (hFileHandle != INVALID_HANDLE_VALUE)
				{
					lpModuleInfo->VerifyDBGFile(hFileHandle, tszSymbolPath, lpModuleInfo);
				} else
				{
					_tprintf(TEXT("\nERROR: Searching for [%s]!\n"), tszSymbolPath);
					CUtilityFunctions::PrintMessageString(GetLastError());
				}

				CloseHandle(hFileHandle);

				if (lpModuleInfo->GetDBGSymbolModuleStatus() == CModuleInfo::SymbolModuleStatus::SYMBOL_MATCH)
				{
					// Cool... it really does match...
					hr = m_lpRecordSetPointer->Close();
					goto cleanup;
				}
			}

			m_lpRecordSetPointer->MoveNext();
		}

		hr = m_lpRecordSetPointer->Close();

		if (FAILED(hr))
			goto error;

	}

	catch (_com_error &e )
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
		DumpCOMException(e);
		goto cleanup;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto cleanup;
	}
	
	goto cleanup;

error:

	TerminateSQLServerConnection();

	_tprintf(TEXT("FAILURE Attempting to query the SQL Server!\n"));

cleanup:
	return true;
}

/////////////////////////// mjl //////////////////////////////////////////

bool CSymbolVerification::InitializeSQLServerConnection2(LPTSTR tszSQLServerName)
{
	HRESULT hr = S_OK;
	TCHAR tszConnectionString[256];
	
	m_fSQLServerConnectionAttempted2 = true;

	_tprintf(TEXT("\nAttempting connection to SQL Server [%s]..."), tszSQLServerName);

	// Compose the Connection String
	// ie. "driver={SQL Server};server=<servername>;database=Symbols"
	_tcscpy(tszConnectionString, TEXT("driver={SQL Server};server="));
	_tcscat(tszConnectionString, tszSQLServerName);
//	_tcscat(tszConnectionString, TEXT(";uid=GUEST;pwd=guest;database=Symbols2"));
	_tcscat(tszConnectionString, TEXT(";uid=Symbol_user;pwd=;database=Symbols"));

	try 
	{
		// Okay, we need a BSTR
		_bstr_t bstrConnectionString( tszConnectionString );

   		// Okay, let's try and actually create this Connection Pointer...
		hr = m_lpConnectionPointer2.CreateInstance( __uuidof( Connection ) );

		if (FAILED(hr))
			goto error;

		// Now, let's use the Connection Pointer object to actually get connected...
		hr = m_lpConnectionPointer2->Open( bstrConnectionString, "", "", -1);

		if (FAILED(hr))
			goto error;

		
		// Now, let's create a RecordSet for use later...
		hr = m_lpRecordSetPointer2.CreateInstance( __uuidof( Recordset ) );

		if (FAILED(hr))
			goto error;

		_tprintf(TEXT("Complete\n"));

		m_fSQLServerConnectionInitialized2 = true;
	}	

	catch (_com_error &e )
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
		DumpCOMException(e);
		goto error;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto error;
	}
	
	goto cleanup;

error:
	if (m_lpConnectionPointer2)
		m_lpConnectionPointer2 = NULL;

	_tprintf(TEXT("\nFAILURE Attempting SQL Server Connection!  Error = 0x%x\n"), hr);

	switch (hr)
	{
		case E_NOINTERFACE:
		case REGDB_E_CLASSNOTREG:
			_tprintf(TEXT("\nThe most likely reason for this is that your system does not have\n"));
			_tprintf(TEXT("the necessary ADO components installed.  You should install the\n"));
			_tprintf(TEXT("latest Microsoft Data Access Component (MDAC) release available on\n"));
			_tprintf(TEXT("http://www.microsoft.com/data/download.htm\n"));

			break;
	}

cleanup:
	return 	m_fSQLServerConnectionInitialized2;
}


bool CSymbolVerification::TerminateSQLServerConnection2()
{
	// Free the Connection
	if (m_lpConnectionPointer2)
		m_lpConnectionPointer2 = NULL;

	if (m_lpRecordSetPointer2)
		m_lpRecordSetPointer2 = NULL;

	m_fSQLServerConnectionInitialized2 = false;

	return true;	
}

bool CSymbolVerification::SearchForDBGFileUsingSQLServer2(LPTSTR tszPEImageModuleName, DWORD dwPEImageTimeDateStamp, CModuleInfo *lpModuleInfo)
{
	HRESULT hr = S_OK;
	FieldPtr		lpFieldSymbolPath = NULL;
	_variant_t		vSymbolPath;

	_bstr_t			sFieldSymbolPath;
	wchar_t			wszSymbolPath[_MAX_PATH+1];
	wchar_t			wszReturnedDBGFile[_MAX_FNAME];
	wchar_t			wszReturnedDBGFileExtension[_MAX_EXT];
	
	TCHAR			tszCommandText[512];
	TCHAR			tszDBGFileName[_MAX_FNAME];
	
	HANDLE			hFileHandle;

	_tsplitpath(tszPEImageModuleName, NULL, NULL, tszDBGFileName, NULL);

#ifdef _UNICODE
	
	LPTSTR wszDBGFileName = tszDBGFileName;

#else

	wchar_t wszDBGFileName[_MAX_FNAME];

	MultiByteToWideChar(	CP_ACP,
							MB_PRECOMPOSED,
							tszDBGFileName,
							-1,
							wszDBGFileName,
							_MAX_FNAME);
#endif

	// Compose the Query String
	_stprintf(tszCommandText, TEXT("SELECT tblDBGModulePaths.DBGModulePath FROM tblDBGModules,tblDBGModulePaths WHERE tblDBGModules.DBGFilename='%s.DBG' AND tblDBGModules.TimeDateStamp='%d' AND tblDBGModules.DBGModuleID = tblDBGModulePaths.DBGModuleID"),tszDBGFileName,dwPEImageTimeDateStamp);
	try {
		_bstr_t bstrCommandText( tszCommandText );

		m_lpRecordSetPointer2 = m_lpConnectionPointer2->Execute(bstrCommandText, NULL, adCmdText);

	    while ( !m_lpRecordSetPointer2->EndOfFile )
		{
			vSymbolPath = m_lpRecordSetPointer2->Fields->GetItem("DBGModulePath")->Value;
 		    lpFieldSymbolPath = m_lpRecordSetPointer2->Fields->GetItem(_variant_t( "DBGModulePath" ));

#ifdef _DEBUG
		    _tprintf(TEXT("Searching SQL Server for matching symbol for [%s]\n"), tszPEImageModuleName);
#endif
			vSymbolPath.Clear();

			vSymbolPath = lpFieldSymbolPath->Value;

			wcscpy(wszSymbolPath, vSymbolPath.bstrVal);

			_wsplitpath(wszSymbolPath, NULL, NULL, wszReturnedDBGFile, wszReturnedDBGFileExtension);

			// 
			if ( (_wcsicmp(wszReturnedDBGFile, wszDBGFileName) == 0 ) &&
				 (_wcsicmp(wszReturnedDBGFileExtension, L".DBG") == 0 )
			   )
			{
#ifdef _DEBUG
				wprintf(L"Module path = %s\n", wszSymbolPath);
#endif
#ifdef _UNICODE
				wchar_t * tszSymbolPath = wszSymbolPath;
#else
				char   tszSymbolPath[_MAX_PATH+1];

				WideCharToMultiByte(CP_ACP,
						0,
						wszSymbolPath,
						-1,
						tszSymbolPath,
						_MAX_PATH+1,
					    NULL,
						NULL);
#endif
				// Okay, let's validate the DBG file we are pointing to...
				hFileHandle = CreateFile(	tszSymbolPath,
											GENERIC_READ,
											(FILE_SHARE_READ | FILE_SHARE_WRITE),
											NULL,
											OPEN_EXISTING,
											0,
											NULL);

				// Does the returned handle look good?
				if (hFileHandle != INVALID_HANDLE_VALUE)
				{
					lpModuleInfo->VerifyDBGFile(hFileHandle, tszSymbolPath, lpModuleInfo);
				} else
				{
					_tprintf(TEXT("\nERROR: Searching for [%s]!\n"), tszSymbolPath);
					CUtilityFunctions::PrintMessageString(GetLastError());
				}

				CloseHandle(hFileHandle);

				if (lpModuleInfo->GetDBGSymbolModuleStatus() == CModuleInfo::SymbolModuleStatus::SYMBOL_MATCH)
				{
					// Cool... it really does match...
					hr = m_lpRecordSetPointer2->Close();
					goto cleanup;
				}
			}

			m_lpRecordSetPointer2->MoveNext();
		}

		hr = m_lpRecordSetPointer2->Close();

		if (FAILED(hr))
			goto error;

	}

	catch (_com_error &e )
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
		DumpCOMException(e);
		goto cleanup;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto cleanup;
	}
	
	goto cleanup;

error:

	TerminateSQLServerConnection();

	_tprintf(TEXT("FAILURE Attempting to query the SQL Server!\n"));

cleanup:
	return true;
}

bool CSymbolVerification::SearchForPDBFileUsingSQLServer2(LPTSTR tszPEImageModuleName, DWORD dwPDBSignature, CModuleInfo *lpModuleInfo)
{
	HRESULT hr = S_OK;
	FieldPtr		lpFieldSymbolPath = NULL;
	_variant_t		vSymbolPath;

	_bstr_t			sFieldSymbolPath;
	wchar_t			wszSymbolPath[_MAX_PATH+1];
	wchar_t			wszReturnedPDBFile[_MAX_FNAME];
	wchar_t			wszReturnedPDBFileExtension[_MAX_EXT];
	
	TCHAR			tszCommandText[512];
	TCHAR			tszPDBFileName[_MAX_FNAME];
	
	HANDLE			hFileHandle;

	_tsplitpath(tszPEImageModuleName, NULL, NULL, tszPDBFileName, NULL);

#ifdef _UNICODE
	
	LPTSTR wszPDBFileName = tszPDBFileName;

#else

	wchar_t wszPDBFileName[_MAX_FNAME];

	MultiByteToWideChar(	CP_ACP,
							MB_PRECOMPOSED,
							tszPDBFileName,
							-1,
							wszPDBFileName,
							_MAX_FNAME);
#endif

	// Compose the Query String
	_stprintf(tszCommandText, TEXT("SELECT tblPDBModulePaths.PDBModulePath FROM tblPDBModules,tblPDBModulePaths WHERE tblPDBModules.PDBFilename='%s.PDB' AND tblPDBModules.PDBSignature='%d' AND tblPDBModules.PDBModuleID = tblPDBModulePaths.PDBModuleID"),tszPDBFileName,dwPDBSignature);
	try {
		_bstr_t bstrCommandText( tszCommandText );

		m_lpRecordSetPointer2 = m_lpConnectionPointer2->Execute(bstrCommandText, NULL, adCmdText);

	    while ( !m_lpRecordSetPointer2->EndOfFile )
		{
			vSymbolPath = m_lpRecordSetPointer2->Fields->GetItem("PDBModulePath")->Value;
 		    lpFieldSymbolPath = m_lpRecordSetPointer2->Fields->GetItem(_variant_t( "PDBModulePath" ));

#ifdef _DEBUG
		    _tprintf(TEXT("Searching SQL Server for matching symbol for [%s]\n"), tszPEImageModuleName);
#endif

			vSymbolPath.Clear();

			vSymbolPath = lpFieldSymbolPath->Value;

			wcscpy(wszSymbolPath, vSymbolPath.bstrVal);

			_wsplitpath(wszSymbolPath, NULL, NULL, wszReturnedPDBFile, wszReturnedPDBFileExtension);

			if ( (_wcsicmp(wszReturnedPDBFile, wszPDBFileName) == 0 ) &&
				 (_wcsicmp(wszReturnedPDBFileExtension, L".PDB") == 0 )
			   )
			{
#ifdef _DEBUG
				wprintf(L"Module path = %s\n", wszSymbolPath);
#endif
#ifdef _UNICODE
				wchar_t * tszSymbolPath = wszSymbolPath;
#else
				char   tszSymbolPath[_MAX_PATH+1];

				WideCharToMultiByte(CP_ACP,
						0,
						wszSymbolPath,
						-1,
						tszSymbolPath,
						_MAX_PATH+1,
					    NULL,
						NULL);
#endif
				// Okay, let's validate the DBG file we are pointing to...
				hFileHandle = CreateFile(	tszSymbolPath,
											GENERIC_READ,
											(FILE_SHARE_READ | FILE_SHARE_WRITE),
											NULL,
											OPEN_EXISTING,
											0,
											NULL);

				// Does the returned handle look good?
				if (hFileHandle != INVALID_HANDLE_VALUE)
				{
					lpModuleInfo->VerifyPDBFile(hFileHandle, tszSymbolPath, lpModuleInfo);
				} else
				{
					_tprintf(TEXT("\nERROR: Searching for [%s]!\n"), tszSymbolPath);
					CUtilityFunctions::PrintMessageString(GetLastError());
				}

				CloseHandle(hFileHandle);

				if (lpModuleInfo->GetPDBSymbolModuleStatus() == CModuleInfo::SymbolModuleStatus::SYMBOL_MATCH)
				{
					// Cool... it really does match...
					hr = m_lpRecordSetPointer2->Close();
					goto cleanup;
				}
			}

			m_lpRecordSetPointer2->MoveNext();
		}

		hr = m_lpRecordSetPointer2->Close();

		if (FAILED(hr))
			goto error;

	}

	catch (_com_error &e )
	{
		_tprintf( TEXT("\nFAILURE Attempting SQL2 Server Connection!\n") );
		DumpCOMException(e);
		goto cleanup;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE Attempting SQL2 Server Connection!\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto cleanup;
	}
	
	goto cleanup;

error:

	TerminateSQLServerConnection2();

	_tprintf(TEXT("FAILURE Attempting to query the SQL Server!\n"));

cleanup:
	return true;
}

HRESULT CSymbolVerification::InitializeDIASupport()
{
	HRESULT hr;

	m_fDiaDataSourcePresent = false;
	
	hr = diaGetDataSource(m_lpDiaDataSource);
	
	if (SUCCEEDED(hr))
	{
		m_fDiaDataSourcePresent = true;
	};
	
	return hr;
}


HRESULT
CSymbolVerification::diaGetDataSource(CComPtr<IDiaDataSource> & source)
{
	const char* diaPaths[] = {
			"msdia20.dll",
	//        "..\\bin\\msdia20.dll",
	//        "..\\..\\bin\\msdia20.dll",
			0
	};

	HRESULT hr = S_OK;

	// Obtain Access To The Provider
	hr = CoCreateInstance(CLSID_DiaSource, NULL, CLSCTX_INPROC_SERVER, IID_IDiaDataSource, (void **) &source );

	if (FAILED(hr))
	{
		int i;

		switch (hr)
		{
			case REGDB_E_CLASSNOTREG:

				for (i = 0; FAILED( hr ) && diaPaths[i] != 0; ++i ) 
				{
	                hr = NoRegCoCreate( diaPaths[i], CLSID_DiaSource, IID_IDiaDataSource, (void **) &source );
		        }
				break;
			
			default:
				break;
		}
	}

	return hr;

}

bool CSymbolVerification::diaOldPdbFormatFound(GUID * guid, DWORD sig)
{
	bool fOldPdbFormatFound = false;

	if ( (guid->Data1 == sig) &&
		 (guid->Data2 == 0) &&
		 (guid->Data3 == 0) )
	{
		// Change our assumption.... this is looking like an old PDB format
		fOldPdbFormatFound = true;
		
		for (int i = 0; i < 8; i++) 
		{
			if (guid->Data4[i])
			{
				// Oops... found some data... must be a new PDB format
				fOldPdbFormatFound = false;
				break;
			}
		}
	}
	return fOldPdbFormatFound;
}

bool CSymbolVerification::ValidGUID(GUID * guid)
{
    int i;

    if (!guid)
        return false;

    if (guid->Data1)
        return true;
    if (guid->Data2)
        return true;
    if (guid->Data3)
        return true;
    for (i = 0; i < 8; i++) {
        if (guid->Data4[i])
            return true;
    }

    return false;
}

/*
bool CSymbolVerification::ValidSig(DWORD sig, GUID *guid)
{
    if (ValidGUID(guid))
        return true;

    if (sig)
        return true;

    return false;
}
*/



#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\utilityfunctions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       utilityfunctions.h
//
//--------------------------------------------------------------------------

// UtilityFunctions.h: interface for the CUtilityFunctions class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UTILITYFUNCTIONS_H__C97C8493_D457_11D2_845B_0010A4F1B732__INCLUDED_)
#define AFX_UTILITYFUNCTIONS_H__C97C8493_D457_11D2_845B_0010A4F1B732__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>
#include <DBGHELP.H>

typedef struct structENVBLOCK
{
	LPTSTR tszEnvironmentVariable;
	LPTSTR tszRegistryKey;
	LPTSTR tszRegistryValue;
	LPTSTR tszFriendlyProductName;
} ENVBLOCK;

extern ENVBLOCK g_tszEnvironmentVariables[];

// Define the callback method for FindDebugInfoFileEx()
typedef BOOL (*PFIND_DEBUG_FILE_CALLBACK_T)(HANDLE FileHandle,LPTSTR FileName,PVOID CallerData);


#define fdifRECURSIVE   0x1

class CUtilityFunctions  
{
public:
	CUtilityFunctions();
	virtual ~CUtilityFunctions();

	static LPWSTR CopyTSTRStringToUnicode(LPCTSTR tszInputString, LPWSTR wszOutputBuffer = NULL, unsigned int iBufferLength = 0);
	static LPSTR  CopyTSTRStringToAnsi(LPCTSTR tszInputString, LPSTR szOutputBuffer = NULL, unsigned int iBufferLength = 0);
	static LPTSTR CopyUnicodeStringToTSTR(LPCWSTR wszInputString, LPTSTR tszOutputBuffer = NULL, unsigned int iBufferLength = 0);
	static LPTSTR CopyAnsiStringToTSTR(LPCSTR szInputString, LPTSTR tszOutputBuffer = NULL, unsigned int iBufferLength = 0);
	static LPTSTR CopyString(LPCTSTR tszInputString, LPTSTR tszDestinationString = NULL);
	static size_t UTF8ToUnicode(LPCSTR lpSrcStr, LPWSTR lpDestStr, size_t cchDest);
	static size_t UTF8ToUnicodeCch(LPCSTR lpSrcStr, size_t cchSrc, LPWSTR lpDestStr, size_t cchDest);

	static HRESULT VerifyFileExists(LPCTSTR tszFormatSpecifier, LPCTSTR tszFilePathToTest);
	static HRESULT ReportFailure(HANDLE hHandle, LPCTSTR tszFormatSpecifier, LPCTSTR tszFilePathToTest);
	static LPTSTR ExpandPath(LPCTSTR tszInputPath, bool fExpandSymSrv = false);
	static bool UnMungePathIfNecessary(LPTSTR tszPossibleBizarrePath);
	static bool FixupDeviceDriverPathIfNecessary(LPTSTR tszPossibleBaseDeviceDriverName, unsigned int iBufferLength);
	static bool ContainsWildCardCharacter(LPCTSTR tszPathToSearch);
	static bool CopySymbolFileToSymbolTree(LPCTSTR tszImageModuleName, LPTSTR * lplptszOriginalPathToSymbolFile, LPCTSTR tszSymbolTreePath);
	static bool CopySymbolFileToImagePath(LPCTSTR tszImageModulePath, LPTSTR * lplptszOriginalPathToSymbolFile);
	static DWORD CALLBACK CopySymbolFileCallback(
								LARGE_INTEGER TotalFileSize,          // file size
								LARGE_INTEGER TotalBytesTransferred,  // bytes transferred
								LARGE_INTEGER StreamSize,             // bytes in stream
								LARGE_INTEGER StreamBytesTransferred, // bytes transferred for stream
								DWORD dwStreamNumber,                 // current stream
								DWORD dwCallbackReason,               // callback reason
								HANDLE hSourceFile,                   // handle to source file
								HANDLE hDestinationFile,              // handle to destination file
								LPVOID lpData                         // from CopyFileEx
								);

	static void PrintMessageString(DWORD dwMessageId);
	static HANDLE FindDebugInfoFileEx(LPTSTR tszFileName, LPTSTR SymbolPath, LPTSTR DebugFilePath, PFIND_DEBUG_FILE_CALLBACK_T Callback, PVOID CallerData);
    static HANDLE FindDebugInfoFileEx2(LPTSTR tszFileName, LPTSTR SymbolPath, /* LPTSTR DebugFilePath, */ PFIND_DEBUG_FILE_CALLBACK_T Callback, PVOID CallerData);
	static HANDLE fnFindDebugInfoFileEx(LPTSTR tszFileName, LPTSTR SymbolPath, LPTSTR DebugFilePath, PFIND_DEBUG_FILE_CALLBACK_T Callback, PVOID CallerData, DWORD flag);
	
	static void EnsureTrailingBackslash(LPTSTR tsz);
	static void RemoveTrailingBackslash(LPTSTR tsz);
	static bool   ScavengeForSymbolFiles(LPCTSTR tszSymbolPathStart, LPCTSTR tszSymbolToSearchFor, PFIND_DEBUG_FILE_CALLBACK_T Callback, PVOID CallerData, LPHANDLE lpFileHandle, int iRecurseDepth);

	// Output Assistance!
	static inline void OutputLineOfStars() {
		_tprintf(TEXT("*******************************************************************************\n"));
	};

	static inline void OutputLineOfDashes() {
		_tprintf(TEXT("-------------------------------------------------------------------------------\n"));
	};

protected:
	static LPTSTR ReAlloc(LPTSTR tszOutputPathBuffer, LPTSTR * ptszOutputPathPointer, size_t size);
	enum { MAX_RECURSE_DEPTH = 30 };
	static DWORD m_dwGetLastError;
};

#endif // !defined(AFX_UTILITYFUNCTIONS_H__C97C8493_D457_11D2_845B_0010A4F1B732__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\imports\include\dia2.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu May 31 03:31:56 2001
 */
/* Compiler settings for f:\vs70builds\9247\vc\langapi\idl\dia2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dia2_h__
#define __dia2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDiaLoadCallback_FWD_DEFINED__
#define __IDiaLoadCallback_FWD_DEFINED__
typedef interface IDiaLoadCallback IDiaLoadCallback;
#endif 	/* __IDiaLoadCallback_FWD_DEFINED__ */


#ifndef __IDiaReadExeAtOffsetCallback_FWD_DEFINED__
#define __IDiaReadExeAtOffsetCallback_FWD_DEFINED__
typedef interface IDiaReadExeAtOffsetCallback IDiaReadExeAtOffsetCallback;
#endif 	/* __IDiaReadExeAtOffsetCallback_FWD_DEFINED__ */


#ifndef __IDiaReadExeAtRVACallback_FWD_DEFINED__
#define __IDiaReadExeAtRVACallback_FWD_DEFINED__
typedef interface IDiaReadExeAtRVACallback IDiaReadExeAtRVACallback;
#endif 	/* __IDiaReadExeAtRVACallback_FWD_DEFINED__ */


#ifndef __IDiaDataSource_FWD_DEFINED__
#define __IDiaDataSource_FWD_DEFINED__
typedef interface IDiaDataSource IDiaDataSource;
#endif 	/* __IDiaDataSource_FWD_DEFINED__ */


#ifndef __IDiaEnumSymbols_FWD_DEFINED__
#define __IDiaEnumSymbols_FWD_DEFINED__
typedef interface IDiaEnumSymbols IDiaEnumSymbols;
#endif 	/* __IDiaEnumSymbols_FWD_DEFINED__ */


#ifndef __IDiaEnumSymbolsByAddr_FWD_DEFINED__
#define __IDiaEnumSymbolsByAddr_FWD_DEFINED__
typedef interface IDiaEnumSymbolsByAddr IDiaEnumSymbolsByAddr;
#endif 	/* __IDiaEnumSymbolsByAddr_FWD_DEFINED__ */


#ifndef __IDiaEnumSourceFiles_FWD_DEFINED__
#define __IDiaEnumSourceFiles_FWD_DEFINED__
typedef interface IDiaEnumSourceFiles IDiaEnumSourceFiles;
#endif 	/* __IDiaEnumSourceFiles_FWD_DEFINED__ */


#ifndef __IDiaEnumLineNumbers_FWD_DEFINED__
#define __IDiaEnumLineNumbers_FWD_DEFINED__
typedef interface IDiaEnumLineNumbers IDiaEnumLineNumbers;
#endif 	/* __IDiaEnumLineNumbers_FWD_DEFINED__ */


#ifndef __IDiaEnumInjectedSources_FWD_DEFINED__
#define __IDiaEnumInjectedSources_FWD_DEFINED__
typedef interface IDiaEnumInjectedSources IDiaEnumInjectedSources;
#endif 	/* __IDiaEnumInjectedSources_FWD_DEFINED__ */


#ifndef __IDiaEnumSegments_FWD_DEFINED__
#define __IDiaEnumSegments_FWD_DEFINED__
typedef interface IDiaEnumSegments IDiaEnumSegments;
#endif 	/* __IDiaEnumSegments_FWD_DEFINED__ */


#ifndef __IDiaEnumSectionContribs_FWD_DEFINED__
#define __IDiaEnumSectionContribs_FWD_DEFINED__
typedef interface IDiaEnumSectionContribs IDiaEnumSectionContribs;
#endif 	/* __IDiaEnumSectionContribs_FWD_DEFINED__ */


#ifndef __IDiaEnumFrameData_FWD_DEFINED__
#define __IDiaEnumFrameData_FWD_DEFINED__
typedef interface IDiaEnumFrameData IDiaEnumFrameData;
#endif 	/* __IDiaEnumFrameData_FWD_DEFINED__ */


#ifndef __IDiaEnumDebugStreamData_FWD_DEFINED__
#define __IDiaEnumDebugStreamData_FWD_DEFINED__
typedef interface IDiaEnumDebugStreamData IDiaEnumDebugStreamData;
#endif 	/* __IDiaEnumDebugStreamData_FWD_DEFINED__ */


#ifndef __IDiaEnumDebugStreams_FWD_DEFINED__
#define __IDiaEnumDebugStreams_FWD_DEFINED__
typedef interface IDiaEnumDebugStreams IDiaEnumDebugStreams;
#endif 	/* __IDiaEnumDebugStreams_FWD_DEFINED__ */


#ifndef __IDiaAddressMap_FWD_DEFINED__
#define __IDiaAddressMap_FWD_DEFINED__
typedef interface IDiaAddressMap IDiaAddressMap;
#endif 	/* __IDiaAddressMap_FWD_DEFINED__ */


#ifndef __IDiaSession_FWD_DEFINED__
#define __IDiaSession_FWD_DEFINED__
typedef interface IDiaSession IDiaSession;
#endif 	/* __IDiaSession_FWD_DEFINED__ */


#ifndef __IDiaSymbol_FWD_DEFINED__
#define __IDiaSymbol_FWD_DEFINED__
typedef interface IDiaSymbol IDiaSymbol;
#endif 	/* __IDiaSymbol_FWD_DEFINED__ */


#ifndef __IDiaSourceFile_FWD_DEFINED__
#define __IDiaSourceFile_FWD_DEFINED__
typedef interface IDiaSourceFile IDiaSourceFile;
#endif 	/* __IDiaSourceFile_FWD_DEFINED__ */


#ifndef __IDiaLineNumber_FWD_DEFINED__
#define __IDiaLineNumber_FWD_DEFINED__
typedef interface IDiaLineNumber IDiaLineNumber;
#endif 	/* __IDiaLineNumber_FWD_DEFINED__ */


#ifndef __IDiaSectionContrib_FWD_DEFINED__
#define __IDiaSectionContrib_FWD_DEFINED__
typedef interface IDiaSectionContrib IDiaSectionContrib;
#endif 	/* __IDiaSectionContrib_FWD_DEFINED__ */


#ifndef __IDiaSegment_FWD_DEFINED__
#define __IDiaSegment_FWD_DEFINED__
typedef interface IDiaSegment IDiaSegment;
#endif 	/* __IDiaSegment_FWD_DEFINED__ */


#ifndef __IDiaInjectedSource_FWD_DEFINED__
#define __IDiaInjectedSource_FWD_DEFINED__
typedef interface IDiaInjectedSource IDiaInjectedSource;
#endif 	/* __IDiaInjectedSource_FWD_DEFINED__ */


#ifndef __IDiaStackWalkFrame_FWD_DEFINED__
#define __IDiaStackWalkFrame_FWD_DEFINED__
typedef interface IDiaStackWalkFrame IDiaStackWalkFrame;
#endif 	/* __IDiaStackWalkFrame_FWD_DEFINED__ */


#ifndef __IDiaFrameData_FWD_DEFINED__
#define __IDiaFrameData_FWD_DEFINED__
typedef interface IDiaFrameData IDiaFrameData;
#endif 	/* __IDiaFrameData_FWD_DEFINED__ */


#ifndef __IDiaImageData_FWD_DEFINED__
#define __IDiaImageData_FWD_DEFINED__
typedef interface IDiaImageData IDiaImageData;
#endif 	/* __IDiaImageData_FWD_DEFINED__ */


#ifndef __IDiaTable_FWD_DEFINED__
#define __IDiaTable_FWD_DEFINED__
typedef interface IDiaTable IDiaTable;
#endif 	/* __IDiaTable_FWD_DEFINED__ */


#ifndef __IDiaEnumTables_FWD_DEFINED__
#define __IDiaEnumTables_FWD_DEFINED__
typedef interface IDiaEnumTables IDiaEnumTables;
#endif 	/* __IDiaEnumTables_FWD_DEFINED__ */


#ifndef __DiaSource_FWD_DEFINED__
#define __DiaSource_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaSource DiaSource;
#else
typedef struct DiaSource DiaSource;
#endif /* __cplusplus */

#endif 	/* __DiaSource_FWD_DEFINED__ */


#ifndef __DiaSourceAlt_FWD_DEFINED__
#define __DiaSourceAlt_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaSourceAlt DiaSourceAlt;
#else
typedef struct DiaSourceAlt DiaSourceAlt;
#endif /* __cplusplus */

#endif 	/* __DiaSourceAlt_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"
#include "cvconst.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dia2_0000 */
/* [local] */ 


enum NameSearchOptions
    {	nsNone	= 0,
	nsfCaseSensitive	= 0x1,
	nsfCaseInsensitive	= 0x2,
	nsfFNameExt	= 0x4,
	nsfRegularExpression	= 0x8,
	nsfUndecoratedName	= 0x10,
	nsCaseSensitive	= nsfCaseSensitive,
	nsCaseInsensitive	= nsfCaseInsensitive,
	nsFNameExt	= nsfCaseInsensitive | nsfFNameExt,
	nsRegularExpression	= nsfRegularExpression | nsfCaseSensitive,
	nsCaseInRegularExpression	= nsfRegularExpression | nsfCaseInsensitive
    } ;

enum __MIDL___MIDL_itf_dia2_0000_0001
    {	E_PDB_OK	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )1),
	E_PDB_USAGE	= E_PDB_OK + 1,
	E_PDB_OUT_OF_MEMORY	= E_PDB_USAGE + 1,
	E_PDB_FILE_SYSTEM	= E_PDB_OUT_OF_MEMORY + 1,
	E_PDB_NOT_FOUND	= E_PDB_FILE_SYSTEM + 1,
	E_PDB_INVALID_SIG	= E_PDB_NOT_FOUND + 1,
	E_PDB_INVALID_AGE	= E_PDB_INVALID_SIG + 1,
	E_PDB_PRECOMP_REQUIRED	= E_PDB_INVALID_AGE + 1,
	E_PDB_OUT_OF_TI	= E_PDB_PRECOMP_REQUIRED + 1,
	E_PDB_NOT_IMPLEMENTED	= E_PDB_OUT_OF_TI + 1,
	E_PDB_V1_PDB	= E_PDB_NOT_IMPLEMENTED + 1,
	E_PDB_FORMAT	= E_PDB_V1_PDB + 1,
	E_PDB_LIMIT	= E_PDB_FORMAT + 1,
	E_PDB_CORRUPT	= E_PDB_LIMIT + 1,
	E_PDB_TI16	= E_PDB_CORRUPT + 1,
	E_PDB_ACCESS_DENIED	= E_PDB_TI16 + 1,
	E_PDB_ILLEGAL_TYPE_EDIT	= E_PDB_ACCESS_DENIED + 1,
	E_PDB_INVALID_EXECUTABLE	= E_PDB_ILLEGAL_TYPE_EDIT + 1,
	E_PDB_DBG_NOT_FOUND	= E_PDB_INVALID_EXECUTABLE + 1,
	E_PDB_NO_DEBUG_INFO	= E_PDB_DBG_NOT_FOUND + 1,
	E_PDB_INVALID_EXE_TIMESTAMP	= E_PDB_NO_DEBUG_INFO + 1,
	E_PDB_RESERVED	= E_PDB_INVALID_EXE_TIMESTAMP + 1,
	E_PDB_DEBUG_INFO_NOT_IN_PDB	= E_PDB_RESERVED + 1,
	E_PDB_MAX	= E_PDB_DEBUG_INFO_NOT_IN_PDB + 1
    } ;

enum __MIDL___MIDL_itf_dia2_0000_0002
    {	DIA_E_MODNOTFOUND	= E_PDB_MAX + 1,
	DIA_E_PROCNOTFOUND	= DIA_E_MODNOTFOUND + 1
    } ;
typedef void ( __cdecl *PfnPDBDebugDirV )( 
    BOOL __MIDL_0010,
    void *__MIDL_0011);












extern RPC_IF_HANDLE __MIDL_itf_dia2_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0000_v0_0_s_ifspec;

#ifndef __IDiaLoadCallback_INTERFACE_DEFINED__
#define __IDiaLoadCallback_INTERFACE_DEFINED__

/* interface IDiaLoadCallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLoadCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C32ADB82-73F4-421b-95D5-A4706EDF5DBE")
    IDiaLoadCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyDebugDir( 
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOpenDBG( 
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOpenPDB( 
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictRegistryAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictSymbolServerAccess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLoadCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLoadCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLoadCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLoadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyDebugDir )( 
            IDiaLoadCallback * This,
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenDBG )( 
            IDiaLoadCallback * This,
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenPDB )( 
            IDiaLoadCallback * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictRegistryAccess )( 
            IDiaLoadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictSymbolServerAccess )( 
            IDiaLoadCallback * This);
        
        END_INTERFACE
    } IDiaLoadCallbackVtbl;

    interface IDiaLoadCallback
    {
        CONST_VTBL struct IDiaLoadCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLoadCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLoadCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLoadCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLoadCallback_NotifyDebugDir(This,fExecutable,cbData,data)	\
    (This)->lpVtbl -> NotifyDebugDir(This,fExecutable,cbData,data)

#define IDiaLoadCallback_NotifyOpenDBG(This,dbgPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenDBG(This,dbgPath,resultCode)

#define IDiaLoadCallback_NotifyOpenPDB(This,pdbPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenPDB(This,pdbPath,resultCode)

#define IDiaLoadCallback_RestrictRegistryAccess(This)	\
    (This)->lpVtbl -> RestrictRegistryAccess(This)

#define IDiaLoadCallback_RestrictSymbolServerAccess(This)	\
    (This)->lpVtbl -> RestrictSymbolServerAccess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyDebugDir_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ BOOL fExecutable,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE data[  ]);


void __RPC_STUB IDiaLoadCallback_NotifyDebugDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyOpenDBG_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ LPCOLESTR dbgPath,
    /* [in] */ HRESULT resultCode);


void __RPC_STUB IDiaLoadCallback_NotifyOpenDBG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyOpenPDB_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ LPCOLESTR pdbPath,
    /* [in] */ HRESULT resultCode);


void __RPC_STUB IDiaLoadCallback_NotifyOpenPDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_RestrictRegistryAccess_Proxy( 
    IDiaLoadCallback * This);


void __RPC_STUB IDiaLoadCallback_RestrictRegistryAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_RestrictSymbolServerAccess_Proxy( 
    IDiaLoadCallback * This);


void __RPC_STUB IDiaLoadCallback_RestrictSymbolServerAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLoadCallback_INTERFACE_DEFINED__ */


#ifndef __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__
#define __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__

/* interface IDiaReadExeAtOffsetCallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaReadExeAtOffsetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587A461C-B80B-4f54-9194-5032589A6319")
    IDiaReadExeAtOffsetCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadExecutableAt( 
            /* [in] */ DWORDLONG fileOffset,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaReadExeAtOffsetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaReadExeAtOffsetCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaReadExeAtOffsetCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaReadExeAtOffsetCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadExecutableAt )( 
            IDiaReadExeAtOffsetCallback * This,
            /* [in] */ DWORDLONG fileOffset,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaReadExeAtOffsetCallbackVtbl;

    interface IDiaReadExeAtOffsetCallback
    {
        CONST_VTBL struct IDiaReadExeAtOffsetCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaReadExeAtOffsetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaReadExeAtOffsetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaReadExeAtOffsetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaReadExeAtOffsetCallback_ReadExecutableAt(This,fileOffset,cbData,pcbData,data)	\
    (This)->lpVtbl -> ReadExecutableAt(This,fileOffset,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaReadExeAtOffsetCallback_ReadExecutableAt_Proxy( 
    IDiaReadExeAtOffsetCallback * This,
    /* [in] */ DWORDLONG fileOffset,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaReadExeAtOffsetCallback_ReadExecutableAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__ */


#ifndef __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__
#define __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__

/* interface IDiaReadExeAtRVACallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaReadExeAtRVACallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E3F80CA-7517-432a-BA07-285134AAEA8E")
    IDiaReadExeAtRVACallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadExecutableAtRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaReadExeAtRVACallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaReadExeAtRVACallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaReadExeAtRVACallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaReadExeAtRVACallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadExecutableAtRVA )( 
            IDiaReadExeAtRVACallback * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaReadExeAtRVACallbackVtbl;

    interface IDiaReadExeAtRVACallback
    {
        CONST_VTBL struct IDiaReadExeAtRVACallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaReadExeAtRVACallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaReadExeAtRVACallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaReadExeAtRVACallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaReadExeAtRVACallback_ReadExecutableAtRVA(This,relativeVirtualAddress,cbData,pcbData,data)	\
    (This)->lpVtbl -> ReadExecutableAtRVA(This,relativeVirtualAddress,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaReadExeAtRVACallback_ReadExecutableAtRVA_Proxy( 
    IDiaReadExeAtRVACallback * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaReadExeAtRVACallback_ReadExecutableAtRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__ */


#ifndef __IDiaDataSource_INTERFACE_DEFINED__
#define __IDiaDataSource_INTERFACE_DEFINED__

/* interface IDiaDataSource */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaDataSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79F1BB5F-B66E-48e5-B6A9-1545C323CA3D")
    IDiaDataSource : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lastError( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromPdb( 
            /* [in] */ LPCOLESTR pdbPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadAndValidateDataFromPdb( 
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataForExe( 
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromIStream( 
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE openSession( 
            /* [out] */ IDiaSession **ppSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaDataSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaDataSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaDataSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaDataSource * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastError )( 
            IDiaDataSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromPdb )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR pdbPath);
        
        HRESULT ( STDMETHODCALLTYPE *loadAndValidateDataFromPdb )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataForExe )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromIStream )( 
            IDiaDataSource * This,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *openSession )( 
            IDiaDataSource * This,
            /* [out] */ IDiaSession **ppSession);
        
        END_INTERFACE
    } IDiaDataSourceVtbl;

    interface IDiaDataSource
    {
        CONST_VTBL struct IDiaDataSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaDataSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaDataSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaDataSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaDataSource_get_lastError(This,pRetVal)	\
    (This)->lpVtbl -> get_lastError(This,pRetVal)

#define IDiaDataSource_loadDataFromPdb(This,pdbPath)	\
    (This)->lpVtbl -> loadDataFromPdb(This,pdbPath)

#define IDiaDataSource_loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)	\
    (This)->lpVtbl -> loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)

#define IDiaDataSource_loadDataForExe(This,executable,searchPath,pCallback)	\
    (This)->lpVtbl -> loadDataForExe(This,executable,searchPath,pCallback)

#define IDiaDataSource_loadDataFromIStream(This,pIStream)	\
    (This)->lpVtbl -> loadDataFromIStream(This,pIStream)

#define IDiaDataSource_openSession(This,ppSession)	\
    (This)->lpVtbl -> openSession(This,ppSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaDataSource_get_lastError_Proxy( 
    IDiaDataSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaDataSource_get_lastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataFromPdb_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR pdbPath);


void __RPC_STUB IDiaDataSource_loadDataFromPdb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadAndValidateDataFromPdb_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR pdbPath,
    /* [in] */ GUID *pcsig70,
    /* [in] */ DWORD sig,
    /* [in] */ DWORD age);


void __RPC_STUB IDiaDataSource_loadAndValidateDataFromPdb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataForExe_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR executable,
    /* [in] */ LPCOLESTR searchPath,
    /* [in] */ IUnknown *pCallback);


void __RPC_STUB IDiaDataSource_loadDataForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataFromIStream_Proxy( 
    IDiaDataSource * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB IDiaDataSource_loadDataFromIStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_openSession_Proxy( 
    IDiaDataSource * This,
    /* [out] */ IDiaSession **ppSession);


void __RPC_STUB IDiaDataSource_openSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaDataSource_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSymbols_INTERFACE_DEFINED__
#define __IDiaEnumSymbols_INTERFACE_DEFINED__

/* interface IDiaEnumSymbols */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSymbols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAB72C48-443B-48f5-9B0B-42F0820AB29A")
    IDiaEnumSymbols : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSymbol **symbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSymbols **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSymbolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSymbols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSymbols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSymbols * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSymbols * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSymbols * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSymbols * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSymbol **symbol);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSymbols * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSymbols * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSymbols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSymbols * This,
            /* [out] */ IDiaEnumSymbols **ppenum);
        
        END_INTERFACE
    } IDiaEnumSymbolsVtbl;

    interface IDiaEnumSymbols
    {
        CONST_VTBL struct IDiaEnumSymbolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSymbols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSymbols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSymbols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSymbols_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSymbols_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSymbols_Item(This,index,symbol)	\
    (This)->lpVtbl -> Item(This,index,symbol)

#define IDiaEnumSymbols_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbols_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSymbols_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSymbols_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_get__NewEnum_Proxy( 
    IDiaEnumSymbols * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSymbols_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_get_Count_Proxy( 
    IDiaEnumSymbols * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSymbols_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Item_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSymbol **symbol);


void __RPC_STUB IDiaEnumSymbols_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Next_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbols_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Skip_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSymbols_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Reset_Proxy( 
    IDiaEnumSymbols * This);


void __RPC_STUB IDiaEnumSymbols_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Clone_Proxy( 
    IDiaEnumSymbols * This,
    /* [out] */ IDiaEnumSymbols **ppenum);


void __RPC_STUB IDiaEnumSymbols_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSymbols_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__
#define __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__

/* interface IDiaEnumSymbolsByAddr */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSymbolsByAddr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("624B7D9C-24EA-4421-9D06-3B577471C1FA")
    IDiaEnumSymbolsByAddr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByAddr( 
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByVA( 
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prev( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSymbolsByAddr **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSymbolsByAddrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSymbolsByAddr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSymbolsByAddr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByAddr )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByRVA )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByVA )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Prev )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSymbolsByAddr * This,
            /* [out] */ IDiaEnumSymbolsByAddr **ppenum);
        
        END_INTERFACE
    } IDiaEnumSymbolsByAddrVtbl;

    interface IDiaEnumSymbolsByAddr
    {
        CONST_VTBL struct IDiaEnumSymbolsByAddrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSymbolsByAddr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSymbolsByAddr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSymbolsByAddr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSymbolsByAddr_symbolByAddr(This,isect,offset,ppSymbol)	\
    (This)->lpVtbl -> symbolByAddr(This,isect,offset,ppSymbol)

#define IDiaEnumSymbolsByAddr_symbolByRVA(This,relativeVirtualAddress,ppSymbol)	\
    (This)->lpVtbl -> symbolByRVA(This,relativeVirtualAddress,ppSymbol)

#define IDiaEnumSymbolsByAddr_symbolByVA(This,virtualAddress,ppSymbol)	\
    (This)->lpVtbl -> symbolByVA(This,virtualAddress,ppSymbol)

#define IDiaEnumSymbolsByAddr_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbolsByAddr_Prev(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Prev(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbolsByAddr_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByAddr_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ DWORD isect,
    /* [in] */ DWORD offset,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByRVA_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByVA_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONGLONG virtualAddress,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Next_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbolsByAddr_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Prev_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbolsByAddr_Prev_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Clone_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [out] */ IDiaEnumSymbolsByAddr **ppenum);


void __RPC_STUB IDiaEnumSymbolsByAddr_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSourceFiles_INTERFACE_DEFINED__
#define __IDiaEnumSourceFiles_INTERFACE_DEFINED__

/* interface IDiaEnumSourceFiles */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSourceFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10F3DBD9-664F-4469-B808-9471C7A50538")
    IDiaEnumSourceFiles : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSourceFile **sourceFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSourceFile **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSourceFiles **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSourceFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSourceFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSourceFiles * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSourceFiles * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSourceFiles * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSourceFile **sourceFile);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSourceFile **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSourceFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSourceFiles * This,
            /* [out] */ IDiaEnumSourceFiles **ppenum);
        
        END_INTERFACE
    } IDiaEnumSourceFilesVtbl;

    interface IDiaEnumSourceFiles
    {
        CONST_VTBL struct IDiaEnumSourceFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSourceFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSourceFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSourceFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSourceFiles_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSourceFiles_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSourceFiles_Item(This,index,sourceFile)	\
    (This)->lpVtbl -> Item(This,index,sourceFile)

#define IDiaEnumSourceFiles_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSourceFiles_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSourceFiles_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSourceFiles_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_get__NewEnum_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSourceFiles_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_get_Count_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSourceFiles_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Item_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSourceFile **sourceFile);


void __RPC_STUB IDiaEnumSourceFiles_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Next_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSourceFile **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSourceFiles_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Skip_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSourceFiles_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Reset_Proxy( 
    IDiaEnumSourceFiles * This);


void __RPC_STUB IDiaEnumSourceFiles_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Clone_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [out] */ IDiaEnumSourceFiles **ppenum);


void __RPC_STUB IDiaEnumSourceFiles_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSourceFiles_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumLineNumbers_INTERFACE_DEFINED__
#define __IDiaEnumLineNumbers_INTERFACE_DEFINED__

/* interface IDiaEnumLineNumbers */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumLineNumbers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE30E878-54AC-44f1-81BA-39DE940F6052")
    IDiaEnumLineNumbers : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaLineNumber **lineNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaLineNumber **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumLineNumbers **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumLineNumbersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumLineNumbers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumLineNumbers * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumLineNumbers * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumLineNumbers * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaLineNumber **lineNumber);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaLineNumber **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumLineNumbers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumLineNumbers * This,
            /* [out] */ IDiaEnumLineNumbers **ppenum);
        
        END_INTERFACE
    } IDiaEnumLineNumbersVtbl;

    interface IDiaEnumLineNumbers
    {
        CONST_VTBL struct IDiaEnumLineNumbersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumLineNumbers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumLineNumbers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumLineNumbers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumLineNumbers_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumLineNumbers_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumLineNumbers_Item(This,index,lineNumber)	\
    (This)->lpVtbl -> Item(This,index,lineNumber)

#define IDiaEnumLineNumbers_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumLineNumbers_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumLineNumbers_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumLineNumbers_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_get__NewEnum_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumLineNumbers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_get_Count_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumLineNumbers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Item_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaLineNumber **lineNumber);


void __RPC_STUB IDiaEnumLineNumbers_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Next_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaLineNumber **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumLineNumbers_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Skip_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumLineNumbers_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Reset_Proxy( 
    IDiaEnumLineNumbers * This);


void __RPC_STUB IDiaEnumLineNumbers_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Clone_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [out] */ IDiaEnumLineNumbers **ppenum);


void __RPC_STUB IDiaEnumLineNumbers_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumLineNumbers_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumInjectedSources_INTERFACE_DEFINED__
#define __IDiaEnumInjectedSources_INTERFACE_DEFINED__

/* interface IDiaEnumInjectedSources */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumInjectedSources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5612573-6925-4468-8883-98CDEC8C384A")
    IDiaEnumInjectedSources : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaInjectedSource **injectedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaInjectedSource **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumInjectedSources **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumInjectedSourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumInjectedSources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumInjectedSources * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumInjectedSources * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumInjectedSources * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaInjectedSource **injectedSource);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaInjectedSource **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumInjectedSources * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumInjectedSources * This,
            /* [out] */ IDiaEnumInjectedSources **ppenum);
        
        END_INTERFACE
    } IDiaEnumInjectedSourcesVtbl;

    interface IDiaEnumInjectedSources
    {
        CONST_VTBL struct IDiaEnumInjectedSourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumInjectedSources_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumInjectedSources_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumInjectedSources_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumInjectedSources_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumInjectedSources_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumInjectedSources_Item(This,index,injectedSource)	\
    (This)->lpVtbl -> Item(This,index,injectedSource)

#define IDiaEnumInjectedSources_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumInjectedSources_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumInjectedSources_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumInjectedSources_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_get__NewEnum_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumInjectedSources_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_get_Count_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumInjectedSources_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Item_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaInjectedSource **injectedSource);


void __RPC_STUB IDiaEnumInjectedSources_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Next_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaInjectedSource **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumInjectedSources_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Skip_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumInjectedSources_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Reset_Proxy( 
    IDiaEnumInjectedSources * This);


void __RPC_STUB IDiaEnumInjectedSources_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Clone_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [out] */ IDiaEnumInjectedSources **ppenum);


void __RPC_STUB IDiaEnumInjectedSources_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumInjectedSources_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSegments_INTERFACE_DEFINED__
#define __IDiaEnumSegments_INTERFACE_DEFINED__

/* interface IDiaEnumSegments */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSegments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8368CA9-01D1-419d-AC0C-E31235DBDA9F")
    IDiaEnumSegments : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSegment **segment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSegment **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSegments **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSegmentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSegments * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSegments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSegments * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSegments * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSegments * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSegments * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSegment **segment);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSegments * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSegment **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSegments * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSegments * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSegments * This,
            /* [out] */ IDiaEnumSegments **ppenum);
        
        END_INTERFACE
    } IDiaEnumSegmentsVtbl;

    interface IDiaEnumSegments
    {
        CONST_VTBL struct IDiaEnumSegmentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSegments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSegments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSegments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSegments_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSegments_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSegments_Item(This,index,segment)	\
    (This)->lpVtbl -> Item(This,index,segment)

#define IDiaEnumSegments_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSegments_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSegments_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSegments_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_get__NewEnum_Proxy( 
    IDiaEnumSegments * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSegments_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_get_Count_Proxy( 
    IDiaEnumSegments * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSegments_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Item_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSegment **segment);


void __RPC_STUB IDiaEnumSegments_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Next_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSegment **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSegments_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Skip_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSegments_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Reset_Proxy( 
    IDiaEnumSegments * This);


void __RPC_STUB IDiaEnumSegments_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Clone_Proxy( 
    IDiaEnumSegments * This,
    /* [out] */ IDiaEnumSegments **ppenum);


void __RPC_STUB IDiaEnumSegments_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSegments_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSectionContribs_INTERFACE_DEFINED__
#define __IDiaEnumSectionContribs_INTERFACE_DEFINED__

/* interface IDiaEnumSectionContribs */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSectionContribs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1994DEB2-2C82-4b1d-A57F-AFF424D54A68")
    IDiaEnumSectionContribs : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSectionContrib **section) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSectionContrib **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSectionContribs **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSectionContribsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSectionContribs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSectionContribs * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSectionContribs * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSectionContribs * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSectionContrib **section);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSectionContrib **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSectionContribs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSectionContribs * This,
            /* [out] */ IDiaEnumSectionContribs **ppenum);
        
        END_INTERFACE
    } IDiaEnumSectionContribsVtbl;

    interface IDiaEnumSectionContribs
    {
        CONST_VTBL struct IDiaEnumSectionContribsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSectionContribs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSectionContribs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSectionContribs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSectionContribs_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSectionContribs_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSectionContribs_Item(This,index,section)	\
    (This)->lpVtbl -> Item(This,index,section)

#define IDiaEnumSectionContribs_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSectionContribs_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSectionContribs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSectionContribs_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_get__NewEnum_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSectionContribs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_get_Count_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSectionContribs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Item_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSectionContrib **section);


void __RPC_STUB IDiaEnumSectionContribs_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Next_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSectionContrib **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSectionContribs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Skip_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSectionContribs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Reset_Proxy( 
    IDiaEnumSectionContribs * This);


void __RPC_STUB IDiaEnumSectionContribs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Clone_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [out] */ IDiaEnumSectionContribs **ppenum);


void __RPC_STUB IDiaEnumSectionContribs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSectionContribs_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumFrameData_INTERFACE_DEFINED__
#define __IDiaEnumFrameData_INTERFACE_DEFINED__

/* interface IDiaEnumFrameData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumFrameData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FC77A4B-3C1C-44ed-A798-6C1DEEA53E1F")
    IDiaEnumFrameData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaFrameData **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumFrameData **ppenum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE frameByRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE frameByVA( 
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumFrameDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumFrameData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumFrameData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumFrameData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumFrameData * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumFrameData * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumFrameData * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaFrameData **frame);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaFrameData **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumFrameData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumFrameData * This,
            /* [out] */ IDiaEnumFrameData **ppenum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *frameByRVA )( 
            IDiaEnumFrameData * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaFrameData **frame);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *frameByVA )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaFrameData **frame);
        
        END_INTERFACE
    } IDiaEnumFrameDataVtbl;

    interface IDiaEnumFrameData
    {
        CONST_VTBL struct IDiaEnumFrameDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumFrameData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumFrameData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumFrameData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumFrameData_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumFrameData_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumFrameData_Item(This,index,frame)	\
    (This)->lpVtbl -> Item(This,index,frame)

#define IDiaEnumFrameData_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumFrameData_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumFrameData_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumFrameData_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IDiaEnumFrameData_frameByRVA(This,relativeVirtualAddress,frame)	\
    (This)->lpVtbl -> frameByRVA(This,relativeVirtualAddress,frame)

#define IDiaEnumFrameData_frameByVA(This,virtualAddress,frame)	\
    (This)->lpVtbl -> frameByVA(This,virtualAddress,frame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_get__NewEnum_Proxy( 
    IDiaEnumFrameData * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumFrameData_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_get_Count_Proxy( 
    IDiaEnumFrameData * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumFrameData_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Item_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Next_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaFrameData **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumFrameData_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Skip_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumFrameData_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Reset_Proxy( 
    IDiaEnumFrameData * This);


void __RPC_STUB IDiaEnumFrameData_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Clone_Proxy( 
    IDiaEnumFrameData * This,
    /* [out] */ IDiaEnumFrameData **ppenum);


void __RPC_STUB IDiaEnumFrameData_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_frameByRVA_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_frameByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_frameByVA_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONGLONG virtualAddress,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_frameByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumFrameData_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumDebugStreamData_INTERFACE_DEFINED__
#define __IDiaEnumDebugStreamData_INTERFACE_DEFINED__

/* interface IDiaEnumDebugStreamData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumDebugStreamData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("486943E8-D187-4a6b-A3C4-291259FFF60D")
    IDiaEnumDebugStreamData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumDebugStreamData **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumDebugStreamDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumDebugStreamData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumDebugStreamData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ DWORD index,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ ULONG celt,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ],
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumDebugStreamData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumDebugStreamData * This,
            /* [out] */ IDiaEnumDebugStreamData **ppenum);
        
        END_INTERFACE
    } IDiaEnumDebugStreamDataVtbl;

    interface IDiaEnumDebugStreamData
    {
        CONST_VTBL struct IDiaEnumDebugStreamDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumDebugStreamData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumDebugStreamData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumDebugStreamData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumDebugStreamData_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumDebugStreamData_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumDebugStreamData_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaEnumDebugStreamData_Item(This,index,cbData,pcbData,data)	\
    (This)->lpVtbl -> Item(This,index,cbData,pcbData,data)

#define IDiaEnumDebugStreamData_Next(This,celt,cbData,pcbData,data,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,cbData,pcbData,data,pceltFetched)

#define IDiaEnumDebugStreamData_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumDebugStreamData_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumDebugStreamData_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get__NewEnum_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get_Count_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get_name_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Item_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ DWORD index,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaEnumDebugStreamData_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Next_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ ULONG celt,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumDebugStreamData_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Skip_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumDebugStreamData_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Reset_Proxy( 
    IDiaEnumDebugStreamData * This);


void __RPC_STUB IDiaEnumDebugStreamData_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Clone_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [out] */ IDiaEnumDebugStreamData **ppenum);


void __RPC_STUB IDiaEnumDebugStreamData_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumDebugStreamData_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumDebugStreams_INTERFACE_DEFINED__
#define __IDiaEnumDebugStreams_INTERFACE_DEFINED__

/* interface IDiaEnumDebugStreams */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumDebugStreams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08CBB41E-47A6-4f87-92F1-1C9C87CED044")
    IDiaEnumDebugStreams : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaEnumDebugStreamData **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaEnumDebugStreamData **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumDebugStreams **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumDebugStreamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumDebugStreams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumDebugStreams * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumDebugStreams * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumDebugStreams * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaEnumDebugStreamData **stream);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaEnumDebugStreamData **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumDebugStreams * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumDebugStreams * This,
            /* [out] */ IDiaEnumDebugStreams **ppenum);
        
        END_INTERFACE
    } IDiaEnumDebugStreamsVtbl;

    interface IDiaEnumDebugStreams
    {
        CONST_VTBL struct IDiaEnumDebugStreamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumDebugStreams_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumDebugStreams_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumDebugStreams_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumDebugStreams_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumDebugStreams_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumDebugStreams_Item(This,index,stream)	\
    (This)->lpVtbl -> Item(This,index,stream)

#define IDiaEnumDebugStreams_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumDebugStreams_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumDebugStreams_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumDebugStreams_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_get__NewEnum_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumDebugStreams_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_get_Count_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumDebugStreams_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Item_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDiaEnumDebugStreamData **stream);


void __RPC_STUB IDiaEnumDebugStreams_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Next_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaEnumDebugStreamData **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumDebugStreams_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Skip_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumDebugStreams_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Reset_Proxy( 
    IDiaEnumDebugStreams * This);


void __RPC_STUB IDiaEnumDebugStreams_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Clone_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [out] */ IDiaEnumDebugStreams **ppenum);


void __RPC_STUB IDiaEnumDebugStreams_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumDebugStreams_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_0123 */
/* [local] */ 

struct DiaAddressMapEntry
    {
    DWORD rva;
    DWORD rvaTo;
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dia2_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0123_v0_0_s_ifspec;

#ifndef __IDiaAddressMap_INTERFACE_DEFINED__
#define __IDiaAddressMap_INTERFACE_DEFINED__

/* interface IDiaAddressMap */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaAddressMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B62A2E7A-067A-4ea3-B598-04C09717502C")
    IDiaAddressMap : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressMapEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_addressMapEnabled( 
            /* [in] */ BOOL NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddressEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_relativeVirtualAddressEnabled( 
            /* [in] */ BOOL NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_imageAlign( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_imageAlign( 
            /* [in] */ DWORD NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_imageHeaders( 
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ],
            /* [in] */ BOOL originalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_addressMap( 
            /* [in] */ DWORD cData,
            /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
            /* [in] */ BOOL imageToSymbols) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaAddressMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaAddressMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaAddressMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaAddressMap * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressMapEnabled )( 
            IDiaAddressMap * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_addressMapEnabled )( 
            IDiaAddressMap * This,
            /* [in] */ BOOL NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddressEnabled )( 
            IDiaAddressMap * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_relativeVirtualAddressEnabled )( 
            IDiaAddressMap * This,
            /* [in] */ BOOL NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageAlign )( 
            IDiaAddressMap * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_imageAlign )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *set_imageHeaders )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ],
            /* [in] */ BOOL originalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *set_addressMap )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD cData,
            /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
            /* [in] */ BOOL imageToSymbols);
        
        END_INTERFACE
    } IDiaAddressMapVtbl;

    interface IDiaAddressMap
    {
        CONST_VTBL struct IDiaAddressMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaAddressMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaAddressMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaAddressMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaAddressMap_get_addressMapEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_addressMapEnabled(This,pRetVal)

#define IDiaAddressMap_put_addressMapEnabled(This,NewVal)	\
    (This)->lpVtbl -> put_addressMapEnabled(This,NewVal)

#define IDiaAddressMap_get_relativeVirtualAddressEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddressEnabled(This,pRetVal)

#define IDiaAddressMap_put_relativeVirtualAddressEnabled(This,NewVal)	\
    (This)->lpVtbl -> put_relativeVirtualAddressEnabled(This,NewVal)

#define IDiaAddressMap_get_imageAlign(This,pRetVal)	\
    (This)->lpVtbl -> get_imageAlign(This,pRetVal)

#define IDiaAddressMap_put_imageAlign(This,NewVal)	\
    (This)->lpVtbl -> put_imageAlign(This,NewVal)

#define IDiaAddressMap_set_imageHeaders(This,cbData,data,originalHeaders)	\
    (This)->lpVtbl -> set_imageHeaders(This,cbData,data,originalHeaders)

#define IDiaAddressMap_set_addressMap(This,cData,data,imageToSymbols)	\
    (This)->lpVtbl -> set_addressMap(This,cData,data,imageToSymbols)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_addressMapEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaAddressMap_get_addressMapEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_addressMapEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ BOOL NewVal);


void __RPC_STUB IDiaAddressMap_put_addressMapEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_relativeVirtualAddressEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaAddressMap_get_relativeVirtualAddressEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_relativeVirtualAddressEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ BOOL NewVal);


void __RPC_STUB IDiaAddressMap_put_relativeVirtualAddressEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_imageAlign_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaAddressMap_get_imageAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_imageAlign_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD NewVal);


void __RPC_STUB IDiaAddressMap_put_imageAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaAddressMap_set_imageHeaders_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE data[  ],
    /* [in] */ BOOL originalHeaders);


void __RPC_STUB IDiaAddressMap_set_imageHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaAddressMap_set_addressMap_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD cData,
    /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
    /* [in] */ BOOL imageToSymbols);


void __RPC_STUB IDiaAddressMap_set_addressMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaAddressMap_INTERFACE_DEFINED__ */


#ifndef __IDiaSession_INTERFACE_DEFINED__
#define __IDiaSession_INTERFACE_DEFINED__

/* interface IDiaSession */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67138B34-79CD-4b42-B74A-A18ADBB799DF")
    IDiaSession : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_loadAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_loadAddress( 
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_globalScope( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumTables( 
            /* [out] */ IDiaEnumTables **ppEnumTables) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSymbolsByAddr( 
            /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findChildren( 
            /* [in] */ IDiaSymbol *parent,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByAddr( 
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByRVA( 
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByToken( 
            /* [in] */ ULONG token,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symsAreEquiv( 
            /* [in] */ IDiaSymbol *symbolA,
            /* [in] */ IDiaSymbol *symbolB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symbolById( 
            /* [in] */ DWORD id,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByRVAEx( 
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByVAEx( 
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findFile( 
            /* [in] */ IDiaSymbol *pCompiland,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSourceFiles **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findFileById( 
            /* [in] */ DWORD uniqueId,
            /* [out] */ IDiaSourceFile **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLines( 
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByAddr( 
            /* [in] */ DWORD seg,
            /* [in] */ DWORD offset,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByRVA( 
            /* [in] */ DWORD rva,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByLinenum( 
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [in] */ DWORD linenum,
            /* [in] */ DWORD column,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findInjectedSource( 
            /* [in] */ LPCOLESTR srcFile,
            /* [out] */ IDiaEnumInjectedSources **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumDebugStreams( 
            /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSession * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_loadAddress )( 
            IDiaSession * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_loadAddress )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_globalScope )( 
            IDiaSession * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumTables )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumTables **ppEnumTables);
        
        HRESULT ( STDMETHODCALLTYPE *getSymbolsByAddr )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr);
        
        HRESULT ( STDMETHODCALLTYPE *findChildren )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *parent,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByAddr )( 
            IDiaSession * This,
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByRVA )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByVA )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByToken )( 
            IDiaSession * This,
            /* [in] */ ULONG token,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *symsAreEquiv )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *symbolA,
            /* [in] */ IDiaSymbol *symbolB);
        
        HRESULT ( STDMETHODCALLTYPE *symbolById )( 
            IDiaSession * This,
            /* [in] */ DWORD id,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByRVAEx )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByVAEx )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *findFile )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *pCompiland,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSourceFiles **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findFileById )( 
            IDiaSession * This,
            /* [in] */ DWORD uniqueId,
            /* [out] */ IDiaSourceFile **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLines )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByAddr )( 
            IDiaSession * This,
            /* [in] */ DWORD seg,
            /* [in] */ DWORD offset,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByRVA )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByVA )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByLinenum )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [in] */ DWORD linenum,
            /* [in] */ DWORD column,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findInjectedSource )( 
            IDiaSession * This,
            /* [in] */ LPCOLESTR srcFile,
            /* [out] */ IDiaEnumInjectedSources **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumDebugStreams )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams);
        
        END_INTERFACE
    } IDiaSessionVtbl;

    interface IDiaSession
    {
        CONST_VTBL struct IDiaSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSession_get_loadAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_loadAddress(This,pRetVal)

#define IDiaSession_put_loadAddress(This,NewVal)	\
    (This)->lpVtbl -> put_loadAddress(This,NewVal)

#define IDiaSession_get_globalScope(This,pRetVal)	\
    (This)->lpVtbl -> get_globalScope(This,pRetVal)

#define IDiaSession_getEnumTables(This,ppEnumTables)	\
    (This)->lpVtbl -> getEnumTables(This,ppEnumTables)

#define IDiaSession_getSymbolsByAddr(This,ppEnumbyAddr)	\
    (This)->lpVtbl -> getSymbolsByAddr(This,ppEnumbyAddr)

#define IDiaSession_findChildren(This,parent,symtag,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findChildren(This,parent,symtag,name,compareFlags,ppResult)

#define IDiaSession_findSymbolByAddr(This,isect,offset,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByAddr(This,isect,offset,symtag,ppSymbol)

#define IDiaSession_findSymbolByRVA(This,rva,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByRVA(This,rva,symtag,ppSymbol)

#define IDiaSession_findSymbolByVA(This,va,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByVA(This,va,symtag,ppSymbol)

#define IDiaSession_findSymbolByToken(This,token,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByToken(This,token,symtag,ppSymbol)

#define IDiaSession_symsAreEquiv(This,symbolA,symbolB)	\
    (This)->lpVtbl -> symsAreEquiv(This,symbolA,symbolB)

#define IDiaSession_symbolById(This,id,ppSymbol)	\
    (This)->lpVtbl -> symbolById(This,id,ppSymbol)

#define IDiaSession_findSymbolByRVAEx(This,rva,symtag,ppSymbol,displacement)	\
    (This)->lpVtbl -> findSymbolByRVAEx(This,rva,symtag,ppSymbol,displacement)

#define IDiaSession_findSymbolByVAEx(This,va,symtag,ppSymbol,displacement)	\
    (This)->lpVtbl -> findSymbolByVAEx(This,va,symtag,ppSymbol,displacement)

#define IDiaSession_findFile(This,pCompiland,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findFile(This,pCompiland,name,compareFlags,ppResult)

#define IDiaSession_findFileById(This,uniqueId,ppResult)	\
    (This)->lpVtbl -> findFileById(This,uniqueId,ppResult)

#define IDiaSession_findLines(This,compiland,file,ppResult)	\
    (This)->lpVtbl -> findLines(This,compiland,file,ppResult)

#define IDiaSession_findLinesByAddr(This,seg,offset,length,ppResult)	\
    (This)->lpVtbl -> findLinesByAddr(This,seg,offset,length,ppResult)

#define IDiaSession_findLinesByRVA(This,rva,length,ppResult)	\
    (This)->lpVtbl -> findLinesByRVA(This,rva,length,ppResult)

#define IDiaSession_findLinesByVA(This,va,length,ppResult)	\
    (This)->lpVtbl -> findLinesByVA(This,va,length,ppResult)

#define IDiaSession_findLinesByLinenum(This,compiland,file,linenum,column,ppResult)	\
    (This)->lpVtbl -> findLinesByLinenum(This,compiland,file,linenum,column,ppResult)

#define IDiaSession_findInjectedSource(This,srcFile,ppResult)	\
    (This)->lpVtbl -> findInjectedSource(This,srcFile,ppResult)

#define IDiaSession_getEnumDebugStreams(This,ppEnumDebugStreams)	\
    (This)->lpVtbl -> getEnumDebugStreams(This,ppEnumDebugStreams)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSession_get_loadAddress_Proxy( 
    IDiaSession * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSession_get_loadAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaSession_put_loadAddress_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaSession_put_loadAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSession_get_globalScope_Proxy( 
    IDiaSession * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSession_get_globalScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getEnumTables_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumTables **ppEnumTables);


void __RPC_STUB IDiaSession_getEnumTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getSymbolsByAddr_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr);


void __RPC_STUB IDiaSession_getSymbolsByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findChildren_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *parent,
    /* [in] */ enum SymTagEnum symtag,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSymbols **ppResult);


void __RPC_STUB IDiaSession_findChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByAddr_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD isect,
    /* [in] */ DWORD offset,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByRVA_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByVA_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByToken_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONG token,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_symsAreEquiv_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *symbolA,
    /* [in] */ IDiaSymbol *symbolB);


void __RPC_STUB IDiaSession_symsAreEquiv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_symbolById_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD id,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_symbolById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByRVAEx_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol,
    /* [out] */ long *displacement);


void __RPC_STUB IDiaSession_findSymbolByRVAEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByVAEx_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol,
    /* [out] */ long *displacement);


void __RPC_STUB IDiaSession_findSymbolByVAEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findFile_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *pCompiland,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSourceFiles **ppResult);


void __RPC_STUB IDiaSession_findFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findFileById_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD uniqueId,
    /* [out] */ IDiaSourceFile **ppResult);


void __RPC_STUB IDiaSession_findFileById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLines_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *compiland,
    /* [in] */ IDiaSourceFile *file,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByAddr_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD seg,
    /* [in] */ DWORD offset,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByRVA_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByVA_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByLinenum_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *compiland,
    /* [in] */ IDiaSourceFile *file,
    /* [in] */ DWORD linenum,
    /* [in] */ DWORD column,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByLinenum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findInjectedSource_Proxy( 
    IDiaSession * This,
    /* [in] */ LPCOLESTR srcFile,
    /* [out] */ IDiaEnumInjectedSources **ppResult);


void __RPC_STUB IDiaSession_findInjectedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getEnumDebugStreams_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams);


void __RPC_STUB IDiaSession_getEnumDebugStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSession_INTERFACE_DEFINED__ */


#ifndef __IDiaSymbol_INTERFACE_DEFINED__
#define __IDiaSymbol_INTERFACE_DEFINED__

/* interface IDiaSymbol */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSymbol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72827A48-D320-4eaf-8436-548ADE47D5E5")
    IDiaSymbol : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symIndexId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symTag( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lexicalParent( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_classParent( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_dataKind( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_locationType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offset( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_slot( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_volatileType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_constType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_unalignedType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_access( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_libraryName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_platform( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_editAndContinueEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndMajor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndMinor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndBuild( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndMajor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndMinor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndBuild( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_objectFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_thunkOrdinal( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_thisAdjust( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtual( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_intro( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_pure( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_callingConvention( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [retval][out] */ VARIANT *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_baseType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_token( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_timeStamp( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_guid( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symbolsFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_reference( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_bitPosition( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_arrayIndexType( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_packed( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_constructor( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_overloadedOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_nested( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasNestedTypes( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasAssignmentOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasCastOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_scoped( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseClass( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_indirectVirtualBaseClass( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBasePointerOffset( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualTableShape( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lexicalParentId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_classParentId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_typeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_arrayIndexTypeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualTableShapeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_function( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_managed( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_msil( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseDispIndex( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_undecoratedName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_age( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_signature( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilerGenerated( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressTaken( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_rank( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lowerBound( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_upperBound( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lowerBoundId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_upperBoundId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_dataBytes( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findChildren( 
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetRelativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetVirtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_machineType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_oemId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_oemSymbolId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_types( 
            /* [in] */ DWORD cTypes,
            /* [out] */ DWORD *pcTypes,
            /* [length_is][size_is][out] */ IDiaSymbol *types[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_typeIds( 
            /* [in] */ DWORD cTypeIds,
            /* [out] */ DWORD *pcTypeIds,
            /* [length_is][size_is][out] */ DWORD typeIds[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSymbolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSymbol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSymbol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSymbol * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symIndexId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symTag )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lexicalParent )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_classParent )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataKind )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_locationType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offset )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_slot )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_volatileType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_constType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unalignedType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_access )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_libraryName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_platform )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_language )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_editAndContinueEnabled )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndMajor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndMinor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndBuild )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndMajor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndMinor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndBuild )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_objectFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_thunkOrdinal )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_thisAdjust )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtual )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_intro )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_pure )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_callingConvention )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_value )( 
            IDiaSymbol * This,
            /* [retval][out] */ VARIANT *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_token )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_timeStamp )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_guid )( 
            IDiaSymbol * This,
            /* [retval][out] */ GUID *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symbolsFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_reference )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_count )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_bitPosition )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_arrayIndexType )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_packed )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_constructor )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_overloadedOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nested )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasNestedTypes )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasAssignmentOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasCastOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_scoped )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseClass )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_indirectVirtualBaseClass )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBasePointerOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualTableShape )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lexicalParentId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_classParentId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_typeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_arrayIndexTypeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualTableShapeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_function )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_managed )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_msil )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseDispIndex )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_undecoratedName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_age )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_signature )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilerGenerated )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressTaken )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_rank )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lowerBound )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_upperBound )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lowerBoundId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_upperBoundId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_dataBytes )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *findChildren )( 
            IDiaSymbol * This,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetSection )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetRelativeVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_machineType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_oemId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_oemSymbolId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_types )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cTypes,
            /* [out] */ DWORD *pcTypes,
            /* [length_is][size_is][out] */ IDiaSymbol *types[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *get_typeIds )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cTypeIds,
            /* [out] */ DWORD *pcTypeIds,
            /* [length_is][size_is][out] */ DWORD typeIds[  ]);
        
        END_INTERFACE
    } IDiaSymbolVtbl;

    interface IDiaSymbol
    {
        CONST_VTBL struct IDiaSymbolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSymbol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSymbol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSymbol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSymbol_get_symIndexId(This,pRetVal)	\
    (This)->lpVtbl -> get_symIndexId(This,pRetVal)

#define IDiaSymbol_get_symTag(This,pRetVal)	\
    (This)->lpVtbl -> get_symTag(This,pRetVal)

#define IDiaSymbol_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaSymbol_get_lexicalParent(This,pRetVal)	\
    (This)->lpVtbl -> get_lexicalParent(This,pRetVal)

#define IDiaSymbol_get_classParent(This,pRetVal)	\
    (This)->lpVtbl -> get_classParent(This,pRetVal)

#define IDiaSymbol_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaSymbol_get_dataKind(This,pRetVal)	\
    (This)->lpVtbl -> get_dataKind(This,pRetVal)

#define IDiaSymbol_get_locationType(This,pRetVal)	\
    (This)->lpVtbl -> get_locationType(This,pRetVal)

#define IDiaSymbol_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSymbol_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaSymbol_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaSymbol_get_registerId(This,pRetVal)	\
    (This)->lpVtbl -> get_registerId(This,pRetVal)

#define IDiaSymbol_get_offset(This,pRetVal)	\
    (This)->lpVtbl -> get_offset(This,pRetVal)

#define IDiaSymbol_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSymbol_get_slot(This,pRetVal)	\
    (This)->lpVtbl -> get_slot(This,pRetVal)

#define IDiaSymbol_get_volatileType(This,pRetVal)	\
    (This)->lpVtbl -> get_volatileType(This,pRetVal)

#define IDiaSymbol_get_constType(This,pRetVal)	\
    (This)->lpVtbl -> get_constType(This,pRetVal)

#define IDiaSymbol_get_unalignedType(This,pRetVal)	\
    (This)->lpVtbl -> get_unalignedType(This,pRetVal)

#define IDiaSymbol_get_access(This,pRetVal)	\
    (This)->lpVtbl -> get_access(This,pRetVal)

#define IDiaSymbol_get_libraryName(This,pRetVal)	\
    (This)->lpVtbl -> get_libraryName(This,pRetVal)

#define IDiaSymbol_get_platform(This,pRetVal)	\
    (This)->lpVtbl -> get_platform(This,pRetVal)

#define IDiaSymbol_get_language(This,pRetVal)	\
    (This)->lpVtbl -> get_language(This,pRetVal)

#define IDiaSymbol_get_editAndContinueEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_editAndContinueEnabled(This,pRetVal)

#define IDiaSymbol_get_frontEndMajor(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndMajor(This,pRetVal)

#define IDiaSymbol_get_frontEndMinor(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndMinor(This,pRetVal)

#define IDiaSymbol_get_frontEndBuild(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndBuild(This,pRetVal)

#define IDiaSymbol_get_backEndMajor(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndMajor(This,pRetVal)

#define IDiaSymbol_get_backEndMinor(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndMinor(This,pRetVal)

#define IDiaSymbol_get_backEndBuild(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndBuild(This,pRetVal)

#define IDiaSymbol_get_sourceFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFileName(This,pRetVal)

#define IDiaSymbol_get_objectFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_objectFileName(This,pRetVal)

#define IDiaSymbol_get_thunkOrdinal(This,pRetVal)	\
    (This)->lpVtbl -> get_thunkOrdinal(This,pRetVal)

#define IDiaSymbol_get_thisAdjust(This,pRetVal)	\
    (This)->lpVtbl -> get_thisAdjust(This,pRetVal)

#define IDiaSymbol_get_virtualBaseOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseOffset(This,pRetVal)

#define IDiaSymbol_get_virtual(This,pRetVal)	\
    (This)->lpVtbl -> get_virtual(This,pRetVal)

#define IDiaSymbol_get_intro(This,pRetVal)	\
    (This)->lpVtbl -> get_intro(This,pRetVal)

#define IDiaSymbol_get_pure(This,pRetVal)	\
    (This)->lpVtbl -> get_pure(This,pRetVal)

#define IDiaSymbol_get_callingConvention(This,pRetVal)	\
    (This)->lpVtbl -> get_callingConvention(This,pRetVal)

#define IDiaSymbol_get_value(This,pRetVal)	\
    (This)->lpVtbl -> get_value(This,pRetVal)

#define IDiaSymbol_get_baseType(This,pRetVal)	\
    (This)->lpVtbl -> get_baseType(This,pRetVal)

#define IDiaSymbol_get_token(This,pRetVal)	\
    (This)->lpVtbl -> get_token(This,pRetVal)

#define IDiaSymbol_get_timeStamp(This,pRetVal)	\
    (This)->lpVtbl -> get_timeStamp(This,pRetVal)

#define IDiaSymbol_get_guid(This,pRetVal)	\
    (This)->lpVtbl -> get_guid(This,pRetVal)

#define IDiaSymbol_get_symbolsFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_symbolsFileName(This,pRetVal)

#define IDiaSymbol_get_reference(This,pRetVal)	\
    (This)->lpVtbl -> get_reference(This,pRetVal)

#define IDiaSymbol_get_count(This,pRetVal)	\
    (This)->lpVtbl -> get_count(This,pRetVal)

#define IDiaSymbol_get_bitPosition(This,pRetVal)	\
    (This)->lpVtbl -> get_bitPosition(This,pRetVal)

#define IDiaSymbol_get_arrayIndexType(This,pRetVal)	\
    (This)->lpVtbl -> get_arrayIndexType(This,pRetVal)

#define IDiaSymbol_get_packed(This,pRetVal)	\
    (This)->lpVtbl -> get_packed(This,pRetVal)

#define IDiaSymbol_get_constructor(This,pRetVal)	\
    (This)->lpVtbl -> get_constructor(This,pRetVal)

#define IDiaSymbol_get_overloadedOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_overloadedOperator(This,pRetVal)

#define IDiaSymbol_get_nested(This,pRetVal)	\
    (This)->lpVtbl -> get_nested(This,pRetVal)

#define IDiaSymbol_get_hasNestedTypes(This,pRetVal)	\
    (This)->lpVtbl -> get_hasNestedTypes(This,pRetVal)

#define IDiaSymbol_get_hasAssignmentOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_hasAssignmentOperator(This,pRetVal)

#define IDiaSymbol_get_hasCastOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_hasCastOperator(This,pRetVal)

#define IDiaSymbol_get_scoped(This,pRetVal)	\
    (This)->lpVtbl -> get_scoped(This,pRetVal)

#define IDiaSymbol_get_virtualBaseClass(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseClass(This,pRetVal)

#define IDiaSymbol_get_indirectVirtualBaseClass(This,pRetVal)	\
    (This)->lpVtbl -> get_indirectVirtualBaseClass(This,pRetVal)

#define IDiaSymbol_get_virtualBasePointerOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBasePointerOffset(This,pRetVal)

#define IDiaSymbol_get_virtualTableShape(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualTableShape(This,pRetVal)

#define IDiaSymbol_get_lexicalParentId(This,pRetVal)	\
    (This)->lpVtbl -> get_lexicalParentId(This,pRetVal)

#define IDiaSymbol_get_classParentId(This,pRetVal)	\
    (This)->lpVtbl -> get_classParentId(This,pRetVal)

#define IDiaSymbol_get_typeId(This,pRetVal)	\
    (This)->lpVtbl -> get_typeId(This,pRetVal)

#define IDiaSymbol_get_arrayIndexTypeId(This,pRetVal)	\
    (This)->lpVtbl -> get_arrayIndexTypeId(This,pRetVal)

#define IDiaSymbol_get_virtualTableShapeId(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualTableShapeId(This,pRetVal)

#define IDiaSymbol_get_code(This,pRetVal)	\
    (This)->lpVtbl -> get_code(This,pRetVal)

#define IDiaSymbol_get_function(This,pRetVal)	\
    (This)->lpVtbl -> get_function(This,pRetVal)

#define IDiaSymbol_get_managed(This,pRetVal)	\
    (This)->lpVtbl -> get_managed(This,pRetVal)

#define IDiaSymbol_get_msil(This,pRetVal)	\
    (This)->lpVtbl -> get_msil(This,pRetVal)

#define IDiaSymbol_get_virtualBaseDispIndex(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseDispIndex(This,pRetVal)

#define IDiaSymbol_get_undecoratedName(This,pRetVal)	\
    (This)->lpVtbl -> get_undecoratedName(This,pRetVal)

#define IDiaSymbol_get_age(This,pRetVal)	\
    (This)->lpVtbl -> get_age(This,pRetVal)

#define IDiaSymbol_get_signature(This,pRetVal)	\
    (This)->lpVtbl -> get_signature(This,pRetVal)

#define IDiaSymbol_get_compilerGenerated(This,pRetVal)	\
    (This)->lpVtbl -> get_compilerGenerated(This,pRetVal)

#define IDiaSymbol_get_addressTaken(This,pRetVal)	\
    (This)->lpVtbl -> get_addressTaken(This,pRetVal)

#define IDiaSymbol_get_rank(This,pRetVal)	\
    (This)->lpVtbl -> get_rank(This,pRetVal)

#define IDiaSymbol_get_lowerBound(This,pRetVal)	\
    (This)->lpVtbl -> get_lowerBound(This,pRetVal)

#define IDiaSymbol_get_upperBound(This,pRetVal)	\
    (This)->lpVtbl -> get_upperBound(This,pRetVal)

#define IDiaSymbol_get_lowerBoundId(This,pRetVal)	\
    (This)->lpVtbl -> get_lowerBoundId(This,pRetVal)

#define IDiaSymbol_get_upperBoundId(This,pRetVal)	\
    (This)->lpVtbl -> get_upperBoundId(This,pRetVal)

#define IDiaSymbol_get_dataBytes(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_dataBytes(This,cbData,pcbData,data)

#define IDiaSymbol_findChildren(This,symtag,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findChildren(This,symtag,name,compareFlags,ppResult)

#define IDiaSymbol_get_targetSection(This,pRetVal)	\
    (This)->lpVtbl -> get_targetSection(This,pRetVal)

#define IDiaSymbol_get_targetOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_targetOffset(This,pRetVal)

#define IDiaSymbol_get_targetRelativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_targetRelativeVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_targetVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_targetVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_machineType(This,pRetVal)	\
    (This)->lpVtbl -> get_machineType(This,pRetVal)

#define IDiaSymbol_get_oemId(This,pRetVal)	\
    (This)->lpVtbl -> get_oemId(This,pRetVal)

#define IDiaSymbol_get_oemSymbolId(This,pRetVal)	\
    (This)->lpVtbl -> get_oemSymbolId(This,pRetVal)

#define IDiaSymbol_get_types(This,cTypes,pcTypes,types)	\
    (This)->lpVtbl -> get_types(This,cTypes,pcTypes,types)

#define IDiaSymbol_get_typeIds(This,cTypeIds,pcTypeIds,typeIds)	\
    (This)->lpVtbl -> get_typeIds(This,cTypeIds,pcTypeIds,typeIds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symIndexId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_symIndexId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symTag_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_symTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_name_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lexicalParent_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_lexicalParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_classParent_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_classParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_type_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_dataKind_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_dataKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_locationType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_locationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressSection_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_relativeVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_registerId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_registerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_offset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_offset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_length_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_slot_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_slot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_volatileType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_volatileType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_constType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_constType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_unalignedType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_unalignedType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_access_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_libraryName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_libraryName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_platform_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_platform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_language_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_editAndContinueEnabled_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_editAndContinueEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndMajor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndMinor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndBuild_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndMajor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndMinor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndBuild_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_sourceFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_sourceFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_objectFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_objectFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_thunkOrdinal_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_thunkOrdinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_thisAdjust_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_thisAdjust_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtual_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_intro_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_intro_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_pure_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_pure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_callingConvention_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_callingConvention_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_value_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ VARIANT *pRetVal);


void __RPC_STUB IDiaSymbol_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_baseType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_baseType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_token_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_token_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_timeStamp_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_timeStamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_guid_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB IDiaSymbol_get_guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symbolsFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_symbolsFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_reference_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_reference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_count_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_bitPosition_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_bitPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_arrayIndexType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_arrayIndexType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_packed_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_packed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_constructor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_constructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_overloadedOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_overloadedOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_nested_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_nested_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasNestedTypes_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasNestedTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasAssignmentOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasAssignmentOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasCastOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasCastOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_scoped_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_scoped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseClass_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_indirectVirtualBaseClass_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_indirectVirtualBaseClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBasePointerOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBasePointerOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualTableShape_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualTableShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lexicalParentId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_lexicalParentId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_classParentId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_classParentId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_typeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_typeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_arrayIndexTypeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_arrayIndexTypeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualTableShapeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualTableShapeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_code_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_function_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_managed_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_managed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_msil_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_msil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseDispIndex_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseDispIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_undecoratedName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_undecoratedName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_age_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_age_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_signature_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_compilerGenerated_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_compilerGenerated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressTaken_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressTaken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_rank_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_rank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lowerBound_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_lowerBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_upperBound_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_upperBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lowerBoundId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_lowerBoundId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_upperBoundId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_upperBoundId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_dataBytes_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaSymbol_get_dataBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_findChildren_Proxy( 
    IDiaSymbol * This,
    /* [in] */ enum SymTagEnum symtag,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSymbols **ppResult);


void __RPC_STUB IDiaSymbol_findChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetSection_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetRelativeVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetRelativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_machineType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_machineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_oemId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_oemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_oemSymbolId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_oemSymbolId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_types_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cTypes,
    /* [out] */ DWORD *pcTypes,
    /* [length_is][size_is][out] */ IDiaSymbol *types[  ]);


void __RPC_STUB IDiaSymbol_get_types_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_typeIds_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cTypeIds,
    /* [out] */ DWORD *pcTypeIds,
    /* [length_is][size_is][out] */ DWORD typeIds[  ]);


void __RPC_STUB IDiaSymbol_get_typeIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSymbol_INTERFACE_DEFINED__ */


#ifndef __IDiaSourceFile_INTERFACE_DEFINED__
#define __IDiaSourceFile_INTERFACE_DEFINED__

/* interface IDiaSourceFile */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSourceFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2EF5353-F5A8-4eb3-90D2-CB526ACB3CDD")
    IDiaSourceFile : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_uniqueId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_fileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_checksumType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilands( 
            /* [retval][out] */ IDiaEnumSymbols **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_checksum( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSourceFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSourceFile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSourceFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSourceFile * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_uniqueId )( 
            IDiaSourceFile * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileName )( 
            IDiaSourceFile * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_checksumType )( 
            IDiaSourceFile * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilands )( 
            IDiaSourceFile * This,
            /* [retval][out] */ IDiaEnumSymbols **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_checksum )( 
            IDiaSourceFile * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaSourceFileVtbl;

    interface IDiaSourceFile
    {
        CONST_VTBL struct IDiaSourceFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSourceFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSourceFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSourceFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSourceFile_get_uniqueId(This,pRetVal)	\
    (This)->lpVtbl -> get_uniqueId(This,pRetVal)

#define IDiaSourceFile_get_fileName(This,pRetVal)	\
    (This)->lpVtbl -> get_fileName(This,pRetVal)

#define IDiaSourceFile_get_checksumType(This,pRetVal)	\
    (This)->lpVtbl -> get_checksumType(This,pRetVal)

#define IDiaSourceFile_get_compilands(This,pRetVal)	\
    (This)->lpVtbl -> get_compilands(This,pRetVal)

#define IDiaSourceFile_get_checksum(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_checksum(This,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_uniqueId_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSourceFile_get_uniqueId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_fileName_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSourceFile_get_fileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_checksumType_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSourceFile_get_checksumType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_compilands_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ IDiaEnumSymbols **pRetVal);


void __RPC_STUB IDiaSourceFile_get_compilands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_checksum_Proxy( 
    IDiaSourceFile * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaSourceFile_get_checksum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSourceFile_INTERFACE_DEFINED__ */


#ifndef __IDiaLineNumber_INTERFACE_DEFINED__
#define __IDiaLineNumber_INTERFACE_DEFINED__

/* interface IDiaLineNumber */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLineNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B388EB14-BE4D-421d-A8A1-6CF7AB057086")
    IDiaLineNumber : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compiland( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFile( 
            /* [retval][out] */ IDiaSourceFile **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumber( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumberEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumber( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumberEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFileId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_statement( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilandId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLineNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLineNumber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLineNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLineNumber * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compiland )( 
            IDiaLineNumber * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFile )( 
            IDiaLineNumber * This,
            /* [retval][out] */ IDiaSourceFile **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumber )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumberEnd )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumber )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumberEnd )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaLineNumber * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFileId )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statement )( 
            IDiaLineNumber * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilandId )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        END_INTERFACE
    } IDiaLineNumberVtbl;

    interface IDiaLineNumber
    {
        CONST_VTBL struct IDiaLineNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLineNumber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLineNumber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLineNumber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLineNumber_get_compiland(This,pRetVal)	\
    (This)->lpVtbl -> get_compiland(This,pRetVal)

#define IDiaLineNumber_get_sourceFile(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFile(This,pRetVal)

#define IDiaLineNumber_get_lineNumber(This,pRetVal)	\
    (This)->lpVtbl -> get_lineNumber(This,pRetVal)

#define IDiaLineNumber_get_lineNumberEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_lineNumberEnd(This,pRetVal)

#define IDiaLineNumber_get_columnNumber(This,pRetVal)	\
    (This)->lpVtbl -> get_columnNumber(This,pRetVal)

#define IDiaLineNumber_get_columnNumberEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_columnNumberEnd(This,pRetVal)

#define IDiaLineNumber_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaLineNumber_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaLineNumber_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaLineNumber_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaLineNumber_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaLineNumber_get_sourceFileId(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFileId(This,pRetVal)

#define IDiaLineNumber_get_statement(This,pRetVal)	\
    (This)->lpVtbl -> get_statement(This,pRetVal)

#define IDiaLineNumber_get_compilandId(This,pRetVal)	\
    (This)->lpVtbl -> get_compilandId(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_compiland_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaLineNumber_get_compiland_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_sourceFile_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ IDiaSourceFile **pRetVal);


void __RPC_STUB IDiaLineNumber_get_sourceFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_lineNumber_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_lineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_lineNumberEnd_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_lineNumberEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_columnNumber_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_columnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_columnNumberEnd_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_columnNumberEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_addressSection_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_addressOffset_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_relativeVirtualAddress_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_virtualAddress_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaLineNumber_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_length_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_sourceFileId_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_sourceFileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_statement_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaLineNumber_get_statement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_compilandId_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_compilandId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLineNumber_INTERFACE_DEFINED__ */


#ifndef __IDiaSectionContrib_INTERFACE_DEFINED__
#define __IDiaSectionContrib_INTERFACE_DEFINED__

/* interface IDiaSectionContrib */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSectionContrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CF4B60E-35B1-4c6c-BDD8-854B9C8E3857")
    IDiaSectionContrib : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compiland( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notPaged( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_initializedData( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_uninitializedData( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_remove( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_comdat( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_discardable( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notCached( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_share( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_execute( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_read( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_write( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_dataCrc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relocationsCrc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilandId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSectionContribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSectionContrib * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSectionContrib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSectionContrib * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compiland )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notPaged )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_initializedData )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_uninitializedData )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_remove )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_comdat )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_discardable )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notCached )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_share )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_execute )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_read )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_write )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataCrc )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relocationsCrc )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilandId )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        END_INTERFACE
    } IDiaSectionContribVtbl;

    interface IDiaSectionContrib
    {
        CONST_VTBL struct IDiaSectionContribVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSectionContrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSectionContrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSectionContrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSectionContrib_get_compiland(This,pRetVal)	\
    (This)->lpVtbl -> get_compiland(This,pRetVal)

#define IDiaSectionContrib_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSectionContrib_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaSectionContrib_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSectionContrib_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaSectionContrib_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSectionContrib_get_notPaged(This,pRetVal)	\
    (This)->lpVtbl -> get_notPaged(This,pRetVal)

#define IDiaSectionContrib_get_code(This,pRetVal)	\
    (This)->lpVtbl -> get_code(This,pRetVal)

#define IDiaSectionContrib_get_initializedData(This,pRetVal)	\
    (This)->lpVtbl -> get_initializedData(This,pRetVal)

#define IDiaSectionContrib_get_uninitializedData(This,pRetVal)	\
    (This)->lpVtbl -> get_uninitializedData(This,pRetVal)

#define IDiaSectionContrib_get_remove(This,pRetVal)	\
    (This)->lpVtbl -> get_remove(This,pRetVal)

#define IDiaSectionContrib_get_comdat(This,pRetVal)	\
    (This)->lpVtbl -> get_comdat(This,pRetVal)

#define IDiaSectionContrib_get_discardable(This,pRetVal)	\
    (This)->lpVtbl -> get_discardable(This,pRetVal)

#define IDiaSectionContrib_get_notCached(This,pRetVal)	\
    (This)->lpVtbl -> get_notCached(This,pRetVal)

#define IDiaSectionContrib_get_share(This,pRetVal)	\
    (This)->lpVtbl -> get_share(This,pRetVal)

#define IDiaSectionContrib_get_execute(This,pRetVal)	\
    (This)->lpVtbl -> get_execute(This,pRetVal)

#define IDiaSectionContrib_get_read(This,pRetVal)	\
    (This)->lpVtbl -> get_read(This,pRetVal)

#define IDiaSectionContrib_get_write(This,pRetVal)	\
    (This)->lpVtbl -> get_write(This,pRetVal)

#define IDiaSectionContrib_get_dataCrc(This,pRetVal)	\
    (This)->lpVtbl -> get_dataCrc(This,pRetVal)

#define IDiaSectionContrib_get_relocationsCrc(This,pRetVal)	\
    (This)->lpVtbl -> get_relocationsCrc(This,pRetVal)

#define IDiaSectionContrib_get_compilandId(This,pRetVal)	\
    (This)->lpVtbl -> get_compilandId(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_compiland_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSectionContrib_get_compiland_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_addressSection_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_addressOffset_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_relativeVirtualAddress_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_virtualAddress_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_length_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_notPaged_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_notPaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_code_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_initializedData_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_initializedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_uninitializedData_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_uninitializedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_remove_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_comdat_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_comdat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_discardable_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_discardable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_notCached_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_notCached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_share_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_share_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_execute_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_read_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_write_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_dataCrc_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_dataCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_relocationsCrc_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_relocationsCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_compilandId_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_compilandId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSectionContrib_INTERFACE_DEFINED__ */


#ifndef __IDiaSegment_INTERFACE_DEFINED__
#define __IDiaSegment_INTERFACE_DEFINED__

/* interface IDiaSegment */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSegment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0775B784-C75B-4449-848B-B7BD3159545B")
    IDiaSegment : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frame( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_read( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_write( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_execute( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSegmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSegment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSegment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSegment * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frame )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offset )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_read )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_write )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_execute )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSegment * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        END_INTERFACE
    } IDiaSegmentVtbl;

    interface IDiaSegment
    {
        CONST_VTBL struct IDiaSegmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSegment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSegment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSegment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSegment_get_frame(This,pRetVal)	\
    (This)->lpVtbl -> get_frame(This,pRetVal)

#define IDiaSegment_get_offset(This,pRetVal)	\
    (This)->lpVtbl -> get_offset(This,pRetVal)

#define IDiaSegment_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSegment_get_read(This,pRetVal)	\
    (This)->lpVtbl -> get_read(This,pRetVal)

#define IDiaSegment_get_write(This,pRetVal)	\
    (This)->lpVtbl -> get_write(This,pRetVal)

#define IDiaSegment_get_execute(This,pRetVal)	\
    (This)->lpVtbl -> get_execute(This,pRetVal)

#define IDiaSegment_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSegment_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSegment_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_frame_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_frame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_offset_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_offset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_length_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_read_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_write_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_execute_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_addressSection_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_relativeVirtualAddress_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_virtualAddress_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSegment_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSegment_INTERFACE_DEFINED__ */


#ifndef __IDiaInjectedSource_INTERFACE_DEFINED__
#define __IDiaInjectedSource_INTERFACE_DEFINED__

/* interface IDiaInjectedSource */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaInjectedSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE605CDC-8105-4a23-B710-3259F1E26112")
    IDiaInjectedSource : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_crc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_filename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_objectFilename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualFilename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceCompression( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_source( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaInjectedSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaInjectedSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaInjectedSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaInjectedSource * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_crc )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_filename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_objectFilename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualFilename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceCompression )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_source )( 
            IDiaInjectedSource * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaInjectedSourceVtbl;

    interface IDiaInjectedSource
    {
        CONST_VTBL struct IDiaInjectedSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaInjectedSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaInjectedSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaInjectedSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaInjectedSource_get_crc(This,pRetVal)	\
    (This)->lpVtbl -> get_crc(This,pRetVal)

#define IDiaInjectedSource_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaInjectedSource_get_filename(This,pRetVal)	\
    (This)->lpVtbl -> get_filename(This,pRetVal)

#define IDiaInjectedSource_get_objectFilename(This,pRetVal)	\
    (This)->lpVtbl -> get_objectFilename(This,pRetVal)

#define IDiaInjectedSource_get_virtualFilename(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualFilename(This,pRetVal)

#define IDiaInjectedSource_get_sourceCompression(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceCompression(This,pRetVal)

#define IDiaInjectedSource_get_source(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_source(This,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_crc_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_crc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_length_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_filename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_objectFilename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_objectFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_virtualFilename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_virtualFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_sourceCompression_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_sourceCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_source_Proxy( 
    IDiaInjectedSource * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaInjectedSource_get_source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaInjectedSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_0131 */
/* [local] */ 


enum __MIDL___MIDL_itf_dia2_0131_0001
    {	E_DIA_INPROLOG	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )100),
	E_DIA_SYNTAX	= E_DIA_INPROLOG + 1,
	E_DIA_FRAME_ACCESS	= E_DIA_SYNTAX + 1,
	E_DIA_VALUE	= E_DIA_FRAME_ACCESS + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dia2_0131_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0131_v0_0_s_ifspec;

#ifndef __IDiaStackWalkFrame_INTERFACE_DEFINED__
#define __IDiaStackWalkFrame_INTERFACE_DEFINED__

/* interface IDiaStackWalkFrame */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalkFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97F0F1A6-E04E-4ea4-B4F9-B0D0E8D90F5D")
    IDiaStackWalkFrame : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerValue( 
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_registerValue( 
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE readMemory( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddress( 
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddressStart( 
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalkFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalkFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalkFrame * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerValue )( 
            IDiaStackWalkFrame * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_registerValue )( 
            IDiaStackWalkFrame * This,
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *readMemory )( 
            IDiaStackWalkFrame * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddress )( 
            IDiaStackWalkFrame * This,
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddressStart )( 
            IDiaStackWalkFrame * This,
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress);
        
        END_INTERFACE
    } IDiaStackWalkFrameVtbl;

    interface IDiaStackWalkFrame
    {
        CONST_VTBL struct IDiaStackWalkFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalkFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalkFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalkFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalkFrame_get_registerValue(This,index,pRetVal)	\
    (This)->lpVtbl -> get_registerValue(This,index,pRetVal)

#define IDiaStackWalkFrame_put_registerValue(This,index,NewVal)	\
    (This)->lpVtbl -> put_registerValue(This,index,NewVal)

#define IDiaStackWalkFrame_readMemory(This,va,cbData,pcbData,data)	\
    (This)->lpVtbl -> readMemory(This,va,cbData,pcbData,data)

#define IDiaStackWalkFrame_searchForReturnAddress(This,frame,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddress(This,frame,returnAddress)

#define IDiaStackWalkFrame_searchForReturnAddressStart(This,frame,startAddress,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddressStart(This,frame,startAddress,returnAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_get_registerValue_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackWalkFrame_get_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_put_registerValue_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ DWORD index,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaStackWalkFrame_put_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_readMemory_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaStackWalkFrame_readMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_searchForReturnAddress_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ IDiaFrameData *frame,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkFrame_searchForReturnAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_searchForReturnAddressStart_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ IDiaFrameData *frame,
    /* [in] */ ULONGLONG startAddress,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkFrame_searchForReturnAddressStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackWalkFrame_INTERFACE_DEFINED__ */


#ifndef __IDiaFrameData_INTERFACE_DEFINED__
#define __IDiaFrameData_INTERFACE_DEFINED__

/* interface IDiaFrameData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaFrameData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A39184B7-6A36-42de-8EEC-7DF9F3F59F33")
    IDiaFrameData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthBlock( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthLocals( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthParams( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_maxStack( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthProlog( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthSavedRegisters( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_program( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_systemExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_cplusplusExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionStart( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_allocatesBasePointer( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionParent( 
            /* [retval][out] */ IDiaFrameData **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE execute( 
            IDiaStackWalkFrame *frame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaFrameDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaFrameData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaFrameData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaFrameData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaFrameData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthBlock )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthLocals )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthParams )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_maxStack )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthProlog )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthSavedRegisters )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_program )( 
            IDiaFrameData * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemExceptionHandling )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_cplusplusExceptionHandling )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionStart )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_allocatesBasePointer )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionParent )( 
            IDiaFrameData * This,
            /* [retval][out] */ IDiaFrameData **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *execute )( 
            IDiaFrameData * This,
            IDiaStackWalkFrame *frame);
        
        END_INTERFACE
    } IDiaFrameDataVtbl;

    interface IDiaFrameData
    {
        CONST_VTBL struct IDiaFrameDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaFrameData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaFrameData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaFrameData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaFrameData_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaFrameData_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaFrameData_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaFrameData_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaFrameData_get_lengthBlock(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthBlock(This,pRetVal)

#define IDiaFrameData_get_lengthLocals(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthLocals(This,pRetVal)

#define IDiaFrameData_get_lengthParams(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthParams(This,pRetVal)

#define IDiaFrameData_get_maxStack(This,pRetVal)	\
    (This)->lpVtbl -> get_maxStack(This,pRetVal)

#define IDiaFrameData_get_lengthProlog(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthProlog(This,pRetVal)

#define IDiaFrameData_get_lengthSavedRegisters(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthSavedRegisters(This,pRetVal)

#define IDiaFrameData_get_program(This,pRetVal)	\
    (This)->lpVtbl -> get_program(This,pRetVal)

#define IDiaFrameData_get_systemExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_systemExceptionHandling(This,pRetVal)

#define IDiaFrameData_get_cplusplusExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_cplusplusExceptionHandling(This,pRetVal)

#define IDiaFrameData_get_functionStart(This,pRetVal)	\
    (This)->lpVtbl -> get_functionStart(This,pRetVal)

#define IDiaFrameData_get_allocatesBasePointer(This,pRetVal)	\
    (This)->lpVtbl -> get_allocatesBasePointer(This,pRetVal)

#define IDiaFrameData_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaFrameData_get_functionParent(This,pRetVal)	\
    (This)->lpVtbl -> get_functionParent(This,pRetVal)

#define IDiaFrameData_execute(This,frame)	\
    (This)->lpVtbl -> execute(This,frame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_addressSection_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_addressOffset_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_relativeVirtualAddress_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_virtualAddress_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaFrameData_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthBlock_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthLocals_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthLocals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthParams_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_maxStack_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_maxStack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthProlog_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthProlog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthSavedRegisters_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthSavedRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_program_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaFrameData_get_program_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_systemExceptionHandling_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_systemExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_cplusplusExceptionHandling_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_cplusplusExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_functionStart_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_functionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_allocatesBasePointer_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_allocatesBasePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_type_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_functionParent_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ IDiaFrameData **pRetVal);


void __RPC_STUB IDiaFrameData_get_functionParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaFrameData_execute_Proxy( 
    IDiaFrameData * This,
    IDiaStackWalkFrame *frame);


void __RPC_STUB IDiaFrameData_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaFrameData_INTERFACE_DEFINED__ */


#ifndef __IDiaImageData_INTERFACE_DEFINED__
#define __IDiaImageData_INTERFACE_DEFINED__

/* interface IDiaImageData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaImageData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8E40ED2-A1D9-4221-8692-3CE661184B44")
    IDiaImageData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_imageBase( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaImageDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaImageData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaImageData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaImageData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaImageData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaImageData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageBase )( 
            IDiaImageData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        END_INTERFACE
    } IDiaImageDataVtbl;

    interface IDiaImageData
    {
        CONST_VTBL struct IDiaImageDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaImageData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaImageData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaImageData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaImageData_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaImageData_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaImageData_get_imageBase(This,pRetVal)	\
    (This)->lpVtbl -> get_imageBase(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_relativeVirtualAddress_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaImageData_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_virtualAddress_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaImageData_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_imageBase_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaImageData_get_imageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaImageData_INTERFACE_DEFINED__ */


#ifndef __IDiaTable_INTERFACE_DEFINED__
#define __IDiaTable_INTERFACE_DEFINED__

/* interface IDiaTable */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4A59FB77-ABAC-469b-A30B-9ECC85BFEF14")
    IDiaTable : public IEnumUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IUnknown **element) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaTable * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaTable * This,
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaTable * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaTable * This,
            /* [out] */ IEnumUnknown **ppenum);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaTable * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaTable * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaTable * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaTable * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IUnknown **element);
        
        END_INTERFACE
    } IDiaTableVtbl;

    interface IDiaTable
    {
        CONST_VTBL struct IDiaTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaTable_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaTable_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaTable_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaTable_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)


#define IDiaTable_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaTable_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaTable_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaTable_Item(This,index,element)	\
    (This)->lpVtbl -> Item(This,index,element)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get__NewEnum_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaTable_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get_name_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaTable_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get_Count_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaTable_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaTable_Item_Proxy( 
    IDiaTable * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IUnknown **element);


void __RPC_STUB IDiaTable_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaTable_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumTables_INTERFACE_DEFINED__
#define __IDiaEnumTables_INTERFACE_DEFINED__

/* interface IDiaEnumTables */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumTables;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C65C2B0A-1150-4d7a-AFCC-E05BF3DEE81E")
    IDiaEnumTables : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaTable **table) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            ULONG celt,
            IDiaTable **rgelt,
            ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumTables **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumTablesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumTables * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumTables * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumTables * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumTables * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumTables * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumTables * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaTable **table);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumTables * This,
            ULONG celt,
            IDiaTable **rgelt,
            ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumTables * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumTables * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumTables * This,
            /* [out] */ IDiaEnumTables **ppenum);
        
        END_INTERFACE
    } IDiaEnumTablesVtbl;

    interface IDiaEnumTables
    {
        CONST_VTBL struct IDiaEnumTablesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumTables_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumTables_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumTables_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumTables_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumTables_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumTables_Item(This,index,table)	\
    (This)->lpVtbl -> Item(This,index,table)

#define IDiaEnumTables_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumTables_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumTables_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumTables_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_get__NewEnum_Proxy( 
    IDiaEnumTables * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumTables_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_get_Count_Proxy( 
    IDiaEnumTables * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumTables_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_Item_Proxy( 
    IDiaEnumTables * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDiaTable **table);


void __RPC_STUB IDiaEnumTables_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Next_Proxy( 
    IDiaEnumTables * This,
    ULONG celt,
    IDiaTable **rgelt,
    ULONG *pceltFetched);


void __RPC_STUB IDiaEnumTables_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Skip_Proxy( 
    IDiaEnumTables * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumTables_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Reset_Proxy( 
    IDiaEnumTables * This);


void __RPC_STUB IDiaEnumTables_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Clone_Proxy( 
    IDiaEnumTables * This,
    /* [out] */ IDiaEnumTables **ppenum);


void __RPC_STUB IDiaEnumTables_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumTables_INTERFACE_DEFINED__ */



#ifndef __Dia2Lib_LIBRARY_DEFINED__
#define __Dia2Lib_LIBRARY_DEFINED__

/* library Dia2Lib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_Dia2Lib;

EXTERN_C const CLSID CLSID_DiaSource;

#ifdef __cplusplus

class DECLSPEC_UUID("151CE278-3CCB-4161-8658-679F8BCF29ED")
DiaSource;
#endif

EXTERN_C const CLSID CLSID_DiaSourceAlt;

#ifdef __cplusplus

class DECLSPEC_UUID("AF74D59B-5AF2-4f36-9E86-87B754DC8A4E")
DiaSourceAlt;
#endif
#endif /* __Dia2Lib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_dia2_0136 */
/* [local] */ 

#define	DiaTable_Symbols	( L"Symbols" )

#define	DiaTable_Sections	( L"Sections" )

#define	DiaTable_SrcFiles	( L"SourceFiles" )

#define	DiaTable_LineNums	( L"LineNumbers" )

#define	DiaTable_SegMap	( L"SegmentMap" )

#define	DiaTable_Dbg	( L"Dbg" )

#define	DiaTable_InjSrc	( L"InjectedSource" )

#define	DiaTable_FrameData	( L"FrameData" )



extern RPC_IF_HANDLE __MIDL_itf_dia2_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0136_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\imports\include\diacreate.h ===
// diacreate.h - creation helper functions for DIA initialization
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _DIACREATE_H_
#define _DIACREATE_H_

//
// Create a dia data source object from the dia dll (by dll name - does not access the registry).
//
HRESULT STDMETHODCALLTYPE NoRegCoCreate(  const char*dllName,
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

//
// Create a dia data source object from the dia dll (looks up the class id in the registry).
//
HRESULT STDMETHODCALLTYPE NoOleCoCreate(  REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\imports\include\cvconst.h ===
// cvconst.h - codeview constant definitions
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1993-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _CVCONST_H_
#define _CVCONST_H_



//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_AM33CALL    = 0x12, // AM33 call
    CV_CALL_TRICALL     = 0x13, // TriCore Call
    CV_CALL_SH5CALL     = 0x14, // Hitachi SuperH-5 call
    CV_CALL_M32RCALL    = 0x15, // M32R Call
    CV_CALL_RESERVED    = 0x16  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;

typedef enum THUNK_ORDINAL {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...

 // trampoline thunk ordinals	- only for use in Trampoline thunk symbols
    THUNK_ORDINAL_TRAMP_INCREMENTAL,
    THUNK_ORDINAL_TRAMP_BRANCHISLAND,

} THUNK_ORDINAL;


enum CV_SourceChksum_t {
    CHKSUM_TYPE_NONE = 0,        // indicates no checksum is available
    CHKSUM_TYPE_MD5
};

//
// DIA enums
//

enum SymTagEnum
{
	SymTagNull,
	SymTagExe,
	SymTagCompiland, 
	SymTagCompilandDetails, 
	SymTagCompilandEnv,
	SymTagFunction, 
	SymTagBlock,
	SymTagData,
	SymTagReserved, 
	SymTagLabel, 
	SymTagPublicSymbol, 
	SymTagUDT, 
	SymTagEnum, 
	SymTagFunctionType, 
	SymTagPointerType, 
	SymTagArrayType, 
	SymTagBaseType, 
	SymTagTypedef, 
	SymTagBaseClass,
	SymTagFriend,
	SymTagFunctionArgType, 
	SymTagFuncDebugStart, 
	SymTagFuncDebugEnd,
    SymTagUsingNamespace, 
    SymTagVTableShape,
    SymTagVTable,
	SymTagCustom,
    SymTagThunk,
	SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
	SymTagMax
};

enum LocationType
{
	LocIsNull,
	LocIsStatic,
	LocIsTLS, 
	LocIsRegRel, 
	LocIsThisRel, 
	LocIsEnregistered, 
	LocIsBitField,
    LocIsSlot,
    LocIsIlRel,
    LocInMetaData,
    LocIsConstant,
	LocTypeMax
};

enum DataKind
{
    DataIsUnknown,
    DataIsLocal,
    DataIsStaticLocal,
    DataIsParam,
    DataIsObjectPtr,
    DataIsFileStatic,
    DataIsGlobal,
    DataIsMember,
    DataIsStaticMember,
    DataIsConstant
};

enum BasicType 
{
	btNoType = 0,
	btVoid = 1,
	btChar = 2,
	btWChar = 3,
	btInt = 6,
	btUInt = 7,
	btFloat = 8,
	btBCD = 9,
	btBool = 10,	
	btCurrency = 25,
	btDate = 26,
	btVariant = 27,
	btComplex = 28,
	btBit = 29,
	btBSTR = 30,
    btHresult = 31
};


//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
    CV_CFL_CVTPGD   = 0x09,
} CV_CFL_LANG;


//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMII    = 0x06,
    CV_CFL_PENTIUMPRO   = CV_CFL_PENTIUMII,
    CV_CFL_PENTIUMIII   = 0x07,
    CV_CFL_MIPS         = 0x10,
    CV_CFL_MIPSR4000    = CV_CFL_MIPS,  // don't break current code
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_MIPS32       = 0x12,
    CV_CFL_MIPS64       = 0x13,
    CV_CFL_MIPSI        = 0x14,
    CV_CFL_MIPSII       = 0x15,
    CV_CFL_MIPSIII      = 0x16,
    CV_CFL_MIPSIV       = 0x17,
    CV_CFL_MIPSV        = 0x18,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_PPCFP        = 0x44,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_SHMEDIA      = 0x54,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_ARM5         = 0x63,
    CV_CFL_ARM5T        = 0x64,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
    CV_CFL_IA64_1       = 0x80,
    CV_CFL_IA64_2       = 0x81,
    CV_CFL_CEE          = 0x90,
    CV_CFL_AM33         = 0xA0,
    CV_CFL_M32R         = 0xB0,
    CV_CFL_TRICORE      = 0xC0,
    CV_CFL_RESERVED1    = 0xD0,
} CV_CPU_TYPE_e;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below, hence the high values

    CV_ALLREG_ERR   =   30000,
    CV_ALLREG_TEB   =   30001,
    CV_ALLREG_TIMER =   30002,
    CV_ALLREG_EFAD1 =   30003,
    CV_ALLREG_EFAD2 =   30004,
    CV_ALLREG_EFAD3 =   30005,
    CV_ALLREG_VFRAME=   30006,
    CV_ALLREG_HANDLE=   30007,
    CV_ALLREG_PARAMS=   30008,
    CV_ALLREG_LOCALS=   30009,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

    CV_REG_XMM0     =  154, // KATMAI registers
    CV_REG_XMM1     =  155,
    CV_REG_XMM2     =  156,
    CV_REG_XMM3     =  157,
    CV_REG_XMM4     =  158,
    CV_REG_XMM5     =  159,
    CV_REG_XMM6     =  160,
    CV_REG_XMM7     =  161,

    CV_REG_XMM00    =  162, // KATMAI sub-registers
    CV_REG_XMM01    =  163,
    CV_REG_XMM02    =  164,
    CV_REG_XMM03    =  165,
    CV_REG_XMM10    =  166,
    CV_REG_XMM11    =  167,
    CV_REG_XMM12    =  168,
    CV_REG_XMM13    =  169,
    CV_REG_XMM20    =  170,
    CV_REG_XMM21    =  171,
    CV_REG_XMM22    =  172,
    CV_REG_XMM23    =  173,
    CV_REG_XMM30    =  174,
    CV_REG_XMM31    =  175,
    CV_REG_XMM32    =  176,
    CV_REG_XMM33    =  177,
    CV_REG_XMM40    =  178,
    CV_REG_XMM41    =  179,
    CV_REG_XMM42    =  180,
    CV_REG_XMM43    =  181,
    CV_REG_XMM50    =  182,
    CV_REG_XMM51    =  183,
    CV_REG_XMM52    =  184,
    CV_REG_XMM53    =  185,
    CV_REG_XMM60    =  186,
    CV_REG_XMM61    =  187,
    CV_REG_XMM62    =  188,
    CV_REG_XMM63    =  189,
    CV_REG_XMM70    =  190,
    CV_REG_XMM71    =  191,
    CV_REG_XMM72    =  192,
    CV_REG_XMM73    =  193,

    CV_REG_XMM0L    =  194, 
    CV_REG_XMM1L    =  195,
    CV_REG_XMM2L    =  196,
    CV_REG_XMM3L    =  197,
    CV_REG_XMM4L    =  198,
    CV_REG_XMM5L    =  199,
    CV_REG_XMM6L    =  200,
    CV_REG_XMM7L    =  201,
    
    CV_REG_XMM0H    =  202, 
    CV_REG_XMM1H    =  203,
    CV_REG_XMM2H    =  204,
    CV_REG_XMM3H    =  205,
    CV_REG_XMM4H    =  206,
    CV_REG_XMM5H    =  207,
    CV_REG_XMM6H    =  208,
    CV_REG_XMM7H    =  209,

    CV_REG_MXCSR    =  211, // XMM status register

    CV_REG_EDXEAX   =  212,	// EDX:EAX pair

    CV_REG_EMM0L    =  220, // XMM sub-registers (WNI integer)
    CV_REG_EMM1L    =  221,
    CV_REG_EMM2L    =  222,
    CV_REG_EMM3L    =  223,
    CV_REG_EMM4L    =  224,
    CV_REG_EMM5L    =  225,
    CV_REG_EMM6L    =  226,
    CV_REG_EMM7L    =  227,

    CV_REG_EMM0H    =  228, 
    CV_REG_EMM1H    =  229,
    CV_REG_EMM2H    =  230,
    CV_REG_EMM3H    =  231,
    CV_REG_EMM4H    =  232,
    CV_REG_EMM5H    =  233,
    CV_REG_EMM6H    =  234,
    CV_REG_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_REG_MM00     =  236,
    CV_REG_MM01     =  237,
    CV_REG_MM10     =  238,
    CV_REG_MM11     =  239,
    CV_REG_MM20     =  240,
    CV_REG_MM21     =  241,
    CV_REG_MM30     =  242,
    CV_REG_MM31     =  243,
    CV_REG_MM40     =  244,
    CV_REG_MM41     =  245,
    CV_REG_MM50     =  246,
    CV_REG_MM51     =  247,
    CV_REG_MM60     =  248,
    CV_REG_MM61     =  249,
    CV_REG_MM70     =  250,
    CV_REG_MM71     =  251,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_Br0     =   512,
    CV_IA64_Br1     =   513,
    CV_IA64_Br2     =   514,
    CV_IA64_Br3     =   515,
    CV_IA64_Br4     =   516,
    CV_IA64_Br5     =   517,
    CV_IA64_Br6     =   518,
    CV_IA64_Br7     =   519,

    // Predicate Registers

    CV_IA64_P0	  =   704,
    CV_IA64_P1    =   705,
    CV_IA64_P2    =   706,
    CV_IA64_P3    =   707,
    CV_IA64_P4    =   708,
    CV_IA64_P5    =   709,
    CV_IA64_P6    =   710,
    CV_IA64_P7    =   711,
    CV_IA64_P8    =   712,
    CV_IA64_P9    =   713,
    CV_IA64_P10   =   714,
    CV_IA64_P11   =   715,
    CV_IA64_P12   =   716,
    CV_IA64_P13   =   717,
    CV_IA64_P14   =   718,
    CV_IA64_P15   =   719,
    CV_IA64_P16   =   720,
    CV_IA64_P17   =   721,
    CV_IA64_P18   =   722,
    CV_IA64_P19   =   723,
    CV_IA64_P20   =   724,
    CV_IA64_P21   =   725,
    CV_IA64_P22   =   726,
    CV_IA64_P23   =   727,
    CV_IA64_P24   =   728,
    CV_IA64_P25   =   729,
    CV_IA64_P26   =   730,
    CV_IA64_P27   =   731,
    CV_IA64_P28   =   732,
    CV_IA64_P29   =   733,
    CV_IA64_P30   =   734,
    CV_IA64_P31   =   735,
    CV_IA64_P32   =   736,
    CV_IA64_P33   =   737,
    CV_IA64_P34   =   738,
    CV_IA64_P35   =   739,
    CV_IA64_P36   =   740,
    CV_IA64_P37   =   741,
    CV_IA64_P38   =   742,
    CV_IA64_P39   =   743,
    CV_IA64_P40   =   744,
    CV_IA64_P41   =   745,
    CV_IA64_P42   =   746,
    CV_IA64_P43   =   747,
    CV_IA64_P44   =   748,
    CV_IA64_P45   =   749,
    CV_IA64_P46   =   750,
    CV_IA64_P47   =   751,
    CV_IA64_P48   =   752,
    CV_IA64_P49   =   753,
    CV_IA64_P50   =   754,
    CV_IA64_P51   =   755,
    CV_IA64_P52   =   756,
    CV_IA64_P53   =   757,
    CV_IA64_P54   =   758,
    CV_IA64_P55   =   759,
    CV_IA64_P56   =   760,
    CV_IA64_P57   =   761,
    CV_IA64_P58   =   762,
    CV_IA64_P59   =   763,
    CV_IA64_P60   =   764,
    CV_IA64_P61   =   765,
    CV_IA64_P62   =   766,
    CV_IA64_P63   =   767,

    CV_IA64_Preds   =   768,

    // Banked General Registers

    CV_IA64_IntH0   =   832,
    CV_IA64_IntH1   =   833,
    CV_IA64_IntH2   =   834,
    CV_IA64_IntH3   =   835,
    CV_IA64_IntH4   =   836,
    CV_IA64_IntH5   =   837,
    CV_IA64_IntH6   =   838,
    CV_IA64_IntH7   =   839,
    CV_IA64_IntH8   =   840,
    CV_IA64_IntH9   =   841,
    CV_IA64_IntH10  =   842,
    CV_IA64_IntH11  =   843,
    CV_IA64_IntH12  =   844,
    CV_IA64_IntH13  =   845,
    CV_IA64_IntH14  =   846,
    CV_IA64_IntH15  =   847,

    // Special Registers

    CV_IA64_Ip      =   1016,
    CV_IA64_Umask   =   1017,
    CV_IA64_Cfm     =   1018,
    CV_IA64_Psr     =   1019,

    // Banked General Registers

    CV_IA64_Nats    =   1020,
    CV_IA64_Nats2   =   1021,
    CV_IA64_Nats3   =   1022,

    // General-Purpose Registers

    // Integer registers
    CV_IA64_IntR0   =   1024,
    CV_IA64_IntR1   =   1025,
    CV_IA64_IntR2   =   1026,
    CV_IA64_IntR3   =   1027,
    CV_IA64_IntR4   =   1028,
    CV_IA64_IntR5   =   1029,
    CV_IA64_IntR6   =   1030,
    CV_IA64_IntR7   =   1031,
    CV_IA64_IntR8   =   1032,
    CV_IA64_IntR9   =   1033,
    CV_IA64_IntR10  =   1034,
    CV_IA64_IntR11  =   1035,
    CV_IA64_IntR12  =   1036,
    CV_IA64_IntR13  =   1037,
    CV_IA64_IntR14  =   1038,
    CV_IA64_IntR15  =   1039,
    CV_IA64_IntR16  =   1040,
    CV_IA64_IntR17  =   1041,
    CV_IA64_IntR18  =   1042,
    CV_IA64_IntR19  =   1043,
    CV_IA64_IntR20  =   1044,
    CV_IA64_IntR21  =   1045,
    CV_IA64_IntR22  =   1046,
    CV_IA64_IntR23  =   1047,
    CV_IA64_IntR24  =   1048,
    CV_IA64_IntR25  =   1049,
    CV_IA64_IntR26  =   1050,
    CV_IA64_IntR27  =   1051,
    CV_IA64_IntR28  =   1052,
    CV_IA64_IntR29  =   1053,
    CV_IA64_IntR30  =   1054,
    CV_IA64_IntR31  =   1055,

    // Register Stack
    CV_IA64_IntR32  =   1056,
    CV_IA64_IntR33  =   1057,
    CV_IA64_IntR34  =   1058,
    CV_IA64_IntR35  =   1059,
    CV_IA64_IntR36  =   1060,
    CV_IA64_IntR37  =   1061,
    CV_IA64_IntR38  =   1062,
    CV_IA64_IntR39  =   1063,
    CV_IA64_IntR40  =   1064,
    CV_IA64_IntR41  =   1065,
    CV_IA64_IntR42  =   1066,
    CV_IA64_IntR43  =   1067,
    CV_IA64_IntR44  =   1068,
    CV_IA64_IntR45  =   1069,
    CV_IA64_IntR46  =   1070,
    CV_IA64_IntR47  =   1071,
    CV_IA64_IntR48  =   1072,
    CV_IA64_IntR49  =   1073,
    CV_IA64_IntR50  =   1074,
    CV_IA64_IntR51  =   1075,
    CV_IA64_IntR52  =   1076,
    CV_IA64_IntR53  =   1077,
    CV_IA64_IntR54  =   1078,
    CV_IA64_IntR55  =   1079,
    CV_IA64_IntR56  =   1080,
    CV_IA64_IntR57  =   1081,
    CV_IA64_IntR58  =   1082,
    CV_IA64_IntR59  =   1083,
    CV_IA64_IntR60  =   1084,
    CV_IA64_IntR61  =   1085,
    CV_IA64_IntR62  =   1086,
    CV_IA64_IntR63  =   1087,
    CV_IA64_IntR64  =   1088,
    CV_IA64_IntR65  =   1089,
    CV_IA64_IntR66  =   1090,
    CV_IA64_IntR67  =   1091,
    CV_IA64_IntR68  =   1092,
    CV_IA64_IntR69  =   1093,
    CV_IA64_IntR70  =   1094,
    CV_IA64_IntR71  =   1095,
    CV_IA64_IntR72  =   1096,
    CV_IA64_IntR73  =   1097,
    CV_IA64_IntR74  =   1098,
    CV_IA64_IntR75  =   1099,
    CV_IA64_IntR76  =   1100,
    CV_IA64_IntR77  =   1101,
    CV_IA64_IntR78  =   1102,
    CV_IA64_IntR79  =   1103,
    CV_IA64_IntR80  =   1104,
    CV_IA64_IntR81  =   1105,
    CV_IA64_IntR82  =   1106,
    CV_IA64_IntR83  =   1107,
    CV_IA64_IntR84  =   1108,
    CV_IA64_IntR85  =   1109,
    CV_IA64_IntR86  =   1110,
    CV_IA64_IntR87  =   1111,
    CV_IA64_IntR88  =   1112,
    CV_IA64_IntR89  =   1113,
    CV_IA64_IntR90  =   1114,
    CV_IA64_IntR91  =   1115,
    CV_IA64_IntR92  =   1116,
    CV_IA64_IntR93  =   1117,
    CV_IA64_IntR94  =   1118,
    CV_IA64_IntR95  =   1119,
    CV_IA64_IntR96  =   1120,
    CV_IA64_IntR97  =   1121,
    CV_IA64_IntR98  =   1122,
    CV_IA64_IntR99  =   1123,
    CV_IA64_IntR100 =   1124,
    CV_IA64_IntR101 =   1125,
    CV_IA64_IntR102 =   1126,
    CV_IA64_IntR103 =   1127,
    CV_IA64_IntR104 =   1128,
    CV_IA64_IntR105 =   1129,
    CV_IA64_IntR106 =   1130,
    CV_IA64_IntR107 =   1131,
    CV_IA64_IntR108 =   1132,
    CV_IA64_IntR109 =   1133,
    CV_IA64_IntR110 =   1134,
    CV_IA64_IntR111 =   1135,
    CV_IA64_IntR112 =   1136,
    CV_IA64_IntR113 =   1137,
    CV_IA64_IntR114 =   1138,
    CV_IA64_IntR115 =   1139,
    CV_IA64_IntR116 =   1140,
    CV_IA64_IntR117 =   1141,
    CV_IA64_IntR118 =   1142,
    CV_IA64_IntR119 =   1143,
    CV_IA64_IntR120 =   1144,
    CV_IA64_IntR121 =   1145,
    CV_IA64_IntR122 =   1146,
    CV_IA64_IntR123 =   1147,
    CV_IA64_IntR124 =   1148,
    CV_IA64_IntR125 =   1149,
    CV_IA64_IntR126 =   1150,
    CV_IA64_IntR127 =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltF0   =   2048,
    CV_IA64_FltF1   =   2049,
    CV_IA64_FltF2   =   2050,
    CV_IA64_FltF3   =   2051,
    CV_IA64_FltF4   =   2052,
    CV_IA64_FltF5   =   2053,
    CV_IA64_FltF6   =   2054,
    CV_IA64_FltF7   =   2055,
    CV_IA64_FltF8   =   2056,
    CV_IA64_FltF9   =   2057,
    CV_IA64_FltF10  =   2058,
    CV_IA64_FltF11  =   2059,
    CV_IA64_FltF12  =   2060,
    CV_IA64_FltF13  =   2061,
    CV_IA64_FltF14  =   2062,
    CV_IA64_FltF15  =   2063,
    CV_IA64_FltF16  =   2064,
    CV_IA64_FltF17  =   2065,
    CV_IA64_FltF18  =   2066,
    CV_IA64_FltF19  =   2067,
    CV_IA64_FltF20  =   2068,
    CV_IA64_FltF21  =   2069,
    CV_IA64_FltF22  =   2070,
    CV_IA64_FltF23  =   2071,
    CV_IA64_FltF24  =   2072,
    CV_IA64_FltF25  =   2073,
    CV_IA64_FltF26  =   2074,
    CV_IA64_FltF27  =   2075,
    CV_IA64_FltF28  =   2076,
    CV_IA64_FltF29  =   2077,
    CV_IA64_FltF30  =   2078,
    CV_IA64_FltF31  =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32  =   2080,
    CV_IA64_FltF33  =   2081,
    CV_IA64_FltF34  =   2082,
    CV_IA64_FltF35  =   2083,
    CV_IA64_FltF36  =   2084,
    CV_IA64_FltF37  =   2085,
    CV_IA64_FltF38  =   2086,
    CV_IA64_FltF39  =   2087,
    CV_IA64_FltF40  =   2088,
    CV_IA64_FltF41  =   2089,
    CV_IA64_FltF42  =   2090,
    CV_IA64_FltF43  =   2091,
    CV_IA64_FltF44  =   2092,
    CV_IA64_FltF45  =   2093,
    CV_IA64_FltF46  =   2094,
    CV_IA64_FltF47  =   2095,
    CV_IA64_FltF48  =   2096,
    CV_IA64_FltF49  =   2097,
    CV_IA64_FltF50  =   2098,
    CV_IA64_FltF51  =   2099,
    CV_IA64_FltF52  =   2100,
    CV_IA64_FltF53  =   2101,
    CV_IA64_FltF54  =   2102,
    CV_IA64_FltF55  =   2103,
    CV_IA64_FltF56  =   2104,
    CV_IA64_FltF57  =   2105,
    CV_IA64_FltF58  =   2106,
    CV_IA64_FltF59  =   2107,
    CV_IA64_FltF60  =   2108,
    CV_IA64_FltF61  =   2109,
    CV_IA64_FltF62  =   2110,
    CV_IA64_FltF63  =   2111,
    CV_IA64_FltF64  =   2112,
    CV_IA64_FltF65  =   2113,
    CV_IA64_FltF66  =   2114,
    CV_IA64_FltF67  =   2115,
    CV_IA64_FltF68  =   2116,
    CV_IA64_FltF69  =   2117,
    CV_IA64_FltF70  =   2118,
    CV_IA64_FltF71  =   2119,
    CV_IA64_FltF72  =   2120,
    CV_IA64_FltF73  =   2121,
    CV_IA64_FltF74  =   2122,
    CV_IA64_FltF75  =   2123,
    CV_IA64_FltF76  =   2124,
    CV_IA64_FltF77  =   2125,
    CV_IA64_FltF78  =   2126,
    CV_IA64_FltF79  =   2127,
    CV_IA64_FltF80  =   2128,
    CV_IA64_FltF81  =   2129,
    CV_IA64_FltF82  =   2130,
    CV_IA64_FltF83  =   2131,
    CV_IA64_FltF84  =   2132,
    CV_IA64_FltF85  =   2133,
    CV_IA64_FltF86  =   2134,
    CV_IA64_FltF87  =   2135,
    CV_IA64_FltF88  =   2136,
    CV_IA64_FltF89  =   2137,
    CV_IA64_FltF90  =   2138,
    CV_IA64_FltF91  =   2139,
    CV_IA64_FltF92  =   2140,
    CV_IA64_FltF93  =   2141,
    CV_IA64_FltF94  =   2142,
    CV_IA64_FltF95  =   2143,
    CV_IA64_FltF96  =   2144,
    CV_IA64_FltF97  =   2145,
    CV_IA64_FltF98  =   2146,
    CV_IA64_FltF99  =   2147,
    CV_IA64_FltF100 =   2148,
    CV_IA64_FltF101 =   2149,
    CV_IA64_FltF102 =   2150,
    CV_IA64_FltF103 =   2151,
    CV_IA64_FltF104 =   2152,
    CV_IA64_FltF105 =   2153,
    CV_IA64_FltF106 =   2154,
    CV_IA64_FltF107 =   2155,
    CV_IA64_FltF108 =   2156,
    CV_IA64_FltF109 =   2157,
    CV_IA64_FltF110 =   2158,
    CV_IA64_FltF111 =   2159,
    CV_IA64_FltF112 =   2160,
    CV_IA64_FltF113 =   2161,
    CV_IA64_FltF114 =   2162,
    CV_IA64_FltF115 =   2163,
    CV_IA64_FltF116 =   2164,
    CV_IA64_FltF117 =   2165,
    CV_IA64_FltF118 =   2166,
    CV_IA64_FltF119 =   2167,
    CV_IA64_FltF120 =   2168,
    CV_IA64_FltF121 =   2169,
    CV_IA64_FltF122 =   2170,
    CV_IA64_FltF123 =   2171,
    CV_IA64_FltF124 =   2172,
    CV_IA64_FltF125 =   2173,
    CV_IA64_FltF126 =   2174,
    CV_IA64_FltF127 =   2175,

    // Application Registers

    CV_IA64_ApKR0   =   3072,
    CV_IA64_ApKR1   =   3073,
    CV_IA64_ApKR2   =   3074,
    CV_IA64_ApKR3   =   3075,
    CV_IA64_ApKR4   =   3076,
    CV_IA64_ApKR5   =   3077,
    CV_IA64_ApKR6   =   3078,
    CV_IA64_ApKR7   =   3079,
    CV_IA64_AR8     =   3080,
    CV_IA64_AR9     =   3081,
    CV_IA64_AR10    =   3082,
    CV_IA64_AR11    =   3083,
    CV_IA64_AR12    =   3084,
    CV_IA64_AR13    =   3085,
    CV_IA64_AR14    =   3086,
    CV_IA64_AR15    =   3087,
    CV_IA64_RsRSC   =   3088,
    CV_IA64_RsBSP   =   3089,
    CV_IA64_RsBSPSTORE  =   3090,
    CV_IA64_RsRNAT  =   3091,
    CV_IA64_AR20    =   3092,
    CV_IA64_StFCR   =   3093,
    CV_IA64_AR22    =   3094,
    CV_IA64_AR23    =   3095,
    CV_IA64_EFLAG   =   3096,
    CV_IA64_CSD     =   3097,
    CV_IA64_SSD     =   3098,
    CV_IA64_CFLG    =   3099,
    CV_IA64_StFSR   =   3100,
    CV_IA64_StFIR   =   3101,
    CV_IA64_StFDR   =   3102,
    CV_IA64_AR31    =   3103,
    CV_IA64_ApCCV   =   3104,
    CV_IA64_AR33    =   3105,
    CV_IA64_AR34    =   3106,
    CV_IA64_AR35    =   3107,
    CV_IA64_ApUNAT  =   3108,
    CV_IA64_AR37    =   3109,
    CV_IA64_AR38    =   3110,
    CV_IA64_AR39    =   3111,
    CV_IA64_StFPSR  =   3112,
    CV_IA64_AR41    =   3113,
    CV_IA64_AR42    =   3114,
    CV_IA64_AR43    =   3115,
    CV_IA64_ApITC   =   3116,
    CV_IA64_AR45    =   3117,
    CV_IA64_AR46    =   3118,
    CV_IA64_AR47    =   3119,
    CV_IA64_AR48    =   3120,
    CV_IA64_AR49    =   3121,
    CV_IA64_AR50    =   3122,
    CV_IA64_AR51    =   3123,
    CV_IA64_AR52    =   3124,
    CV_IA64_AR53    =   3125,
    CV_IA64_AR54    =   3126,
    CV_IA64_AR55    =   3127,
    CV_IA64_AR56    =   3128,
    CV_IA64_AR57    =   3129,
    CV_IA64_AR58    =   3130,
    CV_IA64_AR59    =   3131,
    CV_IA64_AR60    =   3132,
    CV_IA64_AR61    =   3133,
    CV_IA64_AR62    =   3134,
    CV_IA64_AR63    =   3135,
    CV_IA64_RsPFS   =   3136,
    CV_IA64_ApLC    =   3137,
    CV_IA64_ApEC    =   3138,
    CV_IA64_AR67    =   3139,
    CV_IA64_AR68    =   3140,
    CV_IA64_AR69    =   3141,
    CV_IA64_AR70    =   3142,
    CV_IA64_AR71    =   3143,
    CV_IA64_AR72    =   3144,
    CV_IA64_AR73    =   3145,
    CV_IA64_AR74    =   3146,
    CV_IA64_AR75    =   3147,
    CV_IA64_AR76    =   3148,
    CV_IA64_AR77    =   3149,
    CV_IA64_AR78    =   3150,
    CV_IA64_AR79    =   3151,
    CV_IA64_AR80    =   3152,
    CV_IA64_AR81    =   3153,
    CV_IA64_AR82    =   3154,
    CV_IA64_AR83    =   3155,
    CV_IA64_AR84    =   3156,
    CV_IA64_AR85    =   3157,
    CV_IA64_AR86    =   3158,
    CV_IA64_AR87    =   3159,
    CV_IA64_AR88    =   3160,
    CV_IA64_AR89    =   3161,
    CV_IA64_AR90    =   3162,
    CV_IA64_AR91    =   3163,
    CV_IA64_AR92    =   3164,
    CV_IA64_AR93    =   3165,
    CV_IA64_AR94    =   3166,
    CV_IA64_AR95    =   3167,
    CV_IA64_AR96    =   3168,
    CV_IA64_AR97    =   3169,
    CV_IA64_AR98    =   3170,
    CV_IA64_AR99    =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // CPUID Registers

    CV_IA64_CPUID0  =   3328,
    CV_IA64_CPUID1  =   3329,
    CV_IA64_CPUID2  =   3330,
    CV_IA64_CPUID3  =   3331,
    CV_IA64_CPUID4  =   3332,
    
    // Control Registers

    CV_IA64_ApDCR   =   4096,
    CV_IA64_ApITM   =   4097,
    CV_IA64_ApIVA   =   4098,
    CV_IA64_CR3     =   4099,
    CV_IA64_CR4     =   4100,
    CV_IA64_CR5     =   4101,
    CV_IA64_CR6     =   4102,
    CV_IA64_CR7     =   4103,
    CV_IA64_ApPTA   =   4104,
    CV_IA64_ApGPTA  =   4105,
    CV_IA64_CR10    =   4106,
    CV_IA64_CR11    =   4107,
    CV_IA64_CR12    =   4108,
    CV_IA64_CR13    =   4109,
    CV_IA64_CR14    =   4110,
    CV_IA64_CR15    =   4111,
    CV_IA64_StIPSR  =   4112,
    CV_IA64_StISR   =   4113,
    CV_IA64_CR18    =   4114,
    CV_IA64_StIIP   =   4115,
    CV_IA64_StIFA   =   4116,
    CV_IA64_StITIR  =   4117,
    CV_IA64_StIIPA  =   4118,
    CV_IA64_StIFS   =   4119,
    CV_IA64_StIIM   =   4120,
    CV_IA64_StIHA   =   4121,
    CV_IA64_CR26    =   4122,
    CV_IA64_CR27    =   4123,
    CV_IA64_CR28    =   4124,
    CV_IA64_CR29    =   4125,
    CV_IA64_CR30    =   4126,
    CV_IA64_CR31    =   4127,
    CV_IA64_CR32    =   4128,
    CV_IA64_CR33    =   4129,
    CV_IA64_CR34    =   4130,
    CV_IA64_CR35    =   4131,
    CV_IA64_CR36    =   4132,
    CV_IA64_CR37    =   4133,
    CV_IA64_CR38    =   4134,
    CV_IA64_CR39    =   4135,
    CV_IA64_CR40    =   4136,
    CV_IA64_CR41    =   4137,
    CV_IA64_CR42    =   4138,
    CV_IA64_CR43    =   4139,
    CV_IA64_CR44    =   4140,
    CV_IA64_CR45    =   4141,
    CV_IA64_CR46    =   4142,
    CV_IA64_CR47    =   4143,
    CV_IA64_CR48    =   4144,
    CV_IA64_CR49    =   4145,
    CV_IA64_CR50    =   4146,
    CV_IA64_CR51    =   4147,
    CV_IA64_CR52    =   4148,
    CV_IA64_CR53    =   4149,
    CV_IA64_CR54    =   4150,
    CV_IA64_CR55    =   4151,
    CV_IA64_CR56    =   4152,
    CV_IA64_CR57    =   4153,
    CV_IA64_CR58    =   4154,
    CV_IA64_CR59    =   4155,
    CV_IA64_CR60    =   4156,
    CV_IA64_CR61    =   4157,
    CV_IA64_CR62    =   4158,
    CV_IA64_CR63    =   4159,
    CV_IA64_SaLID   =   4160,
    CV_IA64_SaIVR   =   4161,
    CV_IA64_SaTPR   =   4162,
    CV_IA64_SaEOI   =   4163,
    CV_IA64_SaIRR0  =   4164,
    CV_IA64_SaIRR1  =   4165,
    CV_IA64_SaIRR2  =   4166,
    CV_IA64_SaIRR3  =   4167,
    CV_IA64_SaITV   =   4168,
    CV_IA64_SaPMV   =   4169,
    CV_IA64_SaCMCV  =   4170,
    CV_IA64_CR75    =   4171,
    CV_IA64_CR76    =   4172,
    CV_IA64_CR77    =   4173,
    CV_IA64_CR78    =   4174,
    CV_IA64_CR79    =   4175,
    CV_IA64_SaLRR0  =   4176,
    CV_IA64_SaLRR1  =   4177,
    CV_IA64_CR82    =   4178,
    CV_IA64_CR83    =   4179,
    CV_IA64_CR84    =   4180,
    CV_IA64_CR85    =   4181,
    CV_IA64_CR86    =   4182,
    CV_IA64_CR87    =   4183,
    CV_IA64_CR88    =   4184,
    CV_IA64_CR89    =   4185,
    CV_IA64_CR90    =   4186,
    CV_IA64_CR91    =   4187,
    CV_IA64_CR92    =   4188,
    CV_IA64_CR93    =   4189,
    CV_IA64_CR94    =   4190,
    CV_IA64_CR95    =   4191,
    CV_IA64_CR96    =   4192,
    CV_IA64_CR97    =   4193,
    CV_IA64_CR98    =   4194,
    CV_IA64_CR99    =   4195,
    CV_IA64_CR100   =   4196,
    CV_IA64_CR101   =   4197,
    CV_IA64_CR102   =   4198,
    CV_IA64_CR103   =   4199,
    CV_IA64_CR104   =   4200,
    CV_IA64_CR105   =   4201,
    CV_IA64_CR106   =   4202,
    CV_IA64_CR107   =   4203,
    CV_IA64_CR108   =   4204,
    CV_IA64_CR109   =   4205,
    CV_IA64_CR110   =   4206,
    CV_IA64_CR111   =   4207,
    CV_IA64_CR112   =   4208,
    CV_IA64_CR113   =   4209,
    CV_IA64_CR114   =   4210,
    CV_IA64_CR115   =   4211,
    CV_IA64_CR116   =   4212,
    CV_IA64_CR117   =   4213,
    CV_IA64_CR118   =   4214,
    CV_IA64_CR119   =   4215,
    CV_IA64_CR120   =   4216,
    CV_IA64_CR121   =   4217,
    CV_IA64_CR122   =   4218,
    CV_IA64_CR123   =   4219,
    CV_IA64_CR124   =   4220,
    CV_IA64_CR125   =   4221,
    CV_IA64_CR126   =   4222,
    CV_IA64_CR127   =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0    =   5120,
    CV_IA64_Pkr1    =   5121,
    CV_IA64_Pkr2    =   5122,
    CV_IA64_Pkr3    =   5123,
    CV_IA64_Pkr4    =   5124,
    CV_IA64_Pkr5    =   5125,
    CV_IA64_Pkr6    =   5126,
    CV_IA64_Pkr7    =   5127,
    CV_IA64_Pkr8    =   5128,
    CV_IA64_Pkr9    =   5129,
    CV_IA64_Pkr10   =   5130,
    CV_IA64_Pkr11   =   5131,
    CV_IA64_Pkr12   =   5132,
    CV_IA64_Pkr13   =   5133,
    CV_IA64_Pkr14   =   5134,
    CV_IA64_Pkr15   =   5135,

    // Region Registers

    CV_IA64_Rr0     =   6144,
    CV_IA64_Rr1     =   6145,
    CV_IA64_Rr2     =   6146,
    CV_IA64_Rr3     =   6147,
    CV_IA64_Rr4     =   6148,
    CV_IA64_Rr5     =   6149,
    CV_IA64_Rr6     =   6150,
    CV_IA64_Rr7     =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0    =   7168,
    CV_IA64_PFD1    =   7169,
    CV_IA64_PFD2    =   7170,
    CV_IA64_PFD3    =   7171,
    CV_IA64_PFD4    =   7172,
    CV_IA64_PFD5    =   7173,
    CV_IA64_PFD6    =   7174,
    CV_IA64_PFD7    =   7175,

    // Performance Monitor Config Registers

    CV_IA64_PFC0    =   7424,
    CV_IA64_PFC1    =   7425,
    CV_IA64_PFC2    =   7426,
    CV_IA64_PFC3    =   7427,
    CV_IA64_PFC4    =   7428,
    CV_IA64_PFC5    =   7429,
    CV_IA64_PFC6    =   7430,
    CV_IA64_PFC7    =   7431,

    // Instruction Translation Registers

    CV_IA64_TrI0    =   8192,
    CV_IA64_TrI1    =   8193,
    CV_IA64_TrI2    =   8194,
    CV_IA64_TrI3    =   8195,
    CV_IA64_TrI4    =   8196,
    CV_IA64_TrI5    =   8197,
    CV_IA64_TrI6    =   8198,
    CV_IA64_TrI7    =   8199,

    // Data Translation Registers

    CV_IA64_TrD0    =   8320,
    CV_IA64_TrD1    =   8321,
    CV_IA64_TrD2    =   8322,
    CV_IA64_TrD3    =   8323,
    CV_IA64_TrD4    =   8324,
    CV_IA64_TrD5    =   8325,
    CV_IA64_TrD6    =   8326,
    CV_IA64_TrD7    =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0    =   8448,
    CV_IA64_DbI1    =   8449,
    CV_IA64_DbI2    =   8450,
    CV_IA64_DbI3    =   8451,
    CV_IA64_DbI4    =   8452,
    CV_IA64_DbI5    =   8453,
    CV_IA64_DbI6    =   8454,
    CV_IA64_DbI7    =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0    =   8576,
    CV_IA64_DbD1    =   8577,
    CV_IA64_DbD2    =   8578,
    CV_IA64_DbD3    =   8579,
    CV_IA64_DbD4    =   8580,
    CV_IA64_DbD5    =   8581,
    CV_IA64_DbD6    =   8582,
    CV_IA64_DbD7    =   8583,

    //
    // Register set for the TriCore processor.
    //

    CV_TRI_NOREG    =   CV_REG_NONE,

    // General Purpose Data Registers

    CV_TRI_D0   =   10,
    CV_TRI_D1   =   11,
    CV_TRI_D2   =   12,
    CV_TRI_D3   =   13,
    CV_TRI_D4   =   14,
    CV_TRI_D5   =   15,
    CV_TRI_D6   =   16,
    CV_TRI_D7   =   17,
    CV_TRI_D8   =   18,
    CV_TRI_D9   =   19,
    CV_TRI_D10  =   20,
    CV_TRI_D11  =   21,
    CV_TRI_D12  =   22,
    CV_TRI_D13  =   23,
    CV_TRI_D14  =   24,
    CV_TRI_D15  =   25,

    // General Purpose Address Registers

    CV_TRI_A0   =   26,
    CV_TRI_A1   =   27,
    CV_TRI_A2   =   28,
    CV_TRI_A3   =   29,
    CV_TRI_A4   =   30,
    CV_TRI_A5   =   31,
    CV_TRI_A6   =   32,
    CV_TRI_A7   =   33,
    CV_TRI_A8   =   34,
    CV_TRI_A9   =   35,
    CV_TRI_A10  =   36,
    CV_TRI_A11  =   37,
    CV_TRI_A12  =   38,
    CV_TRI_A13  =   39,
    CV_TRI_A14  =   40,
    CV_TRI_A15  =   41,

    // Extended (64-bit) data registers

    CV_TRI_E0   =   42,
    CV_TRI_E2   =   43,
    CV_TRI_E4   =   44,
    CV_TRI_E6   =   45,
    CV_TRI_E8   =   46,
    CV_TRI_E10  =   47,
    CV_TRI_E12  =   48,
    CV_TRI_E14  =   49,

    // Extended (64-bit) address registers

    CV_TRI_EA0  =   50,
    CV_TRI_EA2  =   51,
    CV_TRI_EA4  =   52,
    CV_TRI_EA6  =   53,
    CV_TRI_EA8  =   54,
    CV_TRI_EA10 =   55,
    CV_TRI_EA12 =   56,
    CV_TRI_EA14 =   57,
    
    CV_TRI_PSW  =   58,
    CV_TRI_PCXI =   59,
    CV_TRI_PC   =   60,
    CV_TRI_FCX  =   61,
    CV_TRI_LCX  =   62,
    CV_TRI_ISP  =   63,
    CV_TRI_ICR  =   64,
    CV_TRI_BIV  =   65,
    CV_TRI_BTV  =   66,
    CV_TRI_SYSCON   =   67,
    CV_TRI_DPRx_0   =   68,
    CV_TRI_DPRx_1   =   69,
    CV_TRI_DPRx_2   =   70,
    CV_TRI_DPRx_3   =   71,
    CV_TRI_CPRx_0   =   68,
    CV_TRI_CPRx_1   =   69,
    CV_TRI_CPRx_2   =   70,
    CV_TRI_CPRx_3   =   71,
    CV_TRI_DPMx_0   =   68,
    CV_TRI_DPMx_1   =   69,
    CV_TRI_DPMx_2   =   70,
    CV_TRI_DPMx_3   =   71,
    CV_TRI_CPMx_0   =   68,
    CV_TRI_CPMx_1   =   69,
    CV_TRI_CPMx_2   =   70,
    CV_TRI_CPMx_3   =   71,
    CV_TRI_DBGSSR   =   72,
    CV_TRI_EXEVT    =   73,
    CV_TRI_SWEVT    =   74,
    CV_TRI_CREVT    =   75,
    CV_TRI_TRnEVT   =   76,
    CV_TRI_MMUCON   =   77,
    CV_TRI_ASI      =   78,
    CV_TRI_TVA      =   79,
    CV_TRI_TPA      =   80,
    CV_TRI_TPX      =   81,
    CV_TRI_TFA      =   82,

    //
    // Register set for the AM33 and related processors.
    //

    CV_AM33_NOREG   =   CV_REG_NONE,

    // "Extended" (general purpose integer) registers
    CV_AM33_E0      =   10,
    CV_AM33_E1      =   11,
    CV_AM33_E2      =   12,
    CV_AM33_E3      =   13,
    CV_AM33_E4      =   14,
    CV_AM33_E5      =   15,
    CV_AM33_E6      =   16,
    CV_AM33_E7      =   17,

    // Address registers
    CV_AM33_A0      =   20,
    CV_AM33_A1      =   21,
    CV_AM33_A2      =   22,
    CV_AM33_A3      =   23,

    // Integer data registers
    CV_AM33_D0      =   30,
    CV_AM33_D1      =   31,
    CV_AM33_D2      =   32,
    CV_AM33_D3      =   33,

    // (Single-precision) floating-point registers
    CV_AM33_FS0     =   40,
    CV_AM33_FS1     =   41,
    CV_AM33_FS2     =   42,
    CV_AM33_FS3     =   43,
    CV_AM33_FS4     =   44,
    CV_AM33_FS5     =   45,
    CV_AM33_FS6     =   46,
    CV_AM33_FS7     =   47,
    CV_AM33_FS8     =   48,
    CV_AM33_FS9     =   49,
    CV_AM33_FS10    =   50,
    CV_AM33_FS11    =   51,
    CV_AM33_FS12    =   52,
    CV_AM33_FS13    =   53,
    CV_AM33_FS14    =   54,
    CV_AM33_FS15    =   55,
    CV_AM33_FS16    =   56,
    CV_AM33_FS17    =   57,
    CV_AM33_FS18    =   58,
    CV_AM33_FS19    =   59,
    CV_AM33_FS20    =   60,
    CV_AM33_FS21    =   61,
    CV_AM33_FS22    =   62,
    CV_AM33_FS23    =   63,
    CV_AM33_FS24    =   64,
    CV_AM33_FS25    =   65,
    CV_AM33_FS26    =   66,
    CV_AM33_FS27    =   67,
    CV_AM33_FS28    =   68,
    CV_AM33_FS29    =   69,
    CV_AM33_FS30    =   70,
    CV_AM33_FS31    =   71,

    // Special purpose registers

    // Stack pointer
    CV_AM33_SP      =   80,

    // Program counter
    CV_AM33_PC      =   81,

    // Multiply-divide/accumulate registers
    CV_AM33_MDR     =   82,
    CV_AM33_MDRQ    =   83,
    CV_AM33_MCRH    =   84,
    CV_AM33_MCRL    =   85,
    CV_AM33_MCVF    =   86,

    // CPU status words
    CV_AM33_EPSW    =   87,
    CV_AM33_FPCR    =   88,

    // Loop buffer registers
    CV_AM33_LIR     =   89,
    CV_AM33_LAR     =   90,

    //
    // Register set for the Mitsubishi M32R
    //

    CV_M32R_NOREG    =   CV_REG_NONE,

    CV_M32R_R0    =   10,
    CV_M32R_R1    =   11,
    CV_M32R_R2    =   12,
    CV_M32R_R3    =   13,
    CV_M32R_R4    =   14,
    CV_M32R_R5    =   15,
    CV_M32R_R6    =   16,
    CV_M32R_R7    =   17,
    CV_M32R_R8    =   18,
    CV_M32R_R9    =   19,
    CV_M32R_R10   =   20,
    CV_M32R_R11   =   21,
    CV_M32R_R12   =   22,   // Gloabal Pointer, if used
    CV_M32R_R13   =   23,   // Frame Pointer, if allocated
    CV_M32R_R14   =   24,   // Link Register
    CV_M32R_R15   =   25,   // Stack Pointer    
    CV_M32R_PSW   =   26,   // Preocessor Status Register
    CV_M32R_CBR   =   27,   // Condition Bit Register
    CV_M32R_SPI   =   28,   // Interrupt Stack Pointer
    CV_M32R_SPU   =   29,   // User Stack Pointer
    CV_M32R_SPO   =   30,   // OS Stack Pointer
    CV_M32R_BPC   =   31,   // Backup Program Counter
    CV_M32R_ACHI  =   32,   // Accumulator High
    CV_M32R_ACLO  =   33,   // Accumulator Low
    CV_M32R_PC    =   34,   // Program Counter

} CV_HREG_e;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\chksum\makefile.inc ===
$(O)\chkverfy.res: chkverfy.rc
$(O)\chksum.res: chksum.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\chksum\chkverfy.c ===
// Analyses the output from the new chkeckrel
// t-mhills

#include <direct.h>
#include <io.h>
#include <ctype.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define F_flag 1   //Values to store in the command line switches flag
#define I1_flag 2
#define I2_flag 4
#define X_flag 8

               // These codes should match the codes below in the usage description
#define par_err 6  //comand line parameter error exit code 5
#define exep_err 5 //error in the exception file
#define chk_err 4  //error in the one of the source files
#define mem_err 3  //memory allocation error
#define file_err 2 //file find/read error
#define comp_err 1 //comparison found differences
#define no_err 0   // files compared okay

#define exceptionfilelinelength 512  //These value used to control the size of temporary strings
#define chkfilelinelength 2048       //Ideally there would be no limit but file reads require static variables
#define maxpathlength 200

struct translatetable  //Used to store translate commands from the exception file.
{
  struct translatetable *next;
  char *source1name;
  char *source2name;
};

struct excludetable   //Used to store exclude commands from the exception file.
{
  struct excludetable *next;
  char *path;
};

struct checksums      //Used to store checksums with file names.
{
  struct checksums *next;
  long sum;
  char filename; // This structure is of variable length to accomodate any string length.
};

void error (char exitcode);                               //Ends program and returns exitcode to the system.

void showchecksumlist (struct checksums *list);           //Displays Checksums with filenames.

void showdualchecksumlist (struct checksums *list);       //Shows checksums in a format good for missmatched checksums.

char excluded (char *str, struct excludetable *ex);       //If any of the exclude strings are in str it returns true.

char *translate (char *str, struct translatetable *tran); //Make a copy of str with changes from exception file.

long readhex (char *str);                                 //Convert hex string to long.

char proccessline (char *tempstr, struct translatetable *translations, struct excludetable *exclusions,
                  char *startpath, char flags, char **filename, long *filesum);
                                                          //Parse line and apply all exceptions and flags

char loadsource1 (char *filename, struct checksums **sums,
                  struct translatetable *translations, struct excludetable * exclusions,
                  char *startpath, char flags);           //Load source1 into a checksum list.

char comparesource2 (char *filename, struct checksums **sums,
                     struct checksums **extrasource2, struct checksums **missmatched,
                     struct translatetable *translations, struct excludetable * exclusions,
                     char *startpath, char flags);        //Compare the second file to the checksum list.

void removewhitespace (char *str);                        //Removes whitespace from the end of a string.

char *strstrupcase (char *str1, char *str2);              //Case insensitive strstr.

char proccess_exception_file (char *filename, struct translatetable **trans, struct excludetable **exclude, char **path);
                                                          //Parse exception file.

char proccess_command_line (int argc, char *argv[ ], char **source1, char **source2, char *flags, char **exception);
                                                          //Parse command line arguments

void completehelp ();                                     //Show nearly complete documentation


// ******************************** MAIN ***************************
void __cdecl
main(
    int argc,
    char *argv[ ]
    )
{
  char errnum = 0;
  char *source1filename = NULL;
  char *source2filename = NULL;
  char *exceptionfilename = NULL;
  char flags;  // flags: /F=1=(F_flag); /I1=2=(I1_flag); /I2=4=(I2_flag); /X=8=(X_flag)

  struct translatetable *translations = NULL; //
  struct excludetable *exclusions = NULL;     //Information from exception file stored here.
  char *startpath = NULL;                     //

  struct checksums *source1checksums = NULL;  //List of extra files in Source1
  struct checksums *source2checksums = NULL;  //List of extra files in Source2
  struct checksums *missmatched = NULL;       //List of files with chechsums that don't match.

  struct translatetable *temp = NULL;         //
  struct checksums *temp2 = NULL;             //Temporary pointers used to help deallocate memory

  //Parse command line.
  if (errnum = proccess_command_line (argc, argv, &source1filename, &source2filename, &flags, &exceptionfilename))
  {
    goto freecommandline;  // skip to end and deallocate memory
  }

  //Show information obtained from command line.
  printf ("Source1 = %s\n", source1filename);
  printf ("Source2 = %s\n", source2filename);
  if (flags & F_flag)
    printf ("Comparing flat Share.\n");
  if (flags & I1_flag)
    printf ("Ignoring extra files in Source1.\n");
  if (flags & I2_flag)
    printf ("Ignoring extra files in Source2.\n");
  if (flags & X_flag)
    printf ("Exception file = %s\n", exceptionfilename);

  //Parse the excpetion file if it exists.
  if (flags & X_flag)
  {
    if (errnum = proccess_exception_file (exceptionfilename, &translations, &exclusions, &startpath))
    {
      goto freeexceptiontable; //skip to end and dealocate memory
    };

    //Display information from exception file.
    temp = translations;
    while (temp != NULL)
    {
      printf ("TRANSLATE %s --> %s\n", temp->source1name, temp->source2name);
      temp = temp->next;
    };
    temp = (struct translatetable *) exclusions;  //note: using wrong type to avoid making another temp pointer
    while (temp != NULL)
    {
      printf ("EXCLUDE %s\n", temp->source1name);
      temp = temp->next;
    };
    if (startpath != NULL)
      printf ("STARTPATH %s\n", startpath);
  };

  //Read source1 and store files and checksums in source1checksums.
  if (errnum = loadsource1 (source1filename, &source1checksums, translations, exclusions, startpath, flags))
  {
    goto freesource1checksums;
  };

  //printf ("\n\nSource1:\n\n");  //for debugging
  //showchecksumlist (source1checksums);

  //Read source2 and compare it to the files/checksums from source1.  Store differences.
  if (errnum = comparesource2 (source2filename, &source1checksums, &source2checksums, &missmatched,
                               translations, exclusions, startpath, flags))
  {
    goto freesource2checksums;
  };

  //Display extra files unless /I1 or /I2 was used in the command line.
  if ((!(flags & I1_flag)) & (source1checksums != NULL))
  {
    errnum = 1;
    printf ("\n********** Extra files in %s **********\n", source1filename);
    showchecksumlist (source1checksums);
  };
  if ((!(flags & I2_flag)) & (source2checksums != NULL))
  {
    errnum = 1;
    printf ("\n********** Extra files in %s **********\n", source2filename);
    showchecksumlist (source2checksums);
  };

  //Display missmatched checksums.
  if (missmatched != NULL)
  {
    errnum = 1;
    printf ("\n********** Checksums from %s != checksums from %s.**********\n", source1filename, source2filename);
    showdualchecksumlist (missmatched);
  };

  //Deallocate memory.
freesource2checksums:
  while (source2checksums != NULL)
  {
    temp2 = source2checksums;
    source2checksums = source2checksums->next;
    free (temp2);
  };
  while (missmatched != NULL)
  {
    temp2 = missmatched;
    missmatched = missmatched->next;
    free (temp2);
  };
freesource1checksums:
  while (source1checksums != NULL)
  {
    temp2 = source1checksums;
    source1checksums = source1checksums->next;
    free (temp2);
  };
freeexceptiontable:
  if (startpath != NULL)
    free (startpath);
  while (translations != NULL)
  {
    if (translations->source1name != NULL)
      free (translations->source1name);
    if (translations->source2name != NULL)
      free (translations->source2name);
    temp = translations;
    translations = translations->next;
    free (temp);
  };
  while (exclusions != NULL)
  {
    if (exclusions->path != NULL)
      free (exclusions->path);
    temp = (struct translatetable *) exclusions;
    exclusions = exclusions->next;
    free (temp);
  };

freecommandline:
  if (source1filename != NULL)
    free (source1filename);
  if (source2filename != NULL)
    free (source2filename);
  if (exceptionfilename != NULL)
    free (exceptionfilename);

  //End program and show help if needed.
  error (errnum);
};


void showchecksumlist (struct checksums *list)
{
  while (list != NULL)
  {
    printf ("%d  %s\n", list->sum, &(list->filename));
    list = list->next;
  };
};

void showdualchecksumlist (struct checksums *list)
//This can only be used with the missmatched checksums list since it assumes that the files
//come in pairs of identical filenames with different checksums.
{
  while (list != NULL)
  {
    if (list->next == NULL)
    {
      printf ("Error: list corruption detected in showdualchecksumlist function.\n");
      return;
    };
    printf ("%d != %d %s\n", list->sum, list->next->sum, &(list->filename));
    list = list->next->next;
  };
};

char excluded (char *str, struct excludetable *ex)   //If any of the exclude strings are in str it returns true.
{
  while (ex != NULL)
  {
    if (strstr (str, ex->path))
      return (1);
    ex = ex->next;
  }
  return (0);
};

char *translate (char *str, struct translatetable *tran)
{
  char *temp;
  char *newstr;

  while (tran != NULL)    //Search translate table.
  {
    if ((temp = strstr (str, tran->source1name)) != NULL)  //If we found one that needs translating
    {
      //Allocate memory for new string.
      if ((newstr = malloc (strlen (str) + strlen (tran->source2name) - strlen(tran->source1name) + 1))==NULL)
        return (NULL);
      strncpy(newstr, str, (size_t)(temp - str));            //Write part before translations.
      strcpy (&newstr [temp-str], tran->source2name);        //Add translated part
      strcat (newstr, &temp [strlen (tran->source1name)]);   //Add end of string
      return (newstr);
    };
    tran = tran->next;
  };
  return (_strdup (str)); //If didn't need to be translated, make a new copy anyway for uniformity.
};

long readhex (char *str)
{
  long temp = 0;
  int position = 0;
  for (position = 0; 1;position++)
  {
    if ((str[position] == ' ')|(str[position] == '\n')|(str[position] == '\x00'))
    {
      return (temp);
    }
    else
    {
      temp *= 16;
      if ((str [position] >= '0') & (str [position] <= '9'))
      {
        temp+=(str[position]-'0');
      }
      else if ((str [position] >= 'a') & (str [position] <= 'f'))
      {
        temp+=(str[position]-'a'+10);
      }
      else
        return (-1);
    };
  };
};

char proccessline (char *tempstr, struct translatetable *translations, struct excludetable *exclusions,
                  char *startpath, char flags, char **filename, long *filesum)
{
  char *name;
  char *newname;
  char *sumstr;

  *filename = NULL;                             //Make sure that if no name is returned this is blank
  removewhitespace (tempstr);

  //If it is a line that says "-  N0 files" then the sum is assigned to 0
  if ((sumstr = strstr (tempstr, "  -  No files")) != NULL)
  {
    *filesum=0;
    sumstr [0]=0;
  }
  //Otherwise find checksum
  else
  {
    sumstr = tempstr + strlen (tempstr);            //Find checksum by finding the last space in the line
    while ((sumstr [0] != ' ')&(sumstr != tempstr)) //
      sumstr--;                                     //
    if (sumstr==tempstr)                            //
    {
      printf ("Comment: %s", tempstr);            //If there is no space before the first character,
      return (chk_err);                           //the line is invalid.  Assume it is a comment.
    };
    sumstr [0] = 0;                               //Split string into path/filename and checksum
    sumstr++;                                     //

    //convert checksum string to a number
    if ((*filesum = readhex (sumstr))==-1)
    {
      printf ("Comment: %s %s\n", tempstr, sumstr); //If the checksum isn't a valid hex number
      return (chk_err);                             //assume the line is a commment.
    };
  };

  //Apply any translations that may be valid for this path/file.
  if ((name = translate (tempstr, translations)) == NULL)
  {
    printf ("Need memory.");
    return (mem_err);
  };

  //Make sure this file isn't excluded.
  if (!excluded (name, exclusions))
  {
    //If there isn't a startpath then all files will be proccessed
    //If there is a startpath then only the ones containing the path will be proccessed
    if (startpath == NULL)
    {
      newname = name;
      goto instartpath;
    }
    else if ((newname = strstr (name, startpath)) != NULL) //If this file is in startpath
    {
      newname = newname + strlen (startpath);     //Remove startpath

    instartpath:                   //This happens if one of the above conditions was true

      //Remove path if doing a flat compare.
      if (flags & F_flag)
      {
        while (strstr (newname, "\\") != NULL)    // Remove path
        {                                         //
          newname = strstr (newname, "\\");       //
          newname++;                              // and leading "\\"
        };
      };

      //Make a final copy of the path/file to return
      if ((*filename = _strdup (newname)) == NULL)
      {
        printf ("Memory err.");
        free (name);
        return (mem_err);
      };
    };
  };
  free (name);
  return (0);
};

char loadsource1 (char *filename, struct checksums **sums,
                  struct translatetable *translations, struct excludetable * exclusions,
                  char *startpath, char flags)
{
  FILE *chkfile;
  char tempstr [chkfilelinelength];
  char *name;
  char err;
  long tempsum;
  struct checksums *newsum;
  struct checksums **last;  //Used to keep trak of the end of the linked list.
  last = sums;

  if ((chkfile = fopen (filename, "r"))==NULL)
  {
    printf ("Error opening source1.\n\n");
    return (file_err);
  };

  //Proccess all lines
  while (fgets (tempstr, chkfilelinelength, chkfile) != NULL)
  {
    //Verify that the entire line was read in and not just part of it
    if (tempstr [strlen (tempstr)-1] != '\n')
    {
      printf ("Unexpected end of line.  chkfilelinelength may need to be larger.\n  %s\n", tempstr);
      fclose (chkfile);
      return (chk_err);
    };

    //Parse line
    if ((err = proccessline (tempstr, translations, exclusions, startpath, flags, &name, &tempsum)) == 0)
    {
      //If this line was excluded or not in the path don't do anything, just go on to the next line.
      if (name != NULL)
      {
        //Create a new structure and add it to the end of the linked list.
        if ((newsum = malloc (sizeof (struct checksums) + strlen (name))) == NULL)
        {                    //Note: this is a variable length structure to fit any size of string.
          printf ("Memory err.");
          fclose (chkfile);
          return (mem_err);
        };
        *last = newsum;
        newsum->next = NULL;
        newsum->sum = tempsum;
        strcpy(&(newsum->filename), name);
        last = &((*last)->next);

        //Free temporary storage.
        free (name);
      };
    }
    else
    {
      if (err != chk_err)  //Just skip line if it isn't understandable.
      {
        fclose (chkfile);
        return (err);
      };
    };
  };

  //Ckeck to make sure it quit because it was done and not because of file errors.
  if (ferror (chkfile))
  {
    printf ("Error reading source1.\n\n");
    return (file_err);
  };
  if (fclose (chkfile))
  {
    printf ("Error closing source1.\n\nContinuing anyway...");
  };
  return (0);
};

char notnull_strcmp (struct checksums *sum, char *str)
// perform short circuit evaluation of ((sum != NULL) & (strcmp (&(sum->filename), str) != 0)
{
  if (sum != NULL)
  {
    if (strcmp (&(sum->filename), str) != 0)
    {
      return (1);
    };
  };
  return (0);
};

char comparesource2 (char *filename, struct checksums **sums,
                     struct checksums **extrasource2, struct checksums **missmatched,
                     struct translatetable *translations, struct excludetable * exclusions,
                     char *startpath, char flags)
{
  FILE *chkfile;
  char tempstr [chkfilelinelength];
  char *name;
  char err;
  long tempsum;
  struct checksums *newsum;
  struct checksums *search;
  struct checksums **lastlink;

  if ((chkfile = fopen (filename, "r"))==NULL)
  {
    printf ("Error opening source2.\n\n");
    return (file_err);
  };
  while (fgets (tempstr, chkfilelinelength, chkfile) != NULL)
  {
    //Verify that the entire line was read.
    if (tempstr [strlen (tempstr)-1] != '\n')
    {
      printf ("Unexpected end of line.  chkfilelinelength may need to be larger.\n  %s\n", tempstr);
      fclose (chkfile);
      return (chk_err);
    };

    //Parse line
    if ((err = proccessline (tempstr, NULL, exclusions, startpath, flags, &name, &tempsum)) == 0)
    {
      //If file was skipped do nothing
      if (name != NULL)
      {
        //Prepare to look for a match
        search = *sums;
        lastlink = sums;
        //short circuit evaluation of:(search != NULL) & (strcmp (&(search->filename), name) != 0)
        while (notnull_strcmp (search, name))
        {
          search = search->next;
          lastlink = &((*lastlink)->next);
        };

        if (search != NULL)               //If a match was found
        {                                 // remove it from the sums list
          *lastlink = search->next;       // by linking around it
          if (search->sum == tempsum)     // If checksums match
          {                               //
            search->sum=0;
            free (search);                //  Deallocate memory
          }                               //
          else                            // If the checksums didn't match
          {                               //
            if ((newsum = malloc (sizeof (struct checksums) + strlen (name))) == NULL)
            {                             //  Add 2nd name and checksum to missmatched list
              printf ("Memory err.");     //
              fclose (chkfile);           //
              return (mem_err);           //
            };                            //
            newsum->next = *missmatched;  //
            newsum->sum = tempsum;        //
            strcpy(&(newsum->filename), name);
            *missmatched = newsum;        //
            search->next = *missmatched;  //  Add 1st name to the missmatched list
            *missmatched = search;        //
          };                              //
        }                                 //
        else                              //If no match was found
        {                                 // this needs to be added to extrasource2 list
          if ((newsum = malloc (sizeof (struct checksums) + strlen (name))) == NULL)
          {                  //Note: this is a variable length structure to fit any size of string.
            printf ("Memory err.");
            fclose (chkfile);
            return (mem_err);
          };
          newsum->next = *extrasource2;
          newsum->sum = tempsum;
          strcpy(&(newsum->filename), name);
          *extrasource2 = newsum;
        };

        //free temporary storage
        free (name);
      };
    }
    else
    {
      if (err != chk_err)   //Just skip the line (don't abort) if it is bad
      {
        fclose (chkfile);
        return (err);
      };
    };
  };
  if (ferror (chkfile))
  {
    printf ("Error reading source2.\n\n");
    return (file_err);
  };
  if (fclose (chkfile))
  {
    printf ("Error closing source2.\n\nContinuing anyway...");
  };
  return (0);
};

void removewhitespace (char *str)  // removes whitespace from the end of a string
{
  int end;
  end = strlen (str);
  while ((end > 0)&((str [end-1] == '\n')|(str [end-1] == ' ')))
   end--;
  str [end] = 0;
};

char *strstrupcase (char *str1, char *str2)
{
  char *temp;
  size_t count;
  size_t length;

  length = strlen (str2);
  for (temp = str1; strlen (temp) > length; temp++)
  {
    for (count = 0; (toupper (temp [count]) == toupper (str2 [count]))&(count < length); count++);
    if (count==length)
    {
      return (temp);
    };
  };
  return (NULL);
};

char proccess_exception_file (char *filename, struct translatetable **trans, struct excludetable **exclude, char **path)
{
  FILE *efile;
  char tempstr [exceptionfilelinelength];
  char *start;
  char *end;
  struct translatetable *temp;

  if ((efile = fopen (filename, "r"))==NULL)
  {
    printf ("Error opening excetion file.\n\n");
    return (file_err);
  }

  while (fgets (tempstr, exceptionfilelinelength, efile) != NULL)
  {
    start = tempstr;
    while (start [0] == ' ')  //Remove leading whitespace
      start++;

    //If it is a translate command
    if (strstrupcase (start, "TRANSLATE") == start)
    {
      start = start + 10;         //Go past translate
      while (start [0] == ' ')      //skip spaces
        start++;
      if (start [0] == 0)
      {
        printf ("Unexpected end of line in exception file:\n%s", tempstr);
        return (exep_err);
      };
      end = strstr (start, "-->");  //Find second part of string
      if (end == NULL)
      {
        printf ("Line: %s \nmust have two file names separated by -->", tempstr);
        return (exep_err);
      }
      end [0] = '\0';  //Split string
      removewhitespace (start);
      if ((temp = malloc (sizeof (struct translatetable))) == NULL)
      {
        printf ("Insufficient memory to load exception table.");
        return (mem_err);
      }
      if ((temp->source1name = _strdup (start)) == NULL)
      {
        printf ("Unable to allocate memory for char temp->source1name in proccess_exception_file.\n");
        free (temp);
        return (mem_err);
      }
      start = end + 3;
      while (start [0] == ' ')  //Remove leading whitespace
        start++;
      if (start [0] == 0)
      {
        printf ("Unexpected end of line in exception file:\n   %s", tempstr);
        free (temp->source1name);
        free (temp);
        return (exep_err);
      };
      removewhitespace (start);
      if ((temp->source2name = _strdup (start)) == NULL)
      {
        printf ("Unable to allocate memory for char temp->source1name in proccess_exception_file.\n");
        free (temp->source1name);
        free (temp);
        return (mem_err);
      }
      temp->next = *trans;
      *trans = temp;
    }

    //If it is an exclude command.
    else if (strstrupcase (start, "EXCLUDE") == start)
    {
      start = start + 7;         //Go past exclude
      while (start [0] == ' ')      //skip spaces
        start++;
      if (start [0] == 0)
      {
        printf ("Unexpected end of line in exception file:\n   %s", tempstr);
        return (exep_err);
      };
      removewhitespace (start);
      if ((temp = malloc (sizeof (struct excludetable))) == NULL)
      {
        printf ("Insufficient memory to load exception table.");
        return (mem_err);
      }
      if ((temp->source1name = _strdup (start)) == NULL)  //source1name coresponds to path
      {
        printf ("Unable to allocate memory for char temp->path in proccess_exception_file.\n");
        free (temp);
        return (mem_err);
      }
      temp->next = (struct translatetable *) *exclude;
      *exclude = (struct excludetable *) temp;
    }

    //If it is a startpath command
    else if (strstrupcase (start, "STARTPATH") == start)
    {
      if (*path != NULL)
      {
        printf ("Only one STARTPATH command is allowed in the exception file.\n");
        return (exep_err);
      };
      start = start + 9;         //Go past startpath
      while (start [0] == ' ')      //skip spaces
        start++;
      if (start [0] == 0)
      {
        printf ("Unexpected end of line in exception file:\n   %s", tempstr);
        return (exep_err);
      };
      removewhitespace (start);
      if ((*path = _strdup (start)) == NULL)
      {
        printf ("Unable to allocate memory for char path in proccess_exception_file.\n");
        return (mem_err);
      }
    }
    else if (!start [0] == ';') //if it's not a comment
    {
      printf ("Unexpected line in exception file:\n   %s", tempstr);
      return (exep_err);
    };
  };
  if (ferror (efile))
  {
    printf ("Error reading exception file.\n\n");
    return (file_err);
  };
  if (fclose (efile))
  {
    printf ("Error closing excetion file.\n\nContinuing anyway...");
  };
  return (0);
};

char proccess_command_line (int argc, char *argv[ ], char **source1, char **source2, char *flags, char **exception)
// flags: /F=1=(F_flag); /I1=2=(I1_flag); /I2=4=(I2_flag); /X=8=(X_flag)
{
  int argloop;
  *flags=0; //temporarily using 16=source1 found; 32=source2 found

  for (argloop = 1;argloop < argc; argloop++)
  {
    if (argv[argloop][0] == '/')
	  {							
	    if ((argv[argloop][1] == 'F')|(argv[argloop][1] == 'f')) //we got a /f
	    {
	      *flags|=F_flag;   //duplicate flags will not cause errors
	    }
      else if (argv[argloop][1] == '?')
      {
        completehelp ();
      }
	    else if ((argv[argloop][1] == 'I')|(argv[argloop][1] == 'i'))
      {
        if (argv[argloop][2] == '1')
        {
          *flags|=I1_flag;  //we got a /i1
        }
        else if (argv[argloop][2] == '2')
        {
          *flags|=I2_flag;  //we got a /i2
        }
        else
        {
          printf ("Unknown switch \"/I%c\" .\n\n", argv[argloop][2]);
          return (par_err);
        }
      }
      else if ((argv[argloop][1] == 'X')|(argv[argloop][1] == 'x'))
      {
        *flags|=X_flag; // we got a /x
        if (argloop+1 == argc)
        {
          printf ("Parameter /X must be followed by a filename.\n\n");
          return (par_err);
        };
        if ((*exception = _strdup (argv [argloop + 1]))==NULL)
        {
          printf ("Unable to allocate memory for char *exception in proccess_command_line.\n");
          error (mem_err);
        };
        argloop++; //to skip this parameter in the general parser
      }
      else
      {
        printf ("Unknown switch \"/%c\" .\n\n", argv[argloop][1]);
        return (par_err);
      }
  	}
  	else  // it must be a source filename
  	{
  	  if (!(*flags & 16)) //first source in command line
      {
        if ((*source1 = _strdup (argv [argloop]))==NULL)
        {
          printf ("Unable to allocate memory for char *source1 in proccess_command_line.\n");
          return (mem_err);
        };
        *flags|=16;
      }
      else if (!(*flags & 32)) //second source in command line
      {
        if ((*source2 = _strdup (argv [argloop]))==NULL)
        {
          printf ("Unable to allocate memory for char *source2 in proccess_command_line.\n");
          return (mem_err);
        };
        *flags|=32;
      }
      else
      {
        printf ("Too many source filenames in the command line.\n\n");
        return (par_err);
      };
    };
  };
  if (!(*flags & 32))
  {
    printf ("Command line must contain two source files.\n\n");
    return (par_err);
  };
  *flags|=(!(32+16)); // clear temporary source1 and source2 flags
  return (0);
};

void completehelp ()
{
  printf ("Usage:\n"
          "CHKVERFY <Source1> <Source2> [/F] [/X <exceptionfile>] [/I1] [/I2]\n"
          "     /F  = Flat share (ignore paths).\n"
          "     /I1 = Ignore extra files in Source1.\n"
          "     /I2 = Ignore extra files in Source2.\n"
          "     /X  = excetion file with the following commands.\n"
          "          TRANSLATE <Source1name> --> <Source2name>\n"
          "             Replaces <Source1name> with <Sourece2name> whereever found.\n"
          "             Note: make sure the filename you are using is only in the full\n"
          "             filename of the files you mant to translate.\n\n"
          "          EXCLUDE <pathsegment>\n"
          "             Any path and file containing this string will be ignored.\n\n"
          "          STARTPATH <directory name>\n"
          "             Files without this string in the path will be ignored.\n"
          "             The part of the path before this string will be ignored.\n\n"
          "         Note: These three commands are proccessed in the order shown above. \n"
          "               For example, the command \"TRANSLATE C:\\nt --> C:\\\" will\n"
          "               override the command \"EXCLUDE C:\\nt\".\n"
          "               The order of commands in the exception files doesn't matter\n"
          "               unless two commands both try to translate the same file.\n"
          "               In that case, the last command in the file takes precedence.\n"
          "Exit codes:\n"            // These code values should match the codes defined above.
          "     6 = Invalid command line arguments.\n"
          "     5 = Error in exception file format.\n"
          "     4 = Error in chkfile.\n"
          "     3 = Memory allocation error.\n"
          "     2 = File access error.\n"
          "     1 = No errors: Source1 and Source2 failed compare.\n"
          "     0 = No errors: Source1 and Source2 compared successfully.\n\n"
          );
  exit (0);
};

void error (char exitcode)
{
  if (exitcode >= exep_err)
  {
  printf ("Usage:\n"
          "CHKVERFY <Source1> <Source2> [/F] [/X <exceptionfile>] [/I1] [/I2]\n"
          "     /?  = Complete help.\n"
          "     /F  = Flat share (ignore paths).\n"
          "     /I1 = Ignore extra files in Source1.\n"
          "     /I2 = Ignore extra files in Source2.\n"
          "     /X  = excetion file with the following commands.\n"
          );
  };
  switch (exitcode)
  {
    case 0:
      printf ("\n\n(0) Files compare okay.\n");
      break;
    case 1:
      printf ("\n\n(1) Some files or checksums don't match.\n");
      break;
    case 2:
      printf ("\n\n(2) Terminated due to file access error.\n");
      break;
    case 3:
      printf ("\n\n(3) Terminated due to memory allocation error.\n");
      break;
    case 4:
      printf ("\n\n(4) The format of the source files was not as expected.\n");
      break;
    case 5:
      printf ("\n\n(5) Error in exception file format.\n");
      break;
    case 6:
      printf ("\n\n(6) Bad command line argument.\n");
      break;
  };
  exit (exitcode);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\chksum\chksum.c ===
/**************************************************************************************\
*  Chksum.c
*  Purpose: Print to stdout checksum of all files in current directory, and optionally
*           recurse from current directory.
*
*  Created 02-15-95.  DonBr
*
\**************************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <errno.h>
#include <string.h>
#include <io.h>
#include <imagehlp.h>
#include <direct.h>
#include <ctype.h>

// type definitions
#define exename "chksum"
#define MAX_EXCLUDE (30)
#define LISTSIZE 12000   // max allowable number of files and dirs in a flat directory

typedef struct List {
       char            Name[MAX_PATH];  // file or directory name
       unsigned long   Attributes;
       unsigned long   Size;
} List, *pList;

// Function prototypes
VOID CheckRel();
VOID CheckSum(List *rgpList, TCHAR *x); //, TCHAR *szDirectory);
int __cdecl CompFileAndDir( const void *elem1 , const void *elem2);
int __cdecl CompName( const void *elem1 , const void *elem2);
int MyGetFullPathName( IN const CHAR *InPath, IN OUT CHAR *FullPath);
VOID CreateOutputPath(char *CurrentDir, char *NewDir);
VOID ParseArgs(int *pargc, char **argv);
VOID Usage();

// Variable declarations

BOOL fRecurse = FALSE;
BOOL fPathOverride = FALSE;
BOOL fFileOut = FALSE;
BOOL fExclude = FALSE;
BOOL fFileIn = FALSE;
int  DirNum = 1,DirNameSize = 0, ProcessedFiles=0, endchar=0, ExclCounter=0;
int  grc=0;  // global return code
char szRootDir[MAX_PATH];
char szRootDir2[MAX_PATH];
char *szFileOut;
char szFileOutFullPath[MAX_PATH];
char *szExclude[MAX_EXCLUDE];
char *szFileIn;
CHAR szDirectory[MAX_PATH] = {"."};  // default to current directory
FILE* fout;
FILE* fin;


// Begin main program
VOID __cdecl
main(
    INT argc,
    LPSTR argv[]
    )

{
    TCHAR CWD[MAX_PATH];
    HANDLE logfh;

    ParseArgs(&argc, argv);

    // Create File if fFileOut==TRUE
    if (fFileOut) {
       fout = fopen(szFileOut, "w");
       if (fout == NULL) {
          fprintf(stderr, "Output file %s could not be created.\n", szFileOut);
          exit(1);
       }

    }
    /*
    // Open File if fFileIn==TRUE
    if (fFileIn) {
       fin = fopen(szFileIn, "r");  // open check file
       if (fin == NULL) {
          fprintf(stderr, "Check file %s could not be opened.\n", szFileIn);
          exit(1);
       }
    }
    */

    // set root path
    if (fPathOverride) {

       // attempt to change directories
       if (_chdir(szRootDir) == -1){
          fprintf(stderr, "Path not found: %s\n", szRootDir);
          Usage();
       }
    }else{
       GetCurrentDirectory(MAX_PATH, szRootDir);
    }

    fprintf(fout==NULL? stdout : fout , "Processing %s\n", szRootDir);

    CheckRel();  // primary worker routine

    fprintf(stdout, "%d files processed in %d directories\n", ProcessedFiles, DirNum);

    if (fFileOut) {
       fclose(fout);
    }

    exit(grc);
}

/**************************************************************************************\
*  Checkrel
*  Purpose: Create an array of List structures containing file data for the current
*           directory, sort the array alphabetically placing Files first and
*           directories last, and finally process the array contents.  Another instance
*           of checkrel is started for directories, and checksum is called for files.
\**************************************************************************************/

VOID CheckRel()
{
    HANDLE fh;
    TCHAR CurrentDir[MAX_PATH] = {"\0"};
    TCHAR NewDir[MAX_PATH] = {"\0"};

    WIN32_FIND_DATA *pfdata;
    BOOL fFilesInDir=FALSE;
    BOOL fDirsFound=FALSE;
    int iArrayMember=0, cNumDir=0, i=0, Length=0;
    pList *rgpList = NULL;  // a pointer to an array of pointers to List structures
    CHAR cFileNameFullPath[MAX_PATH];

    pfdata = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    if (!pfdata) {
       fprintf(stderr, "Not enough memory.\n");
       grc++;
       return;
    }

    // Find the first file
    fh = FindFirstFile("*.*", pfdata);
    if (fh == INVALID_HANDLE_VALUE) {
       fprintf(fout==NULL? stdout : fout , "\t No files found\n");
       free(pfdata);
       grc++;
       return;
    }

    // Allocate an array of pointers to List structures
    rgpList = (pList *) malloc(LISTSIZE * sizeof(pList));
    if (!rgpList) {
       fprintf(stderr, "Not enough memory allocating rgpList[].\n");
       free(pfdata);
       FindClose(fh);      // close the file handle
       grc++;
       return;
    }

    //
    // DoWhile loop to find all files and directories in current directory
    // and copy pertinent data to individual List structures.
    //
    do {              // while (FindNextFile(fh, pfdata))

       if (strcmp(pfdata->cFileName, ".") && strcmp(pfdata->cFileName, "..")) {  // skip . and ..

          //
          // If excluding files and current file matches any excluded file 
          // (case insensitively), then don't process current file
          //
          if (fExclude) {
             for (i=0; i < ExclCounter; i++) {
                if (!_strcmpi(pfdata->cFileName, szExclude[i])) {
                   goto excludefound;

                }
             }
          }

          //
          // If current file matches output file name, then don't process current file
          //
          if ((fFileOut) && (!strcmp(szFileOut, pfdata->cFileName)) ) {

             // File names match.  If full paths match, ignore the output file.

             MyGetFullPathName(pfdata->cFileName, cFileNameFullPath);
             if ( !_strcmpi( szFileOutFullPath, cFileNameFullPath) ) {
                goto excludefound;
             }
          }

          rgpList[iArrayMember] = (pList)malloc(sizeof(List));  // allocate the memory

          if (!rgpList[iArrayMember]) {
             fputs("Not enough memory.\n", stderr);
             free(pfdata);
             FindClose(fh);      // close the file handle
             for (i=0; i<iArrayMember; i++) free(rgpList[i]);
             free(rgpList);
             grc++;
             return;
          }

          strcpy(rgpList[iArrayMember]->Name, pfdata->cFileName);
          _strlwr(rgpList[iArrayMember]->Name);  // all lowercase for strcmp in CompName
          memcpy(&(rgpList[iArrayMember]->Attributes), &pfdata->dwFileAttributes, 4);
          memcpy(&(rgpList[iArrayMember]->Size), &pfdata->nFileSizeLow, 4);

          if (!(rgpList[iArrayMember]->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {  //If file
             fFilesInDir=TRUE;
          } else {
             if (rgpList[iArrayMember]->Attributes & FILE_ATTRIBUTE_DIRECTORY) {  //If directory
                fDirsFound=TRUE;
             }
             if (fRecurse) {  // if recursive increment directory counter
                cNumDir++;
             }
          }

          iArrayMember++;
          if (iArrayMember >= LISTSIZE) {
             GetCurrentDirectory(MAX_PATH, CurrentDir);
             fprintf(stderr, "More than %d files in %s. \nRebuild chksum.exe or eliminate some files from the root of this directory.\n", LISTSIZE, CurrentDir);
             free(pfdata);
             FindClose(fh);      // close the file handle
             for (i=0; i<iArrayMember; i++) free(rgpList[i]);
             free(rgpList);
             grc++;
             return;
          }
          excludefound: ;
       }


    } while (FindNextFile(fh, pfdata));

    if (pfdata) free(pfdata);
    if (fh) FindClose(fh);      // close the file handle

    //
    // if no directories or files found with exception of . and ..
    //
    if ( (iArrayMember==0) || (!fFilesInDir) ){

       GetCurrentDirectory(MAX_PATH, CurrentDir);

       CreateOutputPath(CurrentDir, NewDir);

       // fprintf(fout==NULL? stdout : fout , "%s  -  No files\n", NewDir);
    }

    // Sort Array arranging FILE entries at top
    qsort( (void *)rgpList, iArrayMember, sizeof(List *), CompFileAndDir);

    // Sort Array alphabetizing only FILE names
    qsort( (void *)rgpList, iArrayMember-cNumDir, sizeof(List *), CompName);

    // Sort Array alphabetizing only DIRectory names
    qsort( (void *)&rgpList[iArrayMember-cNumDir], cNumDir, sizeof(List *), CompName);

    //
    // Process newly sorted structures.
    // Checksum files or start another instance of checkrel() for directories
    //
    for (i=0; i < iArrayMember; ++i) {

       if (rgpList[i]->Attributes & FILE_ATTRIBUTE_DIRECTORY) {  // if Dir


          if (fRecurse) {                                        // if recursive

             if (_chdir(rgpList[i]->Name) == -1){   // cd into subdir and check for error
                fprintf(stderr, "Unable to change directory: %s  (error %d)\n", rgpList[i]->Name, GetLastError());
                grc++;

             } else {
                DirNum++;      // directory counter
                CheckRel();   // start another iteration of checkrel function in new directory
                _chdir(".."); // get back to previous directory when above iteration returns

             } // end if _chdir

          } // end if recurse

       } else {  // else if not Directory
             GetCurrentDirectory(MAX_PATH, CurrentDir);

             CreateOutputPath(CurrentDir, NewDir);

             CheckSum(rgpList[i], NewDir);
       }

    } // end for i < iArrayMember

    // Clean up the array and it's elements
    for (i=0; i<iArrayMember; i++) free(rgpList[i]);
    free(rgpList);

} // end CheckRel

/*************************************************************************************\
* CheckSum
* Purpose: uses MapFileAndCheckSum to determine file checksum and outputs data.
\*************************************************************************************/
VOID CheckSum(List *rgpList, TCHAR *x) {//TCHAR *szDirectory) {
    ULONG HeaderSum, CheckSum=0, status;

    if (rgpList->Size != 0) { //High != 0 || rgpList->nFileSizeLow != 0) {
       status = MapFileAndCheckSum(rgpList->Name, &HeaderSum, &CheckSum);
       if (status != CHECKSUM_SUCCESS) {
          fprintf(fout==NULL? stdout : fout , "\nCannot open or map file: %s (error %d)\n", rgpList->Name, GetLastError());
          grc++;
          return;
       }
    }

    fprintf(fout==NULL? stdout : fout , "%s\\%s %lx\n", x, rgpList->Name, CheckSum);//szDirectory, rgpList->Name, CheckSum);
    ProcessedFiles++;

} //CheckSum


/********************************************************************************************\
* CompFileAndDir
* Purpose: a comparision routine passed to QSort.  It compares elem1 and elem2
* based upon their attribute, i.e., is it a file or directory.
\********************************************************************************************/

int __cdecl
CompFileAndDir( const void *elem1 , const void *elem2 )
{
   pList p1, p2;
   // qsort passes a void universal pointer, use a typecast (List**)
   // so the compiler recognizes the data as a List structure.
   // Typecast pointer-to-pointer-to-List and dereference ONCE
   // leaving a pList.  I don't dereference the remaining pointer
   // in the p1 and p2 definitions to avoid copying the structure.
   p1 = (*(List**)elem1);
   p2 = (*(List**)elem2);

   if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
      return 0;
   } //both dirs
   if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
      return 0;
   } //both files
   if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
      return 1;
   } // elem1 is dir and elem2 is file
   if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
      return -1;
   } // elem1 is file and elem2 is dir

   return 0; // if none of above

}


/********************************************************************************************\
* CompName is another compare routine passed to QSort that compares the two Name strings     *
\********************************************************************************************/

int __cdecl
CompName( const void *elem1 , const void *elem2 )
{
   return strcmp( (*(List**)elem1)->Name, (*(List**)elem2)->Name );
}

/**********************************************************************************************\
* CreateOutputPath just formats NewDir, the path prepended to filename during checksum output  *
\**********************************************************************************************/
VOID CreateOutputPath(char *CurrentDir, char *NewDir)
{
             strcpy(NewDir, ".");

             // if rootdir ends in '\' and currentdir and szrootdir2 don't match
             // handles case where /p path override arg ends in a '\' char like "/p g:\"
             // files listed at the root don't need the extra '\' placed in NewDir, but
             // directories at the root DO need ".\" prepended to their name

             _strlwr(CurrentDir);
             //fprintf(stdout, "szrootdir: %s, szrootdir2: %s, currentdir: %s\n", szRootDir, szRootDir2, CurrentDir);

             if ( (szRootDir[strlen(szRootDir)-1] == '\\') &&  // if arg path ends in "\"
                (strcmp(CurrentDir, szRootDir2)) &&            // if they don't match
                (CurrentDir[strlen(CurrentDir)-1] != '\\') //&&  // if currentdir doesn't end with "\"
                //(szRootDir2[strlen(szRootDir2)-1] != ':') ){   // if arg path ends with ":"
             ){
                strcat(NewDir, "\\");
             }

             if (  (CurrentDir[strlen(CurrentDir)-2] !=':') && (CurrentDir[strlen(CurrentDir)-1] !='\\')  ){
                strcat(NewDir, &CurrentDir[(strlen(szRootDir))] );
             }

}

VOID
ParseArgs(int *pargc, char **argv) {

   CHAR cswitch, c, *p;
   int argnum = 1;

   while ( argnum < *pargc ) {
      _strlwr(argv[argnum]);
      cswitch = *argv[argnum];
      if (cswitch == '/' || cswitch == '-') {
         c = *(argv[argnum]+1);

         switch (c) {

         case '?':
            Usage();

         case 'r':
            fRecurse = TRUE;
            break;

         case 'p':
            if ( ((argnum+1) < *pargc) && (*(argv[argnum]+2) == '\0') && (*(argv[argnum+1]) != '\0') ) {
               ++argnum; // increment to next arg string
               strcpy(szRootDir, argv[argnum]);
               if (szRootDir == NULL) {
                  fprintf(stderr, "out of memory for root dir.\n");
                  exit(1);
               }
               fPathOverride = TRUE;

               // Find the full path to the root
               if ( !MyGetFullPathName(argv[argnum], szRootDir) ) {
                  fprintf(stderr, "Cannot get full path for root dir %s\n", szRootDir);
                  exit(1);
               }
               _strlwr(szRootDir);

               strcpy(szRootDir2, szRootDir);
               // if path given ends in a "\", remove it...
               if (szRootDir2[strlen(szRootDir2)-1] == 92) szRootDir2[strlen(szRootDir2)-1] = '\0';
               break;

            } else {
               Usage();
            }

         case 'o':
            if ( ((argnum+1) < *pargc) && (*(argv[argnum]+2) == '\0') && (*(argv[argnum+1]) != '\0') ) {
               ++argnum;
               szFileOut = _strdup(argv[argnum]);
               if (szFileOut == NULL) {
                  fprintf(stderr, "Out of memory for output file.\n");
                  exit(1);
               }
               fFileOut = TRUE;

               // Find the full path to the output file
               if ( !MyGetFullPathName(szFileOut, szFileOutFullPath) ) {
                  fprintf(stderr, "Cannot get full path for output file %s\n", szFileOut);
                  exit(1);
               }
               _strlwr(szFileOutFullPath);  // lower case full path to output file
               _strlwr(szFileOut);          // lower case path to output file
               break;

            } else {
               Usage();
            }


         case 'x':                              // check number of args given
            if ( ((argnum+1) < *pargc) && (*(argv[argnum]+2) == '\0') && (*(argv[argnum+1]) != '\0') ) {
               ++argnum;
               szExclude[ExclCounter] = _strdup(argv[argnum]);
               if (szExclude[ExclCounter] == NULL) {
                  fprintf(stderr, "Out of memory for exclude name.\n");
                  exit(1);
               }
               fExclude = TRUE;
               _strlwr(szExclude[ExclCounter]);
               ExclCounter++;

               break;

            } else {
               Usage();
            }

         /*
         case 'i':
            if ( (*(argv[argnum]+2) == '\0') && (*(argv[argnum+1]) != '\0') ) {
               ++argnum;
               szFileIn = strdup(argv[argnum]);
               if (szFileIn == NULL) {
                  fprintf(stderr, "Out of memory for input file.\n");
                  exit(1);
               }
               fFileIn = TRUE;
               break;

            } else {
               Usage();
            }
         */
         default:
               fprintf(stderr, "\nInvalid argument: %s\n", argv[argnum]);
               Usage();
         } //switch

      } else {
         Usage();
      }  // if
      ++argnum;
   } // while
} // parseargs


LPSTR pszUsage =
    "Generates a listing of each file processed and its check sum.\n\n"
    "Usage: %s   [/?]          display this message\n"
    "                [/r]          recursive file check\n"
    "                [/p pathname] root path override\n"
    "                [/o filename] output file name\n"
    "                [/x name]     exclude file or directory\n\n"
    "Notes: If no /p path is given, the current directory is processed.\n"
    "       Exclude multiple files or directories with multiple /x arguments\n"
    "         e.g. - /x file1 /x file2\n\n"
    "Example: %s /r /p c:\\winnt351 /o %s.chk /x symbols /x dump\n"
    "";

VOID
Usage()
{
    fprintf(stderr, pszUsage, exename, exename, exename);
    exit(1);
}

int MyGetFullPathName( IN const CHAR *InPath, IN OUT CHAR *FullPath)
{
    int len;
    LPSTR FilePart;
    len = GetFullPathName(InPath, MAX_PATH, FullPath, &FilePart);
    return ( (len>0 && len<MAX_PATH) ? len : 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\imports\include\pdb.h ===
// Debug Information API
// Copyright (C) 1993-1996, Microsoft Corp.  All Rights Reserved.

#pragma once

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __PDB_INCLUDED__
#define __PDB_INCLUDED__

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned __int64 DWORDLONG;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SIG;        // unique (across PDB instances) signature
typedef ULONG   AGE;        // no. of times this instance has been updated
typedef const char*     SZ_CONST;   // const string
typedef void *          PV;
typedef const void *    PCV;

#ifdef  LNGNM
#define LNGNM_CONST	const
#else   // LNGNM
#define LNGNM_CONST
#endif  // LNGNM

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
} GUID;

#endif // !GUID_DEFINED

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;

#endif // !_HRESULT_DEFINED


typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

enum {
#ifdef LNGNM
    PDBIntv70   = 20000406,
    PDBIntv70Dep = 20000301,
#else
    PDBIntv70   = 20000301,
#endif
    PDBIntv69   = 19990511,
    PDBIntv61   = 19980914,
    PDBIntv50a  = 19970116,
    PDBIntv60   = PDBIntv50a,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
#ifdef LNGNM
    PDBIntv     = PDBIntv70,   // Now we support both 50 & 60, 69 is only an intermediate version
    PDBIntvAlt  = PDBIntv50,   
    PDBIntvAlt2 = PDBIntv60,   
    PDBIntvAlt3 = PDBIntv69,
#else
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntvAlt2 = PDBIntv60,   // Alternate (backward compatible) supported interface
    PDBIntvAlt3 = PDBIntv61,
    PDBIntv     = PDBIntv69,
#endif  
};

enum {
    PDBImpvVC2  = 19941610,
    PDBImpvVC4  = 19950623,
    PDBImpvVC41 = 19950814,
    PDBImpvVC50 = 19960307,
    PDBImpvVC98 = 19970604,
    PDBImpvVC70 = 20000404,
    PDBImpvVC70Dep = 19990604,  // deprecated vc70 implementation version
#ifdef LNGNM
    PDBImpv     = PDBImpvVC70,
#else
    PDBImpv     = PDBImpvVC98,
#endif
};


enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
};

// cvinfo.h type index, intentionally typedef'ed here to check equivalence.
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.

typedef CV_typ_t        TI;     // PDB name for type index
typedef CV_typ16_t      TI16;   // 16-bit version
typedef unsigned long   NI;     // name index
typedef TI *            PTi;
typedef TI16 *          PTi16;

typedef BYTE            ITSM;   // type server map index
typedef ITSM*           PITSM;

typedef BOOL    (__stdcall *PFNVALIDATEDEBUGINFOFILE) (const char * szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancilliary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    char *  szMod;                      // exe/dll
    char *  szLib;                      // lib if appropriate
    char *  szObj;                      // object file
    char * *rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char  szValidatedFile[PDB_MAX_PATH];// output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
    char *  szExe;                      // exe/dll
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

typedef BOOL ( __stdcall * PfnFindDebugInfoFile) ( PSEARCHDEBUGINFO );

#define PdbInterface struct

PdbInterface PDB;                   // program database
PdbInterface DBI;                   // debug information within the PDB
PdbInterface Mod;                   // a module within the DBI
PdbInterface TPI;                   // type info within the DBI
PdbInterface GSI;                   // global symbol info
PdbInterface SO;                    
PdbInterface Stream;                // some named bytestream in the PDB
PdbInterface StreamImage;           // some memory mapped stream
PdbInterface NameMap;              // name mapping
PdbInterface Enum;                 // generic enumerator
PdbInterface EnumNameMap;          // enumerate names within a NameMap
PdbInterface EnumContrib;          // enumerate contributions
PdbInterface Dbg;                   // misc debug data (FPO, OMAP, etc)
PdbInterface Src;                   // Src file data
PdbInterface EnumSrc;               // Src file enumerator
PdbInterface SrcHash;               // Src file hasher
PdbInterface EnumLines;

typedef PdbInterface PDB PDB;
typedef PdbInterface DBI DBI;
typedef PdbInterface Mod Mod;
typedef PdbInterface TPI TPI;
typedef PdbInterface GSI GSI;
typedef PdbInterface SO SO;
typedef PdbInterface Stream Stream;
typedef PdbInterface StreamImage StreamImage;
typedef PdbInterface NameMap NameMap;
typedef PdbInterface Enum Enum;
typedef PdbInterface EnumStreamNames EnumStreamNames;
typedef PdbInterface EnumNameMap EnumNameMap;
typedef PdbInterface EnumContrib EnumContrib;
typedef PdbInterface WidenTi WidenTi;
typedef PdbInterface Dbg Dbg;
typedef PdbInterface EnumThunk EnumThunk;
typedef PdbInterface Src Src;
typedef PdbInterface EnumSrc EnumSrc;
typedef PdbInterface SrcHash SrcHash;

typedef SrcHash *   PSrcHash;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_ILLEGAL_TYPE_EDIT,   // trying to edit types in read-only mode
    EC_INVALID_EXECUTABLE,  // not recogized as a valid executable
    EC_DBG_NOT_FOUND,       // A required .DBG file was not found
    EC_NO_DEBUG_INFO,       // No recognized debug info found
    EC_INVALID_EXE_TIMESTAMP, // Invalid timestamp on Openvalidate of exe
    EC_RESERVED, // RESERVED for future use
    EC_DEBUG_INFO_NOT_IN_PDB, // returned by OpenValidateX
    EC_MAX
};

#define  pure = 0

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#ifdef PDB_SERVER
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllexport) RTYPE PDBCALL
#elif   defined(PDB_LIBRARY)
#define PDB_IMPORT_EXPORT(RTYPE)    RTYPE PDBCALL
#else
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL
#endif

#define PDBAPI PDB_IMPORT_EXPORT

#ifndef IN
#define IN                  /* in parameter, parameters are IN by default */
#endif
#ifndef OUT
#define OUT                 /* out parameter */
#endif

// Type of callback arg to PDB::OpenValidate5

enum POVC
{
    povcNotifyDebugDir,
    povcNotifyOpenDBG,
    povcNotifyOpenPDB,
    povcNotifySymbolServerQuery,
    povcReadExecutableAt,
    povcReadExecutableAtRVA,
};

typedef int (PDBCALL *PDBCALLBACK)();

typedef PDBCALLBACK (PDBCALL *PfnPDBQueryCallback)(void *pvClient, enum POVC povc);

typedef void (PDBCALL *PfnPDBNotifyDebugDir)(void *pvClient, BOOL fExecutable, const struct _IMAGE_DEBUG_DIRECTORY *pdbgdir);
typedef void (PDBCALL *PfnPDBNotifyOpenDBG)(void *pvClient, const wchar_t *wszDbgPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifyOpenPDB)(void *pvClient, const wchar_t *wszPdbPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifySymbolServerQuery)(void *pvClient, const char *szURL, HRESULT hr);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAt)(void *pvClient, DWORDLONG fo, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAtRVA)(void *pvClient, DWORD rva, DWORD cb, void *pv);

// type of callback arg to PDB::GetRawBytes
typedef BOOL (PDBCALL *PFNfReadPDBRawBytes)(const void *, long);

// WidenTi interface needs a couple of structures to communicate info back
// and forth.
struct OffMap {
    ULONG       offOld;
    ULONG       offNew;
};
typedef struct OffMap   OffMap;
typedef OffMap *        POffMap;

struct SymConvertInfo {
    ULONG       cbSyms;             // size necessary for converting a block
    ULONG       cSyms;              // count of symbols, necessary to allocate
                                    // mpoffOldoffNew array.
    BYTE *      pbSyms;             // block of symbols (output side)
    OffMap *    rgOffMap;           // OffMap rgOffMap[cSyms]
};
typedef struct SymConvertInfo   SymConvertInfo;
enum { wtiSymsNB09 = 0, wtiSymsNB10 = 1 };

// Filter values for PDBCopyTo
enum { 
    copyRemovePrivate       = 0x00000001,   // remove private debug information
    copyCreateNewSig        = 0x00000002,   // create new signature for target pdb
};

// PDBCopy callback signatures and function pointer types for PDB::CopyTo2 and CopyToW2
//
enum PCC {
    pccFilterPublics,
};

#if !defined(__cplusplus)
typedef enum PCC    PCC;
#endif  // __cplusplus

typedef BOOL (PDBCALL *PDBCOPYCALLBACK)();
typedef PDBCOPYCALLBACK (PDBCALL *PfnPDBCopyQueryCallback)(void *pvClientContext, PCC pcc);

// Return (true, pszNewPublic==NULL) to keep the name as is,
// (true, pszNewPublic!=NULL) changes name to pszNewPublic,
// false to discard public entirely.
//
typedef BOOL (PDBCALL *PfnPDBCopyFilterPublics)(
    void *          pvClientContext,
    DWORD           dwFilterFlags,
    unsigned int    offPublic,
    unsigned int    sectPublic,
    unsigned int    grfPublic,      // see cvinfo.h, definition of CV_PUBSYMFLAGS_e and
                                    // CV_PUBSYMFLAGS give the format of this bitfield.
    const wchar_t * szPublic,
    wchar_t **      pszNewPublic
    );

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,   // deprecated
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
#if !defined(VER60)
    dbgtypeTokenRidMap,
    dbgtypeXData,
    dbgtypePData,
    dbgtypeNewFPO,
#endif
    dbgtypeMax          // must be last!
};

typedef enum DBGTYPE DBGTYPE;

// Linker data necessary for relinking an image.  Record contains two SZ strings
// off of the end of the record with two offsets from the base 
//
enum VerLinkInfo {
    vliOne = 1,
    vliTwo = 2,
    vliCur = vliTwo,
};

struct LinkInfo {
    ULONG           cb;             // size of the whole record.  computed as
                                    //  sizeof(LinkInfo) + strlen(szCwd) + 1 +
                                    //  strlen(szCommand) + 1
    ULONG           ver;            // version of this record (VerLinkInfo)
    ULONG           offszCwd;       // offset from base of this record to szCwd
    ULONG           offszCommand;   // offset from base of this record
    ULONG           ichOutfile;     // index of start of output file in szCommand
    ULONG           offszLibs;      // offset from base of this record to szLibs

    // The command includes the full path to the linker, the -re and -out:...
    // swithches.
    // A sample might look like the following:
    // "c:\program files\msdev\bin\link.exe -re -out:debug\foo.exe"
    // with ichOutfile being 48.
    // the -out switch is guaranteed to be the last item in the command line.
#ifdef __cplusplus
    VerLinkInfo Ver() const {
        return VerLinkInfo(ver);
    }
    long Cb() const {
        return cb;
    }
    char *     SzCwd() const {
        return (char *)((char *)(this) + offszCwd);
    }
    char *    SzCommand() const {
        return (char *)((char *)(this) + offszCommand);
    }
    char *    SzOutFile() const {
        return SzCommand() + ichOutfile;
    }
    LinkInfo() :
        cb(0), ver(vliCur), offszCwd(0), offszCommand(0), ichOutfile(0)
    {
    }
    char *    SzLibs() const {
        return (char *)((char *)(this) + offszLibs);
    }

#endif
};

#ifdef LNGNM
#ifdef __cplusplus
struct LinkInfoW : public LinkInfo
{
    wchar_t* SzCwdW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCwd);
    }
    wchar_t* SzCommandW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCommand);
    }
    wchar_t* SzOutFileW() const {
        return SzCommandW() + ichOutfile;
    }
    wchar_t* SzLibsW() const {
        return (wchar_t *)((wchar_t *)(this) + offszLibs);
    }
};
#else
typedef struct LinkInfo LinkInfoW;
#endif  // __cplusplus

typedef LinkInfoW * PLinkInfoW;

#endif  // LNGNM

typedef struct LinkInfo LinkInfo;
typedef LinkInfo *      PLinkInfo;


//
// Source (Src) info
//
// This is the source file server for virtual and real source code.
// It is structured as an index on the object file name concatenated
// with 
enum SrcVer {
    srcverOne = 19980827,
};

enum SrcCompress {
    srccompressNone,
    srccompressRLE,
    srccompressHuffman,
    srccompressLZ,
};

#ifdef LNGNM
struct tagSrcHeader {
#else
struct SrcHeader {
#endif
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
#ifndef LNGNM
    unsigned char   szNames[1]; // file names (szFile "\0" szObj "\0" szVirtual,
                                //  as in: "f.cpp" "\0" "f.obj" "\0" "*inj:1:f.obj")
                                // in the case of non-virtual files, szVirtual is
                                // the same as szFile.
#endif
};

#ifdef LNGNM
struct SrcHeader : public tagSrcHeader
{
    unsigned char szNames[1];   // see comment above
};

struct SrcHeaderW : public tagSrcHeader
{
    wchar_t szNames[1];   // see comment above
};

typedef struct SrcHeaderW    SrcHeaderW;
typedef SrcHeaderW *         PSrcHeaderW;
typedef const SrcHeaderW *   PCSrcHeaderW;

//cassert(offsetof(SrcHeader,szNames) == sizeof(tagSrcHeader));
//cassert(offsetof(SrcHeaderW,szNames) == sizeof(tagSrcHeader));

#endif      // LNGNM

typedef struct SrcHeader    SrcHeader;
typedef SrcHeader *         PSrcHeader;
typedef const SrcHeader *   PCSrcHeader;

// header used for storing the info and for output to clients who are reading
//
struct SrcHeaderOut {
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned long   niFile;
    unsigned long   niObj;
    unsigned long   niVirt;
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
    short           sPad;
    union {
        void *      pvReserved1;
        __int64     pv64Reserved2;
    };
};

typedef struct SrcHeaderOut SrcHeaderOut;
typedef SrcHeaderOut *      PSrcHeaderOut;
typedef const SrcHeaderOut *PCSrcHeaderOut;

struct SrcHeaderBlock {
    __int32     ver;
    __int32     cb;
    struct {
        DWORD   dwLowDateTime;
        DWORD   dwHighDateTime;
    } ft;
    __int32     age;
    BYTE        rgbPad[44];
};

typedef struct SrcHeaderBlock   SrcHeaderBlock;


#ifdef __cplusplus

struct IStream;

// C++ Binding

PdbInterface PDB {                 // program database
    enum {
        intv  = PDBIntv,
#if defined(LNGNM)
        intvVC70Dep = PDBIntv70Dep, // deprecated
#endif
        intvAlt = PDBIntvAlt,
        intvAlt2 = PDBIntvAlt2,
        intvAlt3 = PDBIntvAlt3,
    };

    static PDBAPI(BOOL)
           OpenValidate(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           Open(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate3(
               const char *szExecutable,
               const char *szSearchPath,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT char szDbgPath[PDB_MAX_PATH],
               OUT DWORD *pfo,
               OUT DWORD *pcb,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate4(
               const wchar_t *wszPDB,
               const char *szMode,
               PCSIG70 pcsig70,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) OpenInStream(
               IStream *pIStream,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) ExportValidateInterface(INTV intv);
    static PDBAPI(BOOL) ExportValidateImplementation(IMPV impv);

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual EC   QueryLastError(OUT char szError[cbErrMax]) pure;
    virtual char*QueryPDBName(OUT char szPDB[PDB_MAX_PATH]) pure;
    virtual SIG  QuerySignature() pure;
    virtual AGE  QueryAge() pure;
    virtual BOOL CreateDBI(const char* szTarget, OUT DBI** ppdbi) pure;
    virtual BOOL OpenDBI(const char* szTarget, const char* szMode, OUT DBI** ppdbi ) pure;
    virtual BOOL OpenTpi(const char* szMode, OUT TPI** pptpi) pure;

    virtual BOOL Commit() pure;
    virtual BOOL Close() pure;
    virtual BOOL OpenStream(const char* szStream, OUT Stream** ppstream) pure;
    virtual BOOL GetEnumStreamNameMap(OUT Enum** ppenum) pure;
    virtual BOOL GetRawBytes(PFNfReadPDBRawBytes fSnarfRawBytes) pure;
    virtual IMPV QueryPdbImplementationVersion() pure;

    virtual BOOL OpenDBIEx(const char* szTarget, const char* szMode, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn=0) pure;

    virtual BOOL CopyTo(const char *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;

    //
    // support for source file data
    //
    virtual BOOL OpenSrc(OUT Src** ppsrc) pure;

    virtual EC   QueryLastErrorExW(OUT wchar_t *wszError, size_t cchMax) pure;
    virtual wchar_t *QueryPDBNameExW(OUT wchar_t *wszPDB, size_t cchMax) pure;
    virtual BOOL QuerySignature2(PSIG70 psig70) pure;
    virtual BOOL CopyToW(const wchar_t *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;
    virtual BOOL fIsSZPDB() const pure;
#ifdef LNGNM
    virtual BOOL OpenStreamW(const wchar_t * szStream, OUT Stream** ppstream) pure;
#endif


    inline BOOL ValidateInterface()
    {
        return ExportValidateInterface(intv);
    }

    static PDBAPI(BOOL)
           Open2W(
               const wchar_t *wszPDB,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx2W(
               const wchar_t *wszPDB,
               const char *szMode,
               long cbPage,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate5(
               const wchar_t *wszExecutable,
               const wchar_t *wszSearchPath,
               void *pvClient,
               PfnPDBQueryCallback pfnQueryCallback,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);


};


// Review: a stream directory service would be more appropriate
// than Stream::Delete, ...

PdbInterface Stream {
    virtual long QueryCb() pure;
    virtual BOOL Read(long off, void* pvBuf, long* pcbBuf) pure;
    virtual BOOL Write(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Replace(void* pvBuf, long cbBuf) pure;
    virtual BOOL Append(void* pvBuf, long cbBuf) pure;
    virtual BOOL Delete() pure;
    virtual BOOL Release() pure;
    virtual BOOL Read2(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Truncate(long cb) pure;
};

PdbInterface StreamImage {
    static PDBAPI(BOOL) open(Stream* pstream, long cb, OUT StreamImage** ppsi);
    virtual long size() pure;
    virtual void* base() pure;
    virtual BOOL noteRead(long off, long cb, OUT void** ppv) pure;
    virtual BOOL noteWrite(long off, long cb, OUT void** ppv) pure;
    virtual BOOL writeBack() pure;
    virtual BOOL release() pure;
};

PdbInterface DBI {             // debug information
    enum { intv = PDBIntv };
    virtual IMPV QueryImplementationVersion() pure;
    virtual INTV QueryInterfaceVersion() pure;
    virtual BOOL OpenMod(const char* szModule, const char* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteMod(const char* szModule) pure;
    virtual BOOL QueryNextMod(Mod* pmod, Mod** ppmodNext) pure;
    virtual BOOL OpenGlobals(OUT GSI **ppgsi) pure;
    virtual BOOL OpenPublics(OUT GSI **ppgsi) pure;
    virtual BOOL AddSec(USHORT isect, USHORT flags, long off, long cb) pure;
    virtual BOOL QueryModFromAddr(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb) pure;
    virtual BOOL QuerySecMap(OUT BYTE* pb, long* pcb) pure;
    virtual BOOL QueryFileInfo(OUT BYTE* pb, long* pcb) pure;
    virtual void DumpMods() pure;
    virtual void DumpSecContribs() pure;
    virtual void DumpSecMap() pure;

    virtual BOOL Close() pure;
    virtual BOOL AddThunkMap(long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                    struct SO* psoSectMap, unsigned nSects,
                    USHORT isectThunkTable, long offThunkTable) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL getEnumContrib(OUT Enum** ppenum) pure;
    virtual BOOL QueryTypeServer( ITSM itsm, OUT TPI** pptpi ) pure;
    virtual BOOL QueryItsmForTi( TI ti, OUT ITSM* pitsm ) pure;
    virtual BOOL QueryNextItsm( ITSM itsm, OUT ITSM *inext ) pure;
    virtual BOOL QueryLazyTypes() pure;
    virtual BOOL SetLazyTypes( BOOL fLazy ) pure;   // lazy is default and can only be turned off
    virtual BOOL FindTypeServers( OUT EC* pec, OUT char szError[cbErrMax] ) pure;
    virtual void DumpTypeServers() pure;
    virtual BOOL OpenDbg(DBGTYPE dbgtype, OUT Dbg **ppdbg) pure;
    virtual BOOL QueryDbgTypes(OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype) pure;
    // apis to support EnC work
    virtual BOOL QueryAddrForSec(OUT USHORT* pisect, OUT long* poff, 
            USHORT imod, long cb, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdb( OUT PDB** pppdb ) pure;
    virtual BOOL AddLinkInfo(IN PLinkInfo ) pure;
    virtual BOOL QueryLinkInfo(PLinkInfo, OUT long * pcb) pure;
    // new to vc6
    virtual AGE  QueryAge() const pure;
    virtual void * QueryHeader() const pure;
    virtual void FlushTypeServers() pure;
    virtual BOOL QueryTypeServerByPdb(const char* szPdb, OUT ITSM* pitsm) pure;

#ifdef LNGNM        // Long filename support
    virtual BOOL OpenModW(const wchar_t* szModule, const wchar_t* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteModW(const wchar_t* szModule) pure;
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL QueryTypeServerByPdbW( const wchar_t* szPdb, OUT ITSM* pitsm ) pure;
    virtual BOOL AddLinkInfoW(IN PLinkInfoW ) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual USHORT QueryMachineType() const pure;
    virtual void SetMachineType(USHORT wMachine) pure;
    virtual void RemoveDataForRva( ULONG rva, ULONG cb ) pure;
#endif

};

PdbInterface Mod {             // info for one module within DBI
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BOOL AddTypes(BYTE* pbTypes, long cb) pure;
    virtual BOOL AddSymbols(BYTE* pbSym, long cb) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL AddSecContrib(USHORT isect, long off, long cb, ULONG dwCharacteristics) pure;
    virtual BOOL QueryCBName(OUT long* pcb) pure;
    virtual BOOL QueryName(OUT char szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySymbols(BYTE* pbSym, long* pcb) pure;
    virtual BOOL QueryLines(BYTE* pbLines, long* pcb) pure;

    virtual BOOL SetPvClient(void *pvClient) pure;
    virtual BOOL GetPvClient(OUT void** ppvClient) pure;
    virtual BOOL QueryFirstCodeSecContrib(OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
//
// Make all users of this api use the real one, as this is exactly what it was
// supposed to query in the first place
//
#define QuerySecContrib QueryFirstCodeSecContrib

    virtual BOOL QueryImod(OUT USHORT* pimod) pure;
    virtual BOOL QueryDBI(OUT DBI** ppdbi) pure;
    virtual BOOL Close() pure;
    virtual BOOL QueryCBFile(OUT long* pcb) pure;
    virtual BOOL QueryFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryTpi(OUT TPI** pptpi) pure; // return this Mod's Tpi
    // apis to support EnC work
    virtual BOOL AddSecContribEx(USHORT isect, long off, long cb, ULONG dwCharacteristics, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QueryItsm(OUT USHORT* pitsm) pure;
    virtual BOOL QuerySrcFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdbFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL ReplaceLines(BYTE* pbLines, long cb) pure;
#ifdef LNGNM
    // V7 line number support
	virtual bool GetEnumLines( EnumLines** ppenum ) pure;
	virtual bool QueryLineFlags( OUT DWORD* pdwFlags ) pure;	// what data is present?
	virtual bool QueryFileNameInfo( 
                    IN DWORD        fileId,                 // source file identifier
                    OUT wchar_t*    szFilename,             // file name string 
                    IN OUT DWORD*   pccFilename,            // length of string
                    OUT DWORD*      pChksumType,            // type of chksum
                    OUT BYTE*       pbChksum,   	        // pointer to buffer for chksum data
                    IN OUT DWORD*   pcbChksum		        // number of bytes of chksum (in/out)
                    ) pure; 	    
    // Long filenames support
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL AddLinesW(const wchar_t* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          ULONG lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL QueryNameW(OUT wchar_t szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySrcFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryPdbFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
#endif
};

PdbInterface TPI {             // type info

    enum { intv = PDBIntv };

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;

    virtual BOOL QueryTi16ForCVRecord(BYTE* pb, OUT TI16* pti) pure;
    virtual BOOL QueryCVRecordForTi16(TI16 ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi16(TI16 ti, OUT BYTE** ppb) pure;
    virtual TI16 QueryTi16Min() pure;
    virtual TI16 QueryTi16Mac() pure;

    virtual long QueryCb() pure;
    virtual BOOL Close() pure;
    virtual BOOL Commit() pure;

    virtual BOOL QueryTi16ForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI16* pti) pure;
    virtual BOOL SupportQueryTiForUDT() pure;

    // the new versions that truly take 32-bit types
    virtual BOOL fIs16bitTypePool() pure;
    virtual BOOL QueryTiForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti) pure;
    virtual BOOL QueryTiForCVRecord(BYTE* pb, OUT TI* pti) pure;
    virtual BOOL QueryCVRecordForTi(TI ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi(TI ti, OUT BYTE** ppb) pure;
    virtual TI   QueryTiMin() pure;
    virtual TI   QueryTiMac() pure;
    virtual BOOL AreTypesEqual( TI ti1, TI ti2 ) pure;
    virtual BOOL IsTypeServed( TI ti ) pure;
#ifdef LNGNM
    virtual BOOL QueryTiForUDTW(const wchar_t *wcs, BOOL fCase, OUT TI* pti) pure;
#endif
};

PdbInterface GSI {
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BYTE* NextSym(BYTE* pbSym) pure;
    virtual BYTE* HashSym(const char* szName, BYTE* pbSym) pure;
    virtual BYTE* NearestSym(USHORT isect, long off, OUT long* pdisp) pure;      //currently only supported for publics
    virtual BOOL Close() pure;
    virtual BOOL getEnumThunk(USHORT isect, long off, OUT EnumThunk** ppenum) pure;
    virtual unsigned long OffForSym(BYTE *pbSym) pure;
    virtual BYTE* SymForOff(unsigned long off) pure;
#ifdef LNGNM
    virtual BYTE* HashSymW(const wchar_t *wcsName, BYTE* pbSym) pure;
#endif
};


PdbInterface NameMap {
    static PDBAPI(BOOL) open(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
    virtual BOOL close() pure;
    virtual BOOL reinitialize() pure;
    virtual BOOL getNi(const char* sz, OUT NI* pni) pure;
    virtual BOOL getName(NI ni, OUT const char** psz) pure;
    virtual BOOL getEnumNameMap(OUT Enum** ppenum) pure;
    virtual BOOL contains(const char* sz, OUT NI* pni) pure;
    virtual BOOL commit() pure;
    virtual BOOL isValidNi(NI ni) pure;
#ifdef LNGNM
    virtual BOOL getNiW(const wchar_t* sz, OUT NI* pni) pure;
    virtual BOOL getNameW(NI ni, OUT wchar_t* szName, IN OUT size_t * pcch) pure;
    virtual BOOL containsW(const wchar_t *sz, OUT NI* pni) pure;
#endif
};

#define __ENUM_INCLUDED__
PdbInterface Enum {
    virtual void release() pure;
    virtual void reset() pure;
    virtual BOOL next() pure;
};

PdbInterface EnumNameMap : Enum {
    virtual void get(OUT const char** psz, OUT NI* pni) pure;
};

PdbInterface EnumContrib : Enum {
    virtual void get(OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual void getCrcs(OUT DWORD* pcrcData, OUT DWORD* pcrcReloc ) pure;
    virtual bool fUpdate(IN long off, IN long cb) pure;
};

PdbInterface EnumThunk: Enum {
	virtual void get( OUT USHORT* pisect, OUT long* poff, OUT long* pcb ) pure;
};

struct CV_Line_t;
struct CV_Column_t;
PdbInterface EnumLines: public Enum
{
    // 
    // Blocks of lines are always in offset order, lines within blocks are also ordered by offset
    //
    virtual bool getLines( 	
        OUT DWORD*      fileId, 	// id for the filename
        OUT DWORD*      poffset,	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines, 	// number of lines (in/out)
        OUT CV_Line_t*  pLines		// pointer to buffer for line info
        ) = 0;
    virtual bool getLinesColumns( 	
        OUT DWORD*      fileId,     // id for the filename	    
        OUT DWORD*      poffset, 	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines,    // number of lines (in/out)
        OUT CV_Line_t*  pLines,		// pointer to buffer for line info
        OUT CV_Column_t*pColumns	// pointer to buffer for column info
        ) = 0;
};

//
// interface to use to widen type indices from 16 to 32 bits
// and store the results in a new location.
//
PdbInterface WidenTi {
public:
    static PDBAPI(BOOL)
    fCreate (
        WidenTi *&,
        unsigned cTypeInitialCache =256,
        BOOL fNB10Syms =wtiSymsNB09
        );

    virtual void
    release() pure;

    virtual BYTE /* TYPTYPE */ *
    pTypeWidenTi ( TI ti16, BYTE /* TYPTYPE */ * ) pure;

    virtual BYTE /* SYMTYPE */ *
    pSymWidenTi ( BYTE /* SYMTYPE */ * ) pure;

    virtual BOOL
    fTypeWidenTiNoCache ( BYTE * pbTypeDst, BYTE * pbTypeSrc, long & cbDst ) pure;

    virtual BOOL
    fSymWidenTiNoCache ( BYTE * pbSymDst, BYTE * pbSymSrc, long & cbDst ) pure;

    virtual BOOL
    fTypeNeedsWidening ( BYTE * pbType ) pure;

    virtual BOOL
    fSymNeedsWidening ( BYTE * pbSym ) pure;

    virtual BOOL
    freeRecord ( void * ) pure;

    // symbol block converters/query.  symbols start at doff from pbSymIn,
    // converted symbols will go at sci.pbSyms + doff, cbSyms are all including
    // doff.
    virtual BOOL
        fQuerySymConvertInfo (
        SymConvertInfo &    sciOut,
        BYTE *              pbSym,
        long                cbSym,
        int                 doff =0
        ) pure;

    virtual BOOL
    fConvertSymbolBlock (
        SymConvertInfo &    sciOut,
        BYTE *              pbSymIn,
        long                cbSymIn,
        int                 doff =0
        ) pure;
};

// interface for managing Dbg data
PdbInterface Dbg {
   // close Dbg Interface
   virtual BOOL Close() pure;
   // return number of elements (NOT bytes)
   virtual long QuerySize() pure;
   // reset enumeration index
   virtual void Reset() pure;
   // skip next celt elements (move enumeration index)
   virtual BOOL Skip(ULONG celt) pure;
   // query next celt elements into user-supplied buffer
   virtual BOOL QueryNext(ULONG celt, OUT void *rgelt) pure;
   // search for an element and fill in the entire struct given a field.
   // Only supported for the following debug types and fields:
   // DBG_FPO              'ulOffStart' field of FPO_DATA
   // DBG_FUNC             'StartingAddress' field of IMAGE_FUNCTION_ENTRY
   // DBG_OMAP             'rva' field of OMAP
   virtual BOOL Find(IN OUT void *pelt) pure;
   // remove debug data
   virtual BOOL Clear() pure;
   // append celt elements
   virtual BOOL Append(ULONG celt, const void *rgelt) pure;
   // replace next celt elements
   virtual BOOL ReplaceNext(ULONG celt, const void *rgelt) pure;
};

PdbInterface Src {
    // close and commit the changes (when open for write)
    virtual bool
    Close() pure;

    // add a source file or file-ette
    virtual bool
    Add(IN PCSrcHeader psrcheader, IN const void * pvData) pure;

    // remove a file or file-ette or all of the injected code for
    // one particular compiland (using the object file name)
    virtual bool
    Remove(IN SZ_CONST szFile) pure;

    // query and copy the header/control data to the output buffer
    virtual bool
    QueryByName(IN SZ_CONST szFile, OUT PSrcHeaderOut psrcheaderOut) const pure;

    // copy the file data (the size of the buffer is in the SrcHeaderOut
    // structure) to the output buffer.
    virtual bool
    GetData(IN PCSrcHeaderOut pcsrcheader, OUT void * pvData) const pure;

    // create an enumerator to traverse all of the files included
    // in the mapping.
    virtual bool
    GetEnum(OUT EnumSrc ** ppenum) const pure;

    // Get the header block (master header) of the Src data.
    // Includes age, time stamp, version, and size of the master stream
    virtual bool
    GetHeaderBlock(SrcHeaderBlock & shb) const pure;
#ifdef LNGNM
    virtual bool RemoveW(IN wchar_t *wcsFile) pure;
    virtual bool QueryByNameW(IN wchar_t *wcsFile, OUT PSrcHeaderOut psrcheaderOut) const pure;
    virtual bool AddW(IN PCSrcHeaderW psrcheader, IN const void * pvData) pure;
#endif
};

PdbInterface EnumSrc : Enum {
    virtual void get(OUT PCSrcHeaderOut * ppcsrcheader) pure;
};


PdbInterface SrcHash {

    // Various types we need
    //
    
    // Tri-state return type
    //
    enum TriState {
        tsYes,
        tsNo,
        tsMaybe,
    };

    // Hash identifier
    //
    enum HID {
        hidNone,
        hidMD5,
        hidMax,
    };

    // Define machine independent types for storage of HashID and size_t
    //
    typedef __int32 HashID_t;
    typedef unsigned __int32 CbHash_t;

    // Create a SrcHash object with the usual two-stage construction technique
    //
    static PDBAPI(bool)
    FCreateSrcHash(OUT PSrcHash &);

    // Accumulate more bytes into the hash
    //
    virtual bool
    FHashBuffer(IN PCV pvBuf, IN size_t cbBuf) pure;

    // Query the hash id
    //
    virtual HashID_t
    HashID() const pure;

    // Query the size of the hash 
    //
    virtual CbHash_t
    CbHash() const pure;

    // Copy the hash bytes to the client buffer
    //
    virtual void
    GetHash(OUT PV pvHash, IN CbHash_t cbHash) const pure;

    // Verify the incoming hash against a target buffer of bytes
    // returning a yes it matches, no it doesn't, or indeterminate.
    //
    virtual TriState
    TsVerifyHash(
        IN HID,
        IN CbHash_t cbHash,
        IN PCV pvHash,
        IN size_t cbBuf,
        IN PCV pvBuf
        ) pure;

    // Reset this object to pristine condition
    //
    virtual bool
    FReset() pure;

    // Close off and release this object
    //
    virtual void
    Close() pure;
};

#endif  // __cplusplus

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

typedef BOOL (PDBCALL *PfnPDBOpen)(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **);

PDBAPI(BOOL)
PDBOpen(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpen2W(
    const wchar_t *wszPDB,
    const char *szMode,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx2W(
    const wchar_t *wszPDB,
    const char *szMode,
    long cbPage,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate3(
    const char *szExecutable,
    const char *szSearchPath,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate4(
    const wchar_t *wszPDB,
    const char *szMode,
    PCSIG70 pcsig70,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate5(
    const wchar_t *wszExecutable,
    const wchar_t *wszSearchPath,
    void *pvClient,
    PfnPDBQueryCallback pfnQueryCallback,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI(BOOL)
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface()
{
    return PDBExportValidateInterface(PDBIntv);
}

typedef BOOL (PDBCALL *PfnPDBExportValidateInterface)(INTV);

__inline BOOL PDBValidateInterfacePfn(PfnPDBExportValidateInterface pfn)
{
    return (*pfn)(PDBIntv);
}

PDBAPI(EC)     PDBQueryLastError(PDB *ppdb, OUT char szError[cbErrMax]);
PDBAPI(INTV)   PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI(IMPV)   PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI(char*)  PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI(SIG)    PDBQuerySignature(PDB* ppdb);
PDBAPI(AGE)    PDBQueryAge(PDB* ppdb);
PDBAPI(BOOL)   PDBCreateDBI(PDB* ppdb, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenDBIEx(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn);
PDBAPI(BOOL)   PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenTpi(PDB* ppdb, const char* szMode, OUT TPI** pptpi);
PDBAPI(BOOL)   PDBCommit(PDB* ppdb);
PDBAPI(BOOL)   PDBClose(PDB* ppdb);
PDBAPI(BOOL)   PDBOpenStream(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
PDBAPI(BOOL)   PDBCopyTo(PDB *ppdb, const char *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBCopyToW(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBfIsSZPDB(PDB *ppdb);
PDBAPI(BOOL)   PDBCopyToW2(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, PfnPDBCopyQueryCallback pfnCallBack, void * pvClientContext);

PDBAPI(INTV)   DBIQueryInterfaceVersion(DBI* pdbi);
PDBAPI(IMPV)   DBIQueryImplementationVersion(DBI* pdbi);
PDBAPI(BOOL)   DBIOpenMod(DBI* pdbi, const char* szModule, const char* szFile, OUT Mod** ppmod);
PDBAPI(BOOL)   DBIDeleteMod(DBI* pdbi, const char* szModule);
PDBAPI(BOOL)   DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI(BOOL)   DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIAddSec(DBI* pdbi, USHORT isect, USHORT flags, long off, long cb);
PDBAPI(BOOL)   DBIAddPublic(DBI* pdbi, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb);
PDBAPI(BOOL)   DBIQuerySecMap(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQueryFileInfo(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQuerySupportsEC(DBI* pdbi);
PDBAPI(void)   DBIDumpMods(DBI* pdbi);
PDBAPI(void)   DBIDumpSecContribs(DBI* pdbi);
PDBAPI(void)   DBIDumpSecMap(DBI* pdbi);
PDBAPI(BOOL)   DBIClose(DBI* pdbi);
PDBAPI(BOOL)   DBIAddThunkMap(DBI* pdbi, long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                              struct SO* psoSectMap, unsigned nSects, USHORT isectThunkTable, long offThunkTable);
PDBAPI(BOOL)   DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI(BOOL)   DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI(BOOL)   DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI(BOOL)   DBIQueryNextItsm(DBI* pdbi, ITSM itsm, OUT ITSM *inext );
PDBAPI(BOOL)   DBIQueryLazyTypes(DBI* pdbi);
PDBAPI(BOOL)   DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI(BOOL)   DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI(BOOL)   DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);
PDBAPI(BOOL)   DBIAddLinkInfo(DBI* pdbi, IN PLinkInfo);
PDBAPI(BOOL)   DBIQueryLinkInfo(DBI* pdbi, PLinkInfo, IN OUT long * pcb);

PDBAPI(INTV)   ModQueryInterfaceVersion(Mod* pmod);
PDBAPI(IMPV)   ModQueryImplementationVersion(Mod* pmod);
PDBAPI(BOOL)   ModAddTypes(Mod* pmod, BYTE* pbTypes, long cb);
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb);
PDBAPI(BOOL)   ModAddPublic(Mod* pmod, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   ModAddLines(Mod* pmod, const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                           USHORT lineStart, BYTE* pbCoff, long cbCoff);
PDBAPI(BOOL)   ModAddSecContrib(Mod * pmod, USHORT isect, long off, long cb, ULONG dwCharacteristics);
PDBAPI(BOOL)   ModQueryCBName(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySymbols(Mod* pmod, BYTE* pbSym, long* pcb);
PDBAPI(BOOL)   ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb);
PDBAPI(BOOL)   ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI(BOOL)   ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI(BOOL)   ModQuerySecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryFirstCodeSecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryImod(Mod* pmod, OUT USHORT* pimod);
PDBAPI(BOOL)   ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI(BOOL)   ModClose(Mod* pmod);
PDBAPI(BOOL)   ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySrcFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQueryPdbFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySupportsEC(Mod* pmod);
PDBAPI(BOOL)   ModQueryTpi(Mod* pmod, OUT TPI** pptpi);
PDBAPI(BOOL)   ModReplaceLines(Mod* pmod, BYTE* pbLines, long cb);

PDBAPI(INTV)   TypesQueryInterfaceVersion(TPI* ptpi);
PDBAPI(IMPV)   TypesQueryImplementationVersion(TPI* ptpi);
// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)   TypesQueryTiForCVRecordEx(TPI* ptpi, BYTE* pb, OUT TI* pti);
PDBAPI(BOOL)   TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE* pb, IN OUT long* pcb);
PDBAPI(BOOL)   TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE** ppb);
PDBAPI(TI)     TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)     TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(long)   TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)   TypesClose(TPI* ptpi);
PDBAPI(BOOL)   TypesCommit(TPI* ptpi);
PDBAPI(BOOL)   TypesQueryTiForUDTEx(TPI* ptpi, LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)   TypesSupportQueryTiForUDT(TPI*);
PDBAPI(BOOL)   TypesfIs16bitTypePool(TPI*);
// Map all old ones to new ones for new compilands.
#define TypesQueryTiForCVRecord     TypesQueryTiForCVRecordEx
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx
#define TypesQueryTiForUDT          TypesQueryTiForUDTEx
PDBAPI(BOOL)    TypesAreTypesEqual( TPI* ptpi, TI ti1, TI ti2 );
PDBAPI(BOOL)    TypesIsTypeServed( TPI* ptpi, TI ti );

PDBAPI(BYTE*)  GSINextSym (GSI* pgsi, BYTE* pbSym);
PDBAPI(BYTE*)  GSIHashSym (GSI* pgsi, const char* szName, BYTE* pbSym);
PDBAPI(BYTE*)  GSINearestSym (GSI* pgsi, USHORT isect, long off,OUT long* pdisp);//currently only supported for publics
PDBAPI(BOOL)   GSIClose(GSI* pgsi);
PDBAPI(unsigned long)   GSIOffForSym( GSI* pgsi, BYTE* pbSym );
PDBAPI(BYTE*)   GSISymForOff( GSI* pgsi, unsigned long off );

PDBAPI(long)   StreamQueryCb(Stream* pstream);
PDBAPI(BOOL)   StreamRead(Stream* pstream, long off, void* pvBuf, long* pcbBuf);
PDBAPI(BOOL)   StreamWrite(Stream* pstream, long off, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamReplace(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamAppend(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamDelete(Stream* pstream);
PDBAPI(BOOL)   StreamTruncate(Stream* pstream, long cb);
PDBAPI(BOOL)   StreamRelease(Stream* pstream);

PDBAPI(BOOL)   StreamImageOpen(Stream* pstream, long cb, OUT StreamImage** ppsi);
PDBAPI(void*)  StreamImageBase(StreamImage* psi);
PDBAPI(long)   StreamImageSize(StreamImage* psi);
PDBAPI(BOOL)   StreamImageNoteRead(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageNoteWrite(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageWriteBack(StreamImage* psi);
PDBAPI(BOOL)   StreamImageRelease(StreamImage* psi);

PDBAPI(BOOL)   NameMapOpen(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
PDBAPI(BOOL)   NameMapClose(NameMap* pnm);
PDBAPI(BOOL)   NameMapReinitialize(NameMap* pnm);
PDBAPI(BOOL)   NameMapGetNi(NameMap* pnm, const char* sz, OUT NI* pni);
PDBAPI(BOOL)   NameMapGetName(NameMap* pnm, NI ni, OUT const char** psz);
PDBAPI(BOOL)   NameMapGetEnumNameMap(NameMap* pnm, OUT Enum** ppenum);
PDBAPI(BOOL)   NameMapCommit(NameMap* pnm);

PDBAPI(void)   EnumNameMapRelease(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapReset(EnumNameMap* penum);
PDBAPI(BOOL)   EnumNameMapNext(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapGet(EnumNameMap* penum, OUT const char** psz, OUT NI* pni);

PDBAPI(void)   EnumContribRelease(EnumContrib* penum);
PDBAPI(void)   EnumContribReset(EnumContrib* penum);
PDBAPI(BOOL)   EnumContribNext(EnumContrib* penum);
PDBAPI(void)   EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(void)   EnumContribGetCrcs(EnumContrib* penum, OUT DWORD* pcrcData, OUT DWORD* pcrcReloc);
PDBAPI(BOOL)   EnumContribfUpdate(EnumContrib* penum, IN long off, IN long cb);

PDBAPI(SIG)    SigForPbCb(BYTE* pb, size_t cb, SIG sig);
PDBAPI(void)   TruncStFromSz(char *stDst, const char *szSrc, size_t cbSrc);

PDBAPI(BOOL)   DbgClose(Dbg *pdbg);
PDBAPI(long)   DbgQuerySize(Dbg *pdbg);
PDBAPI(void)   DbgReset(Dbg *pdbg);
PDBAPI(BOOL)   DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI(BOOL)   DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI(BOOL)   DbgFind(Dbg *pdbg, IN OUT void *pelt);
PDBAPI(BOOL)   DbgClear(Dbg *pdbg);
PDBAPI(BOOL)   DbgAppend(Dbg *pdbg, ULONG celt, const void *rgelt);
PDBAPI(BOOL)   DbgReplaceNext(Dbg *pdbg, ULONG celt, const void *rgelt);

#if __cplusplus
};
#endif

struct SO {
    long off;
    USHORT isect;
    unsigned short pad;
};

#ifndef cbNil
#define cbNil   ((long)-1)
#endif
#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((USHORT)(-1))

#define pdbWrite                "w"
#define pdbRead                 "r"
#define pdbGetTiOnly            "i"
#define pdbGetRecordsOnly       "c"
#define pdbFullBuild            "f"
#define pdbTypeAppend           "a"
#define pdbRepro                "z"

#endif // __PDB_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\chmode\chmode.c ===
/* chmode - change mode/attribute of file
 *
 *   17-Apr-1986 daniel lipkie  add /R flag
 *   18-Jul-1986 daniel lipkie  add /N flag
 *   17-Jun-1987 bw  Hard-code '/' as switch char ( '-' conflicts with off )
 *   19-Oct-1990 w-barry Added forward function declaraions.
 *   27-Nov-1990 w-barry Began switch to Win32 API (including replacement of
 *                       getattr() with the Win32 equivalent.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tools.h>

#define ATTRLEN 8

flagType fSetAttr = FALSE;
flagType fRecurse = FALSE;
flagType fNondirOnly = FALSE;
char strPattern[MAX_PATH];
char strAttr[ATTRLEN];
DWORD maskOR  = FILE_ATTRIBUTE_NORMAL;
DWORD maskAND = 0xff;

// Forward Function Declartions...
void attr2str( char, char * );
void walkdir( char *, struct findType *, void * );
void walk( char *, struct findType *, void * );
int dochmode( char * );
void Usage( void );
int __cdecl main( int, char ** );


void
attr2str(
        char attr,
        char *pStr
        )
{
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_DIRECTORY ) ? 'd' : '-');
    *pStr++ = '-';
    *pStr++ = ' ';
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_HIDDEN ) ? 'H' : '-');
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_SYSTEM ) ? 'S' : '-');
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_ARCHIVE ) ? 'A' : '-');
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_READONLY ) ? 'R' : '-');
    *pStr = '\0';
}


void
walkdir(
       char *p,
       struct findType *b,
       void *dummy
       )
{
    char *pBuf;

    if (!HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) ||
        !strcmp (b->fbuf.cFileName, ".") || !strcmp (b->fbuf.cFileName, "..") ||
        (HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN) ||
         HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_SYSTEM)))
        /* do not enum "." and ".."
         * do not enum contents of non-directories
         * do not enum contents of hidden/system directories */
        return;
    if ((pBuf = malloc(MAX_PATH)) == NULL)
        return;
    strcpy(pBuf, p);
    if (!fPathChr((strend(pBuf))[-1]))
        strcat(pBuf, "\\");
    strcat(pBuf, strPattern);
    printf("subdirectory: %s\n", pBuf);
    dochmode(pBuf);
    free(pBuf);
}

void
walk (
     char *p,
     struct findType *b,
     void *dummy
     )
{
    if (TESTFLAG(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY) &&
        (!strcmp (b->fbuf.cFileName,".") || !strcmp (b->fbuf.cFileName, "..")))
        /* don't show mode of . and .. */
        return;

    if (fSetAttr) {
        if (TESTFLAG(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY) && fNondirOnly)
            /* Is a directory and /N flag so do NOT set attr */
            return;
        if (!SetFileAttributes(p, (b->fbuf.dwFileAttributes | maskOR) & maskAND) ) {
            attr2str( (char)((b->fbuf.dwFileAttributes | maskOR) & maskAND), strAttr);
            printf("error: attributes not set to %s  %s\n", strAttr, p);
        }
    } else {
        attr2str( (char)b->fbuf.dwFileAttributes, strAttr);
        printf("%s  %s\n", strAttr, p);
    }
    dummy;
}

int
dochmode(
        char *pstr
        )
{
    char *pBuf;

    if (!forfile (pstr, -1, walk, NULL))
        printf ("%s does not exist\n", pstr);
    if (fRecurse) {
        if ((pBuf = malloc(MAX_PATH)) == NULL)
            return( 0 );
        drive(pstr, pBuf);
        path(pstr, pBuf);
        /* do NOT append pathchar, we want to enum sub dir in this dir */
        strcat(pBuf, "*.*");
        forfile(pBuf, -1, walkdir, NULL);
        free(pBuf);
    }
    return 0;
}

void
Usage ()
{
    puts("Usage: CHMODE [/RN] {[-+][hsar]}+ {filespec}+\n"
         "    /R - Recurse to subdirectories\n"
         "    /N - Non-directory files only");
    exit( 1 );
}

int
__cdecl
main (
     int c,
     char *v[]
     )
{
    register char *p;
    char ch;
    DWORD attr;

    ConvertAppToOem( c, v );
    SHIFT (c,v);
    while (c > 0 && ((ch = *v[0]) == '-' || ch == '+' || ch == '/')) {
        p = *v;
        if (ch == '/') {
            while (*++p != '\0') {
                if (*p == 'R') {
                    fRecurse = TRUE;
                } else if (*p == 'N') {
                    fNondirOnly  = TRUE;
                } else {
                    Usage();
                }
            }
        } else {
            fSetAttr = TRUE;
            attr = 0;
            while (*++p != '\0')
                switch (*p) {
                    case 'h':
                        SETFLAG(attr, FILE_ATTRIBUTE_HIDDEN);
                        break;
                    case 's':
                        SETFLAG(attr, FILE_ATTRIBUTE_SYSTEM);
                        break;
                    case 'a':
                        SETFLAG(attr, FILE_ATTRIBUTE_ARCHIVE);
                        break;
                    case 'r':
                        SETFLAG(attr, FILE_ATTRIBUTE_READONLY);
                        break;
                    default:
                        Usage ();
                }
            if (ch == '+')
                SETFLAG(maskOR, attr);
            else
                RSETFLAG(maskAND, attr);
        }
        SHIFT(c,v);
    }

    if (c == 0) {
        if (fSetAttr) {
            /* if switches set then require filenames */
            Usage();
        } else {
            strcpy(strPattern, "*.*");
            dochmode("*.*");
        }
    } else while (c) {
            if (!fileext(*v, strPattern)) {
                strcpy(strPattern, "*.*");
            }
            dochmode(*v);
            SHIFT(c, v);
        }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\clearmem\cmutl.h ===
/*** cmUtl.H - Function declarations/defines for cmUtl.C routines.
 *
 *
 * Title:
 *	cmUtl external function declarations/defines
 *
 *      Copyright (c) 1990, Microsoft Corporation.
 *	Russ Blake.
 *
 *
 * Modification History:
 *	90.03.08  RezaB -- Created
 *
 */



/* * * *  E x t e r n a l   F u n c t i o n   D e c l a r a t i o n s  * * * */

extern BOOL  Failed (RC rc, LPSTR lpstrFname, WORD lineno, LPSTR lpstrMsg);

extern void  DisplayUsage (void);

extern RC    AddObjectHandle (LPHANDLE *plphandles, HANDLE handle);

extern long  FoldNormDist (long lMean, short sSDev, long lLoLimit,
                           long  lHiLimit);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\clearmem\clearmem.h ===
/*** clearmem.h- Public defines and structure definitions for cache flusher.
 *
 *
 * Title:
 *	Cache flusher include file used by all
 *
 *      Copyright (c) 1990, Microsoft Corporation.
 *	Russ Blake.
 *
 *
 * Modification History:
 *	90.03.08 - RussBl -- Created
 *
 */



/* * * * * * * * *   N T   C o m m o n   D e f i n e s   * * * * * * * * * */

#define RC        NTSTATUS


/* * * * * * * *   C o m m o n   M i s c .   D e f i n e s   * * * * * * * */

// Runtime flags
//
// #define STATIC static   // This is defined so all the defined STATIC 
   #define STATIC          // functions can easily become non-static by        
                           // changing this define to "".  Remember that
                           // static functions are not visiable by the
			   // kernel debugger.

   #define RESERVED_NULL NULL // Reserved null fields

// #define CF_DEBUG_L1	   // Flag indicating display of debug info - Level1
                           // (Level 1:  Displays process/thread arguments
// #define CF_DEBUG_L2	   // Flag indicating display of debug info - Level2
                           // (Level 2:  Displays thread start/completion info
// #define CF_DEBUG_L3	   // Flag indicating display of debug info - Level3
			   // (Level 3:  Displays CF cycle states' info
// #define CF_DEBUG_L4	   // Flag indicating display of debug info - Level4
			   // (Level 4:  Displays CF cycle timing info



// User defined error codes
//
#define     LOGIC_ERR  0x7FFFFF01L  // Error code indicating logic error
                                    // is encountered
#define INPUTARGS_ERR  0x7FFFFF02L  // Error code for invalid number of
                                    // input arguments
#define   FILEARG_ERR  0x7FFFFF03L  // Error code for invalid input file
                                    // argument
#define   TIMEARG_ERR  0x7FFFFF04L  // Error code for invalid trail time
                                    // argument
#define  INSUFMEM_ERR  0x7FFFFF05L  // Error code indicating memory can't
                                    // be allocated by MALLOC/REALLOC
#define  MEANSDEV_ERR  0x7FFFFF06L  // Error code for invalid mean and/or
                                    // standard deviation
#define     FSEEK_ERR  0x7FFFFF07L  // Error code indicating fseek()
                                    // failure
#define    FCLOSE_ERR  0x7FFFFF08L  // Error code indicating fclose()
                                    // failure
#define    FFLUSH_ERR  0x7FFFFF09L  // Error code indicating fflush()
                                    // failure
#define     FOPEN_ERR  0x7FFFFF0AL  // Error code indicating fopen()
                                    // failure
#define  PRCSETUP_ERR  0x7FFFFF0BL  // Error code indicating error during
                                    // child process setup/initialization
#define  THDSETUP_ERR  0x7FFFFF0CL  // Error code indicating error during
				    // thread setup/initialization
#define  PROCINFO_ERR  0x7FFFFF0DL  // Error code indicating error during
				    // retrieval of process information
#define   SETWSET_ERR  0x7FFFFF0EL  // Error code indicating error during
				    // setting of working set information


// Maximu length defines
//
#define  FNAME_LEN		  256	// Maximum file name langth
#define   LINE_LEN                128   // Maximum input line length
#define  ULONG_LEN                 15   // Maximum length required to store
                                        // ULONG values in ASCII format
					// 10+1(null)=11

#define    ERR_NOFILE  0xFFFFFFFFL  // Failure from CreateFile

// String (EXEs & KEYs) constants
//
#define 	CF_EXE	     "CLEARMEM.EXE"	// CF's binary name


// Other defines
//

#define PAGESIZE		   4096    // Page size in bytes
#define SECTION_SIZE	   16*1024*1024L   // Size of data section for flushing
#define FLUSH_FILE_SIZE        256*1024L   // Size of flush file

// Next is max that cache will permit in WS at one time for each file,
// less 1 (or we reach into next private segment because of how we
// alternate read locations)

#define NUM_FLUSH_READS 	     63    // Number of pages to read:


#define LAZY_DELAY		   5000L   // Lazy Writer delay

#define NUM_FILES		      3    // Number of flush files

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\systeminfo\pch.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      pch.h
//
//  Abstract:
//
//      pre-compiled header declaration
//      files that has to be pre-compiled into .pch file
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#define CMDLINE_VERSION   200

#pragma once        // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
    #include <Security.h>
    #include <SecExt.h>
}

//
// public Windows header files
//
#include <windows.h>
#include <tchar.h>
#include <wbemidl.h>
#include <chstring.h>
#include <comdef.h>
#include <wbemtime.h>
#include <dsrole.h>                 // domain role information
#include <strsafe.h>

//
// public C header files
//
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\clearmem\cmutl.c ===
/*** cmUtl.C - Utility functions for Win 32 Clear Memory.
 *
 *
 * Title:
 *	cmUtl - Clear Memory Utility Routines
 *
 *      Copyright (c) 1990-1993, Microsoft Corporation.
 *	Russ Blake.
 *
 *
 * Description:
 *
 *	This file includes all the utility functions used by the Win 32
 *	clear memory. (clearmem.c)
 *
 *
 * Design/Implementation Notes:
 *
 *
 * Modification History:
 *	90.03.08  RussBl -- Created
 * 93.05.12  HonWahChan -- removed timer related error msgs.
 *
 */



/* * * * * * * * * * * * *  I N C L U D E    F I L E S  * * * * * * * * * * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "clearmem.h"



/* * * * * * * * * *  G L O B A L   D E C L A R A T I O N S  * * * * * * * * */
/* none */



/* * * * * * * * * *  F U N C T I O N   P R O T O T Y P E S  * * * * * * * * */

#include "cmUtl.h"



/* * * * * * * * * * *  G L O B A L    V A R I A B L E S  * * * * * * * * * */
/* none */



/* * * * * *  E X P O R T E D   G L O B A L    V A R I A B L E S  * * * * * */
/* none */





/*******************************  F a i l e d  *******************************
 *
 *      Failed(rc, lpstrFname, lineno, lpstrMsg) -
 *              Checks the RC for an error type if an error has occured,
 *              prints the appropriate error message.  It logs the error
 *              message to the testlog file.
 *
 *      ENTRY   rc         - return code from the last API call
 *              lpstrFname - contains file name of where error occured
 *              lineno     - contains line number of failed API call
 *              lpstrMsg   - contains a general purpose message about the error
 *
 *      EXIT    -none-
 *
 *      RETURN  TRUE  - if API failed
 *              FALSE - if API successful
 *
 *      WARNING:  
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

BOOL Failed (RC rc, LPSTR lpstrFname, WORD lineno, LPSTR lpstrMsg)
{
    LPSTR lpstrErrMsg;


    if (rc != STATUS_SUCCESS) {

        switch (rc) {

            case (NTSTATUS)STATUS_INVALID_PARAMETER:
                lpstrErrMsg = "Invalid parameter";
                break;

            case STATUS_TIMEOUT:
                lpstrErrMsg = "TimeOut occured";
                break;

            case STATUS_INVALID_HANDLE:
                lpstrErrMsg = "Invalid handle";
                break;

            case STATUS_BUFFER_OVERFLOW:
                lpstrErrMsg = "Buffer overflow";
                break;

            case STATUS_ABANDONED:
                lpstrErrMsg = "Object abandoned";
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                lpstrErrMsg = "Not enough memory";
                break;

            case LOGIC_ERR:
                lpstrErrMsg = "Logic error encountered";
                break;

            case INPUTARGS_ERR:
                lpstrErrMsg = "Invalid number of input arguments";
                break;

            case FILEARG_ERR:
		          lpstrErrMsg = "Invalid cf data file argument";
                break;

            case TIMEARG_ERR:
                lpstrErrMsg = "Invalid trial time argument";
                break;

            case INSUFMEM_ERR:
                lpstrErrMsg = "Insufficient Memory";
                break;

            case FCLOSE_ERR:
                lpstrErrMsg = "fclose() failed";
                break;

            case FFLUSH_ERR:
                lpstrErrMsg = "fflush() failed";
                break;

            case FOPEN_ERR:
                lpstrErrMsg = "fopen() failed";
                break;

            case FSEEK_ERR:
                lpstrErrMsg = "fseek() failed";
                break;

            case MEANSDEV_ERR:
                lpstrErrMsg = "Invalid Mean and/or Standard Deviation";
                break;

            case PRCSETUP_ERR:
                lpstrErrMsg = "Child process setup/init failed";
                break;

            case THDSETUP_ERR:
                lpstrErrMsg = "Thread setup/init failed";
                break;

            default:
                lpstrErrMsg = "";

        } /* switch(rc) */

        printf(" **************************\n");
        printf(" * FAILure --> Line=%d File=%s (pid=0x%lX tid=0x%lX)\n",
               lineno, lpstrFname, GetCurrentProcessId(),
               GetCurrentThreadId());
        printf(" * RC=0x%lX (%s)\n", rc, lpstrErrMsg);
        printf(" * %s\n", lpstrMsg);
        printf(" **************************\n");

        return(TRUE);

    } /* if(rc..) */

    return(FALSE);

} /* Failed() */





/**************************  D i s p l a y U s a g e  ************************
 *
 *      DisplayUsage() -
 *		Displays usgae for Multi-Processor Response cf
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

void DisplayUsage (void)
{

    printf("\nUsage:  cf FlushFile\n");
    printf("    FlushFile - File used to flush the cache, should be 128kb\n");

    return;

} /* DisplayUsage() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\systeminfo\init.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      Init.cpp
//
//  Abstract:
//
//      This module implements the general initialization stuff
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "systeminfo.h"

//
// private function prototype(s)
//


CSystemInfo::CSystemInfo()
/*++
// Routine Description:
//     Initializes the class member variables
// Arguments: 
//     none
// Return Value:
//     none
--*/
{
    //initialize the class member variables
    m_dwFormat = 0;
    m_bUsage = FALSE;
    m_pWbemLocator = NULL;
    m_pWbemServices = NULL;
    m_pAuthIdentity = NULL;
    m_arrData = NULL;
    m_bNeedPassword = FALSE;
    m_pColumns = FALSE;
    m_hOutput = NULL;
}


CSystemInfo::~CSystemInfo()
/*++
// Routine Description:
//        release the memory for member variables
//
// Arguments:none
//
// Return Value: none
//
--*/
{
    // connection to the remote system has to be closed which is established thru win32 api
    if ( m_bCloseConnection == TRUE )
    {
        CloseConnection( m_strServer );
    }

    // release memory
    DESTROY_ARRAY( m_arrData );

    // release the interfaces
    SAFE_RELEASE( m_pWbemLocator );
    SAFE_RELEASE( m_pWbemServices );

    // release the memory allocated for output columns
    FreeMemory( (LPVOID *)&m_pColumns );

    // uninitialize the com library
    CoUninitialize();
}


BOOL 
CSystemInfo::Initialize()
/*++
// Routine Description:
//        Initialize the data
//
// Arguments: none
//
// Return Value:
//         FALSE on failure 
//         TRUE on success
--*/
{
    //
    // memory allocations

    // allocate for storage dynamic array
    if ( m_arrData == NULL )
    {
        m_arrData = CreateDynamicArray();
        if ( m_arrData == NULL )
        {
            SetLastError( (DWORD)E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // make the array as a 2-dimensinal array
        DynArrayAppendRow( m_arrData, 0 );

        // put the default values
        for( DWORD dw = 0; dw < MAX_COLUMNS; dw++ )
        {
            switch( dw )
            {
            case CI_PROCESSOR:
            case CI_PAGEFILE_LOCATION:
            case CI_HOTFIX:
            case CI_NETWORK_CARD:
                {
                    // create the array
                    TARRAY arr = NULL;
                    arr = CreateDynamicArray();
                    if ( arr == NULL )
                    {
                        SetLastError( (DWORD)E_OUTOFMEMORY );
                        SaveLastError();
                        return FALSE;
                    }

                    // set the default value
                    DynArrayAppendString( arr, V_NOT_AVAILABLE, 0 );

                    // add this array to the array
                    DynArrayAppendEx2( m_arrData, 0, arr );

                    // break the switch
                    break;
                }

            default:
                // string type
                DynArrayAppendString2( m_arrData, 0, V_NOT_AVAILABLE, 0 );
            }
        }
    }

    //
    // allocate for output columns
    if ( AllocateColumns() == FALSE )
    {
        return FALSE;
    }

    //
    // init the console scree buffer structure to zero's
    // and then get the console handle and screen buffer information
    //
    // prepare for status display.
    // for this get a handle to the screen output buffer
    // but this handle will be null if the output is being redirected. so do not check
    // for the validity of the handle. instead try to get the console buffer information
    // only in case you have a valid handle to the output screen buffer
    //
    // NOTE:
    // here we will be dynamically decide whether to print the status messages onto STDOUT
    // or STDERR based on the redirection choosed by the user
    // By default, we will try to display the status messages onto STDOUT -- and in case
    // STDOUT is redirected, then we will print the messages onto STDERR
    // if even STDERR is redirected, then we wont display any status messages
    m_hOutput = NULL;
    SecureZeroMemory( &m_csbi, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );        // zero the memory structure

    // determine the redirection choice of the user and based on that get the handle to the
    // appropriate console file
    if ( IsConsoleFile( stdout ) == TRUE )
    {
        // stdout
        m_hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    }
    else if ( IsConsoleFile( stderr ) == TRUE )
    {
        // stderr
        m_hOutput = GetStdHandle( STD_ERROR_HANDLE );
    }

    // if we get any pointer to console file, then get the screen buffer info
    if ( m_hOutput != NULL )
    {
        GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
    }

    //
    // initialize the COM library
    if ( InitializeCom( &m_pWbemLocator ) == FALSE )
    {
        return FALSE;
    }

    // initialization is successful
    SetLastError( NO_ERROR );    // clear the error
    SetReason( L"" );           // clear the reason
    return TRUE;
}


BOOL 
CSystemInfo::AllocateColumns()
/*++
// Routine Description:
//          Allocates and adjust the columns to display
//
// Arguments: none
//
// Return Value:
//            FALSE on failure
//            TRUE on success
//
--*/
{
    // local variables
    PTCOLUMNS pCurrentColumn = NULL;

    //
    // allocate memory for columns
    m_pColumns = (TCOLUMNS*) AllocateMemory ( MAX_COLUMNS * sizeof( TCOLUMNS ));
    if ( m_pColumns == NULL )
    {
        // generate error info
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();

        // prepare the error message
        CHString strBuffer;
        strBuffer.Format( _T( "%s %s" ), TAG_ERROR, GetReason() );
        DISPLAY_MESSAGE( stderr, strBuffer );

        // return
        return FALSE;
    }

    // init with null's
    SecureZeroMemory( m_pColumns, sizeof( TCOLUMNS ) * MAX_COLUMNS );

    // host name
    pCurrentColumn = m_pColumns + CI_HOSTNAME;
    pCurrentColumn->dwWidth = COLWIDTH_HOSTNAME;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_HOSTNAME, MAX_STRING_LENGTH );

    // OS Name
    pCurrentColumn = m_pColumns + CI_OS_NAME;
    pCurrentColumn->dwWidth = COLWIDTH_OS_NAME;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_OS_NAME, MAX_STRING_LENGTH );

    // OS Version
    pCurrentColumn = m_pColumns + CI_OS_VERSION;
    pCurrentColumn->dwWidth = COLWIDTH_OS_VERSION;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_OS_VERSION, MAX_STRING_LENGTH );

    // OS Manufacturer
    pCurrentColumn = m_pColumns + CI_OS_MANUFACTURER;
    pCurrentColumn->dwWidth = COLWIDTH_OS_MANUFACTURER;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_OS_MANUFACTURER, MAX_STRING_LENGTH );

    // OS Configuration
    pCurrentColumn = m_pColumns + CI_OS_CONFIG;
    pCurrentColumn->dwWidth = COLWIDTH_OS_CONFIG;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_OS_CONFIG, MAX_STRING_LENGTH );

    // OS Build Type
    pCurrentColumn = m_pColumns + CI_OS_BUILDTYPE;
    pCurrentColumn->dwWidth = COLWIDTH_OS_BUILDTYPE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_OS_BUILDTYPE, MAX_STRING_LENGTH );

    // Registered Owner
    pCurrentColumn = m_pColumns + CI_REG_OWNER;
    pCurrentColumn->dwWidth = COLWIDTH_REG_OWNER;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_REG_OWNER, MAX_STRING_LENGTH );

    // Registered Organization
    pCurrentColumn = m_pColumns + CI_REG_ORG;
    pCurrentColumn->dwWidth = COLWIDTH_REG_ORG;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_REG_ORG, MAX_STRING_LENGTH );

    // Product ID
    pCurrentColumn = m_pColumns + CI_PRODUCT_ID;
    pCurrentColumn->dwWidth = COLWIDTH_PRODUCT_ID;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_PRODUCT_ID, MAX_STRING_LENGTH );

    // install date
    pCurrentColumn = m_pColumns + CI_INSTALL_DATE;
    pCurrentColumn->dwWidth = COLWIDTH_INSTALL_DATE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_INSTALL_DATE, MAX_STRING_LENGTH );

    // system up time
    pCurrentColumn = m_pColumns + CI_SYSTEM_UPTIME;
    pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_UPTIME;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_UPTIME, MAX_STRING_LENGTH );

    // system manufacturer
    pCurrentColumn = m_pColumns + CI_SYSTEM_MANUFACTURER;
    pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_MANUFACTURER;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_MANUFACTURER, MAX_STRING_LENGTH );

    // system model
    pCurrentColumn = m_pColumns + CI_SYSTEM_MODEL;
    pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_MODEL;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_MODEL, MAX_STRING_LENGTH );

    // system type
    pCurrentColumn = m_pColumns + CI_SYSTEM_TYPE;
    pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_TYPE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_TYPE, MAX_STRING_LENGTH );

    // processor
    pCurrentColumn = m_pColumns + CI_PROCESSOR;
    pCurrentColumn->dwWidth = COLWIDTH_PROCESSOR;
    pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_PROCESSOR, MAX_STRING_LENGTH );

    // bios version
    pCurrentColumn = m_pColumns + CI_BIOS_VERSION;
    pCurrentColumn->dwWidth = COLWIDTH_BIOS_VERSION;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_BIOS_VERSION, MAX_STRING_LENGTH );

    // windows directory
    pCurrentColumn = m_pColumns + CI_WINDOWS_DIRECTORY;
    pCurrentColumn->dwWidth = COLWIDTH_WINDOWS_DIRECTORY;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_WINDOWS_DIRECTORY, MAX_STRING_LENGTH );

    // system directory
    pCurrentColumn = m_pColumns + CI_SYSTEM_DIRECTORY;
    pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_DIRECTORY;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_DIRECTORY, MAX_STRING_LENGTH );

    // boot device
    pCurrentColumn = m_pColumns + CI_BOOT_DEVICE;
    pCurrentColumn->dwWidth = COLWIDTH_BOOT_DEVICE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_BOOT_DEVICE, MAX_STRING_LENGTH );

    // system locale
    pCurrentColumn = m_pColumns + CI_SYSTEM_LOCALE;
    pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_LOCALE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_LOCALE, MAX_STRING_LENGTH );

    // input locale
    pCurrentColumn = m_pColumns + CI_INPUT_LOCALE;
    pCurrentColumn->dwWidth = COLWIDTH_INPUT_LOCALE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_INPUT_LOCALE, MAX_STRING_LENGTH );

    // time zone
    pCurrentColumn = m_pColumns + CI_TIME_ZONE;
    pCurrentColumn->dwWidth = COLWIDTH_TIME_ZONE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_TIME_ZONE, MAX_STRING_LENGTH );

    // total physical memory
    pCurrentColumn = m_pColumns + CI_TOTAL_PHYSICAL_MEMORY;
    pCurrentColumn->dwWidth = COLWIDTH_TOTAL_PHYSICAL_MEMORY;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_TOTAL_PHYSICAL_MEMORY, MAX_STRING_LENGTH );

    // available physical memory
    pCurrentColumn = m_pColumns + CI_AVAILABLE_PHYSICAL_MEMORY;
    pCurrentColumn->dwWidth = COLWIDTH_AVAILABLE_PHYSICAL_MEMORY;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_AVAILABLE_PHYSICAL_MEMORY, MAX_STRING_LENGTH );

    // virtual memory max
    pCurrentColumn = m_pColumns + CI_VIRTUAL_MEMORY_MAX;
    pCurrentColumn->dwWidth = COLWIDTH_VIRTUAL_MEMORY_MAX;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_VIRTUAL_MEMORY_MAX, MAX_STRING_LENGTH );

    // virtual memory available
    pCurrentColumn = m_pColumns + CI_VIRTUAL_MEMORY_AVAILABLE;
    pCurrentColumn->dwWidth = COLWIDTH_VIRTUAL_MEMORY_AVAILABLE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_VIRTUAL_MEMORY_AVAILABLE, MAX_STRING_LENGTH );

    // virtual memory usage
    pCurrentColumn = m_pColumns + CI_VIRTUAL_MEMORY_INUSE;
    pCurrentColumn->dwWidth = COLWIDTH_VIRTUAL_MEMORY_INUSE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_VIRTUAL_MEMORY_INUSE, MAX_STRING_LENGTH );

    // page file location
    pCurrentColumn = m_pColumns + CI_PAGEFILE_LOCATION;
    pCurrentColumn->dwWidth = COLWIDTH_PAGEFILE_LOCATION;
    pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_PAGEFILE_LOCATION, MAX_STRING_LENGTH );

    // domain
    pCurrentColumn = m_pColumns + CI_DOMAIN;
    pCurrentColumn->dwWidth = COLWIDTH_DOMAIN;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_DOMAIN, MAX_STRING_LENGTH );

    // logon server
    pCurrentColumn = m_pColumns + CI_LOGON_SERVER;
    pCurrentColumn->dwWidth = COLWIDTH_LOGON_SERVER;
    pCurrentColumn->dwFlags = SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_LOGON_SERVER, MAX_STRING_LENGTH );

    // hotfix
    pCurrentColumn = m_pColumns + CI_HOTFIX;
    pCurrentColumn->dwWidth = COLWIDTH_HOTFIX;
    pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_HOTFIX, MAX_STRING_LENGTH );

    // network card
    pCurrentColumn = m_pColumns + CI_NETWORK_CARD;
    pCurrentColumn->dwWidth = COLWIDTH_NETWORK_CARD;
    pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING;
    StringCopy( pCurrentColumn->szColumn, COLHEAD_NETWORK_CARD, MAX_STRING_LENGTH );

    // return success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\clearmem\clearmem.c ===
/*** ClearMem.C - Win 32 clear memory
 *
 *
 * Title:
 *
 *	ClearMem - Win 32 clear memory Main File
 *
 *      Copyright (c) 1990-1994, Microsoft Corporation.
 *	Russ Blake.
 *
 *
 * Description:
 *
 *	This is the main part of the clear memory tool.
 *	It takes as a parameter a file to use to flush the memory.
 *
 *	     Usage:  clearmem filename [-q] [-d]
 *
 *			filename: name of file to use to flush the
 *				  memory.  Should be at least 128kb.
 *
 *
 *	The Clear Memory is organized as follows:
 *
 *	     o ClearMem.c ........ Tools main body
 *	     o ClearMem.h
 *
 *	     o cmUtl.c ..... clear memory utility routines
 *	     o cmUtl.h
 *
 *
 *
 *
 *
 *
 * Modification History:
 *
 *	90.03.08  RussBl -- Created (copy of response probe)
 *	92.07.24  MarkLea -- Added -t -w -b switches
 *					  -- Modified AccessSection algorithm.
 * 93.05.12  HonWahChan
 *               -- used total physical memory (instead of SECTION_SIZE);
 *               -- used GetTickCount() instead of timer calls.
 *
 *
 */

char *VERSION = "1.17x  (93.05.12)";



/* * * * * * * * * * * * *  I N C L U D E    F I L E S  * * * * * * * * * * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "clearmem.h"
#include "cmUtl.h"



/* * * * * * * * * *  G L O B A L   D E C L A R A T I O N S  * * * * * * * * */
/* none */



/* * * * * * * * * *  F U N C T I O N   P R O T O T Y P E S  * * * * * * * * */

       __cdecl main        (int argc, char *argv[]);
STATIC RC Initialize     (int argc, char *argv[]);
STATIC RC Cleanup	 (void);
STATIC RC FlushCache	 (void);
STATIC RC AccessSection  (void);
STATIC RC ReadFlushFile  (void);
     void ParseCmdLine   (int argc, char *argv[]);
	 void Usage          (char *argv[], char *);


/* * * * * * * * * * *  G L O B A L    V A R I A B L E S  * * * * * * * * * */
BOOL   	bQuiet,
		bRead = TRUE,
		bWrite;
BOOL   	bDebugBreakOnEntry;
ULONG  	ulMemSize,
		ulPageCount,
		ulTouchCount = 1;

ULONG_PTR	ulSectionSize;
/* * * * * *  E X P O R T E D   G L O B A L    V A R I A B L E S  * * * * * */
/* none */





/*********************************  m a i n  **********************************
 *
 *      main(argc, argv)
 *
 *      ENTRY   argc - number of input arguments
 *              argv - contains command line arguments
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

__cdecl main (int argc, char *argv[])
{
    RC	    rc;
    DWORD    ulFlushTime;	     // Total time for flushing
		
    ParseCmdLine (argc, argv);
	if(ulMemSize){
		ulSectionSize = ulMemSize * 1024 * 1024;
	}
	else {
      // get total physical memory size in the system
      MEMORYSTATUS   MemStat;

      GlobalMemoryStatus (&MemStat);
      ulSectionSize = MemStat.dwTotalPhys;
	}

//	ExitProcess(STATUS_SUCCESS);

    if (bDebugBreakOnEntry)
        DebugBreak();
	
	if (!bQuiet) {
        //
        // set initial total flushing time
        //
        ulFlushTime = GetTickCount() ;
    }


    //
    // Do initialization
    //
    rc = Initialize(argc, argv);
    if (Failed(rc, __FILE__, __LINE__, "main() - Initialize")) {
        return(rc);
    }

    //
    // Now flush the cache
    //

	rc = FlushCache();

    if (Failed(rc, __FILE__, __LINE__, "main() - FlushCache")) {
        return(rc);
    }

    if (!bQuiet) {
        ulFlushTime = GetTickCount() - ulFlushTime;
        printf("Elapsed Time for Flushing: %lu milliseconds \n", ulFlushTime);
    }
    //
    // Cleanup
    //
    rc = Cleanup();
    if (Failed(rc, __FILE__, __LINE__, "main() - Cleanup")) {
        return(rc);
    }

#ifdef CF_DEBUG_L1
    if (!bQuiet) {
        printf("| ==> Exiting PROCESS:  %s \n", CF_EXE );
    }
#endif

    if (bDebugBreakOnEntry)
		DebugBreak();
    ExitProcess(STATUS_SUCCESS);

} /* main() */





/***************************  I n i t i a l i z e  ****************************
 *
 *      Initialize(argc, argv) -
 *              Performs basic initializations (getting input arguments,
 *              creating semaphores, display debug info, ...)
 *
 *      ENTRY   argc - number of input arguments
 *              argv - list of input arguments
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

STATIC RC Initialize (int argc, char *argv[])
{
    int        i;

    //
    // Sign on message
    //

    if (!bQuiet) {
        printf("\nNT Win 32 Clear Memory.\n"
               "Copyright 1990-1993, Microsoft Corporation.\n"
               "Version %s\n\n", VERSION);
    }

#ifdef CF_DEBUG_L1
    //
    // Display debugging info
    //
    if (!bQuiet) {
        printf("/-------------------------------\n");
        printf("| %s:\n", CF_EXE);
        printf("|\n");
        for (i=0; i<argc; i++) {
	          printf("|         o argv[%i]=%s\n", i, argv[i]);
        }
        printf("\\-------------------------------\n");
    }
#else
    i;      // Prevent compiler from complaining about unreferenced variable
#endif



    return(STATUS_SUCCESS);

} /* Initialize() */




/******************************  C l e a n u p  *******************************
 *
 *	Cleanup(void) -
 *              Basic cleanup. (closing semaphores, freeing memory, ...)
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

STATIC RC Cleanup (void)
{

    return(STATUS_SUCCESS);

} /* Cleanup() */




/************************  F l u s h C a c h e	 *****************************
 *
 *	FlushCache(void) -
 *		Flushes the file cache by createing a large data
 *		segment, and touching every page to shrink the cache
 *		to 128kb, then reading in a 128kb file to clear the
 *		remaining cache
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

RC FlushCache (void)
{

RC    rc;

    //
    // First touch all the data pages
    //

#ifdef CF_DEBUG_L1
    if (!bQuiet) {
       printf("| ==> Start Flushing:  Access Section of size: %lu \n",
	         ulSectionSize );
    }
#endif

    rc = AccessSection();
    if (Failed(rc, __FILE__, __LINE__, "FlushCache() - AccessSection")) {
        return(rc);
    }

    //
    // Next read the flushing file to what's left of the cache
    //

#ifdef CF_DEBUG_L1
    if (!bQuiet) {
        printf("| ==> Start Flushing:  Read File: %s \n",
	         "FLUSH1" );
    }
#endif
//	while (ulTouchCount) {
		rc = ReadFlushFile();
//		--ulTouchCount;

		if (Failed(rc, __FILE__, __LINE__, "FlushCache() - Read Flush File")) {
			return(rc);
		}
//	}



    return(STATUS_SUCCESS);

} /* FlushCache() */




/************************  A c c e s s S e c t i o n  ************************
 *
 *	AccessSection(void) -
 *		Touches every page in the data section
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

RC AccessSection (void)
{

	RC    rc;
	ULONG uli,
                  ulj;
	PULONG	puSectionData;			//Points to data section for flushing memory

    //
    // Allocate virtual memory
    //
    if ( (puSectionData = (PULONG)VirtualAlloc(NULL,	       // New allocation
				    ulSectionSize,      // Size in bytes
				    MEM_RESERVE | MEM_COMMIT,
				    PAGE_READWRITE)) == NULL ) {	//Changed to READWRITE
        rc = GetLastError();
	Failed(rc, __FILE__, __LINE__, "AccessSection() - VirtualAlloc");
        return(rc);
    }

    //
    // Now touch every page of the section
    //
	if(bWrite){
		
		while (ulTouchCount) {
			puSectionData = &puSectionData[0];
			for ( uli = 0; uli < (ulSectionSize-1); uli+=sizeof(ULONG)) {
				*puSectionData = 0xFFFFFFFF;
				++puSectionData;
			}
			--ulTouchCount;
		}
	}
	if(bRead) {
//        DbgBreakPoint();
                ulj = 0;
		while (ulTouchCount) {
			for ( uli = 0; uli < ulSectionSize; uli += PAGESIZE ) {
			 ulj += *(puSectionData+(uli/sizeof(ULONG)));
			}
			--ulTouchCount;
		}
	}

	return(STATUS_SUCCESS);

} /* AccessSection() */


/************************  R e a d F l u s h F i l e  ************************
 *
 *	ReadFlushFile(void) -
 *		Touches every page in the flush file, non-sequentially
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

CHAR  chBuffer[PAGESIZE];

RC ReadFlushFile (void)
{
	RC    rc;
	SHORT sNewPos;
	ULONG uli;
	ULONG ulNumReads,
		  ulNumBytesRead;
	BOOL  bFileCreated;
	SHORT sFile;				// Indicates which of the three
								// files is being used to flush
	CHAR  chFlushFileName1[] = "FLUSH1";
	CHAR  chFlushFileName2[] = "FLUSH2";
	CHAR  chFlushFileName3[] = "FLUSH3";

	CHAR *pchFlushFileName[3] = { chFlushFileName1,
								  chFlushFileName2,
								  chFlushFileName3 };
	FILE *pfFlushFile;			// Points to the file used for
								// flushing the cache
	FILE *pfSaveFile[3];		// Remembers them for the close
	CHAR  achErrMsg[LINE_LEN];

    //
    // Assume no file is created: all three already exist
    //

    bFileCreated = FALSE;

    for (sFile = 0; sFile < NUM_FILES; sFile++) {

	//
	// First attempt to create the file
	//

	if ( (pfFlushFile = CreateFile(pchFlushFileName[sFile],
				       GENERIC_WRITE,
				       FILE_SHARE_READ,
				       NULL,
				       CREATE_NEW,
				       0,
				       0))
		  == INVALID_HANDLE_VALUE ) {

	    //
	    // Could not create the file
	    //

	    rc = GetLastError();

	    if (!(rc == ERROR_FILE_EXISTS || rc == ERROR_ACCESS_DENIED)) {

		//
		// Cannot create a new file
		//

		sprintf(achErrMsg,
			"ReadFlushFile() - Error creating %s: %lu",
			pchFlushFileName[sFile], rc);
		Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
		return(FILEARG_ERR);
	    }
	}
	else {

	    //
	    // New file has been created without difficulty
	    // Fill it with data
	    //

	    bFileCreated = TRUE;

	    for (uli = 0; uli < FLUSH_FILE_SIZE; uli += PAGESIZE) {
		if (!WriteFile(pfFlushFile,
			       &chBuffer,
			       PAGESIZE,
			       &ulNumBytesRead,
			       RESERVED_NULL)) {
		    rc = GetLastError();
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - Write File Record to New File");
		    return(rc);
		}
	    }

	    //
	    // Now close it for write, so we can open it for read access
	    //

	    if (!CloseHandle(pfFlushFile)) {
		rc = GetLastError();
		sprintf(achErrMsg, "ReadFlushFile() - Error closing %s: %lu",
			pchFlushFileName[sFile], rc);
		Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
		return(FILEARG_ERR);
	    }
	}
    }

    if (bFileCreated) {

	//
	// Wrote at least 1 file: wait for lazy writer to flush
	// data to disk
	//

	Sleep(LAZY_DELAY);

    }

    for (sFile = 0; sFile < NUM_FILES; sFile++) {

	if ((pfFlushFile = CreateFile( pchFlushFileName[sFile],
				       GENERIC_READ,
				       FILE_SHARE_READ,
				       NULL,
				       OPEN_EXISTING,
				       0,
				       0))
		  == INVALID_HANDLE_VALUE) {

	    //
	    // Cannot open an existing file
	    //

	    rc = GetLastError();
	    sprintf(achErrMsg,
		    "ReadFlushFile() - Error opening %s: %lu",
		    pchFlushFileName[sFile], rc);
	    Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
	    return(FILEARG_ERR);
	}

	//
	// Remember the handle for the close
	//

	pfSaveFile[sFile] = pfFlushFile;

	//
	// Read first record
	//

	if (!ReadFile( pfFlushFile,
		       &chBuffer,
		       1,
		       &ulNumBytesRead,
		       RESERVED_NULL)) {
	    rc = GetLastError();
	    Failed(rc, __FILE__, __LINE__,
		   "ReadFlushFile() - Read First Record");
	    return(rc);
	}



	ulNumReads = 1;


	while (++ulNumReads <= ulPageCount) {
	    if (ulNumReads & 1) {

		//
		// Read an odd record: read previous record
		// Move backward to start of prior record: -1 (start of
		// this record) -4096 (start of previous record) = -4097
		//

		if (SetFilePointer( pfFlushFile, -4097, 0L, FILE_CURRENT) == (DWORD)-1) {
		    rc = GetLastError();
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - Read Odd Record");
		    return(rc);
		}

		if (!ReadFile( pfFlushFile,
			       &chBuffer,
			       1,
			       &ulNumBytesRead,
			       RESERVED_NULL)) {
		    rc = GetLastError();
		    if (rc == ERROR_HANDLE_EOF)
			break;
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - SetPos Odd Record");
		    return(rc);
		}
	    }
	    else {

		//
		// Read an even record: read the one after the next record
		// Move forward to end of this record (4095) + 2 more
		// (8192) = 12287.  (But second record is special, 'cause
		// can't set file pointer negative initially.)
		//

		sNewPos = (SHORT) (ulNumReads == 2L ? 8191 : 12287);


		if (SetFilePointer( pfFlushFile, sNewPos, 0L, FILE_CURRENT) == (DWORD) -1) {
		    rc = GetLastError();
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - Read Even Record");
		    return(rc);
		}

		if (!ReadFile( pfFlushFile,
			       &chBuffer,
			       1,
			       &ulNumBytesRead,
			       RESERVED_NULL)) {
		    rc = GetLastError();
		    if (rc == ERROR_HANDLE_EOF)
			break;
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - SetPos Even Record");
		    return(rc);
		}
	    }
	}
    }

    for (sFile = 0; sFile < NUM_FILES; sFile++) {

	//
	// Close the files
	//

	if (!CloseHandle(pfSaveFile[sFile])) {
	    rc = GetLastError();
	    sprintf(achErrMsg, "ReadFlushFile() - Error closing %s: %lu",
		    pchFlushFileName[sFile], rc);
	    Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
	    return(FILEARG_ERR);
	}
    }

    return(STATUS_SUCCESS);

} /* ReadFlushFile() */

/************************  R e a d F l u s h F i l e  ************************
 *
 *	parseCmdLine(void) -
 *		For Parsing the command line switches
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

 VOID ParseCmdLine (int argc, char *argv[])
 {
     char     *pchParam;
     int      iParamCount;

     for ( iParamCount = 1; iParamCount < argc; iParamCount++) {

         if (argv[iParamCount][0] == '-') {    /* process options */

             pchParam = &(argv[iParamCount][1]);

             while (*pchParam) {
                 switch (*pchParam) {
                     case '?':
                         Usage (argv, " ");
                         break;

                     case 'Q':
                     case 'q':
                         pchParam++;
                         bQuiet = TRUE;
                         break;

                     case 'd':
                     case 'D':   /* print banner */
                         pchParam++;						
                         bDebugBreakOnEntry = TRUE;
                         break;

					 case 'm':
					 case 'M':
						 ulMemSize = (ULONG)atol(&pchParam[1]);
						 if (ulPageCount > 32) {
							 Usage (argv, "Mem size must be less than the amount of physical memory!");
						 }
						 pchParam += strlen(pchParam);
						 break;

					 case 'p':
					 case 'P':
						 ulPageCount = (ULONG)atol(&pchParam[1]);
						 if (ulPageCount > 63) {
							 Usage (argv, "Page Count must be 63 or less!");
						 }
						 pchParam += strlen(pchParam);
						 break;


					 case 't':
					 case 'T':
						 ulTouchCount = (ULONG)atol(&pchParam[1]);
						 pchParam += strlen(pchParam);
						 break;

					 case 'w':
					 case 'W':
						 bWrite = TRUE;
						 bRead = FALSE;
                         break;

					 case 'b':
					 case 'B':
						 bRead = TRUE;
						 bWrite = TRUE;
						 break;


					 default:
                         Usage (argv, "unknown flag");
                         break;

                 }  // end of switch
             }      // end of while
         }          // end of if
     }              // end of for...

	 if(!ulPageCount){
		 ulPageCount = NUM_FLUSH_READS;
	 }
     return;
 }

/*
 *
 *    Usage   - generates a usage message and an error message
 *              and terminates program.
 *
 *    Accepts - argv     - char *[]
 *              message  - char * - an error message
 *
 *    Returns - nothing.
 *
 */

 VOID Usage (char *argv[], char *message)
 {

     printf( "%s\n", message);
     printf( "usage: ");
     printf( "%s [-q] [-d] [-mx] [-px] [-w] [-tx]\n", argv[0]);
     printf( "\t-? :  This message\n");
     printf( "\t-q :  Quiet mode - Nothing printed.\n");
	 printf( "\t-d :  Debug break on Entry into and Exit from app.\n");
	 printf( "\t-m :  Number of megabytes to allocate.\n");
    printf( "\t   :  (default is to use all physical memory.)\n");
	 printf( "\t-p :  Number of pages to read (must be less than 63).\n");
	 printf( "\t-w :  Write to the virtual memory section.\n");
	 printf( "\t-b :  Read and Write the virtual memory section.\n");
	 printf( "\t-t :  Times to touch a page.\n");
	 printf( "**DEFAULT: clearmem -p63 -t1\n");
     exit (1);
 }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\systeminfo\parseandshow.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      parseAndshow.cpp
//
//  Abstract:
//
//      This module implements the command-line parsing and validating the filters
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 27-Dec-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 27-Dec-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "systeminfo.h"

//
// local function prototypes
//


BOOL
CSystemInfo::ProcessOptions(
                            IN DWORD argc,
                            IN LPCTSTR argv[]
                            )
/*++
// Routine Description:
//      processes and validates the command line inputs
//
// Arguments:
//      [ in ] argc          : no. of input arguments specified
//      [ in ] argv          : input arguments specified at command prompt
//
// Return Value:
//      TRUE  : if inputs are valid
//      FALSE : if inputs were errorneously specified
//
--*/
{
    // local variables
    CHString strFormat;
    BOOL bNoHeader = FALSE;
    BOOL bNullPassword = FALSE;

    // temporary local variables
    PTCMDPARSER2 pOptionServer = NULL;
    PTCMDPARSER2 pOptionUserName = NULL;
    PTCMDPARSER2 pOptionPassword = NULL;
    PTCMDPARSER2 pOptionFormat = NULL;


    // local variables
    PTCMDPARSER2 pOption = NULL;
    TCMDPARSER2 pcmdOptions[ MAX_OPTIONS ];

    //
    // set all the fields to 0
    SecureZeroMemory( pcmdOptions, sizeof( TCMDPARSER2 ) * MAX_OPTIONS );

    // -? option
    pOption = &pcmdOptions[ OI_USAGE ];
    StringCopyA( pOption->szSignature, "PARSER2", 8 );
    pOption->dwCount = 1;
    pOption->dwFlags = CP2_USAGE;
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pValue = &m_bUsage;
    pOption->pwszOptions = OPTION_USAGE;

    // -s option
    pOption = &pcmdOptions[ OI_SERVER ];
    StringCopyA( pOption->szSignature, "PARSER2", 8 );
    pOption->dwCount = 1;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_SERVER;

    // -u option
    pOption = &pcmdOptions[ OI_USERNAME ];
    StringCopyA( pOption->szSignature, "PARSER2", 8 );
    pOption->dwCount = 1;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_USERNAME;

    // -p option
    pOption = &pcmdOptions[ OI_PASSWORD ];
    StringCopyA( pOption->szSignature, "PARSER2", 8 );
    pOption->dwCount = 1;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_PASSWORD;

    // -fo option
    pOption = &pcmdOptions[ OI_FORMAT ];
    StringCopyA( pOption->szSignature, "PARSER2", 8 );
    pOption->dwCount = 1;
    pOption->dwFlags = CP2_ALLOCMEMORY| CP2_MODE_VALUES| CP2_VALUE_TRIMINPUT| CP2_VALUE_NONULL;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_FORMAT;
    pOption->pwszValues = OVALUES_FORMAT;

    // -nh option
    pOption = &pcmdOptions[ OI_NOHEADER ];
    StringCopyA( pOption->szSignature, "PARSER2", 8 );
    pOption->dwCount = 1;
    pOption->dwFlags = 0;
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pValue = &bNoHeader;
    pOption->pwszOptions = OPTION_NOHEADER;


    //
    // now, check the mutually exclusive options
    pOptionServer = pcmdOptions + OI_SERVER;
    pOptionUserName = pcmdOptions + OI_USERNAME;
    pOptionPassword = pcmdOptions + OI_PASSWORD;
    pOptionFormat = pcmdOptions + OI_FORMAT;

    //
    // do the parsing
    //
    if ( DoParseParam2( argc, argv, -1, MAX_OPTIONS, pcmdOptions, 0 ) == FALSE )
    {
        return FALSE;           // invalid syntax
    }

    //check whether /p without any value is specified or not..
    if ( NULL == pOptionPassword->pValue )
    {
        bNullPassword = TRUE;
    }

    // release the buffers
    m_strServer   = (LPWSTR)pOptionServer->pValue;
    m_strUserName = (LPWSTR)pOptionUserName->pValue;
    m_strPassword = (LPWSTR)pOptionPassword->pValue;
    strFormat = (LPWSTR)pOptionFormat->pValue;


    // since CHString assignment does the copy operation..
    // release the buffers allocated by common library
    FreeMemory( &pOptionServer->pValue );
    FreeMemory( &pOptionUserName->pValue );
    FreeMemory( &pOptionPassword->pValue );
    FreeMemory( &pOptionFormat->pValue );

    // check the usage option
    if ( m_bUsage && ( argc > 2 ) )
    {
        // no other options are accepted along with -? option
        SetLastError( (DWORD)MK_E_SYNTAX );
        SetReason( ERROR_INVALID_USAGE_REQUEST );
        return FALSE;
    }
    else if ( m_bUsage == TRUE )
    {
        // should not do the furthur validations
        return TRUE;
    }

    // "-u" should not be specified without machine names
    if ( pOptionServer->dwActuals == 0 && pOptionUserName->dwActuals != 0 )
    {
        // invalid syntax
        SetReason( ERROR_USERNAME_BUT_NOMACHINE );
        return FALSE;           // indicate failure
    }

    // "-p" should not be specified without "-u"
    if ( pOptionUserName->dwActuals == 0 && pOptionPassword->dwActuals != 0 )
    {
        // invalid syntax
        SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
        return FALSE;           // indicate failure
    }

    // determine the format in which the process information has to be displayed
    m_dwFormat = SR_FORMAT_LIST;        // default format
    if ( strFormat.CompareNoCase( TEXT_FORMAT_LIST ) == 0 )
    {
        m_dwFormat = SR_FORMAT_LIST;
    }
    else if ( strFormat.CompareNoCase( TEXT_FORMAT_TABLE ) == 0 )
    {
        m_dwFormat = SR_FORMAT_TABLE;
    }
    else if ( strFormat.CompareNoCase( TEXT_FORMAT_CSV ) == 0 )
    {
        m_dwFormat = SR_FORMAT_CSV;
    }

    // user might have given no header option for a LIST format which is invalid
    if ( bNoHeader == TRUE && m_dwFormat == SR_FORMAT_LIST )
    {
        // invalid syntax
        SetReason( ERROR_NH_NOTSUPPORTED );
        return FALSE;                               // indicate failure
    }

    // check for the no header info and apply to the format variable
    if ( bNoHeader == TRUE )
    {
        m_dwFormat |= SR_NOHEADER;
    }

    // check whether caller should accept the password or not
    // if user has specified -s (or) -u and no "-p", then utility should accept password
    // the user will be prompted for the password only if establish connection
    // is failed without the credentials information

    if ( pOptionPassword->dwActuals != 0 )
    {
        if (m_strPassword.Compare( L"*" ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            m_bNeedPassword = TRUE;
        }
        else if ( TRUE == bNullPassword )
        {
            m_strPassword = L"*";
            // user wants the utility to prompt for the password before trying to connect
            m_bNeedPassword = TRUE;
        }
    }
    else if ( (pOptionPassword->dwActuals == 0 &&
              (pOptionServer->dwActuals != 0 || pOptionUserName->dwActuals != 0)) )
    {
        // utility needs to try to connect first and if it fails then prompt for the password
        m_bNeedPassword = TRUE;
        m_strPassword.Empty();
    }

    // command-line parsing is successfull
    return TRUE;
}


VOID
CSystemInfo::ShowOutput(
                        IN DWORD dwStart,
                        IN DWORD dwEnd
                        )
/*++
// Routine Description:
//      show the system configuration information
//
// Arguments:
//      [in] dwStart  : start index
//      [in] dwEnd    : end index
//
// Return Value:
//      NONE
//
--*/
{
    // local variables
    PTCOLUMNS pColumn = NULL;

    // dynamically show / hide columns on need basis
    for( DWORD dw = 0; dw < MAX_COLUMNS; dw++ )
    {
        // point to the column info
        pColumn = m_pColumns + dw;

        // remove the hide flag from the column
        pColumn->dwFlags &= ~( SR_HIDECOLUMN );

        // now if the column should not be shown, set the hide flag)
        if ( dw < dwStart || dw > dwEnd )
            pColumn->dwFlags |= SR_HIDECOLUMN;
    }

    // if the data is being displayed from the first line onwards,
    // add a blank line.. If the format is CSV then there is no need 
    // to display any blank line..
    if ( ( dwStart == 0 ) && (( m_dwFormat & SR_FORMAT_CSV ) != SR_FORMAT_CSV) )
    {
        ShowMessage( stdout, L"\n" );
    }

    //
    // display the results
    ShowResults( MAX_COLUMNS, m_pColumns, m_dwFormat, m_arrData );
}


VOID CSystemInfo::ShowUsage()
/*++
// Routine Description:
//      This function fetches usage information from resource file and display it
//
// Arguments:
//      NONE
//
// Return Value:
//      NONE
--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = ID_HELP_START; dw <= ID_HELP_END; dw++ )
    {
        ShowMessage( stdout, GetResString( dw ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdevent\cmdevent.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#define MAX_WAIT_HANDLES MAXIMUM_WAIT_OBJECTS

__cdecl
main (c, v)
int c;
char *v[];
{
    HANDLE hEvents[ 4 * MAX_WAIT_HANDLES ];
    char *EventNames[ 4 * MAX_WAIT_HANDLES ];
    char *s;
    ULONG nEvents, dwWaitResult;
    BOOLEAN fWaitAny = FALSE;
    BOOLEAN fWait = FALSE;
    BOOLEAN fVerbose = FALSE;
    BOOLEAN fUsage = TRUE;

    nEvents = 0;
    while (--c) {
        s = *++v;
        if (!_stricmp( s, "-a" )) {
            fWaitAny = TRUE;
            fWait = TRUE;
            }
        else
        if (!_stricmp( s, "-w" ))
            fWait = TRUE;
        else
        if (!_stricmp( s, "-v" ))
            fVerbose = TRUE;
        else
        if (nEvents == (4 * MAX_WAIT_HANDLES)) {
            fprintf( stderr, "CMDEVENT: Cant wait on more than %u events.\n",
                     4 * MAX_WAIT_HANDLES
                   );
            exit( -1 );
            }
        else {
            fUsage = FALSE;
            if (nEvents == MAX_WAIT_HANDLES && !fVerbose) {
                fprintf( stderr, "CMDEVENT: Waiting on more than %u events.  Forcing -v\n",
                         MAX_WAIT_HANDLES
                       );
                fVerbose = TRUE;
                }

            {
                char *d;

                d = s;
                while (*d) {
                    if (*d == '\\') {
                        *d = '_';
                        }
                    d++;
                    }
            }
            hEvents[ nEvents ] = fWait ? CreateEvent( NULL, TRUE, FALSE, s )
                                       : OpenEvent( EVENT_ALL_ACCESS, FALSE, s );

            if (hEvents[ nEvents ] == NULL) {
                fprintf( stderr, "CMDEVENT: Unable to %s event named '%s' - %u\n",
                         fWait ? "create" : "open",
                         s,
                         GetLastError()
                       );
                exit( -1 );
                break;
                }
            else
            if (!fWait) {
                if (!SetEvent( hEvents[ nEvents ] )) {
                    fprintf( stderr, "CMDEVENT: Unable to signal event named '%s' - %u\n",
                             s,
                             GetLastError()
                           );
                    }
                }
            else {
                EventNames[ nEvents ] = s;
                nEvents += 1;
                }
            }
        }

    if (fUsage) {
        fprintf( stderr, "usage: CMDEVENT [-w] [-v] EventName(s)...\n" );
        exit( -1 );
        }
    else
    if (fWait) {
        if (fVerbose) {
            fprintf( stderr, "\nWaiting for %u events:", nEvents );
            fflush( stderr );
            }

        while (nEvents) {
            dwWaitResult = WaitForMultipleObjects( nEvents > MAX_WAIT_HANDLES ?
                                                        MAX_WAIT_HANDLES :
                                                        nEvents,
                                                   hEvents,
                                                   FALSE,
                                                   INFINITE
                                                 );
            if (dwWaitResult == WAIT_FAILED) {
                fprintf( stderr, "\nCMDEVENT: Unable to wait for event(s) - %u\n",
                         GetLastError()
                       );
                exit( -1 );
                }
            else
            if (dwWaitResult < nEvents) {
                CloseHandle( hEvents[ dwWaitResult ] );

                if (fVerbose) {
                    fprintf( stderr, " %s", EventNames[ dwWaitResult ] );
                    fflush( stderr );
                    }

                if (fWaitAny) {
                    exit( dwWaitResult+1 );
                    }

                nEvents -= 1;
                if (dwWaitResult < nEvents) {
                    memmove( &hEvents[ dwWaitResult ],
                             &hEvents[ dwWaitResult+1 ],
                             (nEvents - dwWaitResult + 1) * sizeof( hEvents[ 0 ] )
                           );
                    memmove( &EventNames[ dwWaitResult ],
                             &EventNames[ dwWaitResult+1 ],
                             (nEvents - dwWaitResult + 1) * sizeof( EventNames[ 0 ] )
                           );
                    }
                }
            }

        if (fVerbose) {
            fprintf( stderr, "\n" );
            }
        }

    exit( 0 );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\systeminfo\resource.h ===
#define IDS_FMT_KILOBYTES               101
#define IDS_FMT_UPTIME                  102
#define IDS_FMT_OSVERSION               103
#define IDS_FMT_MEGABYTES               104
#define IDS_FMT_PROCESSOR_TOTAL         105
#define IDS_FMT_PROCESSOR_INFO          106
#define IDS_FMT_NIC_TOTAL               107
#define IDS_FMT_NIC_INFO                108
#define IDS_FMT_HOTFIX_TOTAL            109
#define IDS_FMT_HOTFIX_INFO             110
#define IDS_FMT_DHCP_STATUS             111
#define IDS_FMT_DHCP_SERVER             112
#define IDS_FMT_IPADDRESS_TOTAL         113
#define IDS_FMT_IPADDRESS_INFO          114
#define IDS_FMT_NIC_STATUS              115
#define IDS_FMT_CONNECTION              116

#define IDS_OVALUES_FORMAT                      126
#define IDS_TEXT_FORMAT_LIST                    127
#define IDS_TEXT_FORMAT_TABLE                   128
#define IDS_TEXT_FORMAT_CSV                     129
#define IDS_VALUE_STANDALONEWORKSTATION         130
#define IDS_VALUE_MEMBERWORKSTATION             131
#define IDS_VALUE_STANDALONESERVER              132
#define IDS_VALUE_MEMBERSERVER                  133
#define IDS_VALUE_BACKUPDOMAINCONTROLLER        134
#define IDS_VALUE_PRIMARYDOMAINCONTROLLER       135
#define IDS_VALUE_YES                           136
#define IDS_VALUE_NO                            137
#define IDS_VALUE_DISCONNECTED                  138
#define IDS_VALUE_CONNECTING                    139
#define IDS_VALUE_CONNECTED                     140
#define IDS_VALUE_DISCONNECTING                 141
#define IDS_VALUE_HWNOTPRESENT                  142
#define IDS_VALUE_HWDISABLED                    143
#define IDS_VALUE_HWMALFUNCTION                 144
#define IDS_VALUE_MEDIADISCONNECTED             145
#define IDS_VALUE_AUTHENTICATING                146
#define IDS_VALUE_AUTHSUCCEEDED                 147
#define IDS_VALUE_AUTHFAILED                    148

#define IDS_COLHEAD_HOSTNAME                    151
#define IDS_COLHEAD_OS_NAME                     152
#define IDS_COLHEAD_OS_VERSION                  153
#define IDS_COLHEAD_OS_MANUFACTURER             154
#define IDS_COLHEAD_OS_CONFIG                   155
#define IDS_COLHEAD_OS_BUILDTYPE                156
#define IDS_COLHEAD_REG_OWNER                   157
#define IDS_COLHEAD_REG_ORG                     158
#define IDS_COLHEAD_PRODUCT_ID                  159
#define IDS_COLHEAD_INSTALL_DATE                160
#define IDS_COLHEAD_SYSTEM_UPTIME               161
#define IDS_COLHEAD_SYSTEM_MANUFACTURER         162
#define IDS_COLHEAD_SYSTEM_MODEL                163
#define IDS_COLHEAD_SYSTEM_TYPE                 164
#define IDS_COLHEAD_PROCESSOR                   165
#define IDS_COLHEAD_BIOS_VERSION                166
#define IDS_COLHEAD_WINDOWS_DIRECTORY           167
#define IDS_COLHEAD_SYSTEM_DIRECTORY            168
#define IDS_COLHEAD_BOOT_DEVICE                 169
#define IDS_COLHEAD_SYSTEM_LOCALE               170
#define IDS_COLHEAD_INPUT_LOCALE                171
#define IDS_COLHEAD_TIME_ZONE                   172
#define IDS_COLHEAD_TOTAL_PHYSICAL_MEMORY       173
#define IDS_COLHEAD_AVAILABLE_PHYSICAL_MEMORY   174
#define IDS_COLHEAD_VIRTUAL_MEMORY_MAX          175
#define IDS_COLHEAD_VIRTUAL_MEMORY_AVAILABLE    176
#define IDS_COLHEAD_VIRTUAL_MEMORY_INUSE        177
#define IDS_COLHEAD_PAGEFILE_LOCATION           178
#define IDS_COLHEAD_DOMAIN                      179
#define IDS_COLHEAD_LOGON_SERVER                180
#define IDS_COLHEAD_HOTFIX                      181
#define IDS_COLHEAD_NETWORK_CARD                182

#define IDS_COLWIDTH_HOSTNAME                   201
#define IDS_COLWIDTH_OS_NAME                    202
#define IDS_COLWIDTH_OS_VERSION                 203
#define IDS_COLWIDTH_OS_MANUFACTURER            204
#define IDS_COLWIDTH_OS_CONFIG                  205
#define IDS_COLWIDTH_OS_BUILDTYPE               206
#define IDS_COLWIDTH_REG_OWNER                  207
#define IDS_COLWIDTH_REG_ORG                    208
#define IDS_COLWIDTH_PRODUCT_ID                 209
#define IDS_COLWIDTH_INSTALL_DATE               210
#define IDS_COLWIDTH_SYSTEM_UPTIME              211
#define IDS_COLWIDTH_SYSTEM_MANUFACTURER        212
#define IDS_COLWIDTH_SYSTEM_MODEL               213
#define IDS_COLWIDTH_SYSTEM_TYPE                214
#define IDS_COLWIDTH_PROCESSOR                  215
#define IDS_COLWIDTH_BIOS_VERSION               216
#define IDS_COLWIDTH_WINDOWS_DIRECTORY          217
#define IDS_COLWIDTH_SYSTEM_DIRECTORY           218
#define IDS_COLWIDTH_BOOT_DEVICE                219
#define IDS_COLWIDTH_SYSTEM_LOCALE              220
#define IDS_COLWIDTH_INPUT_LOCALE               221
#define IDS_COLWIDTH_TIME_ZONE                  222
#define IDS_COLWIDTH_TOTAL_PHYSICAL_MEMORY      223
#define IDS_COLWIDTH_AVAILABLE_PHYSICAL_MEMORY  224
#define IDS_COLWIDTH_VIRTUAL_MEMORY_MAX         225
#define IDS_COLWIDTH_VIRTUAL_MEMORY_AVAILABLE   226
#define IDS_COLWIDTH_VIRTUAL_MEMORY_INUSE       227
#define IDS_COLWIDTH_PAGEFILE_LOCATION          228
#define IDS_COLWIDTH_DOMAIN                     229
#define IDS_COLWIDTH_LOGON_SERVER               230
#define IDS_COLWIDTH_HOTFIX                     231
#define IDS_COLWIDTH_NETWORK_CARD               232

#define IDS_ERROR_USERNAME_BUT_NOMACHINE    501
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME   502
#define IDS_ERROR_COM_ERROR                 503
#define IDS_ERROR_USERNAME_EMPTY            504
#define IDS_ERROR_NH_NOTSUPPORTED           505
#define IDS_ERROR_SERVERNAME_EMPTY          506
#define IDS_ERROR_INVALID_USAGE_REQUEST     507

#define IDS_MSG_OSINFO                  551
#define IDS_MSG_COMPINFO                552
#define IDS_MSG_PERFINFO                553
#define IDS_MSG_PROCESSORINFO           554
#define IDS_MSG_BIOSINFO                555
#define IDS_MSG_INPUTLOCALEINFO         556
#define IDS_MSG_TZINFO                  557
#define IDS_MSG_PAGEFILEINFO            558
#define IDS_MSG_HOTFIXINFO              559
#define IDS_MSG_NICINFO                 560
#define IDS_MSG_PROFILEINFO             561

#define IDS_HELP_LINE1          1001
#define IDS_HELP_LINE2          1002
#define IDS_HELP_LINE3          1003
#define IDS_HELP_LINE4          1004
#define IDS_HELP_LINE5          1005
#define IDS_HELP_LINE6          1006
#define IDS_HELP_LINE7          1007
#define IDS_HELP_LINE8          1008
#define IDS_HELP_LINE9          1009
#define IDS_HELP_LINE10         1010
#define IDS_HELP_LINE11         1011
#define IDS_HELP_LINE12         1012
#define IDS_HELP_LINE13         1013
#define IDS_HELP_LINE14         1014
#define IDS_HELP_LINE15         1015
#define IDS_HELP_LINE16         1016
#define IDS_HELP_LINE17         1017
#define IDS_HELP_LINE18         1018
#define IDS_HELP_LINE19         1019
#define IDS_HELP_LINE20         1020
#define IDS_HELP_LINE21         1021
#define IDS_HELP_LINE22         1022
#define IDS_HELP_LINE23         1023
#define IDS_HELP_LINE24         1024
#define IDS_HELP_LINE25         1025
#define IDS_HELP_LINE26         1026
#define IDS_HELP_LINE27         1027
#define IDS_HELP_LINE28         1028

// usage indexes into the string table
#define ID_HELP_START       IDS_HELP_LINE1
#define ID_HELP_END         IDS_HELP_LINE28
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\systeminfo\systeminfo.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      SystemInfo.cpp
//
//  Abstract:
//
//      This module displays the system information of local / remote system.
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 27-Dec-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 27-Dec-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "SystemInfo.h"

//
// private function prototype(s)
//
BOOL TranslateLocaleCode( CHString& strLocale );
BOOL FormatNumber( LPCWSTR strValue, CHString& strFmtValue );
BOOL FormatNumberEx( LPCWSTR pwszValue, CHString& strFmtValue );
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, const CONSOLE_SCREEN_BUFFER_INFO& csbi );


DWORD __cdecl
wmain(
        IN DWORD argc,
        IN LPCTSTR argv[]
        )
/*++
// Routine Description:
//      This the entry point to this utility.
//
// Arguments:
//      [ in ] argc     : argument(s) count specified at the command prompt
//      [ in ] argv     : argument(s) specified at the command prompt
//
// Return Value:
//      The below are actually not return values but are the exit values
//      returned to the OS by this application
//          0       : utility is successfull
//          1       : utility failed
--*/
{
    // local variables
    CSystemInfo sysinfo;
    BOOL bResult = FALSE;

    // initialize the systeminfo utility
    if ( sysinfo.Initialize() == FALSE )
    {
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        EXIT_PROCESS( 1 );
    }

    // now do parse the command line options
    if ( sysinfo.ProcessOptions( argc, argv ) == FALSE )
    {
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        EXIT_PROCESS( 1 );
    }

    // check whether usage has to be displayed or not
    if ( sysinfo.m_bUsage == TRUE )
    {
        // show the usage of the utility
        sysinfo.ShowUsage();

        // quit from the utility
        EXIT_PROCESS( 0 );
    }

    // connect to the WMI
    bResult = sysinfo.Connect();
    if ( bResult == FALSE )
    {
        // show the error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        EXIT_PROCESS( 1 );
    }

    // load the data
    if ( sysinfo.LoadData() == FALSE )
    {
        // show the error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        EXIT_PROCESS( 1 );
    }

#ifdef _FAST_LIST
    // NOTE: for list for output will be shown while loading itself.
    // so show the output incase of table and csv formats only
    if ( (sysinfo.m_dwFormat & SR_FORMAT_MASK) != SR_FORMAT_LIST )
#endif

    // show the system configuration information
    sysinfo.ShowOutput();

    // exit from the program
    EXIT_PROCESS( 0 );
}


BOOL
CSystemInfo::Connect()
/*++
// Routine Description:
//            Connects to WMI
//
// Arguments:
//           None
//
// Return Value:
//        TRUE on success
//        FALSE oni failure
--*/
{
    // local variables
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;

    // connect to WMI
    bResult = ConnectWmiEx( m_pWbemLocator,
        &m_pWbemServices, m_strServer, m_strUserName, m_strPassword,
        &m_pAuthIdentity, m_bNeedPassword, WMI_NAMESPACE_CIMV2, &bLocalSystem );

    // check the result of connection
    if ( bResult == FALSE )
    {
        return FALSE;
    }

    // check the local credentials and if need display warning
    if ( GetLastError() == WBEM_E_LOCAL_CREDENTIALS )
    {
        WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
        ShowLastErrorEx( stderr, SLE_TYPE_WARNING | SLE_INTERNAL );

        // get the new screen co-ordinates
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }

    // check the remote system version and its compatiblity
    if ( bLocalSystem == FALSE )
    {
        DWORD dwVersion = 0;
        dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
        if ( IsCompatibleOperatingSystem( dwVersion ) == FALSE )
        {
            SetReason( ERROR_REMOTE_INCOMPATIBLE );
            return FALSE;
        }
    }

    // return the result
    return bResult;
}


BOOL
CSystemInfo::LoadData()
/*++
// Routine Description:
//            Loads the system data
//
// Arguments:
//
// Return Value:
//         FALSE on failure
//         TRUE on success
//
--*/
{
    // local variables
    BOOL bResult = FALSE;

    //
    // load os information
    bResult = LoadOSInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

#ifdef _FAST_LIST
    // ***********************************************
    // show the paritial output .. only in list format
    // ***********************************************
    // Columns Shown here:
    //      Host Name, OS Name, OS Version, OS Manufacturer
    // ***********************************************
    if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        ShowOutput( CI_HOSTNAME, CI_OS_MANUFACTURER );
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }
#endif

    //
    // load computer information
    bResult = LoadComputerInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

#ifdef _FAST_LIST
    // ***********************************************
    // show the paritial output .. only in list format
    // ***********************************************
    // Columns Shown here:
    //      OS Configuration, OS Build Type, Registered Owner,
    //      Registered Organization, Product ID, Original Install Date
    // ***********************************************
    if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        ShowOutput( CI_OS_CONFIG, CI_INSTALL_DATE );
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }
#endif

    //
    // load systemuptime information from perf data
    bResult = LoadPerformanceInfo();
    if ( bResult == FALSE )
    {
	    // return FALSE;
    }

#ifdef _FAST_LIST
    // ***********************************************
    // show the paritial output .. only in list format
    // ***********************************************
    // Columns Shown here:
    //      System Up Time, System Manufacturer, System Model, System type
    // ***********************************************
    if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        ShowOutput( CI_SYSTEM_UPTIME, CI_SYSTEM_TYPE );
        if ( m_hOutput != NULL )
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
    }
#endif

    //
    // load processor information
    bResult = LoadProcessorInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

#ifdef _FAST_LIST
    // ***********************************************
    // show the paritial output .. only in list format
    // ***********************************************
    // Columns Shown here:
    //      Processor(s)
    // ***********************************************
    if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        ShowOutput( CI_PROCESSOR, CI_PROCESSOR );
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }
#endif

    //
    // load bios information
    bResult = LoadBiosInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

#ifdef _FAST_LIST
    // ***********************************************
    // show the paritial output .. only in list format
    // ***********************************************
    // Columns Shown here:
    //      BIOS Version, Windows Directory, System Directory, Boot Device, System Locale
    // ***********************************************
    if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        ShowOutput( CI_BIOS_VERSION, CI_SYSTEM_LOCALE );
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }
#endif

    //
    // load input locale information from keyboard class
    bResult = LoadKeyboardInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

    //
    // load timezone information
    bResult = LoadTimeZoneInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

#ifdef _FAST_LIST
    // ***********************************************
    // show the paritial output .. only in list format
    // ***********************************************
    // Columns Shown here:
    //      Input Locale, Time Zone, Total Physical Memory, Available Physical Memory,
    //      Virtual Memory: Max Size, Virtual Memory: Available, Virtual Memory: In Use
    // ***********************************************
    if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        ShowOutput( CI_INPUT_LOCALE, CI_VIRTUAL_MEMORY_INUSE );
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }
#endif

    // load the logon server information
    bResult = LoadProfileInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

    //
    // load pagefile information
    bResult = LoadPageFileInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

    //
    // load hotfix information from quick fix engineering class
    bResult = LoadHotfixInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

    //
    // load n/w card information from network adapter class
    bResult = LoadNetworkCardInfo();
    if ( bResult == FALSE )
    {
        return FALSE;
    }

#ifdef _FAST_LIST
    // ***********************************************
    // show the paritial output .. only in list format
    // ***********************************************
    // Columns Shown here:
    //      Page File Location(s), Domain, Logon Server, Hotfix(s), NetWork Card(s)
    // ***********************************************
    if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        ShowOutput( CI_PAGEFILE_LOCATION, CI_NETWORK_CARD );
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }
#endif

    // erase the last status message
    PrintProgressMsg( m_hOutput, NULL, m_csbi );

    // return
    return TRUE;
}


BOOL
CSystemInfo::LoadOSInfo()
/*++
// Routine Description:
//                  Loads OS information
//
// Arguments: None
//
// Return Value:
//          TRUE on success
//          FALSE on failure
--*/
{
    // local variables
    HRESULT hr;
    ULONG ulReturned = 0;
    CHString strInstallDate;
    CHString strVirtualMemoryInUse;     // totalvirtualmemorysize - freevirtualmemory
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;

    // property values
    CHString strHostName;               // csname
    CHString strName;                   // caption
    CHString strVersion;                // version
    CHString strServicePack;            // csdversion
    CHString strBuildNumber;            // buildnumber
    CHString strManufacturer;           // manufacturer
    CHString strBuildType;              // buildtype
    CHString strOwner;                  // registereduser
    CHString strOrganization;           // organization
    CHString strSerialNumber;           // serialnumber
    CHString strWindowsDir;             // windowsdirectory
    CHString strSystemDir;              // systemdirectory
    CHString strBootDevice;             // bootdevice
    CHString strFreePhysicalMemory;     // freephysicalmemory
    CHString strTotalVirtualMemory;     // totalvirtualmemorysize
    CHString strFreeVirtualMemory;      // freevirtualmemory
    CHString strLocale;                 // locale
    SYSTEMTIME systimeInstallDate;      // installdate

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_OSINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_OperatingSystem class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_OPERATINGSYSTEM ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    // NOTE: This needs to be traversed only one time.
    hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
    if ( FAILED( hr ) )
    {
        // some error has occured ... oooppps
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the propert information
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_CAPTION, strName );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_CSNAME, strHostName );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_VERSION, strVersion );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_CSDVERSION, strServicePack );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_BUILDNUMBER, strBuildNumber );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_MANUFACTURER, strManufacturer );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_BUILDTYPE, strBuildType );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_REGUSER, strOwner );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_ORGANIZATION, strOrganization );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_SERIALNUMBER, strSerialNumber );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_WINDOWSDIR, strWindowsDir );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_SYSTEMDIR, strSystemDir );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_BOOTDEVICE, strBootDevice );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_LOCALE, strLocale );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_FREEPHYSICALMEMORY, strFreePhysicalMemory );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_TOTALVIRTUALMEMORY, strTotalVirtualMemory );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_FREEVIRTUALMEMORY, strFreeVirtualMemory );
    PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_INSTALLDATE, systimeInstallDate );

    // relase the interfaces
    SAFE_RELEASE( pWbemEnum );
    SAFE_RELEASE( pWbemObject );

    //
    // do the needed formatting the information obtained
    //

    // convert the system locale into appropriate code
    TranslateLocaleCode( strLocale );

    //
    // format the version info
    try
    {
        // sub-local variable
        CHString str;

        // attach the service pack info
        str = strVersion;
        if ( strServicePack.IsEmpty() == FALSE )
        {
            str.Format( L"%s %s", strVersion, strServicePack );
        }

        // attach the build number
        strVersion.Format( FMT_OSVERSION, str, strBuildNumber );
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    //
    // get the formatted date and time
    {
        // sub-local variables
        LCID lcid;
        CHString strTime;
        CHString strDate;
        BOOL bLocaleChanged = FALSE;

        // verify whether console supports the current locale 100% or not
        lcid = GetSupportedUserLocale( &bLocaleChanged );

        // get the formatted date
        try
        {
            // get the size of buffer that is needed
            DWORD dwCount = 0;

            dwCount = GetDateFormat( lcid, 0, &systimeInstallDate,
                ((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL), NULL, 0 );

            // get the required buffer
            LPWSTR pwszTemp = NULL;
            pwszTemp = strDate.GetBufferSetLength( dwCount + 1 );

            // now format the date
            GetDateFormat( lcid, 0, &systimeInstallDate,
                ((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL), pwszTemp, dwCount );

            // release the buffer
            strDate.ReleaseBuffer();
        }
        catch( ... )
        {
            SetLastError( (DWORD)E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // get the formatted time
        try
        {
            // get the size of buffer that is needed
            DWORD dwCount = 0;
            dwCount = GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systimeInstallDate,
                ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), NULL, 0 );

            // get the required buffer
            LPWSTR pwszTemp = NULL;
            pwszTemp = strTime.GetBufferSetLength( dwCount + 1 );

            // now format the date
            GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systimeInstallDate,
                ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), pwszTemp, dwCount );

            // release the buffer
            strTime.ReleaseBuffer();
        }
        catch( ... )
        {
            SetLastError( (DWORD)E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // prepare the
        try
        {
            // prepare the datetime
            strInstallDate.Format( L"%s, %s", strDate, strTime );
        }
        catch( ... )
        {
            SetLastError( (DWORD)E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }
    }

    // format the numeric data
    try
    {
        // sub-local variables
        CHString str;
        WCHAR wszBuffer[ 33 ] = L"\0";

        //
        // first determine the virtual memory in use
        ULONGLONG ullAvailablePhysicalMemory = 0;
        ULONGLONG ullTotal = 0;
        ULONGLONG ullFree = 0;
        ULONGLONG ullInUse = 0;
        ullFree = (ULONGLONG) ( ((( float ) _wtoi64( strFreeVirtualMemory )) / 1024.0f) + 0.5f );
        ullTotal = (ULONGLONG) ( ((( float ) _wtoi64( strTotalVirtualMemory )) / 1024.0f) + 0.5f );
        ullAvailablePhysicalMemory = (ULONGLONG) ( ((( float ) _wtoi64( strFreePhysicalMemory )) / 1024.0f) + 0.5f );
        ullInUse = ullTotal - ullFree;

        //
        // format the virtual memory in use
        _ui64tow( ullInUse, wszBuffer, 10 );                    // convert the ulonglong value into string
        if ( FormatNumberEx( wszBuffer, str ) == FALSE )
        {
            return FALSE;
        }

        // ...
        strVirtualMemoryInUse.Format( FMT_MEGABYTES, str );

        //
        // format the available physical memory
        _ui64tow( ullAvailablePhysicalMemory, wszBuffer, 10 );  // convert the ulonglong value into string
        if ( FormatNumberEx( wszBuffer, str ) == FALSE )
            return FALSE;

        // ...
        strFreePhysicalMemory.Format( FMT_MEGABYTES, str );

        //
        // format the virtual memory max.
        _ui64tow( ullTotal, wszBuffer, 10 );                    // convert the ulonglong value into string
        if ( FormatNumberEx( wszBuffer, str ) == FALSE )
            return FALSE;

        // ...
        strTotalVirtualMemory.Format( FMT_MEGABYTES, str );

        //
        // format the virtual memory free
        _ui64tow( ullFree, wszBuffer, 10 );                 // convert the ulonglong value into string
        if ( FormatNumberEx( wszBuffer, str ) == FALSE )
        {
            return FALSE;
        }

        // ...
        strFreeVirtualMemory.Format( FMT_MEGABYTES, str );
    }
    catch( ... )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    //
    // save the info in dynamic array
    DynArraySetString2( m_arrData, 0, CI_HOSTNAME, strHostName, 0 );
    DynArraySetString2( m_arrData, 0, CI_OS_NAME, strName, 0 );
    DynArraySetString2( m_arrData, 0, CI_OS_VERSION, strVersion, 0 );
    DynArraySetString2( m_arrData, 0, CI_OS_MANUFACTURER, strManufacturer, 0 );
    DynArraySetString2( m_arrData, 0, CI_OS_BUILDTYPE, strBuildType, 0 );
    DynArraySetString2( m_arrData, 0, CI_REG_OWNER, strOwner, 0 );
    DynArraySetString2( m_arrData, 0, CI_REG_ORG, strOrganization, 0 );
    DynArraySetString2( m_arrData, 0, CI_PRODUCT_ID, strSerialNumber, 0 );
    DynArraySetString2( m_arrData, 0, CI_INSTALL_DATE, strInstallDate, 0 );
    DynArraySetString2( m_arrData, 0, CI_WINDOWS_DIRECTORY, strWindowsDir, 0 );
    DynArraySetString2( m_arrData, 0, CI_SYSTEM_DIRECTORY, strSystemDir, 0 );
    DynArraySetString2( m_arrData, 0, CI_BOOT_DEVICE, strBootDevice, 0 );
    DynArraySetString2( m_arrData, 0, CI_SYSTEM_LOCALE, strLocale, 0 );
    DynArraySetString2( m_arrData, 0, CI_AVAILABLE_PHYSICAL_MEMORY, strFreePhysicalMemory, 0 );
    DynArraySetString2( m_arrData, 0, CI_VIRTUAL_MEMORY_MAX, strTotalVirtualMemory, 0 );
    DynArraySetString2( m_arrData, 0, CI_VIRTUAL_MEMORY_AVAILABLE, strFreeVirtualMemory, 0 );
    DynArraySetString2( m_arrData, 0, CI_VIRTUAL_MEMORY_INUSE, strVirtualMemoryInUse, 0 );

    // return success
    return TRUE;
}


BOOL
CSystemInfo::LoadComputerInfo()
/*++
// Routine Description:
//       Loads computer information
//
// Arguments:
//           None
// Return Value:
//     FALSE on failure
//     TRUE on success
//
--*/
{
    // local variables
    HRESULT hr;
    ULONG ulReturned = 0;
    CHString strDomainRole;
    CHString strTotalPhysicalMemory;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;

    // property values
    CHString strModel;
    DWORD dwDomainRole;
    CHString strDomain;
    CHString strSystemType;
    CHString strManufacturer;
    ULONGLONG ullTotalPhysicalMemory;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_COMPINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_ComputerSystem class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_COMPUTERSYSTEM ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    // NOTE: This needs to be traversed only one time.
    hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
    if ( FAILED( hr ) )
    {
        // some error has occured ... oooppps
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the propert information
    PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_MODEL, strModel );
    PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_DOMAIN, strDomain );
    PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_USERNAME, m_strLogonUser );
    PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_DOMAINROLE, dwDomainRole );
    PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_SYSTEMTYPE, strSystemType );
    PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_MANUFACTURER, strManufacturer );
    PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_TOTALPHYSICALMEMORY, ullTotalPhysicalMemory );

    // relase the interfaces
    SAFE_RELEASE( pWbemEnum );
    SAFE_RELEASE( pWbemObject );

    //
    // do the needed formatting the information obtained
    //

    // convert the total physical memory from KB into MB
    try
    {
        // NOTE:
        // ----
        // The max. value of
        // (2 ^ 64) - 1 = "18,446,744,073,709,600,000 K"  (29 chars).
        //              = "18,014,398,509,482,031 M"      (22 chars).
        //
        // so, the buffer size to store the number is fixed as 32 characters
        // which is more than the 29 characters in actuals

        // sub-local variables
        CHString str;
        WCHAR wszBuffer[ 33 ] = L"\0";

        // convert the value first ( take care of rounding )
        ullTotalPhysicalMemory =
            (ULONGLONG) (( ((float) ullTotalPhysicalMemory) / (1024.0f * 1024.0f)) + 0.5f);

        // now ULONGLONG to string
        _ui64tow( ullTotalPhysicalMemory, wszBuffer, 10 );

        // get the formatted number
        if ( FormatNumberEx( wszBuffer, str ) == FALSE )
            return FALSE;

        // ...
        strTotalPhysicalMemory.Format( FMT_MEGABYTES, str );
    }
    catch( ... )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // map the domain role from numeric value to appropriate text value
    try
    {
        //
        // Mapping information of Win32_ComputerSystem's DomainRole property
        // NOTE: Refer to the _DSROLE_MACHINE_ROLE enumeration values in DsRole.h header file
        switch( dwDomainRole )
        {
        case DsRole_RoleStandaloneWorkstation:
            strDomainRole = VALUE_STANDALONEWORKSTATION;
            break;

        case DsRole_RoleMemberWorkstation:
            strDomainRole = VALUE_MEMBERWORKSTATION;
            break;

        case DsRole_RoleStandaloneServer:
            strDomainRole = VALUE_STANDALONESERVER;
            break;

        case DsRole_RoleMemberServer:
            strDomainRole = VALUE_MEMBERSERVER;
            break;

        case DsRole_RoleBackupDomainController:
            strDomainRole = VALUE_BACKUPDOMAINCONTROLLER;
            break;

        case DsRole_RolePrimaryDomainController:
            strDomainRole = VALUE_PRIMARYDOMAINCONTROLLER;
            break;
        }
    }
    catch( ... )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    //
    // save the info in dynamic array
    DynArraySetString2( m_arrData, 0, CI_DOMAIN, strDomain, 0 );
    DynArraySetString2( m_arrData, 0, CI_SYSTEM_MODEL, strModel, 0 );
    DynArraySetString2( m_arrData, 0, CI_OS_CONFIG, strDomainRole, 0 );
    DynArraySetString2( m_arrData, 0, CI_SYSTEM_TYPE, strSystemType, 0 );
    DynArraySetString2( m_arrData, 0, CI_SYSTEM_MANUFACTURER, strManufacturer, 0 );
    DynArraySetString2( m_arrData, 0, CI_TOTAL_PHYSICAL_MEMORY, strTotalPhysicalMemory, 0 );

    // return success
    return TRUE;
}


BOOL
CSystemInfo::LoadBiosInfo()
/*++
// Routine Description:
//     Loads BIOS information
//
// Arguments:
//          None
//
// Return Value:
//        FALSE on failure
//        TRUE on success
//
--*/
{
    // local variables
    HRESULT hr;
    ULONG ulReturned = 0;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;

    // property values
    CHString strVersion;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_BIOSINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_BIOS class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_BIOS ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    // NOTE: This needs to be traversed only one time.
    hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
    if ( FAILED( hr ) )
    {
        // some error has occured ... oooppps
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the propert information
    PropertyGet( pWbemObject, WIN32_BIOS_P_VERSION, strVersion );

    // relase the interfaces
    SAFE_RELEASE( pWbemEnum );
    SAFE_RELEASE( pWbemObject );

    //
    // save the info in dynamic array
    DynArraySetString2( m_arrData, 0, CI_BIOS_VERSION, strVersion, 0 );

    // return success
    return TRUE;
}


BOOL
CSystemInfo::LoadTimeZoneInfo()
/*++
// Routine Description:
//   Loads time-zone information
//
// Arguments: None
//
// Return Value:
//         FALSE on failure
//         TRUE on success
//
--*/
{
    // local variables
    HRESULT hr;
    ULONG ulReturned = 0;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;

    // property values
    CHString strCaption;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_TZINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_TimeZone class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_TIMEZONE ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    // NOTE: This needs to be traversed only one time.
    hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
    if ( FAILED( hr ) )
    {
        // some error has occured ... oooppps
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the propert information
    PropertyGet( pWbemObject, WIN32_TIMEZONE_P_CAPTION, strCaption );

    // relase the interfaces
    SAFE_RELEASE( pWbemEnum );
    SAFE_RELEASE( pWbemObject );

    //
    // save the info in dynamic array
    DynArraySetString2( m_arrData, 0, CI_TIME_ZONE, strCaption, 0 );

    // return success
    return TRUE;
}


BOOL
CSystemInfo::LoadPageFileInfo()
/*++
// Routine Description:
//          Loads page file information
//
// Arguments: none
//
// Return Value:
//           FALSE on failure
//           TRUE on success
//
--*/
{
    // local variables
    HRESULT hr;
    ULONG ulReturned = 0;
    TARRAY arrValues = NULL;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;
    BOOL bNoBreak = TRUE;

    // property values
    CHString strCaption;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_PAGEFILEINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_PageFile class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_PAGEFILE ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    // NOTE: This needs to be traversed only one time.
    do
    {
        hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
        if ( hr == (HRESULT) WBEM_S_FALSE )
        {
            bNoBreak = FALSE;
            // we've reached the end of enumeration .. go out of the loop
            break;
        }
        else if ( FAILED( hr ) )
        {
            // some error has occured ... oooppps
            WMISaveError( hr );
            SAFE_RELEASE( pWbemEnum );
            return FALSE;
        }

        // get the propert information
        PropertyGet( pWbemObject, WIN32_PAGEFILE_P_NAME, strCaption );

        // release the current object
        SAFE_RELEASE( pWbemObject );

        // add the values to the data
        if ( arrValues == NULL )
        {
            arrValues = DynArrayItem2( m_arrData, 0, CI_PAGEFILE_LOCATION );
            if ( arrValues == NULL )
            {
                SetLastError((DWORD) E_UNEXPECTED );
                SaveLastError();
                SAFE_RELEASE( pWbemEnum );
                return FALSE;
            }

            // remove all the existing entries
            DynArrayRemoveAll( arrValues );
        }

        // add the data
        DynArrayAppendString( arrValues, strCaption, 0 );
    } while ( TRUE == bNoBreak );

    // release the enumerated object
    SAFE_RELEASE( pWbemEnum );

    // return
    return TRUE;
}


BOOL
CSystemInfo::LoadProcessorInfo()
/*++
// Routine Description:
//            Loads processor information
//
// Arguments:none
//
// Return Value:
//           FALSE on failure
//           TRUE on success
--*/
{
    // local variables
    HRESULT hr;
    CHString str;
    DWORD dwCount = 0;
    ULONG ulReturned = 0;
    TARRAY arrValues = NULL;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;
    BOOL bNoBreak = TRUE;

    // property values
    DWORD dwClockSpeed;
    CHString strCaption;
    CHString strManufacturer;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_PROCESSORINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_Processor class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_PROCESSOR ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    try
    {
        do
        {
            hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
            if ( hr == (HRESULT) WBEM_S_FALSE )
            {
                bNoBreak = FALSE;
                // we've reached the end of enumeration .. go out of the loop
                break;
            }
            else if ( FAILED( hr ) )
            {
                // some error has occured ... oooppps
                WMISaveError( hr );
                SAFE_RELEASE( pWbemEnum );
                return FALSE;
            }

            // update the counter
            dwCount++;

            // get the propert information
            PropertyGet( pWbemObject, WIN32_PROCESSOR_P_CAPTION, strCaption );
            PropertyGet( pWbemObject, WIN32_PROCESSOR_P_MANUFACTURER, strManufacturer );
            PropertyGet( pWbemObject, WIN32_PROCESSOR_P_CURRENTCLOCKSPEED, dwClockSpeed );

            // check whether we got the clock speed correctly or not
            // if not, get the max. clock speed
            if ( dwClockSpeed == 0 )
                PropertyGet( pWbemObject, WIN32_PROCESSOR_P_MAXCLOCKSPEED, dwClockSpeed );

            // release the current object
            SAFE_RELEASE( pWbemObject );

            // add the values to the data
            if ( arrValues == NULL )
            {
                arrValues = DynArrayItem2( m_arrData, 0, CI_PROCESSOR );
                if ( arrValues == NULL )
                {
                    SetLastError( (DWORD)E_UNEXPECTED );
                    SaveLastError();
                    SAFE_RELEASE( pWbemEnum );
                    return FALSE;
                }

                // remove all the existing entries
                DynArrayRemoveAll( arrValues );
            }

            //
            // prepare the processor info
            str.Format( FMT_PROCESSOR_INFO, dwCount, strCaption, strManufacturer, dwClockSpeed );

            // add the data
            DynArrayAppendString( arrValues, str, 0 );
        } while ( TRUE == bNoBreak );

        // release the enumerated object
        SAFE_RELEASE( pWbemEnum );

        // update the total no. of processors info
        if ( arrValues != NULL )
        {
            // NOTE: this should appear at the first line
            str.Format( FMT_PROCESSOR_TOTAL, dwCount );
            DynArrayInsertString( arrValues, 0, str, 0 );
        }
    }
    catch( ... )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
CSystemInfo::LoadKeyboardInfo()
/*++
// Routine Description:
//          Loads keyboard information
//
// Arguments: none
//
// Return Value:
//           FALSE on failure
//           TRUE on success
--*/
{
    // local variables
    HRESULT hr;
    ULONG ulReturned = 0;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;

    // property values
    CHString strLayout;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_INPUTLOCALEINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_Keyboard class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_KEYBOARD ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    // NOTE: This needs to be traversed only one time.
    hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
    if ( FAILED( hr ) )
    {
        // some error has occured ... oooppps
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the propert information
    PropertyGet( pWbemObject, WIN32_KEYBOARD_P_LAYOUT, strLayout );

    // relase the interfaces
    SAFE_RELEASE( pWbemEnum );
    SAFE_RELEASE( pWbemObject );

    // convert the code page into appropriate text
    TranslateLocaleCode( strLayout );

    //
    // save the info in dynamic array
    DynArraySetString2( m_arrData, 0, CI_INPUT_LOCALE, strLayout, 0 );

    // return
    return TRUE;
}


BOOL
CSystemInfo::LoadHotfixInfo()
/*++
// Routine Description:
//        Loads hot fix information
//
// Arguments: None
//
// Return Value:
//           FALSE on failure
//           TRUE on success
//
--*/
{
    // local variables
    HRESULT hr;
    CHString str;
    DWORD dwCount = 0;
    ULONG ulReturned = 0;
    TARRAY arrValues = NULL;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;
    BOOL bNoBreak = TRUE;

    // property values
    CHString strHotFix;
    CHString strComments;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_HOTFIXINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_QuickFixEngineering class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_QUICKFIXENGINEERING ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    try
    {
        do
        {
            hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
            if ( hr == (HRESULT) WBEM_S_FALSE )
            {
                bNoBreak = FALSE;
                // we've reached the end of enumeration .. go out of the loop
                break;
            }
            else if ( FAILED( hr ) )
            {
                // some error has occured ... oooppps
                WMISaveError( hr );
                SAFE_RELEASE( pWbemEnum );
                return FALSE;
            }

            // update the counter
            dwCount++;

            // get the propert information
            PropertyGet( pWbemObject, WIN32_QUICKFIXENGINEERING_P_HOTFIXID, strHotFix );
            PropertyGet( pWbemObject, WIN32_QUICKFIXENGINEERING_P_FIXCOMMENTS, strComments );

            // release the current object
            SAFE_RELEASE( pWbemObject );

            // add the values to the data
            if ( arrValues == NULL )
            {
                arrValues = DynArrayItem2( m_arrData, 0, CI_HOTFIX );
                if ( arrValues == NULL )
                {
                    SetLastError( (DWORD)E_UNEXPECTED );
                    SaveLastError();
                    SAFE_RELEASE( pWbemEnum );
                    return FALSE;
                }

                // remove all the existing entries
                DynArrayRemoveAll( arrValues );
            }

            // check if fix comments were available or not
            // if available, append that to the the hot fix number
            if ( strComments.GetLength() != 0 )
                strHotFix += L" - " + strComments;

            // prepare the hot fix info
            str.Format( FMT_HOTFIX_INFO, dwCount, strHotFix );

            // add the data
            DynArrayAppendString( arrValues, str, 0 );
        } while ( TRUE == bNoBreak );

        // release the enumerated object
        SAFE_RELEASE( pWbemEnum );

        // update the total no. of hotfix's info
        if ( arrValues != NULL )
        {
            // NOTE: this should appear at the first line
            str.Format( FMT_HOTFIX_TOTAL, dwCount );
            DynArrayInsertString( arrValues, 0, str, 0 );
        }
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }


    // return
    return TRUE;
}


BOOL
CSystemInfo::LoadPerformanceInfo()
/*++
// Routine Description:
//   Loads performance information
//
// Arguments: None
//
// Return Value:
//           FALSE on failure
//           TRUE on success
//
--*/
{
    // local variables
    HRESULT hr;
    CHString strUpTime;
    ULONG ulReturned = 0;
    ULONGLONG ullSysUpTime = 0;
    ULONGLONG ullElapsedTime = 0;
    ULONGLONG ullFrequencyObject = 0;
    ULONGLONG ullTimestampObject = 0;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;
    DWORD dwDays = 0, dwHours = 0, dwMinutes = 0, dwSeconds = 0;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_PERFINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_PerfRawData_PerfOS_System class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_PERFRAWDATA_PERFOS_SYSTEM ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    // NOTE: This needs to be traversed only one time.
    hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
    if ( FAILED( hr ) )
    {
        // some error has occured ... oooppps
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the performance information
    PropertyGet( pWbemObject, WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_SYSUPTIME, ullSysUpTime );
    PropertyGet( pWbemObject, WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_TIMESTAMP, ullTimestampObject );
    PropertyGet( pWbemObject, WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_FREQUENCY, ullFrequencyObject );

    // release the interfaces
    SAFE_RELEASE( pWbemObject );
    SAFE_RELEASE( pWbemEnum );

    // ( performance_time_object - system_up_time ) / frequency_object = elapsed_time
    // NOTE: take care of divide by zero errors.
    if ( ullFrequencyObject == 0 )
    {
        SetLastError( (DWORD)STG_E_UNKNOWN );
        SaveLastError();
        return FALSE;
    }

    // ...
    ullElapsedTime = ( ullTimestampObject - ullSysUpTime ) / ullFrequencyObject;

    //
    // in calculations currently assuming as differences will not cross 2 ^ 32 value
    //

    // no. of days = elapsed_time / 86400
    // update with elapsed_time %= 86400
    dwDays = (DWORD) (ullElapsedTime / 86400);
    ullElapsedTime %= 86400;

    // no. of hours = elapsed_time / 3600
    // update with elapsed_time %= 3600
    dwHours = (DWORD) (ullElapsedTime / 3600);
    ullElapsedTime %= 3600;

    // no. of minutes = elapsed_time / 60
    // no. of seconds = elapsed_time % 60
    dwMinutes = (DWORD) (ullElapsedTime / 60);
    dwSeconds = (DWORD) (ullElapsedTime % 60);

    try
    {
        // now prepare the system up time information
        strUpTime.Format( FMT_UPTIME, dwDays, dwHours, dwMinutes, dwSeconds );
    }
    catch( ... )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // save the info
    DynArraySetString2( m_arrData, 0, CI_SYSTEM_UPTIME, strUpTime, 0 );

    // return
    return TRUE;
}


BOOL
CSystemInfo::LoadNetworkCardInfo()
/*++
// Routine Description:
//         Loads network card information
//
// Arguments: none
//
// Return Value:
//           FALSE on failure
//           TRUE on success
//
--*/
{
    // local variables
    HRESULT hr;
    CHString str;
    DWORD dwCount = 0;
    DWORD dwNicCount = 0;
    DWORD dwStatus = 0;
    BOOL bResult = FALSE;
    ULONG ulReturned = 0;
    TARRAY arrValues = NULL;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemEnum = NULL;
    BOOL bNoBreak = TRUE;

    // property values
    DWORD dwIndex = 0;
    CHString strConnection;
    CHString strDescription;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_NICINFO, m_csbi );

    try
    {
        // enumerate the instances of Win32_NetworkAdapter class
        hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_NETWORKADAPTER ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );

        // check the result of enumeration
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // set the security on the obtained interface
    hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
    if ( FAILED( hr ) )
    {
        WMISaveError( hr );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // get the enumerated objects information
    try
    {
        do
        {
            hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
            if ( hr == (HRESULT) WBEM_S_FALSE )
            {
                bNoBreak = FALSE;
                // we've reached the end of enumeration .. go out of the loop
                break;
            }
            else if ( FAILED( hr ) )
            {
                // some error has occured ... oooppps
                WMISaveError( (DWORD) hr );
                SAFE_RELEASE( pWbemEnum );
                return FALSE;
            }

            // get the property information
            // NOTE: get the result of getting status property information
            PropertyGet( pWbemObject, WIN32_NETWORKADAPTER_P_INDEX, dwIndex );
            PropertyGet( pWbemObject, WIN32_NETWORKADAPTER_P_DESCRIPTION, strDescription );
            PropertyGet( pWbemObject, WIN32_NETWORKADAPTER_P_NETCONNECTIONID, strConnection );
            bResult = PropertyGet( pWbemObject, WIN32_NETWORKADAPTER_P_STATUS, dwStatus, 0 );

            // release the current object
            SAFE_RELEASE( pWbemObject );

            // add the values to the data
            // NOTE: do this only if either we couldn't find the property or status is not -1
            //       FOR WINDOWS 2000 MACHINES 'NetConnectionStatus' PROPERT IS NOT EXISTED IN
            //       WMI 'Win32_NetworkAdapter' CLASS. SO WE WILL BE DISPLAYING THE N/W CARD
            //       INFORMATION IF PROPERTY DOESN'T EXIST OR IF EXISTS AND THE STATUS IS NOT -1
            if ( bResult == FALSE || dwStatus != 0 )
            {
                // update the counter
                dwCount++;

                if ( arrValues == NULL )
                {
                    arrValues = DynArrayItem2( m_arrData, 0, CI_NETWORK_CARD );
                    if ( arrValues == NULL )
                    {
                        SetLastError( (DWORD)E_UNEXPECTED );
                        SaveLastError();
                        SAFE_RELEASE( pWbemEnum );
                        return FALSE;
                    }

                    // remove all the existing entries
                    DynArrayRemoveAll( arrValues );
                }

                // prepare the n/w card info
                str.Format( FMT_NIC_INFO, dwCount, strDescription );

                // add the data
                DynArrayAppendString( arrValues, str, 0 );

                // now check the status in detail ... only if the property exists
                if ( bResult == TRUE )
                {
                    //
                    // property do exists ... so determine the status
                    // display the status of the NIC except it is connected
                    // if the NIC is connected, display the ipaddress and its other information

                    // add the connection name
                    str.Format( FMT_CONNECTION, strConnection );
                    DynArrayAppendString( arrValues, str, 0 );

                    // ...
                    if ( dwStatus != 2 )
                    {
                        // sub-local variables
                        CHString strValues[] = {
                            VALUE_DISCONNECTED, VALUE_CONNECTING,
                            VALUE_CONNECTED, VALUE_DISCONNECTING, VALUE_HWNOTPRESENT,
                            VALUE_HWDISABLED, VALUE_HWMALFUNCTION, VALUE_MEDIADISCONNECTED,
                            VALUE_AUTHENTICATING, VALUE_AUTHSUCCEEDED, VALUE_AUTHFAILED };

                        // prepare the status info
                        if ( dwStatus > 0 && dwStatus < SIZE_OF_ARRAY( strValues ) )
                        {
                            // ...
                            str.Format( FMT_NIC_STATUS, strValues[ dwStatus ] );

                            // save the info
                            DynArrayAppendString( arrValues, str, 0 );
                        }
                    }
                    else
                    {
                        //
                        // get the adapter configuration

                        // sub-local variables
                        CHString strTemp;
                        CHString strDhcpServer;
                        DWORD dwDhcpEnabled = 0;
                        TARRAY arrIPAddress = NULL;

                        // create the ipaddress array
                        arrIPAddress = CreateDynamicArray();
                        if ( arrIPAddress == NULL )
                        {
                            WMISaveError( E_OUTOFMEMORY );
                            SAFE_RELEASE( pWbemEnum );
                            return FALSE;
                        }

                        // prepare the object path
                        str.Format( WIN32_NETWORKADAPTERCONFIGURATION_GET, dwIndex );

                        // get the nic config info object
                        hr = m_pWbemServices->GetObject( _bstr_t( str ),
                            WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pWbemObject, NULL );

                        // check the result .. proceed furthur only if successfull
                        if ( SUCCEEDED( hr ) )
                        {
                            // get the needed property values
                            PropertyGet( pWbemObject, WIN32_NETWORKADAPTERCONFIGURATION_P_IPADDRESS, arrIPAddress );
                            PropertyGet( pWbemObject, WIN32_NETWORKADAPTERCONFIGURATION_P_DHCPSERVER, strDhcpServer );
                            PropertyGet( pWbemObject, WIN32_NETWORKADAPTERCONFIGURATION_P_DHCPENABLED, dwDhcpEnabled );

                            // check and add the dhcp information
                            // NOTE: CIM_BOOLEAN -> TRUE = -1, FALSE = 0
                            strTemp = FMT_DHCP_STATUS;
                            str.Format( strTemp,  ( ( dwDhcpEnabled == -1 ) ? VALUE_YES : VALUE_NO ) );
                            DynArrayAppendString( arrValues, str, 0 );

                            // add the dhcp server info ( if needed )
                            if ( dwDhcpEnabled == -1 )
                            {
                                str.Format( FMT_DHCP_SERVER, strDhcpServer );
                                DynArrayAppendString( arrValues, str, 0 );
                            }

                            //
                            // add the IP Address information
                            DynArrayAppendString( arrValues, FMT_IPADDRESS_TOTAL, 0 );

                            dwNicCount = DynArrayGetCount( arrIPAddress );
                            for( DWORD dw = 0; dw < dwNicCount; dw++ )
                            {
                                // get the info
                                LPCWSTR pwsz = NULL;
                                pwsz = DynArrayItemAsString( arrIPAddress, dw );
                                if ( pwsz == NULL )
                                    continue;

                                // prepare and add the info
                                str.Format( FMT_IPADDRESS_INFO, dw + 1, pwsz );
                                DynArrayAppendString( arrValues, str, 0 );
                            }
                        }

                        // release the object
                        SAFE_RELEASE( pWbemObject );

                        // destroy the dynamic array created for storing ip address info
                        DestroyDynamicArray( &arrIPAddress );
                    }
                }
            }
        } while ( TRUE == bNoBreak );

        // release the enumerated object
        SAFE_RELEASE( pWbemEnum );

        // update the total no. of hotfix's info
        if ( arrValues != NULL )
        {
            // NOTE: this should appear at the first line
            str.Format( FMT_NIC_TOTAL, dwCount );
            DynArrayInsertString( arrValues, 0, str, 0 );
        }
    }
    catch( ... )
    {
        WMISaveError( (DWORD)E_OUTOFMEMORY );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemEnum );
        return FALSE;
    }

    // return success
    return TRUE;
}


BOOL
CSystemInfo::LoadProfileInfo()
/*++
// Routine Description:
//     Loads profile information
//
// Arguments:none
//
// Return Value:
//           FALSE on failure
//           TRUE on success
//
--*/
{
    // local variables
    BOOL bResult = FALSE;
    CHString strLogonServer;
    LPCWSTR pwszPassword = NULL;
    IWbemServices* pDefaultNamespace = NULL;

    // display the status message
    PrintProgressMsg( m_hOutput, MSG_PROFILEINFO, m_csbi );

    // determine the password with which connection to default name has to be made
    pwszPassword = NULL;
    if ( m_pAuthIdentity != NULL )
    {
        pwszPassword = m_pAuthIdentity->Password;
    }

    // we need to establish connection to the remote system's registry
    // for this connect to the default namespace of the WMI using the credentials available with us
    bResult = ConnectWmi( m_pWbemLocator, &pDefaultNamespace,
        m_strServer, m_strUserName, pwszPassword, &m_pAuthIdentity, FALSE, WMI_NAMESPACE_DEFAULT );
    if ( bResult == FALSE )
    {
        return FALSE;
    }

    // get the value of the LOGONSERVER
    RegQueryValueWMI( pDefaultNamespace, WMI_HKEY_CURRENT_USER,
        SUBKEY_VOLATILE_ENVIRONMENT, KEY_LOGONSERVER, strLogonServer );

    // release the interface
    SAFE_RELEASE( pDefaultNamespace );

    //
    // save the info
    DynArraySetString2( m_arrData, 0, CI_LOGON_SERVER, strLogonServer, 0 );

    // return
    return TRUE;
}


VOID
PrintProgressMsg(
                    IN HANDLE hOutput,
                    IN LPCWSTR pwszMsg,
                    IN const CONSOLE_SCREEN_BUFFER_INFO& csbi
                    )
/*++
// Routine Description:
//             Prints the message on console
//
// Arguments:
//         [in]  hOutput  : output handle
//         [in]  pwszMsg  : Message to be printed
//         [in]  csbi  : console screen buffer structure
//
//
// Return Value: none
//
--*/
{
    // local variables
    COORD coord;
    DWORD dwSize = 0;
    WCHAR wszSpaces[ 80 ] = L"";

    // check the handle. if it is null, it means that output is being redirected. so return
    if ( hOutput == NULL )
    {
        return;
    }

    // set the cursor position
    coord.X = 0;
    coord.Y = csbi.dwCursorPosition.Y;

    // first erase contents on the current line
    SecureZeroMemory( wszSpaces, SIZE_OF_ARRAY(wszSpaces) );
    SetConsoleCursorPosition( hOutput, coord );
    WriteConsoleW( hOutput, Replicate( wszSpaces, L" ", 79, 79 ), 79, &dwSize, NULL );

    // now display the message ( if exists )
    SetConsoleCursorPosition( hOutput, coord );
    if ( pwszMsg != NULL )
    {
        WriteConsoleW( hOutput, pwszMsg, StringLength( pwszMsg, 0 ), &dwSize, NULL );
    }
}


BOOL
TranslateLocaleCode( CHString& strLocale )
/*++
// Routine Description:
//          Translates locale code
//
// Arguments:
//           [in]  strLocale   : locale
//
// Return Value:
//        TRUE on success
//        FALSE on failure
//
--*/
{
    // local variables
    CHString str;
    HKEY hKey = NULL;
    DWORD dwSize = 0;
    LONG lRegReturn = 0;
    HKEY hMainKey = NULL;
    WCHAR wszValue[ 64 ] = L"\0";

    //
    // THIS IS A TYPICAL THING WHICH WE ARE DOING HERE
    // BECAUSE WE DONT KNOW WHAT LANGUAGE TARGET MACHINE IS USING
    // SO WE GET THE LOCALE CODE PAGE BEING USED BY THE TARGET MACHINE
    // AND GET THE APPROPRIATE NAME FOR THAT LOCALE FROM THE CURRENT SYSTEM
    // REGISTRY DATABASE. IF THE REGISTRY IS CORRUPTED THEN THERE IS NO WAY
    // TO JUDGE THE OUTPUT THAT DISPLAYED BY THIS UTILITY IS VALID OR INVALID
    //

    try
    {
        // get the reference to the promary hive
        lRegReturn = RegConnectRegistry( NULL, HKEY_CLASSES_ROOT, &hMainKey );
        if ( lRegReturn != ERROR_SUCCESS )
        {
            SaveLastError();
            return FALSE;
        }
        else if ( hMainKey == NULL )
        {
            // THIS IS MEANING LESS IN DOING
            // BUT JUST TO AVOID PREfix BUG THIS PART IS WRITTEN
            SetLastError( (DWORD)E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // now get the reference to the database path
        lRegReturn = RegOpenKeyEx( hMainKey, LOCALE_PATH, 0, KEY_QUERY_VALUE, &hKey);
        if ( lRegReturn != ERROR_SUCCESS )
        {
            switch( lRegReturn )
            {
            case ERROR_FILE_NOT_FOUND:
                SetLastError( ERROR_REGISTRY_CORRUPT );
                break;

            default:
                // save the error information and return FAILURE
                SetLastError( lRegReturn );
                break;
            }

            // close the key and return
            SaveLastError();
            RegCloseKey( hMainKey );
            return FALSE;
        }
        else if ( hKey == NULL )
        {
            // THIS IS MEANING LESS IN DOING
            // BUT JUST TO AVOID PREfix BUG THIS PART IS WRITTEN
            SetLastError( (DWORD)E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // we are interested in the last 4 characters of the code page info
        str = strLocale.Right( 4 );

        //copy the last four charecters in to the string to get the locale
        dwSize = SIZE_OF_ARRAY( wszValue );
        lRegReturn = RegQueryValueExW( hKey, str, NULL, NULL, ( LPBYTE ) wszValue, &dwSize);

        // first close the registry handles
        if ( NULL != hKey )
		{
			RegCloseKey( hKey );
		}

		if ( NULL != hMainKey )
		{
	        RegCloseKey( hMainKey );
		}

        // now check the return value
        if( lRegReturn != ERROR_SUCCESS )
            return FALSE;

        // save the value
        strLocale = wszValue;
    }
    catch( ... )
    {
        WMISaveError( E_OUTOFMEMORY );
		// release the registry handles
        if ( NULL != hKey )
		{
			RegCloseKey( hKey );
			hKey = NULL;
		}

		if ( NULL != hMainKey )
		{
			RegCloseKey( hMainKey );
			hMainKey = NULL;
		}

        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
FormatNumber(
              IN LPCWSTR pwszValue,
              IN CHString& strFmtValue
              )
/*++
// Routine Description:
//
// Arguments:
//      [in] pwszValue :  value
//      [in] strFmtValue : format value
//
// Return Value:
//        TRUE on success
//        FALSE on failure
//
--*/
{
    try
    {
        // get the size of buffer that is needed
        DWORD dwCount = 0;
        if( NULL == pwszValue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            SaveLastError();
            return FALSE;
        }

        dwCount = GetNumberFormat( LOCALE_USER_DEFAULT, 0, pwszValue, NULL, L"", 0 );

        // get the required buffer
        LPWSTR pwszTemp = NULL;
        pwszTemp = strFmtValue.GetBufferSetLength( dwCount + 1 );

        // now format the date
        dwCount = GetNumberFormat( LOCALE_USER_DEFAULT, 0, pwszValue, NULL, pwszTemp, dwCount );
        if( 0 == dwCount )
        {
            SaveLastError();
            return FALSE;
        }

        // release the buffer
        strFmtValue.ReleaseBuffer();
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
FormatNumberEx(
                 IN LPCWSTR pwszValue,
                 OUT CHString& strFmtValue
                )
/*++
// Routine Description:
//           Formats the number
//
// Arguments:
//        [in] pwszValue: Value string
//        [in] strFmtValue : format value
//
// Return Value:
//        TRUE on success
//        FALSE on failure
//
--*/
{
    // local variables
    CHString str;
    LONG lTemp = 0;
    NUMBERFMTW nfmtw;
    DWORD dwGroupSep = 0;
    LPWSTR pwszTemp = NULL;
    CHString strGroupThousSep;

    try
    {
        //
        // get the group seperator character
        lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, NULL, 0 );
        if ( lTemp == 0 )
        {
            // we don't know how to resolve this
            return FALSE;
        }
        else
        {
            // get the group seperation character
            pwszTemp = str.GetBufferSetLength( lTemp + 2 );
            SecureZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
            GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, pwszTemp, lTemp );

            // change the group info into appropriate number
            lTemp = 0;
            dwGroupSep = 0;
            while ( lTemp < str.GetLength() )
            {
                if ( AsLong( str.Mid( lTemp, 1 ), 10 ) != 0 )
                    dwGroupSep = dwGroupSep * 10 + AsLong( str.Mid( lTemp, 1 ), 10 );

                // increment by 2
                lTemp += 2;
            }
        }

        //
        // get the thousand seperator character
        lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, NULL, 0 );
        if ( lTemp == 0 )
        {
            // we don't know how to resolve this
            return FALSE;
        }
        else
        {
            // get the thousand sepeartion charactor
            pwszTemp = strGroupThousSep.GetBufferSetLength( lTemp + 2 );
            SecureZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
            GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, pwszTemp, lTemp );
        }

        // release the CHStrig buffers
        str.ReleaseBuffer();
        strGroupThousSep.ReleaseBuffer();
    }
    catch( ... )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // format the number
    try
    {
        nfmtw.NumDigits = 0;
        nfmtw.LeadingZero = 0;
        nfmtw.NegativeOrder = 0;
        nfmtw.Grouping = dwGroupSep;
        nfmtw.lpDecimalSep = L"";
        nfmtw.lpThousandSep = strGroupThousSep.GetBuffer( strGroupThousSep.GetLength() );

        // get the size of buffer that is needed
        lTemp = GetNumberFormatW( LOCALE_USER_DEFAULT, 0, pwszValue, &nfmtw, NULL, 0 );

        // get/allocate the required buffer
        pwszTemp = strFmtValue.GetBufferSetLength( lTemp + 1 );

        // now format the date
        GetNumberFormat( LOCALE_USER_DEFAULT, 0, pwszValue, &nfmtw, pwszTemp, lTemp );

        // release the buffer
        strFmtValue.ReleaseBuffer();
    }
    catch( ... )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\systeminfo\wmi.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      WMI.h
//
//  Abstract:
//
//      Common functionality for WMI
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )    \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \
    1

#define SAFE_EXECUTE( statement )               \
    hr = statement;     \
    if ( FAILED( hr ) ) \
    {   \
        _com_issue_error( hr ); \
    }   \
    1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2     L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT   L"root\\default"

#define WMI_CLAUSE_AND          L"AND"
#define WMI_CLAUSE_OR           L"OR"
#define WMI_CLAUSE_WHERE        L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem   L"Win32_OperatingSystem"

#define WMI_REGISTRY                    L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE      L"GetStringValue"
#define WMI_REGISTRY_M_DWORDVALUE       L"GetDwordValue"

#define WMI_REGISTRY_IN_HDEFKEY         L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY          L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME       L"sValueName"
#define WMI_REGISTRY_OUT_VALUE          L"sValue"
#define WMI_REGISTRY_OUT_VALUE_DWORD    L"uValue"
#define WMI_REGISTRY_OUT_RETURNVALUE    L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT               2147483648
#define WMI_HKEY_CURRENT_USER               2147483649
#define WMI_HKEY_LOCAL_MACHINE              2147483650
#define WMI_HKEY_USERS                      2147483651
#define WMI_HKEY_CURRENT_CONFIG             2147482652

// messages
// #define ERROR_COM_ERROR                  GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator,
                 IWbemServices** ppServices,
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword,
                 COAUTHIDENTITY** ppAuthIdentity,
                 BOOL bCheckWithNullPwd = FALSE,
                 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2,
                 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL, IWbemContext* pWbemContext = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator,
                   IWbemServices** ppServices,
                   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword,
                   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE,
                   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL,
                   DWORD dwPasswordLen = 0, IWbemContext* pWbemContext = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet(
                    IWbemClassObject* pWmiObject,
                    LPCWSTR pwszProperty,
                    VARIANT* pvarValue );
HRESULT PropertyGet( IWbemClassObject* pWmiObject,
                     LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,
                  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  BOOL& dwValue, BOOL bDefault = FALSE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey,
                       LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName,
                       CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices,
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName,
                       LPCWSTR pwszValueName, DWORD& dwValue, DWORD dwDefault = 0 );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, CHString& strValue,
                                VARTYPE vartype );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex,
                                IWbemClassObject **pScriptObject, VARTYPE vartype );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//
// Arguments:
//
// Return Value:
//
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
    WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\parse.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      parse.cpp
//
//  Abstract:
//
//      This module implements the command-line parsing and validating the filters
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "taskkill.h"

#define MAX_OPERATOR_STRING      101
#define MAX_FILTER_PROP_STRING   256

//
// local function prototypes
//
BOOL TimeFieldsToElapsedTime( LPCWSTR pwszTime, LPCWSTR pwszToken, ULONG& ulElapsedTime );
DWORD FilterMemUsage( LPCWSTR pwszProperty, LPCWSTR pwszOperator,
                      LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );
DWORD FilterCPUTime( LPCWSTR pwszProperty, LPCWSTR pwszOperator,
                     LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );
DWORD FilterUserName( LPCWSTR pwszProperty, LPCWSTR pwszOperator,
                      LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );
DWORD FilterProcessId( LPCWSTR pwszProperty, LPCWSTR pwszOperator,
                       LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );


BOOL
CTaskKill::ProcessOptions(
    IN DWORD argc,
    IN LPCWSTR argv[]
    )
/*++
Routine Description:
      processes and validates the command line inputs

Arguments:
      [ in ] argc          : no. of input arguments specified
      [ in ] argv          : input arguments specified at command prompt

Return Value:
      TRUE  : if inputs are valid
      FALSE : if inputs were errorneously specified
--*/
{
    // local variables
    BOOL bResult = FALSE;
    PTCMDPARSER2 pcmdOptions = NULL;

    // temporary local variables
    PTCMDPARSER2 pOption = NULL;
    PTCMDPARSER2 pOptionServer = NULL;
    PTCMDPARSER2 pOptionUserName = NULL;
    PTCMDPARSER2 pOptionPassword = NULL;

    //
    // prepare the command options
    pcmdOptions = ( TCMDPARSER2 * ) AllocateMemory( sizeof( TCMDPARSER2 ) * MAX_OPTIONS );
    if ( NULL == pcmdOptions )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // ...
    SecureZeroMemory( pcmdOptions, MAX_OPTIONS * sizeof( TCMDPARSER2 ) );

    // -?
    pOption = pcmdOptions + OI_USAGE;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pwszOptions = OPTION_USAGE;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP_USAGE;
    pOption->pValue = &m_bUsage;
    pOption->dwLength    = 0;

    // -s
    pOption = pcmdOptions + OI_SERVER;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_SERVER;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->pValue = NULL;
    pOption->dwLength    = 0;

    // -u
    pOption = pcmdOptions + OI_USERNAME;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_USERNAME;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->pValue = NULL;
    pOption->dwLength    = 0;

    // -p
    pOption = pcmdOptions + OI_PASSWORD;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_PASSWORD;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    pOption->pValue = NULL;
    pOption->dwLength    = 0;

    // -f
    pOption = pcmdOptions + OI_FORCE;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pwszOptions = OPTION_FORCE;
    pOption->pwszValues = NULL;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = 0;
    pOption->pValue = &m_bForce;
    pOption->dwLength = 0;

    // -tr
    pOption = pcmdOptions + OI_TREE;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pwszOptions = OPTION_TREE;
    pOption->pwszValues = NULL;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = 0;
    pOption->pValue = &m_bTree;
    pOption->dwLength = 0;

    // -fi
    pOption = pcmdOptions + OI_FILTER;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_FILTER;
    pOption->dwCount = 0;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_MODE_ARRAY | CP2_VALUE_NODUPLICATES | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->pValue = &m_arrFilters;
    pOption->dwLength    = 0;

    // -pid
    pOption = pcmdOptions + OI_PID;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_PID;
    pOption->dwCount = 0;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_MODE_ARRAY | CP_VALUE_MANDATORY | CP2_VALUE_NODUPLICATES;
    pOption->pValue = &m_arrTasksToKill;
    pOption->dwLength    = 0;

    // -im
    pOption = pcmdOptions + OI_IMAGENAME;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_IMAGENAME;
    pOption->dwCount = 0;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_MODE_ARRAY | CP_VALUE_MANDATORY | CP2_VALUE_NODUPLICATES;
    pOption->pValue = &m_arrTasksToKill;
    pOption->dwLength    = 0;

    //
    // do the parsing
    bResult = DoParseParam2( argc, argv, -1, MAX_OPTIONS, pcmdOptions, 0 );

    // now check the result of parsing and decide
    if ( bResult == FALSE )
    {
        FreeMemory( ( LPVOID * ) &pcmdOptions ); // clear memory
        return FALSE;           // invalid syntax
    }

    //
    // now, check the mutually exclusive options
    pOptionServer = pcmdOptions + OI_SERVER;
    pOptionUserName = pcmdOptions + OI_USERNAME;
    pOptionPassword = pcmdOptions + OI_PASSWORD;

    try
    {
        // release the buffers
        m_strServer   = (LPWSTR)pOptionServer->pValue;
        m_strUserName = (LPWSTR)pOptionUserName->pValue;
        m_strPassword = (LPWSTR)pOptionPassword->pValue;
        if( NULL == (LPWSTR)pOptionPassword->pValue )
        {
            m_strPassword = L"*";
        }

        FreeMemory( &pOptionServer->pValue );
        FreeMemory( &pOptionUserName->pValue );
        FreeMemory( &pOptionPassword->pValue );

        // check the usage option
        if ( TRUE == m_bUsage )
        {   // -? is specified.
            if( 2 < argc )
            {
                // no other options are accepted along with -? option
                FreeMemory( ( LPVOID * ) &pcmdOptions ); // clear memory
                SetLastError( ( DWORD )MK_E_SYNTAX );
                SetReason( ERROR_INVALID_USAGE_REQUEST );
                return FALSE;
            }
            else
            {
                // should not do the furthur validations
                FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                return TRUE;
            }
        }

        // Without -s, -u and -p should not be specified.
        // With -s, -u can be specified, but without -u, -p should not be specified.
        if( 0 != pOptionServer->dwActuals )
        {
            if( ( 0 == pOptionUserName->dwActuals ) && ( 0 != pOptionPassword->dwActuals ) )
            {
                 // invalid syntax
                SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
                FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                return FALSE;           // indicate failure
            }
        }
        else
        {   // -s is not specified.
            if( 0 != pOptionUserName->dwActuals )
            {   // -u without -s.
                 // invalid syntax
                SetReason( ERROR_USERNAME_BUT_NOMACHINE );
                FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                return FALSE;           // indicate failure
            }
            else
            {   // -p without -s.
                if( 0 != pOptionPassword->dwActuals )
                {
                     // invalid syntax
                    SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
                    FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                    return FALSE;           // indicate failure
                }
            }
        }

        // check whether caller should accept the password or not
        // if user has specified -s (or) -u and no "-p", then utility should accept password
        // the user will be prompter for the password only if establish connection
        // is failed without the credentials information
        if ( 0 != pOptionPassword->dwActuals)
        {
            if( 0 == m_strPassword.Compare( L"*" ) )
            {
                // user wants the utility to prompt for the password before trying to connect
                m_bNeedPassword = TRUE;
            }
            else
            {
                if( NULL == (LPCWSTR)m_strPassword )
                {
                    m_strPassword = L"*";
                    // user wants the utility to prompt for the password before trying to connect
                    m_bNeedPassword = TRUE;
                }
            }
        }
        else
        {
            // utility needs to try to connect first and if it fails then prompt for the password
            m_bNeedPassword = TRUE;
            m_strPassword.Empty();
        }

        // either -pid (or) -im are allowed but not both
        if ( (pcmdOptions + OI_PID)->dwActuals != 0 && (pcmdOptions + OI_IMAGENAME)->dwActuals != 0 )
        {
            // invalid syntax
            SetReason( ERROR_PID_OR_IM_ONLY );
            FreeMemory( ( LPVOID * )&pcmdOptions ); // clear memory
            return FALSE;           // indicate failure
        }
        else if ( DynArrayGetCount( m_arrTasksToKill ) == 0 )
        {
            // tasks were not specified .. but user might have specified filters
            // check that and if user didn't filters error
            if ( DynArrayGetCount( m_arrFilters ) == 0 )
            {
                // invalid syntax
                SetReason( ERROR_NO_PID_AND_IM );
                FreeMemory( ( LPVOID * )&pcmdOptions ); // clear memory
                return FALSE;           // indicate failure
            }

            // user specified filters ... add '*' to the list of task to kill
            DynArrayAppendString( m_arrTasksToKill, L"*", 0 );
        }

        // check if '*' is specified along with the filters or not
        // if not specified along with the filters, error
        if ( DynArrayGetCount( m_arrFilters ) == 0 )
        {
            // filters were not specified .. so '*' should not be specified
            LONG lIndex = 0;
            lIndex = DynArrayFindString( m_arrTasksToKill, L"*", TRUE, 0 );
            if ( lIndex != -1 )
            {
                // error ... '*' is specified even if filters were not specified
                SetReason( ERROR_WILDCARD_WITHOUT_FILTERS );
                FreeMemory( ( LPVOID * )&pcmdOptions ); // clear memory
                return FALSE;
            }
        }
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        FreeMemory( ( LPVOID * ) &pcmdOptions );
        return FALSE;
    }

    // command-line parsing is successfull
    FreeMemory( ( LPVOID * )&pcmdOptions ); // clear memory
    return TRUE;
}

BOOL
CTaskKill::ValidateFilters(
    void
    )
/*++
Routine Description:
      validates the filter information specified with -filter option

Arguments:
      NONE

Return Value:
      TRUE    : if filters are appropriately specified
      FALSE   : if filters are errorneously specified
--*/
{
    // local variables
    LONG lIndex = -1;
    BOOL bResult = FALSE;
    PTFILTERCONFIG pConfig = NULL;

    //
    // prepare the filter structure

    // status
    pConfig = m_pfilterConfigs + FI_STATUS;
    pConfig->dwColumn = TASK_STATUS;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_VALUES;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_STATUS, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, FVALUES_STATUS, MAX_FILTER_PROP_STRING );

    // imagename
    pConfig = m_pfilterConfigs + FI_IMAGENAME;
    pConfig->dwColumn = TASK_IMAGENAME;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_IMAGENAME, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // pid
    pConfig = m_pfilterConfigs + FI_PID;
    pConfig->dwColumn = TASK_PID;
    pConfig->dwFlags = F_TYPE_CUSTOM;
    pConfig->pFunction = FilterProcessId;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_NUMERIC, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_PID, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // session
    pConfig = m_pfilterConfigs + FI_SESSION;
    pConfig->dwColumn = TASK_SESSION;
    pConfig->dwFlags = F_TYPE_UNUMERIC;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_NUMERIC, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_SESSION, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // cputime
    pConfig = m_pfilterConfigs + FI_CPUTIME;
    pConfig->dwColumn = TASK_CPUTIME;
    pConfig->dwFlags = F_TYPE_CUSTOM;
    pConfig->pFunction = FilterCPUTime;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_NUMERIC, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_CPUTIME, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // memusage
    pConfig = m_pfilterConfigs + FI_MEMUSAGE;
    pConfig->dwColumn = TASK_MEMUSAGE;
    pConfig->dwFlags = F_TYPE_UNUMERIC;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_NUMERIC, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_MEMUSAGE, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // username
    pConfig = m_pfilterConfigs + FI_USERNAME;
    pConfig->dwColumn = TASK_USERNAME;
    pConfig->dwFlags = F_TYPE_CUSTOM;
    pConfig->pFunction = FilterUserName;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_USERNAME, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // services
    pConfig = m_pfilterConfigs + FI_SERVICES;
    pConfig->dwColumn = TASK_SERVICES;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN | F_MODE_ARRAY;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_SERVICES, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // windowtitle
    pConfig = m_pfilterConfigs + FI_WINDOWTITLE;
    pConfig->dwColumn = TASK_WINDOWTITLE;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_WINDOWTITLE, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // modules
    pConfig = m_pfilterConfigs + FI_MODULES;
    pConfig->dwColumn = TASK_MODULES;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN | F_MODE_ARRAY;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_MODULES, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    //
    // validate the filter
    bResult = ParseAndValidateFilter( MAX_FILTERS,
        m_pfilterConfigs, m_arrFilters, &m_arrFiltersEx );

    // check the filter validation result
    if ( FALSE == bResult )
    {
        return FALSE;
    }
    // find out whether user has requested for the tasks to be filtered
    // on user context and/or services are not ... if yes, set the appropriate flags
    // this check is being done to increase the performance of the utility
    // NOTE: we will be using the parsed filters info for doing this

    // user context
    if ( FALSE == m_bNeedUserContextInfo )
    {
        // find out if the filter property exists in this row
        // NOTE:-
        //        filter property do exists in the seperate indexes only.
        //        refer to the logic of validating the filters in common functionality
        lIndex = DynArrayFindStringEx( m_arrFiltersEx,
            F_PARSED_INDEX_PROPERTY, FILTER_USERNAME, TRUE, 0 );
        if ( -1 != lIndex )
        {
            m_bNeedUserContextInfo = TRUE;
        }
    }

    // services info
    if ( FALSE == m_bNeedServicesInfo )
    {
        // find out if the filter property exists in this row
        // NOTE:-
        //        filter property do exists in the seperate indexes only.
        //        refer to the logic of validating the filters in common functionality
        lIndex = DynArrayFindStringEx( m_arrFiltersEx,
            F_PARSED_INDEX_PROPERTY, FILTER_SERVICES, TRUE, 0 );
        if ( -1 != lIndex )
        {
            m_bNeedServicesInfo = TRUE;
        }
    }

    // modules info
    if ( FALSE == m_bNeedModulesInfo )
    {
        // find out if the filter property exists in this row
        // NOTE:-
        //        filter property do exists in the seperate indexes only.
        //        refer to the logic of validating the filters in common functionality
        lIndex = DynArrayFindStringEx( m_arrFiltersEx,
            F_PARSED_INDEX_PROPERTY, FILTER_MODULES, TRUE, 0 );
        if ( -1 != lIndex )
        {
            m_bNeedModulesInfo = TRUE;
        }
    }

    //
    // do the filter optimization by adding the wmi properties to the query
    //
    // NOTE: as the 'handle' property of the Win32_Process class is string type
    //       we cannot include that in the wmi query for optimization. So make use
    //       of the ProcessId property

    // optimization should not be done if user requested for tree termination
    if ( TRUE == m_bTree )
    {
        try
        {
            // default query
            m_strQuery = WMI_PROCESS_QUERY;
        }
        catch( CHeap_Exception )
        {
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // modify the record filtering type for "memusage" filter from built-in type to custom type
        ( m_pfilterConfigs + FI_MEMUSAGE )->dwFlags = F_TYPE_CUSTOM;
        ( m_pfilterConfigs + FI_MEMUSAGE )->pFunctionData = NULL;
        ( m_pfilterConfigs + FI_MEMUSAGE )->pFunction = FilterMemUsage;

        // modify the record filtering type for "pid" filter from custom to built-in type
        ( m_pfilterConfigs + FI_PID )->dwFlags = F_TYPE_UNUMERIC;
        ( m_pfilterConfigs + FI_PID )->pFunctionData = NULL;
        ( m_pfilterConfigs + FI_PID )->pFunction = NULL;

        // simply return ... filter validation is complete
        return TRUE;
    }

    // variables needed by optimization logic
    LONG lCount = 0;
    CHString strBuffer;
    BOOL bOptimized = FALSE;
    LPCWSTR pwszValue = NULL;
    LPCWSTR pwszClause = NULL;
    LPCWSTR pwszProperty = NULL;
    LPCWSTR pwszOperator = NULL;

    try
    {
        // first clause .. and init
        m_strQuery = WMI_PROCESS_QUERY;
        pwszClause = WMI_QUERY_FIRST_CLAUSE;

        // get the no. of filters
        lCount = DynArrayGetCount( m_arrFiltersEx );

        // traverse thru all the filters and do the optimization
        m_bFiltersOptimized = FALSE;
        for( LONG i = 0; i < lCount; i++ )
        {
            // assume this filter will not be delete / not useful for optimization
            bOptimized = FALSE;

            // get the property, operator and value
            pwszValue = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_VALUE );
            pwszProperty = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_PROPERTY );
            pwszOperator = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_OPERATOR );
            if ( ( NULL == pwszProperty ) || ( NULL == pwszOperator ) || ( NULL == pwszValue ) )
            {
                SetLastError( ( DWORD )STG_E_UNKNOWN );
                SaveLastError();
                return FALSE;
            }

            //
            // based on the property do optimization needed

            // get the mathematically equivalent operator
            pwszOperator = FindOperator( pwszOperator );

            // process id
            if ( 0 == StringCompare( FILTER_PID, pwszProperty, TRUE, 0 ) )
            {
                // convert the value into numeric
                DWORD dwProcessId = AsLong( pwszValue, 10 );
                strBuffer.Format( L" %s %s %s %d",
                    pwszClause, WIN32_PROCESS_PROPERTY_PROCESSID, pwszOperator, dwProcessId );

                // need to be optimized
                bOptimized = TRUE;
            }

            // session id
            else
            {
                if ( 0 == StringCompare( FILTER_SESSION, pwszProperty, TRUE, 0 ) )
                {
                    // convert the value into numeric
                    DWORD dwSession = AsLong( pwszValue, 10 );
                    strBuffer.Format( L" %s %s %s %d",
                        pwszClause, WIN32_PROCESS_PROPERTY_SESSION, pwszOperator, dwSession );

                    // need to be optimized
                    bOptimized = TRUE;
                }
                // image name
                else
                {
                    if ( 0 == StringCompare( FILTER_IMAGENAME, pwszProperty, TRUE, 0 ) )
                    {
                        // check if wild card is specified or not
                        // if wild card is specified, this filter cannot be optimized
                        if ( wcschr( pwszValue, L'*' ) == NULL )
                        {
                            // no conversions needed
                            strBuffer.Format( L" %s %s %s '%s'",
                                pwszClause, WIN32_PROCESS_PROPERTY_IMAGENAME, pwszOperator, pwszValue );

                            // need to be optimized
                            bOptimized = TRUE;
                        }
                    }
                    // mem usage
                    else
                    {
                        if ( 0 == StringCompare( FILTER_MEMUSAGE, pwszProperty, TRUE, 0 ) )
                        {
                            // convert the value into numeric
                            ULONG ulMemUsage = AsLong( pwszValue, 10 ) * 1024;
                            strBuffer.Format( L" %s %s %s %lu",
                                pwszClause, WIN32_PROCESS_PROPERTY_MEMUSAGE, pwszOperator, ulMemUsage );

                            // need to be optimized
                            bOptimized = TRUE;
                        }
                    }
                }
            }

            // check if property is optimizable ... if yes ... remove
            if ( TRUE == bOptimized )
            {
                // change the clause and append the current query
                m_strQuery += strBuffer;
                pwszClause = WMI_QUERY_SECOND_CLAUSE;

                // remove property and update the iterator variables
                m_bFiltersOptimized = TRUE;
                DynArrayRemove( m_arrFiltersEx, i );
                i--;
                lCount--;
            }
        }

        // final touch up to the query
        if ( TRUE == m_bFiltersOptimized )
        {
            m_strQuery += L" )";
        }
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return the filter validation result
    return TRUE;
}


BOOL
TimeFieldsToElapsedTime(
    IN LPCWSTR pwszTime,
    IN LPCWSTR pwszToken,
    OUT ULONG& ulElapsedTime
    )
/*++
Routine Description:
    Retrieve elapsed time.

Arguments:
    [ in ] pwszTime       : Contains time string.
    [ in ] pwszToken      : Contains time seperator.
    [ out ] ulElapsedTime : Contains elapsed time.

Return Value:
    TRUE if success else FAIL is returned.
--*/
{
    // local variables
    ULONG ulValue = 0;
    LPCWSTR pwszField = NULL;
    WCHAR szTemp[ 64 ] = NULL_STRING;
    DWORD dwNext = 0, dwLength = 0, dwCount = 0;

    // check the input
    if ( ( NULL == pwszTime ) ||
         ( NULL == pwszToken ) )
    {
        return FALSE;
    }
    // start parsing the time info
    dwNext = 0;
    dwCount = 0;
    ulElapsedTime = 0;
    do
    {
        // search for the needed token
        pwszField = FindString( pwszTime, pwszToken, dwNext );
        if ( NULL == pwszField )
        {
            // check whether some more text exists in the actual string or not
            if ( dwNext >= StringLength( pwszTime, 0 ) )
            {
                break;          // no more info found
            }
            // get the last info
            StringCopy( szTemp, pwszTime + dwNext, SIZE_OF_ARRAY( szTemp ) );
            dwLength = StringLength( szTemp, 0 );            // update the length
        }
        else
        {
            // determine the length of numeric value and get the numeric value
            dwLength = StringLength( pwszTime, 0 ) - StringLength( pwszField, 0 ) - dwNext;

            // check the length info
            if ( dwLength > SIZE_OF_ARRAY( szTemp ) )
            {
                return FALSE;
            }
            // get the current info
            StringCopy( szTemp, pwszTime + dwNext, dwLength );    // +1 for NULL character
        }

        // update the count of fields we are getting
        dwCount++;

        // check whether this field is numeric or not
        if ( ( 0 == StringLength( szTemp, 0 ) ) ||
             ( FALSE == IsNumeric( szTemp, 10, FALSE ) ) )
        {
            return FALSE;
        }
        // from second token onwards, values greater than 59 are not allowed
        ulValue = AsLong( szTemp, 10 );
        if ( ( 1 < dwCount ) && ( 50 < ulValue ) )
        {
            return FALSE;
        }
        // update the elapsed time
        ulElapsedTime = ( ulElapsedTime + ulValue ) * (( dwCount < 3 ) ? 60 : 1);

        // position to the next information start
        dwNext += dwLength + StringLength( pwszToken, 0 );
    } while ( ( NULL != pwszField ) && ( 3 > dwCount ) );

    // check the no. of time field we got .. we should have got 3 .. if not, error
    if ( ( NULL != pwszField ) || ( 3 != dwCount ) )
    {
        return FALSE;
    }
    // so everything went right ... return success
    return TRUE;
}


DWORD
FilterCPUTime(
    IN LPCWSTR pwszProperty,
    IN LPCWSTR pwszOperator,
    IN LPCWSTR pwszValue,
    IN LPVOID pData,
    IN TARRAY arrRow
    )
/*++
Routine Description:
    Filter process to display with resepect  their CPU time.

Arguments:
    [ in ] pwszProperty   : Contains property value as 'CPUTIME'.
    [ in ] pwszOperator   : Contains operator as 'gt'or 'lt' or 'ge' or 'le'.
    [ in ] pwszValue      : Contains value to filter.
    [ in ] pData          : Contains data to compare.
    [ in ] arrRow         : Contains item value to filter.

Return Value:
    DWORD

--*/
{
    // local variables
    ULONG ulCPUTime = 0;
    ULONG ulElapsedTime = 0;
    LPCWSTR pwszCPUTime = NULL;

    // if the arrRow parameter is NULL, we need to validate the filter
    if ( NULL == arrRow )
    {
        // check if there are any arthemtic sysbols before the cputime value starts
        if ( ( NULL != pwszValue ) && ( 1 < StringLength( pwszValue, 0 ) ) )
        {
            if ( ( L'-' == pwszValue[ 0 ] ) || ( L'+' == pwszValue[ 0 ] ) )
            {
                return F_FILTER_INVALID;
            }
        }

        // validate the filter value and return the result
        if ( FALSE == TimeFieldsToElapsedTime( pwszValue, L":", ulElapsedTime ) )
        {
            return F_FILTER_INVALID;
        }
        else
        {
            return F_FILTER_VALID;
        }
    }

    // get the filter value
    TimeFieldsToElapsedTime( pwszValue, L":", ulElapsedTime );

    // get the record value
    pwszCPUTime = DynArrayItemAsString( arrRow, TASK_CPUTIME );
    if ( NULL == pwszCPUTime )
    {
        return F_RESULT_REMOVE;
    }
    // convert the record value into elapsed time value
    TimeFieldsToElapsedTime( pwszCPUTime, (LPCWSTR) pData, ulCPUTime );

    // return the result
    if ( ulCPUTime == ulElapsedTime )
    {
        return MASK_EQ;
    }
    else
    {
        if ( ulCPUTime < ulElapsedTime )
        {
            return MASK_LT;
        }
        else
        {
            if ( ulCPUTime > ulElapsedTime )
            {
                return MASK_GT;
            }
        }
    }

    // no way flow coming here .. still
    return F_RESULT_REMOVE;
}


DWORD
FilterMemUsage(
    IN LPCWSTR pwszProperty,
    IN LPCWSTR pwszOperator,
    IN LPCWSTR pwszValue,
    IN LPVOID pData,
    IN TARRAY arrRow
    )
/*++
Routine Description:
    Filter process to display with resepect  their CPU time.

Arguments:
    [ in ] pwszProperty   : Contains property value as 'CPUTIME'.
    [ in ] pwszOperator   : Contains operator as 'gt'or 'lt' or 'ge' or 'le'.
    [ in ] pwszValue      : Contains value to filter.
    [ in ] pData          : Contains data to compare.
    [ in ] arrRow         : Contains item value to filter.

Return Value:
    DWORD

--*/
{
    // local variables
    DWORD dwLength = 0;
    ULONGLONG ulValue = 0;
    ULONGLONG ulMemUsage = 0;
    LPCWSTR pwszMemUsage = NULL;

    // check the inputs
    if ( ( NULL == pwszProperty ) ||
         ( NULL == pwszOperator ) ||
         ( NULL == pwszValue ) )
    {
        return F_FILTER_INVALID;
    }
    // check the arrRow parameter
    // because this function will not / should not be called except for filtering
    if ( NULL == arrRow )
    {
        return F_FILTER_INVALID;
    }
    // check the inputs
    if ( NULL == pwszValue )
    {
        return F_RESULT_REMOVE;
    }
    // get the memusage value
    pwszMemUsage = DynArrayItemAsString( arrRow, TASK_MEMUSAGE );
    if ( NULL == pwszMemUsage )
    {
        return F_RESULT_REMOVE;
    }
    // NOTE: as there is no conversion API as of today we use manual ULONGLONG value
    //       preparation from string value
    ulMemUsage = 0;
    dwLength = StringLength( pwszMemUsage, 0 );
    for( DWORD dw = 0; dw < dwLength; dw++ )
    {
        // validate the digit
        if ( ( L'0' > pwszMemUsage[ dw ] ) || ( L'9' < pwszMemUsage[ dw ] ) )
        {
            return F_RESULT_REMOVE;
        }
        // ...
        ulMemUsage = ulMemUsage * 10 + ( pwszMemUsage[ dw ] - 48 );
    }

    // get the user specified value
    ulValue = AsLong( pwszValue, 10 );

    //
    // now determine the result value
    if ( ulMemUsage == ulValue )
    {
        return MASK_EQ;
    }
    else
    {
        if ( ulMemUsage < ulValue )
        {
            return MASK_LT;
        }
        else
        {
            if ( ulMemUsage > ulValue )
            {
                return MASK_GT;
            }
        }
    }
    // never come across this situation ... still
    return F_RESULT_REMOVE;
}


DWORD
FilterUserName(
    IN LPCWSTR pwszProperty,
    IN LPCWSTR pwszOperator,
    IN LPCWSTR pwszValue,
    IN LPVOID pData,
    IN TARRAY arrRow
    )
/*++
Routine Description:
    Filter process to display with resepect  their Username.

Arguments:
    [ in ] pwszProperty   : Contains property value as 'USERNAME'.
    [ in ] pwszOperator   : Contains operator as 'eq' or 'ne'.
    [ in ] pwszValue      : Contains value to filter.
    [ in ] pData          : Contains data to compare.
    [ in ] arrRow         : Contains item value to filter.

Return Value:
    DWORD
--*/
{
    // local variables
    LONG lResult = 0;
    LONG lWildCardPos = 0;
    LPCWSTR pwszTemp = NULL;
    LPCWSTR pwszSearch = NULL;
    BOOL bOnlyUserName = FALSE;
    LPCWSTR pwszUserName = NULL;

    // check the inputs
    if ( ( NULL == pwszProperty ) ||
         ( NULL == pwszOperator ) ||
         ( NULL == pwszValue ) )
    {
        return F_FILTER_INVALID;
    }
    // if the arrRow parameter is NULL, we need to validate the filter
    if ( NULL == arrRow )
    {
        // nothing is there to validate ... just check the length
        // and ensure that so text is present and the value should not be just '*'
        // NOTE: the common functionality will give the value after doing left and right trim
        if ( ( 0 == StringLength( pwszValue, 0 ) ) || ( 0 == StringCompare( pwszValue, L"*", TRUE, 0 ) ) )
        {
            return F_FILTER_INVALID;
        }
        // the wild card character is allowed only at the end
        pwszTemp = _tcschr( pwszValue, L'*' );
        if ( ( NULL != pwszTemp ) && ( 0 != StringLength( pwszTemp + 1, 0 ) ) )
        {
            return F_FILTER_INVALID;
        }
        // filter is valid
        return F_FILTER_VALID;
    }

    // find the position of the wild card in the supplied user name
    lWildCardPos = 0;
    pwszTemp = _tcschr( pwszValue, L'*' );
    if ( NULL != pwszTemp )
    {
        // determine the wild card position
        lWildCardPos = StringLength( pwszValue, 0 ) - StringLength( pwszTemp, 0 );

        // special case:
        // if the pattern is just asterisk, which means that all the
        // information needs to passed thru the filter but there is no chance for
        // this situation as specifying only '*' is being treated as invalid filter
        if ( 0 == lWildCardPos )
        {
            return F_FILTER_INVALID;
        }
    }

    // search for the domain and user name seperator ...
    // if domain name is not specified, comparision will be done only with the user name
    bOnlyUserName = FALSE;
    pwszTemp = _tcschr( pwszValue, L'\\' );
    if ( NULL == pwszTemp )
    {
        bOnlyUserName = TRUE;
    }
    // get the user name from the info
    pwszUserName = DynArrayItemAsString( arrRow, TASK_USERNAME );
    if ( NULL == pwszUserName )
    {
        return F_RESULT_REMOVE;
    }
    // based the search criteria .. meaning whether to search along with the domain or
    // only user name, the seach string will be decided
    pwszSearch = pwszUserName;
    if ( TRUE == bOnlyUserName )
    {
        // search for the domain and user name seperation character
        pwszTemp = _tcschr( pwszUserName, L'\\' );

        // position to the next character
        if ( NULL != pwszTemp )
        {
            pwszSearch = pwszTemp + 1;
        }
    }

    // validate the search string
    if ( NULL == pwszSearch )
    {
        return F_RESULT_REMOVE;
    }
    // now do the comparision
    lResult = StringCompare( pwszSearch, pwszValue, TRUE, lWildCardPos );

    //
    // now determine the result value
    if ( 0 == lResult )
    {
        return MASK_EQ;
    }
    else
    {
        if ( 0 > lResult )
        {
            return MASK_LT;
        }
        if ( 0 < lResult )
        {
            return MASK_GT;
        }
    }

    // never come across this situation ... still
    return F_RESULT_REMOVE;
}


DWORD
FilterProcessId(
    IN LPCWSTR pwszProperty,
    IN LPCWSTR pwszOperator,
    IN LPCWSTR pwszValue,
    IN LPVOID pData,
    IN TARRAY arrRow
    )
/*++
Routine Description:
    Filter process to display with resepect  their Username.

Arguments:
    [ in ] pwszProperty   : Contains property value as 'USERNAME'.
    [ in ] pwszOperator   : Contains operator as 'eq' or 'ne'.
    [ in ] pwszValue      : Contains value to filter.
    [ in ] pData          : Contains data to compare.
    [ in ] arrRow         : Contains item value to filter.

Return Value:
    DWORD
--*/
{
    // local variables
    LPWSTR pwsz = NULL;

    // check the inputs
    if ( ( NULL == pwszProperty ) ||
         ( NULL == pwszOperator ) ||
         ( NULL == pwszValue ) )
    {
        return F_FILTER_INVALID;
    }
    // check the arrRow parameter
    // because this function will not / should not be called except for validation
    if ( NULL != arrRow )
    {
        return F_RESULT_REMOVE;
    }
    // check the inputs ( only needed ones )
    if ( NULL == pwszValue )
    {
        return F_FILTER_INVALID;
    }
    // NOTE: do not call the IsNumeric function. do the numeric validation in this module itself
    //       also do not check for the overflow (or) underflow.
    //       just check whether input is numeric or not
    wcstoul( pwszValue, &pwsz, 10 );
    if ( ( 0 == StringLength( pwszValue, 0 ) ) ||
         ( ( NULL != pwsz ) && ( 0 < StringLength( pwsz, 0 ) ) ) )
    {
        return F_FILTER_INVALID;
    }
    // check if overflow (or) undeflow occured
    if ( ERANGE == errno )
    {
        SetReason( ERROR_NO_PROCESSES );
        return F_FILTER_INVALID;
    }

    // return
    return F_FILTER_VALID;
}


VOID
CTaskKill::Usage(
    void
    )
/*++
Routine Description:
     This function fetches usage information from resource file and shows it.

Arguments:
      NONE

Return Value:
      NONE
--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = ID_HELP_START; dw <= ID_HELP_END; dw++ )
    {
        ShowMessage( stdout, GetResString( dw ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\systeminfo\systeminfo.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      SystemInfo.h
//
//  Abstract:
//
//      macros and function prototypes of SystemInfo.cpp
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//
// *********************************************************************************

#ifndef __SYSTEMINFO_H
#define __SYSTEMINFO_H

// resource header file
#include "resource.h"

//
// NOTE: THIS MODULE WILL WRITTEN IN SUCH A FASHION THAT IT WORKS ONLY
//       IN UNICODE BUILD COMPILATION
//
#ifndef UNICODE
#error Must compile only in unicode build environment
#endif

//
// general purpose macros
//
#define EXIT_PROCESS( exitcode )    \
    ReleaseGlobals();   \
    return exitcode;    \
    1

/*#define RELEASE_MEMORY( block ) \
    if ( (block) != NULL )  \
    {   \
        delete (block); \
        (block) = NULL; \
    }   \
    1

#define RELEASE_MEMORY_EX( block )  \
    if ( (block) != NULL )  \
    {   \
        delete [] (block);  \
        (block) = NULL; \
    }   \
    1
*/
#define DESTROY_ARRAY( array )  \
    if ( (array) != NULL )  \
    {   \
        DestroyDynamicArray( &(array) );    \
        (array) = NULL; \
    }   \
    1

//
// constants / defines / enumerations
//

// registry path
#define LOCALE_PATH                         L"MIME\\Database\\Rfc1766"

// messages
#define ERROR_USERNAME_BUT_NOMACHINE    GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME   GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_USERNAME_EMPTY            GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_NH_NOTSUPPORTED           GetResString( IDS_ERROR_NH_NOTSUPPORTED )
#define ERROR_SERVERNAME_EMPTY          GetResString( IDS_ERROR_SERVERNAME_EMPTY )
#define ERROR_INVALID_USAGE_REQUEST     GetResString( IDS_ERROR_INVALID_USAGE_REQUEST )

// output formats
#define TEXT_FORMAT_LIST        GetResString( IDS_TEXT_FORMAT_LIST )
#define TEXT_FORMAT_TABLE       GetResString( IDS_TEXT_FORMAT_TABLE )
#define TEXT_FORMAT_CSV         GetResString( IDS_TEXT_FORMAT_CSV )

//
// WMI related stuff

// Win32_OperatingSystem class information
#define WIN32_OPERATINGSYSTEM                           L"Win32_OperatingSystem"
#define WIN32_OPERATINGSYSTEM_P_CAPTION                     L"Caption"
#define WIN32_OPERATINGSYSTEM_P_CSNAME                      L"CSName"
#define WIN32_OPERATINGSYSTEM_P_VERSION                     L"Version"
#define WIN32_OPERATINGSYSTEM_P_CSDVERSION                  L"CSDVersion"
#define WIN32_OPERATINGSYSTEM_P_BUILDNUMBER                 L"BuildNumber"
#define WIN32_OPERATINGSYSTEM_P_MANUFACTURER                L"Manufacturer"
#define WIN32_OPERATINGSYSTEM_P_BUILDTYPE                   L"BuildType"
#define WIN32_OPERATINGSYSTEM_P_REGUSER                     L"RegisteredUser"
#define WIN32_OPERATINGSYSTEM_P_ORGANIZATION                L"Organization"
#define WIN32_OPERATINGSYSTEM_P_SERIALNUMBER                L"SerialNumber"
#define WIN32_OPERATINGSYSTEM_P_INSTALLDATE                 L"InstallDate"
#define WIN32_OPERATINGSYSTEM_P_WINDOWSDIR                  L"WindowsDirectory"
#define WIN32_OPERATINGSYSTEM_P_SYSTEMDIR                   L"SystemDirectory"
#define WIN32_OPERATINGSYSTEM_P_BOOTDEVICE                  L"BootDevice"
#define WIN32_OPERATINGSYSTEM_P_LOCALE                      L"Locale"
#define WIN32_OPERATINGSYSTEM_P_FREEPHYSICALMEMORY          L"FreePhysicalMemory"
#define WIN32_OPERATINGSYSTEM_P_TOTALVIRTUALMEMORY          L"TotalVirtualMemorySize"
#define WIN32_OPERATINGSYSTEM_P_FREEVIRTUALMEMORY           L"FreeVirtualMemory"

// Win32_ComputerSystem class information
#define WIN32_COMPUTERSYSTEM                            L"Win32_ComputerSystem"
#define WIN32_COMPUTERSYSTEM_P_MODEL                        L"Model"
#define WIN32_COMPUTERSYSTEM_P_SYSTEMTYPE                   L"SystemType"
#define WIN32_COMPUTERSYSTEM_P_TOTALPHYSICALMEMORY          L"TotalPhysicalMemory"
#define WIN32_COMPUTERSYSTEM_P_MANUFACTURER                 L"Manufacturer"
#define WIN32_COMPUTERSYSTEM_P_DOMAIN                       L"Domain"
#define WIN32_COMPUTERSYSTEM_P_DOMAINROLE                   L"DomainRole"
#define WIN32_COMPUTERSYSTEM_P_USERNAME                     L"UserName"

// Win32_BIOS
#define WIN32_BIOS                                      L"Win32_BIOS"
#define WIN32_BIOS_P_VERSION                                L"Version"

// Win32_TimeZone
#define WIN32_TIMEZONE                                  L"Win32_TimeZone"
#define WIN32_TIMEZONE_P_CAPTION                            L"Caption"

// Win32_PageFile
#define WIN32_PAGEFILE                                  L"Win32_PageFileSetting"
#define WIN32_PAGEFILE_P_NAME                               L"Name"

// Win32_Processor
#define WIN32_PROCESSOR                                 L"Win32_Processor"
#define WIN32_PROCESSOR_P_CAPTION                           L"Caption"
#define WIN32_PROCESSOR_P_MANUFACTURER                      L"Manufacturer"
#define WIN32_PROCESSOR_P_CURRENTCLOCKSPEED                 L"CurrentClockSpeed"
#define WIN32_PROCESSOR_P_MAXCLOCKSPEED                     L"MaxClockSpeed"

// Win32_PerfRawData_PerfOS_System
#define WIN32_PERFRAWDATA_PERFOS_SYSTEM                 L"Win32_PerfRawData_PerfOS_System"
#define WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_SYSUPTIME         L"SystemUpTime"
#define WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_TIMESTAMP         L"Timestamp_Object"
#define WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_FREQUENCY         L"Frequency_Object"

// Win32_Keyboard
#define WIN32_KEYBOARD                                  L"Win32_Keyboard"
#define WIN32_KEYBOARD_P_LAYOUT                             L"Layout"

// Win32_QuickFixEngineering
#define WIN32_QUICKFIXENGINEERING                       L"Win32_QuickFixEngineering"
#define WIN32_QUICKFIXENGINEERING_P_HOTFIXID                L"HotFixID"
#define WIN32_QUICKFIXENGINEERING_P_FIXCOMMENTS             L"FixComments"

// Win32_NetworkAdapter
#define WIN32_NETWORKADAPTER                            L"Win32_NetworkAdapter"
#define WIN32_NETWORKADAPTER_P_INDEX                        L"Index"
#define WIN32_NETWORKADAPTER_P_NETCONNECTIONID              L"NetConnectionID"
#define WIN32_NETWORKADAPTER_P_DESCRIPTION                  L"Description"
#define WIN32_NETWORKADAPTER_P_STATUS                       L"NetConnectionStatus"

// Win32_NetworkAdapterConfiguration
#define WIN32_NETWORKADAPTERCONFIGURATION_GET           L"Win32_NetworkAdapterConfiguration.Index=%d"
#define WIN32_NETWORKADAPTERCONFIGURATION_P_IPADDRESS       L"IPAddress"
#define WIN32_NETWORKADAPTERCONFIGURATION_P_DHCPENABLED     L"DHCPEnabled"
#define WIN32_NETWORKADAPTERCONFIGURATION_P_DHCPSERVER      L"DHCPServer"

//
// registry specific

// registry paths
#define SUBKEY_VOLATILE_ENVIRONMENT                     L"Volatile Environment"
#define KEY_LOGONSERVER                                 L"LOGONSERVER"

//
// column heading names and their indexes in the array ( in fact positions )
#define MAX_COLUMNS             32

// column headings
#define COLHEAD_HOSTNAME                    GetResString( IDS_COLHEAD_HOSTNAME )
#define COLHEAD_OS_NAME                     GetResString( IDS_COLHEAD_OS_NAME )
#define COLHEAD_OS_VERSION                  GetResString( IDS_COLHEAD_OS_VERSION )
#define COLHEAD_OS_MANUFACTURER             GetResString( IDS_COLHEAD_OS_MANUFACTURER )
#define COLHEAD_OS_CONFIG                   GetResString( IDS_COLHEAD_OS_CONFIG )
#define COLHEAD_OS_BUILDTYPE                GetResString( IDS_COLHEAD_OS_BUILDTYPE )
#define COLHEAD_REG_OWNER                   GetResString( IDS_COLHEAD_REG_OWNER )
#define COLHEAD_REG_ORG                     GetResString( IDS_COLHEAD_REG_ORG )
#define COLHEAD_PRODUCT_ID                  GetResString( IDS_COLHEAD_PRODUCT_ID )
#define COLHEAD_INSTALL_DATE                GetResString( IDS_COLHEAD_INSTALL_DATE )
#define COLHEAD_SYSTEM_UPTIME               GetResString( IDS_COLHEAD_SYSTEM_UPTIME )
#define COLHEAD_SYSTEM_MANUFACTURER         GetResString( IDS_COLHEAD_SYSTEM_MANUFACTURER )
#define COLHEAD_SYSTEM_MODEL                GetResString( IDS_COLHEAD_SYSTEM_MODEL )
#define COLHEAD_SYSTEM_TYPE                 GetResString( IDS_COLHEAD_SYSTEM_TYPE )
#define COLHEAD_PROCESSOR                   GetResString( IDS_COLHEAD_PROCESSOR )
#define COLHEAD_BIOS_VERSION                GetResString( IDS_COLHEAD_BIOS_VERSION )
#define COLHEAD_WINDOWS_DIRECTORY           GetResString( IDS_COLHEAD_WINDOWS_DIRECTORY )
#define COLHEAD_SYSTEM_DIRECTORY            GetResString( IDS_COLHEAD_SYSTEM_DIRECTORY )
#define COLHEAD_BOOT_DEVICE                 GetResString( IDS_COLHEAD_BOOT_DEVICE )
#define COLHEAD_SYSTEM_LOCALE               GetResString( IDS_COLHEAD_SYSTEM_LOCALE )
#define COLHEAD_INPUT_LOCALE                GetResString( IDS_COLHEAD_INPUT_LOCALE )
#define COLHEAD_TIME_ZONE                   GetResString( IDS_COLHEAD_TIME_ZONE )
#define COLHEAD_TOTAL_PHYSICAL_MEMORY       GetResString( IDS_COLHEAD_TOTAL_PHYSICAL_MEMORY )
#define COLHEAD_AVAILABLE_PHYSICAL_MEMORY   GetResString( IDS_COLHEAD_AVAILABLE_PHYSICAL_MEMORY )
#define COLHEAD_VIRTUAL_MEMORY_MAX          GetResString( IDS_COLHEAD_VIRTUAL_MEMORY_MAX )
#define COLHEAD_VIRTUAL_MEMORY_AVAILABLE    GetResString( IDS_COLHEAD_VIRTUAL_MEMORY_AVAILABLE )
#define COLHEAD_VIRTUAL_MEMORY_INUSE        GetResString( IDS_COLHEAD_VIRTUAL_MEMORY_INUSE )
#define COLHEAD_PAGEFILE_LOCATION           GetResString( IDS_COLHEAD_PAGEFILE_LOCATION )
#define COLHEAD_DOMAIN                      GetResString( IDS_COLHEAD_DOMAIN )
#define COLHEAD_LOGON_SERVER                GetResString( IDS_COLHEAD_LOGON_SERVER )
#define COLHEAD_HOTFIX                      GetResString( IDS_COLHEAD_HOTFIX )
#define COLHEAD_NETWORK_CARD                GetResString( IDS_COLHEAD_NETWORK_CARD )

// colwidths
#define COLWIDTH_HOSTNAME                   AsLong( GetResString( IDS_COLWIDTH_HOSTNAME ), 10 )
#define COLWIDTH_OS_NAME                    AsLong( GetResString( IDS_COLWIDTH_OS_NAME ), 10 )
#define COLWIDTH_OS_VERSION                 AsLong( GetResString( IDS_COLWIDTH_OS_VERSION ), 10 )
#define COLWIDTH_OS_MANUFACTURER            AsLong( GetResString( IDS_COLWIDTH_OS_MANUFACTURER ), 10 )
#define COLWIDTH_OS_CONFIG                  AsLong( GetResString( IDS_COLWIDTH_OS_CONFIG ), 10 )
#define COLWIDTH_OS_BUILDTYPE               AsLong( GetResString( IDS_COLWIDTH_OS_BUILDTYPE ), 10 )
#define COLWIDTH_REG_OWNER                  AsLong( GetResString( IDS_COLWIDTH_REG_OWNER ), 10 )
#define COLWIDTH_REG_ORG                    AsLong( GetResString( IDS_COLWIDTH_REG_ORG ), 10 )
#define COLWIDTH_PRODUCT_ID                 AsLong( GetResString( IDS_COLWIDTH_PRODUCT_ID ), 10 )
#define COLWIDTH_INSTALL_DATE               AsLong( GetResString( IDS_COLWIDTH_INSTALL_DATE ), 10 )
#define COLWIDTH_SYSTEM_UPTIME              AsLong( GetResString( IDS_COLWIDTH_SYSTEM_UPTIME ), 10 )
#define COLWIDTH_SYSTEM_MANUFACTURER        AsLong( GetResString( IDS_COLWIDTH_SYSTEM_MANUFACTURER ), 10 )
#define COLWIDTH_SYSTEM_MODEL               AsLong( GetResString( IDS_COLWIDTH_SYSTEM_MODEL ), 10 )
#define COLWIDTH_SYSTEM_TYPE                AsLong( GetResString( IDS_COLWIDTH_SYSTEM_TYPE ), 10 )
#define COLWIDTH_PROCESSOR                  AsLong( GetResString( IDS_COLWIDTH_PROCESSOR ), 10 )
#define COLWIDTH_BIOS_VERSION               AsLong( GetResString( IDS_COLWIDTH_BIOS_VERSION ), 10 )
#define COLWIDTH_WINDOWS_DIRECTORY          AsLong( GetResString( IDS_COLWIDTH_WINDOWS_DIRECTORY ), 10 )
#define COLWIDTH_SYSTEM_DIRECTORY           AsLong( GetResString( IDS_COLWIDTH_SYSTEM_DIRECTORY ), 10 )
#define COLWIDTH_BOOT_DEVICE                AsLong( GetResString( IDS_COLWIDTH_BOOT_DEVICE ), 10 )
#define COLWIDTH_SYSTEM_LOCALE              AsLong( GetResString( IDS_COLWIDTH_SYSTEM_LOCALE ), 10 )
#define COLWIDTH_INPUT_LOCALE               AsLong( GetResString( IDS_COLWIDTH_INPUT_LOCALE ), 10 )
#define COLWIDTH_TIME_ZONE                  AsLong( GetResString( IDS_COLWIDTH_TIME_ZONE ), 10 )
#define COLWIDTH_TOTAL_PHYSICAL_MEMORY      AsLong( GetResString( IDS_COLWIDTH_TOTAL_PHYSICAL_MEMORY ), 10 )
#define COLWIDTH_AVAILABLE_PHYSICAL_MEMORY  AsLong( GetResString( IDS_COLWIDTH_AVAILABLE_PHYSICAL_MEMORY ), 10 )
#define COLWIDTH_VIRTUAL_MEMORY_MAX         AsLong( GetResString( IDS_COLWIDTH_VIRTUAL_MEMORY_MAX ), 10 )
#define COLWIDTH_VIRTUAL_MEMORY_AVAILABLE   AsLong( GetResString( IDS_COLWIDTH_VIRTUAL_MEMORY_AVAILABLE ), 10 )
#define COLWIDTH_VIRTUAL_MEMORY_INUSE       AsLong( GetResString( IDS_COLWIDTH_VIRTUAL_MEMORY_INUSE ), 10 )
#define COLWIDTH_PAGEFILE_LOCATION          AsLong( GetResString( IDS_COLWIDTH_PAGEFILE_LOCATION ), 10 )
#define COLWIDTH_DOMAIN                     AsLong( GetResString( IDS_COLWIDTH_DOMAIN ), 10 )
#define COLWIDTH_LOGON_SERVER               AsLong( GetResString( IDS_COLWIDTH_LOGON_SERVER ), 10 )
#define COLWIDTH_HOTFIX                     AsLong( GetResString( IDS_COLWIDTH_HOTFIX ), 10 )
#define COLWIDTH_NETWORK_CARD               AsLong( GetResString( IDS_COLWIDTH_NETWORK_CARD ), 10 )

// indexes
#define CI_HOSTNAME                     0
#define CI_OS_NAME                      1
#define CI_OS_VERSION                   2
#define CI_OS_MANUFACTURER              3
#define CI_OS_CONFIG                    4
#define CI_OS_BUILDTYPE                 5
#define CI_REG_OWNER                    6
#define CI_REG_ORG                      7
#define CI_PRODUCT_ID                   8
#define CI_INSTALL_DATE                 9
#define CI_SYSTEM_UPTIME                10
#define CI_SYSTEM_MANUFACTURER          11
#define CI_SYSTEM_MODEL                 12
#define CI_SYSTEM_TYPE                  13
#define CI_PROCESSOR                    14
#define CI_BIOS_VERSION                 15
#define CI_WINDOWS_DIRECTORY            16
#define CI_SYSTEM_DIRECTORY             17
#define CI_BOOT_DEVICE                  18
#define CI_SYSTEM_LOCALE                19
#define CI_INPUT_LOCALE                 20
#define CI_TIME_ZONE                    21
#define CI_TOTAL_PHYSICAL_MEMORY        22
#define CI_AVAILABLE_PHYSICAL_MEMORY    23
#define CI_VIRTUAL_MEMORY_MAX           24
#define CI_VIRTUAL_MEMORY_AVAILABLE     25
#define CI_VIRTUAL_MEMORY_INUSE         26
#define CI_PAGEFILE_LOCATION            27
#define CI_DOMAIN                       28
#define CI_LOGON_SERVER                 29
#define CI_HOTFIX                       30
#define CI_NETWORK_CARD                 31

// formats
#define FMT_OSVERSION           GetResString( IDS_FMT_OSVERSION )
#define FMT_KILOBYTES           GetResString( IDS_FMT_KILOBYTES )
#define FMT_MEGABYTES           GetResString( IDS_FMT_MEGABYTES )
#define FMT_PROCESSOR_TOTAL     GetResString( IDS_FMT_PROCESSOR_TOTAL )
#define FMT_PROCESSOR_INFO      GetResString( IDS_FMT_PROCESSOR_INFO )
#define FMT_UPTIME              GetResString( IDS_FMT_UPTIME )
#define FMT_HOTFIX_TOTAL        GetResString( IDS_FMT_HOTFIX_TOTAL )
#define FMT_HOTFIX_INFO         GetResString( IDS_FMT_HOTFIX_INFO )
#define FMT_NIC_TOTAL           GetResString( IDS_FMT_NIC_TOTAL )
#define FMT_NIC_INFO            GetResString( IDS_FMT_NIC_INFO )
#define FMT_NIC_STATUS          GetResString( IDS_FMT_NIC_STATUS )
#define FMT_DHCP_STATUS         GetResString( IDS_FMT_DHCP_STATUS )
#define FMT_DHCP_SERVER         GetResString( IDS_FMT_DHCP_SERVER )
#define FMT_IPADDRESS_TOTAL     GetResString( IDS_FMT_IPADDRESS_TOTAL )
#define FMT_IPADDRESS_INFO      GetResString( IDS_FMT_IPADDRESS_INFO )
#define FMT_CONNECTION          GetResString( IDS_FMT_CONNECTION )

//
// Mapping information of Win32_ComputerSystem's DomainRole property
// NOTE: Refer to the _DSROLE_MACHINE_ROLE enumeration values in DsRole.h header file
#define VALUE_STANDALONEWORKSTATION         GetResString( IDS_VALUE_STANDALONEWORKSTATION )
#define VALUE_MEMBERWORKSTATION             GetResString( IDS_VALUE_MEMBERWORKSTATION )
#define VALUE_STANDALONESERVER              GetResString( IDS_VALUE_STANDALONESERVER )
#define VALUE_MEMBERSERVER                  GetResString( IDS_VALUE_MEMBERSERVER )
#define VALUE_BACKUPDOMAINCONTROLLER        GetResString( IDS_VALUE_BACKUPDOMAINCONTROLLER )
#define VALUE_PRIMARYDOMAINCONTROLLER       GetResString( IDS_VALUE_PRIMARYDOMAINCONTROLLER )

// netcard status mapping
#define VALUE_DISCONNECTED                  GetResString( IDS_VALUE_DISCONNECTED )
#define VALUE_CONNECTING                    GetResString( IDS_VALUE_CONNECTING )
#define VALUE_CONNECTED                     GetResString( IDS_VALUE_CONNECTED )
#define VALUE_DISCONNECTING                 GetResString( IDS_VALUE_DISCONNECTING )
#define VALUE_HWNOTPRESENT                  GetResString( IDS_VALUE_HWNOTPRESENT )
#define VALUE_HWDISABLED                    GetResString( IDS_VALUE_HWDISABLED )
#define VALUE_HWMALFUNCTION                 GetResString( IDS_VALUE_HWMALFUNCTION )
#define VALUE_MEDIADISCONNECTED             GetResString( IDS_VALUE_MEDIADISCONNECTED )
#define VALUE_AUTHENTICATING                GetResString( IDS_VALUE_AUTHENTICATING )
#define VALUE_AUTHSUCCEEDED                 GetResString( IDS_VALUE_AUTHSUCCEEDED )
#define VALUE_AUTHFAILED                    GetResString( IDS_VALUE_AUTHFAILED )

#define VALUE_YES                           GetResString( IDS_VALUE_YES )
#define VALUE_NO                            GetResString( IDS_VALUE_NO )

// status messages
#define MSG_OSINFO                          GetResString( IDS_MSG_OSINFO )
#define MSG_COMPINFO                        GetResString( IDS_MSG_COMPINFO )
#define MSG_PERFINFO                        GetResString( IDS_MSG_PERFINFO )
#define MSG_PROCESSORINFO                   GetResString( IDS_MSG_PROCESSORINFO )
#define MSG_BIOSINFO                        GetResString( IDS_MSG_BIOSINFO )
#define MSG_INPUTLOCALEINFO                 GetResString( IDS_MSG_INPUTLOCALEINFO )
#define MSG_TZINFO                          GetResString( IDS_MSG_TZINFO )
#define MSG_PAGEFILEINFO                    GetResString( IDS_MSG_PAGEFILEINFO )
#define MSG_HOTFIXINFO                      GetResString( IDS_MSG_HOTFIXINFO )
#define MSG_NICINFO                         GetResString( IDS_MSG_NICINFO )
#define MSG_PROFILEINFO                     GetResString( IDS_MSG_PROFILEINFO )

//
// command line options

// command line options and their indexes in the array
#define MAX_OPTIONS         6

// options allowed ( no need to localize )
#define OPTION_USAGE        _T( "?" )
#define OPTION_SERVER       _T( "s" )
#define OPTION_USERNAME     _T( "u" )
#define OPTION_PASSWORD     _T( "p" )
#define OPTION_FORMAT       _T( "fo" )
#define OPTION_NOHEADER     _T( "nh" )

// option indexes
#define OI_USAGE                    0
#define OI_SERVER                   1
#define OI_USERNAME                 2
#define OI_PASSWORD                 3
#define OI_FORMAT                   4
#define OI_NOHEADER                 5

// values allowed for format
#define OVALUES_FORMAT          GetResString( IDS_OVALUES_FORMAT )

//
// CSystemInfo
//
class CSystemInfo
{
// constructor / destructor
public:
    CSystemInfo();
    ~CSystemInfo();

// data members
private:

    // command line options
    CHString m_strServer;
    CHString m_strUserName;
    CHString m_strPassword;

    // WMI interfaces
    IWbemLocator* m_pWbemLocator;
    IWbemServices* m_pWbemServices;

    // progress message related
    HANDLE m_hOutput;
    CONSOLE_SCREEN_BUFFER_INFO m_csbi;

    // other(s)
    TARRAY m_arrData;                   // output data storage
    PTCOLUMNS m_pColumns;               // output columns information
    BOOL m_bNeedPassword;               // indicates whether password needs to be accepted or not
    BOOL m_bCloseConnection;            // indicate whether closeconnection function to be called or not
    CHString m_strLogonUser;            // used to find the logon server
    COAUTHIDENTITY* m_pAuthIdentity;    // auth identity

public:
    BOOL m_bUsage;
    DWORD m_dwFormat;

// methods
private:
    BOOL LoadOSInfo();
    BOOL LoadBiosInfo();
    BOOL LoadHotfixInfo();
    BOOL LoadProfileInfo();
    BOOL LoadComputerInfo();
    BOOL LoadTimeZoneInfo();
    BOOL LoadPageFileInfo();
    BOOL LoadKeyboardInfo();
    BOOL LoadProcessorInfo();
    BOOL LoadPerformanceInfo();
    BOOL LoadNetworkCardInfo();

    // output related ...
    BOOL AllocateColumns();

public:
    BOOL LoadData();
    BOOL Initialize();
    BOOL ProcessOptions( DWORD argc, LPCTSTR argv[] );
    BOOL Connect();

    VOID ShowUsage();
    VOID ShowOutput( DWORD dwStart = 0, DWORD dwEnd = MAX_COLUMNS );
};

#endif  // __SYSTEMINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\pch.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      pch.h
//
//  Abstract:
//
//      pre-compiled header declaration
//      files that has to be pre-compiled into .pch file
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once        // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#define CMDLINE_VERSION 200
//
// Private nt headers.
//
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
    #include <Security.h>
    #include <SecExt.h>
}

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <wbemidl.h>
#include <chstring.h>
#include <comdef.h>
#include <wbemtime.h>
#include <dbghelp.h>
#include <winuserp.h>

//
// public C header files
//
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>
#include <errno.h>
#include <strsafe.h>
//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\init.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      Init.cpp
//
//  Abstract:
//
//      This module implements the general initialization stuff
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "taskkill.h"

CTaskKill::CTaskKill()
/*++
Routine Description:
      CTaskKill contructor

Arguments:
      NONE

Return Value:
      NONE
--*/
{
    // init to defaults
    m_arrFilters = NULL;
    m_arrTasksToKill = NULL;
    m_bUsage = FALSE;
    m_bTree = FALSE;
    m_bForce = FALSE;
    m_dwCurrentPid = 0;
    m_bNeedPassword = FALSE;
    m_arrFiltersEx = NULL;
    m_bNeedServicesInfo = FALSE;
    m_bNeedUserContextInfo = FALSE;
    m_bNeedModulesInfo = FALSE;
    m_pfilterConfigs = NULL;
    m_arrWindowTitles = NULL;
    m_pWbemLocator = NULL;
    m_pWbemServices = NULL;
    m_pWbemEnumObjects = NULL;
    m_pWbemTerminateInParams = NULL;
    m_bIsHydra = FALSE;
    m_hWinstaLib = NULL;
    m_pProcessInfo = NULL;
    m_ulNumberOfProcesses = 0;
    m_bCloseConnection = FALSE;
    m_dwServicesCount = 0;
    m_pServicesInfo = NULL;
    m_bUseRemote = FALSE;
    m_pdb = NULL;
    m_pfnWinStationFreeMemory = NULL;
    m_pfnWinStationOpenServerW = NULL;
    m_pfnWinStationCloseServer = NULL;
    m_pfnWinStationFreeGAPMemory = NULL;
    m_pfnWinStationGetAllProcesses = NULL;
    m_pfnWinStationEnumerateProcesses = NULL;
    m_arrRecord = NULL;
    m_pAuthIdentity = NULL;
    m_bTasksOptimized = FALSE;
    m_bFiltersOptimized = FALSE;
}


CTaskKill::~CTaskKill()
/*++
Routine Description:
      CTaskKill destructor

Arguments:
      NONE

Return Value:
      NONE
--*/
{
    //
    // de-allocate memory allocations
    //

    //
    // destroy dynamic arrays
    DESTROY_ARRAY( m_arrRecord );
    DESTROY_ARRAY( m_arrFilters );
    DESTROY_ARRAY( m_arrFiltersEx );
    DESTROY_ARRAY( m_arrWindowTitles );
    DESTROY_ARRAY( m_arrTasksToKill );

    //
    // memory ( with new operator )
    RELEASE_MEMORY_EX( m_pfilterConfigs );

    //
    // release WMI / COM interfaces
    SAFE_RELEASE( m_pWbemLocator );
    SAFE_RELEASE( m_pWbemServices );
    SAFE_RELEASE( m_pWbemEnumObjects );
    SAFE_RELEASE( m_pWbemTerminateInParams );

    // free the wmi authentication structure
    WbemFreeAuthIdentity( &m_pAuthIdentity );

    // if connection to the remote system opened with NET API has to be closed .. do it
    if ( m_bCloseConnection == TRUE )
    {
        CloseConnection( m_strServer );
    }
    // free the memory allocated for services variables
    FreeMemory( ( LPVOID * )&m_pServicesInfo );

    // free the memory allocated for performance block
    FreeMemory( ( LPVOID * ) &m_pdb );

    //
    // free winstation block
    if ( ( FALSE == m_bIsHydra ) && ( NULL != m_pProcessInfo ) )
    {
        // free the GAP memory block
        WinStationFreeGAPMemory( GAP_LEVEL_BASIC,
            (PTS_ALL_PROCESSES_INFO) m_pProcessInfo, m_ulNumberOfProcesses );

        // ...
        m_pProcessInfo = NULL;
    }
    else
    {
        if ( ( TRUE == m_bIsHydra ) && ( NULL != m_pProcessInfo ) )
        {
            // free the winsta memory block
            WinStationFreeMemory( m_pProcessInfo );
            m_pProcessInfo = NULL;
        }
    }
    // free the library
    if ( NULL != m_hWinstaLib )
    {
        FreeLibrary( m_hWinstaLib );
        m_hWinstaLib = NULL;
        m_pfnWinStationFreeMemory = NULL;
        m_pfnWinStationOpenServerW = NULL;
        m_pfnWinStationCloseServer = NULL;
        m_pfnWinStationFreeGAPMemory = NULL;
        m_pfnWinStationGetAllProcesses = NULL;
        m_pfnWinStationEnumerateProcesses = NULL;
    }

    // uninitialize the com library
    CoUninitialize();
}


BOOL
CTaskKill::Initialize(
    void
    )
/*++
Routine Description:
      initialize the task list utility

Arguments:
      NONE

Return Value:
      TRUE    : if filters are appropriately specified
      FALSE   : if filters are errorneously specified
--*/
{
    //
    // memory allocations

    // if at all any occurs, we know that is 'coz of the
    // failure in memory allocation ... so set the error
    SetLastError( ( DWORD )E_OUTOFMEMORY );
    SaveLastError();

    // get the current process id and save it
    m_dwCurrentPid = GetCurrentProcessId();

    // filters ( user supplied )
    if ( NULL == m_arrFilters )
    {
        m_arrFilters = CreateDynamicArray();
        if ( NULL == m_arrFilters )
        {
            return FALSE;
        }
    }

    // tasks to be killed ( user supplied )
    if ( NULL == m_arrTasksToKill )
    {
        m_arrTasksToKill = CreateDynamicArray();
        if ( NULL == m_arrTasksToKill )
        {
            return FALSE;
        }
    }

    // filters ( program generated parsed filters )
    if ( NULL == m_arrFiltersEx )
    {
        m_arrFiltersEx = CreateDynamicArray();
        if ( NULL == m_arrFiltersEx )
        {
            return FALSE;
        }
    }

    // filters configuration info
    if ( NULL == m_pfilterConfigs )
    {
        m_pfilterConfigs = ( TFILTERCONFIG * )AllocateMemory( sizeof( TFILTERCONFIG ) * MAX_FILTERS );
        if ( NULL == m_pfilterConfigs )
        {
            return FALSE;
        }
        // init to ZERO's
        SecureZeroMemory( m_pfilterConfigs, MAX_FILTERS * sizeof( TFILTERCONFIG ) );
    }

    // window titles
    if ( NULL == m_arrWindowTitles )
    {
        m_arrWindowTitles = CreateDynamicArray();
        if ( NULL == m_arrWindowTitles )
        {
            return FALSE;
        }
    }

    // tasks
    if ( NULL == m_arrRecord )
    {
        m_arrRecord = CreateDynamicArray();
        if ( NULL == m_arrRecord )
        {
            return FALSE;
        }
    }

    // initialize the COM library
    if ( FALSE == InitializeCom( &m_pWbemLocator ) )
    {
        return FALSE;
    }

    //
    // load the winsta library and needed functions
    // NOTE: do not raise any error if loading of winsta dll fails
    {   // Local variabels should be destroyed inside this block.
        // +1 is for terminating NULL character.
        LPWSTR lpszSystemPath = NULL;
        DWORD dwLength = MAX_PATH + 1;
        DWORD dwExpectedLength = 0;
        DWORD dwActualBufLen = 0;

        do
        {
            dwActualBufLen = dwLength + 5 + StringLength( WINSTA_DLLNAME, 0 );
            // Length of 'System32' + Length of '\' + Length of 'WINSTA_DLLNAME' + Length of '\0'.
            // 3 WCHARS are extra, to be on safer side.
            lpszSystemPath = (LPWSTR) AllocateMemory( dwActualBufLen * sizeof( WCHAR ) );
            if( NULL == lpszSystemPath )
            {   // Out of memory.
                m_hWinstaLib = NULL;
                break;
            }

            dwExpectedLength = GetSystemDirectory( lpszSystemPath, dwLength );
            if( ( 0 != dwExpectedLength ) ||
                ( dwLength > dwExpectedLength ) )
            {   // Successful
                StringConcat( lpszSystemPath, L"\\", dwActualBufLen );
                StringConcat( lpszSystemPath, WINSTA_DLLNAME, dwActualBufLen );
                m_hWinstaLib = ::LoadLibrary( lpszSystemPath );
                FreeMemory( (LPVOID * )&lpszSystemPath );
                break;
            }
            FreeMemory( (LPVOID * )&lpszSystemPath );
            m_hWinstaLib = NULL;
            // +1 is for terminating NULL character.
            dwLength = dwExpectedLength + 1;
        }while( 0 != dwExpectedLength );
    }

    if ( NULL != m_hWinstaLib )
    {
        // library loaded successfully ... now load the addresses of functions
        m_pfnWinStationFreeMemory = (FUNC_WinStationFreeMemory) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationFreeMemory );
        m_pfnWinStationCloseServer = (FUNC_WinStationCloseServer) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationCloseServer );
        m_pfnWinStationOpenServerW = (FUNC_WinStationOpenServerW) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationOpenServerW );
        m_pfnWinStationFreeGAPMemory = (FUNC_WinStationFreeGAPMemory) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationFreeGAPMemory );
        m_pfnWinStationGetAllProcesses = (FUNC_WinStationGetAllProcesses) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationGetAllProcesses );
        m_pfnWinStationEnumerateProcesses = (FUNC_WinStationEnumerateProcesses) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationEnumerateProcesses );

        // we will keep the library loaded in memory only if all the functions were loaded successfully
        if ( ( NULL == m_pfnWinStationFreeMemory ) ||
             ( NULL == m_pfnWinStationCloseServer ) ||
             ( NULL == m_pfnWinStationOpenServerW ) ||
             ( NULL == m_pfnWinStationFreeGAPMemory ) ||
             ( NULL == m_pfnWinStationGetAllProcesses ) ||
             ( NULL == m_pfnWinStationEnumerateProcesses )
           )
        {
            // some (or) all of the functions were not loaded ... unload the library
            FreeLibrary( m_hWinstaLib );
            m_hWinstaLib = NULL;
            m_pfnWinStationFreeMemory = NULL;
            m_pfnWinStationOpenServerW = NULL;
            m_pfnWinStationCloseServer = NULL;
            m_pfnWinStationFreeGAPMemory = NULL;
            m_pfnWinStationGetAllProcesses = NULL;
            m_pfnWinStationEnumerateProcesses = NULL;
        }
    }

    // initialization is successful
    SetLastError( ( DWORD )NOERROR );            // clear the error
    SetReason( NULL_STRING );           // clear the reason
    return TRUE;
}

BOOL
CTaskKill::EnableDebugPriv(
    void
    )
/*++
Routine Description:
      Enables the debug privliges for the current process so that
      this utility can terminate the processes on local system without any problem

Arguments:
      NONE

Return Value:
      TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    LUID luidValue ;
    BOOL bResult = FALSE;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;

    SecureZeroMemory( &luidValue, sizeof( LUID ) );
    SecureZeroMemory( &tkp, sizeof( TOKEN_PRIVILEGES ) );

    // Retrieve a handle of the access token
    bResult = OpenProcessToken( GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken );
    if ( FALSE == bResult )
    {
        // save the error messaage and return
        SaveLastError();
        return FALSE;
    }

    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depends on this flag.
    bResult = LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &luidValue );
    if ( FALSE == bResult )
    {
        // save the error messaage and return
        SaveLastError();
        CloseHandle( hToken );
        return FALSE;
    }

    // prepare the token privileges structure
    tkp.PrivilegeCount = 1;
    tkp.Privileges[ 0 ].Luid = luidValue;
    tkp.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;

    // now enable the debug privileges in the token
    bResult = AdjustTokenPrivileges( hToken, FALSE, &tkp, sizeof( TOKEN_PRIVILEGES ),
        ( PTOKEN_PRIVILEGES ) NULL, ( PDWORD ) NULL );
    if ( FALSE == bResult )
    {
        // The return value of AdjustTokenPrivileges be texted
        SaveLastError();
        CloseHandle( hToken );
        return FALSE;
    }

    // close the opened token handle
    CloseHandle( hToken );

    // enabled ... inform success
    return TRUE;
}

BOOLEAN
CTaskKill::WinStationFreeMemory(
    IN PVOID pBuffer
    )
/*++
Routine Description:
    Free memory.

Arguments:
    [in] pBuffer : Cotains memory location to free.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the buffer and act
    if ( NULL == pBuffer )
    {
        return TRUE;
    }
    // check whether pointer exists or not
    if ( NULL == m_pfnWinStationFreeMemory )
    {
        return FALSE;
    }
    // call and return the same
    return ((FUNC_WinStationFreeMemory) m_pfnWinStationFreeMemory)( pBuffer );
}


BOOLEAN
CTaskKill::WinStationCloseServer(
    IN HANDLE hServer
    )
/*++
Routine Description:
    Handle to window station is closed.

Arguments:
    [in] hServer : Handle to window station.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input
    if ( NULL == hServer )
    {
        return TRUE;
    }
    // check whether the function pointer exists or not
    if ( NULL == m_pfnWinStationCloseServer )
    {
        return FALSE;
    }
    // call and return
    return ((FUNC_WinStationCloseServer) m_pfnWinStationCloseServer)( hServer );
}


HANDLE
CTaskKill::WinStationOpenServerW(
    IN LPWSTR pwszServerName
    )
/*++
Routine Description:
    Retrieves a handle to an window station on a system.

Arguments:
    [in] pwszServerName : System name from where to retrieve window station handle.

Return Value:
    Valid handle is returned if successful else NULL is returned.
--*/
{
    // check the input & also check whether function pointer exists or not
    if ( ( NULL == pwszServerName ) ||
         ( NULL == m_pfnWinStationOpenServerW ) )
    {
        return NULL;
    }
    // call and return
    return ((FUNC_WinStationOpenServerW) m_pfnWinStationOpenServerW)( pwszServerName );
}


BOOLEAN
CTaskKill::WinStationEnumerateProcesses(
    IN HANDLE hServer,
    OUT PVOID* ppProcessBuffer
    )
/*++
Routine Description:
    Retrieves process running on a system.

Arguments:
    [in] hServer            : Cotains handle to window station.
    [ out ] ppProcessBuffer : Contains process infomration on remote system.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input and also check whether function pointer exists or not
    if ( ( NULL == ppProcessBuffer ) ||
         ( NULL == m_pfnWinStationEnumerateProcesses ) )
    {
        return FALSE;
    }
    // call and return
    return ((FUNC_WinStationEnumerateProcesses)
        m_pfnWinStationEnumerateProcesses)( hServer, ppProcessBuffer );
}


BOOLEAN
CTaskKill::WinStationFreeGAPMemory(
    IN ULONG ulLevel,
    IN PVOID pProcessArray,
    IN ULONG ulCount
    )
/*++
Routine Description:
    Free gap memory block.

Arguments:
    [in] ulLevel         : Contains information level of data.
    [ in ] pProcessArray : Contains data to be freed.
    [ in ] ulCount       : Contains number of blocks to be freed.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input
    if ( NULL == pProcessArray )
    {
        return TRUE;
    }
    // check whether function pointer exists or not
    if ( NULL == m_pfnWinStationFreeGAPMemory )
    {
        return FALSE;
    }
    // call and return
    return ((FUNC_WinStationFreeGAPMemory)
        m_pfnWinStationFreeGAPMemory)( ulLevel, pProcessArray, ulCount );
}


BOOLEAN
CTaskKill::WinStationGetAllProcesses(
    IN HANDLE hServer,
    IN ULONG ulLevel,
    OUT ULONG* pNumberOfProcesses,
    OUT PVOID* ppProcessArray
    )
/*++
Routine Description:
    Retrieves process information running on a system.

Arguments:
    [in] hServer               : Cotains handle to window station.
    [ in ] ulLevel             : Contains information level of data.
    [ out ] pNumberOfProcesses : Contains number of process retrieved.
    [ out ] ppProcessArray     : Contains process realted infomration.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input & check whether function pointer exists or not
    if ( ( NULL == pNumberOfProcesses ) ||
         ( NULL == ppProcessArray ) ||
         ( NULL == m_pfnWinStationGetAllProcesses ) )
    {
        return FALSE;
    }
    return ((FUNC_WinStationGetAllProcesses)
        m_pfnWinStationGetAllProcesses)( hServer, ulLevel, pNumberOfProcesses, ppProcessArray );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\systeminfo\wmi.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    WMI.cpp

Abstract:

    Common functionlity for dealing with WMI.

Author:

    Wipro Technologies

Revision History:

    22-Dec-2000 : Created It.
    24-Apr-2001 : Closing the review comments given by client.

*********************************************************************************************/

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD              GetResString( IDS_STR_INPUT_PASSWORD )
#define INPUT_PASSWORD_LEN          256
// error constants
#define E_SERVER_NOTFOUND           0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface,
                              DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface,
                              LPCWSTR pwszUser,
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword,
                                      LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices,
                          LPCWSTR pwszMethod, DWORD dwHDefKey,
                          LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );


BOOL
IsValidUserEx(
    LPCWSTR pwszUser
    )
/*++

Routine Description:

    Checks wether the User name is a valid one or not

Arguments:

    [in] LPCWSTR    :   String containing the user name

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    CHString strUser;
    LONG lPos = 0;

    if ( ( NULL == pwszUser ) || ( 0 == StringLength( pwszUser, 0 ) ) )
    {
        return TRUE;
    }

    try
    {
        // get user into local memory
        strUser = pwszUser;

        // user name should not be just '\'
        if ( strUser.CompareNoCase( L"\\" ) == 0 )
        {
            return FALSE;
        }

        // user name should not contain invalid characters
        if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
        {
            return FALSE;
        }

        // SPECIAL CHECK
        // check for multiple '\' characters in the user name
        lPos = strUser.Find( L'\\' );
        if ( -1 != lPos )
        {
            // '\' character exists in the user name
            // strip off the user info upto first '\' character
            // check for one more '\' in the remaining string
            // if it exists, invalid user
            strUser = strUser.Mid( lPos + 1 );
            lPos = strUser.Find( L'\\' );
            if ( -1 != lPos )
            {
                return FALSE;
            }
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // user name is valid
    return TRUE;
}


BOOL
IsValidServerEx(
    LPCWSTR pwszServer,
    BOOL& bLocalSystem
    )
/*++

Routine Description:

    Checks wether the Server name is a valid one or not

Arguments:

    [in]  LPCWSTR   :   String containing the user name
    [out] BOOL      :   Is set to TRUE if the local system is being queried.

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    CHString strTemp;

    // Validate input arguments.
    if ( ( NULL == pwszServer ) || ( 0 == StringLength( pwszServer, 0 ) ) )
    {
       bLocalSystem = TRUE;
       return TRUE;
    }

    try
    {
        // kick-off
        bLocalSystem = FALSE;

        if( IsNumeric( pwszServer, 10, FALSE ) == TRUE )
        {
            return FALSE;
        }

        // get a local copy
        strTemp = pwszServer;

        // remove the forward slashes (UNC) if exist in the begining of the server name
        if ( IsUNCFormat( strTemp ) == TRUE )
        {
            strTemp = strTemp.Mid( 2 );
            if ( strTemp.GetLength() == 0 )
            {
                return FALSE;
            }
        }

        if ( strTemp.FindOneOf( L"`~!@#$^&*()+=[]{}|\\<>,?/\"':;" ) != -1 )
        {
            return FALSE;
        }

        // now check if any '\' character appears in the server name. If so error
        if ( strTemp.Find( L'\\' ) != -1 )
        {
            return FALSE;
        }

        // now check if server name is '.' only which represent local system in WMI
        // else determine whether this is a local system or not
        if ( strTemp.CompareNoCase( L"." ) == 0 )
        {
            bLocalSystem = TRUE;
        }
        else
        {
            bLocalSystem = IsLocalSystem( strTemp );
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // inform that server name is valid
    return TRUE;
}


BOOL
InitializeCom(
    IWbemLocator** ppLocator
    )
/*++
Routine Description:

    Initializes the COM library

Arguments:

    [in] IWbemLocator   :   pointer to the IWbemLocator

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;

    try
    {
        // Validate input arguments.
        if( ( NULL == ppLocator ) ||
            ( NULL != *ppLocator ) )
        {
             _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }




        // initialize the COM library
        SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_MULTITHREADED ) );

        // initialize the security
        SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

        // create the locator and get the pointer to the interface of IWbemLocator
        SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

        // initialization successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the WMI error
        WMISaveError( e );
        // Error is returned. Release any interface pointers.
        SAFE_RELEASE( *ppLocator );
    }

    // return the result;
    return bResult;
}


BOOL
ConnectWmi(
    IWbemLocator* pLocator,
    IWbemServices** ppServices,
    LPCWSTR pwszServer,
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    COAUTHIDENTITY** ppAuthIdentity,
    BOOL bCheckWithNullPwd,
    LPCWSTR pwszNamespace,
    HRESULT* phr,
    BOOL* pbLocalSystem,
    IWbemContext* pWbemContext
    )
/*++

Routine Description:

    This function makes a connection to WMI.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;
    _bstr_t bstrServer;
    _bstr_t bstrNamespace;
    _bstr_t bstrUser, bstrPassword;

    // clear the error
    SetLastError( WBEM_S_NO_ERROR );

    // check whether locator object exists or not
    // if not exists, return
    if ( ( NULL == pLocator ) ||
         ( NULL == ppServices ) ||
         ( NULL != *ppServices ) ||
         ( NULL == pwszNamespace ) )
    {
        if ( NULL != phr )
        {
            *phr = WBEM_E_INVALID_PARAMETER;
        }
        // return failure
        return FALSE;
    }

    // kick-off
    if ( NULL != pbLocalSystem )
    {
        *pbLocalSystem = FALSE;
    }

    // ...
    if ( NULL != phr )
    {
        *phr = WBEM_S_NO_ERROR;
    }

    try
    {

        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // validate the server name
        // NOTE: The error being raised in custom define for '0x800706ba' value
        //       The message that will be displayed in "The RPC server is unavailable."
        if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
        {
            _com_issue_error( E_SERVER_NOTFOUND );
        }

        // validate the user name
        if ( IsValidUserEx( pwszUser ) == FALSE )
        {
            _com_issue_error( ERROR_NO_SUCH_USER );
        }

        // prepare namespace
        bstrNamespace = pwszNamespace;              // name space
        if ( ( NULL != pwszServer ) && ( FALSE == bLocalSystem ) )
        {
            // get the server name
            bstrServer = pwszServer;

            // prepare the namespace
            // NOTE: check for the UNC naming format of the server and do
            if ( IsUNCFormat( pwszServer ) == TRUE )
            {
                bstrNamespace = bstrServer + L"\\" + pwszNamespace;
            }
            else
            {
                bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
            }

            // user credentials
            if ( ( NULL != pwszUser ) && ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                // copy the user name
                bstrUser = pwszUser;

                // if password is empty string and if we need to check with
                // null password, then do not set the password and try
                bstrPassword = pwszPassword;
                if ( ( TRUE == bCheckWithNullPwd ) && ( 0 == bstrPassword.length() ) )
                {
                    bstrPassword = (LPWSTR) NULL;
                }
            }
        }
        else
        {    // Display warning message, credentials not required for local system.
            if( ( TRUE == bLocalSystem ) && ( NULL != pwszUser ) &&
                ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                 // got the credentials for the local system
                 if ( NULL != phr )
                 {
                     *phr = WBEM_E_LOCAL_CREDENTIALS;
                 }
            }
        }

        // connect to the remote system's WMI
        // there is a twist here ...
        // do not trap the ConnectServer function failure into exception
        // instead handle that action manually
        // by default try the ConnectServer function as the information which we have
        // in our hands at this point. If the ConnectServer is failed,
        // check whether password variable has any contents are not ... if no contents
        // check with "" (empty) password ... this might pass in this situation ..
        // if this call is also failed ... nothing is there that we can do ... throw the exception
        hr = pLocator->ConnectServer( bstrNamespace,
            bstrUser, bstrPassword, 0L, 0L, NULL, pWbemContext, ppServices );
        if ( FAILED( hr ) )
        {
            //
            // special case ...

            // check whether password exists or not
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'
            if ( hr == E_ACCESSDENIED )
            {
                // check if we tried to connect to the system using null password
                // if so, then try connecting to the remote system with empty string
                if ( bCheckWithNullPwd == TRUE &&
                     bstrUser.length() != 0 && bstrPassword.length() == 0 )
                {
                    // now invoke with ...
                    hr = pLocator->ConnectServer( bstrNamespace,
                        bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, pWbemContext, ppServices );
                }
            }
            else
            {
                if ( WBEM_E_LOCAL_CREDENTIALS == hr )
                {
                    // credentials were passed to the local system.
                    // So ignore the credentials and try to reconnect
                    bLocalSystem = TRUE;
                    bstrUser = (LPWSTR) NULL;
                    bstrPassword = (LPWSTR) NULL;
                    bstrNamespace = pwszNamespace;              // name space
                    hr = pLocator->ConnectServer( bstrNamespace,
                        NULL, NULL, 0L, 0L, NULL, pWbemContext, ppServices );
                }
            }

            // now check the result again .. if failed .. ummmm..
            if ( FAILED( hr ) )
            {
                _com_issue_error( hr );
            }
            else
            {
                bstrPassword = L"";
            }
        }

        // set the security at the interface level also
        SAFE_EXECUTE( SetInterfaceSecurity( *ppServices,
            bstrUser, bstrPassword, ppAuthIdentity ) );

        // ...
        if ( NULL != pbLocalSystem )
        {
            *pbLocalSystem = bLocalSystem;
        }

        // connection to WMI is successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the error
        WMISaveError( e );

        // save the hr value if needed by the caller
        if ( NULL != phr )
        {
            *phr = e.Error();
        }
        SAFE_RELEASE( *ppServices );
        bResult = FALSE;
    }

    // return the result
    return bResult;
}


BOOL
ConnectWmiEx(
    IWbemLocator* pLocator,
    IWbemServices** ppServices,
    LPCWSTR pwszServer,
    CHString& strUserName,
    CHString& strPassword,
    COAUTHIDENTITY** ppAuthIdentity,
    BOOL bNeedPassword,
    LPCWSTR pwszNamespace,
    BOOL* pbLocalSystem,
    DWORD dwPasswordLen,
    IWbemContext* pWbemContext
    )
/*++

Routine Description:

    This function is a wrapper function for the ConnectWmi function.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system
    [ in ] DWORD                :   Contains maximum password buffer length.

Return Value:

    TRUE on success
    FALSE on failure

NOTE: 'dwPasswordLen' WILL BE TAKEN AS 'MAX_STRING_LENGTH' IF NOT SPECIFIED.
      IT IS USER RESPOSIBILITY TO SET THIS PARAMETER TO LIMITING VALUE.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszPassword = NULL;
    CHString strBuffer;

    // clear the error .. if any
    SetLastError( WBEM_S_NO_ERROR );

    try
    {
        // sometime users want the utility to prompt for the password
        // check what user wants the utility to do
        if ( ( TRUE == bNeedPassword ) &&
             ( 0 == strPassword.Compare( L"*" ) ) )
        {
            // user wants the utility to prompt for the password
            // so skip this part and let the flow directly jump the password acceptance part
        }
        else
        {
            // try to establish connection to the remote system with the credentials supplied
            if ( 0 == strUserName.GetLength() )
            {
                // user name is empty
                // so, it is obvious that password will also be empty
                // even if password is specified, we have to ignore that
                bResult = ConnectWmi( pLocator, ppServices,
                    pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem, pWbemContext );
            }
            else
            {
                // credentials were supplied
                // but password might not be specified ... so check and act accordingly
                LPCWSTR pwszTemp = NULL;
                BOOL bCheckWithNull = TRUE;
                if ( bNeedPassword == FALSE )
                {
                    pwszTemp = strPassword;
                    bCheckWithNull = FALSE;
                }

                // ...
                bResult = ConnectWmi( pLocator, ppServices, pwszServer,
                    strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem, pWbemContext );
            }

            SetLastError (hr);

            // check the result ... if successful in establishing connection ... return
            if ( TRUE == bResult )
            {
                return TRUE;
            }

            // now check the kind of error occurred
            switch( hr )
            {
            case E_ACCESSDENIED:
                SetLastError( hr );
                break;

            case WBEM_E_LOCAL_CREDENTIALS:
                SetLastError( hr );
                // needs to do special processing
                break;

            case WBEM_E_ACCESS_DENIED:
            default:
                // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
                //       this error code says that user with the current credentials is not
                //       having access permisions to the 'namespace'
                WMISaveError( hr );
                return FALSE;       // no use of accepting the password .. return failure
                break;
            }


            // if failed in establishing connection to the remote terminal
            // even if the password is specifed, then there is nothing to do ... simply return failure
            if ( bNeedPassword == FALSE )
            {
                return FALSE;
            }
        }

        // check whether user name is specified or not
        // if not, get the local system's current user name under whose credentials, the process
        // is running
        if ( 0 == strUserName.GetLength() )
        {
            // sub-local variables
            LPWSTR pwszUserName = NULL;
            DWORD dwUserLength = 0;    // Username buffer length.
            // Retrieve the buffer length need to store username.
            GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength );

            // get the required buffer
            pwszUserName = strUserName.GetBufferSetLength( dwUserLength );

            if ( FALSE == GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) )
            {
                // error occured while trying to get the current user info
                SaveLastError();
                return FALSE;
            }
            // No need to call 'ReleaseBuffer' since only sufficient memory is allocated.
        }

        // get the required buffer
        if( 0 == dwPasswordLen )
        {
             dwPasswordLen = INPUT_PASSWORD_LEN;
        }
        pwszPassword = strPassword.GetBufferSetLength( dwPasswordLen );

        // accept the password from the user
        strBuffer.Format( INPUT_PASSWORD, strUserName );
        WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ),
            strBuffer, strBuffer.GetLength(), &dwSize, NULL );

        bResult = GetPassword( pwszPassword, dwPasswordLen );
        if ( TRUE != bResult )
        {
            return FALSE;
        }

        // release the buffer allocated for password
        strPassword.ReleaseBuffer();

        // now again try to establish the connection using the currently
        // supplied credentials
        bResult = ConnectWmi( pLocator, ppServices, pwszServer,
            strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace,
            NULL, pbLocalSystem, pWbemContext );
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return the failure
    return bResult;
}


HRESULT
GetSecurityArguments(
    IUnknown* pInterface,
    DWORD& dwAuthorization,
    DWORD& dwAuthentication
    )
/*++

Routine Description:

    This function gets the values for the security services.

Arguments:

    [in] IUnknown   :   pointer to the IUnkown interface
    [out] DWORD     :   to hold the authentication service value
    [out] DWORD     :   to hold the authorization service value

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
    IClientSecurity* pClientSecurity = NULL;

    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    // try to get the client security services values if possible
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
    if ( SUCCEEDED( hr ) )
    {
        // got the client security interface
        // now try to get the security services values
        hr = pClientSecurity->QueryBlanket( pInterface,
            &dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
        if ( SUCCEEDED( hr ) )
        {
            // we've got the values from the interface
            dwAuthentication = dwAuthnSvc;
            dwAuthorization = dwAuthzSvc;
        }

        // release the client security interface
        SAFE_RELEASE( pClientSecurity );
    }

    // return always success
    return hr;
}


HRESULT
SetInterfaceSecurity(
    IUnknown* pInterface,
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    COAUTHIDENTITY** ppAuthIdentity
    )
/*++

Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] LPCWSTR            :   string containing the User name
    [in] LPCWSTR            :   string containing the password
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString strUser;
    CHString strDomain;
    LPCWSTR pwszUserArg = NULL;
    LPCWSTR pwszDomainArg = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    try
    {
        // check the interface
        if ( NULL == pInterface )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // check the authentity strcuture ... if authentity structure is already ready
        // simply invoke the 2nd version of SetInterfaceSecurity
        if ( NULL != *ppAuthIdentity )
        {
            return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
        }

        // If we are doing trivial case, just pass in a null authenication structure
        // for which the current logged in user's credentials will be considered
        if ( ( NULL == pwszUser ) &&
             ( NULL == pwszPassword ) )
        {
            // set the security
            hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization,
                NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY , RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

            // return the result
            return hr;
        }

        // if authority srtucture is NULL then no need to proceed
        if ( NULL == ppAuthIdentity )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // check if authenication info is available or not ...
        // initialize the security authenication information ... UNICODE VERSION STRUCTURE
        if ( NULL == *ppAuthIdentity )
        {
            // parse and find out if the user name contains the domain name
            // if contains, extract the domain value from it
            LONG lPos = -1;
            strDomain = L"";
            strUser = pwszUser;
            if ( -1 != ( lPos = strUser.Find( L'\\' ) ) )
            {
                // user name contains domain name ... domain\user format
                strDomain = strUser.Left( lPos );
                strUser = strUser.Mid( lPos + 1 );
            }
            else
            {
                if ( -1 != ( lPos = strUser.Find( L'@' ) ) )
                {
                    // NEED TO IMPLEMENT THIS ... IF NEEDED
                    // This implementation needs to be done if WMI does not support
                    // UPN name formats directly and if we have to split the
                    // name(user@domain)
                }
                else
                {
                    // server itself is the domain
                    // NOTE: NEED TO DO SOME R & D ON BELOW COMMENTED LINE
                    // strDomain = pwszServer;
                }
             }

            // get the domain info if it exists only
            if ( 0 != strDomain.GetLength() )
            {
                pwszDomainArg = strDomain;
            }

            // get the user info if it exists only
            if ( 0 != strUser.GetLength() )
            {
                pwszUserArg = strUser;
            }

            hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
            if ( FAILED(hr) )
            {
              return hr;
            }
        }

        // set the security information to the interface
        hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY , RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );
    }
    catch( CHeap_Exception )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    // return the result
    return hr;
}


HRESULT
SetInterfaceSecurity(
    IUnknown* pInterface,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    // 'pAuthIdentity' can be NULL or not, so need to check.
    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // get the current security argument value
    hr = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY , RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}


HRESULT
WINAPI SetProxyBlanket(
    IUnknown* pInterface,
    DWORD dwAuthnSvc,
    DWORD dwAuthzSvc,
    LPWSTR pwszPrincipal,
    DWORD dwAuthLevel,
    DWORD dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
    DWORD dwCapabilities
    )
/*++

Routine Description:

    This function sets the authentication information (the security blanket)
    that will be used to make calls.

Arguments:

    [in] IUnknown                       :   pointer to the IUnkown interface
    [in] DWORD                          :   contains the authentication service to use
    [in] DWORD                          :   contains the authorization service to use
    [in] LPWSTR                         :   the server principal name to use
    [in] DWORD                          :   contains the authentication level to use
    [in] DWORD                          :   contains the impersonation level to use
    [in] RPC_AUTH_IDENTITY_HANDLE       :   pointer to the identity of the client
    [in] DWORD                          :   contains the capability flags

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

    // Validate input arguments.
    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if( ( NULL == pInterface ) ||
        ( ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) ) &&
          ( NULL != pAuthInfo ) )
      )
    {
        return( WBEM_E_INVALID_PARAMETER );
    }

    // get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( FAILED(hr) )
    {
        return hr;
    }

    // now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( FAILED(hr) )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    // now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pUnknown );
        SAFE_RELEASE( pClientSecurity );
        return hr;
    }

    // release the security interface
    SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( NULL != pAuthInfo )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( SUCCEEDED(hr) )
        {
            // set security authentication
            hr = pClientSecurity->SetBlanket( pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

            // release
            SAFE_RELEASE( pClientSecurity );
        }
        else
        {
            if ( E_NOINTERFACE == hr )
            {
                hr = S_OK;      // ignore no interface errors
            }
        }
    }

    // release the IUnknown
    SAFE_RELEASE( pUnknown );

    // return the result
    return hr;
}


HRESULT
WINAPI WbemAllocAuthIdentity(
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    LPCWSTR pwszDomain,
    COAUTHIDENTITY** ppAuthIdent
    )
/*++

Routine Description:

    This function allocates memory for the AUTHIDENTITY structure.

Arguments:

    [in] LPCWSTR            :   string containing the user name
    [in] LPCWSTR            :   string containing the password
    [in] LPCWSTR            :   string containing the domain name
    [out] COAUTHIDENTITY    :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

NOTE: 'ppAuthIdent' should be freed by calling 'WbemFreeAuthIdentity' by the user after
      their work is done.

--*/
{
    // local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

    // validate the input parameter
    if ( NULL == ppAuthIdent )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // init with 0's
    SecureZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

    //
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong

    // user
    if ( NULL != pwszUser )
    {
        // allocate memory for user
        LONG lLength = StringLength( pwszUser, 0 );
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->User )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        StringCopy( pAuthIdent->User, pwszUser, (lLength + 1) );
    }

    // domain
    if ( NULL != pwszDomain )
    {
        // allocate memory for domain
        LONG lLength = StringLength( pwszDomain, 0 );
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Domain )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        StringCopy( pAuthIdent->Domain, pwszDomain, (lLength + 1) );
    }

    // passsord
    if ( NULL != pwszPassword )
    {
        // allocate memory for passsord
        LONG lLength = StringLength( pwszPassword, 0 );
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Password )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        StringCopy( pAuthIdent->Password, pwszPassword, (lLength + 1) );
    }

    // type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
    *ppAuthIdent = pAuthIdent;

    // return result
    return S_OK;
}


VOID
WINAPI WbemFreeAuthIdentity(
    COAUTHIDENTITY** ppAuthIdentity
    )
/*++

Routine Description:

    This function releases the memory allocated for the AUTHIDENTITY structure.

Arguments:

    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    None

--*/
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
        // free the memory allocated for user
        if ( NULL != (*ppAuthIdentity)->User )
        {
            CoTaskMemFree( (*ppAuthIdentity)->User );
            (*ppAuthIdentity)->User = NULL;
        }

        // free the memory allocated for password
        if ( NULL != (*ppAuthIdentity)->Password )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Password );
            (*ppAuthIdentity)->Password = NULL;
        }

        // free the memory allocated for domain
        if ( NULL != (*ppAuthIdentity)->Domain )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Domain );
            (*ppAuthIdentity)->Domain = NULL;
        }

        // final the structure
        CoTaskMemFree( *ppAuthIdentity );
        *ppAuthIdentity = NULL;
    }
}


VOID
WMISaveError(
    HRESULT hrError
    )
/*++

Routine Description:

    This function saves the description of the last error returned by WMI

Arguments:

    HRESULT     :   The last return value from WMI

Return Value:

    NONE

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IWbemStatusCodeText* pWbemStatus = NULL;
    _bstr_t bstrErrorString;

    try
    {
        // Set error to different value.
        if ( E_ACCESSDENIED == hrError )
        {
            // change the error message to "Logon failure: unknown user name or bad password."
            hrError = ERROR_LOGON_FAILURE;
        }

        //Set the reason to incompatible os when no class is registered on remote mechine
        if( 0x80040154 == hrError )
        {
            bstrErrorString = _bstr_t( GetResString(IDS_ERROR_REMOTE_INCOMPATIBLE));
            SetReason( bstrErrorString );
            return;
        }
        else
        {   // Get error string.
            hr = CoCreateInstance( CLSID_WbemStatusCodeText,
                                   NULL, CLSCTX_INPROC_SERVER,
                                   IID_IWbemStatusCodeText,
                                   (LPVOID*) &pWbemStatus );
            if( SUCCEEDED( hr ) )
            {
                BSTR bstrString = NULL;
                // Get error string from error code.
                hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0,
                                                    &bstrString );
                if( NULL != bstrString )
                {
                    bstrErrorString = _bstr_t( bstrString );
                    SysFreeString( bstrString );
                }
                if( FAILED( hr ) )
                {
                    _com_issue_error( hrError );
                }
            }
            else
            {
                _com_issue_error( hrError );
            }
        }
    }
    catch( _com_error& e )
    {   // We have got the error. Needs to handle carefully.
        LPWSTR lpwszGetString = NULL;
        try
        {   // ErrorMessage() can throw an exception.
            DWORD dwLength = StringLength( e.ErrorMessage(), 0 ) + 5 ;
            lpwszGetString = ( LPWSTR )AllocateMemory( dwLength * sizeof( WCHAR ) );
            if( NULL != lpwszGetString )
            {
                StringCopy( lpwszGetString, e.ErrorMessage(), dwLength );
                StringConcat( lpwszGetString, L"\n", dwLength );
                SetReason( ( LPCWSTR )lpwszGetString );
                FreeMemory( (LPVOID*) &lpwszGetString );
            }
            else
            {   // Failed to know the exact error occured
                // due to insufficient memory.
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
            }
        }
        catch( ... )
        {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
        }
        return;
    }

    SetReason( (LPCWSTR) bstrErrorString );
    return;
}



HRESULT
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    _variant_t& varValue
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   property name
    [out] _variant_t            :   value of the property

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    VARIANT vtValue;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // initialize the variant and then get the value of the specified property
        VariantInit( &vtValue );
        // Call 'Get' method to retireve the value from WMI.
        hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
        if ( FAILED( hr ) )
        {
            // Clear the variant variable
            VariantClear( &vtValue );
            // Return error.
            return hr;
        }

        // set the value
        varValue = vtValue;
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // Clear the variables.
    VariantClear( &vtValue );
    // Return.
    return hr;
}


HRESULT PropertyGet(
                    IWbemClassObject* pWmiObject,
                    LPCWSTR pwszProperty,
                    VARIANT* pvarValue )
/*++
// Routine Description:
//      Gets the value of the property from the WMI class object
//
// Arguments:
//      [ in ] pWmiObject       : pointer to the WBEM class object
//      [ in ] szProperty       : property name
//      [ out ] varValue        : value of the property
//
// Return Value:
//      HRESULT - result of the operation
//
--*/
{
    // local variables
    HRESULT hr;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL || pvarValue == NULL )
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        // initialize the variant and then get the value of the specified property
        hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, pvarValue, NULL, NULL );
        if ( FAILED( hr ) )
        {
            // clear the variant variable
            VariantClear( pvarValue );

            // failed to get the value for the property
            return hr;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return e.Error();
    }

    // inform success
    return S_OK;
}


BOOL PropertyGet(
                IWbemClassObject* pWmiObject,
                LPCWSTR pwszProperty,
                TARRAY arr )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in string format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   property name
    [out] arr                   :   value of the property

Return Value:

    BOOL

--*/
{
    // local variables
    HRESULT hr;
    VARIANT vtValue;
    LONG lIndex = 0;
    LONG lLBound = 0;
    LONG lUBound = 0;
    VARTYPE vartype;
    SAFEARRAY* pSafeArray = NULL;

    // check the inputs
    if ( pWmiObject == NULL || pwszProperty == NULL || arr == NULL )
        return FALSE;

    // initialize the variant
    VariantInit( &vtValue );

    // now get the property value
    hr = PropertyGet( pWmiObject, pwszProperty, &vtValue );
    if ( FAILED( hr ) )
        return FALSE;

    if ( V_VT( &vtValue ) == VT_NULL )
        return TRUE;

        // confirm that the propety value is of array type .. if not return
    if ( ( V_VT( &vtValue ) & VT_ARRAY ) == 0 )
        return FALSE;

    // get the safearray value
    pSafeArray = V_ARRAY( &vtValue );

    // get the bounds of the array
    SafeArrayGetLBound( pSafeArray, 1, &lLBound );
    SafeArrayGetUBound( pSafeArray, 1, &lUBound );

    // get the type of the elements in the safe array
    vartype = (VARTYPE) (V_VT( &vtValue ) & ~VT_ARRAY);

    try
    {
        // traverse thru the values in the safe array and update into dynamic array
        for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
        {
            // sub-local variables
            VARIANT var;
            CHString strValue;

            // get the value
            V_VT( &var ) = vartype;
            SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

            // add the information to the dynamic array
            switch( vartype )
            {
            case VT_BSTR:
                strValue = V_BSTR( &var );
                DynArrayAppendString( arr, strValue, 0 );
                break;
            }
        }
    }
    catch( ... )
    {
        // clear the variant
        VariantClear( &vtValue );
        return FALSE;   // failure
    }

    // clear the variant
    VariantClear( &vtValue );

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    CHString& strValue,
    LPCWSTR pwszDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in string format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] CHString              :   variable to hold the retrieved property
    [in] LPCWSTR                :   string containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t var;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );
    strValue.Empty();

    try
    {
        // first copy the default value
        strValue = pwszDefault;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the property value
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // Get the value
        // If 'var' does not contain value of requested type
        // then default value is returned.
        if ( VT_BSTR == V_VT( &var ) )
        {
            strValue = (LPCWSTR) _bstr_t( var );
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    DWORD& dwValue,
    DWORD dwDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in dword format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] DWORD                 :   variable to hold the retrieved property
    [in] DWORD                  :   dword containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr;
    _variant_t var;

    // first set the defaul value
    dwValue = dwDefault;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
        return FALSE;

    // get the value of the property
    hr = PropertyGet( pWmiObject, pwszProperty, var );
    if ( FAILED( hr ) )
        return FALSE;

    // get the process id from the variant
    if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
        dwValue = (LONG) var;

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    BOOL& bValue,
    BOOL bDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in bool format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] BOOL                  :   variable to hold the retrieved property
    [in] BOOL                   :   bool containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t var;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    try
    {
        // first set the default value
        bValue = bDefault;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the value of the property
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // Save value obtained.
        // If 'var' does not contain value of requested type
        // then default value is returned.
        if ( VT_BOOL == V_VT( &var ) )
        {
            bValue = var.boolVal;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    ULONGLONG& ullValue
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in ulongulong format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] ULONGULONG            :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // Local variables
    CHString str;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );
    str.Empty();

    try
    {
        // first set the default value
        ullValue = 1;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }

        // get the value of the property
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) )
        { // Error is already set in 'PropertyGet' function.
            return FALSE;
        }

        // get the 64-bit value
        ullValue = _wtoi64( str );

        // Check for error condition.
        if( 0 == ullValue )
        {
            ullValue = 1;
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }
    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    WBEMTime& wbemtime )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in wbemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    CHString str;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Clear method sets the time in the WBEMTime object to an invalid time.
    wbemtime.Clear();
    try
    {
        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }

        // get the value of the property
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) )
        {   // Error is already set in 'PropertyGet' function.
            return FALSE;
        }

        // convert into the time value
        wbemtime = _bstr_t( str );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    SYSTEMTIME& systime )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in systemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // local variables
    CHString strTime;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // get the value of the property
        // 16010101000000.000000+000 is the default time
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) )
        {   // Error is already set.
            return FALSE;
        }

        // prepare the systemtime structure
        // yyyymmddHHMMSS.mmmmmmsUUU
        // NOTE: NO NEED CALL 'IsNumeric()' BEFORE 'AsLong'.
        // Left and MID methods can throw an exception.
        systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
        systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
        systime.wDayOfWeek = 0;
        systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
        systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
        systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
        systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
        systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    _variant_t& varValue
    )
/*++

Routine Description:

    Sets the value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] WBEMTime               :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    VARIANT var;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // put the value
        var = varValue;
        hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // return the result
    return hr;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    LPCWSTR pwszValue
    )
/*++

Routine Description:

    Sets the string value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] LPCWSTR                :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    _variant_t varValue;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) ||
         ( NULL == pwszValue ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = pwszValue;
        SAFE_EXECUTE( PropertyPut( pWmiObject, pwszProperty, varValue ) );
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // return
    return hr;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    DWORD dwValue
    )
/*++

Routine Description:

    Sets the dword value of the property to the WMI class object.

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] DWORD                  :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    _variant_t varValue;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = ( LONG )dwValue;
        SAFE_EXECUTE( PropertyPut( pWmiObject, pwszProperty, varValue ) );
    }
    catch( _com_error& e )
    {
        return e.Error();
    }

    // return
    return S_OK;
}


HRESULT
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    LPCWSTR pwszMethod,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    _variant_t& varValue
    )
/*++

Routine Description:

    This function retrieves the value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] LPCWSTR                :   the name of the method to execute
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [in] _variant_t             :   variable holding the property value retrieved

Return Value:

    TRUE on success
    FALSE on failure

NOTE: Pass arguments of type mentioned in declaration of this function.
      EX: Don't pass 'CHString' argument if 'LPWSTR' is expected.
      Reason: 'CHString' can throw an exception of type 'CHEAP_EXCEPTION'
               which is not handled by this function.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    DWORD dwReturnValue = 0;
    IWbemClassObject* pClass = NULL;
    IWbemClassObject* pMethod = NULL;
    IWbemClassObject* pInParams = NULL;
    IWbemClassObject* pInParamsInstance = NULL;
    IWbemClassObject* pOutParamsInstance = NULL;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // check the input value
    if ( ( NULL == pWbemServices ) ||
         ( NULL == pwszMethod ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // NOTE: If SAFE_EXECUTE( pWbemServices->GetObject(
    //       _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
    //       is executed then,
    //       NO NEED TO CHECK FOR ( PCLASS == NULL ) SINCE IN ALL CASES
    //       OF ERROR THIS VARIABLE WILL BE NULL.

    try
    {
        // get the registry class object
        SAFE_EXECUTE( pWbemServices->GetObject(
            _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );

        // get the method reference required
        SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );

        // create the instance for the in parameters
        SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );

        // set the input values
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey ) );
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName ) );
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName ) );

        // now execute the method
        SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
            _bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
        if ( NULL == pOutParamsInstance )           // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // now check the return value of the method from the output params object
        bResult = PropertyGet( pOutParamsInstance,
            _bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
        if ( ( FALSE == bResult ) ||
             ( 0 != dwReturnValue ) )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // Comapre string and take appropriate action.
        if ( 0 == StringCompare( pwszMethod, WMI_REGISTRY_M_DWORDVALUE, TRUE, 0 ) )
        {
            SAFE_EXECUTE( PropertyGet( pOutParamsInstance,
                                       _bstr_t( WMI_REGISTRY_OUT_VALUE_DWORD ), varValue ) );
        }
        else
        {
            SAFE_EXECUTE( PropertyGet( pOutParamsInstance,
                                       _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue ) );
        }
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // release the interfaces
    SAFE_RELEASE( pClass );
    SAFE_RELEASE( pMethod );
    SAFE_RELEASE( pInParams );
    SAFE_RELEASE( pInParamsInstance );
    SAFE_RELEASE( pOutParamsInstance );

    // return success
    return hr;
}


BOOL
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    CHString& strValue,
    LPCWSTR pwszDefault
    )
/*++

Routine Description:

    This function retrieves the string value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] CHString              :   variable holding the property value retrieved
    [in] LPCWSTR                :   the default value for this property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

      This function won't return values if they are obtained as reference
      from WMI.
      EX: 'VARTYPE' recieved is of type 'VT_BSTR | VT_BYREF' then FALSE is
           returned.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varValue;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Check the input
    if ( ( NULL == pWbemServices ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // Set the default value
        if ( NULL != pwszDefault )
        {
            strValue = pwszDefault;
        }

        // Get the value
        hr = RegQueryValueWMI( pWbemServices,
            WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // Get the value from the variant
        // Get the value
        if ( VT_BSTR == V_VT( &varValue ) )
        {
            strValue = (LPCWSTR)_bstr_t( varValue );
        }
        else
        {
            // Requested type is not found.
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {   // Exception throw by '_variant_t'.
        WMISaveError( e );
        return FALSE;
    }

    // return success
    return TRUE;
}


BOOL
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    DWORD& dwValue,
    DWORD dwDefault
    )
/*++

Routine Description:

    This function retrieves the dword value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] DWORD                 :   variable holding the property value retrieved
    [in] DWORD                  :   the default value for this property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

      This function won't return values if they are obtained as reference
      from WMI.
      EX: 'VARTYPE' recieved is of type 'VT_I4 | VT_BYREF' then FALSE is
           returned.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varValue;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Check the input.
    if ( ( NULL == pWbemServices ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) ||
         ( NULL == dwValue ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // Set the default value.
        dwValue = dwDefault;

        // Get the value.
        hr = RegQueryValueWMI( pWbemServices, WMI_REGISTRY_M_DWORDVALUE, dwHDefKey,
                                pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // get the value from the variant
        switch( V_VT( &varValue ) )
        {
        case VT_I2:
            dwValue = V_I2( &varValue );
            break;
        case VT_I4:
            dwValue = V_I4( &varValue );
            break;
        case VT_UI2:
            dwValue = V_UI2( &varValue );
            break;
        case VT_UI4:
            dwValue = V_UI4( &varValue );
            break;
        case VT_INT:
            dwValue = V_INT( &varValue );
            break;
        case VT_UINT:
            dwValue = V_UINT( &varValue );
            break;
        default:
            // Requested type is not found.
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {   // Exception thrown by _variant_t
        WMISaveError( e );
        return FALSE;
    }

    // return success
    return TRUE;
}


DWORD
GetTargetVersionEx(
    IWbemServices* pWbemServices,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function gets the version of the system from which we are trying to retrieve
    information from.

Arguments:

    [in] IWbemServices      :   pointer to the IWbemServices object
    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    DWORD   -   Target version of the machine if found else 0.

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // local variables
    HRESULT hr = S_OK;
    LONG lPos = 0;
    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwVersion = 0;
    ULONG ulReturned = 0;
    CHString strVersion;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Check the input value
    if ( NULL == pWbemServices )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return 0;
    }

    try
    {
        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum(
            _bstr_t( CLASS_CIMV2_Win32_OperatingSystem ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time.
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( 0 == ulReturned )
        {
            // release the interfaces
            WMISaveError( WBEM_S_FALSE );
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( FALSE == PropertyGet( pWbemObject, L"Version", strVersion ) )
        {
            // release the interfaces
            // Error is already set in the called function.
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );

        //
        // now determine the os version
        dwMajor = dwMinor = 0;

        // Get the major version
        lPos = strVersion.Find( L'.' );
        if ( -1 == lPos )
        {
            // The version string itself is version ... THIS WILL NEVER HAPPEN
            if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion, 10 );
        }
        else
        {
            // major version
            if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

            // get the minor version
            strVersion = strVersion.Mid( lPos + 1 );
            lPos = strVersion.Find( L'.' );
            if ( -1 == lPos)
            {
                if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion, 10 );
            }
            else
            {
                if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
            }
        }

        // mix the version info
        dwVersion = dwMajor * 1000 + dwMinor;
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }

    // If successful then 'pWbemObject' and 'pWbemInstances' are already released.
    // return
    return dwVersion;
}


BOOL
GetPropertyFromSafeArray(
    SAFEARRAY *pSafeArray,
    LONG lIndex,
    CHString& strValue,
    VARTYPE vartype
    )
/*++

Routine Description:

    This function retrieves a property from the safe array.

Arguments:

    [in] SAFEARRAY          :   pointer to the array of elements
    [in] LONG               :   index to retrieve the data from
    [out] CHString          :   variable to hold the return value
    [in] VARTYPE            :   The type of variable to retrieve from the array

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // Local variables.
    VARIANT var;
    HRESULT hRes = S_OK;

     // Clear any errors.
     SetLastError( WBEM_S_NO_ERROR );

    // Check the inputs.
    if ( NULL == pSafeArray )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    // Initialize variant.
    VariantInit( &var );

    try
    {
        // get the value
        V_VT( &var ) = vartype;
        hRes = SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );
        if( FAILED( hRes ) )
        {   // Set error occured.
            WMISaveError( hRes );
            VariantClear( &var );
            return FALSE;
        }

        // Store requested information in
        switch( vartype )
        {
        case VT_BSTR:
            strValue = (LPCWSTR)_bstr_t( var );
            break;
        default:
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            VariantClear( &var );
            return FALSE;
        }
    }
    catch( CHeap_Exception )
    {   // Exception thrown from 'strValue'.
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        VariantClear( &var );
        return FALSE;   // failure
    }

    // Clean-Up and return.
    VariantClear( &var );
    return TRUE;
}


BOOL
GetPropertyFromSafeArray(
    SAFEARRAY *pSafeArray,
    LONG lIndex,
    IWbemClassObject **pScriptObject,
    VARTYPE vartype
    )
/*++
Routine Description:

    This function retrieves a property from the safe array.

Arguments:

    [in] SAFEARRAY          :   pointer to the array of elements
    [in] LONG               :   index to retrieve the data from
    [out] IWbemClassObject  :   variable to hold the return value
    [in] VARTYPE            :   The type of variable to retrieve from the array

Return Value:

    TRUE on success
    FALSE on failure

NOTE: CALLED FUNCTION HAS TO MAKE SURE THAT '*pScriptObject' DOES NOT CONTAIN ANY
      VALUE WHICH MAY CAUSE MEMORY LEAK.
      THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

NOTE: If TRUE is returned then 'VariantClear' is not called over 'var' since if
      a call is made to 'Variantcler' we will loose Interface pointer. Not calling
      'VariantClear' will free 'var' when its out of scope and leaving
      the interface pointer in memory which can be used by the called function.
      IT IS CALLING FUNCTION RESPONSIBILITY TO RELEASE THE INTERFACE POINTER.

--*/
{
    // Local variables.
    VARIANT var;
    HRESULT hRes = S_OK;

     // Clear any errors.
     SetLastError( WBEM_S_NO_ERROR );

    // Validate the inputs
    if ( ( NULL == pSafeArray ) ||
         ( NULL == pScriptObject ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    // Initialize variant.
    VariantInit( &var );

    // Set type of value expected.
    V_VT( &var ) = vartype;

    hRes = SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );
    // check for return value.
    if( FAILED( hRes ) )
    {   // Set error occured.
        WMISaveError( hRes );
        VariantClear( &var );
        return FALSE;
    }
    // Store information requested.
    switch( vartype )
    {
    case VT_UNKNOWN:
        *pScriptObject = (IWbemClassObject *) var.punkVal;
        break;
    default:
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        VariantClear( &var );
        return FALSE;
    }

    // return
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\resource.h ===
#define IDS_FILTER_APPLICATION              102
#define IDS_FILTER_STATUS                   103
#define IDS_FILTER_IMAGENAME                104
#define IDS_FILTER_PID                      105
#define IDS_FILTER_SESSION                  106
#define IDS_FILTER_CPUTIME                  107
#define IDS_FILTER_MEMUSAGE                 108
#define IDS_FILTER_USERNAME                 109
#define IDS_FILTER_SERVICES                 110
#define IDS_FILTER_WINDOWNAME               111
#define IDS_FILTER_MODULES                  112
#define IDS_FVALUES_STATUS                  113

#define IDS_OPERATORS_STRING                121
#define IDS_OPERATORS_NUMERIC               122

#define IDS_VALUE_RUNNING                   151
#define IDS_VALUE_NOTRESPONDING             152
#define IDS_PID_0_DOMAIN                    153
#define IDS_PID_0_USERNAME                  154
#define IDS_VALUE_UNKNOWN                   155

#define IDS_MSG_KILL_SUCCESS                501
#define IDS_MSG_KILL_SUCCESS_QUEUED         502
#define IDS_MSG_KILL_SUCCESS_EX             503
#define IDS_MSG_KILL_SUCCESS_QUEUED_EX      504
#define IDS_ERROR_KILL_FAILED               505
#define IDS_ERROR_KILL_FAILED_EX            506
#define IDS_ERROR_PROCESS_NOTFOUND          507
#define IDS_ERROR_NO_PROCESSES              508
#define IDS_ERROR_UNABLE_TO_TERMINATE       509
#define IDS_ERROR_CRITICAL_SYSTEM_PROCESS   510
#define IDS_ERROR_CANNOT_KILL_SILENTLY      511
#define IDS_ERROR_CANNOT_KILL_ITSELF        512
#define IDS_ERROR_COM_ERROR                 513
#define IDS_ERROR_USERNAME_BUT_NOMACHINE    514
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME   515
#define IDS_ERROR_USERNAME_EMPTY            516
#define IDS_ERROR_SERVER_EMPTY              517
#define IDS_ERROR_WILDCARD_WITHOUT_FILTERS  518
#define IDS_ERROR_PID_OR_IM_ONLY            519
#define IDS_ERROR_NO_PID_AND_IM             520
#define IDS_ERROR_STRING_FOR_PID            521
#define IDS_ERROR_INVALID_USAGE_REQUEST     522
#define IDS_ERROR_PLATFORM_SHOULD_BE_X86    523
#define IDS_MSG_TREE_KILL_SUCCESS           524
#define IDS_ERROR_TREE_KILL_FAILED          525
#define IDS_ERROR_TASK_HAS_CHILDS           526
#define IDS_MSG_TREE_KILL_SUCCESS_QUEUED    527

#define IDS_HELP_LINE1                  1001
#define IDS_HELP_LINE2                  1002
#define IDS_HELP_LINE3                  1003
#define IDS_HELP_LINE4                  1004
#define IDS_HELP_LINE5                  1005
#define IDS_HELP_LINE6                  1006
#define IDS_HELP_LINE7                  1007
#define IDS_HELP_LINE8                  1008
#define IDS_HELP_LINE9                  1009
#define IDS_HELP_LINE10                 1010
#define IDS_HELP_LINE11                 1011
#define IDS_HELP_LINE12                 1012
#define IDS_HELP_LINE13                 1013
#define IDS_HELP_LINE14                 1014
#define IDS_HELP_LINE15                 1015
#define IDS_HELP_LINE16                 1016
#define IDS_HELP_LINE17                 1017
#define IDS_HELP_LINE18                 1018
#define IDS_HELP_LINE19                 1019
#define IDS_HELP_LINE20                 1020
#define IDS_HELP_LINE21                 1021
#define IDS_HELP_LINE22                 1022
#define IDS_HELP_LINE23                 1023
#define IDS_HELP_LINE24                 1024
#define IDS_HELP_LINE25                 1025
#define IDS_HELP_LINE26                 1026
#define IDS_HELP_LINE27                 1027
#define IDS_HELP_LINE28                 1028
#define IDS_HELP_LINE29                 1029
#define IDS_HELP_LINE30                 1030
#define IDS_HELP_LINE31                 1031
#define IDS_HELP_LINE32                 1032
#define IDS_HELP_LINE33                 1033
#define IDS_HELP_LINE34                 1034
#define IDS_HELP_LINE35                 1035
#define IDS_HELP_LINE36                 1036
#define IDS_HELP_LINE37                 1037
#define IDS_HELP_LINE38                 1038
#define IDS_HELP_LINE39                 1039
#define IDS_HELP_LINE40                 1040
#define IDS_HELP_LINE41                 1041
#define IDS_HELP_LINE42                 1042
#define IDS_HELP_LINE43                 1043
#define IDS_HELP_LINE44                 1044
#define IDS_HELP_LINE45                 1045
#define IDS_HELP_LINE46                 1046
#define IDS_HELP_LINE47                 1047
#define IDS_HELP_LINE48                 1048
#define IDS_HELP_LINE49                 1049
#define IDS_HELP_LINE50                 1050
#define IDS_HELP_LINE51                 1051
#define IDS_HELP_LINE52                 1052
#define IDS_HELP_LINE53                 1053
#define IDS_HELP_LINE54                 1054
#define IDS_HELP_LINE55                 1055
#define IDS_HELP_LINE56                 1056
#define IDS_HELP_LINE57                 1057
#define IDS_HELP_LINE58                 1058
#define IDS_HELP_LINE59                 1059

// usage indexes into the string table
#define ID_HELP_START       IDS_HELP_LINE1
#define ID_HELP_END         IDS_HELP_LINE59
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\taskkill.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      TaskKill.cpp
//
//  Abstract:
//
//      This module implements the termination of processes runnging on either local
//      or remote system
//
//      Syntax:
//      ------
//          TaskKill.exe [ -s server [ -u username [ -p password ] ] ] [ -f ] [ -t ]
//              [ -fi filter ] [ -im imagename | -pid pid ]
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "TaskKill.h"

//
// local structures
//
typedef struct __tagWindowTitles
{
    LPWSTR pwszDesk;
    LPWSTR pwszWinsta;
    BOOL bFirstLoop;
    TARRAY arrWindows;
} TWINDOWTITLES, *PTWINDOWTITLES;

//
// private functions ... prototypes
//
BOOL CALLBACK EnumWindowsProc( HWND hWnd, LPARAM lParam );
BOOL CALLBACK EnumDesktopsFunc( LPWSTR pwsz, LPARAM lParam );
BOOL CALLBACK EnumWindowStationsFunc( LPWSTR pwsz, LPARAM lParam );
BOOL CALLBACK EnumMessageWindows( WNDENUMPROC lpEnumFunc, LPARAM lParam );
BOOL GetPerfDataBlock( HKEY hKey, LPWSTR szObjectIndex, PPERF_DATA_BLOCK* ppdb );


DWORD
__cdecl wmain(
    IN DWORD argc,
    IN LPCTSTR argv[]
    )
/*++
Routine Description:
      This the entry point to this utility.

Arguments:
      [ in ] argc     : argument(s) count specified at the command prompt
      [ in ] argv     : argument(s) specified at the command prompt

Return Value:
      The below are actually not return values but are the exit values
      returned to the OS by this application
          0       : utility is successfull
          1       : utility failed
--*/
{
    // local variables
    CTaskKill taskkill;
    BOOL bResult = FALSE;
    DWORD dwExitCode = 0;

    // initialize the taskkill utility
    if ( taskkill.Initialize() == FALSE )
    {
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // now do parse the command line options
    if ( taskkill.ProcessOptions( argc, argv ) == FALSE )
    {
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // check whether usage has to be displayed or not
    if ( taskkill.m_bUsage == TRUE )
    {
        // show the usage of the utility
        taskkill.Usage();

        // quit from the utility
        EXIT_PROCESS( 0 );
    }

    // now validate the filters and check the result of the filter validation
    if ( taskkill.ValidateFilters() == FALSE )
    {
        // invalid filter
        // SPECIAL:
        // -------
        //     for the custom filter "pid" we are setting the tag "INFO:" before
        //     the message in the filter validation part itself
        //     so, check and display
        // display the message
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // enable the kill privileges
    if ( taskkill.EnableDebugPriv() == FALSE )
    {
        // show the error message and exit
        SaveLastError();
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // connect to the server
    bResult = taskkill.Connect();
    if ( FALSE == bResult )
    {
        // show the error message
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // load the data and check
    bResult = taskkill.LoadTasks();
    if ( FALSE == bResult )
    {
        // show the error message
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // invoke the actual termination and get the exit code
    bResult = taskkill.DoTerminate( dwExitCode );
    if ( FALSE == bResult )
    {
        // NOTE: the 'FALSE' return value indicates that some major problem has occured
        //       while trying to terminate the process. Still the exit code will be determined by
        //       the function only. Do not change/set the exit code value
        DISPLAY_GET_REASON();
    }

    // exit from the utility
    EXIT_PROCESS( dwExitCode );
}


BOOL
CTaskKill::Connect(
    void
    )
/*++
Routine Description:
      connects to the remote as well as remote system's WMI

Arguments:
      NONE

Return Value:
      TRUE  : if connection is successful
      FALSE : if connection is unsuccessful
--*/
{
    // local variables
    BOOL bResult = FALSE;
    HRESULT hr = S_OK;

    // release the existing auth identity structure
    WbemFreeAuthIdentity( &m_pAuthIdentity );

    // connect to WMI
    bResult = ConnectWmiEx( m_pWbemLocator,
        &m_pWbemServices, m_strServer, m_strUserName, m_strPassword,
        &m_pAuthIdentity, m_bNeedPassword, WMI_NAMESPACE_CIMV2, &m_bLocalSystem );
    hr = GetLastError();
    // check the result of connection
    if ( FALSE == bResult )
    {
        return FALSE;
    }
#ifndef _WIN64
    // determine the type of the platform if modules info is required
    if ( ( TRUE == m_bLocalSystem ) && ( TRUE == m_bNeedModulesInfo ) )
    {
        // sub-local variables
        DWORD dwPlatform = 0;

        // get the platform type
        dwPlatform = GetTargetPlatformEx( m_pWbemServices, m_pAuthIdentity );

        // if the platform is not 32-bit, error
        if ( dwPlatform != PLATFORM_X86 )
        {
            // let the tool use WMI calls instead of Win32 API
            m_bUseRemote = TRUE;
        }
    }
#endif

    try
    {
        // check the local credentials and if need display warning
        if ( WBEM_E_LOCAL_CREDENTIALS == hr )
        {
            WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
            ShowMessageEx( stderr, 2, FALSE, L"%1 %2",
                           TAG_WARNING, GetReason() );
        }

        // check the remote system version and its compatiblity
        if ( FALSE == m_bLocalSystem )
        {
            // check the version compatibility
            DWORD dwVersion = 0;
            dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
            if ( IsCompatibleOperatingSystem( dwVersion ) == FALSE )
            {
                SetReason( ERROR_REMOTE_INCOMPATIBLE );
                return FALSE;
            }
        }

        // save the server name
        m_strUNCServer = L"";
        if ( m_strServer.GetLength() != 0 )
        {
            // check whether the server name is in UNC format or not .. if not prepare it
            m_strUNCServer = m_strServer;
            if ( IsUNCFormat( m_strServer ) == FALSE )
            {
                m_strUNCServer.Format( L"\\\\%s", m_strServer );
            }
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // return the result
    return TRUE;
}


BOOL
CTaskKill::LoadTasks(
    void
    )
/*++
Routine Description:
      initiate the enumeration

Arguments:
      NONE

Return Value:
      TRUE  : if successful
      FALSE : if unsuccessful
--*/
{
    // local variables
    HRESULT hr = S_OK;
    IWbemClassObject* pObject = NULL;

    // check the services object
    if ( ( NULL == m_pWbemServices ) ||
         ( NULL != m_pWbemEnumObjects ) )
    {
        SetLastError( ( DWORD )STG_E_UNKNOWN );
        SaveLastError();
        return FALSE;
    }

    try
    {
        // do the optimization
        DoOptimization();

        // load the tasks from WMI based on generated query
        hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( m_strQuery ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &m_pWbemEnumObjects );

        // check the result of the ExecQuery
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // set the interface security and check the result
        hr = SetInterfaceSecurity( m_pWbemEnumObjects, m_pAuthIdentity );
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        //
        // get the reference to the Win32_Process class object
        // and then reference to the input parameters of the "Terminate" method
        SAFE_EXECUTE( m_pWbemServices->GetObject(
            _bstr_t( CLASS_PROCESS ), 0, NULL, &pObject, NULL ) );
        SAFE_EXECUTE( pObject->GetMethod(
            _bstr_t( WIN32_PROCESS_METHOD_TERMINATE ), 0, &m_pWbemTerminateInParams, NULL ) );

        // release the WMI object
        SAFE_RELEASE( pObject );

        //
        // retrieve the window title information if needed

        // remove the current window titles information
        DynArrayRemoveAll( m_arrWindowTitles );

        // for the local system, enumerate the window titles of the processes
        // there is no provision for collecting the window titles of remote processes
        if ( TRUE == m_bLocalSystem )
        {
            // prepare the tasks list info
            TWINDOWTITLES windowtitles;
            windowtitles.pwszDesk = NULL;
            windowtitles.pwszWinsta = NULL;
            windowtitles.bFirstLoop = FALSE;
            windowtitles.arrWindows = m_arrWindowTitles;
            EnumWindowStations( EnumWindowStationsFunc, ( LPARAM ) &windowtitles );

            // free the memory allocated with _tcsdup string function
            if ( NULL != windowtitles.pwszDesk )
            {
                free( windowtitles.pwszDesk );
            }
            if ( NULL != windowtitles.pwszWinsta )
            {
                free( windowtitles.pwszWinsta );
            }
        }

        // load the extended tasks information
        LoadTasksEx();          // NOTE: here we are not much bothered abt the return value
    }
    catch( _com_error& e )
    {
        // save the error
        SAFE_RELEASE( pObject );
        WMISaveError( e.Error() );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        // save the error
        SAFE_RELEASE( pObject );
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }

    // return success
    return TRUE;
}


BOOL
CTaskKill::LoadTasksEx(
    void
    )
/*++
Routine Description:
    Store other information such as module, service etc. of a process
    running on a system.

Arguments:
    NONE

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    BOOL bResult = FALSE;

    //
    // NOTE: we are relying on NET API for getting the user context / services info
    // so if any one of them is needed, establish connection to the remote system using NET API
    if ( ( FALSE == m_bNeedModulesInfo ) &&
         ( FALSE == m_bNeedUserContextInfo ) &&
         ( FALSE == m_bNeedServicesInfo )
       )
    {
        return TRUE;
    }
    // init
    m_bCloseConnection = FALSE;

    try
    {
        // we need to use NET API only in case connecting to the remote system
        // with credentials information i.e; m_pAuthIdentity is not NULL
        if ( ( FALSE == m_bLocalSystem ) && ( NULL != m_pAuthIdentity ) )
        {
            // sub-local variables
            DWORD dwConnect = 0;
            LPCWSTR pwszUser = NULL;
            LPCWSTR pwszPassword = NULL;

            // identify the password to connect to the remote system
            pwszPassword = m_pAuthIdentity->Password;
            if ( 0 != m_strUserName.GetLength() )
            {
                pwszUser = m_strUserName;
            }
            // establish connection to the remote system using NET API
            // this we need to do only for remote system
            dwConnect = NO_ERROR;
            m_bCloseConnection = TRUE;
            dwConnect = ConnectServer( m_strUNCServer, pwszUser, pwszPassword );
            if ( NO_ERROR != dwConnect )
            {
                // connection should not be closed .. this is because we didn't establish the connection
                m_bCloseConnection = FALSE;

                // this might be 'coz of the conflict in the credentials ... check that
                if ( ERROR_SESSION_CREDENTIAL_CONFLICT != dwConnect )
                {
                    // return failure
                    return FALSE;
                }
            }

            // check the whether we need to close the connection or not
            // if user name is NULL (or) password is NULL then don't close the connection
            if ( ( NULL == pwszUser ) || ( NULL == pwszPassword ) )
            {
                m_bCloseConnection = FALSE;
            }
        }

        // connect to the remote system's winstation

        // sub-local variables
        HANDLE hServer = NULL;
        bResult = TRUE;
        hServer = SERVERNAME_CURRENT;
        if ( FALSE == m_bLocalSystem )
        {
            // sub-local variables
            LPWSTR pwsz = NULL;

            // connect to the winsta and check the result
            pwsz = m_strUNCServer.GetBuffer( m_strUNCServer.GetLength() );
            hServer = WinStationOpenServerW( pwsz );

            // proceed furthur only if winstation of the remote system is successfully opened
            if ( NULL == hServer )
            {
                bResult = FALSE;
            }
        }

        // prepare to get the user context info .. if needed
        if ( ( TRUE == m_bNeedUserContextInfo ) && ( TRUE == bResult ) )
        {
            // get all the process details
            m_bIsHydra = FALSE;
            bResult = WinStationGetAllProcesses( hServer,
                GAP_LEVEL_BASIC, &m_ulNumberOfProcesses, (PVOID*) &m_pProcessInfo );

            // check the result
            if ( FALSE == bResult )
            {
                // Maybe a Hydra 4 server ?
                // Check the return code indicating that the interface is not available.
                if ( RPC_S_PROCNUM_OUT_OF_RANGE == GetLastError() )
                {
                    // The new interface is not known
                    // It must be a Hydra 4 server
                    // try with the old interface
                    bResult = WinStationEnumerateProcesses( hServer, (PVOID*) &m_pProcessInfo );

                    // check the result of enumeration
                    if ( TRUE == bResult )
                    {
                        m_bIsHydra = TRUE;
                    }
                }
                else
                {
                    // unknown error
                    // ????????????????????????????????????????????????????????????????
                    //      dont know whatz happening to the memory allocated here
                    //      we are getting AV when trying to free the memory allocated
                    //      in the call to WinStationGetAllProcesses
                    // ????????????????????????????????????????????????????????????????
                    m_pProcessInfo = NULL;
                }
            }
        }
                // close the connection to the winsta
        if ( NULL != hServer )
        {
            WinStationCloseServer( hServer );
        }
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // check whether we need services info or not
    if ( TRUE == m_bNeedServicesInfo )
    {
        // load the services
        bResult = LoadServicesInfo();

        // check the result
        if ( FALSE == bResult )
        {
            return FALSE;
        }
    }

    // check whether we need modules info or not
    if ( TRUE == m_bNeedModulesInfo )
    {
        // load the modules information
        bResult = LoadModulesInfo();

        // check the result
        if ( FALSE == bResult )
        {
            return FALSE;
        }
    }

    // NETWORK OPTIMIZATION -
    // while progressing furthur in display of the data, we don't need the connection
    // to the remote system with NET API ... but the connection should be live
    // if user name has to be retrieved .. so check if user name info is needed or not
    // if not, close the connection
    if ( ( FALSE == m_bNeedUserContextInfo ) && ( TRUE == m_bCloseConnection ) )
    {
        m_bCloseConnection = FALSE;             // reset the flag
        CloseConnection( m_strUNCServer );      // close connection
    }

    // return
    return TRUE;
}


BOOL
CTaskKill::LoadModulesInfo(
    void
    )
/*++
Routine Description:
    Store module information of a process.

Arguments:
    NONE

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    HKEY hKey = NULL;
    LONG lReturn = 0;
    BOOL bResult = FALSE;
    BOOL bImagesObject = FALSE;
    BOOL bAddressSpaceObject = FALSE;
    PPERF_OBJECT_TYPE pot = NULL;

    // check whether we need the modules infor or not
    // NOTE: we need to load the performance data only in case if user is querying for remote system only
    if ( ( FALSE == m_bNeedModulesInfo ) || ( TRUE == m_bLocalSystem ) )
    {
        return TRUE;
    }

    try
    {
        // open the remote system performance data key
        lReturn = RegConnectRegistry( m_strUNCServer, HKEY_PERFORMANCE_DATA, &hKey );
        if ( ERROR_SUCCESS != lReturn )
        {
            SetLastError( ( DWORD )lReturn );
            SaveLastError();
            return FALSE;
        }

        // get the performance object ( images )
        bResult = GetPerfDataBlock( hKey, L"740", &m_pdb );
        if ( FALSE == bResult )
        {
            // close the registry key and return
            RegCloseKey( hKey );
            return FALSE;
        }

        // check the validity of the perf block
        if ( 0 != StringCompare( m_pdb->Signature, L"PERF", FALSE, 4 ) )
        {
            // close the registry key and return
            RegCloseKey( hKey );

            // set the error message
            SetLastError( ( DWORD )ERROR_ACCESS_DENIED );
            SaveLastError();
            return FALSE;
        }

        // close the registry key and return
        RegCloseKey( hKey );
        //
        // check whether we got both 740 and 786 blocks or not
        //
        bImagesObject = FALSE;
        bAddressSpaceObject = FALSE;
        pot = (PPERF_OBJECT_TYPE) ( (LPBYTE) m_pdb + m_pdb->HeaderLength );
        for( DWORD dw = 0; dw < m_pdb->NumObjectTypes; dw++ )
        {
            if ( 740 == pot->ObjectNameTitleIndex )
            {
                bImagesObject = TRUE;
            }
            else
            {
                if ( 786 == pot->ObjectNameTitleIndex )
                {
                    bAddressSpaceObject = TRUE;
                }
            }
            // move to the next object
            if( 0 != pot->TotalByteLength )
            {
                pot = ( (PPERF_OBJECT_TYPE) ((PBYTE) pot + pot->TotalByteLength));
            }
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( E_OUTOFMEMORY );
        if( NULL != hKey )
        {
            RegCloseKey( hKey );
        }
        return FALSE;
    }

    // release the resource
	if ( NULL != hKey )
	{
		RegCloseKey( hKey );
		hKey = NULL;
	}

	// check whether we got the needed objects or not
    if ( ( FALSE == bImagesObject ) || ( FALSE == bAddressSpaceObject ) )
    {
        SetLastError( ( DWORD )ERROR_ACCESS_DENIED );
        SaveLastError();
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
CTaskKill::LoadUserNameFromWinsta(
    OUT CHString& strDomain,
    OUT CHString& strUserName
    )
/*++
Routine Description:
    Store username of a process obtained from window station.

Arguments:
    OUT strDomain   : Contains domain name string.
    OUT strUserName : Contains username string.
Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    PSID pSid = NULL;
    BOOL bResult = FALSE;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszDomain = NULL;
    LPCWSTR pwszServer = NULL;
    DWORD dwUserLength = 0;
    DWORD dwDomainLength = 0;
    SID_NAME_USE siduse;

    // check whether winsta data exists or not
    if ( NULL == m_pProcessInfo )
    {
        return FALSE;
    }

    try
    {
        // allocate buffers
        dwUserLength = 128;
        dwDomainLength = 128;
        pwszUser = strUserName.GetBufferSetLength( dwUserLength );
        pwszDomain = strDomain.GetBufferSetLength( dwDomainLength );

        //
        // find for the appropriate the process
        pSid = NULL;
        if ( FALSE == m_bIsHydra )
        {
            // sub-local variables
            PTS_ALL_PROCESSES_INFO ptsallpi = NULL;
            PTS_SYSTEM_PROCESS_INFORMATION pspi = NULL;

            // loop ...
            ptsallpi = (PTS_ALL_PROCESSES_INFO) m_pProcessInfo;
            for( ULONG ul = 0; ul < m_ulNumberOfProcesses; ul++ )
            {
                pspi = ( PTS_SYSTEM_PROCESS_INFORMATION )( ptsallpi[ ul ].pspiProcessInfo );
                if ( pspi->UniqueProcessId == m_dwProcessId )
                {
                    // get the SID and convert it into
                    pSid = ptsallpi[ ul ].pSid;
                    break;               // break from the loop
                }
            }
        }
        else
        {
            //
            // HYDRA ...
            //
            DWORD dwTotalOffset = 0;
            PTS_SYSTEM_PROCESS_INFORMATION pspi = NULL;
            PCITRIX_PROCESS_INFORMATION pcpi = NULL;

            // traverse thru the process info and find the process id
            dwTotalOffset = 0;
            pspi = ( PTS_SYSTEM_PROCESS_INFORMATION ) m_pProcessInfo;
            for( ;; )
            {
                // check the processid
                if ( pspi->UniqueProcessId == m_dwProcessId )
                {
                    break;
                }
                // check whether any more processes exist or not
                if( 0 == pspi->NextEntryOffset )
                {
                        break;
                }
                // position to the next process info
                dwTotalOffset += pspi->NextEntryOffset;
                pspi = (PTS_SYSTEM_PROCESS_INFORMATION) &m_pProcessInfo[ dwTotalOffset ];
            }

            // get the citrix_information which follows the threads
            pcpi = (PCITRIX_PROCESS_INFORMATION)
                ( ((PUCHAR) pspi) + sizeof( TS_SYSTEM_PROCESS_INFORMATION ) +
                (sizeof( SYSTEM_THREAD_INFORMATION ) * pspi->NumberOfThreads) );

            // check the magic number .. if it is not valid ... we haven't got SID
            if( CITRIX_PROCESS_INFO_MAGIC == pcpi->MagicNumber )
            {
                pSid = pcpi->ProcessSid;
            }
        }

        // check the sid value
        if ( NULL == pSid )
        {
            // SPECIAL CASE:
            // -------------
            // PID -> 0 will have a special hard coded user name info
            if ( 0 == m_dwProcessId )
            {
                bResult = TRUE;
                StringCopyW( pwszUser, PID_0_USERNAME, dwUserLength );
                StringCopyW( pwszDomain, PID_0_DOMAIN, dwDomainLength );
            }

            // release the buffer
            strDomain.ReleaseBuffer();
            strUserName.ReleaseBuffer();
            return bResult;
        }

        // determine the server
        pwszServer = NULL;
        if ( FALSE == m_bLocalSystem )
        {
            pwszServer = m_strUNCServer;
        }
        // map the sid to the user name
        bResult = LookupAccountSid( pwszServer, pSid,
            pwszUser, &dwUserLength, pwszDomain, &dwDomainLength, &siduse );
        // release the buffer
        strDomain.ReleaseBuffer();
        strUserName.ReleaseBuffer();
    }
    catch( CHeap_Exception )
    {
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }
    // return the result
    return bResult;
}


BOOL
CTaskKill::LoadServicesInfo(
    void
    )
/*++
Routine Description:
    Store service infomration of a process.

Arguments:
    NONE

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    DWORD dw = 0;                       // looping variable
    DWORD dwSize = 0;                   // used in memory allocation
    DWORD dwResume = 0;                 // used in EnumServicesStatusEx
    BOOL bResult = FALSE;               // captures the result of EnumServicesStatusEx
    SC_HANDLE hScm = NULL;              // holds the handle to the service
    DWORD dwExtraNeeded = 0;            // used in EnumServicesStatusEx and memory allocation
    LPCWSTR pwszServer = NULL;
    LPENUM_SERVICE_STATUS_PROCESS pInfo = NULL;     // holds the services info

    // Initialize the output parameter(s).
    m_dwServicesCount = 0;
    m_pServicesInfo = NULL;

    // check whether we need to load the services info or not
    if ( FALSE == m_bNeedServicesInfo )
    {
        return TRUE;
    }
    // determine the server
    pwszServer = NULL;
    if ( FALSE == m_bLocalSystem )
    {
        pwszServer = m_strUNCServer;
    }

    try
    {
        // Connect to the service controller and check the result
        hScm = OpenSCManager( pwszServer, NULL, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE );
        if ( NULL == hScm )
        {
            // set the reason for the failure and return from here itself
            SaveLastError();
            return FALSE;
        }

        // enumerate the names of the active win32 services
        // for this, first pass through the loop and allocate memory from an initial guess. (4K)
        // if that isn't sufficient, we make another pass and allocate
        // what is actually needed.
        // (we only go through the loop a maximum of two times)
        dw = 0;                 // no. of loops
        dwResume = 0;           // reset / initialize variables
        dwSize = 4 * 1024;      // reset / initialize variables
        while ( 2 >= ++dw )
        {
            // set the size
            dwSize += dwExtraNeeded;

            // allocate memory for storing services information
            pInfo = ( LPENUM_SERVICE_STATUS_PROCESS ) AllocateMemory( dwSize );
            if ( NULL == pInfo )
            {
                // failed in allocating needed memory ... error
                SetLastError( ( DWORD )E_OUTOFMEMORY );
                SaveLastError();
                return FALSE;
            }

            // enumerate services, the process identifier and additional flags for the service
            dwResume = 0;           // lets get all the services again
            bResult = EnumServicesStatusEx( hScm, SC_ENUM_PROCESS_INFO, SERVICE_WIN32,
                SERVICE_ACTIVE, ( LPBYTE ) pInfo, dwSize, &dwExtraNeeded, &m_dwServicesCount, &dwResume, NULL );

            // check the result of the enumeration
            if ( TRUE == bResult )
            {
                // successfully enumerated all the services information
                break;      // jump out of the loop
            }

            // first free the allocated memory
            FreeMemory( ( LPVOID * ) &pInfo );

            // now lets look at what is the error
            if ( ERROR_MORE_DATA == GetLastError() )
            {
                // some more services are not listed because of less memory
                // allocate some more memory and enumerate the remaining services info
                continue;
            }
            else
            {
                // some strange error occured ... inform the same to the caller
                SaveLastError();            // set the reason for the failure
                CloseServiceHandle( hScm ); // close the handle to the service
                return FALSE;               // inform failure
            }
        }
    }
    catch( CHeap_Exception )
    {
        if( NULL != hScm )
        {
                CloseServiceHandle( hScm ); // close the handle to the service
        }
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }
    // check whether there any services or not ... if services count is zero, free the memory
    if ( 0 == m_dwServicesCount )
    {
        // no services exists
        FreeMemory( ( LPVOID * ) &pInfo );
    }
    else
    {
        // set the local pointer to the out parameter
        m_pServicesInfo = pInfo;
    }

    // inform success
    return TRUE;
}


BOOL
GetPerfDataBlock(
    IN HKEY hKey,
    IN LPWSTR pwszObjectIndex,
    IN PPERF_DATA_BLOCK* ppdb
    )
/*++
Routine Description:
    Rertieve performance data block.

Arguments:
    [in] hKey            : Contains handle to registry key.
    [in] pwszObjectIndex : Contains index value of an object.
    [out] ppdb           : Contains performance data.

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    LONG lReturn = 0;
    DWORD dwBytes = 0;
    BOOL bResult = FALSE;

    // check the input parameters
    if ( ( NULL == pwszObjectIndex ) || 
         ( NULL != *ppdb ) || 
         ( NULL == ppdb ) )
    {
        return FALSE;
    }
    // allocate memory for PERF_DATA_BLOCK
    dwBytes = 32 * 1024;        // initially allocate for 32 K
    *ppdb = (PPERF_DATA_BLOCK) AllocateMemory( dwBytes );
    if( NULL == *ppdb )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // get performance data on passed Object
    lReturn = RegQueryValueEx( hKey, pwszObjectIndex, NULL, NULL, (LPBYTE) *ppdb, &dwBytes );
    while( ERROR_MORE_DATA == lReturn )
    {
        // increase memory by 8 K
        dwBytes += 8192;

        // since we are attempting to re-allocate the memory -- and in that process
        // some uncertain memory manipulations might occur -- for that reason,
        // instead of trying to re-allocate memory, release the current memory and
        // try to allocate if fresh
        FreeMemory( ( LPVOID * ) ppdb );

        // now allocate some more memory
        *ppdb = NULL;
        *ppdb = (PPERF_DATA_BLOCK) AllocateMemory( dwBytes );
        if( NULL == *ppdb )
        {
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // try to get the info again
        lReturn = RegQueryValueEx( hKey, pwszObjectIndex, NULL, NULL, (LPBYTE) *ppdb, &dwBytes );
    }

    // check the reason for coming out of the loop
    bResult = TRUE;
    if ( ERROR_SUCCESS != lReturn )
    {
        if ( NULL != *ppdb)
        {
            FreeMemory( ( LPVOID * ) ppdb );
            *ppdb = NULL;
        }

        // save the error info
        bResult = FALSE;
        SetLastError( ( DWORD )lReturn );
        SaveLastError();
    }

    // return the result
    return bResult;
}


VOID
CTaskKill::DoOptimization(
    void
    )
/*++
Routine Description:
     Enumerates the desktops available on a particular window station
     This is a CALLBACK function ... called by EnumWindowStations API function

Arguments:
    NONE

Return Value:
      VOID
--*/
{
    // local variables
    DWORD dwCount = 0;
    CHString strCondition;
    BOOL bOptimized = FALSE;
    LPCWSTR pwsz = NULL;
    LPCWSTR pwszTask = NULL;
    LPCWSTR pwszClause = NULL;
    CHString strInternalQuery;

    // do not the optimization if user requested the tree termination
    if ( TRUE == m_bTree )
    {
        return;
    }

    try
    {
        // traverse thru list of specified tasks to kill and prepare the query
        pwszClause = NULL_STRING;
        dwCount = DynArrayGetCount( m_arrTasksToKill );
        for( DWORD dw = 0; dw < dwCount; dw++ )
        {
            // get the task
            pwszTask = DynArrayItemAsString( m_arrTasksToKill, dw );
            if ( NULL == pwszTask )
            {
                continue;
            }
            // check the for the special input '*' which cannot be optimized
            if ( 0 == StringCompare( pwszTask, L"*", TRUE, 0 ) )
            {
                   return;     // query should not be optimized ... return back
            }
            // now check whether wild-card is specified in the image name
            if ( NULL != (pwsz = FindChar( pwszTask, L'*', 0 )) )
            {
                // the image name contains wild card in it - this cannot be included in query
                if ( StringLength( pwsz, 0 ) == 1 )
                {
                    continue;
                }
            }

            // prepare the query based on the type of input
            // NOTE: in case of numeric it might be a process id (or) image name
            //       we are not sure abt what it can be. So prepare query for both
            if ( IsNumeric( pwszTask, 10, FALSE ) == TRUE )
            {
                // prepare condition
                strCondition.Format( L" %s %s = %s", pwszClause,
                    WIN32_PROCESS_PROPERTY_PROCESSID, pwszTask );
            }
            else
            {
                // prepare the condition
                strCondition.Format( L" %s %s = \"%s\"",
                    pwszClause, WIN32_PROCESS_PROPERTY_IMAGENAME, pwszTask );
            }

            // append to the final query
            strInternalQuery += strCondition;

            // from next time onwards query clause has to be added
            bOptimized = TRUE;
            pwszClause = WMI_CLAUSE_OR;
        }

        // do modifications to the query only if tasks were optimized
        if ( TRUE == bOptimized )
        {
            // now this internal query has to be added to the main query
            // before adding this check whether query optimization is done in filters or not
            // if not, we have to add the where clause also
            strCondition.Format( L"%s %s", m_strQuery,
                (m_bFiltersOptimized == TRUE ? WMI_CLAUSE_AND : WMI_CLAUSE_WHERE) );

            // now add the internal query to the final query
            m_bTasksOptimized = TRUE;
            m_strQuery.Format( L"%s (%s)", strCondition, strInternalQuery );
        }
    }
    catch( CHeap_Exception )
    {
        // we can't anything here ... just return
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return;
    }
}


BOOL
CALLBACK EnumWindowStationsFunc(
    IN LPTSTR lpstr,
    IN LPARAM lParam
    )
/*++
Routine Description:
     Enumerates the desktops available on a particular window station
     This is a CALLBACK function ... called by EnumWindowStations API function

Arguments:
      [ in ] lpstr    : window station name
      [ in ] lParam   : user supplied parameter to this function
                        in this function, this points to TTASKSLIST structure variable

Return Value:
      TRUE upon success and FALSE on failure
--*/
{
    // local variables
    HWINSTA hWinSta = NULL;
    HWINSTA hwinstaSave = NULL;
    PTWINDOWTITLES pWndTitles = ( PTWINDOWTITLES ) lParam;

    // check the input arguments
    if ( ( NULL == lpstr ) || ( NULL == lParam ) )
    {
        return FALSE;
    }
    // get and save the current window station
    hwinstaSave = GetProcessWindowStation();

    // open current tasks window station and change the context to the new workstation
    hWinSta = OpenWindowStation( lpstr, FALSE, MAXIMUM_ALLOWED );
    if ( NULL == hWinSta )
    {
        // failed in getting the process window station
        SaveLastError();
        return FALSE;
    }
    else
    {
        // change the context to the new workstation
        if ( ( hWinSta != hwinstaSave ) && ( FALSE == SetProcessWindowStation( hWinSta ) ) )
        {
            // failed in changing the context
            SaveLastError();
            return FALSE;
        }

        // release the memory allocated for earlier window station
        if ( NULL != pWndTitles->pwszWinsta )
        {
            free( pWndTitles->pwszWinsta );
            pWndTitles->pwszWinsta = NULL;
        }

        // store the window station name
        pWndTitles->pwszWinsta = _tcsdup( lpstr );
        if ( NULL == pWndTitles->pwszWinsta )
        {
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();
            // restore the context to the previous windowstation
            if (hWinSta != hwinstaSave)
            {
                SetProcessWindowStation( hwinstaSave );
                CloseWindowStation( hWinSta );
            }
            return FALSE;
        }
    }

    // enumerate all the desktops for this windowstation
    EnumDesktops( hWinSta, EnumDesktopsFunc, lParam );

    // restore the context to the previous windowstation
    if (hWinSta != hwinstaSave)
    {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hWinSta );
    }

    // continue the enumeration
    return TRUE;
}


BOOL
CALLBACK EnumDesktopsFunc(
    IN LPTSTR lpstr,
    IN LPARAM lParam
    )
/*++
Routine Description:
      Enumerates the windows on a particular desktop
      This is a CALLBACK function ... called by EnumDesktops API function

Arguments:
      [ in ] lpstr    : desktop name
      [ in ] lParam   : user supplied parameter to this function
                        in this function, this points to TTASKSLIST structure variable

Return Value:
      TRUE upon success and FALSE on failure
--*/
{
    // local variables
    HDESK hDesk = NULL;
    HDESK hdeskSave = NULL;
    PTWINDOWTITLES pWndTitles = ( PTWINDOWTITLES )lParam;

    // check the input arguments
    if ( ( NULL == lpstr ) || ( NULL == lParam ) )
    {
        return FALSE;
    }
    // get and save the current desktop
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    // open the tasks desktop and change the context to the new desktop
    hDesk = OpenDesktop( lpstr, 0, FALSE, MAXIMUM_ALLOWED );
    if ( NULL == hDesk )
    {
        // failed in getting the process desktop
        SaveLastError();
        return FALSE;
    }
    else
    {
        // change the context to the new desktop
        if ( ( hDesk != hdeskSave ) && ( FALSE == SetThreadDesktop( hDesk ) ) )
        {
            // failed in changing the context
            SaveLastError();
            return FALSE;
        }

        // release the memory allocated for earlier window station
        if ( NULL != pWndTitles->pwszDesk )
        {
            free( pWndTitles->pwszDesk );
            pWndTitles->pwszDesk = NULL;
        }

        // store the desktop name
        pWndTitles->pwszDesk = _tcsdup( lpstr );
        if ( NULL == pWndTitles->pwszDesk )
        {
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();
            // restore the previous desktop
            if (hDesk != hdeskSave)
            {
                SetThreadDesktop( hdeskSave );
                CloseDesktop( hDesk );
            }
            return FALSE;
        }
    }

    // enumerate all windows in the new desktop
    // first try to get only the top level windows and visible windows only
    ( ( PTWINDOWTITLES ) lParam )->bFirstLoop = TRUE;
    EnumWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );
    EnumMessageWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );

    // enumerate all windows in the new desktop
    // now try to get window titles of all those processes whose we ignored earlier while
    // looping first time
    ( ( PTWINDOWTITLES ) lParam )->bFirstLoop = FALSE;
    EnumWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );
    EnumMessageWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );

    // restore the previous desktop
    if (hDesk != hdeskSave)
    {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hDesk );
    }

    // continue enumeration
    return TRUE;
}


BOOL
CALLBACK EnumMessageWindows(
    IN WNDENUMPROC lpEnumFunc,
    IN LPARAM lParam
    )
/*++
Routine Description:
     Enumerates the message windows

Arguments:
     [ in ] lpEnumFunc   : address of call back function that has to be called for
                           each message window found
     [ in ] lParam       : user supplied parameter to this function
                           in this function, this points to TTASKSLIST structure variable

Return Value:
      TRUE upon success and FALSE on failure
--*/
{
    // local variables
    HWND hWnd = NULL;
    BOOL bResult = FALSE;

    // check the input arguments
    if ( ( NULL == lpEnumFunc ) || ( NULL == lParam ) )
    {
        return FALSE;
    }

    // enumerate all the message windows
    do
    {
        // find the message window
        hWnd = FindWindowEx( HWND_MESSAGE, hWnd, NULL, NULL );

        // check whether we got the handle to the message window or not
        if ( NULL != hWnd )
        {
            // explicitly call the windows enumerators call back function for this window
            bResult = ( *lpEnumFunc )( hWnd, lParam );

            // check the result of the enumeator call back function
            if ( FALSE == bResult )
            {
                // terminate the enumeration
                break;
            }
        }
    } while ( NULL != hWnd );

    // return the enumeration result
    return bResult;
}


BOOL
CALLBACK EnumWindowsProc(
    IN HWND hWnd,
    IN LPARAM lParam
    )
/*++
Routine Description:
      call back called by the API for each window
      retrives the window title and updates the accordingly

Arguments:
      [ in ] hWnd         : handle to the window
      [ in ] lParam       : user supplied parameter to this function
                            in this function, this points to TTASKSLIST structure variable

Return Value:
      TRUE upon success and FALSE on failure
--*/
{
    // local variables
    LONG lIndex = 0;
    DWORD dwPID = 0;
    BOOL bVisible = FALSE;
    BOOL bHung = FALSE;
    TARRAY arrWindows = NULL;
    PTWINDOWTITLES pWndTitles = NULL;
    WCHAR szWindowTitle[ 256 ] = NULL_STRING;

    // check the input arguments
    if ( ( NULL == hWnd ) || ( NULL == lParam ) )
    {
        return FALSE;
    }
    // get the values from the lParam
    pWndTitles = ( PTWINDOWTITLES ) lParam;
    arrWindows = pWndTitles->arrWindows;

    // get the processid for this window
    if ( 0 == GetWindowThreadProcessId( hWnd, &dwPID ) )
    {
        // failed in getting the process id
        return TRUE;            // return but, proceed enumerating other window handle
    }

    // get the visibility state of the window
    // if the window is not visible, and if this is the first we are enumerating the
    // window titles, ignore this process
    bVisible = GetWindowLong( hWnd, GWL_STYLE ) & WS_VISIBLE;
    if ( ( FALSE == bVisible ) && ( TRUE == pWndTitles->bFirstLoop ) )
    {
        return TRUE;    // return but, proceed enumerating other window handle
    }
    // check whether the current window ( for which we have the handle )
    // is main window or not. we don't need child windows
    if ( NULL != GetWindow(hWnd, GW_OWNER) )
    {
        // the current window handle is not for a top level window
        return TRUE;            // return but, proceed enumerating other window handle
    }

    // check if we are already got the window handle for the curren process or not
    // save it only if we are not having it
    lIndex = DynArrayFindDWORDEx( arrWindows, CTaskKill::twiProcessId, dwPID );
    if (  -1 == lIndex )
    {
        // window for this process is not there ... save it
        lIndex = DynArrayAppendRow( arrWindows, CTaskKill::twiCOUNT );
    }
    else
    {
        // check whether window details already exists or not
        if ( NULL != DynArrayItemAsHandle2( arrWindows, lIndex, CTaskKill::twiHandle ) )
        {
            lIndex = -1;        // window details already exists
        }
    }

    // check if window details has to be saved or not ... if needed save them
    if ( -1 != lIndex )
    {
        // check whether the application associated with this windows
        // responding ( or ) not responding
        bHung = IsHungAppWindow( hWnd );

        // save the data
        DynArraySetHandle2( arrWindows, lIndex, CTaskKill::twiHandle, hWnd );
        DynArraySetBOOL2( arrWindows, lIndex, CTaskKill::twiHungInfo, bHung );
        DynArraySetDWORD2( arrWindows, lIndex, CTaskKill::twiProcessId, dwPID );
        DynArraySetString2( arrWindows, lIndex,
            CTaskKill::twiWinSta, pWndTitles->pwszWinsta, 0 );
        DynArraySetString2( arrWindows, lIndex,
            CTaskKill::twiDesktop, pWndTitles->pwszDesk, 0 );

        // get and save the window title
        if ( 0 != GetWindowText( hWnd, szWindowTitle, SIZE_OF_ARRAY( szWindowTitle ) ) )
        {
            DynArraySetString2( arrWindows, lIndex, CTaskKill::twiTitle, szWindowTitle, 0 );
        }
    }

    // continue the enumeration
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\taskkill.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      TaskKill.h
//
//  Abstract:
//
//      macros and function prototypes of TaskKill.cpp
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//
// *********************************************************************************

#ifndef _TASKKILL_H
#define _TASKKILL_H

// resource header file
#include "resource.h"

//
// NOTE: THIS MODULE WILL WRITTEN IN SUCH A FASHION THAT IT WORKS ONLY
//       IN UNICODE BUILD COMPILATION
//
#ifndef UNICODE
#error Must compile only in unicode build environment
#endif

//
// general purpose macros
//

#define   DISPLAY_GET_REASON()          ShowMessageEx( stderr, 2, FALSE, L"%1 %2", \
                                                       TAG_ERROR, GetReason() )

#define EXIT_PROCESS( exitcode )    \
    ReleaseGlobals();   \
    return (exitcode);  \
    1

#define RELEASE_MEMORY_EX( block )  \
    if ( (block) != NULL )  \
    {   \
        FreeMemory( ( LPVOID * ) &( block ));  \
    }   \
    1

#define DESTROY_ARRAY( array )  \
    if ( (array) != NULL )  \
    {   \
        DestroyDynamicArray( &(array) );    \
        (array) = NULL; \
    }   \
    1

//
// winstation related structures ( extract from winsta.h - internal file )
//

//
// structures
typedef struct _CITRIX_PROCESS_INFORMATION {
    ULONG MagicNumber;
    ULONG LogonId;
    PVOID ProcessSid;
    ULONG Pad;
} CITRIX_PROCESS_INFORMATION, * PCITRIX_PROCESS_INFORMATION;

// ...
typedef struct _TS_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} TS_UNICODE_STRING;

// CAUTION:
// TS_SYSTEM_PROCESS_INFORMATION is duplicated from ntexapi.h, and slightly modified.
// (not nice, but necessary because the Midl compiler doesn't like PVOID !)
typedef struct _TS_SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    TS_UNICODE_STRING ImageName;
    LONG BasePriority;                     // KPRIORITY in ntexapi.h
    DWORD UniqueProcessId;                 // HANDLE in ntexapi.h
    DWORD InheritedFromUniqueProcessId;    // HANDLE in ntexapi.h
    ULONG HandleCount;
    ULONG SessionId;
    ULONG SpareUl3;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
} TS_SYSTEM_PROCESS_INFORMATION, *PTS_SYSTEM_PROCESS_INFORMATION;

// ...
typedef struct _TS_ALL_PROCESSES_INFO {
    PTS_SYSTEM_PROCESS_INFORMATION pspiProcessInfo;
    DWORD SizeOfSid;
    PBYTE pSid;
} TS_ALL_PROCESSES_INFO, *PTS_ALL_PROCESSES_INFO;

// defines
#define SERVERNAME_CURRENT                      ((HANDLE)NULL)
#define GAP_LEVEL_BASIC                         0
#define CITRIX_PROCESS_INFO_MAGIC               0x23495452
#define WINSTA_DLLNAME                          L"Winsta.dll"
#define FUNCNAME_WinStationFreeMemory           "WinStationFreeMemory"
#define FUNCNAME_WinStationCloseServer          "WinStationCloseServer"
#define FUNCNAME_WinStationOpenServerW          "WinStationOpenServerW"
#define FUNCNAME_WinStationEnumerateProcesses   "WinStationEnumerateProcesses"
#define FUNCNAME_WinStationFreeGAPMemory        "WinStationFreeGAPMemory"
#define FUNCNAME_WinStationGetAllProcesses      "WinStationGetAllProcesses"
#define SIZEOF_SYSTEM_THREAD_INFORMATION        sizeof( struct SYSTEM_THREAD_INFORMATION )
#define SIZEOF_SYSTEM_PROCESS_INFORMATION       sizeof( struct SYSTEM_PROCESS_INFORMATION )

//
// function prototypes
typedef BOOLEAN (WINAPI * FUNC_WinStationFreeMemory)( PVOID pBuffer );
typedef BOOLEAN (WINAPI * FUNC_WinStationCloseServer)( HANDLE hServer );
typedef HANDLE  (WINAPI * FUNC_WinStationOpenServerW)( LPWSTR pwszServerName );
typedef BOOLEAN (WINAPI * FUNC_WinStationEnumerateProcesses)( HANDLE  hServer, PVOID *ppProcessBuffer );
typedef BOOLEAN (WINAPI * FUNC_WinStationFreeGAPMemory)( ULONG Level,
                                                         PVOID ProcessArray, ULONG ulCount );
typedef BOOLEAN (WINAPI * FUNC_WinStationGetAllProcesses)( HANDLE hServer,
                                                           ULONG Level, ULONG *pNumberOfProcesses,
                                                           PVOID *ppProcessArray );

//
// constants / defines / enumerations
//

//
// WMI related stuff

// class name
#define CLASS_PROCESS                               L"Win32_Process"

// wmi query
#define WMI_QUERY_TYPE                  L"WQL"
#define WMI_SERVICE_QUERY               L"SELECT Name FROM Win32_Service WHERE ProcessId = %d and State=\"Running\""
#define WMI_MODULES_QUERY               L"ASSOCIATORS OF {%s} WHERE ResultClass = CIM_DataFile"
#define WMI_PROCESS_QUERY       \
    L"SELECT " \
    L"__PATH, ProcessId, CSName, Caption, SessionId, ThreadCount, " \
    L"WorkingSetSize, KernelModeTime, UserModeTime, ParentProcessId "   \
    L"FROM Win32_Process"

// wmi query operators etc
#define WMI_QUERY_FIRST_CLAUSE      L"WHERE ("
#define WMI_QUERY_SECOND_CLAUSE     L"AND"

// Win32_Process class properties
#define WIN32_PROCESS_SYSPROPERTY_PATH              L"__PATH"
#define WIN32_PROCESS_PROPERTY_HANDLE               L"Handle"
#define WIN32_PROCESS_PROPERTY_COMPUTER             L"CSName"
#define WIN32_PROCESS_PROPERTY_IMAGENAME            L"Caption"
#define WIN32_PROCESS_PROPERTY_PROCESSID            L"ProcessId"
#define WIN32_PROCESS_PROPERTY_SESSION              L"SessionId"
#define WIN32_PROCESS_PROPERTY_THREADS              L"ThreadCount"
#define WIN32_PROCESS_PROPERTY_USERMODETIME         L"UserModeTime"
#define WIN32_PROCESS_PROPERTY_MEMUSAGE             L"WorkingSetSize"
#define WIN32_PROCESS_PROPERTY_KERNELMODETIME       L"KernelModeTime"
#define WIN32_PROCESS_PROPERTY_PARENTPROCESSID      L"ParentProcessId"

// Win32_Process class method(s)
#define WIN32_PROCESS_METHOD_GETOWNER               L"GetOwner"
#define WIN32_PROCESS_METHOD_TERMINATE              L"Terminate"

// GetOwner method's return values
#define GETOWNER_RETURNVALUE_USER                   L"User"
#define GETOWNER_RETURNVALUE_DOMAIN                 L"Domain"

// Terminate input values
#define TERMINATE_INPARAM_REASON                    L"Reason"

// function default return value
#define WMI_RETURNVALUE                             L"ReturnValue"

// Win32_Service related stuff
#define WIN32_SERVICE_PROPERTY_NAME                 L"Name"

// CIM_DataFile related stuff
#define CIM_DATAFILE_PROPERTY_FILENAME              L"FileName"
#define CIM_DATAFILE_PROPERTY_EXTENSION             L"Extension"

//
// other stuff
#define VALUE_RUNNING               GetResString( IDS_VALUE_RUNNING )
#define VALUE_NOTRESPONDING         GetResString( IDS_VALUE_NOTRESPONDING )
#define VALUE_UNKNOWN               GetResString( IDS_VALUE_UNKNOWN )
#define PID_0_DOMAIN                GetResString( IDS_PID_0_DOMAIN )
#define PID_0_USERNAME              GetResString( IDS_PID_0_USERNAME )

// messages
#define MSG_KILL_SUCCESS                        GetResString( IDS_MSG_KILL_SUCCESS )
#define MSG_KILL_SUCCESS_QUEUED                 GetResString( IDS_MSG_KILL_SUCCESS_QUEUED )
#define MSG_KILL_SUCCESS_EX                     GetResString( IDS_MSG_KILL_SUCCESS_EX )
#define MSG_KILL_SUCCESS_QUEUED_EX              GetResString( IDS_MSG_KILL_SUCCESS_QUEUED_EX )
#define MSG_TREE_KILL_SUCCESS                   GetResString( IDS_MSG_TREE_KILL_SUCCESS )
#define MSG_TREE_KILL_SUCCESS_QUEUED            GetResString( IDS_MSG_TREE_KILL_SUCCESS_QUEUED )
#define ERROR_TREE_KILL_FAILED                  GetResString( IDS_ERROR_TREE_KILL_FAILED )
#define ERROR_TASK_HAS_CHILDS                   GetResString( IDS_ERROR_TASK_HAS_CHILDS )
#define ERROR_KILL_FAILED                       GetResString( IDS_ERROR_KILL_FAILED )
#define ERROR_KILL_FAILED_EX                    GetResString( IDS_ERROR_KILL_FAILED_EX )
#define ERROR_PROCESS_NOTFOUND                  GetResString( IDS_ERROR_PROCESS_NOTFOUND )
#define ERROR_NO_PROCESSES                      GetResString( IDS_ERROR_NO_PROCESSES )
#define ERROR_UNABLE_TO_TERMINATE               GetResString( IDS_ERROR_UNABLE_TO_TERMINATE )
#define ERROR_CRITICAL_SYSTEM_PROCESS           GetResString( IDS_ERROR_CRITICAL_SYSTEM_PROCESS )
#define ERROR_CANNOT_KILL_SILENTLY              GetResString( IDS_ERROR_CANNOT_KILL_SILENTLY )
#define ERROR_CANNOT_KILL_ITSELF                GetResString( IDS_ERROR_CANNOT_KILL_ITSELF )
#define ERROR_COM_ERROR                         GetResString( IDS_ERROR_COM_ERROR )
#define ERROR_USERNAME_BUT_NOMACHINE            GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME           GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_USERNAME_EMPTY                    GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_SERVER_EMPTY                      GetResString( IDS_ERROR_SERVER_EMPTY )
#define ERROR_WILDCARD_WITHOUT_FILTERS          GetResString( IDS_ERROR_WILDCARD_WITHOUT_FILTERS )
#define ERROR_PID_OR_IM_ONLY                    GetResString( IDS_ERROR_PID_OR_IM_ONLY )
#define ERROR_NO_PID_AND_IM                     GetResString( IDS_ERROR_NO_PID_AND_IM )
#define ERROR_STRING_FOR_PID                    GetResString( IDS_ERROR_STRING_FOR_PID )
#define ERROR_INVALID_USAGE_REQUEST             GetResString( IDS_ERROR_INVALID_USAGE_REQUEST )
#define ERROR_PLATFORM_SHOULD_BE_X86            GetResString( IDS_ERROR_PLATFORM_SHOULD_BE_X86 )

//
// command line options and their indexes in the array
#define MAX_OPTIONS         9

// supported options ( do not localize )
#define OPTION_USAGE        L"?"
#define OPTION_SERVER       L"s"
#define OPTION_USERNAME     L"u"
#define OPTION_PASSWORD     L"p"
#define OPTION_FORCE        L"f"
#define OPTION_FILTER       L"fi"
#define OPTION_PID          L"pid"
#define OPTION_IMAGENAME    L"im"
#define OPTION_TREE         L"t"

// indexes
#define OI_USAGE                    0
#define OI_SERVER                   1
#define OI_USERNAME                 2
#define OI_PASSWORD                 3
#define OI_FORCE                    4
#define OI_FILTER                   5
#define OI_PID                      6
#define OI_IMAGENAME                7
#define OI_TREE                     8

//
// filter details
#define MAX_FILTERS         10

// supported filters
#define FILTER_STATUS       GetResString( IDS_FILTER_STATUS )
#define FILTER_IMAGENAME    GetResString( IDS_FILTER_IMAGENAME )
#define FILTER_PID          GetResString( IDS_FILTER_PID )
#define FILTER_SESSION      GetResString( IDS_FILTER_SESSION )
#define FILTER_CPUTIME      GetResString( IDS_FILTER_CPUTIME )
#define FILTER_MEMUSAGE     GetResString( IDS_FILTER_MEMUSAGE )
#define FILTER_USERNAME     GetResString( IDS_FILTER_USERNAME )
#define FILTER_SERVICES     GetResString( IDS_FILTER_SERVICES )
#define FILTER_WINDOWTITLE  GetResString( IDS_FILTER_WINDOWNAME )
#define FILTER_MODULES      GetResString( IDS_FILTER_MODULES )

#define FI_STATUS           0
#define FI_IMAGENAME        1
#define FI_PID              2
#define FI_SESSION          3
#define FI_CPUTIME          4
#define FI_MEMUSAGE         5
#define FI_USERNAME         6
#define FI_SERVICES         7
#define FI_WINDOWTITLE      8
#define FI_MODULES          9

// values supported by 'status' filter
#define FVALUES_STATUS      GetResString( IDS_FVALUES_STATUS )

// operators supported
#define OPERATORS_STRING    GetResString( IDS_OPERATORS_STRING )
#define OPERATORS_NUMERIC   GetResString( IDS_OPERATORS_NUMERIC )

// max. columns ( information ) to be stored for one task
#define MAX_TASKSINFO           18

// task info indexes
#define TASK_HOSTNAME           0
#define TASK_IMAGENAME          1
#define TASK_PID                2
#define TASK_SESSIONNAME        3
#define TASK_SESSION            4
#define TASK_MEMUSAGE           5
#define TASK_STATUS             6
#define TASK_USERNAME           7
#define TASK_CPUTIME            8
#define TASK_WINDOWTITLE        9
#define TASK_SERVICES           10
#define TASK_MODULES            11

// always hidden
#define TASK_HWND               12
#define TASK_WINSTA             13
#define TASK_DESK               14
#define TASK_CREATINGPROCESSID  15
#define TASK_OBJPATH            16
#define TASK_RANK               17

#define NULL_STRING             L"\0"
//
// CTaskKill
//
class CTaskKill
{
public:
    // enumerators
    enum
    {
        twiProcessId = 0,
        twiWinSta = 1,
        twiDesktop = 2,
        twiHandle = 3,
        twiTitle = 4,
        twiHungInfo = 5,
        twiCOUNT,
    };

// constructor / destructor
public:
    CTaskKill();
    ~CTaskKill();

// data memebers
private:
    // input arguments
    BOOL m_bTree;                   // -tr
    BOOL m_bForce;                  // -fo
    CHString m_strServer;           // -s
    CHString m_strUserName;         // -u
    CHString m_strPassword;         // -p
    TARRAY m_arrFilters;            // -fi
    TARRAY m_arrTasksToKill;        // ( defaults = -im and -pid )

    // WMI Query
    CHString m_strQuery;

    // other(s)
    DWORD m_dwCurrentPid;
    BOOL m_bNeedPassword;
    BOOL m_bNeedModulesInfo;
    TARRAY m_arrFiltersEx;          // parsed filters info
    TARRAY m_arrWindowTitles;           // window titles
    BOOL m_bNeedServicesInfo;       // determines whether services info has to gathered or not
    BOOL m_bNeedUserContextInfo;    // determines whether userinfo has to gathered or not
    PTFILTERCONFIG m_pfilterConfigs;    // filters config information

    // WMI / COM interfaces
    IWbemLocator* m_pWbemLocator;
    IWbemServices* m_pWbemServices;
    IEnumWbemClassObject* m_pWbemEnumObjects;
    IWbemClassObject* m_pWbemTerminateInParams;

    // WMI connectivity
    COAUTHIDENTITY* m_pAuthIdentity;

    // output data
    TARRAY m_arrRecord;
    DWORD m_dwProcessId;
    CHString m_strImageName;
    BOOL m_bTasksOptimized;
    BOOL m_bFiltersOptimized;

    // winstation related stuff
    CHString m_strUNCServer;                // server name
    BOOL m_bIsHydra;
    HMODULE m_hWinstaLib;
    PBYTE m_pProcessInfo;
    ULONG m_ulNumberOfProcesses;
    BOOL m_bCloseConnection;

    // services related stuff
    DWORD m_dwServicesCount;
    LPENUM_SERVICE_STATUS_PROCESS m_pServicesInfo;

    // modules related stuff ( remote only )
    BOOL m_bUseRemote;
    PPERF_DATA_BLOCK m_pdb;

    //
    // functions
    FUNC_WinStationFreeMemory m_pfnWinStationFreeMemory;
    FUNC_WinStationOpenServerW m_pfnWinStationOpenServerW;
    FUNC_WinStationCloseServer m_pfnWinStationCloseServer;
    FUNC_WinStationFreeGAPMemory m_pfnWinStationFreeGAPMemory;
    FUNC_WinStationGetAllProcesses m_pfnWinStationGetAllProcesses;
    FUNC_WinStationEnumerateProcesses m_pfnWinStationEnumerateProcesses;

public:
    BOOL m_bUsage;                  // -?
    BOOL m_bLocalSystem;

// functions
private:
    BOOL CanTerminate();
    BOOL Kill();
    BOOL KillProcessOnLocalSystem();
    BOOL ForciblyKillProcessOnLocalSystem();
    BOOL ForciblyKillProcessOnRemoteSystem();
    LONG MatchTaskToKill( DWORD& dwMatchedIndex );

    // helpers
    VOID DoOptimization();
    VOID SaveData( IWbemClassObject* pWmiObject );
    VOID SetMemUsage( IWbemClassObject* pWmiObject );
    VOID SetCPUTime( IWbemClassObject* pWmiObject );
    VOID SetUserContext( IWbemClassObject* pWmiObject );
    VOID SetWindowTitle( void );
    VOID SetServicesInfo( void );
    BOOL SetModulesInfo( void );

    // ...
    BOOL LoadTasksEx();
    BOOL LoadModulesInfo();
    BOOL LoadServicesInfo();
    BOOL GetModulesOnRemote( TARRAY arrModules );
    BOOL GetModulesOnRemoteEx( TARRAY arrModules );
    BOOL LoadModulesOnLocal( TARRAY arrModules );
    BOOL LoadUserNameFromWinsta( CHString& strDomain, CHString& strUserName );

    // winsta functions
    BOOLEAN WinStationFreeMemory( PVOID pBuffer );
    BOOLEAN WinStationCloseServer( HANDLE hServer );
    HANDLE  WinStationOpenServerW( LPWSTR pwszServerName );
    BOOLEAN WinStationEnumerateProcesses( HANDLE  hServer, PVOID *ppProcessBuffer );
    BOOLEAN WinStationFreeGAPMemory( ULONG Level, PVOID ProcessArray, ULONG ulCount );
    BOOLEAN WinStationGetAllProcesses( HANDLE hServer, ULONG Level,
                                       ULONG *pNumberOfProcesses, PVOID *ppProcessArray );
public:
    VOID Usage();
    BOOL Initialize();
    VOID PrepareColumns();
    BOOL ValidateFilters();
    BOOL ProcessOptions( DWORD argc, LPCTSTR argv[] );

    // functionality related
    BOOL Connect();
    BOOL LoadTasks();
    BOOL EnableDebugPriv();
    BOOL DoTerminate( DWORD& dwTerminate );
};

//
// public functions
//

#endif  // _TASKLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\terminate.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      Terminate.cpp
//
//  Abstract:
//
//      This module implements the actual termination of process
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "TaskKill.h"

//
// define(s) / constants
//
#define MAX_ENUM_TASKS              5
#define MAX_ENUM_SERVICES           10
#define MAX_ENUM_MODULES            10
#define WAIT_TIME_IN_SECS           1000                // 1 second ( 1000 milliseconds )
#define MAX_TIMEOUT_RETRIES         60                  // 60 times
#define MAX_TERMINATE_TIMEOUT       1000                // 1 seconds

// We won't allow the following set of critical system processes to be terminated,
// since the system would bug check immediately, no matter who you are.
#define PROCESS_CSRSS_EXE           L"csrss.exe"
#define PROCESS_WINLOGON_EXE        L"winlogon.exe"
#define PROCESS_SMSS_EXE            L"smss.exe"
#define PROCESS_SERVICES_EXE        L"services.exe"

//
// function prototypes
//
#ifndef _WIN64
BOOL EnumLoadedModulesProc( LPSTR lpszModuleName, ULONG ulModuleBase, ULONG ulModuleSize, PVOID pUserData );
#else
BOOL EnumLoadedModulesProc64( LPSTR lpszModuleName, DWORD64 ulModuleBase, ULONG ulModuleSize, PVOID pUserData );
#endif


BOOL
CTaskKill::DoTerminate(
    OUT DWORD& dwExitCode
    )
/*++
Routine Description:
      Search for a valid process to terminate and if found terminate.

Arguments:
      OUT dwExitcode : Contains number with which to exit process.

Return Value:
      TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString str;
    LONG lIndex = -1;
    DWORD dwCount = 0;
    DWORD dwKilled = 0;
    DWORD dwFilters = 0;
    DWORD dwTimeOuts = 0;
    DWORD dwImageNames = 0;
    DWORD dwTasksToKill = 0;
    DWORD dwMatchedIndex = 0;
    BOOL bCanExit = FALSE;
    BOOL bAllTasks = FALSE;
    BOOL bImageName = FALSE;
    ULONG ulReturned = 0;
    TARRAY arrTasks = NULL;
    TARRAY arrImageNames = NULL;
    LPCWSTR pwszTask = NULL;
    IWbemClassObject* pObjects[ MAX_ENUM_TASKS ];

    // clear the error
    SetLastError( ( DWORD )NO_ERROR );

    try
    {
        //
        // prepare ...
        bCanExit = FALSE;
        dwImageNames = 0;
        dwFilters = DynArrayGetCount( m_arrFiltersEx );
        dwTasksToKill = DynArrayGetCount( m_arrTasksToKill );
        arrTasks = CreateDynamicArray();
        arrImageNames = CreateDynamicArray();
        if ( ( NULL == arrImageNames ) || ( NULL == arrTasks ) )
        {
            dwExitCode = 1;
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();

            // release the allocations
            DESTROY_ARRAY( arrTasks );
            DESTROY_ARRAY( arrImageNames );

            // inform failure
            return FALSE;
        }

        // check if '*' is specified or not
        lIndex = DynArrayFindString( m_arrTasksToKill, L"*", TRUE, 0 );
        if ( lIndex != -1 )
        {
            // wild card specified
            dwTasksToKill--;                                // update the counter
            bAllTasks = TRUE;                               // remember
            DynArrayRemove( m_arrTasksToKill, lIndex );     // remove the wildcard entry
        }

        // init all the objects first
        for( DWORD dw = 0; dw < MAX_ENUM_TASKS; dw++ )
        {
            pObjects[ dw ] = NULL;
        }
        // if -tr is specified, free the already allocated memory for m_arrRecord
        if ( TRUE == m_bTree )
        {
            DESTROY_ARRAY( m_arrRecord );
        }

        // traverse thru the running processed and terminate the needed
        dwCount = 0;
        dwKilled = 0;
        do
        {
            // get the object ... time out should not occur
            // NOTE: one-by-one
            hr = m_pWbemEnumObjects->Next(
                WAIT_TIME_IN_SECS, MAX_ENUM_TASKS, pObjects, &ulReturned );
            if ( hr == (HRESULT) WBEM_S_FALSE )
            {
                // we've reached the end of enumeration .. set the flag
                bCanExit = TRUE;
            }
            else if ( hr == (HRESULT) WBEM_S_TIMEDOUT )
            {
                // update the timeouts occured
                dwTimeOuts++;

                // check if max. retries have reached ... if yes better stop
                if ( dwTimeOuts > MAX_TIMEOUT_RETRIES )
                {
                    dwExitCode = 1;
                    DESTROY_ARRAY( arrTasks );
                    DESTROY_ARRAY( arrImageNames );
                    SetLastError( ( DWORD )ERROR_TIMEOUT );
                    SaveLastError();
                    return FALSE;
                }

                // still we can do some more tries ...
                continue;
            }
            else if ( FAILED( hr ) )
            {
                // some error has occured ... oooppps
                dwExitCode = 1;
                DESTROY_ARRAY( arrTasks );
                DESTROY_ARRAY( arrImageNames );
                WMISaveError( hr );
                return FALSE;
            }

            // reset the timeout counter
            dwTimeOuts = 0;

            // loop thru the objects and save the info
            for( ULONG ul = 0; ul < ulReturned; ul++ )
            {
                // if tree option is specified, allocate memory for record every we loop
                if ( m_bTree == TRUE )
                {
                    // create a new array
                    m_arrRecord = CreateDynamicArray();
                    if ( m_arrRecord == NULL )
                    {
                        dwExitCode = 1;
                        SetLastError( ( DWORD )E_OUTOFMEMORY );
                        SaveLastError();

                        // release the allocations
                        DESTROY_ARRAY( arrTasks );
                        DESTROY_ARRAY( arrImageNames );

                        // inform failure
                        return FALSE;
                    }
                }
                else
                {
                    // tree option is not specified, so, just remove the contents
                    DynArrayRemoveAll( m_arrRecord );
                }

                // add the columns first
                DynArrayAddColumns( m_arrRecord, MAX_TASKSINFO );

                // retrive and save data
                SaveData( pObjects[ ul ] );

                // release the object
                SAFE_RELEASE( pObjects[ ul ] );

                // check if this has to be filtered or not
                if ( dwFilters != 0 )
                {
                    BOOL bIgnore = FALSE;
                    bIgnore = CanFilterRecord( MAX_FILTERS,
                        m_pfilterConfigs, m_arrRecord, m_arrFiltersEx );

                    // check if this has to be ignored or not
                    if ( bIgnore == TRUE )
                    {
                        if ( m_bTree == TRUE )
                        {
                            // save this record with rank as 0
                            DynArraySetDWORD( m_arrRecord, TASK_RANK, 0 );
                            DynArrayAppendEx( arrTasks, m_arrRecord );
                        }

                        // continue to the task
                        continue;
                    }
                }

                // crossed from the filter -- update the count
                dwCount++;

                // find the task that has to be killed
                // and check if this task has to be killed or not
                lIndex = -1;
                pwszTask = NULL;
                bImageName = FALSE;
                if ( dwTasksToKill != 0 || dwImageNames != 0 )
                {
                    // check if the process is in list
                    if ( dwTasksToKill != 0 )
                        lIndex = MatchTaskToKill( dwMatchedIndex );

                    // if task is not, check if image names exist and if it matches or not
                    if ( lIndex == -1 && dwImageNames != 0 )
                    {
                        // get the image name and search for the same in the image names list
                        DWORD dwLength = 0;
                        LPCWSTR pwsz = NULL;
                        LPCWSTR pwszTemp = NULL;
                        LPCWSTR pwszImageName = NULL;
                        pwszImageName = DynArrayItemAsString( m_arrRecord, TASK_IMAGENAME );
                        if ( pwszImageName == NULL )
                        {
                            dwExitCode = 1;
                            DESTROY_ARRAY( arrTasks );
                            DESTROY_ARRAY( arrImageNames );
                            SetLastError( ( DWORD )STG_E_UNKNOWN );
                            SaveLastError();
                            return FALSE;
                        }

                        // ...
                        for( DWORD dw = 0; dw < dwImageNames; dw++ )
                        {
                            // get the image name from the list
                            pwszTemp = DynArrayItemAsString( arrImageNames, dw );
                            if ( pwszTemp == NULL )
                            {
                                dwExitCode = 1;
                                DESTROY_ARRAY( arrTasks );
                                DESTROY_ARRAY( arrImageNames );
                                SetLastError( ( DWORD )STG_E_UNKNOWN );
                                SaveLastError();
                                return FALSE;
                            }

                            // determine the no. of characters to compare
                            dwLength = 0;
                            pwsz = FindChar( pwszTemp, L'*', 0 );
                            if ( pwsz != NULL )
                            {
                                // '*' - wildcard is specified in the image name
                                // so, determine the no. of characters to compare
                                // but before that check the length of the string pointer from '*'
                                // it should be 1 - meaning the '*' can be specified only at the end
                                // but not in the middle
                                if ( 1 == StringLength( pwsz, 0 ) )
                                {
                                    dwLength = StringLength( pwszTemp, 0 ) - StringLength( pwsz, 0 );
                                }
                            }

                            // now do the comparision
                            if ( StringCompare( pwszImageName, pwszTemp, TRUE, dwLength ) == 0 )
                            {
                                // image found - has to be terminated
                                bImageName = TRUE;
                                pwszTask = pwszTemp;
                            }
                        }
                    }
                    else if ( lIndex != -1 && dwMatchedIndex == TASK_IMAGENAME )
                    {
                        bImageName = TRUE;          // image name
                        pwszTask = DynArrayItemAsString( m_arrTasksToKill, lIndex );
                    }
                }

                // check whether attempt to terminate or not to attempt
                if ( bAllTasks == FALSE && lIndex == -1 && bImageName == FALSE )
                {
                    if ( m_bTree == TRUE )
                    {
                        // save this record with rank as 0
                        dwCount--;
                        DynArraySetDWORD( m_arrRecord, TASK_RANK, 0 );
                        DynArrayAppendEx( arrTasks, m_arrRecord );
                    }

                    // continue to the task
                    continue;
                }

                // we need to post-pone the killing of the current identified task till we get the
                // entire list of processes
                if ( m_bTree == TRUE )
                {
                    // mark this as rank 1 process
                    DynArraySetDWORD( m_arrRecord, TASK_RANK, 1 );

                    // now add this record to the tasks array
                    DynArrayAppendEx( arrTasks, m_arrRecord );
                }
                else
                {
                    // kill the current task
                    if ( this->Kill() == TRUE )
                    {
                        dwKilled++;     // updated killed processes counter

                        // success message will depend on the task info specified by the user
                        // at the command prompt
                        if ( bImageName == TRUE )
                        {
                            if ( m_bLocalSystem == TRUE && m_bForce == FALSE )
                            {
                                str.Format(MSG_KILL_SUCCESS_QUEUED_EX, m_strImageName, m_dwProcessId);
                            }
                            else
                            {
                                str.Format(MSG_KILL_SUCCESS_EX, m_strImageName, m_dwProcessId);
                            }
                        }
                        else
                        {
                            if ( m_bLocalSystem == TRUE && m_bForce == FALSE )
                            {
                                str.Format( MSG_KILL_SUCCESS_QUEUED, m_dwProcessId );
                            }
                            else
                            {
                                str.Format( MSG_KILL_SUCCESS, m_dwProcessId );
                            }
                        }

                        // show the message
                        ShowMessage( stdout, str );
                    }
                    else
                    {
                        // failed to kill the process .. save the error message
                        if ( bImageName == FALSE )
                            str.Format( ERROR_KILL_FAILED, m_dwProcessId, GetReason() );
                        else
                            str.Format( ERROR_KILL_FAILED_EX, m_strImageName, m_dwProcessId, GetReason() );

                        // show the message
                        ShowMessage( stderr, str );
                    }
                }

                // user might have specified the duplications in the list
                // so check for that and remove it
                if ( bImageName == TRUE )
                {
                    // sub-local
                    CHString strProcessId;
                    LONG lProcessIndex = -1;
                    strProcessId.Format( L"%ld", m_dwProcessId );
                    lProcessIndex = DynArrayFindString( m_arrTasksToKill, strProcessId, TRUE, 0 );
                    if ( lProcessIndex != -1 && lIndex != lProcessIndex )
                        DynArrayRemove( m_arrTasksToKill, lProcessIndex );
                }
                else if ( pwszTask != NULL )
                {
                    // sub-local
                    LONG lProcessIndex = -1;
                    lProcessIndex = DynArrayFindString( m_arrTasksToKill, pwszTask, TRUE, 0 );
                    if ( lProcessIndex != -1 && lIndex != lProcessIndex )
                    {
                        bImageName = TRUE;
                        DynArrayRemove( m_arrTasksToKill, lProcessIndex );
                    }
                }

                // if this is a image name, all the tasks with this image name
                // has to be terminated. so we need to save the image name
                // but before doing this, in order to save memory, check if this image name
                // already exists in the list .. this will avoid duplication of image names
                // in the list and helps in performace
                if ( bImageName == TRUE && pwszTask != NULL &&
                     DynArrayFindString(arrImageNames, pwszTask, TRUE, 0) == -1 )
                {
                    // add to the list
                    dwImageNames++;
                    DynArrayAppendString( arrImageNames, pwszTask, 0 );
                }

                // delete the process info from the arrProcesses ( if needed )
                if ( lIndex != -1 )
                {
                    // yes ... current task was killed remove the entry from arrProcess into
                    // consideration ... so delete it
                    dwTasksToKill--;        // update the counter
                    DynArrayRemove( m_arrTasksToKill, lIndex );
                }

                // check whether we need to quit the program or not
                if ( m_bTree == FALSE && bAllTasks == FALSE && dwTasksToKill == 0 && dwImageNames == 0 )
                {
                    bCanExit = TRUE;
                    break;
                }
            }
        } while ( bCanExit == FALSE );

        // Check (a) are there any process to kill, (b) If yes, are any process killed.
        if( ( 0 != dwCount ) &&( 0 == dwKilled ) )
        {
            dwExitCode = 1;
        }

        // if the -tr is specified, reset the m_arrRecord variable to NULL
        // this will avoid double free-ing the same heap memory
        if ( m_bTree == TRUE )
        {
            m_arrRecord = NULL;
        }

        //
        // SPECIAL HANDLING FOR TREE TERMINATION STARTS HERE
        //
        if ( m_bTree == TRUE && dwCount != 0 )
        {
            //
            // prepare the tree

            // sub-local variables
            LONG lTemp = 0;
            DWORD dwTemp = 0;
            DWORD dwRank = 0;
            DWORD dwIndex = 0;
            DWORD dwLastRank = 0;
            DWORD dwTasksCount = 0;
            DWORD dwProcessId = 0;
            DWORD dwParentProcessId = 0;

            // Need to set error code to 0.
            dwExitCode = 0;
            // loop thru the list of processes
            dwLastRank = 1;
            dwTasksCount = DynArrayGetCount( arrTasks );
            for( dwIndex = 0; dwIndex < dwTasksCount; dwIndex++ )
            {
                // get the rank of the current process
                // and check whether the current process is marked for termination or not
                dwRank = DynArrayItemAsDWORD2( arrTasks, dwIndex, TASK_RANK );
                if ( dwRank == 0 )
                    continue;

                // now loop thru the begining of the tasks and
                // assign the ranks to the childs of this process
                dwProcessId = DynArrayItemAsDWORD2( arrTasks, dwIndex, TASK_PID );
                for( DWORD dw = dwIndex + 1; dw < dwTasksCount; dw++ )
                {
                    // get the process id this process
                    dwTemp = DynArrayItemAsDWORD2( arrTasks, dw, TASK_PID );
                    if ( dwTemp == dwProcessId )
                        continue;               // skip this process

                    // get the parent process id of this process
                    dwParentProcessId = DynArrayItemAsDWORD2( arrTasks, dw, TASK_CREATINGPROCESSID );
                    if ( dwTemp == dwParentProcessId )
                        continue;                       // skip this process also

                    // check the process relation
                    if ( dwProcessId == dwParentProcessId )
                    {
                        // set the rank to this process
                        DynArraySetDWORD2( arrTasks, dw, TASK_RANK, dwRank + 1 );

                        // update the last rank
                        if ( dwRank + 1 > dwLastRank )
                        {
                            dwLastRank = dwRank + 1;
                        }

                        // SPECIAL CONDITION:
                        // -----------------
                        // we need to check the index of this task in the list of tasks information we have
                        // if the index of this task information is above its parent process,
                        // we need to re-initiate the outter loop once again
                        // this is a sort of optimization which we are doing here instead of looping the
                        // outter loop unnecessarily
                        // if ( dw < dwIndex )
                        // {
                        //  dwIndex = 0;
                        // }
                        // ----------------------------------------------------------
                        // currently we are assuming that the list of processe we get
                        // will be in sorting order of creation time
                        // ----------------------------------------------------------
                    }
                }
            }

            //
            // now start terminating the tasks based on their ranks
            dwKilled = 0;
            for( dwRank = dwLastRank; dwRank > 0; dwRank-- )
            {
                // loop thru all the processes and terminate
                for ( lIndex = 0; lIndex < (LONG) dwTasksCount; lIndex++ )
                {
                    // get the record
                    m_arrRecord = (TARRAY) DynArrayItem( arrTasks, lIndex );
                    if ( m_arrRecord == NULL )
                        continue;

                    // check the rank
                    dwTemp = DynArrayItemAsDWORD( m_arrRecord, TASK_RANK );
                    if ( dwTemp != dwRank )
                    {
                        // OPTIMIZATION:
                        // ------------
                        //    check the rank. if the rank is zero, delete this task from the list
                        //    this improves the performance when we run for the next loop
                        if ( dwTemp == 0 )
                        {
                            DynArrayRemove( arrTasks, lIndex );
                            lIndex--;
                            dwTasksCount--;
                        }

                        // skip this task
                        continue;
                    }

                    // get the process id and its parent process id
                    m_dwProcessId = DynArrayItemAsDWORD( m_arrRecord, TASK_PID );
                    dwParentProcessId = DynArrayItemAsDWORD( m_arrRecord, TASK_CREATINGPROCESSID );

                    // ensure that there are no child for this process
                    // NOTE: Termination of some childs might have failed ( this is needed only if -f is not specified )
                    if ( m_bForce == FALSE )
                    {
                        lTemp = DynArrayFindDWORDEx( arrTasks, TASK_CREATINGPROCESSID, m_dwProcessId );
                        if ( lTemp != -1 )
                        {
                            // set the reason
                            SetReason( ERROR_TASK_HAS_CHILDS );

                            // format the error message
                            str.Format( ERROR_TREE_KILL_FAILED, m_dwProcessId, dwParentProcessId, GetReason() );

                            // show the message
                            ShowMessage( stderr, str );

                            // skip this
                            continue;
                        }
                    }

                    // kill the current task
                    if ( this->Kill() == TRUE )
                    {
                        dwKilled++;     // updated killed processes counter

                        // prepare the error message
                        if ( m_bForce == TRUE )
                        {
                            str.Format( MSG_TREE_KILL_SUCCESS, m_dwProcessId, dwParentProcessId );
                        }
                        else
                        {
                            str.Format( MSG_TREE_KILL_SUCCESS_QUEUED, m_dwProcessId, dwParentProcessId );
                        }

                        // remove the current task entry from the list and update the indexes accordingly
                        DynArrayRemove( arrTasks, lIndex );
                        lIndex--;
                        dwTasksCount--;

                        // show the message
                        ShowMessage( stdout, str );
                    }
                    else
                    {
                        // prepare the error message
                        str.Format( ERROR_TREE_KILL_FAILED, m_dwProcessId, dwParentProcessId, GetReason() );

                        // show the message
                        ShowMessage( stderr, str );
                    }
                }
            }

            // reset the value of m_arrRecord
            m_arrRecord = NULL;

            // determine the exit code
            if ( dwTasksCount == dwCount )
                dwExitCode = 255;           // not even one task got terminated
            else if ( dwTasksToKill != 0 || dwTasksCount != 0 )
                dwExitCode = 128;           // tasks were terminated partially
        }
        //
        // SPECIAL HANDLING FOR TREE TERMINATION ENDS HERE
        //
    }
    catch( CHeap_Exception )
    {
        // free the memory
        DESTROY_ARRAY( arrTasks );
        DESTROY_ARRAY( arrImageNames );

        SetLastError( ( DWORD )E_OUTOFMEMORY );
        return 255;
    }

    // free the memory
    DESTROY_ARRAY( arrTasks );
    DESTROY_ARRAY( arrImageNames );

    // final check-up ...
    if ( ( 0 == dwCount ) &&
         ( ( 0 == dwTasksToKill ) ||
           ( TRUE == m_bFiltersOptimized ) ||
           ( 0 != dwFilters ) ) )
    {
        dwExitCode = 0;
        ShowMessage( stdout, ERROR_NO_PROCESSES );      // no tasks were found
    }
    else
    {
        if ( 0 != dwTasksToKill )
        {
            // some processes which are requested to kill are not found
            LPCWSTR pwszTemp = NULL;
            for( DWORD dw = 0; dw < dwTasksToKill; dw++ )
            {
                // get the task name
                pwszTemp = DynArrayItemAsString( m_arrTasksToKill, dw );
                if ( NULL == pwszTemp )
                {
                    continue;                   // skip
                }
                try
                {
                    // prepare and display message ...
                    str.Format( ERROR_PROCESS_NOTFOUND, pwszTemp );
                    ShowMessage( stderr, str );
                }
                catch( CHeap_Exception )
                {
                    SetLastError( ( DWORD )E_OUTOFMEMORY );
                    return 255;
                }
            }

            // exit code
            dwExitCode = 128;
        }
    }
    // return
    return TRUE;
}


inline BOOL
CTaskKill::Kill(
    void
    )
/*++
Routine Description:
      Invokes the appropriate kill function based on the mode of termination

Arguments:
      NONE

Return Value:
      TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    BOOL bResult = FALSE;

    // check whether task can be terminated or not
    if ( FALSE == CanTerminate() )
    {
        return FALSE;
    }

    // check whether local system / remote system
    if ( TRUE == m_bLocalSystem )
    {
        //
        // process termination on local system

        // based on the mode of termination invoke appropriate method
        if ( FALSE == m_bForce )
        {
            bResult = KillProcessOnLocalSystem();
        }
        else
        {
            bResult = ForciblyKillProcessOnLocalSystem();
        }
    }
    else
    {
        //
        // process termination on remote system

        // silent termination of the process on a remote system is not supported
        // it will be always forcible termination
        bResult = ForciblyKillProcessOnRemoteSystem();
    }

    // inform the result
    return bResult;
}


BOOL
CTaskKill::KillProcessOnLocalSystem(
    void
    )
/*++
Routine Description:
      Terminates the process in silence mode ... by posting WM_CLOSE message
      this is for local system only

Arguments:
      NONE

Return Value:
      TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    HDESK hDesk = NULL;
    HDESK hdeskSave = NULL;
    HWINSTA hWinSta = NULL;
    HWINSTA hwinstaSave = NULL;
    HANDLE hProcess = NULL;
    BOOL   bReturn = FALSE; 

    // variables which contains data
    HWND hWnd = NULL;
    LPCWSTR pwszDesktop = NULL;
    LPCWSTR pwszWindowStation = NULL;

    // clear the reason
    SetReason( NULL_STRING );

    // Get process handle for termination.
    // This is done so as to know whether the logged user has
    // adequate permissions to kill the process.
    hProcess = OpenProcess( PROCESS_TERMINATE, FALSE, m_dwProcessId );
    if( NULL == hProcess )
    {   // Current user don't have permissions to kill the process.
        SaveLastError();
        return bReturn;
    }
    // close the handle to the process
    // Current user can kill the process.
    CloseHandle( hProcess );    
    hProcess = NULL; 
    // get the window station and desktop information
    hWnd = ( HWND ) DynArrayItemAsHandle( m_arrRecord, TASK_HWND );
    pwszDesktop = DynArrayItemAsString( m_arrRecord, TASK_DESK );
    pwszWindowStation = DynArrayItemAsString( m_arrRecord, TASK_WINSTA );

    // check whether window window handle exists for this process or not if not, return
    if ( hWnd == NULL )
    {
        SetLastError( ( DWORD )CO_E_NOT_SUPPORTED );
        SetReason( ERROR_CANNOT_KILL_SILENTLY );
        return bReturn;
    }

    // get and save the current window station and desktop
    hwinstaSave = GetProcessWindowStation();
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    // open current tasks window station and change the context to the new workstation
    if ( NULL != pwszWindowStation )
    {
        //
        // process has window station ... get it
        hWinSta = OpenWindowStation( pwszWindowStation,
            FALSE, WINSTA_ENUMERATE | WINSTA_ENUMDESKTOPS );
        if ( NULL == hWinSta )
        {
            // failed in getting the process window station
            SaveLastError();
            return FALSE; 
        }
        else
        {
            // change the context to the new workstation
            if ( ( hWinSta != hwinstaSave ) && ( FALSE == SetProcessWindowStation( hWinSta ) ) )
            {
                // failed in changing the context
                // restore the context to the previous window station
                CloseWindowStation( hWinSta );
                SaveLastError();
                return FALSE;
            }
        }
    }

    // open the tasks desktop and change the context to the new desktop
    if ( NULL != pwszDesktop )
    {
        //
        // process has desktop ... get it
        hDesk = OpenDesktop( pwszDesktop, 0, FALSE, DESKTOP_ENUMERATE );
        if ( NULL == hDesk )
        {
            // failed in getting the process desktop
            // restore the context to the previous window station
            if ( ( NULL != hWinSta ) && ( hWinSta != hwinstaSave ) )
            {
                SetProcessWindowStation( hwinstaSave );
                CloseWindowStation( hWinSta );
            }
            SaveLastError();
            return FALSE;
        }
        else
        {
            // change the context to the new desktop
            if ( ( hDesk != hdeskSave ) && ( FALSE == SetThreadDesktop( hDesk ) ) )
            {
                // failed in changing the context
                // restore the context to the previous window station
                CloseDesktop( hDesk );
                if ( ( NULL != hWinSta ) && ( hWinSta != hwinstaSave ) )
                {
                    SetProcessWindowStation( hwinstaSave );
                    CloseWindowStation( hWinSta );
                }
                SaveLastError();
                return FALSE;
            }
        }
    }

    // atlast ... now kill the process
    if ( ( NULL != hWnd ) && ( PostMessage( hWnd, WM_CLOSE, 0, 0 ) == FALSE ) )
    {
        // failed in posting the message
        SaveLastError();
    }
    else
    {
        bReturn = TRUE;
    }

    // restore the previous desktop
    if ( ( NULL != hDesk ) && ( hDesk != hdeskSave ) )
    {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hDesk );
    }

    // restore the context to the previous window station
    if ( ( NULL != hWinSta ) && ( hWinSta != hwinstaSave ) )
    {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hWinSta );
    }

    // inform success
    return bReturn;
}


BOOL
CTaskKill::ForciblyKillProcessOnLocalSystem(
    void
    )
/*++
Routine Description:
      Terminates the process forcibly ... this is for local system only

Arguments:
      NONE

Return Value:
      TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    DWORD dwExitCode = 0;
    HANDLE hProcess = NULL;

    // get the handle to the process using the process id
    hProcess = OpenProcess(
        PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessId );

    // check whether we got the handle successfully or not ... if not error
    if ( NULL == hProcess )
    {
        // failed in getting the process handle ... may be process might have finished
        // there is one occassion in which, we get the last error as invalid parameter
        // 'coz it doesn't convey proper message to the user, we will check for that error
        // and change the message appropriately
        if ( GetLastError() == ERROR_INVALID_PARAMETER )
        {
            SetLastError( ( DWORD )CO_E_NOT_SUPPORTED );
        }
        // save the error message
        SaveLastError();

        // return failure
        return FALSE;
    }

    // get the state of the process
    if ( FALSE == GetExitCodeProcess( hProcess, &dwExitCode ) )
    {
        // unknow error has occured ... failed
        CloseHandle( hProcess );            // close the process handle
        SaveLastError();
        return FALSE;
    }

    // now check whether the process is active or not
    if ( STILL_ACTIVE != dwExitCode )
    {
        // process is not active ... it is already terminated
        CloseHandle( hProcess );            // close the process handle
        SetLastError( ( DWORD )SCHED_E_TASK_NOT_RUNNING );
        SaveLastError();
        return FALSE;
    }

    // now forcibly try to terminate the process ( exit code will be 1 )
    if ( TerminateProcess( hProcess, 1 ) == FALSE )
    {
        // failed in terminating the process
        CloseHandle( hProcess );            // close the process handle

        // there is one occassion in which, we get the last error as invalid parameter
        // 'coz it doesn't convey proper message to the user, we will check for that error
        // and change the message appropriately
        if ( GetLastError() == ERROR_INVALID_PARAMETER )
        {
            SetLastError( ( DWORD )CO_E_NOT_SUPPORTED );
        }
        // save the error message
        SaveLastError();

        // return failure
        return FALSE;
    }

    // successfully terminated the process with exit code 1
    CloseHandle( hProcess );            // close the process handle
    return TRUE;                        // inform success
}


BOOL
CTaskKill::ForciblyKillProcessOnRemoteSystem(
    void
    )
/*++
Routine Description:
     Terminates the process forcibly ... uses WMI for terminating
     this is for remote system

Arguments:
      NONE

Return Value:
      TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varTemp;
    BOOL bResult = FALSE;
    LPCWSTR pwszPath = NULL;
    IWbemClassObject* pInParams = NULL;
    IWbemClassObject* pOutParams = NULL;
    IWbemCallResult* pCallResult = NULL;

    // get the object path
    pwszPath = DynArrayItemAsString( m_arrRecord, TASK_OBJPATH );
    if ( NULL == pwszPath )
    {
        SetLastError( ( DWORD )STG_E_UNKNOWN );
        SaveLastError();
        return FALSE;
    }

    try
    {
        // create an instance for input parameters
        SAFE_EXECUTE( m_pWbemTerminateInParams->SpawnInstance( 0, &pInParams ) );

        // set the reason ( abnormal termination )
        varTemp = 1L;
        SAFE_EXECUTE( PropertyPut( pInParams, TERMINATE_INPARAM_REASON, varTemp ) );

        // now execute the method ( semi-synchronous call )
        SAFE_EXECUTE( m_pWbemServices->ExecMethod(
            _bstr_t( pwszPath ), _bstr_t( WIN32_PROCESS_METHOD_TERMINATE ),
            WBEM_FLAG_RETURN_IMMEDIATELY, NULL, pInParams, NULL, &pCallResult ) );

        // set security info to the interface
        SAFE_EXECUTE( SetInterfaceSecurity( pCallResult, m_pAuthIdentity ) );

        // keep on retring until we get the control or tries reached max
        LONG lStatus = 0;
        for ( DWORD dw = 0; dw < MAX_TIMEOUT_RETRIES; dw++ )
        {
            // get the call status
            hr = pCallResult->GetCallStatus( 0, &lStatus );
            if ( SUCCEEDED( hr ) )
            {
                break;
            }
            else
            {
                if ( hr == (HRESULT) WBEM_S_TIMEDOUT )
                {
                    continue;
                }
                else
                {
                    _com_issue_error( hr );
                }
            }
        }

        // check if time out max. retries finished
        if ( MAX_TIMEOUT_RETRIES == dw )
        {
            _com_issue_error( hr );
        }
        // now get the result object
        SAFE_EXECUTE( pCallResult->GetResultObject( MAX_TERMINATE_TIMEOUT, &pOutParams ) );

        // get the return value of the result object
        DWORD dwReturnValue = 0;
        if ( PropertyGet( pOutParams, WMI_RETURNVALUE, dwReturnValue ) == FALSE )
        {
            _com_issue_error( ERROR_INTERNAL_ERROR );
        }
        // now check the return value
        // if should be zero .. if not .. failed
        if ( 0 != dwReturnValue )
        {
            //
            // format the message and set the reason

            // frame the error error message depending on the error
            if ( 2 == dwReturnValue )
            {
                SetLastError( ( DWORD )STG_E_ACCESSDENIED );
                SaveLastError();
            }
            else
            {
                if ( 3 == dwReturnValue )
                {
                    SetLastError( ( DWORD )ERROR_DS_INSUFF_ACCESS_RIGHTS );
                    SaveLastError();
                }
                else
                {
                    CHString str;
                    str.Format( ERROR_UNABLE_TO_TERMINATE, dwReturnValue );
                    SetReason( str );
                }
            }
        }
        else
        {
            // everything went successfully ... process terminated successfully
            bResult = TRUE;
        }
    }
    catch( _com_error& e )
    {
        // save the error message and mark as failure
        WMISaveError( e );
        bResult = FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( E_OUTOFMEMORY );
        bResult = FALSE;
    }

    // release the in and out params references
    SAFE_RELEASE( pInParams );
    SAFE_RELEASE( pOutParams );
    SAFE_RELEASE( pCallResult );

    // return the result
    return bResult;
}


LONG
CTaskKill::MatchTaskToKill(
    OUT DWORD& dwMatchedIndex
    )
/*++
Routine Description:
    Matches a task to kill.

Arguments:
      [ out ] dwMatchedIndex   : Process Id that needs to be killed.

Return Value:
    If found task to delete then index value from dynamic array
    is returned else -1 is returned.
--*/
{
    // local variables
    LONG lCount = 0;
    DWORD dwLength = 0;
    LPCWSTR pwsz = NULL;
    LPCWSTR pwszTask = NULL;

    // check if this task has to be killed or not
    lCount = DynArrayGetCount( m_arrTasksToKill );
    for( LONG lIndex = 0; lIndex < lCount; lIndex++ )
    {
        // get the task specified
        pwszTask = DynArrayItemAsString( m_arrTasksToKill, lIndex );
        if ( NULL == pwszTask )
        {
            return -1;
        }
        // check with process id first ( only if task is in numeric format )
        dwMatchedIndex = TASK_PID;
        if ( IsNumeric(pwszTask, 10, FALSE) && (m_dwProcessId == (DWORD) AsLong(pwszTask, 10)) )
        {
            return lIndex;      // specified task matched with current process id
        }
        // determine the no. of characters to compare
        dwLength = 0;
        pwsz = FindChar( pwszTask, L'*', 0 );
        if ( NULL != pwsz )
        {
            // '*' - wildcard is specified in the image name
            // so, determine the no. of characters to compare
            // but before that check the length of the string pointer from '*'
            // it should be 1 - meaning the '*' can be specified only at the end
            // but not in the middle
            if ( 1 == StringLength( pwsz, 0 ) )
            {
                dwLength = StringLength( pwszTask, 0 ) - StringLength( pwsz, 0 );
            }
        }

        // check with image name
        dwMatchedIndex = TASK_IMAGENAME;
        if ( StringCompare( m_strImageName, pwszTask, TRUE, dwLength ) == 0 )
        {
            return lIndex;      // specified task mathed with the image name
        }
    }

    // return the index
    return -1;
}


BOOL
CTaskKill::CanTerminate(
    void
    )
/*++
Routine Description:
      Invokes the appropriate kill function based on the mode of termination

Arguments:
    NONE

Return Value:
      TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwCount = 0;
    LPCWSTR pwszTaskToTerminate = NULL;

    //
    // prepare a list of os critical tasks
    LPCWSTR pwszTasks[] = {
        PROCESS_CSRSS_EXE,
        PROCESS_SMSS_EXE,
        PROCESS_SERVICES_EXE,
        PROCESS_WINLOGON_EXE
    };

    // process id with 0 cannot be terminated
    if ( 0 == m_dwProcessId )
    {
        SetReason( ERROR_CRITICAL_SYSTEM_PROCESS );
        return FALSE;       // task should not be terminated
    }

    // the process cannot be terminated itself
    if ( m_dwProcessId == m_dwCurrentPid )
    {
        SetReason( ERROR_CANNOT_KILL_ITSELF );
        return FALSE;
    }

    // get the task name which user is trying to terminate
    pwszTaskToTerminate = DynArrayItemAsString( m_arrRecord, TASK_IMAGENAME );
    if ( NULL == pwszTaskToTerminate )
    {
        SetLastError( ( DWORD )STG_E_UNKNOWN );
        SaveLastError();
        return FALSE;       // task should not be terminated
    }

    // check if user is trying to terminate the os critical task
    dwCount = SIZE_OF_ARRAY( pwszTasks );
    for( dw = 0; dw < dwCount; dw++ )
    {
        if ( StringCompare( pwszTasks[ dw ], pwszTaskToTerminate, TRUE, 0 ) == 0 )
        {
            SetReason( ERROR_CRITICAL_SYSTEM_PROCESS );
            return FALSE;       // task should not be terminated
        }
    }

    // task can be terminated
    return TRUE;
}


VOID
CTaskKill::SaveData(
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
      Saves process and its information.

Arguments:
    IN pWmiObject : Interface pointer.

Return Value:
      VOID
--*/
{
    // local variables
    CHString str;
    DWORD dwValue = 0;

    try
    {
        // process id
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_PROCESSID, m_dwProcessId );
        DynArraySetDWORD( m_arrRecord, TASK_PID, m_dwProcessId );

        // image name
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_IMAGENAME, m_strImageName );
        DynArraySetString( m_arrRecord, TASK_IMAGENAME, m_strImageName, 0 );

        // object path
        PropertyGet( pWmiObject, WIN32_PROCESS_SYSPROPERTY_PATH, str );
        DynArraySetString( m_arrRecord, TASK_OBJPATH, str, 0 );

        // host name
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_COMPUTER, str );
        DynArraySetString( m_arrRecord, TASK_HOSTNAME, str, 0 );

        // parent process id
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_PARENTPROCESSID, dwValue, 0 );
        DynArraySetDWORD( m_arrRecord, TASK_CREATINGPROCESSID, dwValue );

        // user context
        SetUserContext( pWmiObject );

        // cpu time
        SetCPUTime( pWmiObject );

        // window title and application / process state
        SetWindowTitle( );

        // services
        SetServicesInfo( );

        // modules
        SetModulesInfo( );

        // check if the tree termination is requested
        if ( TRUE == m_bTree )
        {
            // session id
            PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_SESSION, dwValue,  0 );
            DynArraySetDWORD( m_arrRecord, TASK_SESSION, dwValue );

            // mem usage
            SetMemUsage( pWmiObject );
        }
        else
        {
            //
            // status, session id, memory usage
            // property retrieval is built into WMI
            //
        }
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }
}


VOID
CTaskKill::SetUserContext(
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
    Store username property of a process in dynaimc array.

Arguments:
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
    VOID
--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString str;
    CHString strPath;
    CHString strDomain;
    CHString strUserName;
    BOOL bResult = FALSE;
    IWbemClassObject* pOutParams = NULL;

    // check if user name has to be retrieved or not
    if ( FALSE == m_bNeedUserContextInfo )
    {
        return;
    }

    try
    {
        //
        // for getting the user first we will try with API
        // it at all API fails, we will try to get the same information from WMI
        //

        // get the user name
        if ( LoadUserNameFromWinsta( strDomain, strUserName ) == TRUE )
        {
            // format the user name
            str.Format( L"%s\\%s", strDomain, strUserName );
        }
        else
        {
            // user name has to be retrieved - get the path of the current object
            bResult = PropertyGet( pWmiObject, WIN32_PROCESS_SYSPROPERTY_PATH, strPath );
            if ( ( FALSE == bResult ) || ( strPath.GetLength() == 0 ) )
            {
                return;
            }
            // execute the GetOwner method and get the user name
            // under which the current process is executing
            hr = m_pWbemServices->ExecMethod( _bstr_t( strPath ),
                _bstr_t( WIN32_PROCESS_METHOD_GETOWNER ), 0, NULL, NULL, &pOutParams, NULL );
            if ( FAILED( hr ) )
            {
                SAFE_RELEASE( pOutParams );
                return;
            }
            // get the domain and user values from out params object
            // NOTE: do not check the results
            PropertyGet( pOutParams, GETOWNER_RETURNVALUE_DOMAIN, strDomain, L"" );
            PropertyGet( pOutParams, GETOWNER_RETURNVALUE_USER, strUserName, L"" );

            // 'pOutParams' is no more required.
            SAFE_RELEASE( pOutParams );
            // get the value
            if ( strDomain.GetLength() != 0 )
            {
                str.Format( L"%s\\%s", strDomain, strUserName );
            }
            else
            {
                if ( strUserName.GetLength() != 0 )
                {
                    str = strUserName;
                }
            }
        }
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD ) E_OUTOFMEMORY );
        return;
    }

    // save the info
    DynArraySetString( m_arrRecord, TASK_USERNAME, str, 0 );
}


VOID
CTaskKill::SetCPUTime(
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
    Store CPUTIME property of a process in dynaimc array.

Arguments:
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
    VOID
--*/
{
    // local variables
    CHString str;
    ULONGLONG ullCPUTime = 0;
    ULONGLONG ullUserTime = 0;
    ULONGLONG ullKernelTime = 0;

    try
    {
        // get the KernelModeTime value
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_KERNELMODETIME, ullKernelTime );

        // get the user mode time
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_USERMODETIME, ullUserTime );

        // calculate the CPU time
        ullCPUTime = ullUserTime + ullKernelTime;

        // now convert the long time into hours format
        TIME_FIELDS time;
        RtlTimeToElapsedTimeFields ( (LARGE_INTEGER* ) &ullCPUTime, &time );

        // convert the days into hours
        time.Hour = static_cast<CSHORT>( time.Hour + static_cast<SHORT>( time.Day * 24 ) );

        // prepare into time format ( user locale specific time seperator )
        str.Format( L"%d:%02d:%02d", time.Hour, time.Minute, time.Second );

        // save the info
        DynArraySetString( m_arrRecord, TASK_CPUTIME, str, 0 );
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }
}


VOID
CTaskKill::SetWindowTitle(
    void
    )
/*++
Routine Description:
    Store 'Window Title' property of a process in dynaimc array.

Arguments:
    NONE

Return Value:
    VOID
--*/
{
    // local variables
    LONG lTemp = 0;
    HWND hWnd = NULL;
    BOOL bHung = FALSE;
    LPCTSTR pszTemp = NULL;

    // get the window details ... window station, desktop, window title
    // NOTE: This will work only for local system
    DynArraySetString( m_arrRecord, TASK_STATUS, VALUE_UNKNOWN, 0 );
    lTemp = DynArrayFindDWORDEx( m_arrWindowTitles, CTaskKill::twiProcessId, m_dwProcessId );
    if ( -1 != lTemp )
    {
        // save the window title
        pszTemp = DynArrayItemAsString2( m_arrWindowTitles, lTemp, CTaskKill::twiTitle );
        if ( NULL != pszTemp )
        {
            DynArraySetString( m_arrRecord, TASK_WINDOWTITLE, pszTemp, 0 );
        }

        // save the window station
        pszTemp = DynArrayItemAsString2( m_arrWindowTitles, lTemp, CTaskKill::twiWinSta );
        if ( NULL != pszTemp )
        {
            DynArraySetString( m_arrRecord, TASK_WINSTA, pszTemp, 0 );
        }

        // save the desktop information
        pszTemp = DynArrayItemAsString2( m_arrWindowTitles, lTemp, CTaskKill::twiDesktop );
        if ( NULL != pszTemp )
        {
            DynArraySetString( m_arrRecord, TASK_DESK, pszTemp, 0 );
        }

        // save the window handle also
        hWnd = (HWND) DynArrayItemAsHandle2( m_arrWindowTitles, lTemp, CTaskKill::twiHandle );
        if ( NULL != hWnd )
        {
            DynArraySetHandle( m_arrRecord, TASK_HWND, hWnd );

            // determine the application / process hung information
            bHung = DynArrayItemAsBOOL2( m_arrWindowTitles, lTemp, CTaskKill::twiHungInfo );
            if ( TRUE == bHung )
            {
                // not responding
                DynArraySetString( m_arrRecord, TASK_STATUS, VALUE_NOTRESPONDING, 0 );
            }
            else
            {
                // running
                DynArraySetString( m_arrRecord, TASK_STATUS, VALUE_RUNNING, 0 );
            }
        }
    }
}



VOID
CTaskKill::SetMemUsage(
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
    Store 'Memory usage' property of a process in dynaimc array.

Arguments:
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
    VOID
--*/
{
    // local variables
    CHString str;
    NTSTATUS ntstatus;
    ULONGLONG ullMemUsage = 0;
    LARGE_INTEGER liTemp = { 0, 0 };
    CHAR szTempBuffer[ 33 ] = "\0";

    try
    {
        // NOTE:
        // ----
        // The max. value of
        // (2 ^ 64) - 1 = "18,446,744,073,709,600,000 K"  (29 chars).
        //
        // so, the buffer size to store the number is fixed as 32 characters
        // which is more than the 29 characters in actuals

        // set the default value
        DynArraySetString( m_arrRecord, TASK_MEMUSAGE, L"0", 0 );

        // get the KernelModeTime value
        if ( PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_MEMUSAGE, ullMemUsage ) == FALSE )
        {
            return;
        }
        // convert the value into K Bytes
        ullMemUsage /= 1024;

        // now again convert the value from ULONGLONG to string and check the result
        liTemp.QuadPart = ullMemUsage;
        ntstatus = RtlLargeIntegerToChar( &liTemp, 10, SIZE_OF_ARRAY( szTempBuffer ), szTempBuffer );
        if ( ! NT_SUCCESS( ntstatus ) )
        {
            return;
        }
        // now copy this info into UNICODE buffer
        str = szTempBuffer;

        // save the id
        DynArraySetString( m_arrRecord, TASK_MEMUSAGE, str, 0 );
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }
}


VOID
CTaskKill::SetServicesInfo(
    void
    )
/*++
Routine Description:
    Store 'Service' property of a process in dynaimc array.

Arguments:
    NONE

Return Value:
    VOID
--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString strQuery;
    CHString strService;
    ULONG ulReturned = 0;
    BOOL bResult = FALSE;
    BOOL bCanExit = FALSE;
    TARRAY arrServices = NULL;
    IEnumWbemClassObject* pEnumServices = NULL;
    IWbemClassObject* pObjects[ MAX_ENUM_SERVICES ];

    // check whether we need to gather services info or not .. if not skip
    if ( FALSE == m_bNeedServicesInfo )
    {
        return;
    }
    // create array
    arrServices = CreateDynamicArray();
    if ( NULL == arrServices )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return;
    }

    //
    // for getting the services info first we will try with the one we got from API
    // it at all API fails, we will try to get the same information from WMI
    //
    try
    {
        // check whether API returned services or not
        if ( NULL != m_pServicesInfo )
        {
            // get the service names related to the current process
            // identify all the services related to the current process ( based on the PID )
            // and save the info
            for ( DWORD dw = 0; dw < m_dwServicesCount; dw++ )
            {
                // compare the PID's
                if ( m_dwProcessId == m_pServicesInfo[ dw ].ServiceStatusProcess.dwProcessId )
                {
                    // this service is related with the current process ... store service name
                    DynArrayAppendString( arrServices, m_pServicesInfo[ dw ].lpServiceName, 0 );
                }
            }
        }
        else
        {
            try
            {
                // init the objects to NULL's
                for( DWORD dw = 0; dw < MAX_ENUM_SERVICES; dw++ )
                {
                    pObjects[ dw ] = NULL;
                }
                // prepare the query
                strQuery.Format( WMI_SERVICE_QUERY, m_dwProcessId );

                // execute the query
                hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( strQuery ),
                    WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumServices );

                // check the result
                if ( FAILED( hr ) )
                {
                    _com_issue_error( hr );
                }
                // set the security
                hr = SetInterfaceSecurity( pEnumServices, m_pAuthIdentity );
                if ( FAILED( hr ) )
                {
                    _com_issue_error( hr );
                }
                // loop thru the service instances
                do
                {
                    // get the object ... wait
                    // NOTE: one-by-one
                    hr = pEnumServices->Next( WBEM_INFINITE, MAX_ENUM_SERVICES, pObjects, &ulReturned );
                    if ( hr == (HRESULT) WBEM_S_FALSE )
                    {
                        // we've reached the end of enumeration .. set the flag
                        bCanExit = TRUE;
                    }
                    else
                    {
                        if ( hr == (HRESULT) WBEM_S_TIMEDOUT || FAILED( hr ) )
                        {
                            //
                            // some error has occured ... oooppps

                            // exit from the loop
                            break;
                        }
                    }
                    // loop thru the objects and save the info
                    for( ULONG ul = 0; ul < ulReturned; ul++ )
                    {
                        // get the value of the property
                        bResult = PropertyGet( pObjects[ ul ], WIN32_SERVICE_PROPERTY_NAME, strService );
                        if ( TRUE == bResult )
                        {
                            DynArrayAppendString( arrServices, strService, 0 );
                        }
                        // release the interface
                        SAFE_RELEASE( pObjects[ ul ] );
                    }
                } while ( bCanExit == FALSE );
            }
            catch( _com_error& e )
            {
                // save the error
                WMISaveError( e );
            }
        }

        // save and return
        DynArraySetEx( m_arrRecord, TASK_SERVICES, arrServices );
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }

    // release the objects to NULL's
    for( DWORD dw = 0; dw < MAX_ENUM_SERVICES; dw++ )
    {
        // release all the objects
        SAFE_RELEASE( pObjects[ dw ] );
    }

    // now release the enumeration object
    SAFE_RELEASE( pEnumServices );

}


BOOL
CTaskKill::SetModulesInfo(
    void
    )
/*++
Routine Description:
    Store 'Modules' property of a process in dynaimc array.

Arguments:
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    LONG lPos = 0;
    BOOL bResult = FALSE;
    TARRAY arrModules = NULL;

    // check whether we need to get the modules or not
    if ( FALSE == m_bNeedModulesInfo )
    {
        return TRUE;
    }
    // allocate for memory
    arrModules = CreateDynamicArray();
    if ( NULL == arrModules )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // the way we get the modules information is different for local remote
    // so depending that call appropriate function
    if ( ( TRUE == m_bLocalSystem ) && ( FALSE == m_bUseRemote ) )
    {
        // enumerate the modules for the current process
        bResult = LoadModulesOnLocal( arrModules );
    }
    else
    {
        // identify the modules information for the current process ... remote system
        bResult = GetModulesOnRemote( arrModules );
    }

    // check the result
    if ( TRUE == bResult )
    {
        // check if the modules list contains the imagename also. If yes remove that entry
        lPos = DynArrayFindString( arrModules, m_strImageName, TRUE, 0 );
        if ( -1 != lPos )
        {
            // remove the entry
            DynArrayRemove( arrModules, lPos );
        }
    }

    // save the modules information to the array
    // NOTE: irrespective of whether enumeration is success or not we will add the array
    DynArraySetEx( m_arrRecord, TASK_MODULES, arrModules );

    // return
    return bResult;
}


BOOL
CTaskKill::LoadModulesOnLocal(
    IN OUT TARRAY arrModules
    )
/*++
Routine Description:
    Store 'Modules' property of a process in dynaimc array for local system.

Arguments:
    [ in out ] arrModules : Contains dynamic array.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    BOOL bResult = FALSE;
    HANDLE hProcess = NULL;

    // check the input values
    if ( NULL == arrModules )
    {
        return FALSE;
    }
    // open the process handle
    hProcess = OpenProcess( PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessId );
    if ( NULL == hProcess )
    {
        return FALSE;                               // failed in getting the process handle
    }

#ifndef _WIN64
    bResult = EnumerateLoadedModules( hProcess, EnumLoadedModulesProc, arrModules );
#else
    bResult = EnumerateLoadedModules64( hProcess, EnumLoadedModulesProc64, arrModules );
#endif

    // close the process handle .. we dont need this furthur
    CloseHandle( hProcess );
    hProcess = NULL;

    // return
    return bResult;
}


BOOL
CTaskKill::GetModulesOnRemote(
    IN OUT TARRAY arrModules
    )
/*++
Routine Description:
    Store 'Modules' property of a process in dynaimc array for remote system.

Arguments:
    [ in out ] arrModules : Contains dynamic array.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    DWORD dwOffset = 0;
    DWORD dwInstance = 0;
    PPERF_OBJECT_TYPE pot = NULL;
    PPERF_OBJECT_TYPE potImages = NULL;
    PPERF_INSTANCE_DEFINITION pidImages = NULL;
    PPERF_COUNTER_BLOCK pcbImages = NULL;
    PPERF_OBJECT_TYPE potAddressSpace = NULL;
    PPERF_INSTANCE_DEFINITION pidAddressSpace = NULL;
    PPERF_COUNTER_BLOCK pcbAddressSpace = NULL;
    PPERF_COUNTER_DEFINITION pcd = NULL;

    // check the input values
    if ( NULL == arrModules )
    {
        return FALSE;
    }
    // check whether the performance object exists or not
    // if doesn't exists, get the same using WMI
    if ( NULL == m_pdb )
    {
        // invoke the WMI method
        return GetModulesOnRemoteEx( arrModules );
    }

    // get the perf object types
    pot = (PPERF_OBJECT_TYPE) ( (LPBYTE) m_pdb + m_pdb->HeaderLength );
    for( DWORD dw = 0; dw < m_pdb->NumObjectTypes; dw++ )
    {
        if ( 740 == pot->ObjectNameTitleIndex )
        {
            potImages = pot;
        }
        else
        {
            if ( 786 == pot->ObjectNameTitleIndex )
            {
                potAddressSpace = pot;
            }
        }
        // move to the next object
        dwOffset = pot->TotalByteLength;
        if( 0 != dwOffset )
        {
            pot = ( (PPERF_OBJECT_TYPE) ((PBYTE) pot + dwOffset));
        }
    }

    // check whether we got both the object types or not
    if ( ( NULL == potImages ) || ( NULL == potAddressSpace ) )
    {
        return FALSE;
    }
    // find the offset of the process id in the address space object type
    // get the first counter definition of address space object
    pcd = (PPERF_COUNTER_DEFINITION) ( (LPBYTE) potAddressSpace + potAddressSpace->HeaderLength);

    // loop thru the counters and find the offset
    dwOffset = 0;
    for( DWORD dw = 0; dw < potAddressSpace->NumCounters; dw++)
    {
        // 784 is the counter for process id
        if ( 784 == pcd->CounterNameTitleIndex )
        {
            dwOffset = pcd->CounterOffset;
            break;
        }

        // next counter
        pcd = ( (PPERF_COUNTER_DEFINITION) ( (LPBYTE) pcd + pcd->ByteLength) );
    }

    // check whether we got the offset or not
    // if not, we are unsuccessful
    if ( 0 == dwOffset )
    {
        // set the error message
        SetLastError( ( DWORD )ERROR_ACCESS_DENIED );
        SaveLastError();
        return FALSE;
    }

    // get the instances
    pidImages = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) potImages + potImages->DefinitionLength );
    pidAddressSpace = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) potAddressSpace + potAddressSpace->DefinitionLength );

    // counter blocks
    pcbImages = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidImages + pidImages->ByteLength );
    pcbAddressSpace = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidAddressSpace + pidAddressSpace->ByteLength );

    // find the instance number of the process which we are looking for
    for( dwInstance = 0; dwInstance < (DWORD) potAddressSpace->NumInstances; dwInstance++ )
    {
        // sub-local variables
        DWORD dwProcessId = 0;

        // get the process id
        dwProcessId = *((DWORD*) ( (LPBYTE) pcbAddressSpace + dwOffset ));

        // now check if this is the process which we are looking for
        if ( dwProcessId == m_dwProcessId )
        {
            break;
        }
        // continue looping thru other instances
        pidAddressSpace = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) pcbAddressSpace + pcbAddressSpace->ByteLength );
        pcbAddressSpace = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidAddressSpace + pidAddressSpace->ByteLength );
    }

    // check whether we got the instance or not
    // if not, there are no modules for this process
    if ( dwInstance == ( DWORD )potAddressSpace->NumInstances )
    {
        return TRUE;
    }
    // now based the parent instance, collect all the modules
    for( DWORD dw = 0; (LONG) dw < potImages->NumInstances; dw++)
    {
        // check the parent object instance number
        if ( pidImages->ParentObjectInstance == dwInstance )
        {
            try
            {
                // sub-local variables
                CHString str;
                LPWSTR pwszTemp;

                // get the buffer
                pwszTemp = str.GetBufferSetLength( pidImages->NameLength + 10 );        // +10 to be on safe side
                if ( NULL == pwszTemp )
                {
                    SetLastError( ( DWORD )E_OUTOFMEMORY );
                    SaveLastError();
                    return FALSE;
                }

                // get the instance name
                StringCopy( pwszTemp,
                            (LPWSTR) ( (LPBYTE) pidImages + pidImages->NameOffset ),
                            pidImages->NameLength + 1 );

                // release buffer
                str.ReleaseBuffer();

                // add the info the userdata ( for us we will get that in the form of an array
                LONG lIndex = DynArrayAppendString( arrModules, str, 0 );
                if ( -1 == lIndex )
                {
                    // append is failed .. this could be because of lack of memory .. stop the enumeration
                    return FALSE;
                }
            }
            catch( CHeap_Exception )
            {
                SetLastError( ( DWORD )E_OUTOFMEMORY );
                SaveLastError();
                return FALSE;
            }
        }

        // continue looping thru other instances
        pidImages = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) pcbImages + pcbImages->ByteLength );
        pcbImages = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidImages + pidImages->ByteLength );
    }

    return TRUE;
}


BOOL
CTaskKill::GetModulesOnRemoteEx(
    IN OUT TARRAY arrModules
    )
/*++
Routine Description:
    Store 'Modules' property of a process in dynaimc array for remote system.

Arguments:
    [ in out ] arrModules : Contains dynamic array.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    HRESULT hr;
    CHString strQuery;
    CHString strModule;
    CHString strFileName;
    CHString strExtension;
    ULONG ulReturned = 0;
    BOOL bRetValue = TRUE;
    BOOL bResult = FALSE;
    BOOL bCanExit = FALSE;
    LPCWSTR pwszPath = NULL;
    IEnumWbemClassObject* pEnumModules = NULL;
    IWbemClassObject* pObjects[ MAX_ENUM_MODULES ];

    // check the input values
    if ( NULL == arrModules )
    {
        return FALSE;
    }
    // get the path of the object from the tasks array
    pwszPath = DynArrayItemAsString( m_arrRecord, TASK_OBJPATH );
    if ( NULL == pwszPath )
    {
        return FALSE;
    }
    //determine the length of the module name ..
    try
    {
        // init the objects to NULL's
        for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
        {
            pObjects[ dw ] = NULL;
        }
        // prepare the query
        strQuery.Format( WMI_MODULES_QUERY, pwszPath );

        // execute the query
        hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( strQuery ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumModules );
        // check the result
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // set the security
        hr = SetInterfaceSecurity( pEnumModules, m_pAuthIdentity );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }
        // loop thru the instances
        do
        {
            // get the object ... wait
            // NOTE: one-by-one
            hr = pEnumModules->Next( WBEM_INFINITE, MAX_ENUM_MODULES, pObjects, &ulReturned );
            if ( (HRESULT) WBEM_S_FALSE == hr )
            {
                // we've reached the end of enumeration .. set the flag
                bCanExit = TRUE;
            }
            else
            {
                if ( ( (HRESULT) WBEM_S_TIMEDOUT == hr ) || FAILED( hr ))
                {
                    // some error has occured ... oooppps
                    WMISaveError( hr );
                    SetLastError( ( DWORD )STG_E_UNKNOWN );
                    break;
                }
            }
            // loop thru the objects and save the info
            for( ULONG ul = 0; ul < ulReturned; ul++ )
            {
                // get the file name
                bResult = PropertyGet( pObjects[ ul ], CIM_DATAFILE_PROPERTY_FILENAME, strFileName );
                if ( FALSE == bResult )
                {
                    // release the interface
                    SAFE_RELEASE( pObjects[ ul ] );
                    continue;
                }
                // get the extension
                bResult = PropertyGet( pObjects[ ul ], CIM_DATAFILE_PROPERTY_EXTENSION, strExtension );
                if ( FALSE == bResult )
                {
                    // release the interface
                    SAFE_RELEASE( pObjects[ ul ] );
                    continue;
                }

                // format the module name
                strModule.Format( L"%s.%s", strFileName, strExtension );

                // add the info the userdata ( for us we will get that in the form of an array
                LONG lIndex = DynArrayAppendString( arrModules, strModule, 0 );
                if ( lIndex == -1 )
                {
                    // append is failed .. this could be because of lack of memory .. stop the enumeration
                    // release the objects to NULL's
                    for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
                    {
                        // release all the objects
                        SAFE_RELEASE( pObjects[ dw ] );
                    }

                    // now release the enumeration object
                    SAFE_RELEASE( pEnumModules );

                    return FALSE;
                }

                // release the interface
                SAFE_RELEASE( pObjects[ ul ] );
            }
        } while ( bCanExit == FALSE );
    }
    catch( _com_error& e )
    {
        // save the error
        WMISaveError( e );
        bRetValue = FALSE;
    }
    catch( CHeap_Exception )
    {
        // out of memory
        WMISaveError( E_OUTOFMEMORY );
        bRetValue =  FALSE;
    }

    // release the objects to NULL's
    for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
    {
        // release all the objects
        SAFE_RELEASE( pObjects[ dw ] );
    }

    // now release the enumeration object
    SAFE_RELEASE( pEnumModules );

    // return
    return bRetValue;
}


#ifndef _WIN64
BOOL
EnumLoadedModulesProc(
    LPSTR lpszModuleName,
    ULONG ulModuleBase,
    ULONG ulModuleSize,
    PVOID pUserData
    )
#else
BOOL
EnumLoadedModulesProc64(
    LPSTR lpszModuleName,
    DWORD64 ulModuleBase,
    ULONG ulModuleSize,
    PVOID pUserData
    )
#endif
/*++
Routine Description:


Arguments:
    [ in ] lpszModuleName   : Contains module name.
    [ in out ] ulModuleBase :
    [ in ] ulModuleSize     :
    [ in ] pUserData        : Username information.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    CHString str;
    LONG lIndex = 0;
    TARRAY arrModules = NULL;

    // check the input values
    if ( ( NULL == lpszModuleName ) || ( NULL == pUserData ) )
    {
        return FALSE;
    }

    // get the array pointer into the local variable
    arrModules = (TARRAY) pUserData;

    try
    {
        // copy the module name into the local string variable
        // ( conversion from multibyte to unicode will automatically take place )
        str = lpszModuleName;

        // add the info the userdata ( for us we will get that in the form of an array
        lIndex = DynArrayAppendString( arrModules, str, 0 );
        if ( lIndex == -1 )
        {
            // append is failed .. this could be because of lack of memory .. stop the enumeration
            return FALSE;
        }
    }
    catch( CHeap_Exception )
    {
            // out of memory stop the enumeration
            return FALSE;
    }

    // success .. continue the enumeration
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\wmi.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      WMI.h
//
//  Abstract:
//
//      Common functionality for WMI
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )    \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \
    1

#define SAFE_EXECUTE( statement )               \
    hr = statement;     \
    if ( FAILED( hr ) ) \
    {   \
        _com_issue_error( hr ); \
    }   \
    1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2     L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT   L"root\\default"

#define WMI_CLAUSE_AND          L"AND"
#define WMI_CLAUSE_OR           L"OR"
#define WMI_CLAUSE_WHERE        L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem   L"Win32_OperatingSystem"
#define CLASS_CIMV2_Win32_ComputerSystem    L"Win32_ComputerSystem"

#define WMI_REGISTRY                    L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE      L"GetStringValue"
#define WMI_REGISTRY_M_DWORDVALUE       L"GetDwordValue"

#define WMI_REGISTRY_IN_HDEFKEY         L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY          L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME       L"sValueName"
#define WMI_REGISTRY_OUT_VALUE          L"sValue"
#define WMI_REGISTRY_OUT_VALUE_DWORD    L"uValue"
#define WMI_REGISTRY_OUT_RETURNVALUE    L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT               2147483648
#define WMI_HKEY_CURRENT_USER               2147483649
#define WMI_HKEY_LOCAL_MACHINE              2147483650
#define WMI_HKEY_USERS                      2147483651
#define WMI_HKEY_CURRENT_CONFIG             2147482652

#define PLATFORM_UNKNOWN                0
#define PLATFORM_X86                    1
#define PLATFORM_IA64                   2
#define PLATFORM_AMD64                  3

#define TEXT_X86                        L"X86"
#define TEXT_IA64                       L"IA64"
#define TEXT_AMD64                      L"AMD64"

// messages
// #define ERROR_COM_ERROR                  GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator,
                 IWbemServices** ppServices,
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword,
                 COAUTHIDENTITY** ppAuthIdentity,
                 BOOL bCheckWithNullPwd = FALSE,
                 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2,
                 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL, IWbemContext* pWbemContext = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator,
                   IWbemServices** ppServices,
                   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword,
                   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE,
                   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL,
                   DWORD dwPasswordLen = 0, IWbemContext* pWbemContext = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject,
                     LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,
                  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  BOOL& dwValue, BOOL bDefault = FALSE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
DWORD GetTargetPlatformEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey,
                       LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName,
                       CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices,
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName,
                       LPCWSTR pwszValueName, DWORD& dwValue, DWORD dwDefault = 0 );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, CHString& strValue,
                                VARTYPE vartype );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex,
                                IWbemClassObject **pScriptObject, VARTYPE vartype );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//
// Arguments:
//
// Return Value:
//
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
    WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\init.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      Init.cpp
//
//  Abstract:
//
//      This module implements the general initialization stuff
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Nov-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Nov-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "tasklist.h"

//
// macros
//
#define RELEASE_MEMORY( block ) \
    if ( NULL != (block) )  \
    {   \
        FreeMemory( (LPVOID * )&block ); \
        (block) = NULL; \
    }   \
    1

#define DESTROY_ARRAY( array )  \
    if ( (array) != NULL )  \
    {   \
        DestroyDynamicArray( &(array) );    \
        (array) = NULL; \
    }   \
    1

CTaskList::CTaskList()
/*++
Routine Description:
      CTaskList contructor

Arguments:
      NONE

Return Value:
      NONE
--*/
{
    // init to defaults
    m_pWbemLocator = NULL;
    m_pEnumObjects = NULL;
    m_pWbemServices = NULL;
    m_pAuthIdentity = NULL;
    m_bVerbose = FALSE;
    m_bAllServices = FALSE;
    m_bAllModules = FALSE;
    m_dwFormat = 0;
    m_arrFilters = NULL;
    m_bNeedPassword = FALSE;
    m_bNeedModulesInfo = FALSE;
    m_bNeedServicesInfo = FALSE;
    m_bNeedWindowTitles = FALSE;
    m_bNeedUserContextInfo = FALSE;
    m_bLocalSystem = FALSE;
    m_pColumns = NULL;
    m_arrFiltersEx = NULL;
    m_arrWindowTitles = NULL;
    m_pfilterConfigs = NULL;
    m_dwGroupSep = 0;
    m_arrTasks = NULL;
    m_dwProcessId = 0;
    m_bIsHydra = FALSE;
    m_hServer = NULL;
    m_hWinstaLib = NULL;
    m_pProcessInfo = NULL;
    m_ulNumberOfProcesses = 0;
    m_bCloseConnection = FALSE;
    m_dwServicesCount = 0;
    m_pServicesInfo = NULL;
    m_pdb = NULL;
    m_bUseRemote = FALSE;
    m_pfnWinStationFreeMemory = NULL;
    m_pfnWinStationOpenServerW = NULL;
    m_pfnWinStationCloseServer = NULL;
    m_pfnWinStationFreeGAPMemory = NULL;
    m_pfnWinStationGetAllProcesses = NULL;
    m_pfnWinStationNameFromLogonIdW = NULL;
    m_pfnWinStationEnumerateProcesses = NULL;
    m_bUsage = FALSE;
    m_bLocalSystem = TRUE;
    m_bRemoteWarning = FALSE;
}


CTaskList::~CTaskList()
/*++
Routine Description:
      CTaskList destructor

Arguments:
      NONE

Return Value:
      NONE
--*/
{
    //
    // de-allocate memory allocations
    //

    //
    // destroy dynamic arrays
    DESTROY_ARRAY( m_arrTasks );
    DESTROY_ARRAY( m_arrFilters );
    DESTROY_ARRAY( m_arrFiltersEx );
    DESTROY_ARRAY( m_arrWindowTitles );

    //
    // memory ( with new operator )
    // NOTE: should not free m_pszWindowStation and m_pszDesktop
    RELEASE_MEMORY( m_pColumns );
    RELEASE_MEMORY( m_pfilterConfigs );

    //
    // release WMI / COM interfaces
    SAFE_RELEASE( m_pWbemLocator );
    SAFE_RELEASE( m_pWbemServices );
    SAFE_RELEASE( m_pEnumObjects );

    // free authentication identity structure
    // release the existing auth identity structure
    WbemFreeAuthIdentity( &m_pAuthIdentity );

    // close the connection to the remote machine
    if ( TRUE == m_bCloseConnection )
    {
        CloseConnection( m_strUNCServer );
    }

    // free the memory allocated for services variables
    FreeMemory( (LPVOID * )&m_pServicesInfo );

    // free the memory allocated for performance block
    FreeMemory( (LPVOID * )&m_pdb );

    //
    // free winstation block
    if ( ( FALSE == m_bIsHydra ) &&
         ( NULL != m_pProcessInfo ) )
    {
        // free the GAP memory block
        WinStationFreeGAPMemory( GAP_LEVEL_BASIC,
            (PTS_ALL_PROCESSES_INFO) m_pProcessInfo, m_ulNumberOfProcesses );

        // ...
        m_pProcessInfo = NULL;
    }
    else
    {
        if ( ( TRUE == m_bIsHydra ) &&
             ( NULL != m_pProcessInfo ) )
        {
            // free the winsta memory block
            WinStationFreeMemory( m_pProcessInfo );
            m_pProcessInfo = NULL;
        }
    }
    // close the connection window station if needed
    if ( NULL != m_hServer )
    {
        WinStationCloseServer( m_hServer );
    }

    // free the library
    if ( NULL != m_hWinstaLib )
    {
        FreeLibrary( m_hWinstaLib );
        m_hWinstaLib = NULL;
        m_pfnWinStationFreeMemory = NULL;
        m_pfnWinStationOpenServerW = NULL;
        m_pfnWinStationCloseServer = NULL;
        m_pfnWinStationFreeGAPMemory = NULL;
        m_pfnWinStationGetAllProcesses = NULL;
        m_pfnWinStationEnumerateProcesses = NULL;
    }

    // un-initialize the COM library
    CoUninitialize();
}


BOOL
CTaskList::Initialize(
    void
    )
/*++
Routine Description:
      initialize the task list utility

Arguments:
      NONE

Return Value:
      TRUE    : if filters are appropriately specified
      FALSE   : if filters are errorneously specified
--*/
{
    // local variables
    CHString str;
    LONG lTemp = 0;

    //
    // memory allocations

    // if at all any occurs, we know that is 'coz of the
    // failure in memory allocation ... so set the error
    SetLastError( (DWORD)E_OUTOFMEMORY );
    SaveLastError();

    // filters ( user supplied )
    if ( NULL == m_arrFilters )
    {
        m_arrFilters = CreateDynamicArray();
        if ( NULL == m_arrFilters )
        {
            return FALSE;
        }
    }

    // filters ( program generated parsed filters )
    if ( NULL == m_arrFiltersEx )
    {
        m_arrFiltersEx = CreateDynamicArray();
        if ( NULL == m_arrFiltersEx )
        {
            return FALSE;
        }
    }

    // columns configuration info
    if ( NULL == m_pColumns )
    {
        m_pColumns = ( TCOLUMNS * )AllocateMemory( sizeof( TCOLUMNS ) * MAX_COLUMNS );
        if ( NULL == m_pColumns )
        {
            return FALSE;
        }
        // init to ZERO's
        SecureZeroMemory( m_pColumns, MAX_COLUMNS * sizeof( TCOLUMNS ) );
    }

    // filters configuration info
    if ( NULL == m_pfilterConfigs )
    {
        m_pfilterConfigs = ( TFILTERCONFIG * )AllocateMemory( sizeof( TFILTERCONFIG ) * MAX_FILTERS );
        if ( NULL == m_pfilterConfigs )
        {
            return FALSE;
        }
        // init to ZERO's
        SecureZeroMemory( m_pfilterConfigs, MAX_FILTERS * sizeof( TFILTERCONFIG ) );
    }

    // window titles
    if ( NULL == m_arrWindowTitles )
    {
        m_arrWindowTitles = CreateDynamicArray();
        if ( NULL == m_arrWindowTitles )
        {
            return FALSE;
        }
    }

    // tasks
    if ( NULL == m_arrTasks )
    {
        m_arrTasks = CreateDynamicArray();
        if ( NULL == m_arrTasks )
        {
            return FALSE;
        }
    }

    // initialize the COM library
    if ( FALSE == InitializeCom( &m_pWbemLocator ) )
    {
        return FALSE;
    }
    //
    // get the locale specific information
    //

    try
    {
        // sub-local variables
        LPWSTR pwszTemp = NULL;

        //
        // get the time seperator character
        lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, NULL, 0 );
        if ( 0 == lTemp )
        {
            // set the default seperator
            pwszTemp = m_strTimeSep.GetBufferSetLength( 2 );
            SecureZeroMemory( pwszTemp, 2 * sizeof( WCHAR ) );
            StringCopy( pwszTemp, _T( ":" ), 2 );
        }
        else
        {
            // get the time field seperator
            pwszTemp = m_strTimeSep.GetBufferSetLength( lTemp + 2 );
            SecureZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
            lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, pwszTemp, lTemp );
            if( 0 == lTemp )
            {
                return FALSE;
            }
        }

        //
        // get the group seperator character
        lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, NULL, 0 );
        if ( 0 == lTemp )
        {
            // we don't know how to resolve this
            return FALSE;
        }
        else
        {
            // get the group seperation character
            pwszTemp = str.GetBufferSetLength( lTemp + 2 );
            SecureZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
            lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, pwszTemp, lTemp );
            if ( 0 == lTemp )
            {
                // we don't know how to resolve this
                return FALSE;
            }

            // change the group info into appropriate number
            lTemp = 0;
            m_dwGroupSep = 0;
            while ( lTemp < str.GetLength() )
            {
                if ( AsLong( str.Mid( lTemp, 1 ), 10 ) != 0 )
                {
                    m_dwGroupSep = m_dwGroupSep * 10 + AsLong( str.Mid( lTemp, 1 ), 10 );
                }
                // increment by 2
                lTemp += 2;
            }
        }

        //
        // get the thousand seperator character
        lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, NULL, 0 );
        if ( 0 == lTemp )
        {
            // we don't know how to resolve this
            return FALSE;
        }
        else
        {
            // get the thousand sepeartion charactor
            pwszTemp = m_strGroupThousSep.GetBufferSetLength( lTemp + 2 );
            SecureZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
            lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, pwszTemp, lTemp );
            if ( 0 == lTemp )
            {
                // we don't know how to resolve this
                return FALSE;
            }
        }

        // release the CHStrig buffers
        str.ReleaseBuffer();
        m_strTimeSep.ReleaseBuffer();
        m_strGroupThousSep.ReleaseBuffer();
    }
    catch( CHeap_Exception )
    {
        // out of memory
        return FALSE;
    }

    //
    // load the winsta library and needed functions
    // NOTE: do not raise any error if loading of winsta dll fails
    {   // Local variabels should be destroyed inside this block.
        // +1 is for terminating NULL character.
        LPWSTR lpszSystemPath = NULL;
        DWORD dwLength = MAX_PATH + 1;
        DWORD dwExpectedLength = 0;
        DWORD dwActualBufLen = 0;

        do
        {
            dwActualBufLen = dwLength + 5 + StringLength( WINSTA_DLLNAME, 0 );
            // Length of 'System32' + Length of '\' + Length of 'WINSTA_DLLNAME' + Length of '\0'.
            // 3 WCHARS are extra, to be on safer side.
            lpszSystemPath = (LPWSTR) AllocateMemory( dwActualBufLen * sizeof( WCHAR ) );
            if( NULL == lpszSystemPath )
            {   // Out of memory.
                m_hWinstaLib = NULL;
                break;
            }

            dwExpectedLength = GetSystemDirectory( lpszSystemPath, dwLength );
            if( ( 0 != dwExpectedLength ) ||
                ( dwLength > dwExpectedLength ) )
            {   // Successful
                StringConcat( lpszSystemPath, L"\\", dwActualBufLen );
                StringConcat( lpszSystemPath, WINSTA_DLLNAME, dwActualBufLen );
                m_hWinstaLib = ::LoadLibrary( lpszSystemPath );
                FreeMemory( (LPVOID * )&lpszSystemPath );
                break;
            }
            FreeMemory( (LPVOID * )&lpszSystemPath );
            m_hWinstaLib = NULL;
            // +1 is for terminating NULL character.
            dwLength = dwExpectedLength + 1;
        }while( 0 != dwExpectedLength );
    }

    if ( NULL != m_hWinstaLib )
    {
        // library loaded successfully ... now load the addresses of functions
        m_pfnWinStationFreeMemory = (FUNC_WinStationFreeMemory) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationFreeMemory );
        m_pfnWinStationCloseServer = (FUNC_WinStationCloseServer) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationCloseServer );
        m_pfnWinStationOpenServerW = (FUNC_WinStationOpenServerW) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationOpenServerW );
        m_pfnWinStationFreeGAPMemory = (FUNC_WinStationFreeGAPMemory) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationFreeGAPMemory );
        m_pfnWinStationGetAllProcesses = (FUNC_WinStationGetAllProcesses) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationGetAllProcesses );
        m_pfnWinStationNameFromLogonIdW = (FUNC_WinStationNameFromLogonIdW) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationNameFromLogonIdW );
        m_pfnWinStationEnumerateProcesses = (FUNC_WinStationEnumerateProcesses) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationEnumerateProcesses );

        // we will keep the library loaded in memory only if all the functions were loaded successfully
        if ( ( NULL == m_pfnWinStationFreeMemory ) ||
             ( NULL == m_pfnWinStationCloseServer ) ||
             ( NULL == m_pfnWinStationOpenServerW ) ||
             ( NULL == m_pfnWinStationFreeGAPMemory ) ||
             ( NULL == m_pfnWinStationGetAllProcesses ) ||
             ( NULL == m_pfnWinStationEnumerateProcesses ) ||
             ( NULL == m_pfnWinStationNameFromLogonIdW ) )

        {
            // some (or) all of the functions were not loaded ... unload the library
            FreeLibrary( m_hWinstaLib );
            m_hWinstaLib = NULL;
            m_pfnWinStationFreeMemory = NULL;
            m_pfnWinStationOpenServerW = NULL;
            m_pfnWinStationCloseServer = NULL;
            m_pfnWinStationFreeGAPMemory = NULL;
            m_pfnWinStationGetAllProcesses = NULL;
            m_pfnWinStationNameFromLogonIdW = NULL;
            m_pfnWinStationEnumerateProcesses = NULL;
        }
    }

    // enable debug privelages
    EnableDebugPriv();

    // initialization is successful
    SetLastError( NOERROR );            // clear the error
    SetReason( NULL_STRING );           // clear the reason
    return TRUE;
}


BOOL
CTaskList::EnableDebugPriv(
    void
    )
/*++
Routine Description:
      Enables the debug privliges for the current process so that
      this utility can terminate the processes on local system without any problem

Arguments:
      NONE

Return Value:
      TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    LUID luidValue ;
    BOOL bResult = FALSE;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;

    SecureZeroMemory( &luidValue, sizeof( LUID ) );
    SecureZeroMemory( &tkp, sizeof( TOKEN_PRIVILEGES ) );

    // Retrieve a handle of the access token
    bResult = OpenProcessToken( GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken );
    if ( FALSE == bResult )
    {
        // save the error messaage and return
        SaveLastError();
        return FALSE;
    }

    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depends on this flag.
    bResult = LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &luidValue );
    if ( FALSE == bResult )
    {
        // save the error messaage and return
        SaveLastError();
        CloseHandle( hToken );
        return FALSE;
    }

    // prepare the token privileges structure
    tkp.PrivilegeCount = 1;
    tkp.Privileges[ 0 ].Luid = luidValue;
    tkp.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;

    // now enable the debug privileges in the token
    bResult = AdjustTokenPrivileges( hToken, FALSE, &tkp, sizeof( TOKEN_PRIVILEGES ),
        ( PTOKEN_PRIVILEGES ) NULL, ( PDWORD ) NULL );
    if ( FALSE == bResult )
    {
        // The return value of AdjustTokenPrivileges be texted
        SaveLastError();
        CloseHandle( hToken );
        return FALSE;
    }

    // close the opened token handle
    CloseHandle( hToken );

    // enabled ... inform success
    return TRUE;
}


BOOLEAN
CTaskList::WinStationFreeMemory(
    IN PVOID pBuffer
    )
/*++
Routine Description:
    Free memory.

Arguments:
    [in] pBuffer : Cotains memory location to free.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the buffer and act
    if ( NULL == pBuffer )
    {
        return TRUE;
    }
    // check whether pointer exists or not
    if ( NULL == m_pfnWinStationFreeMemory )
    {
        return FALSE;
    }
    // call and return the same
    return ((FUNC_WinStationFreeMemory) m_pfnWinStationFreeMemory)( pBuffer );
}


BOOLEAN
CTaskList::WinStationCloseServer(
    IN HANDLE hServer
    )
/*++
Routine Description:
    Handle to window station is closed.

Arguments:
    [in] hServer : Handle to window station.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input
    if ( NULL == hServer )
    {
        return TRUE;
    }
    // check whether the function pointer exists or not
    if ( NULL == m_pfnWinStationCloseServer )
    {
        return FALSE;
    }
    // call and return
    return ((FUNC_WinStationCloseServer) m_pfnWinStationCloseServer)( hServer );
}


HANDLE
CTaskList::WinStationOpenServerW(
    IN LPWSTR pwszServerName
    )
/*++
Routine Description:
    Retrieves a handle to an window station on a system.

Arguments:
    [in] pwszServerName : System name from where to retrieve window station handle.

Return Value:
    Valid handle is returned if successful else NULL is returned.
--*/
{
    // check the input & also check whether function pointer exists or not
    if ( ( NULL == pwszServerName ) ||
         ( NULL == m_pfnWinStationOpenServerW ) )
    {
        return NULL;
    }
    // call and return
    return ((FUNC_WinStationOpenServerW) m_pfnWinStationOpenServerW)( pwszServerName );
}


BOOLEAN
CTaskList::WinStationEnumerateProcesses(
    IN HANDLE hServer,
    OUT PVOID* ppProcessBuffer
    )
/*++
Routine Description:
    Retrieves process running on a system.

Arguments:
    [in] hServer            : Cotains handle to window station.
    [ out ] ppProcessBuffer : Contains process infomration on remote system.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input and also check whether function pointer exists or not
    if ( ( NULL == ppProcessBuffer ) ||
         ( NULL == m_pfnWinStationEnumerateProcesses ) )
    {
        return FALSE;
    }
    // call and return
    return ((FUNC_WinStationEnumerateProcesses)
        m_pfnWinStationEnumerateProcesses)( hServer, ppProcessBuffer );
}


BOOLEAN
CTaskList::WinStationFreeGAPMemory(
    IN ULONG ulLevel,
    IN PVOID pProcessArray,
    IN ULONG ulCount
    )
/*++
Routine Description:
    Free gap memory block.

Arguments:
    [in] ulLevel         : Contains information level of data.
    [ in ] pProcessArray : Contains data to be freed.
    [ in ] ulCount       : Contains number of blocks to be freed.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input
    if ( NULL == pProcessArray )
    {
        return TRUE;
    }
    // check whether function pointer exists or not
    if ( NULL == m_pfnWinStationFreeGAPMemory )
    {
        return FALSE;
    }
    // call and return
    return ((FUNC_WinStationFreeGAPMemory)
        m_pfnWinStationFreeGAPMemory)( ulLevel, pProcessArray, ulCount );
}


BOOLEAN
CTaskList::WinStationGetAllProcesses(
    IN HANDLE hServer,
    IN ULONG ulLevel,
    OUT ULONG* pNumberOfProcesses,
    OUT PVOID* ppProcessArray
    )
/*++
Routine Description:
    Retrieves process information running on a system.

Arguments:
    [in] hServer               : Cotains handle to window station.
    [ in ] ulLevel             : Contains information level of data.
    [ out ] pNumberOfProcesses : Contains number of process retrieved.
    [ out ] ppProcessArray     : Contains process realted infomration.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input & check whether function pointer exists or not
    if ( ( NULL == pNumberOfProcesses ) ||
         ( NULL == ppProcessArray ) ||
         ( NULL == m_pfnWinStationGetAllProcesses ) )
    {
        return FALSE;
    }
    return ((FUNC_WinStationGetAllProcesses)
        m_pfnWinStationGetAllProcesses)( hServer, ulLevel, pNumberOfProcesses, ppProcessArray );
}


BOOLEAN
CTaskList::WinStationNameFromLogonIdW(
    IN HANDLE hServer,
    IN ULONG ulLogonId,
    OUT LPWSTR pwszWinStationName
    )
/*++
Routine Description:
    Free memory.

Arguments:
    [in] hServer             : Cotains handle to window station.
    [in] ulLogonId           : Contains logon ID.
    [out] pwszWinStationName : Contains window station name.

Return Value:
    TRUE if successful else FALSE is returned.
--*/
{
    // check the input & check whether function pointer exists or not
    if( ( NULL == pwszWinStationName ) ||
        ( NULL == m_pfnWinStationNameFromLogonIdW ) )
    {
        return FALSE;
    }

    return ((FUNC_WinStationNameFromLogonIdW)
        m_pfnWinStationNameFromLogonIdW)( hServer, ulLogonId, pwszWinStationName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\pch.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      pch.h
//
//  Abstract:
//
//      pre-compiled header declaration
//      files that has to be pre-compiled into .pch file
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once        // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#define CMDLINE_VERSION 200
//
// Private nt headers.
//
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
    #include <Security.h>
    #include <SecExt.h>
}

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <wbemidl.h>
#include <chstring.h>
#include <comdef.h>
#include <wbemtime.h>
#include <dbghelp.h>
#include <winuserp.h>

//
// public C header files
//
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>
#include <strsafe.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\taskkill\wmi.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    WMI.cpp

Abstract:

    Common functionlity for dealing with WMI.

Author:

    Wipro Technologies

Revision History:

    22-Dec-2000 : Created It.
    24-Apr-2001 : Closing the review comments given by client.

*********************************************************************************************/

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD              GetResString( IDS_STR_INPUT_PASSWORD )
#define INPUT_PASSWORD_LEN          256
// error constants
#define E_SERVER_NOTFOUND           0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface,
                              DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface,
                              LPCWSTR pwszUser,
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword,
                                      LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices,
                          LPCWSTR pwszMethod, DWORD dwHDefKey,
                          LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );


BOOL
IsValidUserEx(
    LPCWSTR pwszUser
    )
/*++

Routine Description:

    Checks wether the User name is a valid one or not

Arguments:

    [in] LPCWSTR    :   String containing the user name

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    CHString strUser;
    LONG lPos = 0;

    if ( ( NULL == pwszUser ) || ( 0 == StringLength( pwszUser, 0 ) ) )
    {
        return TRUE;
    }

    try
    {
        // get user into local memory
        strUser = pwszUser;

        // user name should not be just '\'
        if ( strUser.CompareNoCase( L"\\" ) == 0 )
        {
            return FALSE;
        }

        // user name should not contain invalid characters
        if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
        {
            return FALSE;
        }

        // SPECIAL CHECK
        // check for multiple '\' characters in the user name
        lPos = strUser.Find( L'\\' );
        if ( -1 != lPos )
        {
            // '\' character exists in the user name
            // strip off the user info upto first '\' character
            // check for one more '\' in the remaining string
            // if it exists, invalid user
            strUser = strUser.Mid( lPos + 1 );
            lPos = strUser.Find( L'\\' );
            if ( -1 != lPos )
            {
                return FALSE;
            }
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // user name is valid
    return TRUE;
}


BOOL
IsValidServerEx(
    LPCWSTR pwszServer,
    BOOL& bLocalSystem
    )
/*++

Routine Description:

    Checks wether the Server name is a valid one or not

Arguments:

    [in]  LPCWSTR   :   String containing the user name
    [out] BOOL      :   Is set to TRUE if the local system is being queried.

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    CHString strTemp;

    // Validate input arguments.
    if ( ( NULL == pwszServer ) || ( 0 == StringLength( pwszServer, 0 ) ) )
    {
       bLocalSystem = TRUE;
       return TRUE;
    }

    try
    {
        // kick-off
        bLocalSystem = FALSE;

        if( IsNumeric( pwszServer, 10, FALSE ) == TRUE )
        {
            return FALSE;
        }

        // get a local copy
        strTemp = pwszServer;

        // remove the forward slashes (UNC) if exist in the begining of the server name
        if ( IsUNCFormat( strTemp ) == TRUE )
        {
            strTemp = strTemp.Mid( 2 );
            if ( strTemp.GetLength() == 0 )
            {
                return FALSE;
            }
        }

        if ( strTemp.FindOneOf( L"`~!@#$^&*()+=[]{}|\\<>,?/\"':;" ) != -1 )
        {
            return FALSE;
        }

        // now check if any '\' character appears in the server name. If so error
        if ( strTemp.Find( L'\\' ) != -1 )
        {
            return FALSE;
        }

        // now check if server name is '.' only which represent local system in WMI
        // else determine whether this is a local system or not
        if ( strTemp.CompareNoCase( L"." ) == 0 )
        {
            bLocalSystem = TRUE;
        }
        else
        {
            bLocalSystem = IsLocalSystem( strTemp );
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // inform that server name is valid
    return TRUE;
}


BOOL
InitializeCom(
    IWbemLocator** ppLocator
    )
/*++
Routine Description:

    Initializes the COM library

Arguments:

    [in] IWbemLocator   :   pointer to the IWbemLocator

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;

    try
    {
        // Validate input arguments.
        if( ( NULL == ppLocator ) ||
            ( NULL != *ppLocator ) )
        {
             _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // initialize the COM library
        SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_MULTITHREADED ) );

        // initialize the security
        SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

        // create the locator and get the pointer to the interface of IWbemLocator
        SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

        // initialization successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the WMI error
        WMISaveError( e );
        // Error is returned. Release any interface pointers.
        SAFE_RELEASE( *ppLocator );
    }

    // return the result;
    return bResult;
}


BOOL
ConnectWmi(
    IWbemLocator* pLocator,
    IWbemServices** ppServices,
    LPCWSTR pwszServer,
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    COAUTHIDENTITY** ppAuthIdentity,
    BOOL bCheckWithNullPwd,
    LPCWSTR pwszNamespace,
    HRESULT* phr,
    BOOL* pbLocalSystem,
    IWbemContext* pWbemContext
    )
/*++

Routine Description:

    This function makes a connection to WMI.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;
    _bstr_t bstrServer;
    _bstr_t bstrNamespace;
    _bstr_t bstrUser, bstrPassword;

    // check whether locator object exists or not
    // if not exists, return
    if ( ( NULL == pLocator ) ||
         ( NULL == ppServices ) ||
         ( NULL != *ppServices ) ||
         ( NULL == pwszNamespace ) )
    {
        if ( NULL != phr )
        {
            *phr = WBEM_E_INVALID_PARAMETER;
        }
        // return failure
        return FALSE;
    }

    // kick-off
    if ( NULL != pbLocalSystem )
    {
        *pbLocalSystem = FALSE;
    }
    // ...
    if ( NULL != phr )
    {
        *phr = WBEM_S_NO_ERROR;
    }

    try
    {

        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // validate the server name
        // NOTE: The error being raised in custom define for '0x800706ba' value
        //       The message that will be displayed in "The RPC server is unavailable."
        if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
        {
            _com_issue_error( E_SERVER_NOTFOUND );
        }

        // validate the user name
        if ( IsValidUserEx( pwszUser ) == FALSE )
        {
            _com_issue_error( ERROR_NO_SUCH_USER );
        }

        // prepare namespace
        bstrNamespace = pwszNamespace;              // name space
        if ( ( NULL != pwszServer ) && ( FALSE == bLocalSystem ) )
        {
            // get the server name
            bstrServer = pwszServer;

            // prepare the namespace
            // NOTE: check for the UNC naming format of the server and do
            if ( IsUNCFormat( pwszServer ) == TRUE )
            {
                bstrNamespace = bstrServer + L"\\" + pwszNamespace;
            }
            else
            {
                bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
            }

            // user credentials
            if ( ( NULL != pwszUser ) && ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                // copy the user name
                bstrUser = pwszUser;

                // if password is empty string and if we need to check with
                // null password, then do not set the password and try
                bstrPassword = pwszPassword;
                if ( ( TRUE == bCheckWithNullPwd ) && ( 0 == bstrPassword.length() ) )
                {
                    bstrPassword = (LPWSTR) NULL;
                }
            }
        }
        else
        {    // Display warning message, credentials not required for local system.
            if( ( TRUE == bLocalSystem ) && ( NULL != pwszUser ) &&
                ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                 // got the credentials for the local system
                 if ( NULL != phr )
                 {
                     *phr = WBEM_E_LOCAL_CREDENTIALS;
                 }
            }
        }

        // connect to the remote system's WMI
        // there is a twist here ...
        // do not trap the ConnectServer function failure into exception
        // instead handle that action manually
        // by default try the ConnectServer function as the information which we have
        // in our hands at this point. If the ConnectServer is failed,
        // check whether password variable has any contents are not ... if no contents
        // check with "" (empty) password ... this might pass in this situation ..
        // if this call is also failed ... nothing is there that we can do ... throw the exception
        hr = pLocator->ConnectServer( bstrNamespace,
            bstrUser, bstrPassword, 0L, 0L, NULL, pWbemContext, ppServices );
        if ( FAILED( hr ) )
        {
            //
            // special case ...

            // check whether password exists or not
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'
            if ( hr == E_ACCESSDENIED )
            {
                // check if we tried to connect to the system using null password
                // if so, then try connecting to the remote system with empty string
                if ( bCheckWithNullPwd == TRUE &&
                     bstrUser.length() != 0 && bstrPassword.length() == 0 )
                {
                    // now invoke with ...
                    hr = pLocator->ConnectServer( bstrNamespace,
                        bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, pWbemContext, ppServices );
                }
            }
            else
            {
                if ( WBEM_E_LOCAL_CREDENTIALS == hr )
                {
                    // credentials were passed to the local system.
                    // So ignore the credentials and try to reconnect
                    bLocalSystem = TRUE;
                    bstrUser = (LPWSTR) NULL;
                    bstrPassword = (LPWSTR) NULL;
                    bstrNamespace = pwszNamespace;              // name space
                    hr = pLocator->ConnectServer( bstrNamespace,
                        NULL, NULL, 0L, 0L, NULL, pWbemContext, ppServices );
                }
            }

            // now check the result again .. if failed .. ummmm..
            if ( FAILED( hr ) )
            {
                _com_issue_error( hr );
            }
            else
            {
                bstrPassword = L"";
            }
        }

        // set the security at the interface level also
        SAFE_EXECUTE( SetInterfaceSecurity( *ppServices,
            bstrUser, bstrPassword, ppAuthIdentity ) );

        // ...
        if ( NULL != pbLocalSystem )
        {
            *pbLocalSystem = bLocalSystem;
        }

        // connection to WMI is successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        try
        {
            // save the error
            WMISaveError( e );

            // save the hr value if needed by the caller
            if ( NULL != phr )
            {
                *phr = e.Error();
            }
        }
        catch( ... )
        {
            WMISaveError( E_OUTOFMEMORY );
        }
        SAFE_RELEASE( *ppServices );
        bResult = FALSE;
    }

    // return the result
    return bResult;
}


BOOL
ConnectWmiEx(
    IWbemLocator* pLocator,
    IWbemServices** ppServices,
    LPCWSTR pwszServer,
    CHString& strUserName,
    CHString& strPassword,
    COAUTHIDENTITY** ppAuthIdentity,
    BOOL bNeedPassword,
    LPCWSTR pwszNamespace,
    BOOL* pbLocalSystem,
    DWORD dwPasswordLen,
    IWbemContext* pWbemContext
    )
/*++

Routine Description:

    This function is a wrapper function for the ConnectWmi function.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system
    [ in ] DWORD                :   Contains maximum password buffer length.

Return Value:

    TRUE on success
    FALSE on failure

NOTE: 'dwPasswordLen' WILL BE TAKEN AS 'MAX_STRING_LENGTH' IF NOT SPECIFIED.
      IT IS USER RESPOSIBILITY TO SET THIS PARAMETER TO LIMITING VALUE.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszPassword = NULL;
    CHString strBuffer;

    try
    {
        // sometime users want the utility to prompt for the password
        // check what user wants the utility to do
        if ( ( TRUE == bNeedPassword ) &&
             ( 0 == strPassword.Compare( L"*" ) ) )
        {
            // user wants the utility to prompt for the password
            // so skip this part and let the flow directly jump the password acceptance part
        }
        else
        {
            // try to establish connection to the remote system with the credentials supplied
            if ( 0 == strUserName.GetLength() )
            {
                // user name is empty
                // so, it is obvious that password will also be empty
                // even if password is specified, we have to ignore that
                bResult = ConnectWmi( pLocator, ppServices,
                    pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem, pWbemContext );
            }
            else
            {
                // credentials were supplied
                // but password might not be specified ... so check and act accordingly
                LPCWSTR pwszTemp = NULL;
                BOOL bCheckWithNull = TRUE;
                if ( bNeedPassword == FALSE )
                {
                    pwszTemp = strPassword;
                    bCheckWithNull = FALSE;
                }

                // ...
                bResult = ConnectWmi( pLocator, ppServices, pwszServer,
                    strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem, pWbemContext );
            }

            SetLastError( hr );
            // check the result ... if successful in establishing connection ... return
            if ( TRUE == bResult )
            {
                return TRUE;
            }

            // now check the kind of error occurred
            switch( hr )
            {
            case E_ACCESSDENIED:
                SetLastError( hr );
                break;

            case WBEM_E_LOCAL_CREDENTIALS:
                SetLastError( hr );
                // needs to do special processing
                break;

            case WBEM_E_ACCESS_DENIED:
            default:
                // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
                //       this error code says that user with the current credentials is not
                //       having access permisions to the 'namespace'
                WMISaveError( hr );
                return FALSE;       // no use of accepting the password .. return failure
                break;
            }


            // if failed in establishing connection to the remote terminal
            // even if the password is specifed, then there is nothing to do ... simply return failure
            if ( bNeedPassword == FALSE )
            {
                return FALSE;
            }
        }

        // check whether user name is specified or not
        // if not, get the local system's current user name under whose credentials, the process
        // is running
        if ( 0 == strUserName.GetLength() )
        {
            // sub-local variables
            LPWSTR pwszUserName = NULL;
            DWORD dwUserLength = 0;    // Username buffer length.
            // Retrieve the buffer length need to store username.
            GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength );

            // get the required buffer
            pwszUserName = strUserName.GetBufferSetLength( dwUserLength );

            if ( FALSE == GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) )
            {
                // error occured while trying to get the current user info
                SaveLastError();
                return FALSE;
            }
            // No need to call 'ReleaseBuffer' since only sufficient memory is allocated.
        }

        // get the required buffer
        if( 0 == dwPasswordLen )
        {
             dwPasswordLen = INPUT_PASSWORD_LEN;
        }
        pwszPassword = strPassword.GetBufferSetLength( dwPasswordLen );

        // accept the password from the user
        strBuffer.Format( INPUT_PASSWORD, strUserName );
        WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ),
            strBuffer, strBuffer.GetLength(), &dwSize, NULL );

        bResult = GetPassword( pwszPassword, dwPasswordLen );
        if ( TRUE != bResult )
        {
            return FALSE;
        }

        // release the buffer allocated for password
        strPassword.ReleaseBuffer();

        // now again try to establish the connection using the currently
        // supplied credentials
        bResult = ConnectWmi( pLocator, ppServices, pwszServer,
            strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace,
            NULL, pbLocalSystem, pWbemContext );
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return the failure
    return bResult;
}


HRESULT
GetSecurityArguments(
    IUnknown* pInterface,
    DWORD& dwAuthorization,
    DWORD& dwAuthentication
    )
/*++

Routine Description:

    This function gets the values for the security services.

Arguments:

    [in] IUnknown   :   pointer to the IUnkown interface
    [out] DWORD     :   to hold the authentication service value
    [out] DWORD     :   to hold the authorization service value

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
    IClientSecurity* pClientSecurity = NULL;

    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    // try to get the client security services values if possible
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
    if ( SUCCEEDED( hr ) )
    {
        // got the client security interface
        // now try to get the security services values
        hr = pClientSecurity->QueryBlanket( pInterface,
            &dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
        if ( SUCCEEDED( hr ) )
        {
            // we've got the values from the interface
            dwAuthentication = dwAuthnSvc;
            dwAuthorization = dwAuthzSvc;
        }

        // release the client security interface
        SAFE_RELEASE( pClientSecurity );
    }

    // return always success
    return hr;
}


HRESULT
SetInterfaceSecurity(
    IUnknown* pInterface,
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    COAUTHIDENTITY** ppAuthIdentity
    )
/*++

Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] LPCWSTR            :   string containing the User name
    [in] LPCWSTR            :   string containing the password
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString strUser;
    CHString strDomain;
    LPCWSTR pwszUserArg = NULL;
    LPCWSTR pwszDomainArg = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    try
    {
        // check the interface
        if ( NULL == pInterface )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // check the authentity strcuture ... if authentity structure is already ready
        // simply invoke the 2nd version of SetInterfaceSecurity
        if ( NULL != *ppAuthIdentity )
        {
            return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
        }

        // If we are doing trivial case, just pass in a null authenication structure
        // for which the current logged in user's credentials will be considered
        if ( ( NULL == pwszUser ) &&
             ( NULL == pwszPassword ) )
        {
            // set the security
            hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization,
                NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

            // return the result
            return hr;
        }

        // if authority srtucture is NULL then no need to proceed
        if ( NULL == ppAuthIdentity )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // check if authenication info is available or not ...
        // initialize the security authenication information ... UNICODE VERSION STRUCTURE
        if ( NULL == *ppAuthIdentity )
        {
            // parse and find out if the user name contains the domain name
            // if contains, extract the domain value from it
            LONG lPos = -1;
            strDomain = L"";
            strUser = pwszUser;
            if ( -1 != ( lPos = strUser.Find( L'\\' ) ) )
            {
                // user name contains domain name ... domain\user format
                strDomain = strUser.Left( lPos );
                strUser = strUser.Mid( lPos + 1 );
            }
            else
            {
                if ( -1 != ( lPos = strUser.Find( L'@' ) ) )
                {
                    // NEED TO IMPLEMENT THIS ... IF NEEDED
                    // This implementation needs to be done if WMI does not support
                    // UPN name formats directly and if we have to split the
                    // name(user@domain)
                }
                else
                {
                    // server itself is the domain
                    // NOTE: NEED TO DO SOME R & D ON BELOW COMMENTED LINE
                    // strDomain = pwszServer;
                }
             }

            // get the domain info if it exists only
            if ( 0 != strDomain.GetLength() )
            {
                pwszDomainArg = strDomain;
            }

            // get the user info if it exists only
            if ( 0 != strUser.GetLength() )
            {
                pwszUserArg = strUser;
            }

            hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
            if ( FAILED(hr) )
            {
              return hr;
            }
        }

        // set the security information to the interface
        hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );
    }
    catch( CHeap_Exception )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    // return the result
    return hr;
}


HRESULT
SetInterfaceSecurity(
    IUnknown* pInterface,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    // 'pAuthIdentity' can be NULL or not, so need to check.
    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // get the current security argument value
    hr = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}


HRESULT
WINAPI SetProxyBlanket(
    IUnknown* pInterface,
    DWORD dwAuthnSvc,
    DWORD dwAuthzSvc,
    LPWSTR pwszPrincipal,
    DWORD dwAuthLevel,
    DWORD dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
    DWORD dwCapabilities
    )
/*++

Routine Description:

    This function sets the authentication information (the security blanket)
    that will be used to make calls.

Arguments:

    [in] IUnknown                       :   pointer to the IUnkown interface
    [in] DWORD                          :   contains the authentication service to use
    [in] DWORD                          :   contains the authorization service to use
    [in] LPWSTR                         :   the server principal name to use
    [in] DWORD                          :   contains the authentication level to use
    [in] DWORD                          :   contains the impersonation level to use
    [in] RPC_AUTH_IDENTITY_HANDLE       :   pointer to the identity of the client
    [in] DWORD                          :   contains the capability flags

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

    // Validate input arguments.
    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if( ( NULL == pInterface ) ||
        ( ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) ) &&
          ( NULL != pAuthInfo ) )
      )
    {
        return( WBEM_E_INVALID_PARAMETER );
    }

    // get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( FAILED(hr) )
    {
        return hr;
    }

    // now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( FAILED(hr) )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    // now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pUnknown );
        SAFE_RELEASE( pClientSecurity );
        return hr;
    }

    // release the security interface
    SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( NULL != pAuthInfo )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( SUCCEEDED(hr) )
        {
            // set security authentication
            hr = pClientSecurity->SetBlanket( pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

            // release
            SAFE_RELEASE( pClientSecurity );
        }
        else
        {
            if ( E_NOINTERFACE == hr )
            {
                hr = S_OK;      // ignore no interface errors
            }
        }
    }

    // release the IUnknown
    SAFE_RELEASE( pUnknown );

    // return the result
    return hr;
}


HRESULT
WINAPI WbemAllocAuthIdentity(
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    LPCWSTR pwszDomain,
    COAUTHIDENTITY** ppAuthIdent
    )
/*++

Routine Description:

    This function allocates memory for the AUTHIDENTITY structure.

Arguments:

    [in] LPCWSTR            :   string containing the user name
    [in] LPCWSTR            :   string containing the password
    [in] LPCWSTR            :   string containing the domain name
    [out] COAUTHIDENTITY    :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

NOTE: 'ppAuthIdent' should be freed by calling 'WbemFreeAuthIdentity' by the user after
      their work is done.

--*/
{
    // local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

    // validate the input parameter
    if ( NULL == ppAuthIdent )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // init with 0's
    SecureZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

    //
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong

    // user
    if ( NULL != pwszUser )
    {
        // allocate memory for user
        LONG lLength = StringLength( pwszUser, 0 );
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->User )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        StringCopy( pAuthIdent->User, pwszUser, (lLength + 1) );
    }

    // domain
    if ( NULL != pwszDomain )
    {
        // allocate memory for domain
        LONG lLength = StringLength( pwszDomain, 0 );
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Domain )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        StringCopy( pAuthIdent->Domain, pwszDomain, (lLength + 1) );
    }

    // passsord
    if ( NULL != pwszPassword )
    {
        // allocate memory for passsord
        LONG lLength = StringLength( pwszPassword, 0 );
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Password )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        StringCopy( pAuthIdent->Password, pwszPassword, (lLength + 1) );
    }

    // type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
    *ppAuthIdent = pAuthIdent;

    // return result
    return S_OK;
}


VOID
WINAPI WbemFreeAuthIdentity(
    COAUTHIDENTITY** ppAuthIdentity
    )
/*++

Routine Description:

    This function releases the memory allocated for the AUTHIDENTITY structure.

Arguments:

    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    None

--*/
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
        // free the memory allocated for user
        if ( NULL != (*ppAuthIdentity)->User )
        {
            CoTaskMemFree( (*ppAuthIdentity)->User );
            (*ppAuthIdentity)->User = NULL;
        }

        // free the memory allocated for password
        if ( NULL != (*ppAuthIdentity)->Password )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Password );
            (*ppAuthIdentity)->Password = NULL;
        }

        // free the memory allocated for domain
        if ( NULL != (*ppAuthIdentity)->Domain )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Domain );
            (*ppAuthIdentity)->Domain = NULL;
        }

        // final the structure
        CoTaskMemFree( *ppAuthIdentity );
        *ppAuthIdentity = NULL;
    }
}


VOID
WMISaveError(
    HRESULT hrError
    )
/*++

Routine Description:

    This function saves the description of the last error returned by WMI

Arguments:

    HRESULT     :   The last return value from WMI

Return Value:

    NONE

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IWbemStatusCodeText* pWbemStatus = NULL;
    _bstr_t bstrErrorString;

    try
    {
        // Set error to different value.
        if ( E_ACCESSDENIED == hrError )
        {
            // change the error message to "Logon failure: unknown user name or bad password."
            hrError = ERROR_LOGON_FAILURE;
        }

        //Set the reason to incompatible os when no class is registered on remote mechine
        if( 0x80040154 == hrError )
        {
            bstrErrorString = _bstr_t( GetResString(IDS_ERROR_REMOTE_INCOMPATIBLE));
            SetReason( bstrErrorString );
            return;
        }
        else
        {   // Get error string.
            hr = CoCreateInstance( CLSID_WbemStatusCodeText,
                                   NULL, CLSCTX_INPROC_SERVER,
                                   IID_IWbemStatusCodeText,
                                   (LPVOID*) &pWbemStatus );
            if( SUCCEEDED( hr ) )
            {
                BSTR bstrString = NULL;
                // Get error string from error code.
                hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0,
                                                    &bstrString );
                if( NULL != bstrString )
                {
                    bstrErrorString = _bstr_t( bstrString );
                    SysFreeString( bstrString );
                }
                if( FAILED( hr ) )
                {
                    _com_issue_error( hrError );
                }
				SAFE_RELEASE( pWbemStatus );
            }
            else
            {
                _com_issue_error( hrError );
            }
        }
    }
    catch( _com_error& e )
    {   // We have got the error. Needs to handle carefully.
        LPWSTR lpwszGetString = NULL;
		SAFE_RELEASE( pWbemStatus );
        try
        {   // ErrorMessage() can throw an exception.
            DWORD dwLength = StringLength( e.ErrorMessage(), 0 ) + 5 ;
            lpwszGetString = ( LPWSTR )AllocateMemory( dwLength * sizeof( WCHAR ) );
            if( NULL != lpwszGetString )
            {
                StringCopy( lpwszGetString, e.ErrorMessage(), dwLength );
                StringConcat( lpwszGetString, L"\n", dwLength );
                SetReason( ( LPCWSTR )lpwszGetString );
                FreeMemory( (LPVOID*) &lpwszGetString );
            }
            else
            {   // Failed to know the exact error occured
                // due to insufficient memory.
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
            }
        }
        catch( ... )
        {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
        }
        return;
    }

    SetReason( (LPCWSTR) bstrErrorString );
    return;
}


HRESULT
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    _variant_t& varValue
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   property name
    [out] _variant_t            :   value of the property

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    VARIANT vtValue;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // initialize the variant and then get the value of the specified property
        VariantInit( &vtValue );
        // Call 'Get' method to retireve the value from WMI.
        hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
        if ( FAILED( hr ) )
        {
            // Clear the variant variable
            VariantClear( &vtValue );
            // Return error.
            return hr;
        }

        // set the value
        varValue = vtValue;
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // Clear the variables.
    VariantClear( &vtValue );
    // Return.
    return hr;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    CHString& strValue,
    LPCWSTR pwszDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in string format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] CHString              :   variable to hold the retrieved property
    [in] LPCWSTR                :   string containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t var;

    strValue.Empty();

    try
    {
        // first copy the default value
        strValue = pwszDefault;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the property value
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // Get the value
        // If 'var' does not contain value of requested type
        // then default value is returned.
        if ( VT_BSTR == V_VT( &var ) )
        {
            strValue = (LPCWSTR) _bstr_t( var );
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    DWORD& dwValue,
    DWORD dwDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in dword format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] DWORD                 :   variable to hold the retrieved property
    [in] DWORD                  :   dword containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr;
    _variant_t var;

    try
    {
        // first set the defaul value
        dwValue = dwDefault;

        // check with object and property passed to the function are valid or not
        // if not, return failure
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the value of the property
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // get the process id from the variant
        switch( V_VT( &var ) )
        {
        case VT_I2:
            dwValue = V_I2( &var );
            break;
        case VT_I4:
            dwValue = V_I4( &var );
            break;
        case VT_UI2:
            dwValue = V_UI2( &var );
            break;
        case VT_UI4:
            dwValue = V_UI4( &var );
            break;
        case VT_INT:
            dwValue = V_INT( &var );
            break;
        case VT_UINT:
            dwValue = V_UINT( &var );
            break;
        default:
            // Requested type is not found.
            // If 'var' does not contain value of requested type
            // then default value is returned.
        break;
        };
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    ULONGLONG& ullValue
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in ulongulong format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] ULONGULONG            :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // Local variables
    CHString str;

    str.Empty();

    try
    {
        // first set the default value
        ullValue = 1;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }

        // get the value of the property
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) )
        { // Error is already set in 'PropertyGet' function.
            return FALSE;
        }

        // get the 64-bit value
        ullValue = _wtoi64( str );

        // Check for error condition.
        if( 0 == ullValue )
        {
            ullValue = 1;
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }
    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    WBEMTime& wbemtime )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in wbemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    CHString str;

    // Clear method sets the time in the WBEMTime object to an invalid time.
    wbemtime.Clear();
    try
    {
        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }

        // get the value of the property
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) )
        {   // Error is already set in 'PropertyGet' function.
            return FALSE;
        }

        // convert into the time value
        wbemtime = _bstr_t( str );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    SYSTEMTIME& systime )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in systemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // local variables
    CHString strTime;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // get the value of the property
        // 16010101000000.000000+000 is the default time
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) )
        {   // Error is already set.
            return FALSE;
        }

        // prepare the systemtime structure
        // yyyymmddHHMMSS.mmmmmmsUUU
        // NOTE: NO NEED CALL 'IsNumeric()' BEFORE 'AsLong'.
        // Left and MID methods can throw an exception.
        systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
        systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
        systime.wDayOfWeek = 0;
        systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
        systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
        systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
        systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
        systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );

    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    _variant_t& varValue
    )
/*++

Routine Description:

    Sets the value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] WBEMTime               :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    VARIANT var;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // put the value
        var = varValue;
        hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // return the result
    return hr;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    LPCWSTR pwszValue
    )
/*++

Routine Description:

    Sets the string value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] LPCWSTR                :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    _variant_t varValue;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) ||
         ( NULL == pwszValue ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = pwszValue;
        SAFE_EXECUTE( PropertyPut( pWmiObject, pwszProperty, varValue ) );
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // return
    return hr;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    DWORD dwValue
    )
/*++

Routine Description:

    Sets the dword value of the property to the WMI class object.

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] DWORD                  :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    _variant_t varValue;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = ( LONG )dwValue;
        SAFE_EXECUTE( PropertyPut( pWmiObject, pwszProperty, varValue ) );
    }
    catch( _com_error& e )
    {
        return e.Error();
    }

    // return
    return S_OK;
}


HRESULT
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    LPCWSTR pwszMethod,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    _variant_t& varValue
    )
/*++

Routine Description:

    This function retrieves the value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] LPCWSTR                :   the name of the method to execute
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [in] _variant_t             :   variable holding the property value retrieved

Return Value:

    TRUE on success
    FALSE on failure

NOTE: Pass arguments of type mentioned in declaration of this function.
      EX: Don't pass 'CHString' argument if 'LPWSTR' is expected.
      Reason: 'CHString' can throw an exception of type 'CHEAP_EXCEPTION'
               which is not handled by this function.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    DWORD dwReturnValue = 0;
    IWbemClassObject* pClass = NULL;
    IWbemClassObject* pMethod = NULL;
    IWbemClassObject* pInParams = NULL;
    IWbemClassObject* pInParamsInstance = NULL;
    IWbemClassObject* pOutParamsInstance = NULL;

    // check the input value
    if ( ( NULL == pWbemServices == NULL ) ||
         ( NULL == pwszMethod ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // NOTE: If SAFE_EXECUTE( pWbemServices->GetObject(
    //       _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
    //       is executed then,
    //       NO NEED TO CHECK FOR ( PCLASS == NULL ) SINCE IN ALL CASES
    //       OF ERROR THIS VARIABLE WILL BE NULL.

    try
    {
        // get the registry class object
        SAFE_EXECUTE( pWbemServices->GetObject(
            _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );

        // get the method reference required
        SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );

        // create the instance for the in parameters
        SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );

        // set the input values
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey ) );
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName ) );
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName ) );

        // now execute the method
        SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
            _bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
        if ( NULL == pOutParamsInstance )           // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // now check the return value of the method from the output params object
        bResult = PropertyGet( pOutParamsInstance,
            _bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
        if ( ( FALSE == bResult ) ||
             ( 0 != dwReturnValue ) )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // Comapre string and take appropriate action.
        if ( 0 == StringCompare( pwszMethod, WMI_REGISTRY_M_DWORDVALUE, TRUE, 0 ) )
        {
            SAFE_EXECUTE( PropertyGet( pOutParamsInstance,
                                       _bstr_t( WMI_REGISTRY_OUT_VALUE_DWORD ), varValue ) );
        }
        else
        {
            SAFE_EXECUTE( PropertyGet( pOutParamsInstance,
                                       _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue ) );
        }
    }
    catch( _com_error& e )
    {
		SAFE_RELEASE( pClass );
		SAFE_RELEASE( pMethod );
		SAFE_RELEASE( pInParams );
		SAFE_RELEASE( pInParamsInstance );
		SAFE_RELEASE( pOutParamsInstance );
        hr = e.Error();
    }

    // release the interfaces
    SAFE_RELEASE( pClass );
    SAFE_RELEASE( pMethod );
    SAFE_RELEASE( pInParams );
    SAFE_RELEASE( pInParamsInstance );
    SAFE_RELEASE( pOutParamsInstance );

    // return success
    return hr;
}


BOOL
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    CHString& strValue,
    LPCWSTR pwszDefault
    )
/*++

Routine Description:

    This function retrieves the string value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] CHString              :   variable holding the property value retrieved
    [in] LPCWSTR                :   the default value for this property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

      This function won't return values if they are obtained as reference
      from WMI.
      EX: 'VARTYPE' recieved is of type 'VT_BSTR | VT_BYREF' then FALSE is
           returned.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varValue;

    // Check the input
    if ( ( NULL == pWbemServices ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // Set the default value
        if ( NULL != pwszDefault )
        {
            strValue = pwszDefault;
        }

        // Get the value
        hr = RegQueryValueWMI( pWbemServices,
            WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // Get the value from the variant
        // Get the value
        if ( VT_BSTR == V_VT( &varValue ) )
        {
            strValue = (LPCWSTR)_bstr_t( varValue );
        }
        else
        {
            // Requested type is not found.
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {   // Exception throw by '_variant_t'.
        WMISaveError( e );
        return FALSE;
    }

    // return success
    return TRUE;
}


DWORD
GetTargetVersionEx(
    IWbemServices* pWbemServices,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function gets the version of the system from which we are trying to retrieve
    information from.

Arguments:

    [in] IWbemServices      :   pointer to the IWbemServices object
    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    DWORD   -   Target version of the machine if found else 0.

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    LONG lPos = 0;
    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwVersion = 0;
    ULONG ulReturned = 0;
    CHString strVersion;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;

    // Check the input value
    if ( NULL == pWbemServices )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return 0;
    }

    try
    {
        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum(
            _bstr_t( CLASS_CIMV2_Win32_OperatingSystem ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time.
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( 0 == ulReturned )
        {
            // release the interfaces
            WMISaveError( WBEM_S_FALSE );
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( FALSE == PropertyGet( pWbemObject, L"Version", strVersion ) )
        {
            // release the interfaces
            // Error is already set in the called function.
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );

        //
        // now determine the os version
        dwMajor = dwMinor = 0;

        // Get the major version
        lPos = strVersion.Find( L'.' );
        if ( -1 == lPos )
        {
            // The version string itself is version ... THIS WILL NEVER HAPPEN
            if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion, 10 );
        }
        else
        {
            // major version
            if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

            // get the minor version
            strVersion = strVersion.Mid( lPos + 1 );
            lPos = strVersion.Find( L'.' );
            if ( -1 == lPos)
            {
                if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion, 10 );
            }
            else
            {
                if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
            }
        }

        // mix the version info
        dwVersion = dwMajor * 1000 + dwMinor;
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }

    // If successful then 'pWbemObject' and 'pWbemInstances' are already released.
    // return
    return dwVersion;
}


DWORD
GetTargetPlatformEx(
    IWbemServices* pWbemServices,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function gets the version of the system from which we are trying to retrieve
    information from.

Arguments:

    [in] IWbemServices      :   pointer to the IWbemServices object
    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    DWORD   -   Target version of the machine if found else 0.

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString strType;
    ULONG ulReturned = 0;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;

    // Check the input value
    if ( NULL == pWbemServices )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return 0;
    }

    try
    {
        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum(
            _bstr_t( CLASS_CIMV2_Win32_ComputerSystem ), 0, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time.
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( 0 == ulReturned )
        {
            // release the interfaces
            WMISaveError( WBEM_S_FALSE );
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( FALSE == PropertyGet( pWbemObject, L"SystemType", strType ) )
        {
            // release the interfaces
            // Error is already set in the called function.
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );

        // determine the type of the platform
        if ( -1 != strType.Find( TEXT_X86 ) )
        {
            return PLATFORM_X86;
        }
        else
        {
            if ( -1 != strType.Find( TEXT_IA64 ) )
            {
                return PLATFORM_IA64;
            }
            else
            {
                if ( -1 != strType.Find( TEXT_AMD64 ) )
                {
                    return PLATFORM_AMD64;
                }
            }
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }

    // return
    return PLATFORM_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\wmi.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      WMI.h
//
//  Abstract:
//
//      Common functionality for WMI
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )    \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \
    1

#define SAFE_EXECUTE( statement )               \
    hr = statement;     \
    if ( FAILED( hr ) ) \
    {   \
        _com_issue_error( hr ); \
    }   \
    1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2     L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT   L"root\\default"

#define WMI_CLAUSE_AND          L"AND"
#define WMI_CLAUSE_OR           L"OR"
#define WMI_CLAUSE_WHERE        L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem   L"Win32_OperatingSystem"
#define CLASS_CIMV2_Win32_ComputerSystem    L"Win32_ComputerSystem"

#define WMI_REGISTRY                    L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE      L"GetStringValue"
#define WMI_REGISTRY_M_DWORDVALUE       L"GetDwordValue"

#define WMI_REGISTRY_IN_HDEFKEY         L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY          L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME       L"sValueName"
#define WMI_REGISTRY_OUT_VALUE          L"sValue"
#define WMI_REGISTRY_OUT_VALUE_DWORD    L"uValue"
#define WMI_REGISTRY_OUT_RETURNVALUE    L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT               2147483648
#define WMI_HKEY_CURRENT_USER               2147483649
#define WMI_HKEY_LOCAL_MACHINE              2147483650
#define WMI_HKEY_USERS                      2147483651
#define WMI_HKEY_CURRENT_CONFIG             2147482652

#define PLATFORM_UNKNOWN                0
#define PLATFORM_X86                    1
#define PLATFORM_IA64                   2
#define PLATFORM_AMD64                  3

#define TEXT_X86                        L"X86"
#define TEXT_IA64                       L"IA64"
#define TEXT_AMD64                      L"AMD64"

// messages
// #define ERROR_COM_ERROR                  GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator,
                 IWbemServices** ppServices,
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword,
                 COAUTHIDENTITY** ppAuthIdentity,
                 BOOL bCheckWithNullPwd = FALSE,
                 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2,
                 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL, IWbemContext* pWbemContext = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator,
                   IWbemServices** ppServices,
                   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword,
                   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE,
                   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL,
                   DWORD dwPasswordLen = 0, IWbemContext* pWbemContext = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject,
                     LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,
                  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  BOOL& dwValue, BOOL bDefault = FALSE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
DWORD GetTargetPlatformEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey,
                       LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName,
                       CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices,
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName,
                       LPCWSTR pwszValueName, DWORD& dwValue, DWORD dwDefault = 0 );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, CHString& strValue,
                                VARTYPE vartype );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex,
                                IWbemClassObject **pScriptObject, VARTYPE vartype );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//
// Arguments:
//
// Return Value:
//
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
    WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\resource.h ===
#define IDS_COLHEAD_HOSTNAME                101
#define IDS_COLHEAD_STATUS                  102
#define IDS_COLHEAD_IMAGENAME               103
#define IDS_COLHEAD_PID                     104
#define IDS_COLHEAD_SESSION                 105
#define IDS_COLHEAD_USERNAME                106
#define IDS_COLHEAD_WINDOWTITLE             107
#define IDS_COLHEAD_CPUTIME                 108
#define IDS_COLHEAD_MEMUSAGE                109
#define IDS_COLHEAD_SERVICES                110
#define IDS_COLHEAD_SESSIONNAME             111
#define IDS_COLHEAD_MODULES                 112

#define IDS_TEXT_FORMAT_LIST                126
#define IDS_TEXT_FORMAT_TABLE               127
#define IDS_TEXT_FORMAT_CSV                 128
#define IDS_OVALUES_FORMAT                  129

#define IDS_COLWIDTH_HOSTNAME               151
#define IDS_COLWIDTH_STATUS                 152
#define IDS_COLWIDTH_IMAGENAME              153
#define IDS_COLWIDTH_PID                    154
#define IDS_COLWIDTH_SESSION                155
#define IDS_COLWIDTH_USERNAME               156
#define IDS_COLWIDTH_WINDOWTITLE            157
#define IDS_COLWIDTH_CPUTIME                158
#define IDS_COLWIDTH_MEMUSAGE               159
#define IDS_COLWIDTH_SERVICES               160
#define IDS_COLWIDTH_SERVICES_WRAP          161
#define IDS_COLWIDTH_SESSIONNAME            162
#define IDS_COLWIDTH_MODULES                163
#define IDS_COLWIDTH_MODULES_WRAP           164

#define IDS_FILTER_SESSIONNAME              201
#define IDS_FILTER_STATUS                   202
#define IDS_FILTER_IMAGENAME                203
#define IDS_FILTER_PID                      204
#define IDS_FILTER_SESSION                  205
#define IDS_FILTER_CPUTIME                  206
#define IDS_FILTER_MEMUSAGE                 207
#define IDS_FILTER_USERNAME                 208
#define IDS_FILTER_SERVICES                 209
#define IDS_FILTER_WINDOWTITLE              210
#define IDS_FILTER_MODULES                  211

#define IDS_FVALUES_STATUS                  226

#define IDS_OPERATORS_STRING                227
#define IDS_OPERATORS_NUMERIC               228

#define IDS_VALUE_RUNNING                   251
#define IDS_VALUE_NOTRESPONDING             252
#define IDS_FMT_KILOBYTE                    253
#define IDS_PID_0_DOMAIN                    254
#define IDS_PID_0_USERNAME                  255
#define IDS_FMT_MODULES_FILTER              256
#define IDS_VALUE_UNKNOWN                   257

#define IDS_ERROR_USERNAME_BUT_NOMACHINE    501
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME   502
#define IDS_ERROR_NODATA_AVAILABLE          503
#define IDS_ERROR_COM_ERROR                 504
#define IDS_ERROR_USERNAME_EMPTY            505
#define IDS_ERROR_NH_NOTSUPPORTED           506
#define IDS_ERROR_M_SVC_V_CANNOTBECOUPLED   507
#define IDS_ERROR_SERVERNAME_EMPTY          508
#define IDS_ERROR_INVALID_USAGE_REQUEST     509
#define IDS_ERROR_M_CHAR_AFTER_WILDCARD     510

#define IDS_WARNING_FILTERNOTSUPPORTED      551

#define IDS_HELP_LINE1                  1001
#define IDS_HELP_LINE2                  1002
#define IDS_HELP_LINE3                  1003
#define IDS_HELP_LINE4                  1004
#define IDS_HELP_LINE5                  1005
#define IDS_HELP_LINE6                  1006
#define IDS_HELP_LINE7                  1007
#define IDS_HELP_LINE8                  1008
#define IDS_HELP_LINE9                  1009
#define IDS_HELP_LINE10                 1010
#define IDS_HELP_LINE11                 1011
#define IDS_HELP_LINE12                 1012
#define IDS_HELP_LINE13                 1013
#define IDS_HELP_LINE14                 1014
#define IDS_HELP_LINE15                 1015
#define IDS_HELP_LINE16                 1016
#define IDS_HELP_LINE17                 1017
#define IDS_HELP_LINE18                 1018
#define IDS_HELP_LINE19                 1019
#define IDS_HELP_LINE20                 1020
#define IDS_HELP_LINE21                 1021
#define IDS_HELP_LINE22                 1022
#define IDS_HELP_LINE23                 1023
#define IDS_HELP_LINE24                 1024
#define IDS_HELP_LINE25                 1025
#define IDS_HELP_LINE26                 1026
#define IDS_HELP_LINE27                 1027
#define IDS_HELP_LINE28                 1028
#define IDS_HELP_LINE29                 1029
#define IDS_HELP_LINE30                 1030
#define IDS_HELP_LINE31                 1031
#define IDS_HELP_LINE32                 1032
#define IDS_HELP_LINE33                 1033
#define IDS_HELP_LINE34                 1034
#define IDS_HELP_LINE35                 1035
#define IDS_HELP_LINE36                 1036
#define IDS_HELP_LINE37                 1037
#define IDS_HELP_LINE38                 1038
#define IDS_HELP_LINE39                 1039
#define IDS_HELP_LINE40                 1040
#define IDS_HELP_LINE41                 1041
#define IDS_HELP_LINE42                 1042
#define IDS_HELP_LINE43                 1043
#define IDS_HELP_LINE44                 1044
#define IDS_HELP_LINE45                 1045
#define IDS_HELP_LINE46                 1046
#define IDS_HELP_LINE47                 1047
#define IDS_HELP_LINE48                 1048
#define IDS_HELP_LINE49                 1049
#define IDS_HELP_LINE50                 1050
#define IDS_HELP_LINE51                 1051
#define IDS_HELP_LINE52                 1052
#define IDS_HELP_LINE53                 1053
#define IDS_HELP_LINE54                 1054
#define IDS_HELP_LINE55                 1055
#define IDS_HELP_LINE56                 1056
#define IDS_HELP_LINE57                 1057
#define IDS_HELP_LINE58                 1058
#define IDS_HELP_LINE59                 1059
#define IDS_HELP_LINE60                 1060
#define IDS_HELP_LINE61                 1061
#define IDS_HELP_LINE62                 1062

// usage indexes into the string table
#define ID_HELP_START       IDS_HELP_LINE1
#define ID_HELP_END         IDS_HELP_LINE62
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\parse.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      parse.cpp
//
//  Abstract:
//
//      This module implements the command-line parsing and validating the filters
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Nov-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Nov-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "tasklist.h"

#define MAX_OPERATOR_STRING      101
#define MAX_FILTER_PROP_STRING   256
//
// local function prototypes
//
BOOL
TimeFieldsToElapsedTime(
    IN LPCWSTR pwszTime,
    IN LPCWSTR pwszToken,
    OUT ULONG& ulElapsedTime
    );

DWORD
FilterUserName(
    IN LPCWSTR pwszProperty,
    IN LPCWSTR pwszOperator,
    IN LPCWSTR pwszValue,
    IN LPVOID pData,
    IN TARRAY arrRow
    );

DWORD
FilterCPUTime(
    IN LPCWSTR pwszProperty,
    IN LPCWSTR pwszOperator,
    IN LPCWSTR pwszValue,
    IN LPVOID pData,
    IN TARRAY arrRow
    );


BOOL
CTaskList::ProcessOptions(
    IN DWORD argc,
    IN LPCTSTR argv[]
    )
/*++
Routine Description:
      processes and validates the command line inputs

Arguments:
      [ in ] argc          : no. of input arguments specified
      [ in ] argv          : input arguments specified at command prompt

Return Value:
      TRUE  : if inputs are valid
      FALSE : if inputs were errorneously specified
--*/
{
    // local variables
    BOOL bNoHeader = FALSE;
    PTCMDPARSER2 pcmdOptions = NULL;
    WCHAR szFormat[ 64 ] = NULL_STRING;

    // temporary local variables
    PTCMDPARSER2 pOption = NULL;
    PTCMDPARSER2 pOptionServer = NULL;
    PTCMDPARSER2 pOptionUserName = NULL;
    PTCMDPARSER2 pOptionPassword = NULL;

    //
    // prepare the command options
    pcmdOptions = ( PTCMDPARSER2 )AllocateMemory( sizeof( TCMDPARSER2 ) * MAX_OPTIONS );
    if ( NULL == pcmdOptions )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // initialize to ZERO's
    SecureZeroMemory( pcmdOptions, MAX_OPTIONS * sizeof( TCMDPARSER2 ) );

    // -?
    pOption = pcmdOptions + OI_USAGE;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pwszOptions = OPTION_USAGE;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP_USAGE;
    pOption->pValue = &m_bUsage;
    pOption->dwLength    = 0;

    // -s
    pOption = pcmdOptions + OI_SERVER;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_SERVER;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->pValue = NULL;
    pOption->dwLength    = 0;

    // -u
    pOption = pcmdOptions + OI_USERNAME;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_USERNAME;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->pValue = NULL;
    pOption->dwLength    = 0;

    // -p
    pOption = pcmdOptions + OI_PASSWORD;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_PASSWORD;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    pOption->pValue = NULL;
    pOption->dwLength    = 0;

    // -fi
    pOption = pcmdOptions + OI_FILTER;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_FILTER;
    pOption->dwCount = 0;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP_TYPE_TEXT | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->pValue = &m_arrFilters;
    pOption->dwLength    = 0;

    // -fo
    pOption = pcmdOptions + OI_FORMAT;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_FORMAT;
    pOption->pwszValues = GetResString(IDS_OVALUES_FORMAT);
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_MODE_VALUES  | CP2_VALUE_TRIMINPUT|
                       CP2_VALUE_NONULL;
    pOption->pValue = szFormat;
    pOption->dwLength    = MAX_STRING_LENGTH;

    // -nh
    pOption = pcmdOptions + OI_NOHEADER;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pwszOptions = OPTION_NOHEADER;
    pOption->pwszValues = NULL;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = 0;
    pOption->pValue = &bNoHeader;
    pOption->dwLength = 0;

    // -v
    pOption = pcmdOptions + OI_VERBOSE;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pwszOptions = OPTION_VERBOSE;
    pOption->pwszValues = NULL;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = 0;
    pOption->pValue = &m_bVerbose;
    pOption->dwLength = 0;

    // -svc
    pOption = pcmdOptions + OI_SVC;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pwszOptions = OPTION_SVC;
    pOption->pwszValues = NULL;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = 0;
    pOption->pValue = &m_bAllServices;
    pOption->dwLength = 0;

    // -m
    pOption = pcmdOptions + OI_MODULES;
    StringCopyA( pOption->szSignature, "PARSER2\0", 8 );
    pOption->dwType = CP_TYPE_TEXT;
    pOption->pwszOptions = OPTION_MODULES;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP2_VALUE_OPTIONAL | CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pOption->pValue = NULL;
    pOption->dwLength = 0;

    //
    // do the parsing
    if ( DoParseParam2( argc, argv, -1, MAX_OPTIONS, pcmdOptions, 0 ) == FALSE )
    {
        FreeMemory( (LPVOID * )&pcmdOptions );  // clear memory
        return FALSE;           // invalid syntax
    }

    //
    // now, check the mutually exclusive options
    pOptionServer = pcmdOptions + OI_SERVER;
    pOptionUserName = pcmdOptions + OI_USERNAME;
    pOptionPassword = pcmdOptions + OI_PASSWORD;

    try
    {
        // release the buffers
        m_strServer   = (LPWSTR)pOptionServer->pValue;
        m_strUserName = (LPWSTR)pOptionUserName->pValue;
        m_strPassword = (LPWSTR)pOptionPassword->pValue;
        if( NULL == (LPWSTR)pOptionPassword->pValue )
        {
            m_strPassword = L"*";
        }
        m_strModules =  (LPWSTR)pcmdOptions[ OI_MODULES ].pValue;

        FreeMemory( &pOptionServer->pValue );
        FreeMemory( &pOptionUserName->pValue );
        FreeMemory( &pOptionPassword->pValue );
        FreeMemory( &( pcmdOptions[ OI_MODULES ].pValue ) );

        // check the usage option
        if ( TRUE == m_bUsage )
        {   // -? is specified.
            if( 2 < argc )
            {
                // no other options are accepted along with -? option
                SetLastError( ( DWORD )MK_E_SYNTAX );
                SetReason( ERROR_INVALID_USAGE_REQUEST );
                FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                return FALSE;
            }
            else
            {
                // should not do the furthur validations
                FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                return TRUE;
            }
        }

        // Without -s, -u and -p should not be specified.
        // With -s, -u can be specified, but without -u, -p should not be specified.
        if( 0 != pOptionServer->dwActuals )
        {
            if( ( 0 == pOptionUserName->dwActuals ) && ( 0 != pOptionPassword->dwActuals ) )
            {
                 // invalid syntax
                SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
                FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                return FALSE;           // indicate failure
            }
        }
        else
        {   // -s is not specified.
            if( 0 != pOptionUserName->dwActuals )
            {   // -u without -s.
                 // invalid syntax
                SetReason( ERROR_USERNAME_BUT_NOMACHINE );
                FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                return FALSE;           // indicate failure
            }
            else
            {   // -p without -s.
                if( 0 != pOptionPassword->dwActuals )
                {
                     // invalid syntax
                    SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
                    FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                    return FALSE;           // indicate failure
                }
            }
        }

        // check whether user has specified modules or not
        if ( 0 != pcmdOptions[ OI_MODULES ].dwActuals )
        {
            // user has specified modules information
            m_bAllModules = TRUE;
            m_bNeedModulesInfo = TRUE;

            // now need to check whether user specified value or not this option
            if ( 0 != m_strModules.GetLength() )
            {
                // sub-local variales
                CHString str;
                LONG lPos = 0;

                // validate the modules .. direct filter
                // if should not have '*' character in between
                lPos = m_strModules.Find( L"*" );
                if ( ( -1 != lPos ) && ( 0 != m_strModules.Mid( lPos + 1 ).GetLength() ) )
                {
                    SetReason( ERROR_M_CHAR_AFTER_WILDCARD );
                    FreeMemory( (LPVOID * )&pcmdOptions );
                    return FALSE;
                }

                // if the wildcard is not specified, it means user is looking for just a particular module name
                // so, do not show the modules info instead show the filtered regular information

                // if the filter specified is not just '*' add a custom filter
                if ( 0 != m_strModules.Compare( L"*" ) )
                {
                    // prepare the search string
                    str.Format( FMT_MODULES_FILTER, m_strModules );

                    // add the value to the filters list
                    if ( -1 == DynArrayAppendString( m_arrFilters, str, 0 ) )
                    {
                        SetLastError( ( DWORD )E_OUTOFMEMORY );
                        SaveLastError();
                        FreeMemory( (LPVOID * )&pcmdOptions );
                        return FALSE;
                    }
                }
                else
                {
                    // user specified just '*' ... clear the contents
                    m_strModules.Empty();
                }
            }
        }

        // determine the format in which the process information has to be displayed
        // Validation on 'm_dwFormat' variable is done at 'DoParseParam2'.
        m_dwFormat = SR_FORMAT_TABLE;
        // By default TABLE format is taken.
        if ( 0 == StringCompare( szFormat, TEXT_FORMAT_LIST, TRUE, 0 ) )
        {   // List
            m_dwFormat = SR_FORMAT_LIST;
        }
        else
        {
            if ( 0 == StringCompare( szFormat, TEXT_FORMAT_CSV,  TRUE, 0 ) )
            {   // CSV
                m_dwFormat = SR_FORMAT_CSV;
            }
        }

        // -nh option is not valid of LIST format
        if ( ( TRUE == bNoHeader ) && ( SR_FORMAT_LIST == m_dwFormat ) )
        {
            // invalid syntax
            SetReason( ERROR_NH_NOTSUPPORTED );
            FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
            return FALSE;           // indicate failure
        }

        // identify output format
        if ( TRUE == bNoHeader )
        {
            m_dwFormat |= SR_NOHEADER;      // do not display the header
        }

        // determine whether we need to get the services / username info or not
        {
            DWORD dwMutuallyExclusive = 0;

            // -svc is specified.
            if( TRUE == m_bAllServices )
            {
                dwMutuallyExclusive += 1;
                m_bNeedServicesInfo = TRUE;
            }
            // -m is specified.
            if( TRUE == m_bAllModules )
            {
                dwMutuallyExclusive += 1;
            }
            // -v is specified.
            if( TRUE == m_bVerbose )
            {
                dwMutuallyExclusive += 1;
                m_bNeedWindowTitles = TRUE;
                m_bNeedUserContextInfo = TRUE;
            }

            // -svc, -m and -v should not appear together.
            if ( ( 0 != dwMutuallyExclusive ) && ( 1 < dwMutuallyExclusive ) )
            {
                // invalid syntax
                SetReason( ERROR_M_SVC_V_CANNOTBECOUPLED );
                FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
                return FALSE;           // indicate failure
            }
        }

        // check whether caller should accept the password or not
        // if user has specified -s (or) -u and no "-p", then utility should accept password
        // the user will be prompter for the password only if establish connection
        // is failed without the credentials information
        if ( 0 != pOptionPassword->dwActuals)
        {
            if( 0 == m_strPassword.Compare( L"*" ) )
            {
                // user wants the utility to prompt for the password before trying to connect
                m_bNeedPassword = TRUE;
            }
            else
            {
                if( NULL == (LPCWSTR)m_strPassword )
                {
                    m_strPassword = L"*";
                    // user wants the utility to prompt for the password before trying to connect
                    m_bNeedPassword = TRUE;
                }
            }
        }
        else
        {
            // utility needs to try to connect first and if it fails then prompt for the password
            m_bNeedPassword = TRUE;
            m_strPassword.Empty();
        }
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        FreeMemory( (LPVOID * )&pcmdOptions );
        return FALSE;
    }

    // command-line parsing is successfull
    FreeMemory( (LPVOID * )&pcmdOptions );      // clear the cmd parser config info
    return TRUE;
}

BOOL
CTaskList::ValidateFilters(
    void
    )
/*++
Routine Description:
      validates the filter information specified with -filter option

Arguments:
      NONE

Return Value:
      TRUE    : if filters are appropriately specified
      FALSE   : if filters are errorneously specified
--*/
{
    // local variables
    LONG lIndex = -1;
    BOOL bResult = FALSE;
    PTFILTERCONFIG pConfig = NULL;

    //
    // prepare the filter structure

    // sessionname
    pConfig = m_pfilterConfigs + FI_SESSIONNAME;
    pConfig->dwColumn = CI_SESSIONNAME;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_SESSIONNAME, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // status
    pConfig = m_pfilterConfigs + FI_STATUS;
    pConfig->dwColumn = CI_STATUS;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_VALUES;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_STATUS, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, FVALUES_STATUS, MAX_FILTER_PROP_STRING );

    // imagename
    pConfig = m_pfilterConfigs + FI_IMAGENAME;
    pConfig->dwColumn = CI_IMAGENAME;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_IMAGENAME, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // pid
    pConfig = m_pfilterConfigs + FI_PID;
    pConfig->dwColumn = CI_PID;
    pConfig->dwFlags = F_TYPE_UNUMERIC;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_NUMERIC, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_PID, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // session
    pConfig = m_pfilterConfigs + FI_SESSION;
    pConfig->dwColumn = CI_SESSION;
    pConfig->dwFlags = F_TYPE_UNUMERIC;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_NUMERIC, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_SESSION, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // cputime
    pConfig = m_pfilterConfigs + FI_CPUTIME;
    pConfig->dwColumn = CI_CPUTIME;
    pConfig->dwFlags = F_TYPE_CUSTOM;
    pConfig->pFunction = FilterCPUTime;
    pConfig->pFunctionData = ( LPVOID) ((LPCWSTR) m_strTimeSep);
    StringCopy( pConfig->szOperators, OPERATORS_NUMERIC, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_CPUTIME, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // memusage
    pConfig = m_pfilterConfigs + FI_MEMUSAGE;
    pConfig->dwColumn = CI_MEMUSAGE;
    pConfig->dwFlags = F_TYPE_UNUMERIC;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_NUMERIC, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_MEMUSAGE, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // username
    pConfig = m_pfilterConfigs + FI_USERNAME;
    pConfig->dwColumn = CI_USERNAME;
    pConfig->dwFlags = F_TYPE_CUSTOM;
    pConfig->pFunction = FilterUserName;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_USERNAME, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // services
    pConfig = m_pfilterConfigs + FI_SERVICES;
    pConfig->dwColumn = CI_SERVICES;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN | F_MODE_ARRAY;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_SERVICES, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // windowtitle
    pConfig = m_pfilterConfigs + FI_WINDOWTITLE;
    pConfig->dwColumn = CI_WINDOWTITLE;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_WINDOWTITLE, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    // modules
    pConfig = m_pfilterConfigs + FI_MODULES;
    pConfig->dwColumn = CI_MODULES;
    pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN | F_MODE_ARRAY;
    pConfig->pFunction = NULL;
    pConfig->pFunctionData = NULL;
    StringCopy( pConfig->szOperators, OPERATORS_STRING, MAX_OPERATOR_STRING );
    StringCopy( pConfig->szProperty, FILTER_MODULES, MAX_FILTER_PROP_STRING );
    StringCopy( pConfig->szValues, NULL_STRING, MAX_FILTER_PROP_STRING );

    //
    // validate the filter
    bResult = ParseAndValidateFilter( MAX_FILTERS,
        m_pfilterConfigs, m_arrFilters, &m_arrFiltersEx );

    // check the filter validation result
    if ( FALSE == bResult )
    {
        return FALSE;
    }
    // find out whether user has requested for the tasks to be filtered
    // on user context and/or services are not ... if yes, set the appropriate flags
    // this check is being done to increase the performance of the utility
    // NOTE: we will be using the parsed filters info for doing this

    // window titles
    if ( FALSE == m_bNeedWindowTitles )
    {
        // find out if the filter property exists in this row
        // NOTE:-
        //        filter property do exists in the seperate indexes only.
        //        refer to the logic of validating the filters in common functionality
        lIndex = DynArrayFindStringEx( m_arrFiltersEx,
            F_PARSED_INDEX_PROPERTY, FILTER_WINDOWTITLE, TRUE, 0 );
        if ( -1 != lIndex )
        {
            m_bNeedWindowTitles = TRUE;
        }
    }

    // status
    if ( FALSE == m_bNeedWindowTitles )
    {
        //
        // we will getting the status an application with the help of window title only
        // so, though we search for the STATUS filter, we will make use of the same window titles flag
        //

        // find out if the filter property exists in this row
        // NOTE:-
        //        filter property do exists in the seperate indexes only.
        //        refer to the logic of validating the filters in common functionality
        lIndex = DynArrayFindStringEx( m_arrFiltersEx,
            F_PARSED_INDEX_PROPERTY, FILTER_STATUS, TRUE, 0 );
        if ( -1 != lIndex )
        {
            m_bNeedWindowTitles = TRUE;
        }
    }

    // user context
    if ( FALSE == m_bNeedUserContextInfo )
    {
        // find out if the filter property exists in this row
        // NOTE:-
        //        filter property do exists in the seperate indexes only.
        //        refer to the logic of validating the filters in common functionality
        lIndex = DynArrayFindStringEx( m_arrFiltersEx,
            F_PARSED_INDEX_PROPERTY, FILTER_USERNAME, TRUE, 0 );
        if ( -1 != lIndex )
        {
            m_bNeedUserContextInfo = TRUE;
        }
    }

    // services info
    if ( FALSE == m_bNeedServicesInfo )
    {
        // find out if the filter property exists in this row
        // NOTE:-
        //        filter property do exists in the seperate indexes only.
        //        refer to the logic of validating the filters in common functionality
        lIndex = DynArrayFindStringEx( m_arrFiltersEx,
            F_PARSED_INDEX_PROPERTY, FILTER_SERVICES, TRUE, 0 );
        if ( -1 != lIndex )
        {
            m_bNeedServicesInfo = TRUE;
        }
    }

    // modules info
    if ( FALSE == m_bNeedModulesInfo )
    {
        // find out if the filter property exists in this row
        // NOTE:-
        //        filter property do exists in the seperate indexes only.
        //        refer to the logic of validating the filters in common functionality
        lIndex = DynArrayFindStringEx( m_arrFiltersEx,
            F_PARSED_INDEX_PROPERTY, FILTER_MODULES, TRUE, 0 );
        if ( -1 != lIndex )
        {
            m_bNeedModulesInfo = TRUE;
        }
    }

    //
    // do the filter optimization by adding the wmi properties to the query
    //
    // NOTE: as the 'handle' property of the Win32_Process class is string type
    //       we cannot include that in the wmi query for optimization. So make use
    //       of the ProcessId property
    LONG lCount = 0;
    CHString strBuffer;
    BOOL bOptimized = FALSE;
    LPCWSTR pwszValue = NULL;
    LPCWSTR pwszClause = NULL;
    LPCWSTR pwszProperty = NULL;
    LPCWSTR pwszOperator = NULL;

    try
    {
        // first clause .. and init
        m_strQuery = WMI_PROCESS_QUERY;
        pwszClause = WMI_QUERY_FIRST_CLAUSE;

        // get the no. of filters
        lCount = DynArrayGetCount( m_arrFiltersEx );

        // traverse thru all the filters and do the optimization
        for( LONG i = 0; i < lCount; i++ )
        {
            // assume this filter will not be delete / not useful for optimization
            bOptimized = FALSE;

            // get the property, operator and value
            pwszValue = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_VALUE );
            pwszProperty = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_PROPERTY );
            pwszOperator = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_OPERATOR );
            if ( ( NULL == pwszProperty ) ||
                 ( NULL == pwszOperator ) ||
                 ( NULL == pwszValue ) )
            {
                SetLastError( ( DWORD )STG_E_UNKNOWN );
                SaveLastError();
                return FALSE;
            }

            //
            // based on the property do optimization needed

            // get the mathematically equivalent operator
            pwszOperator = FindOperator( pwszOperator );

            // process id
            if ( 0 == StringCompare( FILTER_PID, pwszProperty, TRUE, 0 ) )
            {
                // convert the value into numeric
                DWORD dwProcessId = AsLong( pwszValue, 10 );
                strBuffer.Format( L" %s %s %s %d",
                    pwszClause, WIN32_PROCESS_PROPERTY_PROCESSID, pwszOperator, dwProcessId );

                // need to be optimized
                bOptimized = TRUE;
            }

            // session id
            else if ( 0 == StringCompare( FILTER_SESSION, pwszProperty, TRUE, 0 ) )
            {
                // convert the value into numeric
                DWORD dwSession = AsLong( pwszValue, 10 );
                strBuffer.Format( L" %s %s %s %d",
                    pwszClause, WIN32_PROCESS_PROPERTY_SESSION, pwszOperator, dwSession );

                // need to be optimized
                bOptimized = TRUE;
            }

            // image name
            else if ( 0 == StringCompare( FILTER_IMAGENAME, pwszProperty, TRUE, 0 ) )
            {
                // check if wild card is specified or not
                // if wild card is specified, this filter cannot be optimized
                if ( NULL == wcschr( pwszValue, _T( '*' ) ) )
                {
                    // no conversions needed
                    strBuffer.Format( L" %s %s %s '%s'",
                        pwszClause, WIN32_PROCESS_PROPERTY_IMAGENAME, pwszOperator, pwszValue );

                    // need to be optimized
                    bOptimized = TRUE;
                }
            }

            // mem usage
            else if ( 0 == StringCompare( FILTER_MEMUSAGE, pwszProperty, TRUE, 0 ) )
            {
                // convert the value into numeric
                ULONG ulMemUsage = AsLong( pwszValue, 10 ) * 1024;
                strBuffer.Format( L" %s %s %s %lu",
                    pwszClause, WIN32_PROCESS_PROPERTY_MEMUSAGE, pwszOperator, ulMemUsage );

                // need to be optimized
                bOptimized = TRUE;
            }

            // check if property is optimizable ... if yes ... remove
            if ( TRUE == bOptimized )
            {
                // change the clause and append the current query
                m_strQuery += strBuffer;
                pwszClause = WMI_QUERY_SECOND_CLAUSE;

                // remove property and update the iterator variables
                DynArrayRemove( m_arrFiltersEx, i );
                i--;
                lCount--;
            }
        }
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        bResult = FALSE;
    }

    // return the filter validation result
    return bResult;
}


BOOL
TimeFieldsToElapsedTime(
    IN LPCWSTR pwszTime,
    IN LPCWSTR pwszToken,
    OUT ULONG& ulElapsedTime
    )
/*++
Routine Description:
    Retrieve elapsed time.

Arguments:
    [ in ] pwszTime       : Contains time string.
    [ in ] pwszToken      : Contains time seperator.
    [ out ] ulElapsedTime : Contains elapsed time.

Return Value:
    TRUE if success else FAIL is returned.
--*/
{
    // local variables
    ULONG ulValue = 0;
    LPCWSTR pwszField = NULL;
    WCHAR szTemp[ 64 ] = NULL_STRING;
    DWORD dwNext = 0, dwLength = 0, dwCount = 0;

    // check the input
    if ( ( NULL == pwszTime ) ||
         ( NULL == pwszToken ) )
    {
        return FALSE;
    }
    // start parsing the time info
    dwNext = 0;
    dwCount = 0;
    ulElapsedTime = 0;
    do
    {
        // search for the needed token
        pwszField = FindString( pwszTime, pwszToken, dwNext );
        if ( NULL == pwszField )
        {
            // check whether some more text exists in the actual string or not
            if ( dwNext >= StringLength( pwszTime, 0 ) )
            {
                break;          // no more info found
            }
            // get the last info
            StringCopy( szTemp, pwszTime + dwNext, SIZE_OF_ARRAY( szTemp ) );
            dwLength = StringLength( szTemp, 0 );            // update the length
        }
        else
        {
            // determine the length of numeric value and get the numeric value
            dwLength = StringLength( pwszTime, 0 ) - StringLength( pwszField, 0 ) - dwNext;

            // check the length info
            if ( dwLength > SIZE_OF_ARRAY( szTemp ) )
            {
                return FALSE;
            }
            // get the current info
            StringCopy( szTemp, pwszTime + dwNext, dwLength );    // +1 for NULL character
        }

        // update the count of fields we are getting
        dwCount++;

        // check whether this field is numeric or not
        if ( ( 0 == StringLength( szTemp, 0 ) ) ||
             ( FALSE == IsNumeric( szTemp, 10, FALSE ) ) )
        {
            return FALSE;
        }
        // from second token onwards, values greater than 59 are not allowed
        ulValue = AsLong( szTemp, 10 );
        if ( ( 1 < dwCount ) && ( 50 < ulValue ) )
        {
            return FALSE;
        }
        // update the elapsed time
        ulElapsedTime = ( ulElapsedTime + ulValue ) * (( dwCount < 3 ) ? 60 : 1);

        // position to the next information start
        dwNext += dwLength + StringLength( pwszToken, 0 );
    } while ( ( NULL != pwszField ) && ( 3 > dwCount ) );

    // check the no. of time field we got .. we should have got 3 .. if not, error
    if ( ( NULL != pwszField ) || ( 3 != dwCount ) )
    {
        return FALSE;
    }
    // so everything went right ... return success
    return TRUE;
}


DWORD
FilterCPUTime(
    IN LPCWSTR pwszProperty,
    IN LPCWSTR pwszOperator,
    IN LPCWSTR pwszValue,
    IN LPVOID pData,
    IN TARRAY arrRow
    )
/*++
Routine Description:
    Filter process to display with resepect  their CPU time.

Arguments:
    [ in ] pwszProperty   : Contains property value as 'CPUTIME'.
    [ in ] pwszOperator   : Contains operator as 'gt'or 'lt' or 'ge' or 'le'.
    [ in ] pwszValue      : Contains value to filter.
    [ in ] pData          : Contains data to compare.
    [ in ] arrRow         : Contains item value to filter.

Return Value:
    DWORD

--*/
{
    // local variables
    ULONG ulCPUTime = 0;
    ULONG ulElapsedTime = 0;
    LPCWSTR pwszCPUTime = NULL;

    // if the arrRow parameter is NULL, we need to validate the filter
    if ( NULL == arrRow )
    {
        // check if there are any arthemtic sysbols before the cputime value starts
        if ( ( NULL != pwszValue ) && ( 1 < StringLength( pwszValue, 0 ) ) )
        {
            if ( ( L'-' == pwszValue[ 0 ] ) || ( L'+' == pwszValue[ 0 ] ) )
            {
                return F_FILTER_INVALID;
            }
        }

        // validate the filter value and return the result
        if ( FALSE == TimeFieldsToElapsedTime( pwszValue, L":", ulElapsedTime ) )
        {
            return F_FILTER_INVALID;
        }
        else
        {
            return F_FILTER_VALID;
        }
    }

    // get the filter value
    TimeFieldsToElapsedTime( pwszValue, L":", ulElapsedTime );

    // get the record value
    pwszCPUTime = DynArrayItemAsString( arrRow, TASK_CPUTIME );
    if ( NULL == pwszCPUTime )
    {
        return F_RESULT_REMOVE;
    }
    // convert the record value into elapsed time value
    TimeFieldsToElapsedTime( pwszCPUTime, (LPCWSTR) pData, ulCPUTime );

    // return the result
    if ( ulCPUTime == ulElapsedTime )
    {
        return MASK_EQ;
    }
    else
    {
        if ( ulCPUTime < ulElapsedTime )
        {
            return MASK_LT;
        }
        else
        {
            if ( ulCPUTime > ulElapsedTime )
            {
                return MASK_GT;
            }
        }
    }

    // no way flow coming here .. still
    return F_RESULT_REMOVE;
}


DWORD
FilterUserName(
    IN LPCWSTR pwszProperty,
    IN LPCWSTR pwszOperator,
    IN LPCWSTR pwszValue,
    IN LPVOID pData,
    IN TARRAY arrRow
    )
/*++
Routine Description:
    Filter process to display with resepect  their Username.

Arguments:
    [ in ] pwszProperty   : Contains property value as 'USERNAME'.
    [ in ] pwszOperator   : Contains operator as 'eq' or 'ne'.
    [ in ] pwszValue      : Contains value to filter.
    [ in ] pData          : Contains data to compare.
    [ in ] arrRow         : Contains item value to filter.

Return Value:
    DWORD
--*/
{
    // local variables
    LONG lResult = 0;
    LONG lWildCardPos = 0;
    LPCWSTR pwszTemp = NULL;
    LPCWSTR pwszSearch = NULL;
    BOOL bOnlyUserName = FALSE;
    LPCWSTR pwszUserName = NULL;

    // check the inputs
    if ( ( NULL == pwszProperty ) ||
         ( NULL == pwszOperator ) ||
         ( NULL == pwszValue ) )
    {
        return F_FILTER_INVALID;
    }
    // if the arrRow parameter is NULL, we need to validate the filter
    if ( NULL == arrRow )
    {
        // nothing is there to validate ... just check the length
        // and ensure that so text is present and the value should not be just '*'
        // NOTE: the common functionality will give the value after doing left and right trim
        if ( ( 0 == StringLength( pwszValue, 0 ) ) || ( 0 == StringCompare( pwszValue, L"*", TRUE, 0 ) ) )
        {
            return F_FILTER_INVALID;
        }
        // the wild card character is allowed only at the end
        pwszTemp = _tcschr( pwszValue, L'*' );
        if ( ( NULL != pwszTemp ) && ( 0 != StringLength( pwszTemp + 1, 0 ) ) )
        {
            return F_FILTER_INVALID;
        }
        // filter is valid
        return F_FILTER_VALID;
    }

    // find the position of the wild card in the supplied user name
    lWildCardPos = 0;
    pwszTemp = _tcschr( pwszValue, L'*' );
    if ( NULL != pwszTemp )
    {
        // determine the wild card position
        lWildCardPos = StringLength( pwszValue, 0 ) - StringLength( pwszTemp, 0 );

        // special case:
        // if the pattern is just asterisk, which means that all the
        // information needs to passed thru the filter but there is no chance for
        // this situation as specifying only '*' is being treated as invalid filter
        if ( 0 == lWildCardPos )
        {
            return F_FILTER_INVALID;
        }
    }

    // search for the domain and user name seperator ...
    // if domain name is not specified, comparision will be done only with the user name
    bOnlyUserName = FALSE;
    pwszTemp = _tcschr( pwszValue, L'\\' );
    if ( NULL == pwszTemp )
    {
        bOnlyUserName = TRUE;
    }
    // get the user name from the info
    pwszUserName = DynArrayItemAsString( arrRow, TASK_USERNAME );
    if ( NULL == pwszUserName )
    {
        return F_RESULT_REMOVE;
    }
    // based the search criteria .. meaning whether to search along with the domain or
    // only user name, the seach string will be decided
    pwszSearch = pwszUserName;
    if ( TRUE == bOnlyUserName )
    {
        // search for the domain and user name seperation character
        pwszTemp = _tcschr( pwszUserName, L'\\' );

        // position to the next character
        if ( NULL != pwszTemp )
        {
            pwszSearch = pwszTemp + 1;
        }
    }

    // validate the search string
    if ( NULL == pwszSearch )
    {
        return F_RESULT_REMOVE;
    }
    // now do the comparision
    lResult = StringCompare( pwszSearch, pwszValue, TRUE, lWildCardPos );

    //
    // now determine the result value
    if ( 0 == lResult )
    {
        return MASK_EQ;
    }
    else
    {
        if ( 0 > lResult )
        {
            return MASK_LT;
        }
        if ( 0 < lResult )
        {
            return MASK_GT;
        }
    }

    // never come across this situation ... still
    return F_RESULT_REMOVE;
}


VOID
CTaskList::Usage(
    void
    )
/*++
Routine Description:
     This function fetches usage information from resource file and shows it.

Arguments:
      NONE

Return Value:
      NONE
--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    ShowMessage( stdout, L"\n" );
    for( dw = ID_HELP_START; dw <= ID_HELP_END; dw++ )
    {
        ShowMessage( stdout, GetResString( dw ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\showtasks.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      ShowTasks.cpp
//
//  Abstract:
//
//      This module displays the tasks that were retrieved
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 25-Nov-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 25-Nov-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "TaskList.h"

//
// define(s) / constants
//
#define MAX_TIMEOUT_RETRIES             300
#define MAX_ENUM_TASKS                  5
#define MAX_ENUM_SERVICES               10
#define MAX_ENUM_MODULES                5
#define FMT_KILOBYTE                    GetResString( IDS_FMT_KILOBYTE )

#define MAX_COL_FORMAT           65
#define MAX_COL_HEADER           256

// structure signatures
#define SIGNATURE_MODULES       9

//
// typedefs
//
typedef struct _tagModulesInfo
{
    DWORD dwSignature;
    DWORD dwLength;
    LPCWSTR pwszModule;
    TARRAY arrModules;
} TMODULESINFO, *PTMODULESINFO;

//
// function prototypes
//
#ifndef _WIN64
BOOL EnumLoadedModulesProc( LPSTR lpszModuleName, ULONG ulModuleBase, ULONG ulModuleSize, PVOID pUserData );
#else
BOOL EnumLoadedModulesProc64( LPSTR lpszModuleName, DWORD64 ulModuleBase, ULONG ulModuleSize, PVOID pUserData );
#endif

DWORD
CTaskList::Show(
    void
    )
/*++
Routine Description:
     show the tasks running

Arguments:
      NONE

Return Value:
      NONE
--*/
{
    // local variables
    HRESULT hr;
    DWORD dwCount = 0;
    DWORD dwFormat = 0;
    DWORD dwFilters = 0;
    DWORD dwTimeOuts = 0;
    ULONG ulReturned = 0;
    BOOL bCanExit = FALSE;
    IWbemClassObject* pObjects[ MAX_ENUM_TASKS ];

    // init the objects to NULL's
    for( DWORD dw = 0; dw < MAX_ENUM_TASKS; dw++ )
    {
        pObjects[ dw ] = NULL;
    }
    // copy the format that has to be displayed into local memory
    bCanExit = FALSE;
    dwFormat = m_dwFormat;
    dwFilters = DynArrayGetCount( m_arrFiltersEx );

    // prepare the columns structure to display
    PrepareColumns();

    // clear the error code ... if any
    SetLastError( ( DWORD )NO_ERROR );

    try
    {
        // dynamically decide whether to hide or show the window title and status in verbose mode
        if ( FALSE == m_bLocalSystem )
        {
            if ( TRUE == m_bVerbose )
            {
                ( m_pColumns + CI_STATUS )->dwFlags |= SR_HIDECOLUMN;
                ( m_pColumns + CI_WINDOWTITLE )->dwFlags |= SR_HIDECOLUMN;
            }

            // check if we need to display the warning message or not
            if ( TRUE == m_bRemoteWarning )
            {
                ShowMessage( stderr, WARNING_FILTERNOTSUPPORTED );
            }
        }

        // loop thru the process instances
        dwTimeOuts = 0;
        do
        {
            // get the object ... wait only for 1 sec at one time ...
            hr = m_pEnumObjects->Next( 1000, MAX_ENUM_TASKS, pObjects, &ulReturned );
            if ( (HRESULT) WBEM_S_FALSE == hr )
            {
                // we've reached the end of enumeration .. set the flag
                bCanExit = TRUE;
            }
            else
            {
                if ( (HRESULT) WBEM_S_TIMEDOUT == hr )
                {
                    // update the timeouts occured
                    dwTimeOuts++;

                    // check if max. retries have reached ... if yes better stop
                    if ( dwTimeOuts > MAX_TIMEOUT_RETRIES )
                    {
			           for( ULONG ul = 0; ul < MAX_ENUM_TASKS; ul++ )
			            {
							// we need to release the wmi object
							SAFE_RELEASE( pObjects[ ul ] );
						}
                        // time out error
                        SetLastError( ( DWORD )ERROR_TIMEOUT );
                        SaveLastError();
                        return 0;
                    }

                    // still we can do more tries ...
                    continue;
                }
                else
                {
                    if ( FAILED( hr ) )
                    {
                        // some error has occured ... oooppps
                        WMISaveError( hr );
                        SetLastError( ( DWORD )STG_E_UNKNOWN );
                        return 0;
                    }
                }
            }
            // reset the timeout counter
            dwTimeOuts = 0;

            // loop thru the objects and save the info
            for( ULONG ul = 0; ul < ulReturned; ul++ )
            {
                // retrive and save data
                LONG lIndex = DynArrayAppendRow( m_arrTasks, MAX_TASKSINFO );
                SaveInformation( lIndex, pObjects[ ul ] );

                // we need to release the wmi object
                SAFE_RELEASE( pObjects[ ul ] );
            }

            // filter the results .. before doing first if filters do exist or not
            if ( 0 != dwFilters )
            {
                FilterResults( MAX_FILTERS, m_pfilterConfigs, m_arrTasks, m_arrFiltersEx );
            }

            // now show the tasks ... if exists
            if ( 0 != DynArrayGetCount( m_arrTasks ) )
            {
                // if the output is not being displayed first time,
                // print one blank line in between ONLY FOR LIST FORMAT
                if ( ( 0 != dwCount ) && ((dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST) )
                {
                    ShowMessage( stdout, L"\n" );
                }
                else
                {
                    if ( ( 0 == dwCount ) && ((dwFormat & SR_FORMAT_MASK) != SR_FORMAT_CSV) )
                    {
                     // output is being displayed for the first time
                      ShowMessage( stdout, L"\n" );
                    }
                }

                // show the tasks
                ShowResults( MAX_COLUMNS, m_pColumns, dwFormat, m_arrTasks );

                // clear the contents and reset
                dwCount += DynArrayGetCount( m_arrTasks );          // update count
                DynArrayRemoveAll( m_arrTasks );

                // to be on safe side, set the apply no heade flag to the format info
                dwFormat |= SR_NOHEADER;
            }
        } while ( FALSE == bCanExit );
    }
    catch( ... )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return 0;
    }

    // clear the error code ... if any
    // NOTE: BELOW STATEMENT IS THE ONLY ANSWER FOR KNOWING THAT ANY PROCESS
    //       ARE OBTAINED OR NOT FOR DELETION.
    SetLastError( ( DWORD )NO_ERROR );

    // return the no. of tasks that were shown
    return dwCount;
}


BOOL
CTaskList::SaveInformation(
    IN LONG lIndex,
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
    Store infomration obtained in dynaimc array.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    CHString str;

    try
    {
        // object path
        PropertyGet( pWmiObject, WIN32_PROCESS_SYSPROPERTY_PATH, str );
        DynArraySetString2( m_arrTasks, lIndex, TASK_OBJPATH, str, 0 );

        // process id
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_PROCESSID, m_dwProcessId );
        DynArraySetDWORD2( m_arrTasks, lIndex, TASK_PID, m_dwProcessId );

        // host name
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_COMPUTER, str );
        DynArraySetString2( m_arrTasks, lIndex, TASK_HOSTNAME, str, 0 );

        // image name
        PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_IMAGENAME, m_strImageName );
        DynArraySetString2( m_arrTasks, lIndex, TASK_IMAGENAME, m_strImageName, 0 );

        // cpu Time
        SetCPUTime( lIndex, pWmiObject );

        // session id and session name
        SetSession( lIndex, pWmiObject );

        // mem usage
        SetMemUsage( lIndex, pWmiObject );

        // user context
        SetUserContext( lIndex, pWmiObject );

        // window title and process / application state
        SetWindowTitle( lIndex );

        // services
        SetServicesInfo( lIndex );

        // modules
        SetModulesInfo( lIndex );
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }
    // return
    return TRUE;
}


VOID
CTaskList::SetUserContext(
    IN LONG lIndex,
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
    Store username property of a process in dynaimc array.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
    VOID
--*/
{
    // local variables
    HRESULT hr;
    CHString str;
    CHString strPath;
    CHString strDomain;
    CHString strUserName;
    BOOL bResult = FALSE;
    IWbemClassObject* pOutParams = NULL;

    // set the default value
    DynArraySetString2( m_arrTasks, lIndex, TASK_USERNAME, V_NOT_AVAILABLE, 0 );

    // check if user name has to be retrieved or not
    if ( FALSE == m_bNeedUserContextInfo )
    {
        return;
    }
    //
    // for getting the user first we will try with API
    // it at all API fails, we will try to get the same information from WMI
    //
    try
    {
        // get the user name
        str = V_NOT_AVAILABLE;
        if ( TRUE == LoadUserNameFromWinsta( strDomain, strUserName ) )
        {
            // format the user name
            str.Format( L"%s\\%s", strDomain, strUserName );
        }
        else
        {
            // user name has to be retrieved - get the path of the current object
            bResult = PropertyGet( pWmiObject, WIN32_PROCESS_SYSPROPERTY_PATH, strPath );
            if ( ( FALSE == bResult ) ||
                 ( 0 == strPath.GetLength() ) )
            {
                return;
            }
            // execute the GetOwner method and get the user name
            // under which the current process is executing
            hr = m_pWbemServices->ExecMethod( _bstr_t( strPath ),
                _bstr_t( WIN32_PROCESS_METHOD_GETOWNER ), 0, NULL, NULL, &pOutParams, NULL );
            if ( FAILED( hr ) )
            {
                return;
            }

            // get the domain and user values from out params object
            // NOTE: do not check the results
            PropertyGet( pOutParams, GETOWNER_RETURNVALUE_DOMAIN, strDomain, L"" );
            PropertyGet( pOutParams, GETOWNER_RETURNVALUE_USER, strUserName, L"" );

            // get the value
            str = V_NOT_AVAILABLE;
            if ( 0 != strDomain.GetLength() )
            {
                str.Format( L"%s\\%s", strDomain, strUserName );
            }
            else
            {
                if ( 0 != strUserName.GetLength() )
                {
                   str = strUserName;
                }
            }
        }

        // the formatted username might contain the UPN format user name
        // so ... remove that part
        if ( -1 != str.Find( L"@" ) )
        {
            // sub-local
            LONG lPos = 0;
            CHString strTemp;

            // get the position
            lPos = str.Find( L"@" );
            strTemp = str.Left( lPos );
            str = strTemp;
        }

        // save the info
        DynArraySetString2( m_arrTasks, lIndex, TASK_USERNAME, str, 0 );
    }
    catch( CHeap_Exception )
    {
		SAFE_RELEASE( pOutParams );
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }
	SAFE_RELEASE( pOutParams );
    return;
}

VOID
CTaskList::SetCPUTime(
    IN LONG lIndex,
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
    Store CPUTIME property of a process in dynaimc array.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
    VOID
--*/
{
    // local variables
    CHString str;
    BOOL bResult = FALSE;
    ULONGLONG ullCPUTime = 0;
    ULONGLONG ullUserTime = 0;
    ULONGLONG ullKernelTime = 0;

    try
    {
        // get the KernelModeTime value
        bResult = PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_KERNELMODETIME, ullKernelTime );

        // get the user mode time
        bResult = PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_USERMODETIME, ullUserTime );

        // calculate the CPU time
        ullCPUTime = ullUserTime + ullKernelTime;

        // now convert the long time into hours format
        TIME_FIELDS time;
        SecureZeroMemory( &time, sizeof( TIME_FIELDS ) );
        RtlTimeToElapsedTimeFields ( (LARGE_INTEGER* ) &ullCPUTime, &time );

        // convert the days into hours
        time.Hour = static_cast<CSHORT>( time.Hour + static_cast<SHORT>( time.Day * 24 ) );

        // prepare into time format ( user locale specific time seperator )
        str.Format( L"%d%s%02d%s%02d",
            time.Hour, m_strTimeSep, time.Minute, m_strTimeSep, time.Second );

        // save the info
        DynArraySetString2( m_arrTasks, lIndex, TASK_CPUTIME, str, 0 );
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }
    return;
}


VOID
CTaskList::SetWindowTitle(
    IN LONG lIndex
    )
/*++
Routine Description:
    Store 'Window Title' property of a process in dynaimc array.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.

Return Value:
    VOID
--*/
{
    // local variables
    LONG lTemp = 0;
    BOOL bHung = FALSE;
    LPCWSTR pwszTemp = NULL;
    CHString strTitle;
    CHString strState;

    try
    {
        // Initialize status value.
        strState = VALUE_UNKNOWN ;

        // get the window details ... window station, desktop, window title
        // NOTE: This will work only for local system
        lTemp = DynArrayFindDWORDEx( m_arrWindowTitles, CTaskList::twiProcessId, m_dwProcessId );
        if ( -1 != lTemp )
        {
            // window title
            pwszTemp = DynArrayItemAsString2( m_arrWindowTitles, lTemp, CTaskList::twiTitle );
            if ( NULL != pwszTemp )
            {
                strTitle = pwszTemp;
            }

            // application / process state
            bHung = DynArrayItemAsBOOL2( m_arrWindowTitles, lTemp, CTaskList::twiHungInfo );
            strState = ( FALSE == bHung ) ? VALUE_RUNNING : VALUE_NOTRESPONDING;
        }

        // save the info
        DynArraySetString2( m_arrTasks, lIndex, TASK_STATUS, strState, 0 );
        DynArraySetString2( m_arrTasks, lIndex, TASK_WINDOWTITLE, strTitle, 0 );
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }
    return;
}


VOID
CTaskList::SetSession(
    IN LONG lIndex,
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
    Store 'Session name' property of a process in dynaimc array.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
    VOID
--*/
{
    // local variables
    CHString str;
    DWORD dwSessionId = 0;

    // set the default value
    DynArraySetString2( m_arrTasks, lIndex, TASK_SESSION, V_NOT_AVAILABLE, 0 );
    DynArraySetString2( m_arrTasks, lIndex, TASK_SESSIONNAME, L"", 0 );

    try
    {
        // get the threads count for the process
        if ( FALSE == PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_SESSION, dwSessionId ) )
        {
            return;
        }
        // get the session id in string format
        str.Format( L"%d", dwSessionId );

        // save the id
        DynArraySetString2( m_arrTasks, lIndex, TASK_SESSION, str, 0 );

        // get the session name
        if ( ( TRUE == m_bLocalSystem ) || ( ( FALSE == m_bLocalSystem ) && ( NULL != m_hServer ) ) )
        {
            // sub-local variables
            LPWSTR pwsz = NULL;

            // get the buffer
            pwsz = str.GetBufferSetLength( WINSTATIONNAME_LENGTH + 1 );

            // get the name for the session
            if ( FALSE == WinStationNameFromLogonIdW( m_hServer, dwSessionId, pwsz ) )
            {
                return;             // failed in getting the winstation/session name ... return
            }
            // release buffer
            str.ReleaseBuffer();

            // save the session name ... do this only if session name is not empty
            if ( 0 != str.GetLength() )
            {
                DynArraySetString2( m_arrTasks, lIndex, TASK_SESSIONNAME, str, 0 );
            }
        }
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }

    return;
}


VOID
CTaskList::SetMemUsage(
    IN LONG lIndex,
    IN IWbemClassObject* pWmiObject
    )
/*++
Routine Description:
    Store 'Memory usage' property of a process in dynaimc array.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.
    [ in ] pWmiObject : Contains interface pointer.

Return Value:
    VOID
--*/
{
    // local variables
    CHString str;
    LONG lTemp = 0;
    NUMBERFMTW nfmtw;
    NTSTATUS ntstatus;
    ULONGLONG ullMemUsage = 0;
    LARGE_INTEGER liTemp = { 0, 0 };
    CHAR szTempBuffer[ 33 ] = "\0";
    WCHAR wszNumberStr[ 33 ] = L"\0";

    try
    {
        // NOTE:
        // ----
        // The max. value of
        // (2 ^ 64) - 1 = "18,446,744,073,709,600,000 K"  (29 chars).
        //
        // so, the buffer size to store the number is fixed as 32 characters
        // which is more than the 29 characters in actuals

        // set the default value
        DynArraySetString2( m_arrTasks, lIndex, TASK_MEMUSAGE, V_NOT_AVAILABLE, 0 );

        // get the KernelModeTime value
        if ( FALSE == PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_MEMUSAGE, ullMemUsage ) )
        {
            return;
        }
        // convert the value into K Bytes
        ullMemUsage /= 1024;

        // now again convert the value from ULONGLONG to string and check the result
        liTemp.QuadPart = ullMemUsage;
        ntstatus = RtlLargeIntegerToChar( &liTemp, 10, SIZE_OF_ARRAY( szTempBuffer ), szTempBuffer );
        if ( ! NT_SUCCESS( ntstatus ) )
        {
            return;
        }
        // now copy this info into UNICODE buffer
        str = szTempBuffer;

        //
        // prepare to Format the number with commas according to locale conventions.
        nfmtw.NumDigits = 0;
        nfmtw.LeadingZero = 0;
        nfmtw.NegativeOrder = 0;
        nfmtw.Grouping = m_dwGroupSep;
        nfmtw.lpDecimalSep = m_strGroupThousSep.GetBuffer( m_strGroupThousSep.GetLength() );
        nfmtw.lpThousandSep = m_strGroupThousSep.GetBuffer( m_strGroupThousSep.GetLength() );

        // convert the value
        lTemp = GetNumberFormatW( LOCALE_USER_DEFAULT,
            0, str, &nfmtw, wszNumberStr, SIZE_OF_ARRAY( wszNumberStr ) );

        // get the session id in string format
        str.Format( FMT_KILOBYTE, wszNumberStr );

        // save the id
        DynArraySetString2( m_arrTasks, lIndex, TASK_MEMUSAGE, str, 0 );
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }
    return;
}


VOID
CTaskList::SetServicesInfo(
    IN LONG lIndex
    )
/*++
Routine Description:
    Store 'Service' property of a process in dynaimc array.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.

Return Value:
    VOID
--*/
{
    // local variables
    HRESULT hr;
    CHString strQuery;
    CHString strService;
    ULONG ulReturned = 0;
    BOOL bResult = FALSE;
    BOOL bCanExit = FALSE;
    TARRAY arrServices = NULL;
    IEnumWbemClassObject* pEnumServices = NULL;
    IWbemClassObject* pObjects[ MAX_ENUM_SERVICES ];

    // check whether we need to gather services info or not .. if not skip
    if ( FALSE == m_bNeedServicesInfo )
    {
        return;
    }
    // create array
    arrServices = CreateDynamicArray();
    if ( NULL == arrServices )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return;
    }

    //
    // for getting the services info first we will try with the one we got from API
    // it at all API fails, we will try to get the same information from WMI
    //
    try
    {
        // check whether API returned services or not
        if ( NULL != m_pServicesInfo )
        {
            // get the service names related to the current process
            // identify all the services related to the current process ( based on the PID )
            // and save the info
            for ( DWORD dw = 0; dw < m_dwServicesCount; dw++ )
            {
                // compare the PID's
                if ( m_dwProcessId == m_pServicesInfo[ dw ].ServiceStatusProcess.dwProcessId )
                {
                    // this service is related with the current process ... store service name
                    DynArrayAppendString( arrServices, m_pServicesInfo[ dw ].lpServiceName, 0 );
                }
            }
        }
        else
        {
            try
            {
                // init the objects to NULL's
                for( DWORD dw = 0; dw < MAX_ENUM_SERVICES; dw++ )
                {
                    pObjects[ dw ] = NULL;
                }
                // prepare the query
                strQuery.Format( WMI_SERVICE_QUERY, m_dwProcessId );

                // execute the query
                hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( strQuery ),
                    WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumServices );

                // check the result
                if ( FAILED( hr ) )
                {
                    _com_issue_error( hr );
                }
                // set the security
                hr = SetInterfaceSecurity( pEnumServices, m_pAuthIdentity );
                if ( FAILED( hr ) )
                {
                    _com_issue_error( hr );
                }
                // loop thru the service instances
                do
                {
                    // get the object ... wait
                    // NOTE: one-by-one
                    hr = pEnumServices->Next( WBEM_INFINITE, MAX_ENUM_SERVICES, pObjects, &ulReturned );
                    if ( (HRESULT) WBEM_S_FALSE == hr )
                    {
                        // we've reached the end of enumeration .. set the flag
                        bCanExit = TRUE;
                    }
                    else
                    {
                        if ( ( (HRESULT) WBEM_S_TIMEDOUT == hr ) || FAILED( hr ) )
                        {
                         //
                         // some error has occured ... oooppps

                            // exit from the loop
                            break;
                        }
                    }
                    // loop thru the objects and save the info
                    for( ULONG ul = 0; ul < ulReturned; ul++ )
                    {
                        // get the value of the property
                        bResult = PropertyGet( pObjects[ ul ], WIN32_SERVICE_PROPERTY_NAME, strService );
                        if ( TRUE == bResult )
                        {
                            DynArrayAppendString( arrServices, strService, 0 );
                        }
                        // release the interface
                        SAFE_RELEASE( pObjects[ ul ] );
                    }
                } while ( FALSE == bCanExit );
            }
            catch( _com_error& e )
            {
				SAFE_RELEASE( pEnumServices );
                // save the error
                WMISaveError( e );
            }

            // release the objects to NULL's
            for( DWORD dw = 0; dw < MAX_ENUM_SERVICES; dw++ )
            {
                // release all the objects
                SAFE_RELEASE( pObjects[ dw ] );
            }

            // now release the enumeration object
            SAFE_RELEASE( pEnumServices );
        }

        // save and return
        DynArraySetEx2( m_arrTasks, lIndex, TASK_SERVICES, arrServices );
    }
    catch( CHeap_Exception )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
    }
    return;
}


BOOL
CTaskList::SetModulesInfo(
    IN LONG lIndex
    )
/*++
Routine Description:
    Store 'Modules' property of a process in dynaimc array.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    LONG lPos = 0;
    BOOL bResult = FALSE;
    TARRAY arrModules = NULL;

    // check whether we need to get the modules or not
    if ( FALSE == m_bNeedModulesInfo )
    {
        return TRUE;
    }
    // allocate for memory
    arrModules = CreateDynamicArray();
    if ( NULL == arrModules )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // the way we get the modules information is different for local remote
    // so depending that call appropriate function
    if ( ( TRUE == m_bLocalSystem ) && ( FALSE == m_bUseRemote ) )
    {
            // enumerate the modules for the current process
            bResult = LoadModulesOnLocal( arrModules );
    }
    else
    {
        // identify the modules information for the current process ... remote system
        bResult = GetModulesOnRemote( lIndex, arrModules );
    }

    // check the result
    if ( TRUE == bResult  )
    {
        try
        {
            // check if the modules list contains the imagename also. If yes remove that entry
            lPos = DynArrayFindString( arrModules, m_strImageName, TRUE, 0 );
            if ( -1 != lPos )
            {
                // remove the entry
                DynArrayRemove( arrModules, lPos );
            }
        }
        catch( CHeap_Exception )
        {
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }
    }

    // save the modules information to the array
    // NOTE: irrespective of whether enumeration is success or not we will add the array
    DynArraySetEx2( m_arrTasks, lIndex, TASK_MODULES, arrModules );

    // return
    return bResult;
}


BOOL
CTaskList::LoadModulesOnLocal(
    IN OUT TARRAY arrModules
    )
/*++
Routine Description:
    Store 'Modules' property of a process in dynaimc array for local system.

Arguments:
    [ in out ] arrModules : Contains dynamic array.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    LONG lPos = 0;
    BOOL bResult = FALSE;
    TMODULESINFO modules;
    HANDLE hProcess = NULL;

    // check the input values
    if ( NULL == arrModules )
    {
        return FALSE;
    }
    // open the process handle
    hProcess = OpenProcess( PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessId );
    if ( NULL == hProcess )
    {
        return FALSE;                               // failed in getting the process handle
    }

    // prepare the modules structure
    SecureZeroMemory( &modules, sizeof( TMODULESINFO ) );
    modules.dwSignature = SIGNATURE_MODULES;
    modules.dwLength = 0;
    modules.arrModules = arrModules;
    try
    {
        modules.pwszModule = ((m_strModules.GetLength() != 0) ? (LPCWSTR) m_strModules : NULL);
        if ( -1 != (lPos = m_strModules.Find( L"*" )) )
        {
            modules.dwLength = (DWORD) lPos;
            modules.pwszModule = m_strModules;
        }
    }
    catch( CHeap_Exception )
    {
        CloseHandle( hProcess );
        hProcess = NULL;
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

#ifndef _WIN64
    bResult = EnumerateLoadedModules( hProcess, EnumLoadedModulesProc, &modules );
#else
    bResult = EnumerateLoadedModules64( hProcess, EnumLoadedModulesProc64, &modules );
#endif

    // close the process handle .. we dont need this furthur
    CloseHandle( hProcess );
    hProcess = NULL;

    // return
    return bResult;
}


BOOL
CTaskList::GetModulesOnRemote(
    IN LONG lIndex,
    IN OUT TARRAY arrModules )
/*++
Routine Description:
    Store 'Modules' property of a process in dynaimc array for remote system.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.
    [ in out ] arrModules : Contains dynamic array.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    LONG lPos = 0;
    DWORD dwLength = 0;
    DWORD dwOffset = 0;
    DWORD dwInstance = 0;
    PPERF_OBJECT_TYPE pot = NULL;
    PPERF_OBJECT_TYPE potImages = NULL;
    PPERF_INSTANCE_DEFINITION pidImages = NULL;
    PPERF_COUNTER_BLOCK pcbImages = NULL;
    PPERF_OBJECT_TYPE potAddressSpace = NULL;
    PPERF_INSTANCE_DEFINITION pidAddressSpace = NULL;
    PPERF_COUNTER_BLOCK pcbAddressSpace = NULL;
    PPERF_COUNTER_DEFINITION pcd = NULL;

    // check the input values
    if ( NULL == arrModules )
    {
        return FALSE;
    }
    // check whether the performance object exists or not
    // if doesn't exists, get the same using WMI
    if ( NULL == m_pdb )
    {
        // invoke the WMI method
        return GetModulesOnRemoteEx( lIndex, arrModules );
    }

    // get the perf object types
    pot = (PPERF_OBJECT_TYPE) ( (LPBYTE) m_pdb + m_pdb->HeaderLength );
    for( DWORD dw = 0; dw < m_pdb->NumObjectTypes; dw++ )
    {
        if ( 740 == pot->ObjectNameTitleIndex )
        {
            potImages = pot;
        }
        else
        {
            if ( 786 == pot->ObjectNameTitleIndex )
            {
                potAddressSpace = pot;
            }
        }
        // move to the next object
        dwOffset = pot->TotalByteLength;
        if( 0 != dwOffset )
        {
            pot = ( (PPERF_OBJECT_TYPE) ((PBYTE) pot + dwOffset));
        }
    }

    // check whether we got both the object types or not
    if ( ( NULL == potImages ) || ( NULL == potAddressSpace ) )
    {
        return FALSE;
    }
    // find the offset of the process id in the address space object type
    // get the first counter definition of address space object
    pcd = (PPERF_COUNTER_DEFINITION) ( (LPBYTE) potAddressSpace + potAddressSpace->HeaderLength);

    // loop thru the counters and find the offset
    dwOffset = 0;
    for( DWORD dw = 0; dw < potAddressSpace->NumCounters; dw++)
    {
        // 784 is the counter for process id
        if ( 784 == pcd->CounterNameTitleIndex )
        {
            dwOffset = pcd->CounterOffset;
            break;
        }

        // next counter
        pcd = ( (PPERF_COUNTER_DEFINITION) ( (LPBYTE) pcd + pcd->ByteLength) );
    }

    // check whether we got the offset or not
    // if not, we are unsuccessful
    if ( 0 == dwOffset )
    {
        // set the error message
        SetLastError( ( DWORD )ERROR_ACCESS_DENIED );
        SaveLastError();
        return FALSE;
    }

    // get the instances
    pidImages = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) potImages + potImages->DefinitionLength );
    pidAddressSpace = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) potAddressSpace + potAddressSpace->DefinitionLength );

    // counter blocks
    pcbImages = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidImages + pidImages->ByteLength );
    pcbAddressSpace = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidAddressSpace + pidAddressSpace->ByteLength );

    // find the instance number of the process which we are looking for
    for( dwInstance = 0; dwInstance < (DWORD) potAddressSpace->NumInstances; dwInstance++ )
    {
        // sub-local variables
        DWORD dwProcessId = 0;

        // get the process id
        dwProcessId = *((DWORD*) ( (LPBYTE) pcbAddressSpace + dwOffset ));

        // now check if this is the process which we are looking for
        if ( dwProcessId == m_dwProcessId )
        {
            break;
        }
        // continue looping thru other instances
        pidAddressSpace = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) pcbAddressSpace + pcbAddressSpace->ByteLength );
        pcbAddressSpace = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidAddressSpace + pidAddressSpace->ByteLength );
    }

    // check whether we got the instance or not
    // if not, there are no modules for this process
    if ( dwInstance == ( DWORD )potAddressSpace->NumInstances )
    {
        return TRUE;
    }
    //determine the length of the module name ..
    dwLength = 0;
    if ( -1 != (lPos = m_strModules.Find( L"*" )) )
    {
        dwLength = (DWORD) lPos;
    }
    // now based the parent instance, collect all the modules
    for( DWORD dw = 0; (LONG) dw < potImages->NumInstances; dw++)
    {
        // check the parent object instance number
        if ( pidImages->ParentObjectInstance == dwInstance )
        {
            try
            {
                // sub-local variables
                CHString str;
                LPWSTR pwszTemp;

                // get the buffer
                pwszTemp = str.GetBufferSetLength( pidImages->NameLength + 10 );        // +10 to be on safe side
                if ( NULL == pwszTemp )
                {
                    SetLastError( ( DWORD )E_OUTOFMEMORY );
                    SaveLastError();
                    return FALSE;
                }

                // get the instance name
                StringCopy( pwszTemp, (LPWSTR) ( (LPBYTE) pidImages + pidImages->NameOffset ), pidImages->NameLength + 1 );

                // release buffer
                str.ReleaseBuffer();

                // check whether this module needs to be added to the list
                if ( ( 0 == m_strModules.GetLength() ) || ( 0 == StringCompare( str, m_strModules, TRUE, dwLength ) ) )
                {
                    // add the info the userdata ( for us we will get that in the form of an array
                    lIndex = DynArrayAppendString( arrModules, str, 0 );
                    if ( -1 == lIndex )
                    {
                        // append is failed .. this could be because of lack of memory .. stop the enumeration
                        return FALSE;
                    }
                }
            }
            catch( CHeap_Exception )
            {
                SetLastError( ( DWORD )E_OUTOFMEMORY );
                SaveLastError();
                return FALSE;
            }
        }

        // continue looping thru other instances
        pidImages = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) pcbImages + pcbImages->ByteLength );
        pcbImages = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidImages + pidImages->ByteLength );
    }

    return TRUE;
}


BOOL
CTaskList::GetModulesOnRemoteEx(
    IN LONG lIndex,
    IN OUT TARRAY arrModules
    )
/*++
Routine Description:
    Store 'Modules' property of a process in dynaimc array for remote system.

Arguments:
    [ in ] lIndex     : Contains index value of dynamic array.
    [ in out ] arrModules : Contains dynamic array.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    HRESULT hr;
    LONG lPos = 0;
    DWORD dwLength = 0;
    CHString strQuery;
    CHString strModule;
    CHString strFileName;
    CHString strExtension;
    ULONG ulReturned = 0;
    BOOL bResult = FALSE;
    BOOL bCanExit = FALSE;
    LPCWSTR pwszPath = NULL;
    IEnumWbemClassObject* pEnumServices = NULL;
    IWbemClassObject* pObjects[ MAX_ENUM_MODULES ];

    // check the input values
    if ( NULL == arrModules )
    {
        return FALSE;
    }
    // get the path of the object from the tasks array
    pwszPath = DynArrayItemAsString2( m_arrTasks, lIndex, TASK_OBJPATH );
    if ( NULL == pwszPath )
    {
        return FALSE;
    }

    try
    {
        //determine the length of the module name ..
        dwLength = 0;
        if ( -1 != (lPos = m_strModules.Find( L"*" )) )
        {
            dwLength = (DWORD) lPos;
        }

        // init the objects to NULL's
        for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
        {
            pObjects[ dw ] = NULL;
        }
        // prepare the query
        strQuery.Format( WMI_MODULES_QUERY, pwszPath );

        // execute the query
        hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( strQuery ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumServices );

        // check the result
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // set the security
        hr = SetInterfaceSecurity( pEnumServices, m_pAuthIdentity );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // loop thru the instances
        do
        {
            // get the object ... wait
            // NOTE: one-by-one
            hr = pEnumServices->Next( WBEM_INFINITE, MAX_ENUM_MODULES, pObjects, &ulReturned );
            if ( (HRESULT) WBEM_S_FALSE == hr )
            {
                // we've reached the end of enumeration .. set the flag
                bCanExit = TRUE;
            }
            else
            {
                if ( ( (HRESULT) WBEM_S_TIMEDOUT == hr ) || FAILED( hr ))
                {
                    // some error has occured ... oooppps
                    WMISaveError( hr );
                    SetLastError( ( DWORD )STG_E_UNKNOWN );
                    break;
                }
            }

            // loop thru the objects and save the info
            for( ULONG ul = 0; ul < ulReturned; ul++ )
            {
                // get the file name
                bResult = PropertyGet( pObjects[ ul ], CIM_DATAFILE_PROPERTY_FILENAME, strFileName );
                if ( FALSE == bResult )
                {
                    continue;
                }

                // get the extension
                bResult = PropertyGet( pObjects[ ul ], CIM_DATAFILE_PROPERTY_EXTENSION, strExtension );
                if ( FALSE == bResult )
                {
                    continue;
                }

                // format the module name
                strModule.Format( L"%s.%s", strFileName, strExtension );

                // check whether this module needs to be added to the list
                if ( ( 0 == m_strModules.GetLength() ) || ( 0 == StringCompare( strModule, m_strModules, TRUE, dwLength ) ) )
                {
                    // add the info the userdata ( for us we will get that in the form of an array
                    lIndex = DynArrayAppendString( arrModules, strModule, 0 );
                    if ( -1 == lIndex )
                    {
						for( ULONG ulIndex = ul; ulIndex < ulReturned; ulIndex++ )
						{
							SAFE_RELEASE( pObjects[ ulIndex ] );
						}
						SAFE_RELEASE( pEnumServices );
                        // append is failed .. this could be because of lack of memory .. stop the enumeration
                        return FALSE;
                    }
                }

                // release the interface
                SAFE_RELEASE( pObjects[ ul ] );
            }
        } while ( FALSE == bCanExit );
    }
    catch( _com_error& e )
    {
		SAFE_RELEASE( pEnumServices );
        // save the error
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
		SAFE_RELEASE( pEnumServices );
        // out of memory
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }

    // release the objects to NULL's
    for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
    {
        // release all the objects
        SAFE_RELEASE( pObjects[ dw ] );
    }

    // now release the enumeration object
    SAFE_RELEASE( pEnumServices );

    // return
    return TRUE;
}


#ifndef _WIN64
BOOL EnumLoadedModulesProc( LPSTR lpszModuleName, ULONG ulModuleBase, ULONG ulModuleSize, PVOID pUserData )
#else
BOOL EnumLoadedModulesProc64( LPSTR lpszModuleName, DWORD64 ulModuleBase, ULONG ulModuleSize, PVOID pUserData )
#endif
/*++
Routine Description:


Arguments:
    [ in ] lpszModuleName   : Contains module name.
    [ in out ] ulModuleBase :
    [ in ] ulModuleSize     :
    [ in ] pUserData        : Username information.

Return Value:
      TRUE if successful else FALSE.
--*/
{
    // local variables
    CHString str;
    LONG lIndex = 0;
    TARRAY arrModules = NULL;
    PTMODULESINFO pModulesInfo = NULL;

    // check the input values
    if ( ( NULL == lpszModuleName ) || ( NULL == pUserData ) )
    {
        return FALSE;
    }
    // check the internal array info
    pModulesInfo = (PTMODULESINFO) pUserData;
    if ( ( SIGNATURE_MODULES != pModulesInfo->dwSignature ) || ( NULL == pModulesInfo->arrModules ) )
    {
        return FALSE;
    }
    // get the array pointer into the local variable
    arrModules = (TARRAY) pModulesInfo->arrModules;

    try
    {
        // copy the module name into the local string variable
        // ( conversion from multibyte to unicode will automatically take place )
        str = lpszModuleName;

        // check whether this module needs to be added to the list
        if ( ( NULL == pModulesInfo->pwszModule ) ||
             ( 0 == StringCompare( str, pModulesInfo->pwszModule, TRUE, pModulesInfo->dwLength ) ) )
        {
            // add the info the userdata ( for us we will get that in the form of an array
            lIndex = DynArrayAppendString( arrModules, str, 0 );
            if ( -1 == lIndex )
            {
                // append is failed .. this could be because of lack of memory .. stop the enumeration
                return FALSE;
            }
        }
    }
    catch( CHeap_Exception )
    {
            // out of memory stop the enumeration
            return FALSE;
    }

    // success .. continue the enumeration
    return TRUE;
}


VOID
CTaskList::PrepareColumns(
    void
    )
/*++
Routine Description:
      Prepares the columns information.

Arguments:
    NONE

Return Value:
   NONE
--*/
{
    // local variables
    PTCOLUMNS pCurrentColumn = NULL;

    // host name
    pCurrentColumn = m_pColumns + CI_HOSTNAME;
    pCurrentColumn->dwWidth = COLWIDTH_HOSTNAME;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_HOSTNAME, MAX_COL_HEADER );

    // status
    pCurrentColumn = m_pColumns + CI_STATUS;
    pCurrentColumn->dwWidth = COLWIDTH_STATUS;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN | SR_SHOW_NA_WHEN_BLANK;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_STATUS, MAX_COL_HEADER );

    // image name
    pCurrentColumn = m_pColumns + CI_IMAGENAME;
    pCurrentColumn->dwWidth = COLWIDTH_IMAGENAME;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_IMAGENAME, MAX_COL_HEADER );

    // pid
    pCurrentColumn = m_pColumns + CI_PID;
    pCurrentColumn->dwWidth = COLWIDTH_PID;
    pCurrentColumn->dwFlags = SR_TYPE_NUMERIC | SR_HIDECOLUMN;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_PID, MAX_COL_HEADER );

    // session name
    pCurrentColumn = m_pColumns + CI_SESSIONNAME;
    pCurrentColumn->dwWidth = COLWIDTH_SESSIONNAME;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SESSIONNAME, MAX_COL_HEADER );

    // session#
    pCurrentColumn = m_pColumns + CI_SESSION;
    pCurrentColumn->dwWidth = COLWIDTH_SESSION;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_ALIGN_LEFT | SR_HIDECOLUMN;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SESSION, MAX_COL_HEADER );

    // window name
    pCurrentColumn = m_pColumns + CI_WINDOWTITLE;
    pCurrentColumn->dwWidth = COLWIDTH_WINDOWTITLE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN | SR_SHOW_NA_WHEN_BLANK;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_WINDOWTITLE, MAX_COL_HEADER );

    // user name
    pCurrentColumn = m_pColumns + CI_USERNAME;
    pCurrentColumn->dwWidth = COLWIDTH_USERNAME;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_USERNAME, MAX_COL_HEADER );

    // cpu time
    pCurrentColumn = m_pColumns + CI_CPUTIME;
    pCurrentColumn->dwWidth = COLWIDTH_CPUTIME;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_ALIGN_LEFT | SR_HIDECOLUMN;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_CPUTIME, MAX_COL_HEADER );

    // mem usage
    pCurrentColumn = m_pColumns + CI_MEMUSAGE;
    pCurrentColumn->dwWidth = COLWIDTH_MEMUSAGE;
    pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_ALIGN_LEFT | SR_HIDECOLUMN;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_MEMUSAGE, MAX_COL_HEADER );

    // services
    pCurrentColumn = m_pColumns + CI_SERVICES;
    pCurrentColumn->dwWidth = COLWIDTH_MODULES_WRAP;
    pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING | SR_NO_TRUNCATION | SR_HIDECOLUMN | SR_SHOW_NA_WHEN_BLANK;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_SERVICES, MAX_COL_HEADER );

    // modules
    pCurrentColumn = m_pColumns + CI_MODULES;
    pCurrentColumn->dwWidth = COLWIDTH_MODULES_WRAP;
    pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING | SR_NO_TRUNCATION | SR_HIDECOLUMN | SR_SHOW_NA_WHEN_BLANK;
    pCurrentColumn->pFunction = NULL;
    pCurrentColumn->pFunctionData = NULL;
    StringCopy( pCurrentColumn->szFormat, NULL_STRING, MAX_COL_FORMAT );
    StringCopy( pCurrentColumn->szColumn, COLHEAD_MODULES, MAX_COL_HEADER );

    //
    // based on the option selected by the user .. show only needed columns
    if ( TRUE == m_bAllServices )
    {
        ( m_pColumns + CI_IMAGENAME )->dwFlags &= ~( SR_HIDECOLUMN );
        ( m_pColumns + CI_PID )->dwFlags &= ~( SR_HIDECOLUMN );
        ( m_pColumns + CI_SERVICES )->dwFlags &= ~( SR_HIDECOLUMN );
    }
    else if ( TRUE == m_bAllModules )
    {
        ( m_pColumns + CI_IMAGENAME )->dwFlags &= ~( SR_HIDECOLUMN );
        ( m_pColumns + CI_PID )->dwFlags &= ~( SR_HIDECOLUMN );
        ( m_pColumns + CI_MODULES )->dwFlags &= ~( SR_HIDECOLUMN );
    }
    else
    {
        // default ... enable min. columns
        ( m_pColumns + CI_IMAGENAME )->dwFlags &= ~( SR_HIDECOLUMN );
        ( m_pColumns + CI_PID )->dwFlags &= ~( SR_HIDECOLUMN );
        ( m_pColumns + CI_SESSIONNAME )->dwFlags &= ~( SR_HIDECOLUMN );
        ( m_pColumns + CI_SESSION )->dwFlags &= ~( SR_HIDECOLUMN );
        ( m_pColumns + CI_MEMUSAGE )->dwFlags &= ~( SR_HIDECOLUMN );

        // check if verbose option is specified .. show other columns
        if ( TRUE == m_bVerbose )
        {
            ( m_pColumns + CI_STATUS )->dwFlags &= ~( SR_HIDECOLUMN );
            ( m_pColumns + CI_USERNAME )->dwFlags &= ~( SR_HIDECOLUMN );
            ( m_pColumns + CI_CPUTIME )->dwFlags &= ~( SR_HIDECOLUMN );
            ( m_pColumns + CI_WINDOWTITLE )->dwFlags &= ~( SR_HIDECOLUMN );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\tasklist.cpp ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      TaskList.cpp
//
//  Abstract:
//
//      This module implements the command-line parsing the displaying the tasks
//      information current running on local and remote systems
//
//      Syntax:
//      ------
//          TaskList.exe [-s server [-u username [-p password]]]
//                       [-fo format] [-fi filter] [-nh] [-v | -svc | -m]
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "TaskList.h"

//
// local structures
//
typedef struct __tagWindowTitles
{
    LPWSTR lpDesk;
    LPWSTR lpWinsta;
    BOOL bFirstLoop;
    TARRAY arrWindows;
} TWINDOWTITLES, *PTWINDOWTITLES;

//
// private functions ... prototypes
//
BOOL CALLBACK EnumWindowsProc( HWND hWnd, LPARAM lParam );
BOOL CALLBACK EnumDesktopsFunc( LPWSTR lpstr, LPARAM lParam );
BOOL CALLBACK EnumWindowStationsFunc( LPWSTR lpstr, LPARAM lParam );
BOOL CALLBACK EnumMessageWindows( WNDENUMPROC lpEnumFunc, LPARAM lParam );
BOOL GetPerfDataBlock( HKEY hKey, LPWSTR szObjectIndex, PPERF_DATA_BLOCK* ppdb );


DWORD
__cdecl wmain(
    IN DWORD argc,
    IN LPCWSTR argv[]
    )
/*++
Routine Description:
      This the entry point to this utility.

Arguments:
      [ in ] argc     : argument(s) count specified at the command prompt
      [ in ] argv     : argument(s) specified at the command prompt

Return Value:
      The below are actually not return values but are the exit values
      returned to the OS by this application
          0       : utility is successfull
          1       : utility failed
--*/
{
    // local variables
    CTaskList tasklist;

    // initialize the tasklist utility
    if ( FALSE == tasklist.Initialize() )
    {
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // now do parse the command line options
    if ( FALSE == tasklist.ProcessOptions( argc, argv ) )
    {
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // check whether usage has to be displayed or not
    if ( TRUE == tasklist.m_bUsage )
    {
        // show the usage of the utility
        tasklist.Usage();

        // quit from the utility
        EXIT_PROCESS( 0 );
    }

    // now validate the filters and check the result of the filter validation
    if ( FALSE == tasklist.ValidateFilters() )
    {
        // invalid filter
        DISPLAY_GET_REASON();

        // quit from the utility
        EXIT_PROCESS( 1 );
    }

    // connect to the server
    if ( FALSE == tasklist.Connect() )
    {
        // show the error message
        DISPLAY_GET_REASON();
        EXIT_PROCESS( 1 );
    }

    // load the data and check
    if ( FALSE == tasklist.LoadTasks() )
    {
        // show the error message
        DISPLAY_GET_REASON();

        // exit
        EXIT_PROCESS( 1 );
    }

    // now show the tasks running on the machine
    if ( 0 == tasklist.Show() )
    {
        //
        // no tasks were shown ... display the message

        // check if this is because of any error
        if ( NO_ERROR != GetLastError() )
        {
            DISPLAY_GET_REASON();
            EXIT_PROCESS( 1 );
        }
        else
        {
            DISPLAY_MESSAGE( stdout, ERROR_NODATA_AVAILABLE );
        }
    }

    // clean exit
    EXIT_PROCESS( 0 );
}


BOOL
CTaskList::Connect(
    void
    )
/*++
Routine Description:
      connects to the remote as well as remote system's WMI

Arguments:
      [ in ] pszServer     : remote server name

Return Value:
      TRUE  : if connection is successful
      FALSE : if connection is unsuccessful
--*/
{
    // local variables
    BOOL bResult = FALSE;
    HRESULT hr = S_OK;

    // release the existing auth identity structure
    m_bUseRemote = FALSE;
    WbemFreeAuthIdentity( &m_pAuthIdentity );

    // connect to WMI
    bResult = ConnectWmiEx( m_pWbemLocator,
        &m_pWbemServices, m_strServer, m_strUserName, m_strPassword,
        &m_pAuthIdentity, m_bNeedPassword, WMI_NAMESPACE_CIMV2, &m_bLocalSystem );
    hr = GetLastError();
    // check the result of connection
    if ( FALSE == bResult )
    {
        return FALSE;
    }

#ifndef _WIN64
    // determine the type of the platform if modules info is required
    if ( ( TRUE == m_bLocalSystem ) && ( TRUE == m_bNeedModulesInfo ) )
    {
        // sub-local variables
        DWORD dwPlatform = 0;

        // get the platform type
        dwPlatform = GetTargetPlatformEx( m_pWbemServices, m_pAuthIdentity );

        // if the platform is not 32-bit, error
        if ( PLATFORM_X86 != dwPlatform )
        {
            // let the tool use WMI calls instead of Win32 API
            m_bUseRemote = TRUE;
        }
    }
#endif

    try
    {
        // check the local credentials and if need display warning
        if ( WBEM_E_LOCAL_CREDENTIALS == hr )
        {
            WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
            ShowMessageEx( stderr, 2, FALSE, L"%1 %2",
                           TAG_WARNING, GetReason() );
        }

        // check the remote system version and its compatiblity
        if ( FALSE == m_bLocalSystem )
        {
            // check the version compatibility
            DWORD dwVersion = 0;
            dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
            if ( FALSE == IsCompatibleOperatingSystem( dwVersion ) )
            {
                SetReason( ERROR_REMOTE_INCOMPATIBLE );
                return FALSE;
            }
        }

        // save the server name
        m_strUNCServer = L"";
        if ( 0 != m_strServer.GetLength() )
        {
            // check whether the server name is in UNC format or not .. if not prepare it
            m_strUNCServer = m_strServer;
            if ( FALSE == IsUNCFormat( m_strServer ) )
            {
                m_strUNCServer.Format( L"\\\\%s", m_strServer );
            }
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }

    // return the result
    return TRUE;
}


BOOL
CTaskList::LoadTasks(
    void
    )
/*++
Routine Description:
    Store process running on a system.

Arguments:
    NONE

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    HRESULT hr = S_OK;
    LONG lIndex = 0;

    try
    {
        // check the services object
        if ( NULL == m_pWbemServices )
        {
            SetLastError( ( DWORD )STG_E_UNKNOWN );
            SaveLastError();
            return FALSE;
        }

        // load the tasks from WMI based on generated query
        SAFE_RELEASE( m_pEnumObjects );
        hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( m_strQuery ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &m_pEnumObjects );

        // check the result of the ExecQuery
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // set the interface security and check the result
        hr = SetInterfaceSecurity( m_pEnumObjects, m_pAuthIdentity );
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // remove the current window titles information
        DynArrayRemoveAll( m_arrWindowTitles );

        // for the local system, enumerate the window titles of the processes
        // there is no provision for collecting the window titles of remote processes
        m_bRemoteWarning = FALSE;
        if ( ( TRUE == m_bLocalSystem ) && ( TRUE == m_bNeedWindowTitles ) )
        {
            // prepare the tasks list info
            TWINDOWTITLES windowtitles;
            windowtitles.lpDesk = NULL;
            windowtitles.lpWinsta = NULL;
            windowtitles.bFirstLoop = FALSE;
            windowtitles.arrWindows = m_arrWindowTitles;
            EnumWindowStations( EnumWindowStationsFunc, ( LPARAM ) &windowtitles );

            // free the memory allocated with _tcsdup string function
            if ( NULL != windowtitles.lpDesk )
            {
                free( windowtitles.lpDesk );
                windowtitles.lpDesk = NULL;
            }

            // ...
            if ( NULL != windowtitles.lpWinsta )
            {
                free( windowtitles.lpWinsta );
                windowtitles.lpWinsta = NULL;
            }
        }
        else
        {
            if ( ( FALSE == m_bLocalSystem ) && ( TRUE == m_bNeedWindowTitles ) )
            {
                // as window titles and status filters are supported when
                // querying remote systems, check whether user gave those filters are not
                // if there are any filters found -- delete those filters

                //
                // window title
                lIndex = DynArrayFindStringEx( m_arrFiltersEx,
                    F_PARSED_INDEX_PROPERTY, FILTER_WINDOWTITLE, TRUE, 0 );
                while ( -1 != lIndex )
                {
                    // make mark to display the warning message
                    m_bRemoteWarning = TRUE;

                    // remove the filter
                    DynArrayRemove( m_arrFiltersEx, lIndex );

                    // check if there any more filters of this kind
                    lIndex = DynArrayFindStringEx( m_arrFiltersEx,
                        F_PARSED_INDEX_PROPERTY, FILTER_WINDOWTITLE, TRUE, 0 );
                }

                //
                // status
                lIndex = DynArrayFindStringEx( m_arrFiltersEx,
                    F_PARSED_INDEX_PROPERTY, FILTER_STATUS, TRUE, 0 );
                while ( -1 != lIndex )
                {
                    // make mark to display the warning message
                    m_bRemoteWarning = TRUE;

                    // remove the filter
                    DynArrayRemove( m_arrFiltersEx, lIndex );

                    // check if there any more filters of this kind
                    lIndex = DynArrayFindStringEx( m_arrFiltersEx,
                        F_PARSED_INDEX_PROPERTY, FILTER_STATUS, TRUE, 0 );
                }
            }
        }
        // load the extended tasks information
        LoadTasksEx();          // NOTE: here we are not much bothered abt the return value
    }
    catch( CHeap_Exception )
    {
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }

    // return success
    return TRUE;
}


BOOL
CTaskList::LoadTasksEx(
    void
    )
/*++
Routine Description:
    Store other information such as module, service etc. of a process
    running on a system.

Arguments:
    NONE

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    BOOL bResult = FALSE;

    // init
    m_bCloseConnection = FALSE;

    try
    {
        // we need to use NET API only in case connecting to the remote system
        // with credentials information i.e; m_pAuthIdentity is not NULL
        if ( ( FALSE == m_bLocalSystem ) && ( NULL != m_pAuthIdentity ) )
        {
            // sub-local variables
            DWORD dwConnect = 0;
            LPCWSTR pwszUser = NULL;
            LPCWSTR pwszPassword = NULL;

            // identify the password to connect to the remote system
            pwszPassword = m_pAuthIdentity->Password;
            if ( 0 != m_strUserName.GetLength() )
            {
                pwszUser = m_strUserName;
            }
            // establish connection to the remote system using NET API
            // this we need to do only for remote system
            dwConnect = NO_ERROR;
            m_bCloseConnection = TRUE;
            dwConnect = ConnectServer( m_strUNCServer, pwszUser, pwszPassword );
            if ( NO_ERROR != dwConnect )
            {
                // connection should not be closed .. this is because we didn't establish the connection
                m_bCloseConnection = FALSE;

                // this might be 'coz of the conflict in the credentials ... check that
                if ( ERROR_SESSION_CREDENTIAL_CONFLICT != dwConnect )
                {
                    // return failure
                    return FALSE;
                }
            }

            // check the whether we need to close the connection or not
            // if user name is NULL (or) password is NULL then don't close the connection
            if ( ( NULL == pwszUser ) || ( NULL == pwszPassword ) )
            {
                m_bCloseConnection = FALSE;
            }
        }

        // connect to the remote system's winstation
        bResult = TRUE;
        m_hServer = SERVERNAME_CURRENT;
        if ( FALSE == m_bLocalSystem )
        {
            // sub-local variables
            LPWSTR pwsz = NULL;

            // connect to the winsta and check the result
            pwsz = m_strUNCServer.GetBuffer( m_strUNCServer.GetLength() );
            m_hServer = WinStationOpenServerW( pwsz );

            // proceed furthur only if winstation of the remote system is successfully opened
            if ( NULL == m_hServer )
            {
                bResult = FALSE;
            }
        }

        // prepare to get the user context info .. if needed
        if ( ( TRUE == m_bNeedUserContextInfo ) && ( TRUE == bResult ) )
        {
            // get all the process details
            m_bIsHydra = FALSE;
            bResult = WinStationGetAllProcesses( m_hServer,
                GAP_LEVEL_BASIC, &m_ulNumberOfProcesses, (PVOID*) &m_pProcessInfo );

            // check the result
            if ( FALSE == bResult )
            {
                // Maybe a Hydra 4 server ?
                // Check the return code indicating that the interface is not available.
                if ( RPC_S_PROCNUM_OUT_OF_RANGE == GetLastError() )
                {
                    // The new interface is not known
                    // It must be a Hydra 4 server
                    // try with the old interface
                    bResult = WinStationEnumerateProcesses( m_hServer, (PVOID*) &m_pProcessInfo );

                    // check the result of enumeration
                    if ( TRUE == bResult )
                    {
                        m_bIsHydra = TRUE;
                    }
                }
                else
                {
                    // unknown error
                    // ????????????????????????????????????????????????????????????????
                    //      dont know whatz happening to the memory allocated here
                    //      we are getting AV when trying to free the memory allocated
                    //      in the call to WinStationGetAllProcesses
                    // ????????????????????????????????????????????????????????????????
                    m_pProcessInfo = NULL;
                }
            }
        }

        // check whether we need services info or not
        if ( TRUE == m_bNeedServicesInfo )
        {
            // load the services
            bResult = LoadServicesInfo();

            // check the result
            if ( FALSE == bResult )
            {
                return FALSE;
            }
        }

        // check whether we need modules info or not
        if ( TRUE == m_bNeedModulesInfo )
        {
            // load the modules information
            bResult = LoadModulesInfo();

            // check the result
            if ( FALSE == bResult )
            {
                return FALSE;
            }
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
CTaskList::LoadModulesInfo(
    void
    )
/*++
Routine Description:
    Store module information of a process.

Arguments:
    NONE

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    HKEY hKey = NULL;
    LONG lReturn = 0;
    BOOL bResult = FALSE;
    BOOL bImagesObject = FALSE;
    BOOL bAddressSpaceObject = FALSE;
    PPERF_OBJECT_TYPE pot = NULL;

    // check whether we need the modules infor or not
    // NOTE: we need to load the performance data only in case if user is querying for remote system only
    if ( ( FALSE == m_bNeedModulesInfo ) || ( TRUE == m_bLocalSystem ) )
    {
        return TRUE;
    }

    try
    {
        // open the remote system performance data key
        lReturn = RegConnectRegistry( m_strUNCServer, HKEY_PERFORMANCE_DATA, &hKey );
        if ( ERROR_SUCCESS != lReturn )
        {
            SetLastError( ( DWORD )lReturn );
            SaveLastError();
            return FALSE;
        }

        // get the performance object ( images )
        bResult = GetPerfDataBlock( hKey, L"740", &m_pdb );
        if ( FALSE == bResult )
        {
            // close the registry key and return
            RegCloseKey( hKey );
            return FALSE;
        }

        // check the validity of the perf block
        if ( 0 != StringCompare( m_pdb->Signature, L"PERF", FALSE, 4 ) )
        {
            // close the registry key and return
            RegCloseKey( hKey );

            // set the error message
            SetLastError( ( DWORD )ERROR_ACCESS_DENIED );
            SaveLastError();
            return FALSE;
        }

        // close the registry key and return
        RegCloseKey( hKey );

        //
        // check whether we got both 740 and 786 blocks or not
        //
        bImagesObject = FALSE;
        bAddressSpaceObject = FALSE;
        pot = (PPERF_OBJECT_TYPE) ( (LPBYTE) m_pdb + m_pdb->HeaderLength );
        for( DWORD dw = 0; dw < m_pdb->NumObjectTypes; dw++ )
        {
            if ( 740 == pot->ObjectNameTitleIndex )
            {
                bImagesObject = TRUE;
            }
            else
            {
                if ( 786 == pot->ObjectNameTitleIndex )
                {
                    bAddressSpaceObject = TRUE;
                }
            }
            // move to the next object
            if( 0 != pot->TotalByteLength )
            {
                pot = ( (PPERF_OBJECT_TYPE) ((PBYTE) pot + pot->TotalByteLength));
            }
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( E_OUTOFMEMORY );
        if( NULL != hKey )
        {
            RegCloseKey( hKey );
        }
        return FALSE;
    }

    // check whether we got the needed objects or not
    if ( ( FALSE == bImagesObject ) || ( FALSE == bAddressSpaceObject ) )
    {
        SetLastError( ( DWORD )ERROR_ACCESS_DENIED );
        SaveLastError();
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
CTaskList::LoadUserNameFromWinsta(
    OUT CHString& strDomain,
    OUT CHString& strUserName
    )
/*++
Routine Description:
    Store username of a process obtained from window station.

Arguments:
    OUT strDomain   : Contains domain name string.
    OUT strUserName : Contains username string.
Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    PSID pSid = NULL;
    BOOL bResult = FALSE;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszDomain = NULL;
    LPCWSTR pwszServer = NULL;
    DWORD dwUserLength = 0;
    DWORD dwDomainLength = 0;
    SID_NAME_USE siduse;

    // check whether winsta data exists or not
    if ( NULL == m_pProcessInfo )
    {
        return FALSE;
    }

    try
    {
        // allocate buffers
        dwUserLength = 128;
        dwDomainLength = 128;
        pwszUser = strUserName.GetBufferSetLength( dwUserLength );
        pwszDomain = strDomain.GetBufferSetLength( dwDomainLength );

        //
        // find for the appropriate the process
        pSid = NULL;
        if ( FALSE == m_bIsHydra )
        {
            // sub-local variables
            PTS_ALL_PROCESSES_INFO ptsallpi = NULL;
            PTS_SYSTEM_PROCESS_INFORMATION pspi = NULL;

            // loop ...
            ptsallpi = (PTS_ALL_PROCESSES_INFO) m_pProcessInfo;
            for( ULONG ul = 0; ul < m_ulNumberOfProcesses; ul++ )
            {
                pspi = ( PTS_SYSTEM_PROCESS_INFORMATION )( ptsallpi[ ul ].pspiProcessInfo );
                if ( pspi->UniqueProcessId == m_dwProcessId )
                {
                    // get the SID and convert it into
                    pSid = ptsallpi[ ul ].pSid;
                    break;               // break from the loop
                }
            }
        }
        else
        {
            //
            // HYDRA ...
            //

            // sub-local variables
            DWORD dwTotalOffset = 0;
            PTS_SYSTEM_PROCESS_INFORMATION pspi = NULL;
            PCITRIX_PROCESS_INFORMATION pcpi = NULL;

            // traverse thru the process info and find the process id
            dwTotalOffset = 0;
            pspi = ( PTS_SYSTEM_PROCESS_INFORMATION ) m_pProcessInfo;
            for( ;; )
            {
                // check the processid
                if ( pspi->UniqueProcessId == m_dwProcessId )
                {
                    break;
                }
                // check whether any more processes exist or not
                if( 0 == pspi->NextEntryOffset )
                {
                        break;
                }
                // position to the next process info
                dwTotalOffset += pspi->NextEntryOffset;
                pspi = (PTS_SYSTEM_PROCESS_INFORMATION) &m_pProcessInfo[ dwTotalOffset ];
            }

            // get the citrix_information which follows the threads
            pcpi = (PCITRIX_PROCESS_INFORMATION)
                ( ((PUCHAR) pspi) + sizeof( TS_SYSTEM_PROCESS_INFORMATION ) +
                (sizeof( SYSTEM_THREAD_INFORMATION ) * pspi->NumberOfThreads) );

            // check the magic number .. if it is not valid ... we haven't got SID
            if( CITRIX_PROCESS_INFO_MAGIC == pcpi->MagicNumber )
            {
                pSid = pcpi->ProcessSid;
            }
        }

        // check the sid value
        if ( NULL == pSid )
        {
            // SPECIAL CASE:
            // -------------
            // PID -> 0 will have a special hard coded user name info
            if ( 0 == m_dwProcessId )
            {
                bResult = TRUE;
                lstrcpynW( pwszUser, PID_0_USERNAME, dwUserLength );
                lstrcpynW( pwszDomain, PID_0_DOMAIN, dwDomainLength );
            }

            // release the buffer
            strDomain.ReleaseBuffer();
            strUserName.ReleaseBuffer();
            return bResult;
        }

        // determine the server
        pwszServer = NULL;
        if ( FALSE == m_bLocalSystem )
        {
            pwszServer = m_strUNCServer;
        }
        // map the sid to the user name
        bResult = LookupAccountSid( pwszServer, pSid,
            pwszUser, &dwUserLength, pwszDomain, &dwDomainLength, &siduse );

        // release the buffer
        strDomain.ReleaseBuffer();
        strUserName.ReleaseBuffer();
    }
    catch( CHeap_Exception )
    {
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }
    // return the result
    return bResult;
}


BOOL
CTaskList::LoadServicesInfo(
    void
    )
/*++
Routine Description:
    Store service infomration of a process.

Arguments:
    NONE

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    DWORD dw = 0;                       // looping variable
    DWORD dwSize = 0;                   // used in memory allocation
    DWORD dwResume = 0;                 // used in EnumServicesStatusEx
    BOOL bResult = FALSE;               // captures the result of EnumServicesStatusEx
    SC_HANDLE hScm = NULL;              // holds the handle to the service
    DWORD dwExtraNeeded = 0;            // used in EnumServicesStatusEx and memory allocation
    LPCWSTR pwszServer = NULL;
    LPENUM_SERVICE_STATUS_PROCESS pInfo = NULL;     // holds the services info

    // Initialize the output parameter(s).
    m_dwServicesCount = 0;
    m_pServicesInfo = NULL;

    // check whether we need to load the services info or not
    if ( FALSE == m_bNeedServicesInfo )
    {
        return TRUE;
    }
    // determine the server
    pwszServer = NULL;
    if ( FALSE == m_bLocalSystem )
    {
        pwszServer = m_strUNCServer;
    }

    try
    {
        // Connect to the service controller and check the result
        hScm = OpenSCManager( pwszServer, NULL, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE );
        if ( NULL == hScm )
        {
            // set the reason for the failure and return from here itself
            SaveLastError();
            return FALSE;
        }

        // enumerate the names of the active win32 services
        // for this, first pass through the loop and allocate memory from an initial guess. (4K)
        // if that isn't sufficient, we make another pass and allocate
        // what is actually needed.
        // (we only go through the loop a maximum of two times)
        dw = 0;                 // no. of loops
        dwResume = 0;           // reset / initialize variables
        dwSize = 4 * 1024;      // reset / initialize variables
        while ( 2 >= ++dw )
        {
            // set the size
            dwSize += dwExtraNeeded;

            // allocate memory for storing services information
            pInfo = ( LPENUM_SERVICE_STATUS_PROCESS ) AllocateMemory( dwSize );
            if ( NULL == pInfo )
            {
                // failed in allocating needed memory ... error
                SetLastError( ( DWORD )E_OUTOFMEMORY );
                SaveLastError();
                return FALSE;
            }

            // enumerate services, the process identifier and additional flags for the service
            dwResume = 0;           // lets get all the services again
            bResult = EnumServicesStatusEx( hScm, SC_ENUM_PROCESS_INFO, SERVICE_WIN32,
                SERVICE_ACTIVE, ( LPBYTE ) pInfo, dwSize, &dwExtraNeeded, &m_dwServicesCount, &dwResume, NULL );

            // check the result of the enumeration
            if ( TRUE == bResult )
            {
                // successfully enumerated all the services information
                break;      // jump out of the loop
            }

            // first free the allocated memory
            FreeMemory( ( LPVOID * ) &pInfo );

            // now lets look at what is the error
            if ( ERROR_MORE_DATA == GetLastError() )
            {
                // some more services are not listed because of less memory
                // allocate some more memory and enumerate the remaining services info
                continue;
            }
            else
            {
                // some strange error occured ... inform the same to the caller
                SaveLastError();            // set the reason for the failure
                CloseServiceHandle( hScm ); // close the handle to the service
                return FALSE;               // inform failure
            }
        }
    }
    catch( CHeap_Exception )
    {
        if( NULL != hScm )
        {
                CloseServiceHandle( hScm ); // close the handle to the service
        }
        WMISaveError( E_OUTOFMEMORY );
        return FALSE;
    }
    // check whether there any services or not ... if services count is zero, free the memory
    if ( 0 == m_dwServicesCount )
    {
        // no services exists
        FreeMemory( ( LPVOID * ) &pInfo );
    }
    else
    {
        // set the local pointer to the out parameter
        m_pServicesInfo = pInfo;
    }

    // inform success
    return TRUE;
}


BOOL
GetPerfDataBlock(
    IN HKEY hKey,
    IN LPWSTR pwszObjectIndex,
    IN PPERF_DATA_BLOCK* ppdb
    )
/*++
Routine Description:
    Rertieve performance data block.

Arguments:
    [in] hKey            : Contains handle to registry key.
    [in] pwszObjectIndex : Contains index value of an object.
    [out] ppdb           : Contains performance data.

Return Value:
    TRUE if success else FALSE is returned.
--*/
{
    // local variables
    LONG lReturn = 0;
    DWORD dwBytes = 0;
    BOOL bResult = FALSE;

    // check the input parameters
    if ( ( NULL == pwszObjectIndex ) || 
         ( NULL != *ppdb ) || 
         ( NULL == ppdb ) )
    {
        return FALSE;
    }
    // allocate memory for PERF_DATA_BLOCK
    dwBytes = 32 * 1024;        // initially allocate for 32 K
    *ppdb = (PPERF_DATA_BLOCK) AllocateMemory( dwBytes );
    if( NULL == *ppdb )
    {
        SetLastError( ( DWORD )E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // get performance data on passed Object
    lReturn = RegQueryValueEx( hKey, pwszObjectIndex, NULL, NULL, (LPBYTE) *ppdb, &dwBytes );
    while( ERROR_MORE_DATA == lReturn )
    {
        // increase memory by 8 K
        dwBytes += 8192;

        // since we are attempting to re-allocate the memory -- and in that process
        // some uncertain memory manipulations might occur -- for that reason,
        // instead of trying to re-allocate memory, release the current memory and
        // try to allocate if fresh
        FreeMemory( ( LPVOID * ) ppdb );

        // now allocate some more memory
        *ppdb = NULL;
        *ppdb = (PPERF_DATA_BLOCK) AllocateMemory( dwBytes );
        if( NULL == *ppdb )
        {
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // try to get the info again
        lReturn = RegQueryValueEx( hKey, pwszObjectIndex, NULL, NULL, (LPBYTE) *ppdb, &dwBytes );
    }

    // check the reason for coming out of the loop
    bResult = TRUE;
    if ( ERROR_SUCCESS != lReturn )
    {
        if ( NULL != *ppdb)
        {
            FreeMemory( ( LPVOID * ) ppdb );
            *ppdb = NULL;
        }

        // save the error info
        bResult = FALSE;
        SetLastError( ( DWORD )lReturn );
        SaveLastError();
    }

    // return the result
    return bResult;
}


BOOL
CALLBACK EnumWindowStationsFunc(
    IN LPTSTR lpstr,
    IN LPARAM lParam
    )
/*++
Routine Description:
     Enumerates the desktops available on a particular window station
     This is a CALLBACK function ... called by EnumWindowStations API function

Arguments:
      [ in ] lpstr    : window station name
      [ in ] lParam   : user supplied parameter to this function
                        in this function, this points to TTASKSLIST structure variable

Return Value:
      TRUE upon success and FALSE on failure
--*/
{
    // local variables
    HWINSTA hWinSta = NULL;
    HWINSTA hwinstaSave = NULL;
    PTWINDOWTITLES pWndTitles = ( PTWINDOWTITLES ) lParam;

    // check the input arguments
    if ( ( NULL == lpstr ) || ( NULL == lParam ) )
    {
        return FALSE;
    }
    // get and save the current window station
    hwinstaSave = GetProcessWindowStation();

    // open current tasks window station and change the context to the new workstation
    hWinSta = OpenWindowStation( lpstr, FALSE, MAXIMUM_ALLOWED );
    if ( NULL == hWinSta )
    {
        // failed in getting the process window station
        SaveLastError();
        return FALSE;
    }
    else
    {
        // change the context to the new workstation
        if ( ( hWinSta != hwinstaSave ) && ( FALSE == SetProcessWindowStation( hWinSta ) ) )
        {
            // failed in changing the context
            SaveLastError();
            return FALSE;
        }

        // release the memory allocated for earlier window station
        if ( NULL != pWndTitles->lpWinsta )
        {
            free( pWndTitles->lpWinsta );
            pWndTitles->lpWinsta = NULL;
        }

        // store the window station name
        pWndTitles->lpWinsta = _tcsdup( lpstr );
        if ( NULL == pWndTitles->lpWinsta )
        {
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();
            // restore the context to the previous windowstation
            if (hWinSta != hwinstaSave)
            {
                SetProcessWindowStation( hwinstaSave );
                CloseWindowStation( hWinSta );
            }
            return FALSE;
        }
    }

    // enumerate all the desktops for this windowstation
    EnumDesktops( hWinSta, EnumDesktopsFunc, lParam );

    // restore the context to the previous windowstation
    if (hWinSta != hwinstaSave)
    {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hWinSta );
    }

    // continue the enumeration
    return TRUE;
}


BOOL
CALLBACK EnumDesktopsFunc(
    IN LPTSTR lpstr,
    IN LPARAM lParam
    )
/*++
Routine Description:
      Enumerates the windows on a particular desktop
      This is a CALLBACK function ... called by EnumDesktops API function

Arguments:
      [ in ] lpstr    : desktop name
      [ in ] lParam   : user supplied parameter to this function
                        in this function, this points to TTASKSLIST structure variable

Return Value:
      TRUE upon success and FALSE on failure
--*/
{
    // local variables
    HDESK hDesk = NULL;
    HDESK hdeskSave = NULL;
    PTWINDOWTITLES pWndTitles = ( PTWINDOWTITLES )lParam;

    // check the input arguments
    if ( ( NULL == lpstr ) || ( NULL == lParam ) )
    {
        return FALSE;
    }
    // get and save the current desktop
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    // open the tasks desktop and change the context to the new desktop
    hDesk = OpenDesktop( lpstr, 0, FALSE, MAXIMUM_ALLOWED );
    if ( NULL == hDesk )
    {
        // failed in getting the process desktop
        SaveLastError();
        return FALSE;
    }
    else
    {
        // change the context to the new desktop
        if ( ( hDesk != hdeskSave ) && ( FALSE == SetThreadDesktop( hDesk ) ) )
        {
            // failed in changing the context
            SaveLastError();
            return FALSE;
        }

        // release the memory allocated for earlier window station
        if ( NULL != pWndTitles->lpDesk )
        {
            free( pWndTitles->lpDesk );
            pWndTitles->lpDesk = NULL;
        }

        // store the desktop name
        pWndTitles->lpDesk = _tcsdup( lpstr );
        if ( NULL == pWndTitles->lpDesk )
        {
            SetLastError( ( DWORD )E_OUTOFMEMORY );
            SaveLastError();
            // restore the previous desktop
            if ( hDesk != hdeskSave )
            {
                SetThreadDesktop( hdeskSave );
                CloseDesktop( hDesk );
            }
            return FALSE;
        }
    }

    // enumerate all windows in the new desktop
    // first try to get only the top level windows and visible windows only
    ( ( PTWINDOWTITLES ) lParam )->bFirstLoop = TRUE;
    EnumWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );
    EnumMessageWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );

    // enumerate all windows in the new desktop
    // now try to get window titles of all those processes whose we ignored earlier while
    // looping first time
    ( ( PTWINDOWTITLES ) lParam )->bFirstLoop = FALSE;
    EnumWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );
    EnumMessageWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );

    // restore the previous desktop
    if ( hDesk != hdeskSave )
    {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hDesk );
    }

    // continue enumeration
    return TRUE;
}


BOOL
CALLBACK EnumMessageWindows(
    IN WNDENUMPROC lpEnumFunc,
    IN LPARAM lParam
    )
/*++
Routine Description:
     Enumerates the message windows

Arguments:
     [ in ] lpEnumFunc   : address of call back function that has to be called for
                           each message window found
     [ in ] lParam       : user supplied parameter to this function
                           in this function, this points to TTASKSLIST structure variable

Return Value:
      TRUE upon success and FALSE on failure
--*/
{
    // local variables
    HWND hWnd = NULL;
    BOOL bResult = FALSE;

    // check the input arguments
    if ( ( NULL == lpEnumFunc ) || ( NULL == lParam ) )
    {
        return FALSE;
    }

    // enumerate all the message windows
    do
    {
        // find the message window
        hWnd = FindWindowEx( HWND_MESSAGE, hWnd, NULL, NULL );

        // check whether we got the handle to the message window or not
        if ( NULL != hWnd )
        {
            // explicitly call the windows enumerators call back function for this window
            bResult = ( *lpEnumFunc )( hWnd, lParam );

            // check the result of the enumeator call back function
            if ( FALSE == bResult )
            {
                // terminate the enumeration
                break;
            }
        }
    } while ( NULL != hWnd );

    // return the enumeration result
    return bResult;
}


BOOL
CALLBACK EnumWindowsProc(
    IN HWND hWnd,
    IN LPARAM lParam
    )
/*++
Routine Description:
      call back called by the API for each window
      retrives the window title and updates the accordingly

Arguments:
      [ in ] hWnd         : handle to the window
      [ in ] lParam       : user supplied parameter to this function
                            in this function, this points to TTASKSLIST structure variable

Return Value:
      TRUE upon success and FALSE on failure
--*/
{
    // local variables
    LONG lIndex = 0;
    DWORD dwPID = 0;
    BOOL bVisible = FALSE;
    BOOL bHung = FALSE;
    TARRAY arrWindows = NULL;
    PTWINDOWTITLES pWndTitles = NULL;
    WCHAR szWindowTitle[ 256 ] = NULL_STRING;

    // check the input arguments
    if ( ( NULL == hWnd ) || ( NULL == lParam ) )
    {
        return FALSE;
    }
    // get the values from the lParam
    pWndTitles = ( PTWINDOWTITLES ) lParam;
    arrWindows = pWndTitles->arrWindows;

    // get the processid for this window
    if ( 0 == GetWindowThreadProcessId( hWnd, &dwPID ) )
    {
        // failed in getting the process id
        return TRUE;            // return but, proceed enumerating other window handle
    }

    // get the visibility state of the window
    // if the window is not visible, and if this is the first we are enumerating the
    // window titles, ignore this process
    bVisible = GetWindowLong( hWnd, GWL_STYLE ) & WS_VISIBLE;
    if ( ( FALSE == bVisible ) && ( TRUE == pWndTitles->bFirstLoop ) )
    {
        return TRUE;    // return but, proceed enumerating other window handle
    }
    // check whether the current window ( for which we have the handle )
    // is main window or not. we don't need child windows
    if ( NULL != GetWindow(hWnd, GW_OWNER) )
    {
        // the current window handle is not for a top level window
        return TRUE;            // return but, proceed enumerating other window handle
    }

    // check if we are already got the window handle for the curren process or not
    // save it only if we are not having it
    lIndex = DynArrayFindDWORDEx( arrWindows, CTaskList::twiProcessId, dwPID );
    if (  -1 == lIndex )
    {
        // window for this process is not there ... save it
        lIndex = DynArrayAppendRow( arrWindows, CTaskList::twiCOUNT );
    }
    else
    {
        // check whether window details already exists or not
        if ( NULL != DynArrayItemAsHandle2( arrWindows, lIndex, CTaskList::twiHandle ) )
        {
            lIndex = -1;        // window details already exists
        }
    }

    // check if window details has to be saved or not ... if needed save them
    if ( -1 != lIndex )
    {
        // check whether the application associated with this windows
        // responding ( or ) not responding
        bHung = IsHungAppWindow( hWnd );

        // save the data
        DynArraySetHandle2( arrWindows, lIndex, CTaskList::twiHandle, hWnd );
        DynArraySetBOOL2( arrWindows, lIndex, CTaskList::twiHungInfo, bHung );
        DynArraySetDWORD2( arrWindows, lIndex, CTaskList::twiProcessId, dwPID );
        DynArraySetString2( arrWindows, lIndex,
            CTaskList::twiWinSta, pWndTitles->lpWinsta, 0 );
        DynArraySetString2( arrWindows, lIndex,
            CTaskList::twiDesktop, pWndTitles->lpDesk, 0 );

        // get and save the window title
        if ( 0 != GetWindowText( hWnd, szWindowTitle, SIZE_OF_ARRAY( szWindowTitle ) ) )
        {
            DynArraySetString2( arrWindows, lIndex, CTaskList::twiTitle, szWindowTitle, 0 );
        }
    }

    // continue the enumeration
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\wmi.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    WMI.cpp

Abstract:

    Common functionlity for dealing with WMI.

Author:

    Wipro Technologies

Revision History:

    22-Dec-2000 : Created It.
    24-Apr-2001 : Closing the review comments given by client.

*********************************************************************************************/

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD              GetResString( IDS_STR_INPUT_PASSWORD )
#define INPUT_PASSWORD_LEN          256
// error constants
#define E_SERVER_NOTFOUND           0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface,
                              DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface,
                              LPCWSTR pwszUser,
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword,
                                      LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices,
                          LPCWSTR pwszMethod, DWORD dwHDefKey,
                          LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );


BOOL
IsValidUserEx(
    LPCWSTR pwszUser
    )
/*++

Routine Description:

    Checks wether the User name is a valid one or not

Arguments:

    [in] LPCWSTR    :   String containing the user name

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    CHString strUser;
    LONG lPos = 0;

    if ( ( NULL == pwszUser ) || ( 0 == StringLength( pwszUser, 0 ) ) )
    {
        return TRUE;
    }

    try
    {
        // get user into local memory
        strUser = pwszUser;

        // user name should not be just '\'
        if ( strUser.CompareNoCase( L"\\" ) == 0 )
        {
            return FALSE;
        }

        // user name should not contain invalid characters
        if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
        {
            return FALSE;
        }

        // SPECIAL CHECK
        // check for multiple '\' characters in the user name
        lPos = strUser.Find( L'\\' );
        if ( -1 != lPos )
        {
            // '\' character exists in the user name
            // strip off the user info upto first '\' character
            // check for one more '\' in the remaining string
            // if it exists, invalid user
            strUser = strUser.Mid( lPos + 1 );
            lPos = strUser.Find( L'\\' );
            if ( -1 != lPos )
            {
                return FALSE;
            }
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // user name is valid
    return TRUE;
}


BOOL
IsValidServerEx(
    LPCWSTR pwszServer,
    BOOL& bLocalSystem
    )
/*++

Routine Description:

    Checks wether the Server name is a valid one or not

Arguments:

    [in]  LPCWSTR   :   String containing the user name
    [out] BOOL      :   Is set to TRUE if the local system is being queried.

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    CHString strTemp;

    // Validate input arguments.
    if ( ( NULL == pwszServer ) || ( 0 == StringLength( pwszServer, 0 ) ) )
    {
       bLocalSystem = TRUE;
       return TRUE;
    }

    try
    {
        // kick-off
        bLocalSystem = FALSE;

        if( IsNumeric( pwszServer, 10, FALSE ) == TRUE )
        {
            return FALSE;
        }

        // get a local copy
        strTemp = pwszServer;

        // remove the forward slashes (UNC) if exist in the begining of the server name
        if ( IsUNCFormat( strTemp ) == TRUE )
        {
            strTemp = strTemp.Mid( 2 );
            if ( strTemp.GetLength() == 0 )
            {
                return FALSE;
            }
        }

        if ( strTemp.FindOneOf( L"`~!@#$^&*()+=[]{}|\\<>,?/\"':;" ) != -1 )
        {
            return FALSE;
        }

        // now check if any '\' character appears in the server name. If so error
        if ( strTemp.Find( L'\\' ) != -1 )
        {
            return FALSE;
        }

        // now check if server name is '.' only which represent local system in WMI
        // else determine whether this is a local system or not
        if ( strTemp.CompareNoCase( L"." ) == 0 )
        {
            bLocalSystem = TRUE;
        }
        else
        {
            bLocalSystem = IsLocalSystem( strTemp );
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // inform that server name is valid
    return TRUE;
}


BOOL
InitializeCom(
    IWbemLocator** ppLocator
    )
/*++
Routine Description:

    Initializes the COM library

Arguments:

    [in] IWbemLocator   :   pointer to the IWbemLocator

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;

    try
    {
        // Validate input arguments.
        if( ( NULL == ppLocator ) ||
            ( NULL != *ppLocator ) )
        {
             _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // initialize the COM library
        SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_MULTITHREADED ) );

        // initialize the security
        SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

        // create the locator and get the pointer to the interface of IWbemLocator
        SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

        // initialization successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the WMI error
        WMISaveError( e );
        // Error is returned. Release any interface pointers.
        SAFE_RELEASE( *ppLocator );
    }

    // return the result;
    return bResult;
}


BOOL
ConnectWmi(
    IWbemLocator* pLocator,
    IWbemServices** ppServices,
    LPCWSTR pwszServer,
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    COAUTHIDENTITY** ppAuthIdentity,
    BOOL bCheckWithNullPwd,
    LPCWSTR pwszNamespace,
    HRESULT* phr,
    BOOL* pbLocalSystem,
    IWbemContext* pWbemContext
    )
/*++

Routine Description:

    This function makes a connection to WMI.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;
    _bstr_t bstrServer;
    _bstr_t bstrNamespace;
    _bstr_t bstrUser, bstrPassword;

    // check whether locator object exists or not
    // if not exists, return
    if ( ( NULL == pLocator ) ||
         ( NULL == ppServices ) ||
         ( NULL != *ppServices ) ||
         ( NULL == pwszNamespace ) )
    {
        if ( NULL != phr )
        {
            *phr = WBEM_E_INVALID_PARAMETER;
        }
        // return failure
        return FALSE;
    }

    // kick-off
    if ( NULL != pbLocalSystem )
    {
        *pbLocalSystem = FALSE;
    }
    // ...
    if ( NULL != phr )
    {
        *phr = WBEM_S_NO_ERROR;
    }

    try
    {

        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // validate the server name
        // NOTE: The error being raised in custom define for '0x800706ba' value
        //       The message that will be displayed in "The RPC server is unavailable."
        if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
        {
            _com_issue_error( E_SERVER_NOTFOUND );
        }

        // validate the user name
        if ( IsValidUserEx( pwszUser ) == FALSE )
        {
            _com_issue_error( ERROR_NO_SUCH_USER );
        }

        // prepare namespace
        bstrNamespace = pwszNamespace;              // name space
        if ( ( NULL != pwszServer ) && ( FALSE == bLocalSystem ) )
        {
            // get the server name
            bstrServer = pwszServer;

            // prepare the namespace
            // NOTE: check for the UNC naming format of the server and do
            if ( IsUNCFormat( pwszServer ) == TRUE )
            {
                bstrNamespace = bstrServer + L"\\" + pwszNamespace;
            }
            else
            {
                bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
            }

            // user credentials
            if ( ( NULL != pwszUser ) && ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                // copy the user name
                bstrUser = pwszUser;

                // if password is empty string and if we need to check with
                // null password, then do not set the password and try
                bstrPassword = pwszPassword;
                if ( ( TRUE == bCheckWithNullPwd ) && ( 0 == bstrPassword.length() ) )
                {
                    bstrPassword = (LPWSTR) NULL;
                }
            }
        }
        else
        {    // Display warning message, credentials not required for local system.
            if( ( TRUE == bLocalSystem ) && ( NULL != pwszUser ) &&
                ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                 // got the credentials for the local system
                 if ( NULL != phr )
                 {
                     *phr = WBEM_E_LOCAL_CREDENTIALS;
                 }
            }
        }

        // connect to the remote system's WMI
        // there is a twist here ...
        // do not trap the ConnectServer function failure into exception
        // instead handle that action manually
        // by default try the ConnectServer function as the information which we have
        // in our hands at this point. If the ConnectServer is failed,
        // check whether password variable has any contents are not ... if no contents
        // check with "" (empty) password ... this might pass in this situation ..
        // if this call is also failed ... nothing is there that we can do ... throw the exception
        hr = pLocator->ConnectServer( bstrNamespace,
            bstrUser, bstrPassword, 0L, 0L, NULL, pWbemContext, ppServices );
        if ( FAILED( hr ) )
        {
            //
            // special case ...

            // check whether password exists or not
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'
            if ( hr == E_ACCESSDENIED )
            {
                // check if we tried to connect to the system using null password
                // if so, then try connecting to the remote system with empty string
                if ( bCheckWithNullPwd == TRUE &&
                     bstrUser.length() != 0 && bstrPassword.length() == 0 )
                {
                    // now invoke with ...
                    hr = pLocator->ConnectServer( bstrNamespace,
                        bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, pWbemContext, ppServices );
                }
            }
            else
            {
                if ( WBEM_E_LOCAL_CREDENTIALS == hr )
                {
                    // credentials were passed to the local system.
                    // So ignore the credentials and try to reconnect
                    bLocalSystem = TRUE;
                    bstrUser = (LPWSTR) NULL;
                    bstrPassword = (LPWSTR) NULL;
                    bstrNamespace = pwszNamespace;              // name space
                    hr = pLocator->ConnectServer( bstrNamespace,
                        NULL, NULL, 0L, 0L, NULL, pWbemContext, ppServices );
                }
            }

            // now check the result again .. if failed .. ummmm..
            if ( FAILED( hr ) )
            {
                _com_issue_error( hr );
            }
            else
            {
                bstrPassword = L"";
            }
        }

        // set the security at the interface level also
        SAFE_EXECUTE( SetInterfaceSecurity( *ppServices,
            bstrUser, bstrPassword, ppAuthIdentity ) );

        // ...
        if ( NULL != pbLocalSystem )
        {
            *pbLocalSystem = bLocalSystem;
        }

        // connection to WMI is successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        try
        {
            // save the error
            WMISaveError( e );

            // save the hr value if needed by the caller
            if ( NULL != phr )
            {
                *phr = e.Error();
            }
        }
        catch( ... )
        {
            WMISaveError( E_OUTOFMEMORY );
        }
        SAFE_RELEASE( *ppServices );
        bResult = FALSE;
    }

    // return the result
    return bResult;
}


BOOL
ConnectWmiEx(
    IWbemLocator* pLocator,
    IWbemServices** ppServices,
    LPCWSTR pwszServer,
    CHString& strUserName,
    CHString& strPassword,
    COAUTHIDENTITY** ppAuthIdentity,
    BOOL bNeedPassword,
    LPCWSTR pwszNamespace,
    BOOL* pbLocalSystem,
    DWORD dwPasswordLen,
    IWbemContext* pWbemContext
    )
/*++

Routine Description:

    This function is a wrapper function for the ConnectWmi function.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system
    [ in ] DWORD                :   Contains maximum password buffer length.

Return Value:

    TRUE on success
    FALSE on failure

NOTE: 'dwPasswordLen' WILL BE TAKEN AS 'MAX_STRING_LENGTH' IF NOT SPECIFIED.
      IT IS USER RESPOSIBILITY TO SET THIS PARAMETER TO LIMITING VALUE.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszPassword = NULL;
    CHString strBuffer;

    try
    {
        // sometime users want the utility to prompt for the password
        // check what user wants the utility to do
        if ( ( TRUE == bNeedPassword ) &&
             ( 0 == strPassword.Compare( L"*" ) ) )
        {
            // user wants the utility to prompt for the password
            // so skip this part and let the flow directly jump the password acceptance part
        }
        else
        {
            // try to establish connection to the remote system with the credentials supplied
            if ( 0 == strUserName.GetLength() )
            {
                // user name is empty
                // so, it is obvious that password will also be empty
                // even if password is specified, we have to ignore that
                bResult = ConnectWmi( pLocator, ppServices,
                    pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem, pWbemContext );
            }
            else
            {
                // credentials were supplied
                // but password might not be specified ... so check and act accordingly
                LPCWSTR pwszTemp = NULL;
                BOOL bCheckWithNull = TRUE;
                if ( bNeedPassword == FALSE )
                {
                    pwszTemp = strPassword;
                    bCheckWithNull = FALSE;
                }

                // ...
                bResult = ConnectWmi( pLocator, ppServices, pwszServer,
                    strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem, pWbemContext );
            }

            SetLastError( hr );
            // check the result ... if successful in establishing connection ... return
            if ( TRUE == bResult )
            {
                return TRUE;
            }

            // now check the kind of error occurred
            switch( hr )
            {
            case E_ACCESSDENIED:
                SetLastError( hr );
                break;

            case WBEM_E_LOCAL_CREDENTIALS:
                SetLastError( hr );
                // needs to do special processing
                break;

            case WBEM_E_ACCESS_DENIED:
            default:
                // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
                //       this error code says that user with the current credentials is not
                //       having access permisions to the 'namespace'
                WMISaveError( hr );
                return FALSE;       // no use of accepting the password .. return failure
                break;
            }


            // if failed in establishing connection to the remote terminal
            // even if the password is specifed, then there is nothing to do ... simply return failure
            if ( bNeedPassword == FALSE )
            {
                return FALSE;
            }
        }

        // check whether user name is specified or not
        // if not, get the local system's current user name under whose credentials, the process
        // is running
        if ( 0 == strUserName.GetLength() )
        {
            // sub-local variables
            LPWSTR pwszUserName = NULL;
            DWORD dwUserLength = 0;    // Username buffer length.
            // Retrieve the buffer length need to store username.
            GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength );

            // get the required buffer
            pwszUserName = strUserName.GetBufferSetLength( dwUserLength );

            if ( FALSE == GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) )
            {
                // error occured while trying to get the current user info
                SaveLastError();
                return FALSE;
            }
            // No need to call 'ReleaseBuffer' since only sufficient memory is allocated.
        }

        // get the required buffer
        if( 0 == dwPasswordLen )
        {
             dwPasswordLen = INPUT_PASSWORD_LEN;
        }
        pwszPassword = strPassword.GetBufferSetLength( dwPasswordLen );

        // accept the password from the user
        strBuffer.Format( INPUT_PASSWORD, strUserName );
        WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ),
            strBuffer, strBuffer.GetLength(), &dwSize, NULL );

        bResult = GetPassword( pwszPassword, dwPasswordLen );
        if ( TRUE != bResult )
        {
            return FALSE;
        }

        // release the buffer allocated for password
        strPassword.ReleaseBuffer();

        // now again try to establish the connection using the currently
        // supplied credentials
        bResult = ConnectWmi( pLocator, ppServices, pwszServer,
            strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace,
            NULL, pbLocalSystem, pWbemContext );
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return the failure
    return bResult;
}


HRESULT
GetSecurityArguments(
    IUnknown* pInterface,
    DWORD& dwAuthorization,
    DWORD& dwAuthentication
    )
/*++

Routine Description:

    This function gets the values for the security services.

Arguments:

    [in] IUnknown   :   pointer to the IUnkown interface
    [out] DWORD     :   to hold the authentication service value
    [out] DWORD     :   to hold the authorization service value

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
    IClientSecurity* pClientSecurity = NULL;

    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    // try to get the client security services values if possible
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
    if ( SUCCEEDED( hr ) )
    {
        // got the client security interface
        // now try to get the security services values
        hr = pClientSecurity->QueryBlanket( pInterface,
            &dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
        if ( SUCCEEDED( hr ) )
        {
            // we've got the values from the interface
            dwAuthentication = dwAuthnSvc;
            dwAuthorization = dwAuthzSvc;
        }

        // release the client security interface
        SAFE_RELEASE( pClientSecurity );
    }

    // return always success
    return hr;
}


HRESULT
SetInterfaceSecurity(
    IUnknown* pInterface,
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    COAUTHIDENTITY** ppAuthIdentity
    )
/*++

Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] LPCWSTR            :   string containing the User name
    [in] LPCWSTR            :   string containing the password
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString strUser;
    CHString strDomain;
    LPCWSTR pwszUserArg = NULL;
    LPCWSTR pwszDomainArg = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    try
    {
        // check the interface
        if ( NULL == pInterface )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // check the authentity strcuture ... if authentity structure is already ready
        // simply invoke the 2nd version of SetInterfaceSecurity
        if ( NULL != *ppAuthIdentity )
        {
            return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
        }

        // If we are doing trivial case, just pass in a null authenication structure
        // for which the current logged in user's credentials will be considered
        if ( ( NULL == pwszUser ) &&
             ( NULL == pwszPassword ) )
        {
            // set the security
            hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization,
                NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

            // return the result
            return hr;
        }

        // if authority srtucture is NULL then no need to proceed
        if ( NULL == ppAuthIdentity )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // check if authenication info is available or not ...
        // initialize the security authenication information ... UNICODE VERSION STRUCTURE
        if ( NULL == *ppAuthIdentity )
        {
            // parse and find out if the user name contains the domain name
            // if contains, extract the domain value from it
            LONG lPos = -1;
            strDomain = L"";
            strUser = pwszUser;
            if ( -1 != ( lPos = strUser.Find( L'\\' ) ) )
            {
                // user name contains domain name ... domain\user format
                strDomain = strUser.Left( lPos );
                strUser = strUser.Mid( lPos + 1 );
            }
            else
            {
                if ( -1 != ( lPos = strUser.Find( L'@' ) ) )
                {
                    // NEED TO IMPLEMENT THIS ... IF NEEDED
                    // This implementation needs to be done if WMI does not support
                    // UPN name formats directly and if we have to split the
                    // name(user@domain)
                }
                else
                {
                    // server itself is the domain
                    // NOTE: NEED TO DO SOME R & D ON BELOW COMMENTED LINE
                    // strDomain = pwszServer;
                }
             }

            // get the domain info if it exists only
            if ( 0 != strDomain.GetLength() )
            {
                pwszDomainArg = strDomain;
            }

            // get the user info if it exists only
            if ( 0 != strUser.GetLength() )
            {
                pwszUserArg = strUser;
            }

            hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
            if ( FAILED(hr) )
            {
              return hr;
            }
        }

        // set the security information to the interface
        hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );
    }
    catch( CHeap_Exception )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    // return the result
    return hr;
}


HRESULT
SetInterfaceSecurity(
    IUnknown* pInterface,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    // 'pAuthIdentity' can be NULL or not, so need to check.
    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // get the current security argument value
    hr = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}


HRESULT
WINAPI SetProxyBlanket(
    IUnknown* pInterface,
    DWORD dwAuthnSvc,
    DWORD dwAuthzSvc,
    LPWSTR pwszPrincipal,
    DWORD dwAuthLevel,
    DWORD dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
    DWORD dwCapabilities
    )
/*++

Routine Description:

    This function sets the authentication information (the security blanket)
    that will be used to make calls.

Arguments:

    [in] IUnknown                       :   pointer to the IUnkown interface
    [in] DWORD                          :   contains the authentication service to use
    [in] DWORD                          :   contains the authorization service to use
    [in] LPWSTR                         :   the server principal name to use
    [in] DWORD                          :   contains the authentication level to use
    [in] DWORD                          :   contains the impersonation level to use
    [in] RPC_AUTH_IDENTITY_HANDLE       :   pointer to the identity of the client
    [in] DWORD                          :   contains the capability flags

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

    // Validate input arguments.
    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if( ( NULL == pInterface ) ||
        ( ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) ) &&
          ( NULL != pAuthInfo ) )
      )
    {
        return( WBEM_E_INVALID_PARAMETER );
    }

    // get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( FAILED(hr) )
    {
        return hr;
    }

    // now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( FAILED(hr) )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    // now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pUnknown );
        SAFE_RELEASE( pClientSecurity );
        return hr;
    }

    // release the security interface
    SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( NULL != pAuthInfo )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( SUCCEEDED(hr) )
        {
            // set security authentication
            hr = pClientSecurity->SetBlanket( pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

            // release
            SAFE_RELEASE( pClientSecurity );
        }
        else
        {
            if ( E_NOINTERFACE == hr )
            {
                hr = S_OK;      // ignore no interface errors
            }
        }
    }

    // release the IUnknown
    SAFE_RELEASE( pUnknown );

    // return the result
    return hr;
}


HRESULT
WINAPI WbemAllocAuthIdentity(
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    LPCWSTR pwszDomain,
    COAUTHIDENTITY** ppAuthIdent
    )
/*++

Routine Description:

    This function allocates memory for the AUTHIDENTITY structure.

Arguments:

    [in] LPCWSTR            :   string containing the user name
    [in] LPCWSTR            :   string containing the password
    [in] LPCWSTR            :   string containing the domain name
    [out] COAUTHIDENTITY    :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

NOTE: 'ppAuthIdent' should be freed by calling 'WbemFreeAuthIdentity' by the user after
      their work is done.

--*/
{
    // local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

    // validate the input parameter
    if ( NULL == ppAuthIdent )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // init with 0's
    SecureZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

    //
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong

    // user
    if ( NULL != pwszUser )
    {
        // allocate memory for user
        LONG lLength = StringLength( pwszUser, 0 );
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->User )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        StringCopy( pAuthIdent->User, pwszUser, (lLength + 1) );
    }

    // domain
    if ( NULL != pwszDomain )
    {
        // allocate memory for domain
        LONG lLength = StringLength( pwszDomain, 0 );
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Domain )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        StringCopy( pAuthIdent->Domain, pwszDomain, (lLength + 1) );
    }

    // passsord
    if ( NULL != pwszPassword )
    {
        // allocate memory for passsord
        LONG lLength = StringLength( pwszPassword, 0 );
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Password )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        StringCopy( pAuthIdent->Password, pwszPassword, (lLength + 1) );
    }

    // type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
    *ppAuthIdent = pAuthIdent;

    // return result
    return S_OK;
}


VOID
WINAPI WbemFreeAuthIdentity(
    COAUTHIDENTITY** ppAuthIdentity
    )
/*++

Routine Description:

    This function releases the memory allocated for the AUTHIDENTITY structure.

Arguments:

    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    None

--*/
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
        // free the memory allocated for user
        if ( NULL != (*ppAuthIdentity)->User )
        {
            CoTaskMemFree( (*ppAuthIdentity)->User );
            (*ppAuthIdentity)->User = NULL;
        }

        // free the memory allocated for password
        if ( NULL != (*ppAuthIdentity)->Password )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Password );
            (*ppAuthIdentity)->Password = NULL;
        }

        // free the memory allocated for domain
        if ( NULL != (*ppAuthIdentity)->Domain )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Domain );
            (*ppAuthIdentity)->Domain = NULL;
        }

        // final the structure
        CoTaskMemFree( *ppAuthIdentity );
        *ppAuthIdentity = NULL;
    }
}


VOID
WMISaveError(
    HRESULT hrError
    )
/*++

Routine Description:

    This function saves the description of the last error returned by WMI

Arguments:

    HRESULT     :   The last return value from WMI

Return Value:

    NONE

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IWbemStatusCodeText* pWbemStatus = NULL;
    _bstr_t bstrErrorString;

    try
    {
        // Set error to different value.
        if ( E_ACCESSDENIED == hrError )
        {
            // change the error message to "Logon failure: unknown user name or bad password."
            hrError = ERROR_LOGON_FAILURE;
        }

        //Set the reason to incompatible os when no class is registered on remote mechine
        if( 0x80040154 == hrError )
        {
            bstrErrorString = _bstr_t( GetResString(IDS_ERROR_REMOTE_INCOMPATIBLE));
            SetReason( bstrErrorString );
            return;
        }
        else
        {   // Get error string.
            hr = CoCreateInstance( CLSID_WbemStatusCodeText,
                                   NULL, CLSCTX_INPROC_SERVER,
                                   IID_IWbemStatusCodeText,
                                   (LPVOID*) &pWbemStatus );
            if( SUCCEEDED( hr ) )
            {
                BSTR bstrString = NULL;
                // Get error string from error code.
                hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0,
                                                    &bstrString );
                if( NULL != bstrString )
                {
                    bstrErrorString = _bstr_t( bstrString );
                    SysFreeString( bstrString );
                }
                if( FAILED( hr ) )
                {
                    _com_issue_error( hrError );
                }
				SAFE_RELEASE( pWbemStatus );
            }
            else
            {
                _com_issue_error( hrError );
            }
        }
    }
    catch( _com_error& e )
    {   // We have got the error. Needs to handle carefully.
        LPWSTR lpwszGetString = NULL;
		SAFE_RELEASE( pWbemStatus );
        try
        {   // ErrorMessage() can throw an exception.
            DWORD dwLength = StringLength( e.ErrorMessage(), 0 ) + 5 ;
            lpwszGetString = ( LPWSTR )AllocateMemory( dwLength * sizeof( WCHAR ) );
            if( NULL != lpwszGetString )
            {
                StringCopy( lpwszGetString, e.ErrorMessage(), dwLength );
                StringConcat( lpwszGetString, L"\n", dwLength );
                SetReason( ( LPCWSTR )lpwszGetString );
                FreeMemory( (LPVOID*) &lpwszGetString );
            }
            else
            {   // Failed to know the exact error occured
                // due to insufficient memory.
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
            }
        }
        catch( ... )
        {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
        }
        return;
    }

    SetReason( (LPCWSTR) bstrErrorString );
    return;
}


HRESULT
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    _variant_t& varValue
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   property name
    [out] _variant_t            :   value of the property

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    VARIANT vtValue;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // initialize the variant and then get the value of the specified property
        VariantInit( &vtValue );
        // Call 'Get' method to retireve the value from WMI.
        hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
        if ( FAILED( hr ) )
        {
            // Clear the variant variable
            VariantClear( &vtValue );
            // Return error.
            return hr;
        }

        // set the value
        varValue = vtValue;
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // Clear the variables.
    VariantClear( &vtValue );
    // Return.
    return hr;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    CHString& strValue,
    LPCWSTR pwszDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in string format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] CHString              :   variable to hold the retrieved property
    [in] LPCWSTR                :   string containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t var;

    strValue.Empty();

    try
    {
        // first copy the default value
        strValue = pwszDefault;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the property value
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // Get the value
        // If 'var' does not contain value of requested type
        // then default value is returned.
        if ( VT_BSTR == V_VT( &var ) )
        {
            strValue = (LPCWSTR) _bstr_t( var );
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    DWORD& dwValue,
    DWORD dwDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in dword format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] DWORD                 :   variable to hold the retrieved property
    [in] DWORD                  :   dword containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr;
    _variant_t var;

    try
    {
        // first set the defaul value
        dwValue = dwDefault;

        // check with object and property passed to the function are valid or not
        // if not, return failure
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the value of the property
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // get the process id from the variant
        switch( V_VT( &var ) )
        {
        case VT_I2:
            dwValue = V_I2( &var );
            break;
        case VT_I4:
            dwValue = V_I4( &var );
            break;
        case VT_UI2:
            dwValue = V_UI2( &var );
            break;
        case VT_UI4:
            dwValue = V_UI4( &var );
            break;
        case VT_INT:
            dwValue = V_INT( &var );
            break;
        case VT_UINT:
            dwValue = V_UINT( &var );
            break;
        default:
            // Requested type is not found.
            // If 'var' does not contain value of requested type
            // then default value is returned.
        break;
        };
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    ULONGLONG& ullValue
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in ulongulong format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] ULONGULONG            :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // Local variables
    CHString str;

    str.Empty();

    try
    {
        // first set the default value
        ullValue = 1;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }

        // get the value of the property
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) )
        { // Error is already set in 'PropertyGet' function.
            return FALSE;
        }

        // get the 64-bit value
        ullValue = _wtoi64( str );

        // Check for error condition.
        if( 0 == ullValue )
        {
            ullValue = 1;
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }
    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    WBEMTime& wbemtime )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in wbemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    CHString str;

    // Clear method sets the time in the WBEMTime object to an invalid time.
    wbemtime.Clear();
    try
    {
        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }

        // get the value of the property
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) )
        {   // Error is already set in 'PropertyGet' function.
            return FALSE;
        }

        // convert into the time value
        wbemtime = _bstr_t( str );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    SYSTEMTIME& systime )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in systemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // local variables
    CHString strTime;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // get the value of the property
        // 16010101000000.000000+000 is the default time
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) )
        {   // Error is already set.
            return FALSE;
        }

        // prepare the systemtime structure
        // yyyymmddHHMMSS.mmmmmmsUUU
        // NOTE: NO NEED CALL 'IsNumeric()' BEFORE 'AsLong'.
        // Left and MID methods can throw an exception.
        systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
        systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
        systime.wDayOfWeek = 0;
        systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
        systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
        systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
        systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
        systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );

    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    _variant_t& varValue
    )
/*++

Routine Description:

    Sets the value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] WBEMTime               :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    VARIANT var;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // put the value
        var = varValue;
        hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // return the result
    return hr;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    LPCWSTR pwszValue
    )
/*++

Routine Description:

    Sets the string value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] LPCWSTR                :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    _variant_t varValue;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) ||
         ( NULL == pwszValue ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = pwszValue;
        SAFE_EXECUTE( PropertyPut( pWmiObject, pwszProperty, varValue ) );
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // return
    return hr;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    DWORD dwValue
    )
/*++

Routine Description:

    Sets the dword value of the property to the WMI class object.

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] DWORD                  :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    _variant_t varValue;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = ( LONG )dwValue;
        SAFE_EXECUTE( PropertyPut( pWmiObject, pwszProperty, varValue ) );
    }
    catch( _com_error& e )
    {
        return e.Error();
    }

    // return
    return S_OK;
}


HRESULT
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    LPCWSTR pwszMethod,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    _variant_t& varValue
    )
/*++

Routine Description:

    This function retrieves the value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] LPCWSTR                :   the name of the method to execute
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [in] _variant_t             :   variable holding the property value retrieved

Return Value:

    TRUE on success
    FALSE on failure

NOTE: Pass arguments of type mentioned in declaration of this function.
      EX: Don't pass 'CHString' argument if 'LPWSTR' is expected.
      Reason: 'CHString' can throw an exception of type 'CHEAP_EXCEPTION'
               which is not handled by this function.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    DWORD dwReturnValue = 0;
    IWbemClassObject* pClass = NULL;
    IWbemClassObject* pMethod = NULL;
    IWbemClassObject* pInParams = NULL;
    IWbemClassObject* pInParamsInstance = NULL;
    IWbemClassObject* pOutParamsInstance = NULL;

    // check the input value
    if ( ( NULL == pWbemServices == NULL ) ||
         ( NULL == pwszMethod ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // NOTE: If SAFE_EXECUTE( pWbemServices->GetObject(
    //       _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
    //       is executed then,
    //       NO NEED TO CHECK FOR ( PCLASS == NULL ) SINCE IN ALL CASES
    //       OF ERROR THIS VARIABLE WILL BE NULL.

    try
    {
        // get the registry class object
        SAFE_EXECUTE( pWbemServices->GetObject(
            _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );

        // get the method reference required
        SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );

        // create the instance for the in parameters
        SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );

        // set the input values
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey ) );
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName ) );
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName ) );

        // now execute the method
        SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
            _bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
        if ( NULL == pOutParamsInstance )           // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // now check the return value of the method from the output params object
        bResult = PropertyGet( pOutParamsInstance,
            _bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
        if ( ( FALSE == bResult ) ||
             ( 0 != dwReturnValue ) )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // Comapre string and take appropriate action.
        if ( 0 == StringCompare( pwszMethod, WMI_REGISTRY_M_DWORDVALUE, TRUE, 0 ) )
        {
            SAFE_EXECUTE( PropertyGet( pOutParamsInstance,
                                       _bstr_t( WMI_REGISTRY_OUT_VALUE_DWORD ), varValue ) );
        }
        else
        {
            SAFE_EXECUTE( PropertyGet( pOutParamsInstance,
                                       _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue ) );
        }
    }
    catch( _com_error& e )
    {
		SAFE_RELEASE( pClass );
		SAFE_RELEASE( pMethod );
		SAFE_RELEASE( pInParams );
		SAFE_RELEASE( pInParamsInstance );
		SAFE_RELEASE( pOutParamsInstance );
        hr = e.Error();
    }

    // release the interfaces
    SAFE_RELEASE( pClass );
    SAFE_RELEASE( pMethod );
    SAFE_RELEASE( pInParams );
    SAFE_RELEASE( pInParamsInstance );
    SAFE_RELEASE( pOutParamsInstance );

    // return success
    return hr;
}


BOOL
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    CHString& strValue,
    LPCWSTR pwszDefault
    )
/*++

Routine Description:

    This function retrieves the string value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] CHString              :   variable holding the property value retrieved
    [in] LPCWSTR                :   the default value for this property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

      This function won't return values if they are obtained as reference
      from WMI.
      EX: 'VARTYPE' recieved is of type 'VT_BSTR | VT_BYREF' then FALSE is
           returned.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varValue;

    // Check the input
    if ( ( NULL == pWbemServices ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // Set the default value
        if ( NULL != pwszDefault )
        {
            strValue = pwszDefault;
        }

        // Get the value
        hr = RegQueryValueWMI( pWbemServices,
            WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // Get the value from the variant
        // Get the value
        if ( VT_BSTR == V_VT( &varValue ) )
        {
            strValue = (LPCWSTR)_bstr_t( varValue );
        }
        else
        {
            // Requested type is not found.
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {   // Exception throw by '_variant_t'.
        WMISaveError( e );
        return FALSE;
    }

    // return success
    return TRUE;
}


DWORD
GetTargetVersionEx(
    IWbemServices* pWbemServices,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function gets the version of the system from which we are trying to retrieve
    information from.

Arguments:

    [in] IWbemServices      :   pointer to the IWbemServices object
    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    DWORD   -   Target version of the machine if found else 0.

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    LONG lPos = 0;
    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwVersion = 0;
    ULONG ulReturned = 0;
    CHString strVersion;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;

    // Check the input value
    if ( NULL == pWbemServices )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return 0;
    }

    try
    {
        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum(
            _bstr_t( CLASS_CIMV2_Win32_OperatingSystem ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time.
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( 0 == ulReturned )
        {
            // release the interfaces
            WMISaveError( WBEM_S_FALSE );
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( FALSE == PropertyGet( pWbemObject, L"Version", strVersion ) )
        {
            // release the interfaces
            // Error is already set in the called function.
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );

        //
        // now determine the os version
        dwMajor = dwMinor = 0;

        // Get the major version
        lPos = strVersion.Find( L'.' );
        if ( -1 == lPos )
        {
            // The version string itself is version ... THIS WILL NEVER HAPPEN
            if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion, 10 );
        }
        else
        {
            // major version
            if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

            // get the minor version
            strVersion = strVersion.Mid( lPos + 1 );
            lPos = strVersion.Find( L'.' );
            if ( -1 == lPos)
            {
                if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion, 10 );
            }
            else
            {
                if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
            }
        }

        // mix the version info
        dwVersion = dwMajor * 1000 + dwMinor;
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }

    // If successful then 'pWbemObject' and 'pWbemInstances' are already released.
    // return
    return dwVersion;
}


DWORD
GetTargetPlatformEx(
    IWbemServices* pWbemServices,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function gets the version of the system from which we are trying to retrieve
    information from.

Arguments:

    [in] IWbemServices      :   pointer to the IWbemServices object
    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    DWORD   -   Target version of the machine if found else 0.

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString strType;
    ULONG ulReturned = 0;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;

    // Check the input value
    if ( NULL == pWbemServices )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return 0;
    }

    try
    {
        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum(
            _bstr_t( CLASS_CIMV2_Win32_ComputerSystem ), 0, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time.
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( 0 == ulReturned )
        {
            // release the interfaces
            WMISaveError( WBEM_S_FALSE );
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( FALSE == PropertyGet( pWbemObject, L"SystemType", strType ) )
        {
            // release the interfaces
            // Error is already set in the called function.
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );

        // determine the type of the platform
        if ( -1 != strType.Find( TEXT_X86 ) )
        {
            return PLATFORM_X86;
        }
        else
        {
            if ( -1 != strType.Find( TEXT_IA64 ) )
            {
                return PLATFORM_IA64;
            }
            else
            {
                if ( -1 != strType.Find( TEXT_AMD64 ) )
                {
                    return PLATFORM_AMD64;
                }
            }
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }

    // return
    return PLATFORM_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cmdline\tasklist\tasklist.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      TaskList.h
//
//  Abstract:
//
//      macros and function prototypes of TList.cpp
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//
// *********************************************************************************

#ifndef _TASKLIST_H
#define _TASKLIST_H

// resource header file
#include "resource.h"

//
// NOTE: THIS MODULE WILL WRITTEN IN SUCH A FASHION THAT IT WORKS ONLY
//       IN UNICODE BUILD COMPILATION
//
#ifndef UNICODE
#error Must compile only in unicode build environment
#endif

//
// general purpose macros
//
#define EXIT_PROCESS( exitcode )    \
    ReleaseGlobals();   \
    return exitcode;    \
    1

#define   DISPLAY_GET_REASON()          ShowMessageEx( stderr, 2, FALSE, L"%1 %2", \
                                                       TAG_ERROR, GetReason() )

//
// winstation related structures ( extract from winsta.h - internal file )
//

//
// structures
typedef struct _CITRIX_PROCESS_INFORMATION {
    ULONG MagicNumber;
    ULONG LogonId;
    PVOID ProcessSid;
    ULONG Pad;
} CITRIX_PROCESS_INFORMATION, * PCITRIX_PROCESS_INFORMATION;

// ...
typedef struct _TS_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} TS_UNICODE_STRING;

// CAUTION:
// TS_SYSTEM_PROCESS_INFORMATION is duplicated from ntexapi.h, and slightly modified.
// (not nice, but necessary because the Midl compiler doesn't like PVOID !)
typedef struct _TS_SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    TS_UNICODE_STRING ImageName;
    LONG BasePriority;                     // KPRIORITY in ntexapi.h
    DWORD UniqueProcessId;                 // HANDLE in ntexapi.h
    DWORD InheritedFromUniqueProcessId;    // HANDLE in ntexapi.h
    ULONG HandleCount;
    ULONG SessionId;
    ULONG SpareUl3;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
} TS_SYSTEM_PROCESS_INFORMATION, *PTS_SYSTEM_PROCESS_INFORMATION;

// ...
typedef struct _TS_ALL_PROCESSES_INFO {
    PTS_SYSTEM_PROCESS_INFORMATION pspiProcessInfo;
    DWORD SizeOfSid;
    PBYTE pSid;
} TS_ALL_PROCESSES_INFO, *PTS_ALL_PROCESSES_INFO;

// defines
#define SERVERNAME_CURRENT                      ((HANDLE)NULL)
#define GAP_LEVEL_BASIC                         0
#define CITRIX_PROCESS_INFO_MAGIC               0x23495452
#define WINSTATIONNAME_LENGTH                   64
#define WINSTA_DLLNAME                          L"Winsta.dll"
#define FUNCNAME_WinStationFreeMemory           "WinStationFreeMemory"
#define FUNCNAME_WinStationCloseServer          "WinStationCloseServer"
#define FUNCNAME_WinStationOpenServerW          "WinStationOpenServerW"
#define FUNCNAME_WinStationEnumerateProcesses   "WinStationEnumerateProcesses"
#define FUNCNAME_WinStationFreeGAPMemory        "WinStationFreeGAPMemory"
#define FUNCNAME_WinStationGetAllProcesses      "WinStationGetAllProcesses"
#define FUNCNAME_WinStationNameFromLogonIdW     "WinStationNameFromLogonIdW"
#define SIZEOF_SYSTEM_THREAD_INFORMATION        sizeof( struct SYSTEM_THREAD_INFORMATION )
#define SIZEOF_SYSTEM_PROCESS_INFORMATION       sizeof( struct SYSTEM_PROCESS_INFORMATION )

//
// function prototypes
typedef BOOLEAN (WINAPI * FUNC_WinStationFreeMemory)( PVOID pBuffer );
typedef BOOLEAN (WINAPI * FUNC_WinStationCloseServer)( HANDLE hServer );
typedef HANDLE  (WINAPI * FUNC_WinStationOpenServerW)( LPWSTR pwszServerName );
typedef BOOLEAN (WINAPI * FUNC_WinStationNameFromLogonIdW)( HANDLE hServer,
                                                            ULONG LogonId, LPWSTR pwszWinStationName );
typedef BOOLEAN (WINAPI * FUNC_WinStationEnumerateProcesses)( HANDLE  hServer, PVOID *ppProcessBuffer );
typedef BOOLEAN (WINAPI * FUNC_WinStationFreeGAPMemory)( ULONG Level,
                                                         PVOID ProcessArray, ULONG ulCount );
typedef BOOLEAN (WINAPI * FUNC_WinStationGetAllProcesses)( HANDLE hServer,
                                                           ULONG Level, ULONG *pNumberOfProcesses,
                                                           PVOID *ppProcessArray );

//
// constants / defines / enumerations
//

//
// WMI related stuff

// class name
#define CLASS_PROCESS                               L"Win32_Process"

// wmi query
#define WMI_QUERY_TYPE                  L"WQL"
#define WMI_SERVICE_QUERY               L"SELECT Name FROM Win32_Service WHERE ProcessId = %d and State=\"Running\""
#define WMI_MODULES_QUERY               L"ASSOCIATORS OF {%s} WHERE ResultClass = CIM_DataFile"
#define WMI_PROCESS_QUERY       \
    L"SELECT " \
    L"__PATH, ProcessId, CSName, Caption, SessionId, ThreadCount, " \
    L"WorkingSetSize, KernelModeTime, UserModeTime "    \
    L" FROM Win32_Process"

// wmi query operators etc
#define WMI_QUERY_FIRST_CLAUSE      L"WHERE"
#define WMI_QUERY_SECOND_CLAUSE     L"AND"

// Win32_Process class properties
#define WIN32_PROCESS_SYSPROPERTY_PATH              L"__PATH"
#define WIN32_PROCESS_PROPERTY_HANDLE               L"Handle"
#define WIN32_PROCESS_PROPERTY_COMPUTER             L"CSName"
#define WIN32_PROCESS_PROPERTY_IMAGENAME            L"Caption"
#define WIN32_PROCESS_PROPERTY_PROCESSID            L"ProcessId"
#define WIN32_PROCESS_PROPERTY_SESSION              L"SessionId"
#define WIN32_PROCESS_PROPERTY_THREADS              L"ThreadCount"
#define WIN32_PROCESS_PROPERTY_USERMODETIME         L"UserModeTime"
#define WIN32_PROCESS_PROPERTY_MEMUSAGE             L"WorkingSetSize"
#define WIN32_PROCESS_PROPERTY_KERNELMODETIME       L"KernelModeTime"

// Win32_Process class method(s)
#define WIN32_PROCESS_METHOD_GETOWNER               L"GetOwner"

// GetOwner method's return values
#define GETOWNER_RETURNVALUE_USER                   L"User"
#define GETOWNER_RETURNVALUE_DOMAIN                 L"Domain"

// function default return value
#define WMI_RETURNVALUE                             L"ReturnValue"

// Win32_Service related stuff
#define WIN32_SERVICE_PROPERTY_NAME                 L"Name"

// CIM_DataFile related stuff
#define CIM_DATAFILE_PROPERTY_FILENAME              L"FileName"
#define CIM_DATAFILE_PROPERTY_EXTENSION             L"Extension"

//
// other stuff

// generals
#define VALUE_RUNNING               GetResString( IDS_VALUE_RUNNING )
#define VALUE_NOTRESPONDING         GetResString( IDS_VALUE_NOTRESPONDING )
#define VALUE_UNKNOWN               GetResString( IDS_VALUE_UNKNOWN )
#define PID_0_DOMAIN                GetResString( IDS_PID_0_DOMAIN )
#define PID_0_USERNAME              GetResString( IDS_PID_0_USERNAME )
#define FMT_MODULES_FILTER          GetResString( IDS_FMT_MODULES_FILTER )

// error messages
#define ERROR_USERNAME_BUT_NOMACHINE    GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME   GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_NODATA_AVAILABLE          GetResString( IDS_ERROR_NODATA_AVAILABLE )
#define ERROR_USERNAME_EMPTY            GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_NH_NOTSUPPORTED           GetResString( IDS_ERROR_NH_NOTSUPPORTED )
#define ERROR_M_SVC_V_CANNOTBECOUPLED   GetResString( IDS_ERROR_M_SVC_V_CANNOTBECOUPLED )
#define ERROR_SERVERNAME_EMPTY          GetResString( IDS_ERROR_SERVERNAME_EMPTY )
#define ERROR_INVALID_USAGE_REQUEST     GetResString( IDS_ERROR_INVALID_USAGE_REQUEST )
#define ERROR_M_CHAR_AFTER_WILDCARD     GetResString( IDS_ERROR_M_CHAR_AFTER_WILDCARD )
#define ERROR_PLATFORM_SHOULD_BE_X86    GetResString( IDS_ERROR_PLATFORM_SHOULD_BE_X86 )

// warnings
#define WARNING_FILTERNOTSUPPORTED      GetResString( IDS_WARNING_FILTERNOTSUPPORTED )

// output formats
#define TEXT_FORMAT_LIST        GetResString( IDS_TEXT_FORMAT_LIST )
#define TEXT_FORMAT_TABLE       GetResString( IDS_TEXT_FORMAT_TABLE )
#define TEXT_FORMAT_CSV         GetResString( IDS_TEXT_FORMAT_CSV )

//
// column heading names and their indexes in the array ( in fact positions )
#define MAX_COLUMNS             12

// column headings
#define COLHEAD_HOSTNAME        GetResString( IDS_COLHEAD_HOSTNAME )
#define COLHEAD_STATUS          GetResString( IDS_COLHEAD_STATUS )
#define COLHEAD_IMAGENAME       GetResString( IDS_COLHEAD_IMAGENAME )
#define COLHEAD_PID             GetResString( IDS_COLHEAD_PID )
#define COLHEAD_SESSION         GetResString( IDS_COLHEAD_SESSION )
#define COLHEAD_USERNAME        GetResString( IDS_COLHEAD_USERNAME )
#define COLHEAD_WINDOWTITLE     GetResString( IDS_COLHEAD_WINDOWTITLE )
#define COLHEAD_CPUTIME         GetResString( IDS_COLHEAD_CPUTIME )
#define COLHEAD_MEMUSAGE        GetResString( IDS_COLHEAD_MEMUSAGE )
#define COLHEAD_SERVICES        GetResString( IDS_COLHEAD_SERVICES )
#define COLHEAD_SESSIONNAME     GetResString( IDS_COLHEAD_SESSIONNAME )
#define COLHEAD_MODULES         GetResString( IDS_COLHEAD_MODULES )

// indexes
#define CI_HOSTNAME         TASK_HOSTNAME
#define CI_STATUS           TASK_STATUS
#define CI_IMAGENAME        TASK_IMAGENAME
#define CI_PID              TASK_PID
#define CI_SESSION          TASK_SESSION
#define CI_USERNAME         TASK_USERNAME
#define CI_WINDOWTITLE      TASK_WINDOWTITLE
#define CI_CPUTIME          TASK_CPUTIME
#define CI_MEMUSAGE         TASK_MEMUSAGE
#define CI_SERVICES         TASK_SERVICES
#define CI_SESSIONNAME      TASK_SESSIONNAME
#define CI_MODULES          TASK_MODULES

// column widths
#define COLWIDTH_HOSTNAME       AsLong( GetResString( IDS_COLWIDTH_HOSTNAME ), 10 )
#define COLWIDTH_STATUS         AsLong( GetResString( IDS_COLWIDTH_STATUS ), 10 )
#define COLWIDTH_IMAGENAME      AsLong( GetResString( IDS_COLWIDTH_IMAGENAME ), 10 )
#define COLWIDTH_PID            AsLong( GetResString( IDS_COLWIDTH_PID ), 10 )

// to avoid the RC change at this moment, we are hard coding this value in this file
// #define COLWIDTH_SESSION     AsLong( GetResString( IDS_COLWIDTH_SESSION ), 10 )
#define COLWIDTH_SESSION        11

#define COLWIDTH_USERNAME       AsLong( GetResString( IDS_COLWIDTH_USERNAME ), 10 )
#define COLWIDTH_WINDOWTITLE    AsLong( GetResString( IDS_COLWIDTH_WINDOWTITLE ), 10 )
#define COLWIDTH_CPUTIME        AsLong( GetResString( IDS_COLWIDTH_CPUTIME  ), 10 )
#define COLWIDTH_MEMUSAGE       AsLong( GetResString( IDS_COLWIDTH_MEMUSAGE ), 10 )
#define COLWIDTH_SERVICES       AsLong( GetResString( IDS_COLWIDTH_SERVICES ), 10 )
#define COLWIDTH_SERVICES_WRAP  AsLong( GetResString( IDS_COLWIDTH_SERVICES_WRAP ), 10 )
#define COLWIDTH_SESSIONNAME    AsLong( GetResString( IDS_COLWIDTH_SESSIONNAME ), 10 )
#define COLWIDTH_MODULES        AsLong( GetResString( IDS_COLWIDTH_MODULES ), 10 )
#define COLWIDTH_MODULES_WRAP   AsLong( GetResString( IDS_COLWIDTH_MODULES_WRAP ), 10 )

//
// command line options

// command line options and their indexes in the array
#define MAX_OPTIONS         10

// options allowed ( no need to localize )
#define OPTION_USAGE        L"?"
#define OPTION_SERVER       L"s"
#define OPTION_USERNAME     L"u"
#define OPTION_PASSWORD     L"p"
#define OPTION_FILTER       L"fi"
#define OPTION_FORMAT       L"fo"
#define OPTION_NOHEADER     L"nh"
#define OPTION_VERBOSE      L"v"
#define OPTION_SVC          L"svc"
#define OPTION_MODULES      L"m"

// option indexes
#define OI_USAGE                    0
#define OI_SERVER                   1
#define OI_USERNAME                 2
#define OI_PASSWORD                 3
#define OI_FILTER                   4
#define OI_FORMAT                   5
#define OI_NOHEADER                 6
#define OI_VERBOSE                  7
#define OI_SVC                      8
#define OI_MODULES                  9

// values allowed for format
#define OVALUES_FORMAT          GetResString( IDS_OVALUES_FORMAT )

//
// filter details
#define MAX_FILTERS         11

// filter allowed
#define FILTER_SESSIONNAME      GetResString( IDS_FILTER_SESSIONNAME )
#define FILTER_STATUS           GetResString( IDS_FILTER_STATUS )
#define FILTER_IMAGENAME        GetResString( IDS_FILTER_IMAGENAME )
#define FILTER_PID              GetResString( IDS_FILTER_PID )
#define FILTER_SESSION          GetResString( IDS_FILTER_SESSION )
#define FILTER_CPUTIME          GetResString( IDS_FILTER_CPUTIME )
#define FILTER_MEMUSAGE         GetResString( IDS_FILTER_MEMUSAGE )
#define FILTER_USERNAME         GetResString( IDS_FILTER_USERNAME )
#define FILTER_SERVICES         GetResString( IDS_FILTER_SERVICES )
#define FILTER_WINDOWTITLE      GetResString( IDS_FILTER_WINDOWTITLE )
#define FILTER_MODULES          GetResString( IDS_FILTER_MODULES )

// indexes
#define FI_SESSIONNAME      0
#define FI_STATUS           1
#define FI_IMAGENAME        2
#define FI_PID              3
#define FI_SESSION          4
#define FI_CPUTIME          5
#define FI_MEMUSAGE         6
#define FI_USERNAME         7
#define FI_SERVICES         8
#define FI_WINDOWTITLE      9
#define FI_MODULES          10

// values allowed for status
#define FVALUES_STATUS      GetResString( IDS_FVALUES_STATUS )

// operators
#define OPERATORS_STRING    GetResString( IDS_OPERATORS_STRING )
#define OPERATORS_NUMERIC   GetResString( IDS_OPERATORS_NUMERIC )

// max. columns ( information ) to be stored for one task
#define MAX_TASKSINFO           17

// task info indexes
#define TASK_HOSTNAME           0
#define TASK_IMAGENAME          1
#define TASK_PID                2
#define TASK_SESSIONNAME        3
#define TASK_SESSION            4
#define TASK_MEMUSAGE           5
#define TASK_STATUS             6
#define TASK_USERNAME           7
#define TASK_CPUTIME            8
#define TASK_WINDOWTITLE        9
#define TASK_SERVICES           10
#define TASK_MODULES            11

// always hidden
#define TASK_HWND               12
#define TASK_WINSTA             13
#define TASK_DESK               14
#define TASK_CREATINGPROCESSID  15
#define TASK_OBJPATH            16

#define NULL_STRING             L"\0"
#define __STRING_64             WCHAR[ 64 ]
#define __MAX_SIZE_STRING       WCHAR[ 256 ]
//
// CTaskList
//
class CTaskList
{
public:
    // enumerators
    enum
    {
        twiProcessId = 0,
        twiWinSta = 1,
        twiDesktop = 2,
        twiHandle = 3,
        twiTitle = 4,
        twiHungInfo = 5,
        twiCOUNT,
    };

// constructor / destructor
public:
    CTaskList();
    ~CTaskList();

// data memebers
private:
    // WMI / COM interfaces
    IWbemLocator* m_pWbemLocator;
    IWbemServices* m_pWbemServices;
    IEnumWbemClassObject* m_pEnumObjects;

    // WMI connectivity
    COAUTHIDENTITY* m_pAuthIdentity;

    // command-line argument values
    BOOL m_bVerbose;
    BOOL m_bAllServices;
    BOOL m_bAllModules;
    DWORD m_dwFormat;
    TARRAY m_arrFilters;
    CHString m_strServer;
    CHString m_strUserName;
    CHString m_strPassword;
    CHString m_strModules;

    // others
    BOOL m_bNeedPassword;               // infoms whether password has to read or not
    BOOL m_bRemoteWarning;              // window title and status filters are invalid for remote systems
    BOOL m_bNeedModulesInfo;
    BOOL m_bNeedServicesInfo;           // determines whether services info has to gathered or not
    BOOL m_bNeedUserContextInfo;        // determines whether userinfo has to gathered or not
    BOOL m_bNeedWindowTitles;           // determines whether window titles has to be gathered or not
    PTCOLUMNS m_pColumns;               // columns config information
    TARRAY m_arrFiltersEx;              // parsed filters info
    TARRAY m_arrWindowTitles;           // window titles
    PTFILTERCONFIG m_pfilterConfigs;    // filters config information
    CHString m_strQuery;                // optimized WMI Query for filters
    DWORD m_dwGroupSep;             // number group seperation in number formatting
    CHString m_strTimeSep;              // time seperator
    CHString m_strGroupThousSep;        // thousand sepeartion character in number formatting

    // output data
    TARRAY m_arrTasks;
    DWORD m_dwProcessId;
    CHString m_strImageName;

    // helpers .. in getting info using API
    CHString m_strUNCServer;                // server name
    BOOL m_bCloseConnection;

    // winstation related stuff
    BOOL m_bIsHydra;
    HANDLE m_hServer;
    HMODULE m_hWinstaLib;
    PBYTE m_pProcessInfo;
    ULONG m_ulNumberOfProcesses;

    // services related stuff
    DWORD m_dwServicesCount;
    LPENUM_SERVICE_STATUS_PROCESS m_pServicesInfo;

    // modules related stuff ( remote only )
    BOOL m_bUseRemote;
    PPERF_DATA_BLOCK m_pdb;

    //
    // functions
    FUNC_WinStationFreeMemory m_pfnWinStationFreeMemory;
    FUNC_WinStationOpenServerW m_pfnWinStationOpenServerW;
    FUNC_WinStationCloseServer m_pfnWinStationCloseServer;
    FUNC_WinStationFreeGAPMemory m_pfnWinStationFreeGAPMemory;
    FUNC_WinStationGetAllProcesses m_pfnWinStationGetAllProcesses;
    FUNC_WinStationNameFromLogonIdW m_pfnWinStationNameFromLogonIdW;
    FUNC_WinStationEnumerateProcesses m_pfnWinStationEnumerateProcesses;

public:
    // command-line argument values
    BOOL m_bUsage;
    BOOL m_bLocalSystem;

// functions
private:

    // helpers
    VOID SetCPUTime( LONG lIndex, IWbemClassObject* pWmiObject );
    VOID SetSession( LONG lIndex, IWbemClassObject* pWmiObject );
    VOID SetMemUsage( LONG lIndex, IWbemClassObject* pWmiObject );
    VOID SetUserContext( LONG lIndex, IWbemClassObject* pWmiObject );
    VOID SetWindowTitle( LONG lIndex );
    VOID SetServicesInfo( LONG lIndex );
    BOOL SetModulesInfo( LONG lIndex );
    BOOL SaveInformation( LONG lIndex, IWbemClassObject* pWmiObject );

    // ...
    BOOL LoadTasksEx();
    BOOL LoadModulesInfo();
    BOOL LoadServicesInfo();
    BOOL EnableDebugPriv();
    BOOL GetModulesOnRemote( LONG lIndex, TARRAY arrModules );
    BOOL GetModulesOnRemoteEx( LONG lIndex, TARRAY arrModules );
    BOOL LoadModulesOnLocal( TARRAY arrModules );
    BOOL LoadUserNameFromWinsta( CHString& strDomain, CHString& strUserName );

    // winsta functions
    BOOLEAN WinStationFreeMemory( PVOID pBuffer );
    BOOLEAN WinStationCloseServer( HANDLE hServer );
    HANDLE  WinStationOpenServerW( LPWSTR pwszServerName );
    BOOLEAN WinStationEnumerateProcesses( HANDLE  hServer, PVOID *ppProcessBuffer );
    BOOLEAN WinStationFreeGAPMemory( ULONG Level, PVOID ProcessArray, ULONG ulCount );
    BOOLEAN WinStationNameFromLogonIdW( HANDLE hServer, ULONG ulLogonId, LPWSTR pwszWinStationName );
    BOOLEAN WinStationGetAllProcesses( HANDLE hServer, ULONG Level,
                                       ULONG *pNumberOfProcesses, PVOID *ppProcessArray );
public:
    VOID Usage();
    BOOL Initialize();
    VOID PrepareColumns();
    BOOL ValidateFilters();
    BOOL ProcessOptions( DWORD argc, LPCWSTR argv[] );

    // functionality related
    DWORD Show();
    BOOL Connect();
    BOOL LoadTasks();
};

//
// public functions
//

#endif  // _TASKLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\compdir\compdir.h ===
#include <windows.h>
#include <stdio.h>

#include <stdlib.h>
#include <string.h>

#include <direct.h>
#include <io.h>
#include <conio.h>

#define GetFileAttributeError 0xFFFFFFFF
#define printval( var, type) printf( #var " = %" #type "\n", var) // macro for debugging
#define READ_BUFFER_SIZE ( 8*1024*sizeof(DWORD)) // 32k blocks


#define ATTRIBUTE_TYPE DWORD
#define GET_ATTRIBUTES( FileName, Attributes) Attributes = GetFileAttributes( FileName)
#define SET_ATTRIBUTES( FileName, Attributes) !SetFileAttributes( FileName, Attributes)

HINSTANCE NtDll; // used to load Dll's rather than link with them

#define WORK_INITIALIZE_ITEM 0
#define WORK_ITEM            1
#define WORK_TERMINATE_ITEM  2

typedef VOID (*PWORKER_ROUTINE)();

typedef struct _WORK_QUEUE {
    CRITICAL_SECTION CriticalSection;
    HANDLE Semaphore;
    LIST_ENTRY Queue;
    BOOL Terminating;
    PWORKER_ROUTINE WorkerRoutine;
    DWORD NumberOfWorkerThreads;
    HANDLE WorkerThreads[ 1 ];      // Variable length array
} WORK_QUEUE, *PWORK_QUEUE;

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    DWORD Reason;
    PWORK_QUEUE WorkQueue;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

typedef struct _VIRTUAL_BUFFER {
    LPVOID Base;
    SIZE_T PageSize;
    LPVOID CommitLimit;
    LPVOID ReserveLimit;
} VIRTUAL_BUFFER, *PVIRTUAL_BUFFER;

typedef struct _COPY_REQUEST_STATE {
    VIRTUAL_BUFFER Buffer;
    LPSTR CurrentOutput;
} COPY_REQUEST_STATE, *PCOPY_REQUEST_STATE;

CRITICAL_SECTION CreatePathCriticalSection;

typedef struct _COPY_REQUEST {
    WORK_QUEUE_ITEM WorkItem;
    LPSTR Destination;
    LPSTR FullPathSrc;
    ATTRIBUTE_TYPE Attributes;
    DWORD SizeLow;
} COPY_REQUEST, *PCOPY_REQUEST;

INT NumberOfWorkerThreads;
DWORD TlsIndex;
PWORK_QUEUE CDWorkQueue;

#define NONREADONLYSYSTEMHIDDEN ( ~( FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN))
#define NORMAL_ATTRIBUTES (FILE_ATTRIBUTE_DIRECTORY |   \
                           FILE_ATTRIBUTE_READONLY |    \
                           FILE_ATTRIBUTE_SYSTEM |      \
                           FILE_ATTRIBUTE_HIDDEN |      \
                           FILE_ATTRIBUTE_ARCHIVE)

#define _strrev

FILE *CheckFile;
char CheckFileName[_MAX_PATH];

typedef struct NodeStruct {
    char			  *Name;
    FILETIME                      Time;
    ATTRIBUTE_TYPE                Attributes;
    int                           Height;
    struct NodeStruct             *First;
    struct NodeStruct             *Last;
    struct NodeStruct             *Left;
    struct NodeStruct             *Next;
    struct NodeStruct             *Right;
    DWORD			  SizeHigh;
    DWORD			  SizeLow;
    char			  Flag[5];
    struct NodeStruct             *DiffNode;
    BOOL                          Process;

} *LinkedFileList; /* linked file list */

typedef struct CFLStruct {
    LinkedFileList *List;
    char           *Path;
} *PCFLStruct;

DWORD ReadBuffer[READ_BUFFER_SIZE/sizeof(DWORD)];

BOOL ProcessModeDefault;

//
// Flags passed to COMPDIR
//

BOOL  fBreakLinks;
BOOL  fCheckAttribs;
BOOL  fCheckBits;
BOOL  fChecking;
BOOL  fCheckSize;
BOOL  fCheckTime;
BOOL  fCreateNew;
BOOL  fCreateLink;
BOOL  fDoNotDelete;
BOOL  fDoNotRecurse;
BOOL  fDontCopyAttribs;
BOOL  fDontLowerCase;
BOOL  fExclude;
BOOL  fExecute;
BOOL  fIgnoreRs;       // Ignore Resource, TimeStamps, CheckSums and Rebase Information
BOOL  fIgnoreSlmFiles;
BOOL  fMatching;
BOOL  fMultiThread;
BOOL  fOpposite;
BOOL  fScript;
BOOL  fSpecAttribs;
BOOL  fVerbose;

BOOL  ExitValue;
BOOL  SparseTree;

BOOL NoMapBinaryCompare( char *file1, char *file2);
BOOL BinaryCompare( char *file1, char *file2);
LPSTR CombineThreeStrings( char *FirstString, char *SecondString, char *ThirdString);
void  CompDir( char *Path1, char *Path2);
BOOL  FilesDiffer( LinkedFileList File1, LinkedFileList File2, char *Path1, char *Path2);
void  CompLists( LinkedFileList *AddList, LinkedFileList *DelList, LinkedFileList *DifList, char *Path1, char *Path2);
void  CopyNode( char *Destination, LinkedFileList Source, char *FullPathSrc);
DWORD CreateFileList( LPVOID ThreadParameter);
BOOL  DelNode( char *name);
BOOL  IsFlag( char *argv);
BOOL  MyCreatePath( char *Path, BOOL IsDirectory);
BOOL  MyCopyFile( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
void  ParseEnvArgs( void);
void  ParseArgs( int argc, char *argv[]);
void  PrintFile( LinkedFileList File, char *Path, char *DiffPath);
void  PrintList( LinkedFileList list);
void  ProcessAdd( LinkedFileList List, char *String1, char *String2);
void  ProcessDel( LinkedFileList List, char *String);
void  ProcessDiff( LinkedFileList List, char *String1, char *String2);
void  ProcessLists( LinkedFileList AddList, LinkedFileList DelList, LinkedFileList DifList,
                   char *Path1, char *Path2                                               );
void  Usage( void);
BOOL  AddToList( LinkedFileList Node, LinkedFileList *list);

void  CreateNode( LinkedFileList *Node, WIN32_FIND_DATA *Buff);
BOOL  InitializeNtDllFunctions();
BOOL  MakeLink( char *src, char *dst, BOOL Output);
int   NumberOfLinks( char *FileName);
BOOL  SisCopyFile( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists, LPBOOL fTrySis);

PWORK_QUEUE CreateWorkQueue( IN DWORD NumberOfWorkerThreads, IN PWORKER_ROUTINE WorkerRoutine);
VOID  ProcessRequest( IN PWORK_QUEUE_ITEM WorkItem);
VOID  DestroyWorkQueue( IN OUT PWORK_QUEUE WorkQueue);
DWORD WorkerThread( LPVOID lpThreadParameter);
VOID  DestroyWorkQueue( IN OUT PWORK_QUEUE WorkQueue);
BOOL  QueueWorkItem( IN OUT PWORK_QUEUE WorkQueue, IN PWORK_QUEUE_ITEM WorkItem);
VOID  ProcessCopyFile( IN PCOPY_REQUEST WorkerRequest, IN PCOPY_REQUEST_STATE State);
BOOL  CreateVirtualBuffer( OUT PVIRTUAL_BUFFER Buffer, IN SIZE_T CommitSize, IN SIZE_T ReserveSize OPTIONAL);
BOOL  ExtendVirtualBuffer( IN PVIRTUAL_BUFFER Buffer, IN LPVOID Address);
BOOL  TrimVirtualBuffer( IN PVIRTUAL_BUFFER Buffer);
BOOL  FreeVirtualBuffer( IN PVIRTUAL_BUFFER Buffer);
int   VirtualBufferExceptionFilter( IN DWORD ExceptionCode, IN PEXCEPTION_POINTERS ExceptionInfo, IN OUT PVIRTUAL_BUFFER Buffer);

void  CreateNameNode( LinkedFileList *Node, char *Name);
void  DuplicateNode( LinkedFileList FirstNode, LinkedFileList *Node);
BOOL  Excluded( char *Buff, char *Path);
BOOL  Matched( char *Buff, char *Path);
void  FreeList( LinkedFileList *list);
LPSTR MyStrCat( char* firststring, char *secondstring);
BOOL  Match( char *pat, char* text);
void  OutOfMem( void);
void  PrintTree( LinkedFileList List, int Level);
BOOL  FindInMatchListTop( char *Name, LinkedFileList *List);
BOOL  FindInMatchListFront( char *Name, LinkedFileList *List);
LinkedFileList *FindInList( char *Name, LinkedFileList *List);
LinkedFileList *Next( LinkedFileList List);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\compdir\doscopy.c ===
#include <stdio.h>
#include <dos.h>
#include <windows.h>
#include <compdir.h>

BOOL BinaryCompare( char *file1, char *file2)
{
    register int char1, char2;
    FILE *filehandle1, *filehandle2;

    if ( (filehandle1 = fopen( file1, "rb")) == NULL)
    {
        fprintf( stderr, "cannot open %s\n", file1);
        return( FALSE);
    }
    if ( (filehandle2 = fopen( file2, "rb")) == NULL)
    {
        fprintf( stderr, "cannot open %s\n", file2);
        fclose( filehandle1);
        return( FALSE);
    }
    while ( TRUE)
    {
        if ( (char1 = getc( filehandle1)) != EOF)
        {
            if ( (char2 = getc( filehandle2)) != EOF)
            {
                if ( char1 != char2)
                {
                    fclose( filehandle1);
                    fclose( filehandle2);
                    return( FALSE);
                }

            } else
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( FALSE);
            }

        } else
        {
            if ( (char2 = getc( filehandle2)) == EOF)
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( TRUE);

            } else
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( FALSE);
            }
        }
    }
}

/* Copies one file to another (both specified by path). Dynamically
 * allocates memory for the file buffer. Returns TRUE if successful,
 * or FALSE if unsuccessful. This function uses _dos_ functions only;
 * standard C functions are not used.
 */
BOOL fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm )
{
    char _far *buf = NULL;
    unsigned segbuf, count;

    /* Attempt to dynamically allocate all of memory (0xffff paragraphs).
     * This will fail, but will return the amount actually available
     * in segbuf. Then allocate this amount.
     */
    if ( _dos_allocmem( 0xffff, &segbuf ) )
    {
        count = segbuf;
        if ( _dos_allocmem( count, &segbuf ) )
        {
            return FALSE;
        }
    }
    FP_SEG( buf ) = segbuf;

    /* Read and write until there is nothing left. */
    while ( count )
    {
        /* Read and write input. */
        if ( ( _dos_read( hfSrcParm, buf, count, &count )) )
        {
	    _dos_freemem( segbuf );
            return FALSE;
        }
        if ( (_dos_write( hfDstParm, buf, count, &count )) )
        {
	    _dos_freemem( segbuf );
            return FALSE;
        }
    }
    /* Free memory. */
    _dos_freemem( segbuf );
    return TRUE;
}

BOOL FCopy( char *src, char *dst, BOOL Output)
{
    HANDLE srcfh, dstfh;
    BOOL result;
    ATTRIBUTE_TYPE Attributes;
    unsigned filedate, filetime;
    GET_ATTRIBUTES( src, Attributes);

    if ( Attributes == FILE_ATTRIBUTE_DIRECTORY)
    {
        if ( Output )
        {
            fprintf( stderr, "\nUnable to open source");
        }
	return FALSE;
    }

    if ( _dos_creatnew( src, _A_RDONLY, &srcfh) != 0)
    {
        if ( _dos_open( src, O_RDONLY, &srcfh) != 0)
        {
            if ( Output )
            {
               fprintf( stderr, "\nUnable to open source, error code %d", GetLastError() );
            }
            if ( srcfh != INVALID_HANDLE_VALUE)
            {
                CloseHandle( srcfh );
            }
            return FALSE;
        }
    }

    if ( _dos_getftime( srcfh, &filedate, &filetime) != 0)
    {
        if ( Output )
        {
           fprintf( stderr, "\nUnable to get time of source");
        }
        if ( srcfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( srcfh );
        }
	return FALSE;
    }

    if ( _dos_creatnew( dst, _A_NORMAL, &dstfh) != 0)
    {
        if ( _dos_open( dst,  O_RDWR,   &dstfh) != 0)
        {
            if ( Output )
            {
                fprintf( stderr, "\nUnable to create destination, error code %d", GetLastError() );
            }
            if ( srcfh != INVALID_HANDLE_VALUE)
            {
                CloseHandle( srcfh );
            }
            if ( dstfh != INVALID_HANDLE_VALUE)
            {
                CloseHandle( dstfh );
            }
            return FALSE;
        }
    }

    result = fastcopy( srcfh, dstfh );

    if ( !result)
    {
        if ( dstfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( dstfh );
            dstfh = INVALID_HANDLE_VALUE;
        }

        DeleteFile( dst );
        if ( srcfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( srcfh );
        }
        if ( Output )
        {
            fprintf( stderr, "\nUnable to copy file");
        }
        return FALSE;
    }

    if ( _dos_setftime( dstfh, filedate, filetime != 0))
    {
        if ( Output )
        {
           fprintf( stderr, "\nUnable to set time of destination");
        }
        if ( srcfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( srcfh );
        }
        if ( dstfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( dstfh );
        }
	return FALSE;
    }

    if ( srcfh != INVALID_HANDLE_VALUE)
    {
        CloseHandle( srcfh );
    }
    if ( dstfh != INVALID_HANDLE_VALUE)
    {
        CloseHandle( dstfh );
    }
    return TRUE;

} // FCopy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\compdir\compdir.c ===
/************************************************************************
 *  Compdir: compare directories
 *
 ************************************************************************/

#define IF_GET_ATTR_FAILS( FileName, Attributes) GET_ATTRIBUTES( FileName, Attributes); if ( Attributes == GetFileAttributeError)
#define FIND_FIRST( String, Buff) FindFirstFile( String, &Buff)
#define FIND_NEXT( handle, Buff) !FindNextFile( handle, &Buff)
#define FREE( memory)
#define MYSTRCAT( FirstString, SecondString) strcat( strcpy( _alloca( strlen( FirstString) + strlen( SecondString) + 1), FirstString), SecondString)
#define COMBINETHREESTRINGS( FirstString, SecondString, ThirdString) strcat( strcat( strcpy( _alloca( strlen( FirstString) + strlen( SecondString) + strlen( ThirdString) + 1), FirstString), SecondString), ThirdString)

#include "compdir.h"

#include "imagehlp.h"

int Mymemcmp( const void *buf1, const void *buf2, size_t count );

LinkedFileList  MatchList   = NULL;
LinkedFileList  MStarList   = NULL;
LinkedFileList  ExcludeList = NULL;
LinkedFileList  EStarList   = NULL;

DWORD Granularity = 0;   // used in ParseArgs

ATTRIBUTE_TYPE CompareAttribute, NegativeCompareAttribute; // used as file compare criteria
BOOL CompareAttributeSet = FALSE;
BOOL NegativeCompareAttributeSet = FALSE;
BOOL Excludes    = FALSE;
BOOL Matches     = FALSE;
BOOL RunningOnNT = FALSE;

BOOL DealingWithDirectories;

fSpecAttribs     = FALSE;
fBreakLinks      = FALSE;
fCheckAttribs    = FALSE;
fCheckBits       = FALSE;
fChecking        = FALSE;
fCheckSize       = FALSE;
fCheckTime       = FALSE;
fCreateNew       = FALSE;
fCreateLink      = FALSE;
fDoNotDelete     = FALSE;
fDoNotRecurse    = FALSE;
fDontCopyAttribs = FALSE;
fDontLowerCase   = FALSE;
fExclude         = FALSE;
fExecute         = FALSE;
fForce           = FALSE;
fIgnoreRs        = FALSE;
fIgnoreSlmFiles  = FALSE;
fMatching        = FALSE;
fMultiThread     = FALSE;
fOnlyIfExists    = FALSE;
fOpposite        = FALSE;
fScript          = FALSE;
fTrySis          = FALSE;
fVerbose         = FALSE;

void  __cdecl main( int argc, char **argv)
{
    ATTRIBUTE_TYPE Attributes1, Attributes2;
    char *Path1, *Path2;

    OSVERSIONINFO VersionInformation;

    SYSTEM_INFO SystemInformation;

    ExitValue = 0;

    Attributes1 = GetFileAttributeError;
    Attributes2 = GetFileAttributeError;

    ProcessModeDefault = TRUE;               // Used by opposite mode

    ParseEnvArgs( );         // Parse COMPDIRCMD environment variable
    ParseArgs( argc, argv);  // Check argument validity.

    //
    // Check existence of first path.
    //

    IF_GET_ATTR_FAILS( argv[argc - 2], Attributes1)
    {
        fprintf( stderr, "Could not find %s (error = %d)\n", argv[argc - 2], GetLastError());
        exit( 1);
    }

    IF_GET_ATTR_FAILS( argv[argc - 1], Attributes2)
    {
        if ( !fCreateNew)
        {
            fprintf( stderr, "Could not find %s (error = %d)\n", argv[argc - 1], GetLastError());
            exit( 1);
        }
    }
    //
    // If second directory is a drive letter append path of first directory
    //     to it
    //
    if (
        ( strlen( argv[argc-1]) == 2)
                   &&
        ( *( argv[argc-1] + 1) == ':')
       )
    {
        if ( ( Path2 = _fullpath( NULL, argv[argc-2], 0)) == NULL)
        {
            Path2 = argv[argc-1];

        } else
        {
            Path2[0] = *( argv[argc-1]);
            IF_GET_ATTR_FAILS( Path2, Attributes2)
            {
                if ( !fCreateNew)
                {
                    fprintf( stderr, "Could not find %s (error = %d)\n", Path2, GetLastError());
                    exit( 1);
                }
            }
        }

    } else if ( ( Path2 = _fullpath( NULL, argv[argc-1], 0)) == NULL)
    {
        Path2 = argv[argc-1];
    }

    if ( ( Path1 = _fullpath( NULL, argv[argc-2], 0)) == NULL)
    {
        Path1 = argv[argc-2];
    }

    if ( !fDontLowerCase)
    {
        _strlwr( Path1);
        _strlwr( Path2);
    }

    if ( fVerbose)
    {
        fprintf( stdout, "Compare criterion: existence" );
        if ( fCheckSize)
        {
            fprintf( stdout, ", size" );
        }
        if ( fCheckTime)
        {
            fprintf( stdout, ", date/time" );
        }
        if ( fCheckBits)
        {
            fprintf( stdout, ", contents" );
        }
        fprintf( stdout, "\n" );
        fprintf( stdout, "Path1: %s\n", Path1);
        fprintf( stdout, "Path2: %s\n", Path2);
    }

    VersionInformation.dwOSVersionInfoSize = sizeof( OSVERSIONINFO);

    if ( GetVersionEx( &VersionInformation) )
    {
        if ( VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            RunningOnNT = TRUE;
        }
    }

    if ( ( fCreateLink) || ( fBreakLinks) || ( fTrySis))
    {
        if ( RunningOnNT)
        {
            NtDll = LoadLibrary( "ntdll.dll");
            if ( !NtDll)
            {
                fprintf( stderr, "Could not find ntdll.dll. Can't perform /l or /$\n");
                fCreateLink = FALSE;
                fTrySis = FALSE;
                ExitValue = 1;

            } else
            {
                if ( !InitializeNtDllFunctions())
                {
                    fprintf( stderr, "Could not load ntdll.dll. Can't perform /l or /$\n");
                    fCreateLink = FALSE;
                    fTrySis = FALSE;
                    ExitValue = 1;
                }
            }

        } else
        {
            fprintf( stderr, "/l and /$ only work on NT. Can't perform /l or /$\n");
            fCreateLink = FALSE;
            fTrySis = FALSE;
            ExitValue = 1;
        }

    }

    if ( fMultiThread)
    {
        //
        // Query the number of processors from the system and
        // default the number of worker threads to 4 times that.
        //

        GetSystemInfo( &SystemInformation );
        NumberOfWorkerThreads = SystemInformation.dwNumberOfProcessors * 4;
        if ( fVerbose)
        {
            fprintf( stdout, "Processors: %d\n", SystemInformation.dwNumberOfProcessors );
        }

        //
        // Allocate a thread local storage slot for use by our worker
        // thread routine ( ProcessRequest).  This call reserves a
        // 32-bit slot in the thread local storage array for every
        // thread in this process.  Remember the slot index in a global
        // variable for use by our worker thread routine.
        //

        TlsIndex = TlsAlloc();
        if ( TlsIndex == 0xFFFFFFFF)
        {
            fprintf( stderr, "Unable to allocate thread local storage.\n" );
            fMultiThread = FALSE;
            ExitValue = 1;
        }
        //
        // Create a work queue, which will create the specified number of threads
        // to process.
        //

        CDWorkQueue = CreateWorkQueue( NumberOfWorkerThreads, ProcessRequest );
        if ( CDWorkQueue == NULL)
        {
            fprintf( stderr, "Unable to create %u worker threads.\n", NumberOfWorkerThreads );
            fMultiThread = FALSE;
            ExitValue = 1;
        }
        //
        // Mutual exclusion between and requests that are creating paths
        // is done with a critical section.
        //

        InitializeCriticalSection( &CreatePathCriticalSection );
    }


    if ( Attributes1 & FILE_ATTRIBUTE_DIRECTORY)
    {
        DealingWithDirectories = TRUE;

    } else
    {
        DealingWithDirectories = FALSE;
    }

    if ( Matches)
    {
        SparseTree = TRUE;

    } else
    {
        SparseTree = FALSE;
    }

    if ( fCreateNew)
    {
        IF_GET_ATTR_FAILS( Path2, Attributes2)
        {
            fprintf ( stdout, "Making %s\t", Path2);

            if ( !MyCreatePath( Path2, DealingWithDirectories))
            {
                fprintf ( stderr, "Unable to create path %s\n", Path2);
                fprintf ( stdout, "\n");
                ExitValue = 1;

            } else
            {
                fprintf( stdout, "[OK]\n");
                CompDir( Path1, Path2);
            }

        } else
        {
            CompDir( Path1, Path2);
        }

    } else
    {
        CompDir( Path1, Path2);
    }

    free( Path1);
    free( Path2);

    if ( fMultiThread)
    {
        //
        // This will wait for the work queues to empty before terminating the
        // worker threads and destroying the queue.
        //

        DestroyWorkQueue( CDWorkQueue );
        DeleteCriticalSection( &CreatePathCriticalSection );
    }

    if ( fCreateLink)
    {
        FreeLibrary( NtDll);
    }

    exit( ExitValue);

}  // main

BOOL NoMapBinaryCompare ( char *file1, char *file2)
{
    register int char1, char2;
    FILE *filehandle1, *filehandle2;

    if ( ( filehandle1 = fopen ( file1, "rb")) == NULL)
    {
        fprintf ( stderr, "cannot open %s\n", file1);
        ExitValue = 1;
        return ( FALSE);
    }
    if ( ( filehandle2 = fopen( file2, "rb")) == NULL)
    {
        fprintf( stderr, "cannot open %s\n", file2);
        fclose( filehandle1);
        ExitValue = 1;
        return( FALSE);
    }
    while ( TRUE)
    {
        if ( ( char1 = getc( filehandle1)) != EOF)
        {
            if ( ( char2 = getc( filehandle2)) != EOF)
            {
                if ( char1 != char2)
                {
                    fclose( filehandle1);
                    fclose( filehandle2);
                    return( FALSE);
                }

            } else
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( FALSE);
            }

        } else
        {
            if ( ( char2 = getc( filehandle2)) == EOF)
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( TRUE);

            } else
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( FALSE);
            }
        }
    }
}


BOOL BinaryCompare( char *file1, char *file2)
{
    char String[MAX_PATH];
    char RebasedFile[MAX_PATH]; // used in BinaryCompares with /i switch
    char *RebasedFile2 = NULL;  // used in BinaryCompares with /i switch

    HANDLE hFile1, hFile2;
    HANDLE hMappedFile1, hMappedFile2;

    BOOL IsNTImage = FALSE;

    LPVOID MappedAddr1, MappedAddr2;

    PIMAGE_NT_HEADERS32   NtHeader1, NtHeader2;

    ULONG OldImageSize, NewImageSize;
    ULONG_PTR OldImageBase, NewImageBase;

    // fprintf( stdout, "file1: %s, file2: %s\n", file1, file2);

    //
    // File1 Mapping
    //

    if ( ( hFile1 = CreateFile(
                               file1,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL
                              )) == (HANDLE)-1)
    {
        fprintf( stderr, "Unable to open %s, error code %d\n", file1, GetLastError() );
        if ( hFile1 != INVALID_HANDLE_VALUE)
        {
            CloseHandle( hFile1 );
        }
        return FALSE;
    }

    hMappedFile1 = CreateFileMapping(
                                     hFile1,
                                     NULL,
                                     PAGE_WRITECOPY,
                                     0,
                                     0,
                                     NULL
                                    );

    if ( hMappedFile1 == NULL)
    {
        fprintf( stderr, "Unable to map %s, error code %d\n", file1, GetLastError() );
        CloseHandle( hFile1);
        return FALSE;
    }

    MappedAddr1 = MapViewOfFile(
                                hMappedFile1,
                                FILE_MAP_COPY,
                                0,
                                0,
                                0
                               );

    if ( MappedAddr1 == NULL)
    {
        fprintf( stderr, "Unable to get mapped view of %s, error code %d\n", file1, GetLastError() );
        CloseHandle( hFile1 );
        return FALSE;
    }

    CloseHandle( hMappedFile1);

    //
    // File2 rebasing and mapping
    //

    if ( fIgnoreRs)
    {
        GetTempPath( MAX_PATH, String);

        RebasedFile2 = RebasedFile;

        GetTempFileName( String, NULL, 0, RebasedFile2);

        if ( ( ( PIMAGE_DOS_HEADER)MappedAddr1)->e_magic == IMAGE_DOS_SIGNATURE)
        {
            try
            {
                NtHeader1 = ( PIMAGE_NT_HEADERS32)( (PCHAR)MappedAddr1 + ( (PIMAGE_DOS_HEADER)MappedAddr1)->e_lfanew);

                if ( NtHeader1->Signature == IMAGE_NT_SIGNATURE)
                {
                    NewImageBase = ( NtHeader1->OptionalHeader.ImageBase);

                    if (
                         ( RebasedFile2 != NULL)
                                   &&
                         ( CopyFile ( file2, RebasedFile2, FALSE))
                                   &&
                         ( ReBaseImage(
                                       RebasedFile2,
                                       NULL,
                                       TRUE,
                                       FALSE,
                                       FALSE,
                                       0,
                                       &OldImageSize,
                                       &OldImageBase,
                                       &NewImageSize,
                                       &NewImageBase,
                                       0
                                      ))
                       )
                    {
                        IsNTImage = TRUE;
                    }
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {}
        }
    }

    if ( IsNTImage)
    {
        if ( ( hFile2 = CreateFile(
                                   RebasedFile2,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                  )) == (HANDLE)-1)
        {
            fprintf( stderr, "Unable to open %s, error code %d\n", RebasedFile2, GetLastError() );
            if ( hFile2 != INVALID_HANDLE_VALUE)
            {
                CloseHandle( hFile2 );
            }
            return FALSE;
        }

    } else
    {
        if ( ( hFile2 = CreateFile(
                                   file2,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                  )) == (HANDLE)-1 )
        {
            fprintf( stderr, "Unable to open %s, error code %d\n", file2, GetLastError() );
            if ( hFile2 != INVALID_HANDLE_VALUE)
            {
                CloseHandle( hFile2 );
            }
            return FALSE;
        }
    }

    hMappedFile2 = CreateFileMapping(
                                     hFile2,
                                     NULL,
                                     PAGE_WRITECOPY,
                                     0,
                                     0,
                                     NULL
                                    );

    if ( hMappedFile2 == NULL)
    {
        fprintf( stderr, "Unable to map %s, error code %d\n", file2, GetLastError() );
        CloseHandle( hFile2);
        return FALSE;
    }

    MappedAddr2 = MapViewOfFile(
                                hMappedFile2,
                                FILE_MAP_COPY,
                                0,
                                0,
                                0
                               );

    if ( MappedAddr2 == NULL)
    {
        fprintf( stderr, "Unable to get mapped view of %s, error code %d\n", file1, GetLastError() );
        UnmapViewOfFile( MappedAddr1 );
        CloseHandle( hFile1 );
        return FALSE;
    }

    CloseHandle( hMappedFile2);

    if ( fIgnoreRs & IsNTImage)
    {
        if ( ( (PIMAGE_DOS_HEADER)MappedAddr2)->e_magic == IMAGE_DOS_SIGNATURE)
        {
            try
            {
                NtHeader2 = (PIMAGE_NT_HEADERS32)( (PCHAR)MappedAddr2 + ( (PIMAGE_DOS_HEADER)MappedAddr2)->e_lfanew);

                if ( NtHeader2->Signature == IMAGE_NT_SIGNATURE)
                {
                    IsNTImage = IsNTImage & TRUE;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {}
        }
    }

    //
    //  Main compare block
    //

    if ( fIgnoreRs)
    {
        if ( IsNTImage)
        {
            try
            {
                ULONG i, c;
                ULONG DirectoryAddressA;
                ULONG DirectoryAddressB;
                ULONG DirectoryAddressD;
                ULONG DirectoryAddressE;
                ULONG DirectoryAddressI;
                ULONG DirectoryAddressR;
                ULONG SizetoEndofFile1 = 0;
                ULONG SizetoResource1  = 0;
                ULONG SizeZeroedOut1   = 0;
                ULONG SizetoEndofFile2 = 0;
                ULONG SizetoResource2  = 0;
                ULONG SizeZeroedOut2   = 0;

                PIMAGE_SECTION_HEADER NtSection;
                PIMAGE_DEBUG_DIRECTORY Debug;
                PIMAGE_EXPORT_DIRECTORY Export;

                BOOL DeleteHeader, AfterResource;

                //
                // Set up virtual addresses of sections of interest
                //

                DirectoryAddressA = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;

                DirectoryAddressB = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;

                DirectoryAddressD = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

                DirectoryAddressI = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                DirectoryAddressE = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                DirectoryAddressR = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;

                //
                //  Zero out Binding Info
                //

                if ( ( DirectoryAddressB < NtHeader1->OptionalHeader.SizeOfHeaders) && ( 0 < DirectoryAddressB))
                {
                    // fprintf( stdout, "ZeroMemoryBa %lx\n", DirectoryAddressB );

                    ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr1 + DirectoryAddressB) ,
                                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size);
                }

                NtSection = (PIMAGE_SECTION_HEADER)(
                                                    (ULONG_PTR)NtHeader1 +
                                                    sizeof( ULONG) +
                                                    sizeof( IMAGE_FILE_HEADER) +
                                                    NtHeader1->FileHeader.SizeOfOptionalHeader
                                                   );


                AfterResource = FALSE; // Initialize

                //
                // Loop through file1 mapping zeroing out ignore sections
                //

                for ( i=0; i<NtHeader1->FileHeader.NumberOfSections; i++)
                {
                    DeleteHeader = FALSE; // Initialize

                    //
                    // Deal with IAT
                    //

                    if ( DirectoryAddressA >= NtSection->VirtualAddress &&
                         DirectoryAddressA < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        // fprintf ( stdout, "ZeroMemoryA1 start %lx and length %lx\n", ( ( DirectoryAddressA - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                        //           NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr1 + ( DirectoryAddressA - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                                    NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size);

                        DeleteHeader = TRUE;
                    }

                    //
                    // Deal with Import
                    //

                    if ( DirectoryAddressI >= NtSection->VirtualAddress &&
                         DirectoryAddressI < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        // fprintf ( stdout, "ZeroMemoryI1 start %lx and length %lx\n", ( ( DirectoryAddressI - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                        //           NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr1 + ( DirectoryAddressI - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                                   NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

                        DeleteHeader = TRUE;
                    }

                    //
                    // Deal with Export
                    //

                    if ( DirectoryAddressE >= NtSection->VirtualAddress &&
                         DirectoryAddressE < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        ULONG NumberOfExportDirectories;

                        NumberOfExportDirectories = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size / sizeof( IMAGE_EXPORT_DIRECTORY );

                        Export = (PIMAGE_EXPORT_DIRECTORY)( (ULONG_PTR)MappedAddr1 + ( DirectoryAddressE - NtSection->VirtualAddress) + NtSection->PointerToRawData);

                        for ( c=0; c<NumberOfExportDirectories; c++)
                        {
                            // fprintf ( stdout, "ZeroMemoryE1 start %lx and length %lx\n", ( ( DirectoryAddressE - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                            //           NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);

                            Export->TimeDateStamp = 0;

                            Export++;
                        }
                    }

                    //
                    // Deal with Debug
                    //

                    if ( DirectoryAddressD >= NtSection->VirtualAddress &&
                         DirectoryAddressD < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        DWORD TimeDate;
                        ULONG NumberOfDebugDirectories;

                        NumberOfDebugDirectories = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof( IMAGE_DEBUG_DIRECTORY );

                        Debug = (PIMAGE_DEBUG_DIRECTORY)( (ULONG_PTR)MappedAddr1 + ( DirectoryAddressD - NtSection->VirtualAddress) + NtSection->PointerToRawData);

                        for ( c=0; c<NumberOfDebugDirectories; c++)
                        {
                            // fprintf ( stdout, "ZeroMemoryD1 start %lx and length %lx\n", ( ( DirectoryAddressD - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                            //           NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

                            if (Debug->PointerToRawData && Debug->SizeOfData)
                            {
                                ZeroMemory((PVOID)((ULONG_PTR)MappedAddr1 + Debug->PointerToRawData),
                                           Debug->SizeOfData);
                            }

                            Debug->PointerToRawData = 0;
                            if (c == 0)
                            {
                                TimeDate = Debug->TimeDateStamp;
                            }
                            Debug->TimeDateStamp = 0;

                            Debug++;
                        }
                        while ( Debug->TimeDateStamp == TimeDate)
                        {
                            Debug->TimeDateStamp = 0;
                            Debug++;
                        }
                    }

                    //
                    // Deal with Resource
                    //

                    if ( DirectoryAddressR >= NtSection->VirtualAddress &&
                         DirectoryAddressR < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        SizetoResource1 = ( ( DirectoryAddressR - NtSection->VirtualAddress) + NtSection->PointerToRawData);
                        SizeZeroedOut1 = NtSection->SizeOfRawData;

                        // fprintf ( stdout, "ZeroMemoryR1 start %lx and length %lx\n", SizetoResource1,
                        //           SizeZeroedOut1);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr1 + SizetoResource1),
                                    SizeZeroedOut1);

                        DeleteHeader = TRUE;
                        AfterResource = TRUE;
                    }

                    //
                    // Deal with Header
                    //

                    if ( DeleteHeader || AfterResource)
                    {
                        // fprintf ( stdout, "ZeroMemoryH1 start %lx and length %lx\n", (PUCHAR)NtSection - (PUCHAR)MappedAddr1, sizeof( IMAGE_SECTION_HEADER));

                        ZeroMemory( NtSection, sizeof( IMAGE_SECTION_HEADER));
                    }
                    ++NtSection;

                }

                //
                // Set up virtual addresses of sections of interest
                //

                DirectoryAddressA = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;

                DirectoryAddressB = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;

                DirectoryAddressI = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                DirectoryAddressE = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                DirectoryAddressD = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

                DirectoryAddressR = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;



                NtSection = (PIMAGE_SECTION_HEADER)(
                                                    (ULONG_PTR)NtHeader2 +
                                                    sizeof( ULONG) +
                                                    sizeof( IMAGE_FILE_HEADER) +
                                                    NtHeader2->FileHeader.SizeOfOptionalHeader
                                                   );

                //
                //  Zero out Binding Info
                //

                if ( ( DirectoryAddressB < NtHeader2->OptionalHeader.SizeOfHeaders) && ( 0 < DirectoryAddressB))
                {
                    // fprintf( stdout, "ZeroMemoryBb %lx\n", DirectoryAddressB );

                    ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr2 + DirectoryAddressB) ,
                                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size);
                }

                AfterResource = FALSE; //Initialize

                //
                // Loop through file2 mapping zeroing out ignore sections
                //

                for ( i=0; i<NtHeader2->FileHeader.NumberOfSections; i++)
                {
                    DeleteHeader = FALSE; // Initialize

                    //
                    // Deal with IAT
                    //

                    if ( DirectoryAddressA >= NtSection->VirtualAddress &&
                         DirectoryAddressA < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        // fprintf ( stdout, "ZeroMemoryA2 start %lx and length %lx\n", ( ( DirectoryAddressA - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                        //           NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr2 + ( DirectoryAddressA - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                                    NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size);

                        DeleteHeader = TRUE;
                    }

                    //
                    // Deal with Import
                    //

                    if ( DirectoryAddressI >= NtSection->VirtualAddress &&
                         DirectoryAddressI < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        // fprintf ( stdout, "ZeroMemoryI2 start %lx and length %lx\n", ( ( DirectoryAddressI - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                        //           NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr2 + ( DirectoryAddressI - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                                   NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

                        DeleteHeader = TRUE;
                    }

                    //
                    // Deal with Export
                    //

                    if ( DirectoryAddressE >= NtSection->VirtualAddress &&
                         DirectoryAddressE < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        ULONG NumberOfExportDirectories;

                        NumberOfExportDirectories = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size / sizeof( IMAGE_EXPORT_DIRECTORY );

                        Export = (PIMAGE_EXPORT_DIRECTORY)( (ULONG_PTR)MappedAddr2 + ( DirectoryAddressE - NtSection->VirtualAddress) + NtSection->PointerToRawData);

                        for ( c=0; c<NumberOfExportDirectories; c++)
                        {
                            // fprintf ( stdout, "ZeroMemoryE2 start %lx and length %lx\n", ( ( DirectoryAddressE - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                            //           NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);

                            Export->TimeDateStamp = 0;

                            Export++;
                        }
                    }

                    //
                    // Deal with Debug
                    //

                    if ( DirectoryAddressD >= NtSection->VirtualAddress &&
                         DirectoryAddressD < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        DWORD TimeDate;
                        ULONG NumberOfDebugDirectories;

                        NumberOfDebugDirectories = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof( IMAGE_DEBUG_DIRECTORY );

                        Debug = (PIMAGE_DEBUG_DIRECTORY)( (ULONG_PTR)MappedAddr2 + ( DirectoryAddressD - NtSection->VirtualAddress) + NtSection->PointerToRawData);

                        for ( c=0; c<NumberOfDebugDirectories; c++)
                        {
                            // fprintf ( stdout, "ZeroMemoryD2 start %lx and length %lx\n", ( ( DirectoryAddressD - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                            //           NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

                            if (Debug->PointerToRawData && Debug->SizeOfData)
                            {
                                ZeroMemory((PVOID)((ULONG_PTR)MappedAddr2 + Debug->PointerToRawData),
                                           Debug->SizeOfData);
                            }

                            Debug->PointerToRawData = 0;
                            if (c == 0)
                            {
                                TimeDate = Debug->TimeDateStamp;
                            }
                            Debug->TimeDateStamp = 0;

                            Debug++;
                        }
                        while ( Debug->TimeDateStamp == TimeDate)
                        {
                            Debug->TimeDateStamp = 0;
                            Debug++;
                        }
                    }

                    //
                    // Deal with Resource
                    //

                    if ( DirectoryAddressR >= NtSection->VirtualAddress &&
                         DirectoryAddressR < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        SizetoResource2 = ( ( DirectoryAddressR - NtSection->VirtualAddress) + NtSection->PointerToRawData);
                        SizeZeroedOut2 = NtSection->SizeOfRawData;

                        // fprintf ( stdout, "ZeroMemoryR2 start %lx and length %lx\n", SizetoResource2,
                        //           SizeZeroedOut2);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr2 + SizetoResource2),
                                    SizeZeroedOut2);

                        DeleteHeader = TRUE;
                        AfterResource = TRUE;
                    }

                    //
                    // Deal with Header
                    //

                    if ( DeleteHeader || AfterResource)
                    {
                        // fprintf( stdout, "ZeroMemoryH2 start %lx and length %lx\n", (PUCHAR)NtSection - (PUCHAR)MappedAddr2, sizeof( IMAGE_SECTION_HEADER));

                        ZeroMemory( NtSection, sizeof( IMAGE_SECTION_HEADER));
                    }
                    ++NtSection;
                }

                //
                //  Zero out header info
                //

                NtHeader1->FileHeader.TimeDateStamp = 0;

                NtHeader2->FileHeader.TimeDateStamp = 0;

                NtHeader1->OptionalHeader.CheckSum = 0;

                NtHeader2->OptionalHeader.CheckSum = 0;

                NtHeader1->OptionalHeader.SizeOfInitializedData = 0;

                NtHeader2->OptionalHeader.SizeOfInitializedData = 0;

                NtHeader1->OptionalHeader.SizeOfImage = 0;

                NtHeader2->OptionalHeader.SizeOfImage = 0;

                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = 0;

                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = 0;

                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;

                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;

                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;

                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;

                //
                // Do compares here
                //

                if ( SizetoResource1 == SizetoResource2)
                {
                    if ( memcmp( MappedAddr1, MappedAddr2, SizetoResource1) == 0)
                    {
                        SizetoEndofFile1 =  GetFileSize( hFile1, NULL) - ( SizetoResource1 + SizeZeroedOut1);

                        SizetoEndofFile2 =  GetFileSize( hFile2, NULL) - ( SizetoResource2 + SizeZeroedOut2);

                        if ( SizetoEndofFile1 == SizetoEndofFile2)
                        {
                            if ( memcmp( (PVOID)( (ULONG_PTR)MappedAddr1 + SizetoResource1 + SizeZeroedOut1), (PVOID)( ( ULONG_PTR)MappedAddr2 + SizetoResource2 + SizeZeroedOut2), SizetoEndofFile1) == 0)
                            {
                                UnmapViewOfFile( MappedAddr1 );
                                UnmapViewOfFile( MappedAddr2 );
                                CloseHandle( hFile1 );
                                CloseHandle( hFile2 );
                                return TRUE;
                            }
                        }
                    }
                }
                UnmapViewOfFile( MappedAddr1 );
                UnmapViewOfFile( MappedAddr2 );
                CloseHandle( hFile1 );
                CloseHandle( hFile2 );
                return FALSE;
            }
            except( EXCEPTION_EXECUTE_HANDLER )
            {
                UnmapViewOfFile( MappedAddr1 );
                UnmapViewOfFile( MappedAddr2 );
                CloseHandle( hFile1 );
                CloseHandle( hFile2 );
                if ( !NoMapBinaryCompare( file1, file2))
                {
                    return FALSE;

                } else
                {
                    return TRUE;
                }
            }
        }

        _unlink( RebasedFile2); // Delete RebasedFile that might have been created
    }

    if ( GetFileSize( hFile1, NULL) == GetFileSize( hFile2, NULL) )
    {
        try
        {
            if ( memcmp( MappedAddr1, MappedAddr2, GetFileSize( hFile1, NULL)) == 0)
            {
                UnmapViewOfFile( MappedAddr1 );
                UnmapViewOfFile( MappedAddr2 );
                CloseHandle( hFile1 );
                CloseHandle( hFile2 );
                return TRUE;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            UnmapViewOfFile( MappedAddr1 );
            UnmapViewOfFile( MappedAddr2 );
            CloseHandle( hFile1 );
            CloseHandle( hFile2 );
            if ( !NoMapBinaryCompare( file1, file2))
            {
                return FALSE;

            } else
            {
                return TRUE;
            }
        }
    }

    UnmapViewOfFile( MappedAddr1 );
    UnmapViewOfFile( MappedAddr2 );
    CloseHandle( hFile1 );
    CloseHandle( hFile2 );
    return FALSE;

}

int Mymemcmp( const void *buf1, const void *buf2, size_t count )
{
    size_t memoffset = 0;
    int retval = FALSE;

    do
    {
        try
        {
            if ( memcmp( (PVOID)( (PCHAR)buf1 + memoffset), (PVOID)( (PCHAR)buf2 + memoffset), sizeof( size_t)) != 0)
            {
                fprintf( stdout, "Offset is %Lx ", memoffset);
                fprintf( stdout, "Contents are %Lx and %Lx\n", *( (PULONG)( (PCHAR)buf1 + memoffset)), *( (PULONG)( (PCHAR)buf2 + memoffset)) );

                retval = TRUE;
            }
        }

        except( EXCEPTION_EXECUTE_HANDLER )
        {
            fprintf( stdout, "Memory not allocated\n");

        }

    }  while ( ( memoffset = memoffset + sizeof( size_t)) < count);

    return retval;

}

//
// CompDir turns Path1 and Path2 into:
//
//   AddList - Files that exist in Path1 but not in Path2
//
//   DelList - Files that do not exist in Path1 but exist in Path2
//
//   DifList - Files that are different between Path1 and Path2 based
//             on criteria provided by flags passed to CompDir
//
//   It then passes these lists to CompLists and processes the result.
//

void CompDir( char *Path1, char *Path2)
{
    LinkedFileList   AddList, DelList, DifList;
    struct CFLStruct Parameter1, Parameter2;

    DWORD            Id;
    HANDLE           Threads[2];

    DWORD CFReturn;

    AddList  = NULL;  //
    DelList  = NULL;  //  Start with empty lists
    DifList  = NULL;  //

    Parameter1.List = &AddList;
    Parameter1.Path = Path1;

    if ( fMultiThread)
    {
        Threads[0] = CreateThread(
                                  NULL,
                                  0,
                                  CreateFileList,
                                  &Parameter1,
                                  0,
                                  &Id
                                 );

        if ( Threads[0] == NULL)
        {
            fprintf( stderr, "CreateThread1Failed, error code %d\n", GetLastError() );
            CreateFileList( &Parameter1);
            fMultiThread = FALSE;
        }

    } else
    {
        CreateFileList( &Parameter1);
    }

    Parameter2.List = &DelList;
    Parameter2.Path = Path2;

    if ( fMultiThread)
    {
        Threads[1] = CreateThread(
                                  NULL,
                                  0,
                                  CreateFileList,
                                  &Parameter2,
                                  0,
                                  &Id
                                 );
        if ( Threads[1] == NULL)
        {
            fprintf( stderr, "CreateThread2Failed, error code %d\n", GetLastError() );
            CFReturn = CreateFileList( &Parameter2);
            fMultiThread = FALSE;
        }

    } else
    {
        CFReturn = CreateFileList( &Parameter2);
    }


    if ( fMultiThread)
    {
        Id = WaitForMultipleObjects(
                                    2,
                                    Threads,
                                    TRUE,
                                    (DWORD)-1
                                   );

        GetExitCodeThread( Threads[1], &CFReturn);

        CloseHandle( Threads[0]);
        CloseHandle( Threads[1]);
    }

    if ( CFReturn == 0)
    {
        CompLists( &AddList, &DelList, &DifList, Path1, Path2);

        ProcessLists( AddList, DelList, DifList, Path1, Path2);
    }

    FreeList( &DifList);
    FreeList( &DelList);
    FreeList( &AddList);

} // CompDir

BOOL FilesDiffer( LinkedFileList File1, LinkedFileList File2, char *Path1, char *Path2)
{

    DWORD High1, High2, Low1, Low2;     // Used in comparing times
    BOOL Differ = FALSE;
    char *FullPath1, *FullPath2;

    //
    // Check if same name is a directory under Path1
    // and a file under Path2 or vice-versa
    //

    if (
        ( (*File1).Attributes & FILE_ATTRIBUTE_DIRECTORY)
                                ||
        ( (*File2).Attributes & FILE_ATTRIBUTE_DIRECTORY)
       )
    {
        if ( ( (*File1).Attributes & FILE_ATTRIBUTE_DIRECTORY) && ( (*File2).Attributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if ( !fDoNotRecurse)
            {
                //
                // Create Full Path Strings
                //
                _strrev( (*File1).Name);
                _strrev( (*File2).Name);

                if ( DealingWithDirectories)
                {
                    ( Path1[strlen( Path1) - 1] == '\\') ? ( FullPath1 = MYSTRCAT( Path1, (*File1).Name)) :
                        ( FullPath1 = COMBINETHREESTRINGS( Path1, "\\", (*File1).Name));

                    ( Path2[strlen( Path2) - 1] == '\\') ? ( FullPath2 = MYSTRCAT( Path2, (*File1).Name)) :
                        ( FullPath2 = COMBINETHREESTRINGS( Path2, "\\", (*File1).Name));
                } else
                {
                    FullPath1 = MYSTRCAT( Path1, "");

                    FullPath2 = MYSTRCAT( Path2, "");
                }

                _strrev( (*File1).Name);
                _strrev( (*File2).Name);

                CompDir( FullPath1, FullPath2);

                FREE( FullPath1);
                FREE( FullPath2);
            }

        } else
        {
            if( ! ( (*File1).Attributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                strcat( (*File1).Flag, "@");

            } else
            {
                strcat( (*File2).Flag, "@");
            }
            Differ = TRUE;
        }

    } else
    {
        if ( fCheckTime)
        {
            if ( Granularity)
            {
                //
                // Bit manipulation to deal with large integers.
                //

                High1 = (*File1).Time.dwHighDateTime>>23;
                High2 = (*File2).Time.dwHighDateTime>>23;
                if ( High1 == High2)
                {
                    Low1 = ( (*File1).Time.dwHighDateTime<<9) |
                           ( (*File1).Time.dwLowDateTime>>23);
                    Low2 = ( (*File2).Time.dwHighDateTime<<9) |
                           ( (*File2).Time.dwLowDateTime>>23);
                    if ( ( ( Low1 > Low2) ? ( Low1 - Low2) : ( Low2 - Low1))
                                                          > Granularity)
                    {
                       strcat( (*File1).Flag, "T");
                       Differ = TRUE;
                    }
                 } else
                 {
                     Differ = TRUE;
                 }

            } else if ( CompareFileTime( &( (*File1).Time),
                     &( (*File2).Time)) != 0)
            {
                strcat( (*File1).Flag, "T");
                Differ = TRUE;
            }
        }

        if ( fCheckSize &&
             (
              ( (*File1).SizeLow != (*File2).SizeLow)
                             ||
              ( (*File1).SizeHigh != (*File2).SizeHigh)
             )
           )
        {
            strcat( (*File1).Flag, "S");
            Differ = TRUE;
        }

        if ( fCheckAttribs)
        {
            if ( ((*File1).Attributes ^ (*File2).Attributes) & NORMAL_ATTRIBUTES)
            {
                strcat( (*File1).Flag, "A");
                Differ = TRUE;
            }
        }

        if ( fCheckBits)
        {
            //
            // Create Full Path Strings
            //
            _strrev( (*File1).Name);
            _strrev( (*File2).Name);

            if ( DealingWithDirectories)
            {
                ( Path1[strlen( Path1) - 1] == '\\') ? ( FullPath1 = MYSTRCAT( Path1, (*File1).Name)) :
                    ( FullPath1 = COMBINETHREESTRINGS( Path1, "\\", (*File1).Name));

                ( Path2[strlen( Path2) - 1] == '\\') ? ( FullPath2 = MYSTRCAT( Path2, (*File1).Name)) :
                    ( FullPath2 = COMBINETHREESTRINGS( Path2, "\\", (*File1).Name));
            } else
            {
                FullPath1 = MYSTRCAT( Path1, "");

                FullPath2 = MYSTRCAT( Path2, "");
            }

            _strrev( (*File1).Name);
            _strrev( (*File2).Name);

            if ( fIgnoreRs)
            {
                if (
                    (
                     (*File1).SizeLow != 0
                              ||
                     (*File1).SizeHigh != 0)
                              &&
                     ( !BinaryCompare( FullPath1, FullPath2)
                    )
                   )
                {
                    strcat( (*File1).Flag, "B");
                    Differ = TRUE;
                }

            } else
            {
                if (
                    ( (*File1).SizeLow   != (*File2).SizeLow)
                                    ||
                    ( (*File1).SizeHigh  != (*File2).SizeHigh)
                                    ||
                    (
                     (
                      (*File1).SizeLow != 0
                                ||
                      (*File1).SizeHigh != 0
                     )
                                    &&
                     ( !BinaryCompare( FullPath1, FullPath2))
                    )
                   )
                {
                    strcat( (*File1).Flag, "B");
                    Differ = TRUE;
                }
            }

            FREE( FullPath1);
            FREE( FullPath2);
        }

        if ( fForce)
        {
            Differ = TRUE;
        }
    }

    return Differ;

} // FilesDiffer

//
// CompLists Does the dirty work for CompDir
//
void CompLists( LinkedFileList *AddList, LinkedFileList *DelList, LinkedFileList *DifList, char *Path1, char *Path2)
{
    LinkedFileList *TmpAdd, *TmpDel, TmpNode;
    char *FullPath1, *FullPath2;

    if ( ( DelList == NULL) || ( *DelList == NULL) || ( AddList == NULL) || ( *AddList == NULL))
    {
        return;
    }
    TmpAdd = AddList;   // pointer to keep track of position in addlist

    if ( *TmpAdd != NULL)
    {
        TmpAdd = &( **TmpAdd).First;
    }

    do
    {
        if ( DealingWithDirectories)
        {
            TmpDel = FindInList( ( **TmpAdd).Name, DelList);

        } else
        {
            TmpDel = DelList;
        }
        if ( TmpDel != NULL)
        {
            if ( FilesDiffer( *TmpAdd, *TmpDel, Path1, Path2))
            {
                //
                // Combine Both Nodes together so they
                // can be printed out together
                //
                DuplicateNode( *TmpAdd, &TmpNode);
                DuplicateNode( *TmpDel, &( *TmpNode).DiffNode);
                AddToList( TmpNode, DifList);
                ( **TmpDel).Process = FALSE;
                ( **TmpAdd).Process = FALSE;

            } else
            {
                ( **TmpDel).Process = FALSE;
                ( **TmpAdd).Process = !ProcessModeDefault;
            }

        } else if ( SparseTree && ( ( **TmpAdd).Attributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if ( !fDoNotRecurse)
            {
                _strrev( ( **TmpAdd).Name);

                ( Path1[strlen( Path1) - 1] == '\\') ? ( FullPath1 = MYSTRCAT( Path1, ( **TmpAdd).Name)) :
                    ( FullPath1 = COMBINETHREESTRINGS( Path1, "\\", ( **TmpAdd).Name));

                ( Path2[strlen( Path2) - 1] == '\\') ? ( FullPath2 = MYSTRCAT( Path2, ( **TmpAdd).Name)) :
                    ( FullPath2 = COMBINETHREESTRINGS( Path2, "\\", ( **TmpAdd).Name));

                _strrev( ( **TmpAdd).Name);

                CompDir( FullPath1, FullPath2);
            }

        } // if ( *TmpDel != NULL)

        TmpAdd = &( ( **TmpAdd).Next);

    } while ( *TmpAdd != NULL);

} // CompLists

//
// CopyNode walks the source node and its children ( recursively)
// and creats the appropriate parts on the destination node
//

void CopyNode ( char *Destination, LinkedFileList Source, char *FullPathSrc)
{
    BOOL pend, CanDetectFreeSpace = TRUE;
    int i;
    DWORD sizeround;
    DWORD BytesPerCluster;
    ATTRIBUTE_TYPE Attributes;

    int LastErrorGot;
    __int64 freespac;
    char root[5] = {*Destination,':','\\','\0'};
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;

    if ( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) )
    {
        CanDetectFreeSpace = FALSE;

    } else
    {
        freespac = ( (__int64)cBytesPerSec * (__int64)cSecsPerClus * (__int64)cFreeClus );
        BytesPerCluster = cSecsPerClus * cBytesPerSec;
    }

    fprintf( stdout, "%s => %s\t", FullPathSrc, Destination);

    if ( CanDetectFreeSpace)
    {
        sizeround = (*Source).SizeLow;
        sizeround += BytesPerCluster - 1;
        sizeround /= BytesPerCluster;
        sizeround *= BytesPerCluster;

        if ( freespac < sizeround)
        {
            fprintf( stderr, "not enough space\n");
            return;
        }
    }

    GET_ATTRIBUTES( Destination, Attributes);
    i = SET_ATTRIBUTES( Destination, Attributes & NONREADONLYSYSTEMHIDDEN );

    i = 1;

    do
    {
        if ( !fCreateLink)
        {
            if ( !fBreakLinks)
            {
                pend = MyCopyFile( FullPathSrc, Destination, FALSE);

            } else
            {
                _unlink( Destination);
                pend = MyCopyFile( FullPathSrc, Destination, FALSE);
            }

        } else
        {
            if ( i == 1)
            {
                pend = MakeLink( FullPathSrc, Destination, FALSE);

            } else
            {
                pend = MakeLink( FullPathSrc, Destination, TRUE);
            }
        }

        if ( SparseTree && !pend)
        {
            if ( !MyCreatePath( Destination, FALSE))
            {
                fprintf( stderr, "Unable to create path %s", Destination);
                ExitValue = 1;
            }
        }

    } while ( ( i++ < 2) && ( !pend) );

    if ( !pend)
    {
        LastErrorGot = GetLastError ();

        if ( ( fCreateLink) && ( LastErrorGot == 1))
        {
            fprintf( stderr, "Can only make links on NTFS and OFS");

        } else if ( fCreateLink)
        {
            fprintf( stderr, "(error = %d)", LastErrorGot);

        } else
        {
            fprintf( stderr, "Copy Error (error = %d)", LastErrorGot);
        }

        ExitValue = 1;
    }

    if ( pend)
    {
        fprintf( stdout, "[OK]\n");

    } else
    {
        fprintf( stderr, "\n");
    }
    //
    // Copy attributes from Source to Destination
    //

    // GET_ATTRIBUTES( FullPathSrc, Attributes);
    if ( !fDontCopyAttribs)
    {
        i = SET_ATTRIBUTES( Destination, Source->Attributes);
    }
    else
    {
        i = SET_ATTRIBUTES( Destination, FILE_ATTRIBUTE_ARCHIVE);
    }

} // CopyNode

//
// CreateFileList walks down list adding files as they are found
//
DWORD CreateFileList( LPVOID ThreadParameter)
{
    PCFLStruct Parameter = ( PCFLStruct)ThreadParameter;
    LinkedFileList *List = Parameter->List;
    char *Path = Parameter->Path;
    char *String;
    LinkedFileList Node;
    ATTRIBUTE_TYPE Attributes;

    HANDLE handle;
    WIN32_FIND_DATA Buff;

    IF_GET_ATTR_FAILS( Path, Attributes)
    {
        return 0;
    }

    if ( Attributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        ( Path[strlen( Path) - 1] != '\\') ? ( String = MYSTRCAT( Path,"\\*.*")) :
            ( String = MYSTRCAT( Path,"*.*"));

        handle = FIND_FIRST( String, Buff);

    } else
    {
        handle = FIND_FIRST( Path, Buff);
    }

    FREE( String);

    if ( handle != INVALID_HANDLE_VALUE)
    {
            //
            // Need to find the '.' or '..' directories and get them out of the way
            //

        do
        {
            if (
                ( strcmp( Buff.cFileName, ".")  != 0)
                                &&
                ( strcmp( Buff.cFileName, "..") != 0)
                                &&
                ( ((Buff.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) ||
                  !fDoNotRecurse)
               )
            {
                //
                // If extensions are defined we match them here
                //
                if (
                    ( !Excludes )
                           ||
                    ( Excludes && ( !Excluded( Buff.cFileName, Path)) )
                   )
                {
                    if (
                        ( !Matches )
                              ||
                        ( ( Buff.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                                          ||
                        ( Matches && ( Matched( Buff.cFileName, Path)) )
                       )
                    {
                        if ( !fIgnoreSlmFiles
                                    ||
                             (
                              (_stricmp( Buff.cFileName, "slm.ini") != 0)
                                               &&
                              (_stricmp( Buff.cFileName, "slm.dif") != 0)
                                               &&
                              (_stricmp( Buff.cFileName, "iedcache.slm.v6") != 0)
                             )
                           )
                        {

                            if ( fSpecAttribs)
                            {
                                if ( Buff.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                                {
                                    CreateNode( &Node, &Buff);
                                    AddToList( Node, List);

                                } else if ( NegativeCompareAttributeSet && CompareAttributeSet)
                                {
                                    if (
                                        !( Buff.dwFileAttributes & NegativeCompareAttribute)
                                                           &&
                                        ( ( Buff.dwFileAttributes & CompareAttribute) == CompareAttribute)
                                       )
                                    {
                                        CreateNode( &Node, &Buff);
                                        AddToList( Node, List);
                                    }

                                } else if ( CompareAttributeSet )
                                {
                                    if ( ( Buff.dwFileAttributes & CompareAttribute) == CompareAttribute)
                                    {

                                        CreateNode( &Node, &Buff);
                                        AddToList( Node, List);
                                    }

                                } else if ( NegativeCompareAttributeSet )
                                {
                                    if ( !( Buff.dwFileAttributes & NegativeCompareAttribute) )
                                    {
                                         CreateNode( &Node, &Buff);
                                         AddToList( Node, List);
                                    }
                                }

                            } else
                            {
                                CreateNode( &Node, &Buff);
                                AddToList( Node, List);
                            }
                        }
                    }
                }
            }
        } while ( FIND_NEXT( handle, Buff) == 0);

    } // ( handle != INVALID_HANDLE_VALUE)

    FindClose( handle);

    return 0;       // This will exit this thread

} // CreateFileList

BOOL DelNode ( char *Path)
{
    char *String;
    ATTRIBUTE_TYPE Attributes;

    HANDLE handle;
    WIN32_FIND_DATA Buff;

    IF_GET_ATTR_FAILS( Path, Attributes)
        return TRUE;

    if ( Attributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        ( Path[strlen( Path) - 1] != '\\') ? ( String = MYSTRCAT( Path,"\\*.*")) :
             ( String = MYSTRCAT( Path,"*.*"));

        handle = FIND_FIRST( String, Buff);

        if ( handle == INVALID_HANDLE_VALUE)
        {
            fprintf( stderr, "%s is inaccesible\n", Path);
            ExitValue = 1;
            return FALSE;
        }

        FREE( String);

        do
        {
            //
            // Need to find the '.' or '..' directories and get them out of the way
            //

            if (
                ( strcmp( Buff.cFileName, ".")  != 0)
                              &&
                ( strcmp( Buff.cFileName, "..") != 0)
               )
            {
                //
                // if directory is read-only, make it writable
                //
                if ( Attributes & FILE_ATTRIBUTE_READONLY)
                {
                    if ( SET_ATTRIBUTES( Path, Attributes & ~FILE_ATTRIBUTE_READONLY) != 0)
                    {
                        break;
                    }
                }
                String = COMBINETHREESTRINGS( Path, "\\", Buff.cFileName);
                if ( !DelNode( String))
                {
                    FREE( String);
                    return FALSE;

                } else
                {
                    FREE( String);
                }
            }

        } while ( FIND_NEXT( handle, Buff) == 0);

        FindClose( handle);

        if ( _rmdir( Path) != 0)
        {
            return FALSE;
        }

    } else
    {
        //
        // if file is read-only, make it writable
        //
        if ( Attributes & FILE_ATTRIBUTE_READONLY)
        {
           if ( SET_ATTRIBUTES( Path, Attributes & ~FILE_ATTRIBUTE_READONLY) != 0)
           {
               return FALSE;
           }
        }

        if ( _unlink( Path) != 0)
        {
            return FALSE;
        }
    }
    return TRUE;

} // DelNode

BOOL IsFlag( char *argv)
{
    char String[MAX_PATH];
    char *String1, *String2;
    char *TmpArg;
    char *ExcludeFile, *MatchFile;
    FILE *FileHandle;
    LinkedFileList Node;
    BOOL NegationFlagSet = FALSE;


    if ( ( *argv == '/') || ( *argv == '-'))
    {
        fMatching = FALSE; // If there's a new flag then that's the
        fExclude  = FALSE; // end of the match/exclude list

        if ( strchr( argv, '?'))
        {
            Usage();
        }
        TmpArg = _strlwr( argv);

        while ( *++TmpArg != '\0')
        {
            switch ( *TmpArg)
            {
                case 'a' :
                    fCheckAttribs = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'b' :
                    fCheckBits = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'c' :
                    fScript = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'd' :
                    fDoNotDelete = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'e' :
                    fExecute = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'f' :
                    fOnlyIfExists = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'g' :
                    fIgnoreSlmFiles = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'h' :
                    fDontCopyAttribs = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'i' :
                    fIgnoreRs = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'k' :
                    fBreakLinks = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'l' :
                    fCreateLink = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'm' :

                    if ( NegationFlagSet) {
                        fprintf ( stderr, "can't use - on /m option\n");
                        Usage();
                    }

                    if (
                        ( *( TmpArg + 1) == ':')
                                &&
                        ( *( TmpArg + 2) != '\0')
                       )
                    {

                        ( MatchFile = TmpArg + 2);

                        while (isgraph( *( ++TmpArg + 1))) {}

                        if  ( ( FileHandle = fopen( MatchFile, "r")) == NULL)
                        {
                            fprintf( stderr, "cannot open %s\n", MatchFile);
                            Usage();

                        } else
                        {
                            while ( fgets( String1   = String, MAX_PATH, FileHandle) != NULL)
                            {
                                while ( *( String2 = &( String1[ strspn( String1, " \n\r") ])))
                                {
                                    if ( *( String1 = &( String2[ strcspn( String2, " \n\r") ])))
                                    {
                                         *String1++ = 0;
                                         CreateNameNode( &Node, String2);
                                         if ( strchr( String2, '*') != NULL)
                                         {
                                             AddToList( Node, &MStarList);

                                         } else
                                         {
                                             AddToList( Node, &MatchList);
                                         }
                                    }
                                }
                            }
                            fclose( FileHandle) ;
                        }
                    }
                    fMatching   = TRUE;
                    Matches     = TRUE;
                    break;

                case 'n' :
                    fCreateNew = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'o' :
                    fOpposite = !NegationFlagSet;
                    ProcessModeDefault = !fOpposite;
                    NegationFlagSet = FALSE;
                    break;

                case 'p' :


                    if ( NegationFlagSet) {
                        fprintf ( stderr, "can't use - on /p option\n");
                        Usage();
                    }

                    if ( *( TmpArg + 1) != '{')
                    {
                        fprintf ( stderr, "/p option improperly formatted\n");
                        Usage();
                    }

                    TmpArg++;

                    while ( *++TmpArg != '}')
                    {
                        switch ( *TmpArg)
                        {
                            case 'a' :
                                if ( NegationFlagSet)
                                {
                                    if ( !NegativeCompareAttributeSet)
                                    {
                                        NegativeCompareAttribute = FILE_ATTRIBUTE_ARCHIVE;
                                        NegativeCompareAttributeSet = TRUE;

                                    } else
                                    {
                                        NegativeCompareAttribute = NegativeCompareAttribute | FILE_ATTRIBUTE_ARCHIVE;
                                    }

                                } else
                                {
                                    if ( !CompareAttributeSet)
                                    {
                                        CompareAttribute = FILE_ATTRIBUTE_ARCHIVE;
                                        CompareAttributeSet = TRUE;

                                    } else
                                    {
                                        CompareAttribute = CompareAttribute | FILE_ATTRIBUTE_ARCHIVE;
                                    }
                                }
                                NegationFlagSet = FALSE;
                                break;

                            case 'r' :
                                if ( NegationFlagSet)
                                {
                                    if ( !NegativeCompareAttributeSet)
                                    {
                                        NegativeCompareAttribute = FILE_ATTRIBUTE_READONLY;
                                        NegativeCompareAttributeSet = TRUE;

                                    }  else
                                    {
                                        NegativeCompareAttribute = NegativeCompareAttribute | FILE_ATTRIBUTE_READONLY;
                                    }

                                } else
                                {
                                    if ( !CompareAttributeSet)
                                    {
                                        CompareAttribute = FILE_ATTRIBUTE_READONLY;
                                        CompareAttributeSet = TRUE;

                                    } else
                                    {
                                        CompareAttribute = CompareAttribute | FILE_ATTRIBUTE_READONLY;
                                    }
                                }
                                NegationFlagSet = FALSE;
                                break;

                            case 'h' :
                                if ( NegationFlagSet)
                                {
                                    if ( !NegativeCompareAttributeSet)
                                    {
                                        NegativeCompareAttribute = FILE_ATTRIBUTE_HIDDEN;
                                        NegativeCompareAttributeSet = TRUE;

                                    } else
                                    {
                                        NegativeCompareAttribute = NegativeCompareAttribute | FILE_ATTRIBUTE_HIDDEN;
                                    }

                                } else
                                {
                                    if ( !CompareAttributeSet)
                                    {
                                        CompareAttribute = FILE_ATTRIBUTE_HIDDEN;
                                        CompareAttributeSet = TRUE;

                                    } else
                                    {
                                        CompareAttribute = CompareAttribute | FILE_ATTRIBUTE_HIDDEN;
                                    }
                                }
                                NegationFlagSet = FALSE;
                                break;

                            case 's' :
                                if ( NegationFlagSet)
                                {
                                    if ( !NegativeCompareAttributeSet)
                                    {
                                        NegativeCompareAttribute = FILE_ATTRIBUTE_SYSTEM;
                                        NegativeCompareAttributeSet = TRUE;

                                    } else
                                    {
                                        NegativeCompareAttribute = NegativeCompareAttribute | FILE_ATTRIBUTE_SYSTEM;
                                    }

                                } else
                                {
                                    if ( !CompareAttributeSet)
                                    {
                                        CompareAttribute = FILE_ATTRIBUTE_SYSTEM;
                                        CompareAttributeSet = TRUE;

                                    } else
                                    {
                                        CompareAttribute = CompareAttribute | FILE_ATTRIBUTE_SYSTEM;
                                    }
                                }
                                NegationFlagSet = FALSE;
                                break;

                            case '-' :
                               NegationFlagSet = TRUE;
                               break;

                            default  :
                               fprintf( stderr, "/p option improperly formatted\n");
                               Usage();
                        }

                    }

                    if ( !CompareAttributeSet && !NegativeCompareAttributeSet)
                    {
                        fprintf( stderr, "no compare attributes not set\n");
                        Usage();
                    }
                    fSpecAttribs = TRUE;
                    NegationFlagSet = FALSE;
                    break;

                case 'r' :
                    fDoNotRecurse = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 's' :
                    fCheckSize = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 't' :

                    //
                    // Get Granularity parameter
                    //

                    if (
                        ( *( TmpArg + 1) == ':')
                                  &&
                        ( *( TmpArg + 2) != '\0')
                       )
                    {

                        sscanf( ( TmpArg + 2), "%d", &Granularity);

                        Granularity = Granularity*78125/65536;
                           // Conversion to seconds ^^^^^^^
                           //         10^7/2^23

                        while (isdigit( *( ++TmpArg + 1))) {}
                    }
                    fCheckTime = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'u' :
                    fMultiThread = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'v' :
                    fVerbose = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'w' :
                    fDontLowerCase = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'x' :
                    if ( NegationFlagSet) {
                        fprintf ( stderr, "can't use - on /x option\n");
                        Usage();
                    }

                    if (
                        ( *( TmpArg + 1) == ':')
                                &&
                        ( *( TmpArg + 2) != '\0')
                       )
                    {
                        ( ExcludeFile = TmpArg + 2);

                        while (isgraph( *( ++TmpArg + 1))) {}

                        if ( ( FileHandle = fopen( ExcludeFile, "r")) == NULL)
                        {
                            fprintf( stderr, "cannot open %s\n", ExcludeFile);
                            Usage();

                        } else
                        {
                            while ( fgets( String1   = String, MAX_PATH, FileHandle) != NULL)
                            {
                                 while ( *( String2 = &( String1[ strspn( String1, "\n\r") ])))
                                 {
                                     if ( *( String1 = &( String2[ strcspn ( String2, "\n\r") ])))
                                     {
                                         *String1++ = 0;
                                         CreateNameNode( &Node, String2);
                                         if ( strchr( String2, '*') != NULL)
                                         {
                                             AddToList( Node, &EStarList);

                                         } else
                                         {
                                             AddToList( Node, &ExcludeList);
                                         }
                                     }
                                 }
                            }
                            fclose( FileHandle) ;
                        }
                    }

                    fExclude    = TRUE;
                    Excludes    = TRUE;
                    break;

        case 'z' :
            fForce = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

        case '$' :
            fTrySis = !NegationFlagSet;
            NegationFlagSet = FALSE;
                    break;

                case '/' :
                    NegationFlagSet = FALSE;
                    break;

                case '-' :
                    NegationFlagSet = TRUE;
                    break;

                default :
                    fprintf( stderr, "Don't know flag(s) %s\n", argv);
                    Usage();
            }
        }

    } else
    {
        return FALSE;
    }

    return TRUE;

} // IsFlag

BOOL Excluded( char *FileName, char *Path)
{
    char *PathPlusName;

    PathPlusName = COMBINETHREESTRINGS( Path, "\\", FileName);

    if (
         ( FindInMatchListTop( FileName, &ExcludeList))
                               ||
         ( FindInMatchListTop( PathPlusName, &ExcludeList))
                               ||
         ( FindInMatchListFront( FileName, &EStarList))
                               ||
         ( FindInMatchListFront( PathPlusName, &EStarList))

       )
    {
        FREE( PathPlusName);
        return TRUE;

    } else
    {
        FREE( PathPlusName);
        return FALSE;
    }

} // Excluded

BOOL Matched( char *FileName, char *Path)
{
    char *PathPlusName;

    PathPlusName = COMBINETHREESTRINGS( Path, "\\", FileName);

    if (
         ( FindInMatchListTop( FileName, &MatchList))
                               ||
         ( FindInMatchListTop( PathPlusName, &MatchList))
                               ||
         ( FindInMatchListFront( FileName, &MStarList))
                               ||
         ( FindInMatchListFront( PathPlusName, &MStarList))
       )
    {
        FREE( PathPlusName);
        return TRUE;

    } else
    {
        FREE( PathPlusName);
        return FALSE;
    }

} // Matched

BOOL MyCreatePath( char *Path, BOOL IsDirectory)
{
    char *ShorterPath, *LastSlash;

    ATTRIBUTE_TYPE Attributes;

    IF_GET_ATTR_FAILS( Path, Attributes)
    {
        if ( !IsDirectory || ( ( _mkdir( Path)) != 0) )
        {
            ShorterPath = MYSTRCAT( Path, "");

            LastSlash = strrchr( ShorterPath, '\\');

            if (
                ( LastSlash != NULL)
                        &&
                ( LastSlash != strchr( ShorterPath, '\\'))
               )
            {
                *LastSlash = '\0';

            } else
            {
                FREE( ShorterPath);
                return FALSE;
            }

            if ( MyCreatePath( ShorterPath, TRUE))
            {
                FREE( ShorterPath);

                if ( IsDirectory)
                {
                    return( ( _mkdir( Path)) == 0);

                } else
                {
                    return TRUE;
                }

            } else
            {
                _rmdir( ShorterPath);
                FREE( ShorterPath);
                return FALSE;
            }

        } else
        {
            return TRUE;
        }

    } else
    {
        return TRUE;
    }

} // MyCreatePath


BOOL
MyCopyFile(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    BOOL ok;

    if (fTrySis) {
        ok = SisCopyFile( lpExistingFileName, lpNewFileName, bFailIfExists, &fTrySis);
        if (ok) {
            return TRUE;
        }
    }

    return CopyFile( lpExistingFileName, lpNewFileName, bFailIfExists);
}

int ParseArgsSub( int argc, char *argv[])
{
    int ArgCount, FlagCount;

    LinkedFileList Node;

    ArgCount  = 1;
    FlagCount = 0;

    fMatching = FALSE;
    fExclude = FALSE;

    do
    {
        if ( IsFlag( argv[ArgCount] ))
        {
            FlagCount++;

        } else // ( IsFlag( argv[ArgCount] ))
        {
            if ( ArgCount + 2 < argc)
            {
                if ( fMatching)
                {
                    CreateNameNode( &Node, argv[ArgCount]);
                    if ( strchr( argv[ArgCount], '*') != NULL)
                    {
                        AddToList( Node, &MStarList);

                    } else
                    {
                        AddToList( Node, &MatchList);
                    }
                }
                if ( fExclude)
                {
                    CreateNameNode( &Node, argv[ArgCount]);
                    if ( strchr( argv[ArgCount], '*') != NULL)
                    {
                        AddToList( Node, &EStarList);

                    } else
                    {
                        AddToList( Node, &ExcludeList);
                    }
                }
                if ( ( !fMatching) && ( !fExclude))
                {
                    fprintf( stderr, "Don't know option %s\n", argv[ArgCount]);
                    Usage();
                }
            }
        }
    } while ( ArgCount++ < argc - 1);

    return FlagCount;

} // ParseArgsSub

void ParseEnvArgs( void)
{
    int argc;
    char *argv[128];
    char env[MAX_PATH+2];
    char *p;

    int ArgCount, FlagCount;

    LinkedFileList Node;

    if ( !GetEnvironmentVariable( "COMPDIRCMD", env, MAX_PATH+2)) {
        return;
    }

    argc = 1;
    p = env;
    while ( (*p != 0) && isspace(*p)) {
        p++;
    }
    while ( *p) {
        argv[argc++] = p++;
        while ( (*p != 0) && !isspace(*p)) {
            p++;
        }
        if ( *p != 0) {
            *p++ = 0;
            while ( (*p != 0) && isspace(*p)) {
                p++;
            }
        }
    }

    ParseArgsSub( argc, argv);

} // ParseEnvArgs

void ParseArgs( int argc, char *argv[])
{
    int FlagCount;

    //
    // Check that number of arguments is three or more
    //
    if ( argc < 3)
    {
        fprintf( stderr, "Too few arguments\n");
        Usage();
    }

    FlagCount = ParseArgsSub( argc, argv);

    if ( ( fScript) && ( fVerbose))
    {
        fprintf( stderr, "Cannot do both script and verbose\n");
        Usage();
    }
    if ( ( fVerbose) && ( fExecute))
    {
        fprintf( stderr, "Cannot do both verbose and execute\n");
        Usage();
    }
    if ( ( fScript) && ( fExecute))
    {
        fprintf( stderr, "Cannot do both script and execute\n");
        Usage();
    }
    if ( ( fExclude) && ( fMatching))
    {
        fprintf( stderr, "Cannot do both match and exclude\n");
        Usage();
    }

    if ( ( fCreateNew) && ( !fExecute))
    {
        fprintf( stderr, "Cannot create new without execute\n");
        Usage();
    }
    if ( ( fCreateLink) && ( !fExecute))
    {
        fprintf( stderr, "Cannot do link without execute flag\n");
        Usage();
    }
    if ( ( fForce) && ( !fExecute))
    {
        fprintf( stderr, "Cannot do force without execute flag\n");
        Usage();
    }
    if ( ( fIgnoreRs) && ( !fCheckBits))
    {
        fprintf( stderr, "Cannot ignore rebase info w/o b flag\n");
        Usage();
    }
    if ( ( fBreakLinks) && ( !fExecute))
    {
        fprintf( stderr, "Cannot break links without execute flag\n");
        Usage();
    }
    if ( ( argc - FlagCount) <  3)
    {
        fprintf( stderr, "Too few arguments\n");
        Usage();
    }

    fChecking = fCheckAttribs | fCheckBits | fCheckSize | fCheckTime;

} // ParseArgs

void PrintFile( LinkedFileList File, char *Path, char *DiffPath)
{
    SYSTEMTIME SysTime;
    FILETIME LocalTime;

    if ( File != NULL)
    {
        if ( fVerbose)
        {
            FileTimeToLocalFileTime( &( *File).Time, &LocalTime);
            FileTimeToSystemTime( &LocalTime, &SysTime);

            fprintf ( stdout, "%-4s % 9ld  %2d-%02d-%d  %2d:%02d.%02d.%03d%c %s\n",
                      ( *File).Flag,
                      ( *File).SizeLow,
                      SysTime.wMonth, SysTime.wDay, SysTime.wYear,
                      ( SysTime.wHour > 12 ? ( SysTime.wHour)-12 : SysTime.wHour ),
                      SysTime.wMinute,
                      SysTime.wSecond,
                      SysTime.wMilliseconds,
                      ( SysTime.wHour >= 12 ? 'p' : 'a' ),
                      Path);
        } else
        {
            fprintf( stdout, "%-4s %s\n", ( *File).Flag, Path);
        }

        PrintFile( ( *File).DiffNode, DiffPath, NULL);
    }

} // PrintFile

void ProcessAdd( LinkedFileList List, char *String1, char *String2)
{
    PCOPY_REQUEST CopyRequest;
    LPSTR NewString1, NewString2;

    if ( fMultiThread)
    {
        NewString1 = _strdup( String1);
        NewString2 = _strdup( String2);
    }

    if ( fScript)
    {
        if ( ( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if ( !fOpposite)
            {
                fprintf( stdout, "echo d | xcopy /cehikr \"%s\" \"%s\"\n", String1, String2);
            }

        } else
        {
            fprintf( stdout, "echo f | xcopy /chikr \"%s\" \"%s\"\n", String1, String2);
        }
    }
    else if ( fExecute)
    {
        if ( List->Attributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if ( ( !fDoNotRecurse) && ( !fOpposite))
            {
                if ( !SparseTree)
                {
                    fprintf( stdout, "Making %s\t", String2);

                    if ( !MyCreatePath( String2, TRUE))
                    {
                        fprintf( stderr, "Unable to create path %s\n", String2);
                        fprintf( stdout, "\n");
                        ExitValue = 1;

                    } else
                    {
                        fprintf( stdout, "[OK]\n");
                        CompDir( String1, String2);
                    }

                } else
                {
                    CompDir( String1, String2);
                }
            }

        } else
        {
            if ( fMultiThread)
            {

                CopyRequest = LocalAlloc( LMEM_ZEROINIT, sizeof( *CopyRequest ));
                if ( CopyRequest == NULL)
                {
                    OutOfMem ();
                }

                CopyRequest->WorkItem.Reason = WORK_ITEM;
                CopyRequest->Destination     = NewString2;
                CopyRequest->FullPathSrc     = NewString1;
                CopyRequest->Attributes      = List->Attributes;
                CopyRequest->SizeLow         = List->SizeLow;
                QueueWorkItem( CDWorkQueue, &CopyRequest->WorkItem );
            } else
            {
                CopyNode( String2, List, String1);
            }
        }

    } else
    {
        if ( ( !fOpposite) || ( !( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY)))
        {
            PrintFile( List, String1, NULL);
        }
    }

} // ProcessAdd

void ProcessDel( LinkedFileList List, char *String)
{
    if ( fScript)
    {
        ( ( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY)) ?
        fprintf( stdout, "echo y | rd /s %s\n", String) :
        fprintf( stdout, "del /f %s\n", String);

    } else if ( fExecute)
    {
        fprintf( stdout, "Removing %s\t", String);

        if ( !DelNode( String))
        {
            fprintf( stderr, "Unable to remove %s\n", String);
            fprintf( stdout, "\n");
            ExitValue = 1;

        } else
        {
            fprintf( stdout, "[OK]\n");
        }

    } else
    {
        PrintFile( List, String, NULL);
    }

} // ProcessDel

void ProcessDiff( LinkedFileList List, char *String1, char *String2)
{
    PCOPY_REQUEST CopyRequest;
    LPSTR NewString1, NewString2;

    if ( fMultiThread)
    {
        NewString1 = _strdup( String1);
        NewString2 = _strdup( String2);
    }

    if ( strchr ( (*List).Flag, '@'))
    {
        if ( fScript)
        {
            if ( ( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                fprintf( stdout, "echo y | rd /s %s\n", String2);

            } else
            {
                fprintf( stdout, "del /f %s\n", String2);
            }
        }
        if ( fExecute)
        {
            fprintf( stdout, "Removing %s\t", String2);
            if ( !DelNode( String2))
            {
                fprintf( stderr, "Unable to remove %s\n", String2);
                fprintf( stdout, "\n");
                ExitValue = 1;

            } else
            {
                fprintf( stdout, "[OK]\n");
            }
        }
    }
    if ( fScript)
    {
        ( ( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY)) ?
        fprintf( stdout, "echo d | xcopy /cehikr \"%s\" \"%s\"\n", String1, String2) :
        fprintf( stdout, "echo f | xcopy /chikr \"%s\" \"%s\"\n", String1, String2);

    } else if ( fExecute)
    {

        if ( List->Attributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            CompDir( String1, String2);

        } else
        {
            if ( fMultiThread)
            {

                CopyRequest = LocalAlloc( LMEM_ZEROINIT, sizeof( *CopyRequest ) );
                if ( CopyRequest == NULL)
                {
                    OutOfMem ();
                }

                CopyRequest->WorkItem.Reason = WORK_ITEM;
                CopyRequest->Destination     = NewString2;
                CopyRequest->FullPathSrc     = NewString1;
                CopyRequest->Attributes      = List->Attributes;
                CopyRequest->SizeLow         = List->SizeLow;

                QueueWorkItem( CDWorkQueue, &CopyRequest->WorkItem );
            } else
            {
                CopyNode( String2, List, String1);
            }
        }

    } else
    {
        PrintFile( List, String1, String2);
    }

} // ProcessDiff

void ProcessLists( LinkedFileList AddList, LinkedFileList DelList, LinkedFileList DifList,
                  char *Path1, char *Path2                                               )
{
    LinkedFileList PlaceKeeper;
    char          *String1 = NULL;
    char          *String2 = NULL;
    char          *PathWithSlash1, *PathWithSlash2;

    ( Path1[strlen( Path1) - 1] == '\\') ? ( PathWithSlash1 = MYSTRCAT( Path1, "")) :
        ( PathWithSlash1 = MYSTRCAT( Path1, "\\"));

    ( Path2[strlen( Path2) - 1] == '\\') ? ( PathWithSlash2 = MYSTRCAT( Path2, "")) :
        ( PathWithSlash2 = MYSTRCAT( Path2, "\\"));

    String1 = LocalAlloc( LMEM_ZEROINIT, MAX_PATH);

    String2 = LocalAlloc( LMEM_ZEROINIT, MAX_PATH);

    if ( String1 == NULL)
    {
        OutOfMem();
    }

    if ( String2 == NULL)
    {
        OutOfMem();
    }

    if ( !fOnlyIfExists)
    {
        if ( AddList != NULL)
        {
            PlaceKeeper = ( *AddList).First;

        } else
        {
            PlaceKeeper = NULL;
        }

        while ( PlaceKeeper != NULL)
        {
            if ( ( *PlaceKeeper).Process)
            {
                if ( ExitValue == 0)
                {
                    if ( !fExecute)
                    {
                        ExitValue = 1;
                    }
                }

                _strrev( ( *PlaceKeeper).Name);

                strcat( strcpy( String1, PathWithSlash1), ( *PlaceKeeper).Name);

                strcat( strcpy( String2, PathWithSlash2), ( *PlaceKeeper).Name);

                if ( DealingWithDirectories)
                {
                   ProcessAdd( PlaceKeeper, String1, String2);

                } else
                {

                   ProcessAdd( PlaceKeeper, Path1, Path2);
                }
            }

            PlaceKeeper = ( *PlaceKeeper).Next;
        }
    }

    if ( ( !fDoNotDelete) && ( !fOnlyIfExists))
    {
        if ( DelList != NULL)
        {
            PlaceKeeper = ( *DelList).First;

        } else
        {
            PlaceKeeper = NULL;
        }

        while ( PlaceKeeper != NULL)
        {
            if ( ( *PlaceKeeper).Process)
            {
                if ( ExitValue == 0)
                {
                    if ( !fExecute)
                    {
                        ExitValue = 1;
                    }
                }

                _strrev( ( *PlaceKeeper).Name);

                strcat( strcpy( String2, PathWithSlash2), ( *PlaceKeeper).Name);

                ProcessDel( PlaceKeeper, String2);
            }

            PlaceKeeper = ( *PlaceKeeper).Next;
        }
    }

    if ( DifList != NULL)
    {
        PlaceKeeper = ( *DifList).First;

    } else
    {
        PlaceKeeper = NULL;
    }

    while ( PlaceKeeper != NULL)
    {

        if ( ( *PlaceKeeper).Process)
        {
            if ( ExitValue == 0)
            {
                if ( !fExecute)
                {
                    ExitValue = 1;
                }
            }

            _strrev( ( *PlaceKeeper).Name);

            strcat( strcpy( String1, PathWithSlash1), ( *PlaceKeeper).Name);

            strcat( strcpy( String2, PathWithSlash2), ( *PlaceKeeper).Name);

            if ( DealingWithDirectories)
            {
                ProcessDiff( PlaceKeeper, String1, String2);

            } else
            {
                ProcessDiff( PlaceKeeper, Path1, Path2);
            }
        }

        PlaceKeeper = ( *PlaceKeeper).Next;
    }

    LocalFree( String1);
    LocalFree( String2);

    FREE( PathWithSlash1);
    FREE( PathWithSlash2);

} // ProcessLists

void Usage( void)
{
    fputs( "Usage: compdir [/abcdefghiklnoprstuvwz$] [/m {wildcard specs}] [/x {wildcard specs}] Path1 Path2 \n"
           "    /a     checks for attribute difference       \n"
           "    /b     checks for binary difference          \n"
           "    /c     prints out script to make             \n"
           "           directory2 look like directory1       \n"
           "    /d     do not perform or denote deletions    \n"
           "    /e     execution of tree duplication         \n"
           "    /f     only update files that already exist  \n"
           "    /g     ignore slm files, i.e slm.ini, slm.dif\n"
           "    /h     don't copy attributes                 \n"
           "    /i     ignore rebase and resource differences\n"
           "    /k     break links if copying files (NT only)\n"
           "    /l     use links instead of copies  (NT only)\n"
           "    /m[:f] marks start of match list. f is a     \n"
           "           match file                            \n"
           "    /n     create second path if it doesn't exist\n"
           "    /o     print files that are the same         \n"
           "    /p{A}  only compare files with attribute A   \n"
           "           where A is any combination of ahsr & -\n"
           "    /r     do not recurse into subdirectories    \n"
           "    /s     checks for size difference            \n"
           "    /t[:#] checks for time-date difference;      \n"
           "           takes margin-of-error parameter       \n"
           "           in number of seconds.                 \n"
           "    /u     uses multiple threads (Win32 only)    \n"
           "    /v     prints verbose output                 \n"
           "    /w     preserves case - not just lower case  \n"
           "    /x[:f] marks start of exclude list. f is an  \n"
           "           exclude file                          \n"
           "    /z     forces copy or link without checking  \n"
           "           criteria                              \n"
           "    /$     create SIS links if possible          \n"
           "    /?     prints this message                   \n",
           stderr);
    exit(1);

} // Usage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\compdir\multithd.c ===
#include "compdir.h"

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead) )

#define IsListEmpty(ListHead) (\
    ( ((ListHead)->Flink == (ListHead)) ? TRUE : FALSE ) )

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {\
        PLIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Flink;\
        FirstEntry->Flink->Blink = (ListHead);\
        (ListHead)->Flink = FirstEntry->Flink;\
    }

#define InsertTailList(ListHead,Entry) \
    (Entry)->Flink = (ListHead);\
    (Entry)->Blink = (ListHead)->Blink;\
    (ListHead)->Blink->Flink = (Entry);\
    (ListHead)->Blink = (Entry)

#define ARGUMENT_PRESENT( ArgumentPointer )    (\
    (LPSTR)(ArgumentPointer) != (LPSTR)(NULL) )

#define ROUND_UP( Size, Amount ) (((Size) + ((Amount) - 1)) & ~((Amount) - 1))

VOID
ProcessRequest(
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This function is called whenever a work item is removed from
    the work queue by one of the worker threads.  Which worker
    thread context this function is called in is arbitrary.

    This functions keeps a pointer to state information in
    thread local storage.

    This function is called once at the beginning with a
    special initialization call.  During this call, this
    function allocates space for state information and
    remembers the pointer to the state information in
    a Thread Local Storage (TLS) slot.

    This function is called once at the end with a special
    termination call.  During this call, this function
    frees the state information allocated during the
    initialization call.

    In between these two calls are zero or more calls to
    handle a work item.  The work item is a copy request
    which is handled by the ProcessCopyFile function.

Arguments:

    WorkItem - Supplies a pointer to the work item just removed
        from the work queue.  It is the responsibility of this
        routine to free the memory used to hold the work item.

Return Value:

    None.

--*/

{
    DWORD BytesWritten;
    PCOPY_REQUEST_STATE State;
    PCOPY_REQUEST CopyRequest;
    CHAR MessageBuffer[ 2 * MAX_PATH ];

    if (WorkItem->Reason == WORK_INITIALIZE_ITEM) {
        //
        // First time initialization call.  Allocate space for
        // state information.
        //

        State = LocalAlloc( LMEM_ZEROINIT,
                            sizeof( *State )
                          );

        if (State != NULL) {
            //
            // Now create a virtual buffer, with an initial commitment
            // of zero and a maximum commitment of 128KB.  This buffer
            // will be used to accumulate the output during the copy
            // operation.  This is so the output can be written to
            // standard output with a single write call, thus insuring
            // that it remains contiguous in the output stream, and is
            // not intermingled with the output of the other worker threads.
            //

            if (CreateVirtualBuffer( &State->Buffer, 1, 2 * 64 * 1024 )) {
                //
                // The CurrentOutput field of the state block is
                // a pointer to where the next output goes in the
                // buffer.  It is initialized here and reset each
                // time the buffer is flushed to standard output.
                //

                State->CurrentOutput = State->Buffer.Base;
                }
            else {
                LocalFree( State );
                State = NULL;
                }
            }

        //
        // Remember the pointer to the state informaiton
        // thread local storage.
        //

        TlsSetValue( TlsIndex, State );
        return;
        }

    //
    // Here to handle a work item or special terminate call.
    // Get the state pointer from thread local storage.
    //

    State = (PCOPY_REQUEST_STATE)TlsGetValue( TlsIndex );
    if (State == NULL) {
        return;
        }

    //
    // If this is the special terminate work item, free the virtual
    // buffer and state block allocated above and set the thread
    // local storage value to NULL.  Return to caller.
    //

    if (WorkItem->Reason == WORK_TERMINATE_ITEM) {
        FreeVirtualBuffer( &State->Buffer );
        LocalFree( State );
        TlsSetValue( TlsIndex, NULL );
        return;
        }

    //
    // If not an initialize or terminate work item, then must be a
    // copy request.  Calculate the address of the copy request
    // block, based on the position of the WorkItem field in the
    // COPY_REQUEST structure.
    //

    CopyRequest = CONTAINING_RECORD( WorkItem, COPY_REQUEST, WorkItem );

    //
    // Actual copy operation is protected by a try ... except
    // block so that any attempts to store into the virtual buffer
    // will be handled correctly by extending the virtual buffer.
    //

    _try {
        //
        // Perform the copy
        //
        ProcessCopyFile( CopyRequest, State );

        //
        // If any output was written to the virtual buffer,
        // flush the output to standard output.  Trim the
        // virtual buffer back to zero committed pages.
        //

        if (State->CurrentOutput > (LPSTR)State->Buffer.Base) {
            WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ),
                       State->Buffer.Base,
                       (DWORD)(State->CurrentOutput - (LPSTR)State->Buffer.Base),
                       &BytesWritten,
                       NULL
                     );

            TrimVirtualBuffer( &State->Buffer );
            State->CurrentOutput = (LPSTR)State->Buffer.Base;
            }
        }

    _except( VirtualBufferExceptionFilter( GetExceptionCode(),
                                          GetExceptionInformation(),
                                          &State->Buffer
                                        )
          ) {

        //
        // We will get here if the exception filter was unable to
        // commit the memory.
        //

        WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ),
                   MessageBuffer,
                   sprintf( MessageBuffer, "can't commit memory\n" ),
                   &BytesWritten,
                   NULL
                 );
        }

    //
    // Free the storage used by the CopyRequest
    //

    LocalFree( CopyRequest );

    //
    // All done with this request.  Return to the worker thread that
    // called us.
    //

    return;
}

VOID
ProcessCopyFile(
    IN PCOPY_REQUEST CopyRequest,
    IN PCOPY_REQUEST_STATE State
    )

/*++

Routine Description:

    This function performs the actual copy of the contents of the
    passed file for the copy string given on the command line.
    If we are using synchronous I/O, then do the read operation
    now.

    Copy the contents of the file for any matches, and accumulate
    the match output in the virtual buffer using sprintf, which is
    multi-thread safe, even with the single threaded version of
    the libraries.

Arguments:

    CopyRequest - Supplies a pointer to the copy request which
        contains the relevant information.

    State - Supplies a pointer to state information for the current
        thread.

Return Value:

    None.

--*/

{
    LPSTR FullPathSrc, Destination;
    BOOL pend, CanDetectFreeSpace = TRUE;
    int i;
    DWORD sizeround;
    DWORD BytesPerCluster;
    ATTRIBUTE_TYPE Attributes;

    int LastErrorGot;
    __int64 freespac;
    char root[5] = {'a',':','\\','\0'};
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;

    Destination = CopyRequest->Destination;
    FullPathSrc = CopyRequest->FullPathSrc;

    root[0] = *Destination;

    if( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        CanDetectFreeSpace = FALSE;
    }
    else {
        freespac = ( (__int64)cBytesPerSec * (__int64)cSecsPerClus * (__int64)cFreeClus );
        BytesPerCluster = cSecsPerClus * cBytesPerSec;
    }

    if (!fDontLowerCase) {
        _strlwr(FullPathSrc);
        _strlwr(Destination);
    }

    State->CurrentOutput += sprintf( State->CurrentOutput, "%s => %s\t", FullPathSrc, Destination);

    if (CanDetectFreeSpace) {

        sizeround =  CopyRequest->SizeLow;
        sizeround += BytesPerCluster - 1;
        sizeround /= BytesPerCluster;
        sizeround *= BytesPerCluster;

        if (freespac < sizeround) {
            State->CurrentOutput += sprintf( State->CurrentOutput, "not enough space\n");
            return;
        }
    }

    GET_ATTRIBUTES(Destination, Attributes);
    i = SET_ATTRIBUTES(Destination, Attributes & NONREADONLYSYSTEMHIDDEN );

    i = 1;

    do {

        if (!fCreateLink) {
            if (!fBreakLinks) {
                pend = MyCopyFile (FullPathSrc, Destination, FALSE);
            }
            else {
                _unlink(Destination);
                pend = MyCopyFile (FullPathSrc, Destination, FALSE);
            }
        }
        else {
            if (i == 1) {
                pend = MakeLink (FullPathSrc, Destination, FALSE);
            }
            else {
                pend = MakeLink (FullPathSrc, Destination, TRUE);
            }
        }

        if (SparseTree && !pend) {

            EnterCriticalSection( &CreatePathCriticalSection );

            if (!MyCreatePath(Destination, FALSE)) {
                State->CurrentOutput += sprintf( State->CurrentOutput, "Unable to create path %s", Destination);
                ExitValue = 1;
            }

            LeaveCriticalSection( &CreatePathCriticalSection );
        }

    } while ((i++ < 2) && (!pend) );

    if (!pend) {

        LastErrorGot = GetLastError ();

        if ((fCreateLink) && (LastErrorGot == 1)) {
            State->CurrentOutput += sprintf( State->CurrentOutput, "Can only make links on NTFS and OFS");
        }
        else if (fCreateLink) {
            State->CurrentOutput += sprintf( State->CurrentOutput, "(error = %d)", LastErrorGot);
        }
        else {
            State->CurrentOutput += sprintf( State->CurrentOutput, "Copy Error (error = %d)", LastErrorGot);
        }

        ExitValue = 1;
    }

    State->CurrentOutput += sprintf( State->CurrentOutput, "%s\n", pend == TRUE ? "[OK]" : "");

    //GET_ATTRIBUTES( FullPathSrc, Attributes);
    if ( !fDontCopyAttribs)
    {
        i = SET_ATTRIBUTES( Destination, CopyRequest->Attributes);
    }
    else
    {
        i = SET_ATTRIBUTES( Destination, FILE_ATTRIBUTE_ARCHIVE);
    }

    free (CopyRequest->Destination);
    free (CopyRequest->FullPathSrc);
}

PWORK_QUEUE
CreateWorkQueue(
    IN DWORD NumberOfWorkerThreads,
    IN PWORKER_ROUTINE WorkerRoutine
    )

/*++

Routine Description:

    This function creates a work queue, with the specified number of
    threads to service work items placed in the queue.  Work items
    are removed from the queue in the same order that they are placed
    in the queue.

Arguments:

    NumberOfWorkerThreads - Specifies how many threads this function
        should create to process work items placed in the queue.
        Must be greater than 0 and less than 128.

    WorkerRoutine - Specifies the address of a routine to call
        for each work item as it is removed from the queue.  The
        thread context the routine is called in is undefined.

Return Value:

    A pointer to the work queue.  Returns NULL if unable to create
    the work queue and its worker threads.  Extended error information
    is available from GetLastError()

--*/

{
    PWORK_QUEUE WorkQueue;
    HANDLE Thread;
    DWORD ThreadId;
    DWORD i;

    //
    // Allocate space for the work queue, which includes an
    // array of thread handles.
    //

    WorkQueue = LocalAlloc( LMEM_ZEROINIT,
                            sizeof( *WorkQueue ) +
                                (NumberOfWorkerThreads * sizeof( HANDLE ))
                          );
    if (WorkQueue == NULL) {
        return NULL;
        }

    //
    // The work queue is controlled by a counting semaphore that
    // is incremented each time a work item is placed in the queue
    // and decremented each time a worker thread wakes up to remove
    // an item from the queue.
    //

    if (WorkQueue->Semaphore = CreateSemaphore( NULL, 0, 100000, NULL )) {
        //
        // Mutual exclusion between the worker threads accessing
        // the work queue is done with a critical section.
        //

        InitializeCriticalSection( &WorkQueue->CriticalSection );

        //
        // The queue itself is just a doubly linked list, where
        // items are placed in the queue at the tail of the list
        // and removed from the queue from the head of the list.
        //

        InitializeListHead( &WorkQueue->Queue );

        //
        // Removed the address of the supplied worker function
        // in the work queue structure.
        //

        WorkQueue->WorkerRoutine = WorkerRoutine;

        //
        // Now create the requested number of worker threads.
        // The handle to each thread is remembered in an
        // array of thread handles in the work queue structure.
        //

        for (i=0; i<NumberOfWorkerThreads; i++) {
            Thread = CreateThread( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) WorkerThread,
                                   WorkQueue,
                                   0,
                                   &ThreadId
                                 );
            if (Thread == NULL) {
                break;
                }
            else {
                WorkQueue->NumberOfWorkerThreads++;
                WorkQueue->WorkerThreads[ i ] = Thread;
                SetThreadPriority( Thread, THREAD_PRIORITY_ABOVE_NORMAL );
                }
            }

        //
        // If we successfully created all of the worker threads
        // then return the address of the work queue structure
        // to indicate success.
        //

        if (i == NumberOfWorkerThreads) {
            return WorkQueue;
            }
        }

    //
    // Failed for some reason.  Destroy whatever we managed
    // to create and return failure to the caller.
    //

    DestroyWorkQueue( WorkQueue );
    return NULL;
}

VOID
DestroyWorkQueue(
    IN OUT PWORK_QUEUE WorkQueue
    )

/*++

Routine Description:

    This function destroys a work queue created with the CreateWorkQueue
    functions.  It attempts to shut down the worker threads cleanly
    by queueing a terminate work item to each worker thread.  It then
    waits for all the worker threads to terminate.  If the wait is
    not satisfied within 30 seconds, then it goes ahead and terminates
    all of the worker threads.

Arguments:

    WorkQueue - Supplies a pointer to the work queue to destroy.

Return Value:

    None.

--*/

{
    DWORD i;
    DWORD rc;

    //
    // If the semaphore handle field is not NULL, then there
    // may be threads to terminate.
    //

    if (WorkQueue->Semaphore != NULL) {
        //
        // Set the termiating flag in the work queue and
        // signal the counting semaphore by the number
        // worker threads so they will all wake up and
        // notice the terminating flag and exit.
        //

        EnterCriticalSection( &WorkQueue->CriticalSection );
        _try {
            WorkQueue->Terminating = TRUE;
            ReleaseSemaphore( WorkQueue->Semaphore,
                              WorkQueue->NumberOfWorkerThreads,
                              NULL
                            );
            }
        _finally {
            LeaveCriticalSection( &WorkQueue->CriticalSection );
            }

        //
        // Wait for all worker threads to wake up and see the
        // terminate flag and then terminate themselves.  Timeout
        // the wait after 30 seconds.
        //

        while (TRUE) {
            rc = WaitForMultipleObjectsEx( WorkQueue->NumberOfWorkerThreads,
                                           WorkQueue->WorkerThreads,
                                           TRUE,
                                           3600000,
                                           TRUE
                                         );
            if (rc == WAIT_IO_COMPLETION) {
                //
                // If we came out of the wait because an I/O
                // completion routine was called, reissue the
                // wait.
                //
                continue;
                }
            else {
                break;
                }
            }

        //
        // Now close our thread handles so they will actually
        // evaporate.  If the wait above was unsuccessful,
        // then first attempt to force the termination of
        // each worker thread prior to closing the handle.
        //

        for (i=0; i<WorkQueue->NumberOfWorkerThreads; i++) {
            if (rc != NO_ERROR) {
                TerminateThread( WorkQueue->WorkerThreads[ i ], rc );
                }

            CloseHandle( WorkQueue->WorkerThreads[ i ] );
            }

        //
        // All threads stopped, all thread handles closed.  Now
        // delete the critical section and close the semaphore
        // handle.
        //

        DeleteCriticalSection( &WorkQueue->CriticalSection );
        CloseHandle( WorkQueue->Semaphore );
        }

    //
    // Everything done, now free the memory used by the work queue.
    //

    LocalFree( WorkQueue );
    return;
}

BOOL
QueueWorkItem(
    IN OUT PWORK_QUEUE WorkQueue,
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This function queues a work item to the passed work queue that is
    processed by one of the worker threads associated with the queue.

Arguments:

    WorkQueue - Supplies a pointer to the work queue that is to
        receive the work item.

    WorkItem - Supplies a pointer to the work item to add the the queue.
        The work item structure contains a doubly linked list entry, the
        address of a routine to call and a parameter to pass to that
        routine.  It is the routine's responsibility to reclaim the
        storage occupied by the WorkItem structure.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    BOOL Result;

    //
    // Acquire the work queue critical section and insert the work item
    // in the queue and release the semaphore if the work item is not
    // already in the list.
    //

    EnterCriticalSection( &WorkQueue->CriticalSection );
    Result = TRUE;
    _try {
        WorkItem->WorkQueue = WorkQueue;
        InsertTailList( &WorkQueue->Queue, &WorkItem->List );
        Result = ReleaseSemaphore( WorkQueue->Semaphore, 1, NULL );
        }
    _finally {
        LeaveCriticalSection( &WorkQueue->CriticalSection );
        }

    return Result;
}

DWORD
WorkerThread(
    LPVOID lpThreadParameter
    )
{
    PWORK_QUEUE WorkQueue = (PWORK_QUEUE)lpThreadParameter;
    DWORD rc;
    WORK_QUEUE_ITEM InitWorkItem;
    PWORK_QUEUE_ITEM WorkItem;

    //
    // Call the worker routine with an initialize work item
    // to give it a change to initialize some per thread
    // state that will passed to it for each subsequent
    // work item.
    //

    InitWorkItem.Reason = WORK_INITIALIZE_ITEM;
    (WorkQueue->WorkerRoutine)( &InitWorkItem );
    while( TRUE ) {
        _try {

            //
            // Wait until something is put in the queue (semaphore is
            // released), remove the item from the queue, mark it not
            // inserted, and execute the specified routine.
            //

            rc = WaitForSingleObjectEx( WorkQueue->Semaphore, 0xFFFFFFFF, TRUE );
            if (rc == WAIT_IO_COMPLETION) {
                continue;
                }

            EnterCriticalSection( &WorkQueue->CriticalSection );
            _try {
                if (WorkQueue->Terminating && IsListEmpty( &WorkQueue->Queue )) {
                    break;
                    }

                WorkItem = (PWORK_QUEUE_ITEM)RemoveHeadList( &WorkQueue->Queue );
                }
            _finally {
                LeaveCriticalSection( &WorkQueue->CriticalSection );
                }

            //
            // Execute the worker routine for this work item.
            //

            (WorkQueue->WorkerRoutine)( WorkItem );
            }
        _except( EXCEPTION_EXECUTE_HANDLER ) {
            //
            // Ignore any exceptions from worker routine.
            //
            }
        }

    InitWorkItem.Reason = WORK_TERMINATE_ITEM;
    (WorkQueue->WorkerRoutine)( &InitWorkItem );

    ExitThread( 0 );
    return 0;       // This will exit this thread
}

BOOL
CreateVirtualBuffer(
    OUT PVIRTUAL_BUFFER Buffer,
    IN SIZE_T CommitSize,
    IN SIZE_T ReserveSize OPTIONAL
    )

/*++

Routine Description:

    This function is called to create a virtual buffer.  A virtual
    buffer is a contiguous range of virtual memory, where some initial
    prefix portion of the memory is committed and the remainder is only
    reserved virtual address space.  A routine is provided to extend the
    size of the committed region incrementally or to trim the size of
    the committed region back to some specified amount.

Arguments:

    Buffer - Pointer to the virtual buffer control structure that is
        filled in by this function.

    CommitSize - Size of the initial committed portion of the buffer.
        May be zero.

    ReserveSize - Amount of virtual address space to reserve for the
        buffer.  May be zero, in which case amount reserved is the
        committed size plus one, rounded up to the next 64KB boundary.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    SYSTEM_INFO SystemInformation;

    //
    // Query the page size from the system for rounding
    // our memory allocations.
    //

    GetSystemInfo( &SystemInformation );
    Buffer->PageSize = SystemInformation.dwPageSize;

    //
    // If the reserve size was not specified, default it by
    // rounding up the initial committed size to a 64KB
    // boundary.  This is because the Win32 Virtual Memory
    // API calls always allocate virtual address space on
    // 64KB boundaries, so we might well have it available
    // for commitment.
    //

    if (!ARGUMENT_PRESENT( ReserveSize )) {
        ReserveSize = ROUND_UP( CommitSize + 1, 0x10000 );
        }

    //
    // Attempt to reserve the address space.
    //

    Buffer->Base = VirtualAlloc( NULL,
                                 ReserveSize,
                                 MEM_RESERVE,
                                 PAGE_READWRITE
                               );
    if (Buffer->Base == NULL) {
        //
        // Unable to reserve address space, return failure.
        //

        return FALSE;
        }

    //
    // Attempt to commit some initial portion of the reserved region.
    //
    //

    CommitSize = ROUND_UP( CommitSize, Buffer->PageSize );
    if (CommitSize == 0 ||
        VirtualAlloc( Buffer->Base,
                      CommitSize,
                      MEM_COMMIT,
                      PAGE_READWRITE
                    ) != NULL
       ) {
        //
        // Either the size of the committed region was zero or the
        // commitment succeeded.  In either case calculate the
        // address of the first byte after the committed region
        // and the address of the first byte after the reserved
        // region and return successs.
        //

        Buffer->CommitLimit = (LPVOID)
            ((char *)Buffer->Base + CommitSize);

        Buffer->ReserveLimit = (LPVOID)
            ((char *)Buffer->Base + ReserveSize);

        return TRUE;
        }

    //
    // If unable to commit the memory, release the virtual address
    // range allocated above and return failure.
    //

    VirtualFree( Buffer->Base, 0, MEM_RELEASE );
    return FALSE;
}



BOOL
ExtendVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer,
    IN LPVOID Address
    )

/*++

Routine Description:

    This function is called to extend the committed portion of a virtual
    buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

    Address - Byte at this address is committed, along with all memory
        from the beginning of the buffer to this address.  If the
        address is already within the committed portion of the virtual
        buffer, then this routine does nothing.  If outside the reserved
        portion of the virtual buffer, then this routine returns an
        error.

        Otherwise enough pages are committed so that the memory from the
        base of the buffer to the passed address is a contiguous region
        of committed memory.


Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    SIZE_T NewCommitSize;
    LPVOID NewCommitLimit;

    //
    // See if address is within the buffer.
    //

    if (Address >= Buffer->Base && Address < Buffer->ReserveLimit) {
        //
        // See if the address is within the committed portion of
        // the buffer.  If so return success immediately.
        //

        if (Address < Buffer->CommitLimit) {
            return TRUE;
            }

        //
        // Address is within the reserved portion.  Determine how many
        // bytes are between the address and the end of the committed
        // portion of the buffer.  Round this size to a multiple of
        // the page size and this is the amount we will attempt to
        // commit.
        //

        NewCommitSize =
            (ROUND_UP( (DWORD_PTR)Address + 1, Buffer->PageSize ) -
             (DWORD_PTR)Buffer->CommitLimit
            );

        //
        // Attempt to commit the memory.
        //

        NewCommitLimit = VirtualAlloc( Buffer->CommitLimit,
                                       NewCommitSize,
                                       MEM_COMMIT,
                                       PAGE_READWRITE
                                     );
        if (NewCommitLimit != NULL) {
            //
            // Successful, so update the upper limit of the committed
            // region of the buffer and return success.
            //

            Buffer->CommitLimit = (LPVOID)
                ((DWORD_PTR)NewCommitLimit + NewCommitSize);

            return TRUE;
            }
        }

    //
    // Address is outside of the buffer, return failure.
    //

    return FALSE;
}


BOOL
TrimVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    )

/*++

Routine Description:

    This function is called to decommit any memory that has been
    committed for this virtual buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    Buffer->CommitLimit = Buffer->Base;
    if (!VirtualFree( Buffer->Base, 0, MEM_DECOMMIT ))
        return FALSE;
    else
        return ExtendVirtualBuffer(Buffer, (PCHAR)(Buffer->CommitLimit)+1);
}



BOOL
FreeVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    )
/*++

Routine Description:

    This function is called to free all the memory that is associated
    with this virtual buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    //
    // Decommit and release all virtual memory associated with
    // this virtual buffer.
    //

    return VirtualFree( Buffer->Base, 0, MEM_RELEASE );
}



int
VirtualBufferExceptionFilter(
    IN DWORD ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionInfo,
    IN OUT PVIRTUAL_BUFFER Buffer
    )

/*++

Routine Description:

    This function is an exception filter that handles exceptions that
    referenced uncommitted but reserved memory contained in the passed
    virtual buffer.  It this filter routine is able to commit the
    additional pages needed to allow the memory reference to succeed,
    then it will re-execute the faulting instruction.  If it is unable
    to commit the pages, it will execute the callers exception handler.

    If the exception is not an access violation or is an access
    violation but does not reference memory contained in the reserved
    portion of the virtual buffer, then this filter passes the exception
    on up the exception chain.

Arguments:

    ExceptionCode - Reason for the exception.

    ExceptionInfo - Information about the exception and the context
        that it occurred in.

    Buffer - Points to a virtual buffer control structure that defines
        the reserved memory region that is to be committed whenever an
        attempt is made to access it.

Return Value:

    Exception disposition code that tells the exception dispatcher what
    to do with this exception.  One of three values is returned:

        EXCEPTION_EXECUTE_HANDLER - execute the exception handler
            associated with the exception clause that called this filter
            procedure.

        EXCEPTION_CONTINUE_SEARCH - Continue searching for an exception
            handler to handle this exception.

        EXCEPTION_CONTINUE_EXECUTION - Dismiss this exception and return
            control to the instruction that caused the exception.


--*/

{
    LPVOID FaultingAddress;

    //
    // If this is an access violation touching memory within
    // our reserved buffer, but outside of the committed portion
    // of the buffer, then we are going to take this exception.
    //

    if (ExceptionCode == STATUS_ACCESS_VIOLATION) {
        //
        // Get the virtual address that caused the access violation
        // from the exception record.  Determine if the address
        // references memory within the reserved but uncommitted
        // portion of the virtual buffer.
        //

        FaultingAddress = (LPVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];
        if (FaultingAddress >= Buffer->CommitLimit &&
            FaultingAddress <= Buffer->ReserveLimit
           ) {
            //
            // This is our exception.  Try to extend the buffer
            // to including the faulting address.
            //

            if (ExtendVirtualBuffer( Buffer, FaultingAddress )) {
                //
                // Buffer successfully extended, so re-execute the
                // faulting instruction.
                //

                return EXCEPTION_CONTINUE_EXECUTION;
                }
            else {
                //
                // Unable to extend the buffer.  Stop copying
                // for exception handlers and execute the caller's
                // handler.
                //

                return EXCEPTION_EXECUTE_HANDLER;
                }
            }
        }

    //
    // Not an exception we care about, so pass it up the chain.
    //

    return EXCEPTION_CONTINUE_SEARCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\compdir\link.c ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>

#include "compdir.h"

#define SHARE_ALL   (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
#define lstrchr wcschr

typedef VOID     (*RtlFreeUnicodeStringFunction)();
typedef ULONG    (*RtlNtStatusToDosErrorFunction)();
typedef NTSTATUS (*NtCloseFunction)();
typedef NTSTATUS (*NtSetInformationFileFunction)();
typedef VOID     (*RtlInitUnicodeStringFunction)();
typedef NTSTATUS (*NtOpenFileFunction)();
typedef BOOLEAN  (*RtlCreateUnicodeStringFromAsciizFunction)();
typedef NTSTATUS (*NtQueryInformationFileFunction)();
typedef NTSTATUS (*NtFsControlFileFunction)();
typedef NTSTATUS (*RtlDosPathNameToNtPathName_UFunction)();

RtlFreeUnicodeStringFunction             CDRtlFreeUnicodeString;
RtlNtStatusToDosErrorFunction            CDRtlNtStatusToDosError;
NtCloseFunction                          CDNtClose;
NtSetInformationFileFunction             CDNtSetInformationFile;
RtlInitUnicodeStringFunction             CDRtlInitUnicodeString;
NtOpenFileFunction                       CDNtOpenFile;
RtlCreateUnicodeStringFromAsciizFunction CDRtlCreateUnicodeStringFromAsciiz;
NtQueryInformationFileFunction           CDNtQueryInformationFile;
NtFsControlFileFunction                  CDNtFsControlFile;
RtlDosPathNameToNtPathName_UFunction     CDRtlDosPathNameToNtPathName_U;


BOOL InitializeNtDllFunctions()
{
    CDRtlFreeUnicodeString                 = (RtlFreeUnicodeStringFunction)             GetProcAddress( NtDll, "RtlFreeUnicodeString");
    if         (CDRtlFreeUnicodeString     == NULL) return FALSE;
    CDRtlNtStatusToDosError                = (RtlNtStatusToDosErrorFunction)            GetProcAddress( NtDll, "RtlNtStatusToDosError");
    if        (CDRtlNtStatusToDosError     == NULL) return FALSE;
    CDNtClose                              = (NtCloseFunction)                          GetProcAddress( NtDll, "NtClose");
    if                      (CDNtClose     == NULL) return FALSE;
    CDNtSetInformationFile                 = (NtSetInformationFileFunction)             GetProcAddress( NtDll, "NtSetInformationFile");
    if         (CDNtSetInformationFile     == NULL) return FALSE;
    CDRtlInitUnicodeString                 = (RtlInitUnicodeStringFunction)             GetProcAddress( NtDll, "RtlInitUnicodeString");
    if         (CDRtlInitUnicodeString     == NULL) return FALSE;
    CDNtOpenFile                           = (NtOpenFileFunction)                       GetProcAddress( NtDll, "NtOpenFile");
    if                   (CDNtOpenFile     == NULL) return FALSE;
    CDRtlCreateUnicodeStringFromAsciiz     = (RtlCreateUnicodeStringFromAsciizFunction) GetProcAddress( NtDll, "RtlCreateUnicodeStringFromAsciiz");
    if (CDRtlCreateUnicodeStringFromAsciiz == NULL) return FALSE;
    CDNtQueryInformationFile               = (NtQueryInformationFileFunction)           GetProcAddress( NtDll, "NtQueryInformationFile");
    if           (CDNtQueryInformationFile == NULL) return FALSE;
    CDNtFsControlFile = (NtFsControlFileFunction)GetProcAddress( NtDll, "NtFsControlFile");
    if (CDNtFsControlFile == NULL) return FALSE;
    CDRtlDosPathNameToNtPathName_U = (RtlDosPathNameToNtPathName_UFunction)GetProcAddress( NtDll, "RtlDosPathNameToNtPathName_U");
    if (CDRtlDosPathNameToNtPathName_U == NULL) return FALSE;
    return TRUE;
}

BOOL MakeLink( char *src, char *dst, BOOL Output)
{
    WCHAR                  OldNameBuf[MAX_PATH + 50];
    WCHAR                  NewNameBuf[MAX_PATH + 50];

    HANDLE                 FileHandle,
                           NewFileHandle,
                           RootDirHandle;

    NTSTATUS               Status;
    IO_STATUS_BLOCK        Iosb;
    OBJECT_ATTRIBUTES      Obj;

    PFILE_LINK_INFORMATION pLinkInfo;

    UNICODE_STRING         u,
                           uRel;

    WCHAR                  *pch, ch;
    UNICODE_STRING         uOldName;
    UNICODE_STRING         uNewName;

    UNICODE_STRING         uSrc, uDst;

    (CDRtlCreateUnicodeStringFromAsciiz)( &uSrc, src);
    (CDRtlCreateUnicodeStringFromAsciiz)( &uDst, dst);

    lstrcpy( OldNameBuf, L"\\??\\");
    lstrcat( OldNameBuf, uSrc.Buffer);
    (CDRtlInitUnicodeString)( &uOldName, OldNameBuf);

    lstrcpy( NewNameBuf, L"\\??\\");
    lstrcat( NewNameBuf, uDst.Buffer);
    (CDRtlInitUnicodeString)( &uNewName, NewNameBuf);

    //
    // Open the existing pathname.
    //

    InitializeObjectAttributes( &Obj, &uOldName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = (CDNtOpenFile)( &FileHandle, SYNCHRONIZE, &Obj, &Iosb,
        SHARE_ALL, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( ( CDRtlNtStatusToDosError)( Status));
        if ( Output)
        {
            fprintf( stderr, "Could not open %s", src);
        }
        return FALSE;
    }

    //
    // Now we need to get a handle on the root directory of the 'new'
    // pathname; we'll pass that in the link information, and the
    // rest of the path will be given relative to the root.  We
    // depend on paths looking like "\DosDevices\X:\path".
    //

    pch = lstrchr( uNewName.Buffer + 1, '\\');
    ASSERT( NULL != pch);
    pch = lstrchr( pch + 1, '\\');
    if (!pch) {
        SetLastError(ERROR_INVALID_PARAMETER);
        if ( Output)
        {
            fprintf( stderr, "Invalid path %S", uNewName.Buffer);
        }
        return FALSE;
    }
    ch = pch[1];
    pch[1] = '\0';
    uNewName.Length = (USHORT)(lstrlen( uNewName.Buffer) * sizeof( WCHAR));

    InitializeObjectAttributes( &Obj, &uNewName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = (CDNtOpenFile)( &RootDirHandle, SYNCHRONIZE, &Obj, &Iosb,
        SHARE_ALL, FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);

    pch[1] = ch;

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( (CDRtlNtStatusToDosError)( Status));
        if ( Output)
        {
            fprintf( stderr, "Could not get directory handle for %s", dst);
        }
        return FALSE;
    }

    //
    // Now get the path relative to the root.
    //

    (CDRtlInitUnicodeString)( &uRel, &pch[1]);

    pLinkInfo = _alloca( sizeof( *pLinkInfo) + uRel.Length);
    if ( NULL == pLinkInfo)
    {
        (CDNtClose)( RootDirHandle);
        (CDNtClose)( FileHandle);
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlMoveMemory( pLinkInfo->FileName, uRel.Buffer, uRel.Length);
    pLinkInfo->FileNameLength = uRel.Length;

    pLinkInfo->ReplaceIfExists = TRUE;
    pLinkInfo->RootDirectory = RootDirHandle;

    Status = (CDNtSetInformationFile)( FileHandle, &Iosb, pLinkInfo,
        sizeof( *pLinkInfo) + uRel.Length, FileLinkInformation);

    // If file is already linked to an open file try to delete it

    if ( Status ==  STATUS_ACCESS_DENIED)
    {
        _unlink( dst);
        Status = (CDNtSetInformationFile)( FileHandle, &Iosb, pLinkInfo,
            sizeof( *pLinkInfo) + uRel.Length, FileLinkInformation);
    }

    (CDNtClose)( RootDirHandle);
    (CDNtClose)( FileHandle);

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( (CDRtlNtStatusToDosError)( Status));
        if ( Output)
        {
            fprintf( stderr, "Could not create link for %s", dst);
        }
        return FALSE;
    }

    (CDRtlFreeUnicodeString)( &uSrc);
    (CDRtlFreeUnicodeString)( &uDst);

    return TRUE;


}

int NumberOfLinks( char *FileName)
{

    FILE_STANDARD_INFORMATION FileInfo;

    WCHAR                     FileNameBuf[MAX_PATH + 50];

    HANDLE                    FileHandle;

    NTSTATUS                  Status;

    IO_STATUS_BLOCK           Iosb;

    OBJECT_ATTRIBUTES         Obj;

    UNICODE_STRING            uPrelimFileName,
                              uFileName;

    (CDRtlCreateUnicodeStringFromAsciiz)( &uPrelimFileName, FileName);

    lstrcpy( FileNameBuf, L"\\??\\");
    lstrcat( FileNameBuf, uPrelimFileName.Buffer);
    (CDRtlInitUnicodeString)( &uFileName, FileNameBuf);

    InitializeObjectAttributes( &Obj, &uFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = (CDNtOpenFile)( &FileHandle, SYNCHRONIZE, &Obj, &Iosb,
        SHARE_ALL, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( (CDRtlNtStatusToDosError)( Status));
        return 0;
    }

    Status = (CDNtQueryInformationFile)( FileHandle, &Iosb, &FileInfo,
        sizeof( FileInfo), FileStandardInformation);

    (CDNtClose)( FileHandle);

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( (CDRtlNtStatusToDosError)( Status));
        return 0;
    }

    return FileInfo.NumberOfLinks;


}

BOOL
SisCopyFile(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists,
    LPBOOL fTrySis
    )
{
    BOOL ok;
    DWORD err;
	NTSTATUS        Status;
	HANDLE          volHandle;
	UNICODE_STRING	srcFileName, dstFileName;
	UNICODE_STRING	srcDosFileName, dstDosFileName;
	PSI_COPYFILE	copyFile;
	UCHAR			Buffer[(sizeof(SI_COPYFILE) + MAX_PATH * 2) * sizeof(WCHAR)];
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
	int i;

	copyFile = (PSI_COPYFILE)Buffer;

    srcFileName.Buffer = NULL;
    dstFileName.Buffer = NULL;
    srcDosFileName.Buffer = NULL;
    srcDosFileName.Buffer = NULL;

    //
	// Convert the ansii names to unicode and place in the copyFile buffer.
    //

    ok = CDRtlCreateUnicodeStringFromAsciiz( &srcDosFileName, lpExistingFileName );
    if (!ok) {
        return FALSE;
    }
    ok = CDRtlDosPathNameToNtPathName_U( srcDosFileName.Buffer, &srcFileName, NULL, NULL );
    if (!ok) {
        goto error;
    }
    CDRtlFreeUnicodeString( &srcDosFileName );

    ok = CDRtlCreateUnicodeStringFromAsciiz( &dstDosFileName, lpNewFileName );
    if (!ok) {
        goto error;
    }
    ok = CDRtlDosPathNameToNtPathName_U( dstDosFileName.Buffer, &dstFileName, NULL, NULL );
    if (!ok) {
        goto error;
    }
    CDRtlFreeUnicodeString( &dstDosFileName );

	copyFile->SourceFileNameLength = srcFileName.Length + sizeof(WCHAR);
	copyFile->DestinationFileNameLength = dstFileName.Length + sizeof(WCHAR);
	copyFile->Flags = bFailIfExists ? 0 : COPYFILE_SIS_REPLACE;

	RtlCopyMemory(
		&copyFile->FileNameBuffer[0],
		srcFileName.Buffer,
		copyFile->SourceFileNameLength);

	RtlCopyMemory(
		&copyFile->FileNameBuffer[copyFile->SourceFileNameLength / sizeof(WCHAR)],
		dstFileName.Buffer,
		copyFile->DestinationFileNameLength);

    CDRtlFreeUnicodeString( &dstFileName );

#define	copyFileSize (FIELD_OFFSET(SI_COPYFILE, FileNameBuffer) +		\
					  copyFile->SourceFileNameLength +					\
					  copyFile->DestinationFileNameLength)

	//
	// Get a handle to the source file's containing directory to pass into
	// FSCTL_SIS_COPYFILE,
	//

    for (i = srcFileName.Length / sizeof(WCHAR) - 1;
		 i >= 0 && srcFileName.Buffer[i] != '\\';
		 --i)
		continue;

	srcFileName.Length = (USHORT)(i * sizeof(WCHAR));

    InitializeObjectAttributes(
        &objectAttributes,
        &srcFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    //
    // Need to use NtOpenFile because Win32 doesn't let you open a directory.
    //
	Status = CDNtOpenFile(
                    &volHandle,
					GENERIC_READ | SYNCHRONIZE,
                    &objectAttributes,
                    &ioStatusBlock,
					SHARE_ALL,
					FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    CDRtlFreeUnicodeString( &srcFileName );

	if (!NT_SUCCESS(Status)) {
        SetLastError(CDRtlNtStatusToDosError(Status));
        return FALSE;
	}

    //
    //  Invoke the SIS CopyFile FsCtrl.
    //

    Status = CDNtFsControlFile(
                 volHandle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatusBlock,
                 FSCTL_SIS_COPYFILE,
                 copyFile,		        // Input buffer
                 copyFileSize,			// Input buffer length
                 NULL,                  // Output buffer
                 0 );                   // Output buffer length

    CloseHandle( volHandle );

    if (NT_SUCCESS( Status )) {
        return TRUE;
    }

    if ((Status == STATUS_INVALID_DEVICE_REQUEST) || (Status == STATUS_INVALID_PARAMETER)) {
        *fTrySis = FALSE;
    }

    SetLastError(CDRtlNtStatusToDosError(Status));
    return FALSE;

error:

    err = GetLastError();

    CDRtlFreeUnicodeString( &srcDosFileName );
    CDRtlFreeUnicodeString( &dstDosFileName );
    CDRtlFreeUnicodeString( &srcFileName );
    CDRtlFreeUnicodeString( &dstDosFileName );

    SetLastError(err);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\compdir\comtoolz.c ===
#include "compdir.h"

#define printtext( Text) fprintf( stdout, Text);
#define printstring( String) fprintf( stdout, "%s\n",String);

#define Next( List) ( List == NULL) ? NULL : &(*List).Next

#define CALCULATE_HEIGHT( Node)                                                    \
                                                                                  \
    if ( (*Node).Left == NULL)                                                     \
        if ( (*Node).Right == NULL)                                                \
             (*Node).Height = 1;                                                   \
        else                                                                      \
             (*Node).Height = (*(*Node).Right).Height + 1;                         \
    else                                                                          \
        if ( (*Node).Right == NULL)                                                \
             (*Node).Height = (*(*Node).Left).Height + 1;                          \
        else                                                                      \
            (*Node).Height = ( (*(*Node).Right).Height > (*(*Node).Left).Height) ? \
                (*(*Node).Right).Height + 1 : (*(*Node).Left).Height + 1;

#define ROTATELEFT( List)                                                          \
                                                                                  \
    LinkedFileList TmpPtr;                                                        \
                                                                                  \
    TmpPtr = (**List).Right;                                                      \
    (**List).Right = (*TmpPtr).Left;                                              \
    (*TmpPtr).Left = (*List);                                                     \
    *List = TmpPtr;                                                               \
                                                                                  \
    if ( (*(**List).Left).Right != NULL)                                           \
         (*(**List).Left).Last = (*(*(**List).Left).Right).Last;                   \
    else                                                                          \
        (*(**List).Left).Last = (**List).Left;                                    \
    (**List).First = (*(**List).Left).First;                                      \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Left);                                              \
                                                                                  \
    CALCULATE_HEIGHT(*List);

#define ROTATERIGHT( List)                                                         \
                                                                                  \
    LinkedFileList TmpPtr;                                                        \
                                                                                  \
    TmpPtr = (**List).Left;                                                       \
    (**List).Left = (*TmpPtr).Right;                                              \
    (*TmpPtr).Right = (*List);                                                    \
    *List = TmpPtr;                                                               \
                                                                                  \
    if ( (*(**List).Right).Left != NULL)                                           \
         (*(**List).Right).First = (*(*(**List).Right).Left).First;                \
    else                                                                          \
        (*(**List).Right).First = (**List).Right;                                 \
    (**List).Last = (*(**List).Right).Last;                                       \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Right);                                             \
                                                                                  \
    CALCULATE_HEIGHT( *List);

#define ROTATEUPLEFT( List)                                                        \
                                                                                  \
    LinkedFileList TmpPtr;                                                        \
                                                                                  \
    TmpPtr = (*(**List).Right).Left;                                              \
    (*(**List).Right).Left = (*TmpPtr).Right;                                     \
    (*TmpPtr).Right = (**List).Right;                                             \
    (**List).Right = (*TmpPtr).Left;                                              \
    (*TmpPtr).Left = (*List);                                                     \
    *List = TmpPtr;                                                               \
                                                                                  \
    if ( (*(**List).Left).Right != NULL)                                           \
         (*(**List).Left).Last = (*(*(**List).Left).Right).Last;                   \
    else                                                                          \
        (*(**List).Left).Last = (**List).Left;                                    \
    (**List).First = (*(**List).Left).First;                                      \
                                                                                  \
    if ( (*(**List).Right).Left != NULL)                                           \
         (*(**List).Right).First = (*(*(**List).Right).Left).First;                \
    else                                                                          \
        (*(**List).Right).First = (**List).Right;                                 \
    (**List).Last = (*(**List).Right).Last;                                       \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Left);                                              \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Right);                                             \
                                                                                  \
    CALCULATE_HEIGHT( *List);

#define ROTATEUPRIGHT( List)                                                       \
                                                                                  \
    LinkedFileList TmpPtr;                                                        \
                                                                                  \
    TmpPtr = (*(**List).Left).Right;                                              \
    (*(**List).Left).Right = (*TmpPtr).Left;                                      \
    (*TmpPtr).Left = (**List).Left;                                               \
    (**List).Left = (*TmpPtr).Right;                                              \
    (*TmpPtr).Right = (*List);                                                    \
    *List = TmpPtr;                                                               \
                                                                                  \
    if ( (*(**List).Right).Left != NULL)                                           \
         (*(**List).Right).First = (*(*(**List).Right).Left).First;                \
    else                                                                          \
        (*(**List).Right).First = (**List).Right;                                 \
    (**List).Last = (*(**List).Right).Last;                                       \
                                                                                  \
    if ( (*(**List).Left).Right != NULL)                                           \
         (*(**List).Left).Last = (*(*(**List).Left).Right).Last;                   \
    else                                                                          \
        (*(**List).Left).Last = (**List).Left;                                    \
    (**List).First = (*(**List).Left).First;                                      \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Right);                                             \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Left);                                              \
                                                                                  \
    CALCULATE_HEIGHT( *List);




//
// Walk down list and add Nodes
//

BOOL AddToList( LinkedFileList Node, LinkedFileList *List)
{
    int Result;
    BOOL Changed    = FALSE;
    BOOL ChangedVal = FALSE;

    //
    // If Node is empty do nothing
    //

    if ( Node == NULL)
    {
        return Changed;
    }
    //
    // If list is empty just point to Node
    //

    if ( *List == NULL)
    {
        *List = Node;
        Changed = TRUE;

    //
    // Otherwise go down the list and add
    // in sorted order
    //

    } else
    {
        Result = _stricmp( (*Node).Name, (**List).Name);

        if ( Result < 0)
        {

            if ( (**List).Left == NULL)
            {
                (**List).Left = Node;
                (**List).First = (*Node).First;
                (*(*Node).Last).Next = *List;
                Changed = TRUE;
                CALCULATE_HEIGHT(*List);

            }  else
            {
                ChangedVal = AddToList( Node, &(**List).Left);
                if ( ChangedVal)
                {
                    if ( (**List).First != (*(**List).Left).First)
                    {
                        Changed = TRUE;
                        (**List).First = (*(**List).Left).First;
                    }
                    if ( (*(*(**List).Left).Last).Next != *List)
                    {
                        Changed = TRUE;
                        (*(*(**List).Left).Last).Next = *List;
                    }
                }
                Result = (**List).Height;
                CALCULATE_HEIGHT( *List);
                if ( (**List).Height != Result)
                {
                    Changed = TRUE;
                }
            }
            if ( Changed)
            {
                if ( (**List).Right == NULL)
                {
                    if ( (*(**List).Left).Height > 1 )
                    {
                        if ( (*(**List).Left).Left == NULL )
                        {
                            ROTATEUPRIGHT( List);
                            Changed = TRUE;

                        } else
                        {
                            ROTATERIGHT( List);
                            Changed = TRUE;
                        }
                    }

                } else if ( ( (*(**List).Left).Height - (*(**List).Right).Height) > 1)
                {
                    ROTATERIGHT( List);
                    Changed = TRUE;
                }
            }
        }
        else if ( Result > 0)
        {
            if ( (**List).Right == NULL)
            {

                (**List).Right = Node;
                (**List).Next = (*Node).First;
                (**List).Last = (*Node).Last;
                Changed = TRUE;
                CALCULATE_HEIGHT( *List);

            } else
            {
                ChangedVal = AddToList( Node, &(**List).Right);
                if ( ChangedVal)
                {
                    if ( (**List).Next != (*(**List).Right).First)
                    {
                        Changed = TRUE;
                        (**List).Next = (*(**List).Right).First;
                    }
                    if ( (**List).Last != (*(**List).Right).Last)
                    {
                        Changed = TRUE;
                        (**List).Last = (*(**List).Right).Last;
                    }
                }
                Result = (**List).Height;
                CALCULATE_HEIGHT( *List);
                if ( (**List).Height != Result)
                {
                    Changed = TRUE;
                }
            }
            if ( Changed)
            {
                if ( (**List).Left == NULL)
                {
                    if ( (*(**List).Right).Height > 1 )
                    {
                        if ( (*(**List).Right).Right == NULL )
                        {
                            ROTATEUPLEFT( List);
                            Changed = TRUE;

                        } else
                        {
                            ROTATELEFT( List);
                            Changed = TRUE;
                        }
                    }
                }
                else if ( ( (*(**List).Right).Height - (*(**List).Left).Height) > 1)
                {
                    ROTATELEFT( List);
                    Changed = TRUE;
                }
            }

        } else if ( Result == 0)
        {
            // Don't add if already here
        }

    
}

    return Changed;

} /* AddToList */

LPSTR CombineThreeStrings( char *FirstString, char *SecondString, char *ThirdString)
{
    char *String;

    String = malloc( strlen( FirstString) + strlen( SecondString) + strlen( ThirdString) + 1);
    if ( String == NULL)
    {
        OutOfMem();
    }

    strcpy( String, FirstString);
    strcpy( &(String[strlen( FirstString)]), SecondString);
    strcpy( &(String[strlen( FirstString) + strlen( SecondString)]), ThirdString);

    return( String);

} /* CombineThreeStrings */

void CreateNode( LinkedFileList *Node, WIN32_FIND_DATA *Buff)
{
    (*Node) = malloc( sizeof( struct NodeStruct));
    if ( (*Node) == NULL)
    {
        OutOfMem();
    }
    (**Node).Name = _strrev( _strdup( (*Buff).cFileName));
    if ( (**Node).Name == NULL)
    {
        OutOfMem();
    }
    if ( !fDontLowerCase)
    {
        _strlwr( (**Node).Name);
    }
    strcpy( (**Node).Flag, "");
    (**Node).Attributes = (*Buff).dwFileAttributes;
    if ( (*Buff).dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        strcpy( (**Node).Flag, "DIR");
    }
    (**Node).SizeHigh = (*Buff).nFileSizeHigh;
    (**Node).SizeLow = (*Buff).nFileSizeLow;
    (**Node).Time.dwLowDateTime = (*Buff).ftLastWriteTime.dwLowDateTime;
    (**Node).Time.dwHighDateTime = (*Buff).ftLastWriteTime.dwHighDateTime;
    (**Node).First    = (*Node);
    (**Node).Last     = (*Node);
    (**Node).Left     = NULL;
    (**Node).Next     = NULL;
    (**Node).Process  = ProcessModeDefault;
    (**Node).Right    = NULL;
    (**Node).DiffNode = NULL;
    (**Node).Height   = 1;

} /* CreateNode */


void CreateNameNode( LinkedFileList *Node, char *Name)
{
    (*Node) = malloc( sizeof( struct NodeStruct));
    if ( (*Node) == NULL)
    {
        OutOfMem();
    }
    (**Node).Name = _strdup( Name);
    if ( (**Node).Name == NULL)
    {
        OutOfMem();
    }
    if ( !fDontLowerCase)
    {
        _strlwr( (**Node).Name);
    }
    strcpy( (**Node).Flag, "");
    (**Node).Attributes = 0;
    (**Node).SizeHigh = 0;
    (**Node).SizeLow = 0;
    (**Node).Time.dwLowDateTime  = 0;
    (**Node).Time.dwHighDateTime = 0;
    (**Node).First    = (*Node);
    (**Node).Last     = (*Node);
    (**Node).Left     = NULL;
    (**Node).Next     = NULL;
    (**Node).Process  = TRUE;
    (**Node).Right    = NULL;
    (**Node).DiffNode = NULL;
    (**Node).Height   = 1;

} /* CreateNode */


void DuplicateNode( LinkedFileList FirstNode, LinkedFileList *SecondNode)
{
    (*SecondNode) = malloc( sizeof( struct NodeStruct));
    if ( (*SecondNode) == NULL)
    {
        OutOfMem();
    }
    (**SecondNode).Name = _strdup( (*FirstNode).Name);
    if ( (**SecondNode).Name == NULL)
    {
        OutOfMem();
    }
    if ( !fDontLowerCase)
    {
        _strlwr( (**SecondNode).Name);
    }
    strcpy( (**SecondNode).Flag, (*FirstNode).Flag);
    (**SecondNode).Attributes = (*FirstNode).Attributes;
    (**SecondNode).SizeHigh = (*FirstNode).SizeHigh;
    (**SecondNode).SizeLow  = (*FirstNode).SizeLow;
    (**SecondNode).Time.dwLowDateTime  = (*FirstNode).Time.dwLowDateTime;
    (**SecondNode).Time.dwHighDateTime = (*FirstNode).Time.dwHighDateTime;
    (**SecondNode).First    = (*SecondNode);
    (**SecondNode).Last     = (*SecondNode);
    (**SecondNode).Left     = NULL;
    (**SecondNode).Next     = NULL;
    (**SecondNode).Process  = ProcessModeDefault;
    (**SecondNode).Right    = NULL;
    (**SecondNode).DiffNode = NULL;
    (**SecondNode).Height   = 0;

} // DuplicateNode

LinkedFileList *FindInList( char *Name, LinkedFileList *List)
{
    int Result;
    LinkedFileList *tmpptr = List;

    while ( *tmpptr != NULL)
    {
        Result = _stricmp( (**tmpptr).Name, Name);
        if ( Result == 0)
        {
            return tmpptr;
        }
        if ( Result > 0)
        {
            tmpptr = &(**tmpptr).Left;
        }
        if ( Result < 0)
        {
            tmpptr = &(**tmpptr).Right;
        }
    }
    return NULL;

} /* FindInList */

BOOL FindInMatchListTop( char *Name, LinkedFileList *List)
{
    int Result;
    LinkedFileList *tmpptr = List;

    while ( *tmpptr != NULL)
    {
        Result = _stricmp( (**tmpptr).Name, Name);
        if ( Result == 0)
        {
            return TRUE;
        }
        if ( strchr( (**tmpptr).Name, '*') != NULL)
        {
            if ( Match( (**tmpptr).Name, Name))
            {
                return TRUE;
            }
        }
        if ( Result > 0)
        {
            tmpptr = &(**tmpptr).Left;
        }
        if ( Result < 0)
        {
            tmpptr = &(**tmpptr).Right;
        }
    }
    return FALSE;

} /* FindInList */

BOOL FindInMatchListFront( char *Name, LinkedFileList *List)
{
    LinkedFileList *tmpptr = List;

    if ( *tmpptr != NULL)
    {
       tmpptr = &(**tmpptr).First;
    }

    while ( *tmpptr != NULL)
    {
        if ( Match( (**tmpptr).Name, Name))
        {
            return TRUE;
        }

        tmpptr = &(**tmpptr).Next;
    }
    return FALSE;

} /* FindInList */

//
// Walk down list and free each entry
//

void FreeList( LinkedFileList *List)
{
    if ( (*List) != NULL)
    {
        FreeList( &(**List).Left);
        FreeList( &(**List).Right);
        FreeList( &(**List).DiffNode);
        free( (**List).Name);
        free( *List);
    }

} // FreeList

void PrintTree( LinkedFileList List, int Level)
{
    int Counter = 0;

    if ( List == NULL)
    {
        return;
    }

    PrintTree( (*List).Right, Level + 1);

    while ( Counter++ < Level)
    {
        fprintf( stdout, "       ");
    }

    fprintf( stdout, "%s %d\n", (*List).Name, (*List).Height);

    PrintTree( (*List).Left, Level + 1);

} // Print Tree

//
// This function is is the same as strcat except
// that it does the memory allocation for the string
//

LPSTR MyStrCat( char *FirstString, char *SecondString)
{
    char *String;

    String = malloc( strlen( FirstString) + strlen( SecondString) + 1);
    if ( String == NULL)
    {
        OutOfMem();
    }

    strcpy( String, FirstString);
    strcpy( &(String[strlen( FirstString)]), SecondString);

    return( String);

} /* MyStrCat */

BOOL Match( char *Pat, char* Text)
{
    switch ( *Pat)
    {
        case '\0':
            return *Text == '\0';
        case '?':
            return *Text != '\0' && Match( Pat + 1, Text + 1);
        case '*':
            do
            {
                if ( Match( Pat + 1, Text))
                {
                    return TRUE;
                }
            } while ( *Text++);
            return FALSE;
        default:
            return toupper( *Text) == toupper( *Pat) && Match( Pat + 1, Text + 1);
    }

} /* Match */

/*
LinkedFileList *Next( LinkedFileList List)
{
    if ( List == NULL)
    {
        return NULL;
    }

    return &(*List).Next;

} /* /* Next */

void OutOfMem( void)
{
    fprintf( stderr, "-out of memory-\n");
    exit(1);

} // OutOfMem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\consume\consume.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: consume.cxx
// author: silviuc
// created: Fri Apr 10 14:32:17 1998
//
// history:
//      johnfu  added/modfied -paged-pool and -nonpaged-pool
//              removed -paged-pool-bad and -nonpaged-pool-bad
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>
#include <windows.h>

#include "error.hxx"
#include "physmem.hxx"
#include "pagefile.hxx"
#include "pool.hxx"
#include "disk.hxx"
#include "cputime.hxx"
#include "consume.hxx"

#define Main main

VOID CreatePhysicalMemoryConsumers ();
VOID CreatePageFileConsumers ();
VOID CreateKernelPoolConsumers ();

//
// Table of contents (local functions)
//

static void SleepSomeTime (DWORD TimeOut, HANDLE Job);
static void Help ();

static char * * 
SearchCmdlineOption (

    char * Search,
    char * * Options);

#define SIZE_1_GB 0x40000000

//
// Function:
//
//     Main
//
// Description:
//
//     Main function.
//

void _cdecl
    Main (

    int argc,
    char *argv [])
{
    DWORD TimeOut = INFINITE;
    HANDLE Job = NULL;
    BOOL Result;
    
    //
    // Is help requested?
    //

    if (argc == 1 
        || (argc == 2 && strcmp (argv[1], "?") == 0)
        || (argc == 2 && strcmp (argv[1], "/?") == 0)
        || (argc == 2 && strcmp (argv[1], "-?") == 0)
        || (argc == 2 && strcmp (argv[1], "-h") == 0)
        || (argc == 2 && strcmp (argv[1], "/h") == 0)
        || (argc == 2 && strcmp (argv[1], "-help") == 0)) {
        Help ();
    }   

    //
    // Randomize the seed.
    //

    srand ((unsigned)time(0));

    //
    // Figure out if a time out parameter has been specified.
    //

    {
        char * * Option;

        Option = SearchCmdlineOption ("-time", argv);

        if (Option && *(Option + 1)) {
            TimeOut = atoi (*(Option + 1));
            Message ("Time out after %u seconds.", TimeOut);
            TimeOut *= 1000;
        }
    }

    //
    // Create a job object and assign it to itself. This will help
    // terminating baby consumer processes. However the assign will
    // fail if the consumer is already inside a job object (e.g. dks
    // scheduler).
    //
    // DMihai:
    // We are attaching the current process to a job object only
    // if a timeout was specified in the command line. Otherwise we
    // don't need the job object at all. The dks scheduler 
    // had a race where it would allow this app to assign itself to a
    // job object before the scheduler assigned it to another job. 
    // So the scheduler failed to kill this app when its time came. 
    //

    if (TimeOut != INFINITE) {

        Job = CreateJobObject (0, 0);
        Result = AssignProcessToJobObject (Job, GetCurrentProcess());

        if (Job && Result) {
            Message ("Successfully assigned process to a job object ...");
        }
    }

    //
    // Parse command line. For every command we execute the consumption
    // scenario and then we sleep forever with the resource hold.
    //

    if (SearchCmdlineOption ("-disk-space", argv)) {
        ConsumeAllDiskSpace ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-cpu-time", argv)) {
        ConsumeAllCpuTime ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-kernel-pool", argv)) {
        CreateKernelPoolConsumers ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-physical-memory", argv)) {
        CreatePhysicalMemoryConsumers ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-page-file", argv)) {
        CreatePageFileConsumers ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-physical-memory-worker", argv)) {
        ConsumeAllPhysicalMemory ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-page-file-worker", argv)) {
        ConsumeAllPageFile ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-kernel-pool-worker", argv)) {
        ConsumeAllNonpagedPool ();
        SleepSomeTime (TimeOut, Job);
    }
    else {
        Help ();
    }
}

//
// Function:
//
//     SleepSomeTime
//
// Description:
//
//     Sleeps forever.
//

static void
    SleepSomeTime (
        
        DWORD TimeOut,
        HANDLE Job)
{
    Message ("Sleeping ...");
    fflush (stdout);

    if (TimeOut == INFINITE) {
        while (1) {
            Sleep (10000);
        }
    }
    else {

        Sleep (TimeOut);

        if (Job) {
            TerminateJobObject (Job, 0xAABBBBAA);
        }
    }
}

//
// Function:
//
//     Help
//
// Description:
//
//     Prints help information to stdout.
//

static void
    Help ()
{
    printf (
        "Universal Resource Consumer - Just an innocent stress program, v 0.1.0 \n"
        "Copyright (c) 1998, 1999, Microsoft Corporation                        \n"
        "                                                                       \n"
        "    consume RESOURCE [-time SECONDS]                                   \n"
        "                                                                       \n"
        "RESOURCE can be one of the following:                                  \n"
        "                                                                       \n"
        "    -physical-memory                                                   \n"
        "    -page-file                                                         \n"
        "    -disk-space                                                        \n"
        "    -cpu-time                                                          \n"
        "    -kernel-pool                                                       \n"
        "                                                                       \n");

    exit (1);
}

//
// Function:
//
//     SearchCmdlineOption
//
// Description:
//
//     Helper function for cmdline parsing.
//

static char * * 
SearchCmdlineOption (

    char * Search,
    char * * Options)
{
    for ( ; *Options; Options++) {
        if (_stricmp (Search, *Options) == 0) {
            return Options;
        }
    }

    return NULL;
}

//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// Baby consumer creation
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     CreateBabyConsumer
//
// Description:
//
//     This function calls CreateProcess() with the command line
//     specified. This is used by some consumers that cannot eat
//     completely a resource from only one process. Typical examples
//     are physical memory and page file. Essentially in one process
//     you can consume up to 2Gb therefore we need more processes
//     for machines that have more than 2Gb of RAM.
//

BOOL
    CreateBabyConsumer (

    LPTSTR CommandLine)
{
    BOOL Result;
    TCHAR CmdLine [MAX_PATH];
    STARTUPINFO StartInfo;
    PROCESS_INFORMATION ProcessInfo;

    strcpy (CmdLine, CommandLine);
    ZeroMemory (&StartInfo, sizeof StartInfo);
    ZeroMemory (&ProcessInfo, sizeof ProcessInfo);
    StartInfo.cb = sizeof StartInfo;

    Result = CreateProcess (
        NULL,
        CmdLine,
        NULL,
        NULL,
        0,
        CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        & StartInfo,
        & ProcessInfo);

    CloseHandle (ProcessInfo.hThread);
    CloseHandle (ProcessInfo.hProcess);

    return Result;
}

//
// Function:
//
//     CreatePhysicalMemoryConsumers
// 
// Description:
//
//     This function launches enough physical memory
//     consumer processes to insure that the whole physical
//     memory gets used.
//

VOID
CreatePhysicalMemoryConsumers () 
{
    MEMORYSTATUSEX MemoryInfo;
    DWORD Consumers;
    DWORD Index;

    ZeroMemory (&MemoryInfo, sizeof MemoryInfo);
    MemoryInfo.dwLength = sizeof MemoryInfo;
    GlobalMemoryStatusEx (&MemoryInfo);

    //
    // We will attempt to create a consumer for every 256Mb of physical
    // memory.
    //

    Consumers = 1 + (DWORD)(MemoryInfo.ullTotalPhys / SIZE_1_GB) * 4;

    Message ("Total physical memory: %I64X", MemoryInfo.ullTotalPhys);
    Message ("Available physical memory: %I64X", MemoryInfo.ullAvailPhys);
    Message ("Will attempt to create %u baby consumers ...", Consumers);

    for (Index = 0; Index < Consumers; Index++)
        if (CreateBabyConsumer ("consume -physical-memory-worker") == FALSE)
            Warning ("Cannot create baby consumer `-physical-memory-worker'");
}

//
// Function:
//
//     CreatePageFileConsumers
// 
// Description:
//
//     This function launches enough page file
//     consumer processes to insure that the whole page file
//     gets used.
//

VOID
CreatePageFileConsumers ()
{
    MEMORYSTATUSEX MemoryInfo;
    DWORD Consumers;
    DWORD Index;

    ZeroMemory (&MemoryInfo, sizeof MemoryInfo);
    MemoryInfo.dwLength = sizeof MemoryInfo;
    GlobalMemoryStatusEx (&MemoryInfo);

    //
    // We will attempt to create a consumer for every 256Mb of page file
    //

    Consumers = 1 + (DWORD)(MemoryInfo.ullTotalPageFile / SIZE_1_GB) * 4;

    Message ("Total page file: %I64X", MemoryInfo.ullTotalPageFile);
    Message ("Available page file: %I64X", MemoryInfo.ullAvailPageFile);
    Message ("Will attempt to create %u baby consumers ...", Consumers);

    for (Index = 0; Index < Consumers; Index++)
        if (CreateBabyConsumer ("consume -page-file-worker") == FALSE)
            Warning ("Cannot create baby consumer `-page-file-worker'");
}

//
// Function:
//
//     CreateKernelPoolConsumers
// 
// Description:
//
//     This function launches enough kernel pool
//     consumer processes to insure that the whole 
//     non paged pool gets used.
//

VOID
CreateKernelPoolConsumers ()
{
    DWORD Consumers;
    DWORD Index;

    //
    // We will attempt to create 4 consumers
    //

    Consumers = 4;

    for (Index = 0; Index < Consumers; Index++)
        if (CreateBabyConsumer ("consume -kernel-pool-worker") == FALSE)
            Warning ("Cannot create baby consumer `-kernel-pool-worker'");
}

//
// end of module: consume.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\consume\disk.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: disk.cxx
// author: silviuc
// created: Mon Apr 13 14:02:12 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "disk.hxx"
#include "consume.hxx"

//
// Table of contents (local functions)
//

static DWORD ConvertToMbytes (PULARGE_INTEGER Size);

//
// Function:
//
//     ConsumeAllDiskSpace
//
// Description:
//
//     This function consumes all disk space on the current
//     partition (the one from which `consume' has been launched).
//

void ConsumeAllDiskSpace ()
{
    ULARGE_INTEGER TotalDiskSize;
    ULARGE_INTEGER FreeDiskSize;
    ULARGE_INTEGER UserFreeSize;
    ULARGE_INTEGER RequestSize;
    HANDLE File;
    HANDLE Mapping;
    BOOL Result;
    ULONG uLastBitMask;

    //
    // Get disk space information
    //

    Result = GetDiskFreeSpaceEx (
        NULL, // current directory
        & UserFreeSize,
        & TotalDiskSize,
        & FreeDiskSize);

    if (Result == FALSE) {
        Error ("GetDiskFreeSpaceEx() failed: error %u",
            GetLastError());
    }

    Message ("Total disk space:         %u Mb", ConvertToMbytes (& TotalDiskSize));
    Message ("Free disk space:          %u Mb", ConvertToMbytes (& FreeDiskSize));
    Message ("Free per user space:      %u Mb", ConvertToMbytes (& UserFreeSize));

    //
    // Compute the request size
    //

    RequestSize.QuadPart = UserFreeSize.QuadPart;
    Message ("Attempting to use:        %u Mb", ConvertToMbytes (& RequestSize));

    //
    // Don't allow a size that assigned to a LARGE_INTEGER will result
    // in a negative number
    //

    uLastBitMask = 1 << ( sizeof( uLastBitMask ) * 8 - 1 );
    RequestSize.HighPart &= ~uLastBitMask;

    //
    // Create a file
    //

    File = CreateFile (
        TEXT ("consume.dsk"),
        GENERIC_READ | GENERIC_WRITE,
        0,                              // no sharing
        NULL,                           // default security
        CREATE_ALWAYS,
        FILE_FLAG_DELETE_ON_CLOSE,
        NULL);                          // default template file

    if (File == INVALID_HANDLE_VALUE)
        Error ("CreateFile (`consume.dsk') failed: error %u",
            GetLastError());

    //
    // Create a mapping file on top of the file.
    //

    for ( ; RequestSize.QuadPart > 0 ; ) {
        Mapping = CreateFileMapping (
            File,
            NULL,                 // default security
            PAGE_READWRITE,       // protection
            RequestSize.HighPart,
            RequestSize.LowPart,
            NULL);                // no name

        if (Mapping != NULL)
            break;

        if ( RequestSize.QuadPart >  0x10000 ) {
            RequestSize.QuadPart -= 0x10000;
        }
        else {
            break;
        }

        Message ("Reattempting to use:      %u Mb", ConvertToMbytes (& RequestSize));
    }
}

//
// Function:
//
//     ConvertToMbytes
//
// Description:
//
//     Converts a size to Mbytes so that we can print more user-friendly
//     values.
//

static DWORD 
    ConvertToMbytes (

    PULARGE_INTEGER Size)
{
    return(DWORD)(Size->QuadPart >> 20);
}


//
// end of module: disk.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\consume\cputime.cxx ===
//
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: cputime.cxx
// author: silviuc
// created: Wed Jun 17 18:48:56 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "cputime.hxx"
#include "consume.hxx"

//
// Function:
//
//     ThreadVirtualMemoryStuff
//
// Description:
//
//     This function is run by some consumer threads.
//     It is supposed to perform alloc/free cycles in order
//     to keep the memory manager busy.
//

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
static DWORD
ThreadVirtualMemoryStuff (LPVOID)
{
    PVOID Address;

    for ( ; ; )
      {
        //
        // Allocate a normal space 64K chunk, touch it in
        // one page and then free it.
        //

        Address = (PVOID)(UINT_PTR)(( rand() << 16) | rand());

        try
          {
            Address = VirtualAlloc (
                Address,
                0x10000,
                MEM_RESERVE | MEM_COMMIT,
                PAGE_READWRITE);

            if (Address) {

                *((DWORD *)Address) = 0xAABBCCDD;

                VirtualFree (
                    Address,
                    0,
                    MEM_RELEASE);
            }
          }
        catch (...)
          {
            Message ("VirtualAlloc/Free scenario raised exception");
          }

      } // for ( ; ; )

    //
    // Make compiler happy.
    //

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

//
// Function:
//
//     ThreadVolumeInformationStuff
//
// Description:
//
//     This function is run by some consumer threads.
//     It is supposed to call GetVolumeInformation in a loop.
//     This makes some calls inside the I/O manager.
//

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
static DWORD
ThreadVolumeInformationStuff (LPVOID)
{
    for ( ; ; )
      {
        TCHAR Name [MAX_PATH];
        DWORD SerialNumber;
        DWORD MaxNameLength;
        DWORD FileSystemFlags;
        TCHAR FileSystemName [MAX_PATH];

        try {

            GetVolumeInformation (
                NULL,
                Name,
                MAX_PATH,
                & SerialNumber,
                & MaxNameLength,
                & FileSystemFlags,
                FileSystemName,
                MAX_PATH);
        }
        catch (...) {
            Message ("GetVolumeInformation scenario raised exception");
        }
      }

    //
    // Make compile rhappy.
    //

    return 0;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//
// Global:
//
//     ThreadFunction
//
// Description:
//
//     This is a vector containing all thread functions available.
//     We will pick at random from here when we want to create
//     a thread.
//

static LPTHREAD_START_ROUTINE
ThreadFunction [] =
{
    ThreadVirtualMemoryStuff,
    ThreadVolumeInformationStuff
};

//
// Function:
//
//     ConsumeAllCpuTime
//
// Description:
//
//     This function will try to swamp the system with threads.
//     The "swamp" calculation is very simple. For every processor
//     we create 128 threads having normal priority.
//

void ConsumeAllCpuTime ()
{
    DWORD MaxThreadCount;
    DWORD MaxThreadFunction;
    SYSTEM_INFO SystemInfo;
    DWORD Index;

    //
    // Decide how many threads we should attempt to start.
    // Every processor will add 128 threads.
    //

    GetSystemInfo (& SystemInfo);
    MaxThreadCount = 128 * SystemInfo.dwNumberOfProcessors;
    Message ("Attempting to start %u threads ...", MaxThreadCount);

    //
    // Create all threads required. If we fail to create a thread due
    // to low memory conditions we will wait in a tight loop for better
    // conditions.
    //

    MaxThreadFunction = (sizeof ThreadFunction) / (sizeof ThreadFunction[0]);

    for (Index = 0; Index < MaxThreadCount; Index++)
      {
        HANDLE Thread;
        DWORD ThreadId;
        DWORD FunctionIndex;

        do
          {
            try {

                FunctionIndex = rand() % MaxThreadFunction;
                // Message ("Index function %u", FunctionIndex);

                Thread = CreateThread (
                    NULL,
                    0,
                    ThreadFunction [FunctionIndex],
                    NULL,
                    0,
                    & ThreadId);

                CloseHandle (Thread);
            }
            catch (...) {
                Message ("CreateThread() raised exception");
            }
          }
        while (Thread == NULL);

        printf (".");
      }

    printf("\n");
}

//
// end of module: cputime.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\consume\pagefile.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: pagefile.cxx
// author: silviuc
// created: Fri Apr 10 16:01:57 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "pagefile.hxx"
#include "consume.hxx"

//
// Function:
//
//     ConsumeAllPageFile
//
// Description:
//
//     This function consumes as much page file as possible.
//     It remains active as a consumer of the page file. Whenever
//     it cannot allocate anymore it sleeps for a while then tries 
//     again.
//

void ConsumeAllPageFile ()
{
    MEMORYSTATUSEX MemoryInfo;
    LPVOID Region;
    SIZE_T RegionSize;
    DWORD Count;
    
    //
    // Try to eat page file. This will go on forever in the sense 
    // that the moment somebody frees some memory we will eat it 
    // immediately.
    //
    
    for (Count = 0, RegionSize = 0x100000; ; )
      {
        Region = VirtualAlloc (
            NULL,
            RegionSize,
            MEM_COMMIT,
            PAGE_READWRITE);

        if (Region == NULL)
          {
            Sleep (1000);
            
            //
            // We've got an allocation error. 
            // Switch to 64K chunks and try again.
            //

            RegionSize = 0x10000;
            continue;
          }
        else
          {
            if (++Count % 16 == 0)
                printf (".");
          }
      }
}

//
// end of module: pagefile.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\copyfapi\copyfapi.cxx ===
//+============================================================================
//
//  CopyFAPI.cxx
//
//  This program provides a very simple wrapper of the CopyFileEx API
//  (and the PrivCopyFileEx in NT5) with no extra functionality.
//
//+============================================================================


#define UNICODE
#define _UNICODE

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <winbasep.h>




//+----------------------------------------------------------------------------
//
//  PromptForNotSupported
//
//  When the PrivCopyFileEx callback function is called to inform the caller
//  that something couldn't be copied, this routine is used to prompt the
//  user of this utility to see if we should continue.
//
//+----------------------------------------------------------------------------


struct
{
    WCHAR wc;
    DWORD dwProgress;
} rgPromptResponse[] = { {L'O', PROGRESS_CONTINUE},
                         {L'A', PROGRESS_CANCEL},
                         {L'S', PROGRESS_STOP},
                         {L'Q', PROGRESS_QUIET},
                         {L'N', PRIVPROGRESS_REASON_NOT_HANDLED} };

DWORD
PromptForNotSupported( LPWSTR pwszPrompt )
{
    WCHAR wc = 'z';
    HANDLE hKeyboard = INVALID_HANDLE_VALUE;
    ULONG KeyboardModeNew, KeyboardModeOld;

    hKeyboard = CreateFile( (LPWSTR)L"CONIN$",
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL );
    
    if( INVALID_HANDLE_VALUE != hKeyboard
        &&
        !IsDebuggerPresent()
        &&
        GetConsoleMode( hKeyboard, &KeyboardModeOld ) )
    {
        KeyboardModeNew = KeyboardModeOld & ~(ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT);
        SetConsoleMode( hKeyboard, KeyboardModeNew );
    }

    while(  TRUE )
    {
        for( int i = 0; i < sizeof(rgPromptResponse)/sizeof(rgPromptResponse[0]); i++ )
        {
            if( wc == rgPromptResponse[i].wc )
                return( rgPromptResponse[i].dwProgress );
        }

        wprintf( L"%s (cOntinue, cAncel, Stop, Quiet, Not handled) ", pwszPrompt );
        wc = getwchar();
        wprintf( L"\r" );
        wprintf( L"                                                                             \r" );
    }

    SetConsoleMode( hKeyboard, KeyboardModeOld );
    CloseHandle( hKeyboard );

    return( PROGRESS_CONTINUE );    // Should never execute
}



//+----------------------------------------------------------------------------
//
//  CopyFileProgressRoutine
//
//  This is the callback function given to CopyFileEx (if so desired by
//  the user).  It displays the progress information, and prompts the
//  user for permission to continue if something (e.g. ACLs) can't be 
//  copied.
//
//+----------------------------------------------------------------------------

DWORD
WINAPI
CopyFileProgressRoutine(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData OPTIONAL
    )
{
    wprintf( L"Progress: %7I64i, %7I64i, %7I64i, %7I64i, %7d\n",
             TotalFileSize.QuadPart, TotalBytesTransferred.QuadPart,
             StreamSize, StreamBytesTransferred,
             dwStreamNumber );

    switch( dwCallbackReason )
    {
    case PRIVCALLBACK_STREAMS_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Streams not supported" ));

    case PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Security info not supported" ));

    case PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Compression not supported" ));

    case PRIVCALLBACK_COMPRESSION_FAILED:
        return( PromptForNotSupported( L"Compression failed" ));

    case PRIVCALLBACK_ENCRYPTION_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Encryption not supported" ));

    case PRIVCALLBACK_CANT_ENCRYPT_SYSTEM_FILE:
        return( PromptForNotSupported( L"Can't encrypt a system file" ));

    case PRIVCALLBACK_ENCRYPTION_FAILED:
        return( PromptForNotSupported( L"Encryption failed" ));

    case PRIVCALLBACK_EAS_NOT_SUPPORTED:
        return( PromptForNotSupported( L"EAs not supported" ));

    case PRIVCALLBACK_SPARSE_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Sparse not supported" ));

    case PRIVCALLBACK_SPARSE_FAILED:
        return( PromptForNotSupported( L"Sparse failed" ));

    case PRIVCALLBACK_DACL_ACCESS_DENIED:
        return( PromptForNotSupported( L"DACL access denied" ));

    case PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED:
        return( PromptForNotSupported( L"Owner/group access denied" ));

    case PRIVCALLBACK_OWNER_GROUP_FAILED:
        return( PromptForNotSupported( L"Owner/group failed" ));

    case PRIVCALLBACK_SACL_ACCESS_DENIED:
        return( PromptForNotSupported( L"SACL access denied" ));

    case CALLBACK_CHUNK_FINISHED:
    case CALLBACK_STREAM_SWITCH:
        return( PROGRESS_CONTINUE );
    
    default:
        return( PromptForNotSupported( L"<Unknown>" ));
    }

    return( PRIVPROGRESS_REASON_NOT_HANDLED );

}

void
Usage()
{
    printf( "\n  Purpose:   Call the CopyFile API\n"
              "  Usage:     CopyFAPI [options] <source> <dest>\n"
              "  Options:   -f  COPY_FILE_FAIL_IF_EXISTS\n"
              "             -r  COPY_FILE_RESTARTABLE\n"
              "             -e  COPY_FILE_ALLOW_DECRYPTED_DESTINATION\n"
              "             -m  PRIVCOPY_FILE_METADATA\n"
              "             -s  PRIVCOPY_FILE_SACL\n"
              "             -u  PRIVCOPY_FILE_SUPERSEDE\n"
              "             -o  PRIVCOPY_FILE_OWNER_GROUP\n"
              "             -d  PRIVCOPY_FILE_DIRECTORY\n"
              "             -b  PRIVCOPY_FILE_BACKUP_SEMANTICS\n"
              "             -c  Use the callback function\n"
              "  Note:      Since this simply calls the CopyFile API,\n"
              "             you must specify the file path (not just\n"
              "             the parent directory), and wildcards\n"
              "             are not allowed\n" );
}

typedef BOOL (__stdcall *PFNMoveFileIdentityW)(
    LPCWSTR lpOldFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );

typedef BOOL (__stdcall *PFNPrivCopyFileExW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    );




//+----------------------------------------------------------------------------
//
//  wmain
//
//  User parameters are mapped to CopyFileEx parameters, then the API
//  is called.
//
//+----------------------------------------------------------------------------

extern "C" void __cdecl
wmain( int cArgs, WCHAR *rgpwszArgs[] )
{
    LONG iArgs;
    DWORD dwCopyFileFlags = 0;
    BOOL fUseCallback = FALSE;

    cArgs--;
    iArgs = 1;
    while( cArgs > 0 )
    {
        if( L'-' != rgpwszArgs[iArgs][0]
            &&
            L'/' != rgpwszArgs[iArgs][0] )
        {
            break;
        }

        WCHAR wcUpper = towupper( rgpwszArgs[iArgs][1] );
        switch( wcUpper )
        {
        case 'F':
            dwCopyFileFlags |= COPY_FILE_FAIL_IF_EXISTS;
            break;

        case 'R':
            dwCopyFileFlags |= COPY_FILE_RESTARTABLE;
            break;

        case 'E':
            dwCopyFileFlags |= COPY_FILE_ALLOW_DECRYPTED_DESTINATION;
            break;

        case 'M':
            dwCopyFileFlags |= PRIVCOPY_FILE_METADATA;
            break;

        case 'S':
            dwCopyFileFlags |= PRIVCOPY_FILE_SACL;
            break;

        case 'U':
            dwCopyFileFlags |= PRIVCOPY_FILE_SUPERSEDE;
            break;

        case 'O':
            dwCopyFileFlags |= PRIVCOPY_FILE_OWNER_GROUP;
            break;

        case 'D':
            dwCopyFileFlags |= PRIVCOPY_FILE_DIRECTORY;
            break;

        case 'B':
            dwCopyFileFlags |= PRIVCOPY_FILE_BACKUP_SEMANTICS;
            break;

        case 'C':
            fUseCallback = TRUE;
            break;
             
        case 'X':
            dwCopyFileFlags |= 0x80;
            break;

        case 'P':
            dwCopyFileFlags |= 0x100;
            break;

        default:
            wprintf( L"Invalid option:  %c\n", wcUpper );
            Usage();
            exit(0);
        }

        iArgs++;
        cArgs--;
    }

    if( cArgs != 2 )
    {
        Usage();
        exit(0);
    }

    if( fUseCallback )
        wprintf( L"          cbTotal    cbCur    cbStm cbStmCur   StmNum\n" );

    try
    {
        if( PRIVCOPY_FILE_VALID_FLAGS & dwCopyFileFlags )
        {
            // We need to call the private API

            PFNPrivCopyFileExW pfnPrivCopyFileExW;
            pfnPrivCopyFileExW = (PFNPrivCopyFileExW) GetProcAddress( GetModuleHandle(L"kernel32.dll"),
                                                                      "PrivCopyFileExW" );
            if( NULL == pfnPrivCopyFileExW )
                throw L"Couldn't get PrivCopyFileExW export";

            if( !pfnPrivCopyFileExW( rgpwszArgs[iArgs], rgpwszArgs[iArgs+1],
                                     fUseCallback ? CopyFileProgressRoutine : NULL,
                                     NULL, NULL, dwCopyFileFlags ))
                throw L"PrivCopyFileEx failed";
            else
                wprintf( L"Succeeded\n" );
        }
        else
        {
            // We can use the public API

            if( !CopyFileExW( rgpwszArgs[iArgs], rgpwszArgs[iArgs+1],
                              fUseCallback ? CopyFileProgressRoutine : NULL,
                              NULL, NULL, dwCopyFileFlags ))
                throw L"CopyFileEx failed";
            else
                wprintf( L"Succeeded\n" );
        }
    }
    catch( const WCHAR *pwszError )
    {
        wprintf( L"Error:  %s (%lu)\n", pwszError, GetLastError() );
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cp\cp.c ===
/* cp -  move from one file to another
 *
 * HISTORY:
 *
 *  3-Dec-90    w-barry   ported to Win32.
 * 07-Sep-90    w-wilson  ported to cruiser
 * 19-Mar-87    danl      exit with 1 on any errors
 *
*/


#include <ctype.h>
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <dos.h>
#include <stdio.h>
#include <conio.h>
#include <process.h>
#include <windows.h>
#include <tools.h>
#include <string.h>


char src[MAX_PATH], dst[MAX_PATH], name[MAX_PATH];

__cdecl main (c, v)
int c;
char *v[];
{
    struct findType fbuf, dbuf;
    int i, t;
    HANDLE fh;
    char *s;
    flagType fAsk = FALSE;
    flagType fAppend = FALSE;
    int iRtn = 0;
    char *y;

    ConvertAppToOem( c, v );
    while (c > 1 && fSwitChr(*v[1])) {
        lower( v[1] );
        if (!strcmp( v[1]+1, "p" ))
            fAsk = TRUE;
        else
        if (!strcmp( v[1]+1, "a" ))
            fAppend = TRUE;
        else
            printf( "cp: invalid switch %s\n", v[1] );
        c--;
        v++;
        }

    if (c < 3) {
        printf ("Usage: cp [/p] [/a] file1 [ file2 ...] target\n");
        exit (1);
        }

    for (i=1; i<c; i++) {
        findpath (v[i], src, FALSE);
        pname (src);
        v[i] = _strdup (src);
        }

    if (rootpath (v[c-1], dst) == -1) {
        printf ("Cannot move to %s - %s\n", v[c-1], error ());
        exit (1);
    } else {
        if ( dst[0] == '\\' && dst[1] == '\\' ) {
            y = strbscan (&dst[3], "/\\");
            if ( *y != '\0' ) {
                y = strbscan( y+1, "/\\");
                if ( *y == '\0' ) {
                    strcat(dst, "\\" );
                }
            }
        }
    }

    if (fPathChr (dst[strlen(dst)-1])) {
        SETFLAG (fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
    }
    else if( ffirst( dst, FILE_ATTRIBUTE_DIRECTORY, &fbuf ) ) {
        findclose( &fbuf );  /* Let next ffirst work */
        RSETFLAG (fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
    }
    else if (TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        strcat (dst, "\\");
    }

    if (c != 3 && !TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        if (!fAppend) {
            printf ("Use /A switch to append more than 1 file to another file\n");
            exit (1);
            }
        if( ( fh = CreateFile( dst, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 ) ) == (HANDLE)-1 ) {
            printf ("Cannot create %s - %s\n", dst, error ());
            exit (1);
        }

        for (i=1; i < c-1; i++) {
            if (rootpath (v[i], src) == -1) {
                printf ("Cannot move %s - %s\n", v[i], error ());
                iRtn = 1;
                continue;
                }
            printf( "%s", src );
            fflush( stdout );

            if (_access( src, 0 ) == -1) {
                printf( " - file not found\n" );
                iRtn = 1;
                continue;
                }
            if (s = fappend(src, fh)) {
                iRtn = 1;
                printf (" %s\n", s);
            }
            else
                printf (" [ok]\n");
            }

        CloseHandle( fh );
        }
    else
    for (i=1; i < c-1; i++) {

        if (rootpath (v[i], src) == -1) {
            printf ("Cannot move %s - %s\n", v[i], error ());
            iRtn = 1;
            continue;
            }

        if (_access( src, 0 ) == -1) {
            printf( "%s - file not found\n", src );
            iRtn = 1;
            continue;
            }
        strcpy (name, dst);
        if (TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            if (!fPathChr (name[strlen(name)-1]))
                strcat (name, "\\");
            upd (src, name, name);
            }

        if (!ffirst (name, -1, &dbuf) && fAsk) {

            printf( "%s (delete?)", name );
            fflush( stdout );
            t = _getch();
            t = tolower(t);
            if (t != 'y')
                if (t == 'p')
                    fAsk = FALSE;
                else {
                    printf( " - skipped\n" );
                    continue;
                    }
            printf( "\n" );
            }

        printf ("%s => %s", src, name);
        fflush (stdout);
        if (s = fcopy (src, name)) {
            iRtn = 1;
            printf (" %s\n", s);
        }
        else
            printf (" [ok]\n");
        }
    return( iRtn );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\consume\pool.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997
//

//
// module: pool.cxx
// author: silviuc
// created: Fri Apr 10 16:44:29 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "pool.hxx"
#include "consume.hxx"

//
// Function:
//
//     ConsumeAllNonpagedPool
//
// Description:
//
//     This function consumes as much non paged pool as possible.
//

void
ConsumeAllNonpagedPool ()
{
    DWORD Count;

    //
    // For ever loop to consume nonpaged pool
    //

    for (Count = 0; ; )
      {
        if (CreateEvent (0, 0, 0, 0) == NULL)
          {
            Sleep (1000);
          }
        else
          {
            if (++Count % 1024 == 0)
                printf (".");
          }
      }
}

//
// end of module: pool.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\consume\error.cxx ===
//
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: error.cxx
// author: silviuc
// created: Fri Apr 10 14:30:35 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"

//
// Variable:
//
//     ReportingModuleInitialized
//
// Description:
//
//     This boolean is false if none of the error reporting
//     functions have been called. True otherwise. Every reporting
//     function checks this value first and if it is false, then it
//     initiates the module setup.
//

static BOOL ReportingModuleInitialized = FALSE;

//
// Variable:
//
//     ErrorReportingLock
//
// Description:
//
//     All error reporting functions acquire this lock before printing
//     anything.
//

static CRITICAL_SECTION ErrorReportingLock;

//
// Variable:
//
//     DebugReportingLock
//
// Description:
//
//     All debug reporting functions acquire this lock before printing
//     anything into debugger.
//

static CRITICAL_SECTION DebugReportingLock;

//
// Function:
//
//     CheckIfModuleIsInitialized
//
// Description:
//
//     This function is called whenever an error reporting function is called.
//     If module is not initialized then we do that.
//

static void
CheckIfModuleIsInitialized ()
{
    if (ReportingModuleInitialized == FALSE) {
        InitializeCriticalSection (& ErrorReportingLock);
        InitializeCriticalSection (& DebugReportingLock);
        ReportingModuleInitialized = TRUE;
    }
}

//
// Function:
//
//     Error
//
// Description:
//
//     Printf like function that prints an error message and exits
//     with error code 1.
//

void
__cdecl
Error (char *fmt, ...)
{
    va_list prms;

    CheckIfModuleIsInitialized ();
    EnterCriticalSection (& ErrorReportingLock);

    va_start (prms, fmt);
    printf ("Consume: Error: ");
    vprintf (fmt, prms);
    printf("\n");
    va_end (prms);

    LeaveCriticalSection (& ErrorReportingLock);
    exit (1);
}

//
// Function:
//
//     Warning
//
// Description:
//
//     Printf like function that print a warning message.
//

void
__cdecl
Warning (char *fmt, ...)
{
    va_list prms;

    CheckIfModuleIsInitialized ();
    EnterCriticalSection (& ErrorReportingLock);

    va_start (prms, fmt);
    printf ("Consume: Warning: ");
    vprintf (fmt, prms);
    printf("\n");
    va_end (prms);

    LeaveCriticalSection (& ErrorReportingLock);
}

//
// Function:
//
//     Message
//
// Description:
//
//     Printf like function that prints a message.
//

void
__cdecl
Message (char *fmt, ...)
{
    va_list prms;

    CheckIfModuleIsInitialized ();
    EnterCriticalSection (& ErrorReportingLock);

    va_start (prms, fmt);
    printf ("Consume: Message: ");
    vprintf (fmt, prms);
    printf("\n");
    va_end (prms);

    LeaveCriticalSection (& ErrorReportingLock);
}

//
// Function:
//
//     DebugMessage
//
// Description:
//
//     Printf like function that prints a message into debugger.
//

void
__cdecl
DebugMessage (char *fmt, ...)
{
    va_list prms;
    TCHAR Buffer [1024];
    TCHAR SecondBuffer [1024];

    CheckIfModuleIsInitialized ();
    EnterCriticalSection (& DebugReportingLock);

    va_start (prms, fmt);
    vsprintf (Buffer, fmt, prms);
    sprintf (SecondBuffer, "%s %s\n", "Consume: Debug: ", Buffer);
    OutputDebugString (SecondBuffer);
    va_end (prms);

    LeaveCriticalSection (& DebugReportingLock);
}

//
// end of module: error.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\consume\physmem.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: physmem.cxx
// author: silviuc
// created: Fri Apr 10 14:05:05 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "physmem.hxx"
#include "consume.hxx"

//
// Local functions
//

BOOL
CheckMemoryRegion (

    LPVOID Address,
    SIZE_T Size);

//
// Function:
//
//     ConsumeAllPhysicalMemory
//
// Description:
//
//    This routine will consume all physical memory.
//    It will do so by increasing the working set size and locking the pages
//    in memory. 
//

void ConsumeAllPhysicalMemory ()
{
    BOOL Result;
    SIZE_T MinWsSize;
    SIZE_T MaxWsSize;
    SIZE_T RegionSize;
    LPVOID Region;
    
    //
    // For ever loop in which we try to grab as much physical memory 
    // as possible.
    //

    
    for (RegionSize = 0x100000; ; )
      {
        //
        // Eat more ...
        //

        Region = VirtualAlloc (NULL, RegionSize, MEM_COMMIT, PAGE_READWRITE);

        if (Region == NULL) {

            Sleep (1000);

            //
            // We've got an allocation error. 
            // Switch to 64K chunks and try again.
            //

            RegionSize = 0x10000;
            continue;
        }

        if (VirtualLock (Region, RegionSize) == FALSE) {

            VirtualFree (Region, 0, MEM_RELEASE);

            //
            // We have to increase the working set if possible.
            //

            Result = GetProcessWorkingSetSize(
                GetCurrentProcess(),
                &MinWsSize,
                &MaxWsSize);

            if (Result == FALSE)
              {
                Sleep (1000);
                continue;
              }
            
            MinWsSize += 0x10000;
            MaxWsSize += 0x10000;

            Result = SetProcessWorkingSetSize(
                GetCurrentProcess(),
                MinWsSize,
                MaxWsSize);
    
            if (Result == FALSE) {
                Sleep (1000);
            }

            continue;
          }
        else {

            //
            // Memory is allocated and locked. Touch it.
            //

            assert_ (Region != NULL);
            CheckMemoryRegion (Region, RegionSize);
        }

        printf (".");
      }
}

//
// Function:
//
//     CheckMemoryRegion 
//
// Description:
//
//     This function checks that the memory region is zeroed as
//     it should be when a region has just been allocated and
//     then reads and writes work properly.
//

BOOL
CheckMemoryRegion (

    LPVOID Address,
    SIZE_T Size)
{
    LPBYTE Start, End, Current;

    Current = Start = (LPBYTE) Address;
    End = Start + Size;

    for ( ; Current < End; Current += 1024) {

        if (*Current != 0 || (End - Current >= 1024 && *(Current + 1023) != 0)) {
            Message ("Page at %p not zeroed \n");
            return FALSE;
        }

        *Current = *(Current + 1023) = 0xAB;

        if (*Current != 0xAB || (End - Current >= 1024 && *(Current + 1023) != 0xAB)) {
            Message ("Page at %p has R/W error \n");
            return FALSE;
        }
    }

    return TRUE;
}

//
// end of module: physmem.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cpuid\cpuid.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cpuid.c

Abstract:

    Originally written to test the fix to an OS bug but indended to be
    expanded as time allows to dump out as much useful stuff as we can.

Author:

    Peter L Johnston (peterj) July 14, 1999.

Revision History:

Notes:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winbase.h>

VOID
PrintFeatures(
    ULONG_PTR Result,
    PUCHAR    FeatureBitDescription[]
    );

#if defined(_X86_)

typedef enum {
    CPU_NONE,
    CPU_INTEL,
    CPU_AMD,
    CPU_CYRIX,
    CPU_UNKNOWN
} CPU_VENDORS;


PUCHAR X86FeatureBitDescription[] = {
/*  0 */ "FPU    387 (Floating Point) instructions",
/*  1 */ "VME    Virtual 8086 Mode Enhancements",
/*  2 */ "DE     Debugging Extensions",
/*  3 */ "PSE    Page Size Extensions (4MB pages)",
/*  4 */ "TSC    Time Stamp Counter",
/*  5 */ "MSR    Model Specific Registers (RDMSR/WRMSR)",
/*  6 */ "PAE    Physical Address Extension (> 32 bit physical addressing)",
/*  7 */ "MCE    Machine Check Exception",
/*  8 */ "CX8    CMPXCHG8B (compare and exchange 8 byte)",
/*  9 */ "APIC   Advanced Programmable Interrupt Controller",
/* 10 */ "Reserved",
/* 11 */ "SEP    Fast System Call (SYSENTER/SYSEXIT)",
/* 12 */ "MTRR   Memory Type Range Registers",
/* 13 */ "PGE    PTE Global Flag",
/* 14 */ "MCA    Machine Check Architecture",
/* 15 */ "CMOV   Conditional Move and Compare",
/* 16 */ "PAT    Page Attribute Table",
/* 17 */ "PSE36  4MB pages can have 36 bit physical addresses",
/* 18 */ "PN     96 bit Processor Number",
/* 19 */ "CLFLSH Cache Line Flush",
/* 20 */ "Reserved",
/* 21 */ "DTS    Debug Trace Store",
/* 22 */ "ACPI   ACPI Thermal Throttle Registers",
/* 23 */ "MMX    Multi Media eXtensions",
/* 24 */ "FXSR   Fast Save/Restore (FXSAVE/FXRSTOR)",
/* 25 */ "XMM    Streaming Simd Extensions",
/* 26 */ "WNI    Willamette New Instructions",
/* 27 */ "SLFSNP Self Snoop",
/* 28 */ "JT     Jackson Technology (SMT)",
/* 29 */ "ATHROT Automatic Thermal Throttle",
/* 30 */ "IA64   64 Bit Intel Architecture",
/* 31 */ "Reserved"
    };


PUCHAR AMDExtendedFeatureBitDescription[] = {
/*  0 */ "FPU    387 (Floating Point) instructions",
/*  1 */ "VME    Virtual 8086 Mode Enhancements",
/*  2 */ "DE     Debugging Extensions",
/*  3 */ "PSE    Page Size Extensions (4MB pages)",
/*  4 */ "TSC    Time Stamp Counter",
/*  5 */ "MSR    Model Specific Registers (RDMSR/WRMSR)",
/*  6 */ "PAE    Physical Address Extension (> 32 bit physical addressing)",
/*  7 */ "MCE    Machine Check Exception",
/*  8 */ "CX8    CMPXCHG8B (compare and exchange 8 byte)",
/*  9 */ "APIC   Advanced Programmable Interrupt Controller",
/* 10 */ "Reserved",
/* 11 */ "       SYSCALL and SYSRET Instructions",
/* 12 */ "MTRR   Memory Type Range Registers",
/* 13 */ "PGE    PTE Global Flag",
/* 14 */ "MCA    Machine Check Architecture",
/* 15 */ "CMOV   Conditional Move and Compare",
/* 16 */ "PAT    Page Attribute Table",
/* 17 */ "PSE36  4MB pages can have 36 bit physical addresses",
/* 18 */ "Reserved",
/* 19 */ "Reserved",
/* 20 */ "Reserved",
/* 21 */ "Reserved",
/* 22 */ "       AMD MMX Instruction Extensions",
/* 23 */ "MMX    Multi Media eXtensions",
/* 24 */ "FXSR   Fast Save/Restore (FXSAVE/FXRSTOR)",
/* 25 */ "Reserved",
/* 26 */ "Reserved",
/* 27 */ "Reserved",
/* 28 */ "Reserved",
/* 29 */ "Reserved",
/* 30 */ "       AMD 3DNow! Instruction Extensions",
/* 31 */ "       3DNow! Instructions",
    };

     // From Intel AP-485, Order Number: 241618-021, May 2002

PUCHAR BrandIndex[] = {
    "Intel Celeron",                   // 0x01
    "Intel Pentium III",               // 0x02
    "Intel Pentium III Xeon",          // 0x03
    "Intel Pentium III",               // 0x04
    "Reserved",                        // 0x05
    "Mobile Intel Pentium IIIM",       // 0x06
    "Mobile Intel Celeron",            // 0x07
    "Intel Pentium 4",                 // 0x08
    "Intel Pentium 4",                 // 0x09
    "Intel Celeron",                   // 0x0a
    "Intel Xeon",                      // 0x0b
    "Intel Xeon MP",                   // 0x0c
    "Reserved",                        // 0x0d
    "Mobile Intel Pentium 4M",         // 0x0e
    "Mobile Intel Celeron",            // 0x0f
    };

VOID
ExecuteCpuidFunction(
    IN  ULONG   Function,
    OUT PULONG  Results
    );

BOOLEAN
IsCpuidPresent(
    VOID
    );

PUCHAR
AMD_Associativity(
    ULONG Descriptor
    )
{
    switch (Descriptor) {
    case 0x0:  return"L2 Off";
    case 0x1:  return"Direct";
    case 0x2:  return" 2 way";
    case 0x4:  return" 4 way";
    case 0x6:  return" 8 way";
    case 0x8:  return"16 way";
    case 0xff: return"  Full";
    default:
         return"Reserved";
    }
}
VOID
AMD_DI_TLB(
    ULONG Format,
    ULONG TLBDesc
    )
{
    UCHAR Which = 'D';
    ULONG AssocIndex;
    ULONG Entries;

    if ((TLBDesc >> 16) == 0) {

        //
        // Unified.
        //

        TLBDesc <<= 16;
        Which = ' ';
    }
    do {
        if (Format == 1) {
            AssocIndex = TLBDesc >> 24;
            Entries = (TLBDesc >> 16) & 0xff;
        } else {
            AssocIndex = TLBDesc >> 28;
            Entries = (TLBDesc >> 16) & 0xfff;
        }
        printf(" %8s %4d entry %cTLB",
               AMD_Associativity(AssocIndex),
               Entries,
               Which
               );

        //
        // Repeat for lower half of descriptor.
        //

        TLBDesc <<= 16;
        Which = 'I';
    } while (TLBDesc);
    printf("\n");
}
VOID
AMD_Cache(
    ULONG Format,
    ULONG CacheDesc
    )
{
    ULONG Size;
    ULONG AssocIndex;
    ULONG LinesPerTag;
    ULONG LineSize;

    if (Format == 1) {
        Size = CacheDesc >> 24;
        AssocIndex = (CacheDesc >> 16) & 0xff;
        LinesPerTag = (CacheDesc >> 8) & 0xff;
        LineSize = CacheDesc & 0xff;
    } else {
        Size = CacheDesc >> 16;
        AssocIndex = (CacheDesc >> 12) & 0xf;
        LinesPerTag = (CacheDesc >> 8) & 0xf;
        LineSize = CacheDesc & 0xff;
    }
    printf(" %8s %5dKB (%d L/T)%3d bytes per line.\n",
           AMD_Associativity(AssocIndex),
           Size,
           LinesPerTag,
           LineSize
           );
}

#endif

#if defined(_IA64_)

ULONGLONG
ia64CPUID(
    ULONGLONG Index
    );

PUCHAR IA64FeatureBitDescription[] = {
/*  0 */ "BRL    Long Branch instructions",
/*  1 */ "Reserved-01",
/*  2 */ "Reserved-02",
/*  3 */ "Reserved-03",
/*  4 */ "Reserved-04",
/*  5 */ "Reserved-05",
/*  6 */ "Reserved-06",
/*  7 */ "Reserved-07",
/*  8 */ "Reserved-08",
/*  9 */ "Reserved-09",
/* 10 */ "Reserved-10",
/* 11 */ "Reserved-11",
/* 12 */ "Reserved-12",
/* 13 */ "Reserved-13",
/* 14 */ "Reserved-14",
/* 15 */ "Reserved-15",
/* 16 */ "Reserved-16",
/* 17 */ "Reserved-17",
/* 18 */ "Reserved-18",
/* 19 */ "Reserved-19",
/* 20 */ "Reserved-20",
/* 21 */ "Reserved-21",
/* 22 */ "Reserved-22",
/* 23 */ "Reserved-23",
/* 24 */ "Reserved-24",
/* 25 */ "Reserved-25",
/* 26 */ "Reserved-26",
/* 27 */ "Reserved-27",
/* 28 */ "Reserved-28",
/* 29 */ "Reserved-29",
/* 30 */ "Reserved-30",
/* 31 */ "Reserved-31",
/* 32 */ "Reserved-32",
/* 33 */ "Reserved-33",
/* 34 */ "Reserved-34",
/* 35 */ "Reserved-35",
/* 36 */ "Reserved-36",
/* 37 */ "Reserved-37",
/* 38 */ "Reserved-38",
/* 39 */ "Reserved-39",
/* 40 */ "Reserved-40",
/* 41 */ "Reserved-41",
/* 42 */ "Reserved-42",
/* 43 */ "Reserved-43",
/* 44 */ "Reserved-44",
/* 45 */ "Reserved-45",
/* 46 */ "Reserved-46",
/* 47 */ "Reserved-47",
/* 48 */ "Reserved-48",
/* 49 */ "Reserved-49",
/* 50 */ "Reserved-50",
/* 51 */ "Reserved-51",
/* 52 */ "Reserved-52",
/* 53 */ "Reserved-53",
/* 54 */ "Reserved-54",
/* 55 */ "Reserved-55",
/* 56 */ "Reserved-56",
/* 57 */ "Reserved-57",
/* 58 */ "Reserved-58",
/* 59 */ "Reserved-59",
/* 60 */ "Reserved-60",
/* 61 */ "Reserved-61",
/* 62 */ "Reserved-62",
/* 63 */ "Reserved-63"
    };

#endif

char *FeatureBitDescription32BitFormat = "   %08x  %s\n";
char *FeatureBitDescription64BitFormat = "   %016I64x  %s\n";

VOID
PrintFeatures(
    ULONG_PTR Result,
    PUCHAR    FeatureBitDescription[]
    )
{
    ULONG_PTR temp, temp2, bit;
    char *format = (sizeof(ULONG_PTR) == 8) ? FeatureBitDescription64BitFormat : 
                                              FeatureBitDescription32BitFormat;
                                              
    //
    // Feature bits.
    //

    temp = Result;
    if (temp) {
        printf("   Features\n");
        for (bit = 0, temp2 = 1; temp; bit++, temp2 <<= 1) {
            if ((temp2 & temp) == 0) {
                //
                // Feature bit not set.
                //
                continue;
            }
            temp ^= temp2;
            printf( format, temp2, FeatureBitDescription[bit]);
        }
    }
    return;

} // PrintFeatures()

__cdecl
main(
    LONG    Argc,
    PUCHAR *Argv
    )
{
    ULONG   Processor;
    ULONG   Function;
    ULONG   MaxFunction;
    ULONG   Temp;
    ULONG   Temp2, Bit;
    HANDLE  ProcessHandle;
    HANDLE  ThreadHandle;

#if defined(_X86_)

    ULONG   Results[5];
    ULONG   Family = 0;
    ULONG   Model = 0;
    ULONG   Stepping = 0;
    ULONG   Generation = 0;
    BOOLEAN CpuidPresent;
    CPU_VENDORS Vendor = CPU_NONE;
    ULONG   ThreadAffinity;
    ULONG   SystemAffinity;
    ULONG   ProcessAffinity;

#endif

#if defined(_IA64_)

    ULONGLONG Result;
    ULONGLONG ThreadAffinity;
    ULONGLONG SystemAffinity;
    ULONGLONG ProcessAffinity;
    ULONGLONG VendorInformation[3];

#endif

    //
    // Make sure this process is set to run on any processor in
    // the system.
    //

    ProcessHandle = GetCurrentProcess();
    ThreadHandle = GetCurrentThread();

    if (!GetProcessAffinityMask(ProcessHandle,
                                &ProcessAffinity,
                                &SystemAffinity)) {
        printf("Fatal error: Unable to determine process affinity.\n");
        exit(1);
    }

    if (ProcessAffinity != SystemAffinity) {

        if (!SetProcessAffinityMask(ProcessHandle,
                                    SystemAffinity)) {
            printf("Warning: Unable to run on all processors\n");
            printf("         System  Affinity %08x\n", SystemAffinity);
            printf("       - Process Affinity %08x\n", ProcessAffinity);
            printf("         Will Try         %08x\n", 
                    SystemAffinity & ProcessAffinity);
            SystemAffinity &= ProcessAffinity;
        }
        ProcessAffinity = SystemAffinity;
    }
        
#if defined(_X86_)

    //
    // Cpuid returns 4 DWORDs of data.  In some cases this is string
    // data in which case it needs to be NULL terminated.
    //

    Results[4] = 0;

#endif

    //
    // For each CPU in the system, determine the availability of
    // the CPUID instruction and dump out anything useful it might
    // have to say.
    //

    for (ThreadAffinity = 1, Processor = 0;
         ThreadAffinity;
         ThreadAffinity <<= 1, Processor++) {
        if (!(ThreadAffinity & ProcessAffinity)) {

            //
            // Can't test this processor.
            //

            if (ThreadAffinity > ProcessAffinity) {

                //
                // Tested all the processors there are, we're done.
                //
        
                break;
            }

            continue;
        }

        //
        // Set affinity so this thread can only run on the processor
        // being tested.
        //

        if (!SetThreadAffinityMask(ThreadHandle,
                                   ThreadAffinity)) {

            printf(
                "** Could not set affinity %08x for processor %d, skipping.\n",
                ThreadAffinity,
                Processor);
            continue;
        }

#if defined(_X86_)

        CpuidPresent = IsCpuidPresent();
        if (CpuidPresent) {
            printf("++ Processor %d\n", Processor);
        } else {
            printf("-- No CPUID support, processor %d\n", Processor);
            continue;
        }

        //
        // CPUID is present, examine basic functions.
        //

        ExecuteCpuidFunction(0, Results);

        MaxFunction = Results[0];


        //
        // For reasons unclear to anyone, the Vendor ID string comes
        // back in the order EBX, EDX, ECX,... so switch the last two
        // results before printing it.
        //

        Temp = Results[3];
        Results[3] = Results[2];
        Results[2] = Temp;

        if (strcmp((PVOID)&Results[1], "GenuineIntel") == 0) {
            Vendor = CPU_INTEL;
        } else if (strcmp((PVOID)&Results[1], "AuthenticAMD") == 0) {
            Vendor = CPU_AMD;
        } else if (strcmp((PVOID)&Results[1], "CyrixInstead") == 0) {
            Vendor = CPU_CYRIX;
        } else {
            Vendor = CPU_UNKNOWN;
        }

        printf("   Vendor ID '%s', Maximum Supported Function %d.\n",
                (PUCHAR)(&Results[1]),
                MaxFunction);

        for (Function = 0; Function <= MaxFunction; Function++) {
            ExecuteCpuidFunction(Function, Results);
            printf("   F %d raw = %08x %08x %08x %08x\n",
                    Function,
                    Results[0],
                    Results[1],
                    Results[2],
                    Results[3]);
            //
            // Do some interpretation on the ones we know how to
            // deal with.
            //

            switch(Function) {
            case 0:

                //
                // Already handled as the main header (gave max func
                // and Vendor ID.
                //

                break;

            case 1:

                //
                // EAX = Type, Family, Model, Stepping.
                // EBX = Family != 0xf ?
                //       Yes = Reserved,
                //       No  = 0xAABBCCDD where
                //             AA = APIC ID
                //             BB = LP per PP
                //             CC = CLFLUSH line size (8 = 64 bytes)
                //             DD = Brand Index
                // ECX = Reserved
                // EDX = Feature Bits
                //

                //
                // Family Model Stepping
                //

                Temp = Results[0];
                Family   = (Temp >> 8) & 0xf;
                Model    = (Temp >> 4) & 0xf;
                Stepping =  Temp       & 0xf;
                printf("   Type = %d, Family = %d, Model = %d, Stepping = %d\n",
                       (Temp >> 12) & 0x3, Family, Model, Stepping);

                //
                // Willamette stuff
                //

                if ((Temp & 0xf00) == 0xf00) {
                    Temp = Results[1] & 0xff;
                    if (Temp) {
                            
                        //
                        // Indexes are a DISGUSTING way to get this info!!
                        //

                        printf("   Brand Index %02Xh %s processor\n",
                               Temp,
                               Temp <= (sizeof(BrandIndex) / sizeof(PUCHAR)) ?
                               BrandIndex[Temp-1] :
                               "Unknown");
                    }
                    Temp = (Results[1] >> 8) & 0xff;
                    printf("   CLFLUSH line size (%x) = %d bytes\n",
                           Temp,
                           Temp << 3);    // ?? plj - nobasis
                    Temp = Results[1] >> 16;
                    printf("   LP per PP %d\n", Temp & 0xff);
                    printf("   APIC Id %02x\n", Temp >> 8);
                }

                //
                // Feature bits.
                //

                PrintFeatures( Results[3], X86FeatureBitDescription );
                break;

            case 2:

                //
                // Get number of times we have to do function 2 again.
                // (Then replace iteration count with a NULL descr).
                //

                Temp = Results[0] & 0xff;

                if (Temp == 0) {

                    //
                    // If the count is 0, this processor doesn't do
                    // function 2, get out.
                    //

                    break;
                }
                Results[0] &= 0xffffff00;

                do {
                    ULONG i;

                    for (i = 0; i < 4; i++) {

                        Temp2 = Results[i];

                        if (Temp2 & 0x80000000) {

                            //
                            // Not valid, skip.
                            //

                            continue;
                        }

                        while (Temp2) {

                            UCHAR Descriptor = (UCHAR)(Temp2 & 0xff);
                            ULONG K, Way, Line, Level;
                            PUCHAR IorD = "";

                            Temp2 >>= 8;

                            if (((Descriptor > 0x40) && (Descriptor <= 0x47)) ||
                                ((Descriptor > 0x78) && (Descriptor <= 0x7c)) ||
                                ((Descriptor > 0x80) && (Descriptor <= 0x87))) {

                                //
                                // It's an L2 Descriptor.  (The following
                                // is peterj's wacky formula,... not 
                                // guaranteed forever but the nice people
                                // at Intel better pray I'm dead before
                                // they break it or I'll hunt them down).
                                //

                                Level = 2;
                                Way = Descriptor >= 0x79 ? 8 : 4;
                                K = 0x40 << (Descriptor & 0x7);
                                Line = 32;
                                if ((Descriptor & 0xf8) == 0x78) {
                                    Line = 128;
                                }
                            } else if ((Descriptor >= 0x50) &&
                                       (Descriptor <= 0x5d)) {
                                if (Descriptor & 0x8) {
                                    IorD = "D";
                                    K = 0x40 << (Descriptor - 0x5b);
                                } else {
                                    IorD = "I";
                                    K = 0x40 << (Descriptor - 0x50);
                                }
                                printf("   %02xH  %sTLB %d entry\n",
                                       Descriptor,
                                       IorD,
                                       K);
                                continue;
                            } else {
                                PUCHAR s = NULL;
                                switch (Descriptor) {
                                case 0x00:
                                    continue;
                                case 0x01:
                                    s = "ITLB 4KB pages, 4 way, 32 entry";
                                    break;
                                case 0x02:
                                    s = "ITLB 4MB pages, fully assoc, 2 entry";
                                    break;
                                case 0x03:
                                    s = "DTLB 4KB pages, 4 way, 64 entry";
                                    break;
                                case 0x04:
                                    s = "DTLB 4MB pages, 4 way, 8 entry";
                                    break;
                                case 0x06:
                                    s = "I-Cache 8KB, 4 way, 32B line";
                                    break;
                                case 0x08:
                                    s = "I-Cache 16KB, 4 way, 32B line";
                                    break;
                                case 0x0a:
                                    s = "D-Cache 8KB, 2 way, 32B line";
                                    break;
                                case 0x0c:
                                    s = "D-Cache 16KB, 2 or 4 way, 32B line";
                                    break;
                                case 0x22:
                                    K = 512; Level = 3; Way = 4; Line = 128;
                                    break;
                                case 0x23:
                                    K = 1024; Level = 3; Way = 8; Line = 128;
                                    break;
                                case 0x25:
                                    K = 2048; Level = 3; Way = 8; Line = 128;
                                    break;
                                case 0x29:
                                    K = 4096; Level = 3; Way = 8; Line = 128;
                                    break;
                                case 0x40:
                                    s = "No L3 Cache";
                                    break;
                                case 0x66:
                                    K = 8; Level = 1; Way = 4; Line = 64; IorD = "D";
                                    break;
                                case 0x67:
                                    K = 16; Level = 1; Way = 4; Line = 64; IorD = "D";
                                    break;
                                case 0x68:
                                    K = 32; Level = 1; Way = 4; Line = 64; IorD = "D";
                                    break;
                                case 0x70:
                                    K = 12; Level = 1; Way = 8; Line = 64; IorD = "I";
                                    break;
                                case 0x71:
                                    K = 16; Level = 1; Way = 8; Line = 64; IorD = "I";
                                    break;
                                case 0x72:
                                    K = 32; Level = 1; Way = 8; Line = 64; IorD = "I";
                                    break;
                                case 0x80:
                                    s = "No L2 Cache";
                                    break;
                                default:
                                    s = "Unknown Descriptor";
                                }
                                if (s) {
                                    printf("   %02xH  %s.\n", Descriptor, s);
                                    continue;
                                }
                            }
                            printf("   %02xH  L%d %sCache %dKB, %d way, %dB line\n",
                                   Descriptor,
                                   Level,
                                   IorD,
                                   K,
                                   Way,
                                   Line);
                        } // while more bytes in this register
                    }  // for each register

                    //
                    // If more iterations,... 
                    //

                    if (--Temp == 0) {
                        break;
                    }

                    ExecuteCpuidFunction(2, Results);
                    printf("   F %d raw = %08x %08x %08x %08x\n",
                            2,
                            Results[0],
                            Results[1],
                            Results[2],
                            Results[3]);
                } while (TRUE);
                break;
            }
        }

        //
        // Examine extended functions.
        //

        ExecuteCpuidFunction(0x80000000, Results);

        MaxFunction = Results[0];

        //
        // Ok, function numbers > MaxFunction (the basic one) by
        // definition return undefined results.   But, we are told
        // that if extended functions are not supported, the return
        // value for 0x80000000 will never have the top bit set.
        //

        if ((MaxFunction & 0x80000000) == 0) {
            printf("   This processor does not support Extended CPUID functions.\n");
            continue;
        }

        printf("   Maximum Supported Extended Function 0x%x.\n",
                MaxFunction);

        for (Function = 0x80000000; Function <= MaxFunction; Function++) {
            ExecuteCpuidFunction(Function, Results);
            printf("   F 0x%08x raw = %08x %08x %08x %08x\n",
                    Function,
                    Results[0],
                    Results[1],
                    Results[2],
                    Results[3]);
            switch (Function) {
            case 0x80000000:
                break;

            case 0x80000001:

                if (Vendor == CPU_AMD) {
                    //
                    // EAX = Generation, Model, Stepping.
                    // EBX = Reserved
                    // ECX = Reserved
                    // EDX = Feature Bits
                    //

                    //
                    // Generation Model Stepping
                    //

                    Temp = Results[0];
                    Generation = (Temp >> 8) & 0xf;
                    Model    = (Temp >> 4) & 0xf;
                    Stepping =  Temp       & 0xf;
                    printf("   Generation = %d, Model = %d, Stepping = %d\n",
                           Generation, Model, Stepping);

                    //
                    // Feature bits.
                    //

                    PrintFeatures( Results[3], AMDExtendedFeatureBitDescription );
                }
                break;

            case 0x80000002:

                Temp2 = 1;

            case 0x80000003:

                Temp2++;

            case 0x80000004:

                Temp2++;

                printf("   Processor Name[%2d-%2d] = '%s'\n",
                       49 - (Temp2 * 16),
                       64 - (Temp2 * 16),
                       Results);
                Temp2 = 0;
                break;

            case 0x80000005:

                if (Vendor == CPU_AMD) {

                    if (Family == 6) {

                        //
                        // Athlon.
                        //

                        printf("   Large Page TLBs   :");
                        AMD_DI_TLB(1, Results[0]);

                    } else if (Family > 6) {
                        printf("   Family %d is a new AMD family which this program doesn't know about.\n");
                        break;
                    }

                    //
                    // Common to K5, K6 and Athlon
                    //

                    printf("   4KB   Page TLBs   :");
                    AMD_DI_TLB(1, Results[1]);
                    printf("   L1 D-Cache        :");
                    AMD_Cache(1, Results[2]);
                    printf("   L1 I-Cache        :");
                    AMD_Cache(1, Results[3]);
                }
                break;

            case 0x80000006:

                if (Vendor == CPU_AMD) {

                    if (Family == 6) {

                        //
                        // Athlon.
                        //

                        if (Results[0]) {
                            printf("   Large Page L2 TLB :");
                            AMD_DI_TLB(2, Results[0]);
                        }
                        if (Results[1]) {
                            printf("   4KB   Page L2 TLB :");
                            AMD_DI_TLB(2, Results[1]);
                        }
                        if ((Model == 3) && (Stepping == 0)) {
                            Results[2] &= 0xffff;
                            Results[2] |= 0x400000;
                        }
                    } else if (Family > 6) {
                        break;
                    }

                    //
                    // Common to K5, K6 and Athlon
                    //

                    printf("   L2 Cache          :");
                    AMD_Cache(2, Results[2]);
                }
                break;
            }
        }

#endif

#if defined(_IA64_)

        printf("++ Processor %d\n", Processor);

        //
        // On IA64, cpuid is implemented as a set of 64 bit registers.
        // Registers
        //     0 and 1 contain the Vendor Information.
        //     2 contains 0.
        //     3 most significant 24 bits are reserved, the low 5 bytes
        //       contain-
        //       39-32 archrev
        //       31-24 family
        //       23-16 model
        //       15-08 revision
        //       07-00 number       index of largest implemented register
        //     4 features
        //

        //
        // Until we have read register 3, set 3 as the maximum number.
        //

        MaxFunction = 3;

        for (Function = 0; Function <= MaxFunction; Function++) {

            Result = ia64CPUID(Function);

            printf("   F %d raw = %016I64x\n",
                    Function,
                    Result);

            //
            // Do some interpretation on the ones we know how to
            // deal with.
            //

            switch(Function) {
            case 0:
                VendorInformation[0] = Result;
                break;
            case 1:
                VendorInformation[1] = Result;
                VendorInformation[2] = 0;
                printf("   \"%s\"\n", (PUCHAR)VendorInformation);
                break;
            case 3:
                printf("   Architecture Revision = %d, Family = %d, Model = %d, Revision = %d\n",
                       (Result >> 32) & 0xff,
                       (Result >> 24) & 0xff,
                       (Result >> 16) & 0xff,
                       (Result >>  8) & 0xff);
                MaxFunction = (ULONG)Result & 0xff;
                printf("   Maximum Supported Function %d.\n",
                        MaxFunction);
                break;
            case 4:
                PrintFeatures( Result, IA64FeatureBitDescription );
                break;
            }
        }
#endif

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cpuid\ia64\cpuidsup.s ===
//++
//
// Copyright (c) 2001  Microsoft Corporation
//
// Module Name:
//
//    cpuidsup.s
//
// Abstract:
//
//    This module implements CPUID enquiry for the cpuid program.
//
// Author:
//
//    Peter L. Johnston (peterj) 6-Apr-2001
//
// Environment:
//
//    User mode only
//
//--

#include "ksia64.h"

        .file     "cpuidsup.s"
        .text

        LEAF_ENTRY(ia64CPUID)

        mov     ret0 = cpuid[a0]
        LEAF_RETURN
        ;;

        LEAF_EXIT(ia64CPUID)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cpuid\i386\cpuidsup.asm ===
title   "CPUID support functions"
;++
;
; Copyright (c) 1999  Microsoft Corporation
;
; Module Name:
;
;    cpuidsup.asm
;
; Abstract:
;
;    Implements functions to detect whether or not the CPUID instruction
;    is supported on this processor and to provide a simple method to use
;    CPUID from a C program.
;
; Author:
;
;    Peter Johnston (peterj) July 14, 1999
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.586p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "IsCpuidPresent"
;++
;
; BOOLEAN
; IsCpuidPresent(
;     VOID
;     )
;
; Routine Description:
;
;    If bit 21 of the EFLAGS register is writable, CPUID is supported on
;    this processor.   If not writable, CPUID is not supported.  
;
;    Note: It is expected that this routine is "locked" onto a single
;    processor when run.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE  if CPUID is supported, 
;    FALSE otherwise.
;
;--

EFLAGS_ID   equ 200000h             ; bit 21


cPublicProc _IsCpuidPresent ,0
        pushfd                      ; save EFLAGS
        pop     ecx                 ; get current value
        xor     ecx, EFLAGS_ID      ; flip bit 21
        push    ecx                 ; set flipped value in EFLAGS
        popfd
        pushfd                      ; read it back again
        pop     eax
        xor     eax, ecx            ; if new value is what we set
        shr     eax, 21             ; then these two are the same
        and     eax, 1              ; isolate bit 21 (in bit 0)
        xor     eax, 1              ; and flip it

        stdRET _IsCpuidPresent

stdENDP _IsCpuidPresent

        page
        subttl  "ExecuteCpuidFunction"
;++
;
; VOID
; ExecuteCpuidFunction(
;     ULONG     Function,
;     PULONG    Results
;     )
;
; Routine Description:
;
;    Execute the CPUID instruction, using the Function handed in and
;    return the 4 DWORD result.
;
;    Note: It is expected that this routine is "locked" onto a single
;    processor when run.
;
; Arguments:
;
;    Function   Integer function number to be the input argument for
;               the CPUID instruction.
;    Results    Pointer to the 4 DWORD array where the results are to
;               be returned.
;
; Return Value:
;
;    None.
;
;--


cPublicProc _ExecuteCpuidFunction ,2
        mov     eax, [esp+4]        ; set CPUID function
        push    esi                 ; save esi
        mov     esi, [esp+12]       ; get Results address
        push    ebx                 ; save ebx
        cpuid                       ; execute 
        mov     [esi+0], eax        ; eax -> Results[0]
        mov     [esi+4], ebx        ; ebx -> Results[1]
        mov     [esi+8], ecx        ; ecx -> Results[2]
        mov     [esi+12], edx       ; edx -> Results[3]

        pop     ebx                 ; restore ebx, esi
        pop     esi

        stdRET _ExecuteCpuidFunction

stdENDP _ExecuteCpuidFunction

_TEXT$01   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\crash\crash\crashrc.h ===
#define ID_CRASH       IDOK
#define CRASHDLG       500
#define APPICON        501
#define CRASHDRVDRIVER 502
#define CRASHBMP       503
#define CRASHWAV       504
#define BINARY         1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\crash\driver\crashdrv.c ===
#include <ntddk.h>
#include <string.h>
#include "crashdrv.h"


#define MEMSIZE         4096
#define FCN(cc)         ((cc >> 2) & 0xFFFFFF)
#define DEVICE_NAME     L"\\Device\\CrashDrv"
#define DOSDEVICE_NAME  L"\\DosDevices\\CrashDrv"


typedef VOID (*PTESTFUNC)(PULONG ub);

PTESTFUNC tests[] =
    {
    NULL,
    CrashDrvBugCheck,
    CrashDrvStackOverFlow,
    CrashDrvSimpleTest,
    CrashDrvExceptionTest,
    CrashDrvHardError,
    CrashSpecial
    };

#define MaxTests  (sizeof(tests)/sizeof(PTESTFUNC))

ULONG   CrashDrvRequest;
KEVENT  CrashEvent;
ULONG   CrashRequest;
PULONG  Funk;


NTSTATUS
CrashDrvOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CrashDrvUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CrashDrvIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CrashThread(
    PVOID Context
    );



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    UNICODE_STRING      DeviceName;
    PDEVICE_OBJECT      deviceObject;
    NTSTATUS            status;
    UNICODE_STRING      LinkObject;
    WCHAR               LinkName[80];
    ULONG               DeviceSize;
    HANDLE              ThreadHandle;


    RtlInitUnicodeString( &DeviceName, DEVICE_NAME );
    status = IoCreateDevice( DriverObject,
                             0,
                             &DeviceName,
                             FILE_DEVICE_NULL,
                             0,
                             FALSE,
                             &deviceObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    LinkName[0] = UNICODE_NULL;

    RtlInitUnicodeString(&LinkObject, LinkName);

    LinkObject.MaximumLength = sizeof(LinkName);

    RtlAppendUnicodeToString(&LinkObject, L"\\DosDevices");

    DeviceSize = sizeof(L"\\Device") - sizeof(UNICODE_NULL);
    DeviceName.Buffer += DeviceSize / sizeof(WCHAR);
    DeviceName.Length -= (USHORT)DeviceSize;

    RtlAppendUnicodeStringToString(&LinkObject, &DeviceName);

    DeviceName.Buffer -= DeviceSize / sizeof(WCHAR);
    DeviceName.Length += (USHORT)DeviceSize;

    status = IoCreateSymbolicLink(&LinkObject, &DeviceName);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice( deviceObject );
        return status;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = CrashDrvOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = CrashDrvOpenClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = CrashDrvIoControl;
    DriverObject->DriverUnload                         = CrashDrvUnload;

    KeInitializeEvent( &CrashEvent, NotificationEvent, FALSE );

    Funk = ExAllocatePool( PagedPool, MEMSIZE );

    status = PsCreateSystemThread(
        &ThreadHandle,
        0,
        NULL,
        0,
        NULL,
        CrashThread,
        NULL
        );

    return STATUS_SUCCESS;
}

NTSTATUS
CrashDrvOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );

    return status;
}

VOID
CrashDrvUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PDEVICE_OBJECT currentDevice = DriverObject->DeviceObject;
    UNICODE_STRING fullLinkName;

    while (currentDevice) {

        RtlInitUnicodeString( &fullLinkName, DOSDEVICE_NAME );
        IoDeleteSymbolicLink(&fullLinkName);
        IoDeleteDevice(currentDevice);

        currentDevice = DriverObject->DeviceObject;

    }
}

NTSTATUS
CrashDrvIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpSp  = IoGetCurrentIrpStackLocation(Irp);
    PULONG              ub;


    ub = (PULONG) MmGetSystemAddressForMdl( Irp->MdlAddress );

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CRASHDRV_CHECK_REQUEST) {
        ub[0] = CrashDrvRequest;
        CrashDrvRequest = 0;
    } else {
        if (FCN(IrpSp->Parameters.DeviceIoControl.IoControlCode) > MaxTests) {
            DbgBreakPoint();
        } else {
            tests[FCN(IrpSp->Parameters.DeviceIoControl.IoControlCode)]( ub );
        }
    }

    Irp->IoStatus.Information = 0L;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, 0 );

    return Status;
}


VOID
CrashThread(
    PVOID Context
    )
{
    while( TRUE ) {
        KeWaitForSingleObject( &CrashEvent, Executive, KernelMode, FALSE, NULL );
        KeResetEvent( &CrashEvent );
        switch( CrashRequest ) {
            case KMODE_EXCEPTION_NOT_HANDLED:
                {
                    ULONG i,j;
                    i = 0;
                    j = 0;
                    i = j / i;
                }
                break;

            case IRQL_NOT_LESS_OR_EQUAL:
                {
                    KIRQL irql;
                    KeRaiseIrql( DISPATCH_LEVEL, &irql );
                    Funk[0] = 0;
                    KeLowerIrql( irql );
                }
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\crash\driver\crashdrv.h ===
//
// CrashDrv driver/test constants
//

#define FILE_DEVICE_CRASHDRV              0x00008000


#define TEST_CHECK_REQUEST              0
#define TEST_BUGCHECK                   1
#define TEST_STACK_OVERFLOW             2
#define TEST_SIMPLE                     3
#define TEST_EXCEPTION                  4
#define TEST_HARDERR                    5
#define TEST_SPECIAL                    6

#define IOCTL_CRASHDRV_CHECK_REQUEST      CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_CHECK_REQUEST,  METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_BUGCHECK           CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_BUGCHECK,       METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_STACK_OVERFLOW     CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_STACK_OVERFLOW, METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_SIMPLE             CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_SIMPLE,         METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_EXCEPTION          CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_EXCEPTION,      METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_HARDERR            CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_HARDERR,        METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_SPECIAL            CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_SPECIAL,        METHOD_OUT_DIRECT,FILE_ANY_ACCESS)


//
// prototypes
//

VOID
CrashDrvStackOverFlow(
    PULONG ub
    );

VOID
CrashDrvBugCheck(
    PULONG ub
    );

VOID
CrashDrvSimpleTest(
    PULONG ub
    );

VOID
CrashDrvExceptionTest(
    PULONG ub
    );

VOID
CrashDrvHardError(
    PULONG ub
    );

VOID
CrashSpecial(
    PULONG ub
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\crash\crash\crash.c ===
#include <windows.h>
#include <winioctl.h>
#include <mmsystem.h>
#include <stdio.h>
#include <crashrc.h>
#include <stdlib.h>
#include <bugcodes.h>
#include "crashdrv.h"


#define SERVICE_NAME    "CrashDrv"
#define DRIVER_NAME     "\\systemroot\\system32\\drivers\\crashdrv.sys"
#define CRASHDRV_DEVICE "\\\\.\\CrashDrv"


HINSTANCE   hInst;
DWORD       IoctlBuf[16];
HBITMAP     hBmp;



BOOL    InstallDriver(VOID);
BOOL    CrashTheSystem(DWORD);
BOOL    StartCrashDrvService(VOID);
VOID    SyncAllVolumes(VOID);
BOOL    IsUserAdmin(VOID);


enum {
    CRASH_TYPE_BUGCHECK,
    CRASH_TYPE_STACK_OVERFLOW,
    CRASH_TYPE_IRQL,
    CRASH_TYPE_KMODE_EXCEPTION
};


VOID
Usage(
    )
{
    printf ("USAGE: crash <flags>\n");
    printf ("\n");
    printf ("       Where flags can be one of:\n");
    printf ("\n");
    printf ("        -bugcheck - Crash the system using KeBugCheckEx. This is the default.\n");
    printf ("        -stack-overflow - Crash the system by overflowing the kernel stack.\n");
    printf ("        -irql-not-less-or-equal - Crash the system by accessing a paged-out\n"
            "             page at DISPATCH_LEVEL IRQL.\n");
    printf ("        -kmode-exception-not-handled - Crash the system by a division by zero\n"
            "             error in a kernel thread.\n");
    printf ("\n");
    exit (1);
}

VOID
ParseArgs(
    IN int argc,
    IN char* argv [],
    OUT DWORD* CrashType
    )
{
    INT i;
    
    for (i = 1; i < argc; i++) {

        if (_stricmp (argv [i], "-bugcheck") == 0) {

            *CrashType = CRASH_TYPE_BUGCHECK;

        } else if (_stricmp (argv [i], "-stack-overflow") == 0) {

            *CrashType = CRASH_TYPE_STACK_OVERFLOW;

        } else if (_stricmp (argv [i], "-irql-not-less-or-equal") == 0) {

            *CrashType = CRASH_TYPE_IRQL;

        } else if (_stricmp (argv [i], "-kmode-exception-not-handled") == 0) {

            *CrashType = CRASH_TYPE_KMODE_EXCEPTION;

        } else {

            Usage ();
        }
    }
}
        

int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD CrashType = CRASH_TYPE_BUGCHECK;
    
    if (!IsUserAdmin ()) {
        printf ("You must have administrator priveleges to crash the system\n");
        return 1;
    }

    ParseArgs (argc, argv, &CrashType);

    if (!CrashTheSystem (CrashType)) {
        printf ("An error occured while trying to crash the system\n");
        return 2;
    }

    return 0; // NOTREACHED
}

BOOL
CrashTheSystem(
    IN DWORD CrashType
    )
{
    HANDLE   hCrashDrv;
    DWORD    ReturnedByteCount;
    HGLOBAL  hResource;
    LPVOID   lpResource;
    DWORD    Ioctl;

    if (!StartCrashDrvService()) {
        return FALSE;
    }

    SyncAllVolumes();

    hCrashDrv = CreateFile( CRASHDRV_DEVICE,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL
                        );

    if (hCrashDrv == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (waveOutGetNumDevs()) {
        hResource = LoadResource(
            hInst,
            FindResource( hInst, MAKEINTRESOURCE(CRASHWAV), MAKEINTRESOURCE(BINARY) ) );
        if (hResource) {
            lpResource = LockResource( hResource );
            sndPlaySound( lpResource, SND_MEMORY );
            FreeResource( hResource );
        }
    }

    switch (CrashType) {

        case CRASH_TYPE_STACK_OVERFLOW:
            Ioctl = IOCTL_CRASHDRV_STACK_OVERFLOW;
            IoctlBuf [0] = 0;
            break;

        case CRASH_TYPE_IRQL:
            Ioctl = IOCTL_CRASHDRV_SPECIAL;
            IoctlBuf [0] = IRQL_NOT_LESS_OR_EQUAL;
            break;

        case CRASH_TYPE_KMODE_EXCEPTION:
            Ioctl = IOCTL_CRASHDRV_SPECIAL;
            IoctlBuf [0] = KMODE_EXCEPTION_NOT_HANDLED;
            break;

        case CRASH_TYPE_BUGCHECK:
        default:
            Ioctl = IOCTL_CRASHDRV_BUGCHECK;
            IoctlBuf [0] = 0;
            break;
    }


    if (!DeviceIoControl(
              hCrashDrv,
              Ioctl,
              NULL,
              0,
              IoctlBuf,
              sizeof(IoctlBuf),
              &ReturnedByteCount,
              NULL
              )) {
        return FALSE;
    }

    return TRUE;
}

BOOL
CopyResourceToDriver(
    VOID
    )
{
    HGLOBAL                hResource;
    LPVOID                 lpResource;
    DWORD                  size;
    PIMAGE_DOS_HEADER      dh;
    PIMAGE_NT_HEADERS      nh;
    PIMAGE_SECTION_HEADER  sh;
    HANDLE                 hFile;
    CHAR                   buf[MAX_PATH];


    hResource = LoadResource(
        hInst,
        FindResource( hInst, MAKEINTRESOURCE(CRASHDRVDRIVER), MAKEINTRESOURCE(BINARY) ) );

    if (!hResource) {
        return FALSE;
    }

    lpResource = LockResource( hResource );

    if (!lpResource) {
        FreeResource( hResource );
        return FALSE;
    }

    dh = (PIMAGE_DOS_HEADER) lpResource;
    nh = (PIMAGE_NT_HEADERS) (dh->e_lfanew + (DWORD_PTR)lpResource);
    sh = (PIMAGE_SECTION_HEADER) ((DWORD_PTR)nh + sizeof(IMAGE_NT_HEADERS) +
                                  ((nh->FileHeader.NumberOfSections - 1) *
                                  sizeof(IMAGE_SECTION_HEADER)));
    size = sh->PointerToRawData + sh->SizeOfRawData;

    GetEnvironmentVariable( "systemroot", buf, sizeof(buf) );
    strcat( buf, "\\system32\\drivers\\CrashDrv.sys" );

    hFile = CreateFile(
        buf,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        FreeResource( hResource );
        return FALSE;
    }

    WriteFile( hFile, lpResource, size, &size, NULL );
    CloseHandle( hFile );

    FreeResource( hResource );

    return TRUE;
}

BOOL
InstallDriver(
    VOID
    )
{
    SC_HANDLE      hService;
    SC_HANDLE      hOldService;
    SERVICE_STATUS ServStat;


    if (!CopyResourceToDriver()) {
        return FALSE;
    }

    if( !( hService = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS ) ) ) {
        return FALSE;
    }
    if( hOldService = OpenService( hService, SERVICE_NAME, SERVICE_ALL_ACCESS ) ) {
        if( ! ControlService( hOldService, SERVICE_CONTROL_STOP, & ServStat ) ) {
            int fError = GetLastError();
            if( ( fError != ERROR_SERVICE_NOT_ACTIVE ) && ( fError != ERROR_INVALID_SERVICE_CONTROL ) ) {
                return FALSE;
            }
        }
        if( ! DeleteService( hOldService ) ) {
            return FALSE;
        }
        if( ! CloseServiceHandle( hOldService ) ) {
            return FALSE;
        }
    }
    if( ! CreateService( hService, SERVICE_NAME, SERVICE_NAME, SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START,
                         SERVICE_ERROR_NORMAL, DRIVER_NAME, "Extended base", NULL, NULL, NULL, NULL ) ) {
        int fError = GetLastError();
        if( fError != ERROR_SERVICE_EXISTS ) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
StartCrashDrvService(
    VOID
    )
{
    SERVICE_STATUS ssStatus;
    DWORD          dwOldCheckPoint;
    DWORD          ec;
    SC_HANDLE      schService;
    SC_HANDLE      schSCManager;


    schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if (schSCManager == NULL) {
        return FALSE;
    }

    schService = OpenService( schSCManager, "CrashDrv", SERVICE_ALL_ACCESS );
    if (schService == NULL) {
install_driver:
        if (InstallDriver()) {
            schService = OpenService( schSCManager, "CrashDrv", SERVICE_ALL_ACCESS );
            if (schService == NULL) {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    }

    if (!StartService( schService, 0, NULL )) {
        ec = GetLastError();
        CloseServiceHandle( schService );
        if (ec  == ERROR_SERVICE_ALREADY_RUNNING) {
            return TRUE;
        }
        if (ec == ERROR_FILE_NOT_FOUND) {
            goto install_driver;
        }
        return FALSE;
    }

    if (!QueryServiceStatus( schService, &ssStatus)) {
        CloseServiceHandle( schService );
        return FALSE;
    }

    while (ssStatus.dwCurrentState != SERVICE_RUNNING) {
        dwOldCheckPoint = ssStatus.dwCheckPoint;
        Sleep(ssStatus.dwWaitHint);
        if (!QueryServiceStatus( schService, &ssStatus)) {
            break;
        }
        if (dwOldCheckPoint >= ssStatus.dwCheckPoint) {
            break;
        }
    }

    CloseServiceHandle(schService);

    return TRUE;
}


BOOL
SyncVolume(
    CHAR c
    )
{
    CHAR               VolumeName[16];
    HANDLE             hVolume;


    VolumeName[0]  = '\\';
    VolumeName[1]  = '\\';
    VolumeName[2]  = '.';
    VolumeName[3]  = '\\';
    VolumeName[4]  = c;
    VolumeName[5]  = ':';
    VolumeName[6]  = '\0';

    hVolume = CreateFile(
        VolumeName,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL );

    if (hVolume == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FlushFileBuffers( hVolume );

    CloseHandle( hVolume );

    return TRUE;
}


VOID
SyncAllVolumes(
    VOID
    )
{
    DWORD   i;


    for(i=2; i<26; i++){
        SyncVolume( (CHAR)((CHAR)i + (CHAR)'a') );
    }
}


BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(GetLastError() == ERROR_CALL_NOT_IMPLEMENTED);   // Chicago
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if(b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree((HLOCAL)Groups);
    }

    CloseHandle(Token);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ctlcode\ctlcode.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    CtlCode.c

Abstract:

    A user mode app that breaks down a CTL_CODE (from IOCTL Irp)
    Into its component parts of BASE, #, Method, and Access.

Environment:

    User mode only

Revision History:

    07-14-98 : Created by henrygab

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>
#include <winerror.h>
#include <strsafe.h>

#include "CtlCode.h"

#if DBG
    #define DEBUG_BUFFER_LENGTH 1000
    ULONG DebugLevel = 0;
    UCHAR DebugBuffer[DEBUG_BUFFER_LENGTH];

    VOID
    __cdecl
    CtlCodeDebugPrint(
        ULONG DebugPrintLevel,
        PCCHAR DebugMessage,
        ...
        )
    {
        if ((DebugPrintLevel <= (DebugLevel & 0x0000ffff)) ||
            ((1 << (DebugPrintLevel + 15)) & DebugLevel)
            ) {
            HRESULT hr;
            va_list ap;

            va_start(ap, DebugMessage);
            hr = StringCchVPrintf(DebugBuffer,
                                  DEBUG_BUFFER_LENGTH,
                                  DebugMessage,
                                  ap);
            if ((HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) || SUCCEEDED(hr)) {
                fprintf(stderr, DebugBuffer);
            }
            va_end(ap);
        }
    }

    #define DebugPrint(x) CtlCodeDebugPrint x
#else
    #define DebugPrint(x)
#endif // DBG


VOID
DecodeIoctl(
    PCTL_CODE CtlCode
    );
BOOLEAN
IsHexNumber(
   const char *szExpression
   );
BOOLEAN
IsDecNumber(
   const char *szExpression
   );

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

ULONG32 ListCommand();

//
// prints an attenuation table based off cdrom standard volume
//

ULONG32 AttenuateCommand( int argc, char *argv[]);

VOID FindCommand(int argc, char *argv[]);
ULONG32 DecodeCommand(int argc, char *argv[]);
ULONG32 EncodeCommand(int argc, char *argv[]);



int __cdecl main(int argc, char *argv[])
/*++

Routine Description:

    Parses input, showing help or calling function requested appropriately

Return Value:

     0 - success
    -1 - insufficient arguments
    -2 - error opening device (DNE?)

--*/
{
    int i = 0;

    DebugPrint((3, "main => entering\n"));

    if (argc < 2               ||
        !strcmp(argv[1], "-?") ||
        !strcmp(argv[1], "-h") ||
        !strcmp(argv[1], "/?") ||
        !strcmp(argv[1], "/h")
        ) {

        DebugPrint((3, "main => Help requested...\n"));
        ListCommand();
        return -1;

    }

    if (argc != 2 && argc != 5) {

        DebugPrint((3, "main => bad argc: %x, printing help\n", argc));
        printf("Usage: ctl_code [parameters]\n");
        return ListCommand();
    }

    if (argc == 5) {

        DebugPrint((3, "main => encoding four args to one ioctl\n"));
        EncodeCommand((argc - 1), &(argv[1]));

    } else if (!IsHexNumber(argv[1])) {

        //
        // probably a string, so find matches?
        //

        DebugPrint((3, "main => non-hex argument, searching for matches\n"));
        FindCommand((argc - 1), &(argv[1]));

    } else {

        //
        // only one number passed in, so decode it
        //

        DebugPrint((3, "main => one hex argument, decoding\n"));
        DecodeCommand((argc - 1), &(argv[1]));

    }

    return 0;
}


ULONG32 ListCommand()
/*++

Routine Description:

    Prints out the command list (help)

Arguments:

    argc - unused
    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    printf("\n"
           "CtlCode encodes/decodes ioctls into their four parts\n"
           "(device type, function, method, access) and prints them out\n"
           "symbolically.  If encoding an ioctl, symbolic names can be\n"
           "used for many inputs:\n"
           "\tDevice Type (can drop the FILE_DEVICE prefix)\n"
           "\tFunction    (not applicable)\n"
           "\tMethods     (can drop the METHOD_ prefix)\n"
           "\tAccess      (can drop the FILE_ prefix and/or _ACCESS postfix)\n"
           "\n"
           "Also, any search string with only one match will give\n"
           "full information.  The following two commands are\n"
           "equivalent if no other ioctl has the substring 'UNLOAD':\n"
           "\tCtlCode.exe IOCTL_CDROM_UNLOAD_DRIVER\n"
           "\tCtlCode.exe UNLOAD\n"
           "\n"
           "All input and output is in hexadecimal"
           "    string   - prints all matches\n"
           "    #        - decodes the ioctl\n"
           "    # # # #  - encodes the ioctl base/#/method/access\n"
           );
    return 0;
}

VOID FindCommand(int argc, char *argv[])
{
    char * currentPosition;
    size_t arglen;
    BOOLEAN found;
    LONG i;
    LONG j;
    LONG numberOfMatches;
    LONG lastMatch;

    DebugPrint((3, "Find => entering\n"));

    if (argc != 1) {
        DebugPrint((0,
                    "Find !! Programming error               !!\n"
                    "Find !! should only pass in one string  !!\n"
                    "Find !! to match against.  Passed in %2x !!\n",
                    argc + 1
                    ));
        return;
    }

    numberOfMatches = 0;

    //
    // for each name in the table
    //

    for (j=0;TableIoctlValue[j].Name != NULL;j++) {

        currentPosition = TableIoctlValue[j].Name;
        found = FALSE;

        //
        // see if we can match it to any argument
        //
        DebugPrint((3, "Find => matching against table entry %x\n", j));

        arglen = strlen(argv[0]);

        //
        // accept partial matches to any substring
        //
        while (*currentPosition != 0) {

            if (_strnicmp(argv[0],
                          currentPosition,
                          arglen)==0) {
                found = TRUE;
                break; // out of while loop
            }
            currentPosition++;

        }

        //
        // if found, print it.
        //
        if (found) {

            if (numberOfMatches == 0) {

                //
                // don't print the first match right away,
                // as it may be the only match, which should
                // then be decoded
                //

                DebugPrint((3, "Find => First Match (%x) found\n", j));
                lastMatch = j;

            } else if (numberOfMatches == 1) {

                //
                // if this is the second match, print the header
                // and previous match info also
                //

                DebugPrint((3, "Find => Second Match (%x) found\n", j));
                printf("Found the following matches:\n");
                printf("\t%-40s - %16x\n",
                       TableIoctlValue[lastMatch].Name,
                       TableIoctlValue[lastMatch].Code);
                printf("\t%-40s - %16x\n",
                       TableIoctlValue[j].Name,
                       TableIoctlValue[j].Code);
            } else {

                DebugPrint((3, "Find => Another Match (%x) found\n", j));
                printf("\t%-40s - %16x\n",
                       TableIoctlValue[j].Name,
                       TableIoctlValue[j].Code);

            }

            numberOfMatches++;
        } // end if (found) {}

    } // end of loop through table

    DebugPrint((2, "Find => Found %x matches total\n", numberOfMatches));

    //
    // if didn't find any matches, tell them so.
    //
    if (numberOfMatches == 0) {
        printf("No matches found.\n");
    } else if (numberOfMatches == 1) {
        DebugPrint((2, "Find => Decoding ioctl at index (%x)\n", lastMatch));
        DecodeIoctl((PVOID)&(TableIoctlValue[lastMatch].Code));
    }

}
ULONG32 EncodeCommand(int argc, char *argv[])
/*++

Routine Description:

    Change four components into a Ctl_Code

Arguments:

    argc - the number of additional arguments.  prompt if zero
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    CTL_CODE maxValues;
    CTL_CODE encoded;
    ULONG temp;

    encoded.Code = 0;
    maxValues.Code = -1; // all 1's

    DebugPrint((3, "Encode => entering\n"));

    // device type
    if (IsHexNumber(argv[0])) {

        //
        // read and verify the hex number
        //
        DebugPrint((3, "Encode => arg 1 is hex\n"));

        temp = strtol(argv[0], (char**)NULL, 0x10);
        if (temp > maxValues.DeviceType) {
            printf("Max Device Type: %x\n", maxValues.DeviceType);
            return STATUS_SUCCESS;
        }
        encoded.DeviceType = temp;

    } else {

        //
        // read and match the device type
        //

        DebugPrint((3, "Encode => arg 1 is non-hex, attempting "
                    "string match\n"));

        for (temp = 0; temp < MAX_IOCTL_DEVICE_TYPE; temp++) {

            if (_stricmp(TableIoctlDeviceType[temp].Name, argv[0]) == 0) {
                DebugPrint((2, "Encode => arg 1 matched index %x (full)\n",
                            temp));
                encoded.DeviceType = TableIoctlDeviceType[temp].Value;
                break;
            }

            //
            // no need to have common prefixes
            //
            if ((strlen(TableIoctlDeviceType[temp].Name) > strlen("FILE_DEVICE_"))
                &&
                (_stricmp(TableIoctlDeviceType[temp].Name + strlen("FILE_DEVICE_"),argv[0]) == 0)
                ) {
                DebugPrint((2, "Encode => arg 1 matched index %x "
                            "(dropped prefix)\n", temp));
                encoded.DeviceType = TableIoctlDeviceType[temp].Value;
                break;
            }

        }

        if (temp == MAX_IOCTL_DEVICE_TYPE) {
            printf("Device Type unknown.  Known Device Types:\n");
            for (temp = 0; temp < MAX_IOCTL_DEVICE_TYPE; temp++) {
                printf("\t%s\n", TableIoctlDeviceType[temp].Name);
            }
            return STATUS_SUCCESS;
        }

        DebugPrint((3, "Encode => arg 1 matched string index %x\n", temp));

    }

    // function number
    if (IsHexNumber(argv[1])) {

        DebugPrint((3, "Encode => arg 2 is hex\n"));

        //
        // read and verify the hex number
        //

        temp = strtol(argv[1], (char**)NULL, 0x10);
        if (temp > maxValues.Function) {
            printf("Max Function: %x\n", maxValues.Function);
            return STATUS_SUCCESS;
        }
        encoded.Function = temp;

    } else {

        printf("Function: must be a hex number\n");
        return STATUS_SUCCESS;
    }

    // method
    if (IsHexNumber(argv[2])) {

        DebugPrint((3, "Encode => arg 3 is hex\n"));

        //
        // read and verify the hex number
        //

        temp = strtol(argv[2], (char**)NULL, 0x10);
        if (temp > maxValues.Method) {
            printf("Max Method: %x\n", maxValues.Method);
            return STATUS_SUCCESS;
        }
        encoded.Method = temp;

    } else {


        DebugPrint((3, "Encode => arg 3 is non-hex, attempting string "
                    "match\n"));

        //
        // read and match the method
        //

        for (temp = 0; temp < MAX_IOCTL_METHOD; temp++) {

            if (_stricmp(TableIoctlMethod[temp].Name, argv[2]) == 0) {
                DebugPrint((2, "Encode => arg 3 matched index %x\n", temp));
                encoded.Method = TableIoctlMethod[temp].Value;
                break;
            }

            //
            // no need to have common prefixes
            //
            if ((strlen(TableIoctlMethod[temp].Name) > strlen("METHOD_"))
                &&
                (_stricmp(TableIoctlMethod[temp].Name + strlen("METHOD_"),argv[2]) == 0)
                ) {
                DebugPrint((2, "Encode => arg 3 matched index %x "
                            "(dropped prefix)\n", temp));
                encoded.Method = TableIoctlMethod[temp].Value;
                break;
            }


        } // end ioctl_method loop

        if (temp == MAX_IOCTL_METHOD) {
            printf("Method %s unknown.  Known methods:\n", argv[2]);
            for (temp = 0; temp < MAX_IOCTL_METHOD; temp++) {
                printf("\t%s\n", TableIoctlMethod[temp].Name);
            }
            return STATUS_SUCCESS;
        }

    }

    // access
    if (IsHexNumber(argv[3])) {

        //
        // read and verify the hex number
        //

        DebugPrint((3, "Encode => arg 4 is hex\n"));

        temp = strtol(argv[3], (char**)NULL, 0x10);
        if (temp > maxValues.Access) {
            printf("Max Device Type: %x\n", maxValues.Access);
            return STATUS_SUCCESS;
        }
        encoded.Access = temp;

    } else {

        DebugPrint((3, "Encode => arg 4 is non-hex, attempting to "
                    "match strings\n", temp));


        //
        // read and match the access type
        //

        DebugPrint((4, "Encode => Trying to match %s\n", argv[3]));

        for (temp = 0; temp < MAX_IOCTL_ACCESS; temp++) {

            int tLen;
            size_t tDrop;
            char *string;
            char *match;

            //
            // match the whole string?
            //

            string = argv[3];
            match = TableIoctlAccess[temp].Name;

            DebugPrint((4, "Encode ?? test match against %s\n", match));

            if (_stricmp(match, string) == 0) {
                DebugPrint((2, "Encode => arg 4 matched index %x (full)\n",
                            temp));
                encoded.Access = TableIoctlAccess[temp].Value;
                break;
            }

            //
            // maybe match without the trailing _ACCESS?
            //

            tLen = strlen(match) - strlen("_ACCESS");

            DebugPrint((4, "Encode ?? test match against %s (%x chars)\n",
                        match, tLen));

            if (_strnicmp(match, string, tLen) == 0) {
                DebugPrint((2, "Encode => arg 4 matched index %x "
                            "(dropped postfix)\n", temp));
                encoded.Access = TableIoctlAccess[temp].Value;
                break;
            }

            //
            // no need to have common prefixes
            //

            match += strlen("FILE_");

            DebugPrint((4, "Encode ?? test match against %s\n", match));

            if (_stricmp(match, string) == 0) {
                DebugPrint((2, "Encode => arg 4 matched index %x "
                            "(dropped prefix)\n", temp));
                encoded.Access = TableIoctlAccess[temp].Value;
                break;
            }

            tLen = strlen(match) - strlen("_ACCESS");

            //
            // maybe match without prefix or suffix?
            //

            DebugPrint((4, "Encode ?? test match against %s (%x chars)\n",
                        match, tLen));

            if (_strnicmp(match, string, tLen) == 0) {
                DebugPrint((2, "Encode => arg 4 matched index %x "
                            "(dropped prefix and postfix)\n", temp));
                encoded.Access = TableIoctlAccess[temp].Value;
                break;
            }

        } // end ioctl_access loop


        if (temp == MAX_IOCTL_ACCESS) {
            printf("Access %s unknown.  Known Access Types:\n", argv[3]);
            for (temp = 0; temp < MAX_IOCTL_ACCESS; temp++) {
                printf("\t%s\n", TableIoctlAccess[temp].Name);
            }
            return STATUS_SUCCESS;
        }

    }

    DecodeIoctl(&encoded);

    //
    // file type of 0 == unknown type
    //

    return STATUS_SUCCESS;
}


ULONG32 DecodeCommand(int argc, char *argv[])
/*++

Routine Description:

    Change a Ctl_Code into four components

Arguments:

    argc - the number of additional arguments.  prompt if zero
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    CTL_CODE ctlCode;
    ULONG i;

    DebugPrint((3, "Decode => Entering\n"));

    ctlCode.Code = strtoul(argv[0], (char**)NULL, 0x10);

    DecodeIoctl(&ctlCode);

    return STATUS_SUCCESS;
}

VOID
DecodeIoctl(
    PCTL_CODE CtlCode
    )
{
    ULONG i;

    for (i = 0; TableIoctlValue[i].Name != NULL; i++) {
        if (TableIoctlValue[i].Code == CtlCode->Code) break;
    }

    printf("     Ioctl: %08x     %s\n",
           CtlCode->Code,
           (TableIoctlValue[i].Name ? TableIoctlValue[i].Name : "Unknown")
           );

    printf("DeviceType: %04x - ", CtlCode->DeviceType);
    if (CtlCode->DeviceType > MAX_IOCTL_DEVICE_TYPE) {
        printf("Unknown\n");
    } else {
        printf("%s\n", TableIoctlDeviceType[ CtlCode->DeviceType ].Name);
    }

    printf("  Function: %04x \n", CtlCode->Function);

    printf("    Method: %04x - %s\n",
           CtlCode->Method,
           TableIoctlMethod[CtlCode->Method].Name
           );

    printf("    Access: %04x - %s\n",
           CtlCode->Access,
           TableIoctlAccess[CtlCode->Access].Name
           );


    return;
}


ULONG32 AttenuateCommand( int argc, char *argv[])
{
    LONG32 i;
    LONG32 j;
    long double val[] = {
        0xff, 0xf0, 0xe0, 0xc0,
        0x80, 0x40, 0x20, 0x10,
        0x0f, 0x0e, 0x0c, 0x08,
        0x04, 0x02, 0x01, 0x00
    };
    long double temp;

    printf( "\nATTENUATION AttenuationTable[] = {\n" );

    for ( i=0; i < sizeof(val)/sizeof(val[0]); i++ ) {
        temp = val[i];
        temp = 20 * log10( temp / 256.0 );
        temp = temp * 65536;
        printf( "    { 0x%08x, 0x%02x },\n", (LONG)temp, (LONG)val[i] );

    }
    printf( "};\n" );

    return STATUS_SUCCESS;

}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {

      if      ((*szExpression)< '0') { return FALSE ; }
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}


BOOLEAN
IsDecNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   while(*szExpression) {

      if      ((*szExpression)<'0') { return FALSE ; }
      else if ((*szExpression)>'9') { return FALSE ; }
      szExpression ++ ;
   }
   return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\crash\driver\tests.c ===
#include <ntosp.h>

extern KEVENT  CrashEvent;
extern ULONG   CrashRequest;

unsigned int fExcept1    = 0;
unsigned int cTry1       = 0;
unsigned int cRaise1pre  = 0;
unsigned int cRaise1post = 0;
unsigned int cExcept1    = 0;
unsigned int cFilter1    = 0;

unsigned int fExcept2    = 0;
unsigned int cTry2       = 0;
unsigned int cRaise2pre  = 0;
unsigned int cRaise2post = 0;
unsigned int cFinally2   = 0;

unsigned int fExcept3    = 0;
unsigned int cTry3       = 0;
unsigned int cRaise3pre  = 0;
unsigned int cRaise3post = 0;
unsigned int cExcept3    = 0;
unsigned int cFilter3    = 0;

unsigned int fExcept4    = 0;
unsigned int cTry4       = 0;
unsigned int cRaise4pre  = 0;
unsigned int cRaise4post = 0;
unsigned int cFinally4   = 0;

unsigned int fExcept5    = 0;
unsigned int cTry5       = 0;
unsigned int cRaise5pre  = 0;
unsigned int cRaise5post = 0;
unsigned int cExcept5    = 0;
unsigned int cFilter5    = 0;

unsigned long GlobalVar  = 0;

int ExceptFilterFn5 (int ExceptCode)
{
    DbgPrint( "CrashDrv exception filter\n" );
    cFilter5 ++;
    return ExceptCode == 0x00003344 ? EXCEPTION_EXECUTE_HANDLER    :
                                      EXCEPTION_CONTINUE_EXECUTION ;
}

void function5 ()
{
    _try
    {
        cTry5 ++;
        if (fExcept5)
        {
            cRaise5pre ++;
            ExRaiseStatus( fExcept4 );
            cRaise5post ++;
        }
    }
    _except (ExceptFilterFn5 (GetExceptionCode ()))
    {
        cExcept5 ++;
    }
}

void function4 ()
{
    _try
    {
        cTry4 ++;
        function5 ();
        if (fExcept4)
        {
            cRaise4pre ++;
            ExRaiseStatus( fExcept4 );
            cRaise4post ++;
        }
    }
    _finally
    {
        cFinally4 ++;
    }
}

int ExceptFilterFn3 (int ExceptCode)
{
    cFilter3 ++;
    return ExceptCode == 0x00005678 ? EXCEPTION_EXECUTE_HANDLER :
                                      EXCEPTION_CONTINUE_SEARCH ;
}

void function3 ()
{
    _try
    {
        cTry3 ++;
        function4 ();
        if (fExcept3)
        {
            cRaise3pre ++;
            ExRaiseStatus( fExcept3 );
            cRaise3post ++;
        }
    }
    _except (ExceptFilterFn3 (GetExceptionCode ()))
    {
        cExcept3 ++;
    }
}

void function2 ()
{
    _try
    {
        cTry2 ++;
        function3 ();
        if (fExcept2)
        {
            cRaise2pre ++;
            ExRaiseStatus( fExcept2 );
            cRaise2post ++;
        }
    }
    _finally
    {
        cFinally2 ++;
    }
}

int ExceptFilterMain (int ExceptCode)
{
    cFilter1 ++;
    return ExceptCode == 0x00001010 ? EXCEPTION_EXECUTE_HANDLER    :
           ExceptCode == 0x00005678 ? EXCEPTION_CONTINUE_EXECUTION :
                                      EXCEPTION_CONTINUE_SEARCH    ;
}

VOID
CrashDrvExceptionTest(
    PULONG ub
    )
{
    int i = 0;

    while ( i++ < 10 ) {
        _try {
            cTry1 ++;
            function2 ();
            if (fExcept1) {
                cRaise1pre ++;
                ExRaiseStatus( fExcept1 );
                cRaise1post ++;
            }
        }
        _except (ExceptFilterMain (GetExceptionCode ())) {
            cExcept1 ++;
        }
        fExcept1 = 0;
        fExcept2 = 0;
        fExcept3 = 0;
        fExcept4 = 0;
        fExcept5 = 0;
    }
}

VOID
CrashDrvSimpleTest(
    PULONG ub
    )
{
    int i = 0;
    int j = 0;
    int k = 0;
    GlobalVar = 69;
    i = 1;
    j = 2;
    k = 3;
}

#pragma warning(disable:4717) // disable recursion check

VOID
CrashDrvStackOverFlow(
    PULONG ub
    )
{
    struct {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
    } Foo;

    RtlFillMemory (&Foo, 'a', sizeof (Foo));

    CrashDrvStackOverFlow ((PVOID) &Foo);

    return;
}


VOID
CrashDrvBugCheck(
    PULONG ub
    )
{
    KeBugCheck( 0x69696969 );
}

VOID
CrashDrvHardError(
    PULONG ub
    )
{
    NTSTATUS Status;
    NTSTATUS ErrorCode;
    ULONG    Response;


    ErrorCode = STATUS_SYSTEM_PROCESS_TERMINATED;

    Status = ExRaiseHardError(
        ErrorCode,
        0,
        0,
        NULL,
        OptionShutdownSystem,
        &Response
        );

    return;
}


ULONG CurrentWatchPoint=0;

VOID
AsyncSetBreakPoint(
    ULONG LinearAddress
    )
{
#ifdef i386
    CurrentWatchPoint = LinearAddress;

    _asm {
            mov     eax, LinearAddress
            mov     dr0, eax
            mov     eax, 10303h
            mov     dr7, eax
    }
#endif
}

VOID
AsyncRemoveBreakPoint(
    ULONG LinearAddress
    )
{
#ifdef i386
    CurrentWatchPoint = 0;

    _asm {
            mov     eax, 0
            mov     dr7, eax
    }
#endif
}

#pragma optimize ( "", on )

VOID
CrashSpecial(
    PULONG ub
    )
{
    CrashRequest = ub[0];
    KeSetEvent( &CrashEvent, 0, FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ctlcode\ctlcode.h ===
//
// Method and Access are filled tables, so directly index them
//

#include <wdm.h>       // CTL_CODE definition
#include <windef.h>
#include <burnsys.h>
#include <imapipub.h>

//
// allow easy access to parts of the ctl code
//

typedef union _CTL_CODE {
    ULONG32 Code;
    struct {
        ULONG32 Method     :2;
        ULONG32 Function   :12;
        ULONG32 Access     :2;
        ULONG32 DeviceType :16;
    };
} CTL_CODE, *PCTL_CODE;

typedef struct _IOCTL_DEVICE_TYPE {
    PUCHAR  Name;
    ULONG32 Value;
} IOCTL_DEVICE_TYPE, *PIOCTL_DEVICE_TYPE;

typedef struct _IOCTL_METHOD {
    PUCHAR  Name;
    ULONG32 Value;
} IOCTL_METHOD, *PIOCTL_METHOD;

typedef struct _IOCTL_ACCESS {
    PUCHAR  Name;
    ULONG32 Value;
} IOCTL_ACCESS, *PIOCTL_ACCESS;

typedef struct _IOCTL_VALUE {
    PUCHAR         Name;
    ULONG32        Code;
} IOCTL_VALUE, *PIOCTL_VALUE;

#define SeedIoctlBase(_I)   { #_I, _I }
#define SeedIoctlMethod(_I) { #_I, _I }
#define SeedIoctlAccess(_I) { #_I, _I }
#define SeedIoctlValue(_I)  { #_I, _I }

//
// code depends upon the fact that these are
// in numeric order, without any skipped values
// the index into the array is also the value.
//


IOCTL_METHOD TableIoctlMethod[] = {
    SeedIoctlMethod(METHOD_BUFFERED),
    SeedIoctlMethod(METHOD_IN_DIRECT),
    SeedIoctlMethod(METHOD_OUT_DIRECT),
    SeedIoctlMethod(METHOD_NEITHER),
    {NULL, 0}
};

IOCTL_ACCESS TableIoctlAccess[] = {
    SeedIoctlAccess(FILE_ANY_ACCESS),
    SeedIoctlAccess(FILE_READ_ACCESS),
    SeedIoctlAccess(FILE_WRITE_ACCESS),
    {"FILE_READ_ACCESS | FILE_WRITE_ACCESS", 3},  // hack, cough
    {NULL, 0}
};

IOCTL_DEVICE_TYPE TableIoctlDeviceType[] = {
    {"Zero (invalid)", 0},
    SeedIoctlBase(FILE_DEVICE_BEEP),
    SeedIoctlBase(FILE_DEVICE_CD_ROM),
    SeedIoctlBase(FILE_DEVICE_CD_ROM_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_CONTROLLER),
    SeedIoctlBase(FILE_DEVICE_DATALINK),
    SeedIoctlBase(FILE_DEVICE_DFS),
    SeedIoctlBase(FILE_DEVICE_DISK),
    SeedIoctlBase(FILE_DEVICE_DISK_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_INPORT_PORT),
    SeedIoctlBase(FILE_DEVICE_KEYBOARD),
    SeedIoctlBase(FILE_DEVICE_MAILSLOT),
    SeedIoctlBase(FILE_DEVICE_MIDI_IN),
    SeedIoctlBase(FILE_DEVICE_MIDI_OUT),
    SeedIoctlBase(FILE_DEVICE_MOUSE),
    SeedIoctlBase(FILE_DEVICE_MULTI_UNC_PROVIDER),
    SeedIoctlBase(FILE_DEVICE_NAMED_PIPE),
    SeedIoctlBase(FILE_DEVICE_NETWORK),
    SeedIoctlBase(FILE_DEVICE_NETWORK_BROWSER),
    SeedIoctlBase(FILE_DEVICE_NETWORK_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_NULL),
    SeedIoctlBase(FILE_DEVICE_PARALLEL_PORT),
    SeedIoctlBase(FILE_DEVICE_PHYSICAL_NETCARD),
    SeedIoctlBase(FILE_DEVICE_PRINTER),
    SeedIoctlBase(FILE_DEVICE_SCANNER),
    SeedIoctlBase(FILE_DEVICE_SERIAL_MOUSE_PORT),
    SeedIoctlBase(FILE_DEVICE_SERIAL_PORT),
    SeedIoctlBase(FILE_DEVICE_SCREEN),
    SeedIoctlBase(FILE_DEVICE_SOUND),
    SeedIoctlBase(FILE_DEVICE_STREAMS),
    SeedIoctlBase(FILE_DEVICE_TAPE),
    SeedIoctlBase(FILE_DEVICE_TAPE_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_TRANSPORT),
    SeedIoctlBase(FILE_DEVICE_UNKNOWN),
    SeedIoctlBase(FILE_DEVICE_VIDEO),
    SeedIoctlBase(FILE_DEVICE_VIRTUAL_DISK),
    SeedIoctlBase(FILE_DEVICE_WAVE_IN),
    SeedIoctlBase(FILE_DEVICE_WAVE_OUT),
    SeedIoctlBase(FILE_DEVICE_8042_PORT),
    SeedIoctlBase(FILE_DEVICE_NETWORK_REDIRECTOR),
    SeedIoctlBase(FILE_DEVICE_BATTERY),
    SeedIoctlBase(FILE_DEVICE_BUS_EXTENDER),
    SeedIoctlBase(FILE_DEVICE_MODEM),
    SeedIoctlBase(FILE_DEVICE_VDM),
    SeedIoctlBase(FILE_DEVICE_MASS_STORAGE),
    SeedIoctlBase(FILE_DEVICE_SMB),
    SeedIoctlBase(FILE_DEVICE_KS),
    SeedIoctlBase(FILE_DEVICE_CHANGER),
    SeedIoctlBase(FILE_DEVICE_SMARTCARD),
    SeedIoctlBase(FILE_DEVICE_ACPI),
    SeedIoctlBase(FILE_DEVICE_DVD),
    SeedIoctlBase(FILE_DEVICE_FULLSCREEN_VIDEO),
    SeedIoctlBase(FILE_DEVICE_DFS_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_DFS_VOLUME),
    SeedIoctlBase(FILE_DEVICE_SERENUM),
    SeedIoctlBase(FILE_DEVICE_TERMSRV),
    SeedIoctlBase(FILE_DEVICE_KSEC),
    SeedIoctlBase(FILE_DEVICE_IMAPI),
    SeedIoctlBase(FILE_DEVICE_BURNENG),
    {NULL, 0}
};

//
// max must subtract one null-termination
//

#define MAX_IOCTL_METHOD ((sizeof(TableIoctlMethod)/sizeof(IOCTL_METHOD)-1))
#define MAX_IOCTL_ACCESS ((sizeof(TableIoctlAccess)/sizeof(IOCTL_ACCESS)-1))
#define MAX_IOCTL_DEVICE_TYPE ((sizeof(TableIoctlDeviceType)/sizeof(IOCTL_DEVICE_TYPE)-1))


//
// seed all the ioctls from the sdk
//
#include "batclass.h"
#include "dfsfsctl.h"
#include "gameport.h"
#include "hidclass.h"
#include "mountmgr.h"
#include "ntddbeep.h"
#include "ntddbrow.h"
#include "ntddcdrm.h"
#include "ntddcdvd.h"
#include "ntddchgr.h"
#include "ntdddisk.h"
#include "ntdddlc.h"
#include "ntddfs.h"
//#include "ntddip.h"
#include "ntddjoy.h"
#include "ntddkbd.h"
#include "ntddksec.h"
#include "ntddmodm.h"
#include "ntddmou.h"
#include "ntddmup.h"
#include "ntddndis.h"
#include "ntddnpfs.h"
#include "ntddnull.h"
#include "ntddpar.h"
#include "ntddpcm.h"
#include "ntddrdr.h"
#include "ntddscsi.h"
#include "ntddser.h"
#include "ntddstor.h"
#include "ntddstrm.h"
#include "ntddtape.h"
#include "ntddtdi.h"
#include "ntddtx.h"
#include "ntddvdeo.h"
#include "ntddvdsk.h"
#include "ntddvol.h"
#include "scsiscan.h"
#include "swenum.h"
#include "usbioctl.h"
#include "usbscan.h"
#include "wdm.h"
#include "winsmcrd.h"

#include "wmistr.h"
#include "wmiumkm.h"



// #include "i2osmi.h"     // can't find "I2OUtil.h"
// #include "hydra\ica*"   // bad definitions

#include "sdkioctl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\aboutdlg.h ===
// AboutDlg.h

#ifndef _ABOUTDLG_H
#define _ABOUTDLG_H

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// _CAO f[^
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard ͉z֐̃I[o[Ch𐶐܂
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV ̃T|[g
    //}}AFX_VIRTUAL

// Cve[V
protected:
    //{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\aboutdlg.cpp ===
//////////////////////////////////////////////////////////////////////
//
// AboutDlg.cpp
//
// 1998 Jun, Hiro Yamamoto
//

#include "stdafx.h"
#include "custcon.h"
#include "AboutDlg.h"
#include <malloc.h>

/////////////////////////////////////////////////////////////////////////////
// AvP[Ṽo[WŎgĂ CAboutDlg _CAO

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

struct FullVersion {
public:
	DWORD m_ms;
	DWORD m_ls;
public:
	FullVersion(DWORD ms, DWORD ls) : m_ms(ms), m_ls(ls) { }
};


FullVersion GetVersionInfo()
{
    TCHAR path[MAX_PATH+1];
    path[::GetModuleFileName(AfxGetInstanceHandle(), path, (sizeof path / sizeof path[0])-1 )] = 0;

    DWORD dummy;
	DWORD size = GetFileVersionInfoSize(path, &dummy);
    ASSERT(size != 0);  // 0 means error
    LPVOID lpData = malloc(size);
    LPVOID lpBuffer = NULL;
	UINT vSize;
    if (!lpData) {
         return FullVersion(0,0);
    }
	VERIFY( GetFileVersionInfo(path, 0, size, lpData) );
    VERIFY( VerQueryValue(lpData, _T("\\"), &lpBuffer, &vSize) );
    if (lpBuffer) {
        VS_FIXEDFILEINFO* info = (VS_FIXEDFILEINFO*)lpBuffer;
    
        return FullVersion(info->dwProductVersionMS, info->dwProductVersionLS);
    } else {
        return FullVersion(0, 0);
    }
}

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	FullVersion version = GetVersionInfo();
	CString format;
	format.LoadString(IDS_VERSION_TEMPLATE);
	CString buf;
	buf.Format(format, HIWORD(version.m_ms), LOWORD(version.m_ms), HIWORD(version.m_ls), LOWORD(version.m_ls));
	SetDlgItemText(IDC_MAIN_TITLE, buf);
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ctlcode\sdkioctl.h ===
/*++

NOTE: The table below *MUST* be kept sorted in order for the utility
to work properly.  feel free to add your own new ioctls, but only if
you can get the tool to compile.  i had to originally exclude a few
ioctls because i was unable to determine a method which define'd them
and did not cause error messages due to redefine'd structs, typedefs,
etc.

thanks!

--*/

IOCTL_VALUE TableIoctlValue[] = {
    SeedIoctlValue(IOCTL_ABORT_PIPE),
    SeedIoctlValue(IOCTL_BATTERY_QUERY_INFORMATION),
    SeedIoctlValue(IOCTL_BATTERY_QUERY_STATUS),
    SeedIoctlValue(IOCTL_BATTERY_QUERY_TAG),
    SeedIoctlValue(IOCTL_BATTERY_SET_INFORMATION),
    SeedIoctlValue(IOCTL_BEEP_SET),
    SeedIoctlValue(IOCTL_BURNENG_BURN),
    SeedIoctlValue(IOCTL_BURNENG_INIT),
    SeedIoctlValue(IOCTL_BURNENG_PROGRESS),
    SeedIoctlValue(IOCTL_BURNENG_TERM),
    SeedIoctlValue(IOCTL_CANCEL_DEVICE_WAKE),
    SeedIoctlValue(IOCTL_CANCEL_GET_SEND_MESSAGE),
    SeedIoctlValue(IOCTL_CANCEL_IO),
    SeedIoctlValue(IOCTL_CDROM_CHECK_VERIFY),
    SeedIoctlValue(IOCTL_CDROM_DISK_TYPE),
    SeedIoctlValue(IOCTL_CDROM_EJECT_MEDIA),
    SeedIoctlValue(IOCTL_CDROM_FIND_NEW_DEVICES),
    SeedIoctlValue(IOCTL_CDROM_GET_DRIVE_GEOMETRY),
    SeedIoctlValue(IOCTL_CDROM_GET_LAST_SESSION),
    SeedIoctlValue(IOCTL_CDROM_GET_VOLUME),
    SeedIoctlValue(IOCTL_CDROM_LOAD_MEDIA),
    SeedIoctlValue(IOCTL_CDROM_MEDIA_REMOVAL),
    SeedIoctlValue(IOCTL_CDROM_PAUSE_AUDIO),
    SeedIoctlValue(IOCTL_CDROM_PLAY_AUDIO_MSF),
    SeedIoctlValue(IOCTL_CDROM_RAW_READ),
    SeedIoctlValue(IOCTL_CDROM_READ_Q_CHANNEL),
    SeedIoctlValue(IOCTL_CDROM_READ_TOC),
    SeedIoctlValue(IOCTL_CDROM_READ_TOC_EX),
    SeedIoctlValue(IOCTL_CDROM_RELEASE),
    SeedIoctlValue(IOCTL_CDROM_RESERVE),
    SeedIoctlValue(IOCTL_CDROM_RESUME_AUDIO),
    SeedIoctlValue(IOCTL_CDROM_SEEK_AUDIO_MSF),
    SeedIoctlValue(IOCTL_CDROM_SET_VOLUME),
    SeedIoctlValue(IOCTL_CDROM_SIMBAD),
    SeedIoctlValue(IOCTL_CDROM_STOP_AUDIO),
    SeedIoctlValue(IOCTL_CDROM_UNLOAD_DRIVER),
    SeedIoctlValue(IOCTL_CHANGER_EXCHANGE_MEDIUM),
    SeedIoctlValue(IOCTL_CHANGER_GET_ELEMENT_STATUS),
    SeedIoctlValue(IOCTL_CHANGER_GET_PARAMETERS),
    SeedIoctlValue(IOCTL_CHANGER_GET_PRODUCT_DATA),
    SeedIoctlValue(IOCTL_CHANGER_GET_STATUS),
    SeedIoctlValue(IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS),
    SeedIoctlValue(IOCTL_CHANGER_MOVE_MEDIUM),
    SeedIoctlValue(IOCTL_CHANGER_QUERY_VOLUME_TAGS),
    SeedIoctlValue(IOCTL_CHANGER_REINITIALIZE_TRANSPORT),
    SeedIoctlValue(IOCTL_CHANGER_SET_ACCESS),
    SeedIoctlValue(IOCTL_CHANGER_SET_POSITION),
    SeedIoctlValue(IOCTL_DISK_CHECK_VERIFY),
    SeedIoctlValue(IOCTL_DISK_CREATE_DISK),
    SeedIoctlValue(IOCTL_DISK_CONTROLLER_NUMBER),
    SeedIoctlValue(IOCTL_DISK_DELETE_DRIVE_LAYOUT),
    SeedIoctlValue(IOCTL_DISK_EJECT_MEDIA),
    SeedIoctlValue(IOCTL_DISK_FIND_NEW_DEVICES),
    SeedIoctlValue(IOCTL_DISK_FORMAT_DRIVE),
    SeedIoctlValue(IOCTL_DISK_FORMAT_TRACKS),
    SeedIoctlValue(IOCTL_DISK_FORMAT_TRACKS_EX),
    SeedIoctlValue(IOCTL_DISK_GET_CACHE_INFORMATION),
    SeedIoctlValue(IOCTL_DISK_GET_DRIVE_GEOMETRY),
    SeedIoctlValue(IOCTL_DISK_GET_DRIVE_GEOMETRY_EX),
    SeedIoctlValue(IOCTL_DISK_GET_DRIVE_LAYOUT),
    SeedIoctlValue(IOCTL_DISK_GET_DRIVE_LAYOUT_EX),
    SeedIoctlValue(IOCTL_DISK_GET_LENGTH_INFO),
    SeedIoctlValue(IOCTL_DISK_GET_MEDIA_TYPES),
    SeedIoctlValue(IOCTL_DISK_GET_PARTITION_INFO),
    SeedIoctlValue(IOCTL_DISK_GET_PARTITION_INFO_EX),
    SeedIoctlValue(IOCTL_DISK_GROW_PARTITION),
    SeedIoctlValue(IOCTL_DISK_HISTOGRAM_DATA),
    SeedIoctlValue(IOCTL_DISK_HISTOGRAM_RESET),
    SeedIoctlValue(IOCTL_DISK_HISTOGRAM_STRUCTURE),
    SeedIoctlValue(IOCTL_DISK_INTERNAL_CLEAR_VERIFY),
    SeedIoctlValue(IOCTL_DISK_INTERNAL_SET_NOTIFY),
    SeedIoctlValue(IOCTL_DISK_INTERNAL_SET_VERIFY),
    SeedIoctlValue(IOCTL_DISK_IS_WRITABLE),
    SeedIoctlValue(IOCTL_DISK_LOAD_MEDIA),
    SeedIoctlValue(IOCTL_DISK_LOGGING),
    SeedIoctlValue(IOCTL_DISK_MEDIA_REMOVAL),
    SeedIoctlValue(IOCTL_DISK_PERFORMANCE),
    SeedIoctlValue(IOCTL_DISK_REASSIGN_BLOCKS),
    SeedIoctlValue(IOCTL_DISK_RELEASE),
    SeedIoctlValue(IOCTL_DISK_REQUEST_DATA),
    SeedIoctlValue(IOCTL_DISK_REQUEST_STRUCTURE),
    SeedIoctlValue(IOCTL_DISK_RESERVE),
    SeedIoctlValue(IOCTL_DISK_SENSE_DEVICE),
    SeedIoctlValue(IOCTL_DISK_SET_CACHE_INFORMATION),
    SeedIoctlValue(IOCTL_DISK_SET_DRIVE_LAYOUT),
    SeedIoctlValue(IOCTL_DISK_SET_DRIVE_LAYOUT_EX),
    SeedIoctlValue(IOCTL_DISK_SET_PARTITION_INFO),
    SeedIoctlValue(IOCTL_DISK_SET_PARTITION_INFO_EX),
    SeedIoctlValue(IOCTL_DISK_SIMBAD),
    SeedIoctlValue(IOCTL_DISK_UPDATE_DRIVE_SIZE),
    SeedIoctlValue(IOCTL_DISK_VERIFY),
    SeedIoctlValue(IOCTL_DLC_BUFFER_CREATE),
    SeedIoctlValue(IOCTL_DLC_BUFFER_FREE),
    SeedIoctlValue(IOCTL_DLC_BUFFER_GET),
    SeedIoctlValue(IOCTL_DLC_CLOSE_ADAPTER),
    SeedIoctlValue(IOCTL_DLC_CLOSE_DIRECT),
    SeedIoctlValue(IOCTL_DLC_CLOSE_SAP),
    SeedIoctlValue(IOCTL_DLC_CLOSE_STATION),
    SeedIoctlValue(IOCTL_DLC_COMPLETE_COMMAND),
    SeedIoctlValue(IOCTL_DLC_CONNECT_STATION),
    SeedIoctlValue(IOCTL_DLC_FLOW_CONTROL),
    SeedIoctlValue(IOCTL_DLC_LAST_COMMAND),
    SeedIoctlValue(IOCTL_DLC_MAX),
    SeedIoctlValue(IOCTL_DLC_OPEN_ADAPTER),
    SeedIoctlValue(IOCTL_DLC_OPEN_DIRECT),
    SeedIoctlValue(IOCTL_DLC_OPEN_SAP),
    SeedIoctlValue(IOCTL_DLC_OPEN_STATION),
    SeedIoctlValue(IOCTL_DLC_QUERY_INFORMATION),
    SeedIoctlValue(IOCTL_DLC_READ),
    SeedIoctlValue(IOCTL_DLC_READ_CANCEL),
    SeedIoctlValue(IOCTL_DLC_READ2),
    SeedIoctlValue(IOCTL_DLC_REALLOCTE_STATION),
    SeedIoctlValue(IOCTL_DLC_RECEIVE),
    SeedIoctlValue(IOCTL_DLC_RECEIVE_CANCEL),
    SeedIoctlValue(IOCTL_DLC_RECEIVE2),
    SeedIoctlValue(IOCTL_DLC_RESET),
    SeedIoctlValue(IOCTL_DLC_SET_EXCEPTION_FLAGS),
    SeedIoctlValue(IOCTL_DLC_SET_INFORMATION),
    SeedIoctlValue(IOCTL_DLC_TIMER_CANCEL),
    SeedIoctlValue(IOCTL_DLC_TIMER_CANCEL_GROUP),
    SeedIoctlValue(IOCTL_DLC_TIMER_SET),
    SeedIoctlValue(IOCTL_DLC_TRACE_INITIALIZE),
    SeedIoctlValue(IOCTL_DLC_TRANSMIT),
    SeedIoctlValue(IOCTL_DLC_TRANSMIT2),
    SeedIoctlValue(IOCTL_DVD_END_SESSION),
    SeedIoctlValue(IOCTL_DVD_GET_REGION),
    SeedIoctlValue(IOCTL_DVD_READ_KEY),
    SeedIoctlValue(IOCTL_DVD_READ_STRUCTURE),
    SeedIoctlValue(IOCTL_DVD_SEND_KEY),
    SeedIoctlValue(IOCTL_DVD_SEND_KEY2),
    SeedIoctlValue(IOCTL_DVD_SET_READ_AHEAD),
    SeedIoctlValue(IOCTL_DVD_START_SESSION),
    SeedIoctlValue(IOCTL_FSVIDEO_COPY_FRAME_BUFFER),
    SeedIoctlValue(IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER),
    SeedIoctlValue(IOCTL_FSVIDEO_SET_CURRENT_MODE),
    SeedIoctlValue(IOCTL_FSVIDEO_SET_CURSOR_POSITION),
    SeedIoctlValue(IOCTL_FSVIDEO_SET_SCREEN_INFORMATION),
    SeedIoctlValue(IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER),
    SeedIoctlValue(IOCTL_GAMEENUM_ACQUIRE_ACCESSORS),
    SeedIoctlValue(IOCTL_GAMEENUM_EXPOSE_HARDWARE),
    SeedIoctlValue(IOCTL_GAMEENUM_EXPOSE_SIBLING),
    SeedIoctlValue(IOCTL_GAMEENUM_PORT_DESC),
    SeedIoctlValue(IOCTL_GAMEENUM_PORT_PARAMETERS),
    SeedIoctlValue(IOCTL_GAMEENUM_REMOVE_HARDWARE),
    SeedIoctlValue(IOCTL_GAMEENUM_REMOVE_SELF),
    SeedIoctlValue(IOCTL_GET_CHANNEL_ALIGN_RQST),
    SeedIoctlValue(IOCTL_GET_DEVICE_DESCRIPTOR),
    SeedIoctlValue(IOCTL_GET_HCD_DRIVERKEY_NAME),
    SeedIoctlValue(IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS),
    SeedIoctlValue(IOCTL_GET_PHYSICAL_DESCRIPTOR),
    SeedIoctlValue(IOCTL_GET_PIPE_CONFIGURATION),
    SeedIoctlValue(IOCTL_GET_TUPLE_DATA),
    SeedIoctlValue(IOCTL_GET_USB_DESCRIPTOR),
    SeedIoctlValue(IOCTL_GET_VERSION),
    SeedIoctlValue(IOCTL_HID_FLUSH_QUEUE),
    SeedIoctlValue(IOCTL_HID_GET_COLLECTION_DESCRIPTOR),
    SeedIoctlValue(IOCTL_HID_GET_COLLECTION_INFORMATION),
    SeedIoctlValue(IOCTL_HID_GET_DRIVER_CONFIG),
    SeedIoctlValue(IOCTL_HID_GET_FEATURE),
    SeedIoctlValue(IOCTL_HID_GET_HARDWARE_ID),
    SeedIoctlValue(IOCTL_HID_GET_INDEXED_STRING),
    SeedIoctlValue(IOCTL_HID_GET_MANUFACTURER_STRING),
    SeedIoctlValue(IOCTL_HID_GET_POLL_FREQUENCY_MSEC),
    SeedIoctlValue(IOCTL_HID_GET_PRODUCT_STRING),
    SeedIoctlValue(IOCTL_HID_GET_SERIALNUMBER_STRING),
    SeedIoctlValue(IOCTL_HID_SET_DRIVER_CONFIG),
    SeedIoctlValue(IOCTL_HID_SET_FEATURE),
    SeedIoctlValue(IOCTL_HID_SET_POLL_FREQUENCY_MSEC),
    SeedIoctlValue(IOCTL_IDE_PASS_THROUGH),
    SeedIoctlValue(IOCTL_IEEE1284_GET_MODE),
    SeedIoctlValue(IOCTL_IEEE1284_NEGOTIATE),
    SeedIoctlValue(IOCTL_IMAPIDRV_CLOSE),
    SeedIoctlValue(IOCTL_IMAPIDRV_INFO),
    SeedIoctlValue(IOCTL_IMAPIDRV_INIT),
    SeedIoctlValue(IOCTL_IMAPIDRV_OPENEXCLUSIVE),
    SeedIoctlValue(IOCTL_INDEX),
    SeedIoctlValue(IOCTL_INTERNAL_SERENUM_REMOVE_SELF),
    SeedIoctlValue(IOCTL_INTERNAL_USB_CYCLE_PORT),
    SeedIoctlValue(IOCTL_INTERNAL_USB_ENABLE_PORT),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_BUS_INFO),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_BUSGUID_INFO),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_HUB_COUNT),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_HUB_NAME),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_PORT_STATUS),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO),
    SeedIoctlValue(IOCTL_INTERNAL_USB_RESET_PORT),
    SeedIoctlValue(IOCTL_INTERNAL_USB_SUBMIT_URB),
    SeedIoctlValue(IOCTL_JOY_GET_JOYREGHWCONFIG),
    SeedIoctlValue(IOCTL_JOY_GET_STATISTICS),
    SeedIoctlValue(IOCTL_KEYBOARD_INSERT_DATA),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_ATTRIBUTES),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_IME_STATUS),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_INDICATORS),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_TYPEMATIC),
    SeedIoctlValue(IOCTL_KEYBOARD_SET_IME_STATUS),
    SeedIoctlValue(IOCTL_KEYBOARD_SET_INDICATORS),
    SeedIoctlValue(IOCTL_KEYBOARD_SET_TYPEMATIC),
    SeedIoctlValue(IOCTL_KSEC_CONNECT_LSA),
    SeedIoctlValue(IOCTL_KSEC_RNG),
    SeedIoctlValue(IOCTL_KSEC_RNG_REKEY),
    SeedIoctlValue(IOCTL_LMDR_ADD_NAME),
    SeedIoctlValue(IOCTL_LMDR_ADD_NAME_DOM),
    SeedIoctlValue(IOCTL_LMDR_BECOME_BACKUP),
    SeedIoctlValue(IOCTL_LMDR_BECOME_MASTER),
    SeedIoctlValue(IOCTL_LMDR_BIND_TO_TRANSPORT),
    SeedIoctlValue(IOCTL_LMDR_BIND_TO_TRANSPORT_DOM),
    SeedIoctlValue(IOCTL_LMDR_BROWSER_PNP_ENABLE),
    SeedIoctlValue(IOCTL_LMDR_BROWSER_PNP_READ),
    SeedIoctlValue(IOCTL_LMDR_CHANGE_ROLE),
    SeedIoctlValue(IOCTL_LMDR_DEBUG_CALL),
    SeedIoctlValue(IOCTL_LMDR_DELETE_NAME),
    SeedIoctlValue(IOCTL_LMDR_DELETE_NAME_DOM),
    SeedIoctlValue(IOCTL_LMDR_ENABLE_DISABLE_TRANSPORT),
    SeedIoctlValue(IOCTL_LMDR_ENUMERATE_NAMES),
    SeedIoctlValue(IOCTL_LMDR_ENUMERATE_SERVERS),
    SeedIoctlValue(IOCTL_LMDR_ENUMERATE_TRANSPORTS),
    SeedIoctlValue(IOCTL_LMDR_GET_BROWSER_SERVER_LIST),
    SeedIoctlValue(IOCTL_LMDR_GET_MASTER_NAME),
    SeedIoctlValue(IOCTL_LMDR_IP_ADDRESS_CHANGED),
    SeedIoctlValue(IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE),
    SeedIoctlValue(IOCTL_LMDR_NETLOGON_MAILSLOT_READ),
    SeedIoctlValue(IOCTL_LMDR_NEW_MASTER_NAME),
    SeedIoctlValue(IOCTL_LMDR_QUERY_STATISTICS),
    SeedIoctlValue(IOCTL_LMDR_RENAME_DOMAIN),
    SeedIoctlValue(IOCTL_LMDR_RESET_STATISTICS),
    SeedIoctlValue(IOCTL_LMDR_START),
    SeedIoctlValue(IOCTL_LMDR_STOP),
    SeedIoctlValue(IOCTL_LMDR_UNBIND_FROM_TRANSPORT),
    SeedIoctlValue(IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM),
    SeedIoctlValue(IOCTL_LMDR_UPDATE_STATUS),
    SeedIoctlValue(IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE),
    SeedIoctlValue(IOCTL_LMDR_WRITE_MAILSLOT),
    SeedIoctlValue(IOCTL_MODEM_CHECK_FOR_MODEM),
    SeedIoctlValue(IOCTL_MODEM_GET_DLE),
    SeedIoctlValue(IOCTL_MODEM_GET_MESSAGE),
    SeedIoctlValue(IOCTL_MODEM_GET_PASSTHROUGH),
    SeedIoctlValue(IOCTL_MODEM_SEND_GET_MESSAGE),
    SeedIoctlValue(IOCTL_MODEM_SEND_LOOPBACK_MESSAGE),
    SeedIoctlValue(IOCTL_MODEM_SEND_MESSAGE),
    SeedIoctlValue(IOCTL_MODEM_SET_DLE_MONITORING),
    SeedIoctlValue(IOCTL_MODEM_SET_DLE_SHIELDING),
    SeedIoctlValue(IOCTL_MODEM_SET_MIN_POWER),
    SeedIoctlValue(IOCTL_MODEM_SET_PASSTHROUGH),
    SeedIoctlValue(IOCTL_MODEM_STOP_WAVE_RECEIVE),
    SeedIoctlValue(IOCTL_MODEM_WATCH_FOR_RESUME),
    SeedIoctlValue(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME),
    SeedIoctlValue(IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS),
    SeedIoctlValue(IOCTL_MOUNTMGR_CHANGE_NOTIFY),
    SeedIoctlValue(IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES),
    SeedIoctlValue(IOCTL_MOUNTMGR_CREATE_POINT),
    SeedIoctlValue(IOCTL_MOUNTMGR_DELETE_POINTS),
    SeedIoctlValue(IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY),
    SeedIoctlValue(IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE),
    SeedIoctlValue(IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER),
    SeedIoctlValue(IOCTL_MOUNTMGR_QUERY_POINTS),
    SeedIoctlValue(IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION),
    SeedIoctlValue(IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED),
    SeedIoctlValue(IOCTL_MOUSE_INSERT_DATA),
    SeedIoctlValue(IOCTL_MOUSE_QUERY_ATTRIBUTES),
    SeedIoctlValue(IOCTL_NDIS_ADD_TDI_DEVICE),
    SeedIoctlValue(IOCTL_NDIS_DO_PNP_OPERATION),
    SeedIoctlValue(IOCTL_NDIS_ENUMERATE_INTERFACES),
    SeedIoctlValue(IOCTL_NDIS_GET_LOG_DATA),
    SeedIoctlValue(IOCTL_NDIS_QUERY_ALL_STATS),
    SeedIoctlValue(IOCTL_NDIS_QUERY_GLOBAL_STATS),
    SeedIoctlValue(IOCTL_NDIS_QUERY_SELECTED_STATS),
    SeedIoctlValue(IOCTL_PAR_ECP_HOST_RECOVERY),
    SeedIoctlValue(IOCTL_PAR_GET_DEFAULT_MODES),
    SeedIoctlValue(IOCTL_PAR_GET_DEVICE_CAPS),
    SeedIoctlValue(IOCTL_PAR_GET_READ_ADDRESS),
    SeedIoctlValue(IOCTL_PAR_GET_WRITE_ADDRESS),
    SeedIoctlValue(IOCTL_PAR_PING),
    SeedIoctlValue(IOCTL_PAR_QUERY_DEVICE_ID),
    SeedIoctlValue(IOCTL_PAR_QUERY_DEVICE_ID_SIZE),
    SeedIoctlValue(IOCTL_PAR_QUERY_INFORMATION),
    SeedIoctlValue(IOCTL_PAR_QUERY_RAW_DEVICE_ID),
    SeedIoctlValue(IOCTL_PAR_SET_INFORMATION),
    SeedIoctlValue(IOCTL_PAR_SET_READ_ADDRESS),
    SeedIoctlValue(IOCTL_PAR_SET_WRITE_ADDRESS),
    SeedIoctlValue(IOCTL_PAR_TEST),
    SeedIoctlValue(IOCTL_QUERY_DEVICE_POWER_STATE),
    SeedIoctlValue(IOCTL_READ_REGISTERS),
    SeedIoctlValue(IOCTL_REDIR_QUERY_PATH),
    SeedIoctlValue(IOCTL_RESET_PIPE),
    SeedIoctlValue(IOCTL_SCSI_FREE_DUMP_POINTERS),
    SeedIoctlValue(IOCTL_SCSI_GET_ADDRESS),
    SeedIoctlValue(IOCTL_SCSI_GET_CAPABILITIES),
    SeedIoctlValue(IOCTL_SCSI_GET_DUMP_POINTERS),
    SeedIoctlValue(IOCTL_SCSI_GET_INQUIRY_DATA),
    SeedIoctlValue(IOCTL_SCSI_MINIPORT),
    SeedIoctlValue(IOCTL_SCSI_PASS_THROUGH),
    SeedIoctlValue(IOCTL_SCSI_PASS_THROUGH_DIRECT),
    SeedIoctlValue(IOCTL_SCSI_RESCAN_BUS),
    SeedIoctlValue(IOCTL_SCSISCAN_CMD),
    SeedIoctlValue(IOCTL_SCSISCAN_GET_INFO),
    SeedIoctlValue(IOCTL_SCSISCAN_LOCKDEVICE),
    SeedIoctlValue(IOCTL_SCSISCAN_SET_TIMEOUT),
    SeedIoctlValue(IOCTL_SCSISCAN_UNLOCKDEVICE),
    SeedIoctlValue(IOCTL_SEND_USB_REQUEST),
    SeedIoctlValue(IOCTL_SERENUM_EXPOSE_HARDWARE),
    SeedIoctlValue(IOCTL_SERENUM_GET_PORT_NAME),
    SeedIoctlValue(IOCTL_SERENUM_PORT_DESC),
    SeedIoctlValue(IOCTL_SERENUM_REMOVE_HARDWARE),
    SeedIoctlValue(IOCTL_SERIAL_CLEAR_STATS),
    SeedIoctlValue(IOCTL_SERIAL_CLR_DTR),
    SeedIoctlValue(IOCTL_SERIAL_CLR_RTS),
    SeedIoctlValue(IOCTL_SERIAL_CONFIG_SIZE),
    SeedIoctlValue(IOCTL_SERIAL_GET_BAUD_RATE),
    SeedIoctlValue(IOCTL_SERIAL_GET_CHARS),
    SeedIoctlValue(IOCTL_SERIAL_GET_COMMCONFIG),
    SeedIoctlValue(IOCTL_SERIAL_GET_COMMSTATUS),
    SeedIoctlValue(IOCTL_SERIAL_GET_DTRRTS),
    SeedIoctlValue(IOCTL_SERIAL_GET_HANDFLOW),
    SeedIoctlValue(IOCTL_SERIAL_GET_LINE_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_GET_MODEM_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_GET_MODEMSTATUS),
    SeedIoctlValue(IOCTL_SERIAL_GET_PROPERTIES),
    SeedIoctlValue(IOCTL_SERIAL_GET_STATS),
    SeedIoctlValue(IOCTL_SERIAL_GET_TIMEOUTS),
    SeedIoctlValue(IOCTL_SERIAL_GET_WAIT_MASK),
    SeedIoctlValue(IOCTL_SERIAL_IMMEDIATE_CHAR),
    SeedIoctlValue(IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS),
    SeedIoctlValue(IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE),
    SeedIoctlValue(IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE),
    SeedIoctlValue(IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS),
    SeedIoctlValue(IOCTL_SERIAL_LSRMST_INS